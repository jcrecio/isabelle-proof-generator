{"file_name": "/home/qj213/afp-2021-10-22/thys/Count_Complex_Roots/Extended_Sturm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Count_Complex_Roots", "problem_names": ["lemma is_unit_pCons_ex_iff:\n  fixes p::\"'a::field poly\"\n  shows \"is_unit p \\<longleftrightarrow> (\\<exists>a. a\\<noteq>0 \\<and> p=[:a:])\"", "lemma poly_gcd_iff: \n  \"poly (gcd p q) x=0 \\<longleftrightarrow> poly p x=0 \\<and> poly q x=0 \"", "lemma eventually_poly_nz_at_within:\n  fixes x :: \"'a::{idom,euclidean_space} \"\n  assumes \"p\\<noteq>0\" \n  shows \"eventually (\\<lambda>x. poly p x\\<noteq>0) (at x within S)\"", "lemma sgn_power:\n  fixes x::\"'a::linordered_idom\"\n  shows \"sgn (x^n) = (if n=0 then 1 else if even n then \\<bar>sgn x\\<bar> else sgn x)\"", "lemma poly_divide_filterlim_at_top: \n  fixes p q::\"real poly\"\n  defines \"ll\\<equiv>( if degree q<degree p then \n                    at 0 \n                else if degree q=degree p then \n                    nhds (lead_coeff q / lead_coeff p)\n                else if sgn_pos_inf q * sgn_pos_inf p > 0 then \n                    at_top\n                else \n                    at_bot)\"\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"filterlim (\\<lambda>x. poly q x / poly p x) ll at_top\"", "lemma poly_divide_filterlim_at_bot: \n  fixes p q::\"real poly\"\n  defines \"ll\\<equiv>( if degree q<degree p then \n                    at 0 \n                else if degree q=degree p then \n                    nhds (lead_coeff q / lead_coeff p)\n                else if sgn_neg_inf q * sgn_neg_inf p > 0 then \n                    at_top\n                else \n                    at_bot)\"\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"filterlim (\\<lambda>x. poly q x / poly p x) ll at_bot\"", "lemma cross_alt_coprime_0:\n  assumes \"coprime p q\" \"p=0\\<or>q=0\"\n  shows \"cross_alt p q a b=0\"", "lemma cross_alt_0[simp]: \"cross_alt 0 0 a b=0\"", "lemma cross_alt_poly_commute:\n  \"cross_alt p q a b = cross_alt q p a b\"", "lemma cross_alt_clear_n:\n  assumes \"coprime p q\"\n  shows \"cross_alt p q a b = cross_alt 1 (p*q) a b\"", "lemma changes_alt_itv_smods_rec:\n  assumes \"a<b\" \"coprime p q\" \n  shows \"changes_alt_itv_smods a b p q  = cross_alt p q a b + changes_alt_itv_smods a b q (-(p mod q))\"", "lemma jumpF_polyR_0[simp]: \"jumpF_polyR 0 p a = 0\" \"jumpF_polyR q 0 a = 0\"", "lemma jumpF_polyL_0[simp]: \"jumpF_polyL 0 p a = 0\" \"jumpF_polyL q 0 a = 0\"", "lemma jumpF_polyR_mult_cancel:\n  assumes \"p'\\<noteq>0\"\n  shows \"jumpF_polyR (p' * q) (p' * p) a = jumpF_polyR q p a\"", "lemma jumpF_polyL_mult_cancel:\n  assumes \"p'\\<noteq>0\"\n  shows \"jumpF_polyL (p' * q) (p' * p) a = jumpF_polyL q p a\"", "lemma jumpF_poly_noroot: \n  assumes \"poly p a\\<noteq>0\"\n  shows \"jumpF_polyL q p a = 0\" \"jumpF_polyR q p a = 0\"", "lemma jumpF_polyR_coprime:\n  assumes \"coprime p q\"\n  shows \"jumpF_polyR q p x = (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x=0 then \n                                if sign_r_pos p x \\<longleftrightarrow> poly q x>0 then 1/2 else - 1/2 else 0)\"", "lemma jumpF_polyL_coprime:\n  assumes \"coprime p q\"\n  shows \"jumpF_polyL q p x = (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x=0 then \n                if even (order x p) \\<longleftrightarrow> sign_r_pos p x \\<longleftrightarrow> poly q x>0 then 1/2 else - 1/2 else 0)\"", "lemma jumpF_times:\n  assumes tendsto:\"(f \\<longlongrightarrow> c) F\" and \"c\\<noteq>0\" \"F\\<noteq>bot\"\n  shows \"jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\"", "lemma jumpF_polyR_inverse_add:\n  assumes \"coprime p q\"\n  shows \"jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q*p) x\"", "lemma jumpF_polyL_inverse_add:\n  assumes \"coprime p q\"\n  shows \"jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q*p) x\"", "lemma jumpF_polyL_smult_1:\n  \"jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x\"", "lemma jumpF_polyR_smult_1:\n  \"jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x\"", "lemma\n  shows jumpF_polyR_mod:\"jumpF_polyR q p x = jumpF_polyR (q mod p) p x\" and\n        jumpF_polyL_mod:\"jumpF_polyL q p x = jumpF_polyL (q mod p) p x\"", "lemma jumpF_poly_top_0[simp]: \"jumpF_poly_top 0 p = 0\" \"jumpF_poly_top q 0 = 0\"", "lemma jumpF_poly_bot_0[simp]: \"jumpF_poly_bot 0 p = 0\" \"jumpF_poly_bot q 0 = 0\"", "lemma jumpF_poly_top_code:\n  \"jumpF_poly_top q p = (if p\\<noteq>0 \\<and> q\\<noteq>0 \\<and> degree q>degree p then \n          if sgn_pos_inf q * sgn_pos_inf p > 0 then 1/2 else -1/2 else 0)\"", "lemma jumpF_poly_bot_code:\n  \"jumpF_poly_bot q p = (if p\\<noteq>0 \\<and> q\\<noteq>0 \\<and> degree q>degree p then \n          if sgn_neg_inf q * sgn_neg_inf p > 0 then 1/2 else -1/2 else 0)\"", "lemma cindex_polyE_0[simp]: \"cindex_polyE a b 0 p = 0\" \"cindex_polyE a b q 0 = 0\"", "lemma cindex_polyE_mult_cancel:\n  fixes p q p'::\"real poly\"\n  assumes \"p'\\<noteq> 0\"  \n  shows \"cindex_polyE a b (p' * q ) (p' * p) = cindex_polyE a b q p\"", "lemma cindexE_eq_cindex_polyE: \n  assumes \"a<b\"\n  shows \"cindexE a b (\\<lambda>x. poly q x/poly p x) = cindex_polyE a b q p\"", "lemma cindex_polyE_cross:\n  fixes p::\"real poly\" and a b::real\n  assumes \"a<b\" \n  shows \"cindex_polyE a b 1 p = cross_alt 1 p a b / 2\"", "lemma cindex_polyE_inverse_add:\n  fixes p q::\"real poly\" \n  assumes cp:\"coprime p q\"\n  shows \"cindex_polyE a b q p + cindex_polyE a b p q=cindex_polyE a b 1 (q*p)\"", "lemma cindex_polyE_inverse_add_cross:\n  fixes p q::\"real poly\"\n  assumes \"a < b\" \"coprime p q\" \n  shows \"cindex_polyE a b q p  + cindex_polyE a b p q = cross_alt p q a b / 2\"", "lemma cindex_polyE_smult_1: \n  fixes p q::\"real poly\" and c::real\n  shows \"cindex_polyE a b (smult c q) p =  (sgn c) * cindex_polyE a b q p\"", "lemma cindex_polyE_mod:\n  fixes p q::\"real poly\" \n  shows \"cindex_polyE a b q p =  cindex_polyE a b (q mod p) p\"", "lemma cindex_polyE_rec:\n  fixes p q::\"real poly\"\n  assumes \"a < b\" \"coprime p q\"\n  shows \"cindex_polyE a b q p  = cross_alt q p a b/2  +  cindex_polyE a b (- (p mod q)) q\"", "lemma cindex_polyE_changes_alt_itv_mods: \n  assumes \"a<b\" \"coprime p q\"\n  shows \"cindex_polyE a b q p = changes_alt_itv_smods a b p q / 2\"", "lemma cindex_poly_ubd_eventually:\n  shows \"\\<forall>\\<^sub>F r in at_top. cindexE (-r) r (\\<lambda>x. poly q x/poly p x) = of_int (cindex_poly_ubd q p)\"", "lemma cindex_poly_ubd_0:\n  assumes \"p=0 \\<or> q=0\"\n  shows \"cindex_poly_ubd q p = 0\"", "lemma cindex_poly_ubd_code:\n  shows \"cindex_poly_ubd q p = changes_R_smods p q\"", "lemma cindexE_ubd_poly: \"cindexE_ubd (\\<lambda>x. poly q x/poly p x) = cindex_poly_ubd q p\""], "translations": [["", "lemma is_unit_pCons_ex_iff:\n  fixes p::\"'a::field poly\"\n  shows \"is_unit p \\<longleftrightarrow> (\\<exists>a. a\\<noteq>0 \\<and> p=[:a:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit p = (\\<exists>a. a \\<noteq> (0::'a) \\<and> p = [:a:])", "using is_unit_poly_iff is_unit_triv"], ["proof (prove)\nusing this:\n  (?p dvd 1) = (\\<exists>c. ?p = [:c:] \\<and> c dvd (1::?'a))\n  ?a \\<noteq> (0::?'a) \\<Longrightarrow> is_unit [:?a:]\n\ngoal (1 subgoal):\n 1. is_unit p = (\\<exists>a. a \\<noteq> (0::'a) \\<and> p = [:a:])", "by auto"], ["", "lemma poly_gcd_iff: \n  \"poly (gcd p q) x=0 \\<longleftrightarrow> poly p x=0 \\<and> poly q x=0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (gcd p q) x = (0::'a)) =\n    (poly p x = (0::'a) \\<and> poly q x = (0::'a))", "by (simp add: poly_eq_0_iff_dvd)"], ["", "lemma eventually_poly_nz_at_within:\n  fixes x :: \"'a::{idom,euclidean_space} \"\n  assumes \"p\\<noteq>0\" \n  shows \"eventually (\\<lambda>x. poly p x\\<noteq>0) (at x within S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)", "have \"eventually (\\<lambda>x. poly p x\\<noteq>0) (at x within S) \n      = (\\<forall>\\<^sub>F x in (at x within S). \\<forall>y\\<in>proots p. x \\<noteq> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)) =\n    (\\<forall>\\<^sub>F x in at x within S.\n        \\<forall>y\\<in>proots p. x \\<noteq> y)", "apply (rule eventually_subst,rule eventuallyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (poly p x \\<noteq> (0::'a)) = (\\<forall>y\\<in>proots p. x \\<noteq> y)", "by (auto simp add:proots_def)"], ["proof (state)\nthis:\n  (\\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)) =\n  (\\<forall>\\<^sub>F x in at x within S.\n      \\<forall>y\\<in>proots p. x \\<noteq> y)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)) =\n  (\\<forall>\\<^sub>F x in at x within S.\n      \\<forall>y\\<in>proots p. x \\<noteq> y)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)", "have \"... = (\\<forall>y\\<in>proots p. \\<forall>\\<^sub>F x in (at x within S). x \\<noteq> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at x within S.\n        \\<forall>y\\<in>proots p. x \\<noteq> y) =\n    (\\<forall>y\\<in>proots p.\n        \\<forall>\\<^sub>F x in at x within S. x \\<noteq> y)", "apply (subst eventually_ball_finite_distrib)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (proots p)\n 2. (\\<forall>y\\<in>proots p.\n        \\<forall>\\<^sub>F x in at x within S. x \\<noteq> y) =\n    (\\<forall>y\\<in>proots p.\n        \\<forall>\\<^sub>F x in at x within S. x \\<noteq> y)", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. finite (proots p)\n 2. (\\<forall>y\\<in>proots p.\n        \\<forall>\\<^sub>F x in at x within S. x \\<noteq> y) =\n    (\\<forall>y\\<in>proots p.\n        \\<forall>\\<^sub>F x in at x within S. x \\<noteq> y)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>\\<^sub>F x in at x within S.\n      \\<forall>y\\<in>proots p. x \\<noteq> y) =\n  (\\<forall>y\\<in>proots p.\n      \\<forall>\\<^sub>F x in at x within S. x \\<noteq> y)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<forall>\\<^sub>F x in at x within S.\n      \\<forall>y\\<in>proots p. x \\<noteq> y) =\n  (\\<forall>y\\<in>proots p.\n      \\<forall>\\<^sub>F x in at x within S. x \\<noteq> y)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>proots p.\n       \\<forall>\\<^sub>F x in at x within S. x \\<noteq> y", "unfolding eventually_at"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>proots p.\n       \\<exists>d>0.\n          \\<forall>xa\\<in>S.\n             xa \\<noteq> x \\<and> dist xa x < d \\<longrightarrow>\n             xa \\<noteq> y", "by (metis gt_ex not_less_iff_gr_or_eq zero_less_dist_iff)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>proots p.\n     \\<forall>\\<^sub>F x in at x within S. x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)", "finally"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x within S. poly p x \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sgn_power:\n  fixes x::\"'a::linordered_idom\"\n  shows \"sgn (x^n) = (if n=0 then 1 else if even n then \\<bar>sgn x\\<bar> else sgn x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (x ^ n) =\n    (if n = 0 then 1::'a else if even n then \\<bar>sgn x\\<bar> else sgn x)", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sgn (x ^ 0) =\n    (if 0 = 0 then 1::'a else if even 0 then \\<bar>sgn x\\<bar> else sgn x)\n 2. \\<And>n.\n       sgn (x ^ n) =\n       (if n = 0 then 1::'a\n        else if even n then \\<bar>sgn x\\<bar> else sgn x) \\<Longrightarrow>\n       sgn (x ^ Suc n) =\n       (if Suc n = 0 then 1::'a\n        else if even (Suc n) then \\<bar>sgn x\\<bar> else sgn x)", "by (auto simp add:sgn_mult)"], ["", "lemma poly_divide_filterlim_at_top: \n  fixes p q::\"real poly\"\n  defines \"ll\\<equiv>( if degree q<degree p then \n                    at 0 \n                else if degree q=degree p then \n                    nhds (lead_coeff q / lead_coeff p)\n                else if sgn_pos_inf q * sgn_pos_inf p > 0 then \n                    at_top\n                else \n                    at_bot)\"\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"filterlim (\\<lambda>x. poly q x / poly p x) ll at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "define pp where \"pp=(\\<lambda>x. poly p x / x^(degree p))\""], ["proof (state)\nthis:\n  pp = (\\<lambda>x. poly p x / x ^ degree p)\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "define qq where \"qq=(\\<lambda>x. poly q x / x^(degree q))\""], ["proof (state)\nthis:\n  qq = (\\<lambda>x. poly q x / x ^ degree q)\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "define dd where \"dd=(\\<lambda>x::real. if degree p>degree q then 1/x^(degree p - degree q) else \n                                x^(degree q - degree p))\""], ["proof (state)\nthis:\n  dd =\n  (\\<lambda>x.\n      if degree q < degree p then 1 / x ^ (degree p - degree q)\n      else x ^ (degree q - degree p))\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "have divide_cong:\"\\<forall>\\<^sub>Fx in at_top. poly q x / poly p x = qq x / pp x * dd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. poly q x / poly p x = qq x / pp x * dd x", "proof (rule eventually_at_top_linorderI[of 1])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow> poly q x / poly p x = qq x / pp x * dd x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow> poly q x / poly p x = qq x / pp x * dd x", "assume \"(x::real)\\<ge>1\""], ["proof (state)\nthis:\n  1 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow> poly q x / poly p x = qq x / pp x * dd x", "then"], ["proof (chain)\npicking this:\n  1 \\<le> x", "have \"x\\<noteq>0\""], ["proof (prove)\nusing this:\n  1 \\<le> x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow> poly q x / poly p x = qq x / pp x * dd x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "show \"poly q x / poly p x = qq x / pp x * dd x\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x / poly p x = qq x / pp x * dd x", "unfolding qq_def pp_def dd_def"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x / poly p x =\n    poly q x / x ^ degree q / (poly p x / x ^ degree p) *\n    (if degree q < degree p then 1 / x ^ (degree p - degree q)\n     else x ^ (degree q - degree p))", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  ll \\<equiv>\n  if degree q < degree p then at 0\n  else if degree q = degree p then nhds (lead_coeff q / lead_coeff p)\n       else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top else at_bot\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x / poly p x =\n    poly q x / x ^ degree q / (poly p x / x ^ degree p) *\n    (if degree q < degree p then 1 / x ^ (degree p - degree q)\n     else x ^ (degree q - degree p))", "by (auto simp add:field_simps power_diff)"], ["proof (state)\nthis:\n  poly q x / poly p x = qq x / pp x * dd x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. poly q x / poly p x = qq x / pp x * dd x\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "have qqpp_tendsto:\"((\\<lambda>x. qq x / pp x) \\<longlongrightarrow> lead_coeff q / lead_coeff p) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "have \"(qq \\<longlongrightarrow> lead_coeff q) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qq \\<longlongrightarrow> lead_coeff q) at_top", "unfolding qq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / x ^ degree q) \\<longlongrightarrow>\n     lead_coeff q)\n     at_top", "using poly_divide_tendsto_aux[of q]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / x ^ degree q) \\<longlongrightarrow> lead_coeff q)\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / x ^ degree q) \\<longlongrightarrow>\n     lead_coeff q)\n     at_top", "by (auto elim!:filterlim_mono simp:at_top_le_at_infinity)"], ["proof (state)\nthis:\n  (qq \\<longlongrightarrow> lead_coeff q) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "moreover"], ["proof (state)\nthis:\n  (qq \\<longlongrightarrow> lead_coeff q) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "have \"(pp \\<longlongrightarrow> lead_coeff p) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pp \\<longlongrightarrow> lead_coeff p) at_top", "unfolding pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n     lead_coeff p)\n     at_top", "using poly_divide_tendsto_aux[of p]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow> lead_coeff p)\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n     lead_coeff p)\n     at_top", "by (auto elim!:filterlim_mono simp:at_top_le_at_infinity)"], ["proof (state)\nthis:\n  (pp \\<longlongrightarrow> lead_coeff p) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  (qq \\<longlongrightarrow> lead_coeff q) at_top\n  (pp \\<longlongrightarrow> lead_coeff p) at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  (qq \\<longlongrightarrow> lead_coeff q) at_top\n  (pp \\<longlongrightarrow> lead_coeff p) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (qq \\<longlongrightarrow> lead_coeff q) at_top\n  (pp \\<longlongrightarrow> lead_coeff p) at_top\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "by (auto intro!:tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "have ?thesis when \"degree q<degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "have \"filterlim (\\<lambda>x. poly q x / poly p x) (at 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> at 0", "proof (rule filterlim_atI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_top\n 2. \\<forall>\\<^sub>F x in at_top. poly q x / poly p x \\<noteq> 0", "show \"((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_top", "using poly_divide_tendsto_0_at_infinity[OF that]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_top", "by (auto elim:filterlim_mono simp:at_top_le_at_infinity)"], ["proof (state)\nthis:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. poly q x / poly p x \\<noteq> 0", "have \"\\<forall>\\<^sub>F x in at_top. poly q x \\<noteq>0\" \"\\<forall>\\<^sub>F x in at_top. poly p x \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. poly q x \\<noteq> 0 &&&\n    \\<forall>\\<^sub>F x in at_top. poly p x \\<noteq> 0", "using poly_eventually_not_zero[OF \\<open>q\\<noteq>0\\<close>] poly_eventually_not_zero[OF \\<open>p\\<noteq>0\\<close>]\n              filter_leD[OF at_top_le_at_infinity]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_infinity. poly q x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at_infinity. poly p x \\<noteq> 0\n  eventually ?P at_infinity \\<Longrightarrow> eventually ?P at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. poly q x \\<noteq> 0 &&&\n    \\<forall>\\<^sub>F x in at_top. poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. poly q x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at_top. poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. poly q x / poly p x \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top. poly q x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at_top. poly p x \\<noteq> 0", "show \"\\<forall>\\<^sub>F x in at_top. poly q x / poly p x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. poly q x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at_top. poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. poly q x / poly p x \\<noteq> 0", "apply eventually_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>poly q x \\<noteq> 0; poly p x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> poly q x / poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. poly q x / poly p x \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at_top. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  LIM x at_top. poly q x / poly p x :> at 0", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "unfolding ll_def"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. LIM x at_top.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top\n                       else at_bot", "using that"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at 0\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. LIM x at_top.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top\n                       else at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_top. poly q x / poly p x :> ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree q < degree p \\<Longrightarrow>\n  LIM x at_top. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "moreover"], ["proof (state)\nthis:\n  degree q < degree p \\<Longrightarrow>\n  LIM x at_top. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "have ?thesis when \"degree q=degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "have \"((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> lead_coeff q / lead_coeff p) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "using divide_cong qqpp_tendsto that"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. poly q x / poly p x = qq x / pp x * dd x\n  ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top\n  degree q = degree p\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "unfolding dd_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top.\n     poly q x / poly p x =\n     qq x / pp x *\n     (if degree q < degree p then 1 / x ^ (degree p - degree q)\n      else x ^ (degree q - degree p))\n  ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top\n  degree q = degree p\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "by (auto dest:tendsto_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "unfolding ll_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top\n\ngoal (1 subgoal):\n 1. LIM x at_top.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top\n                       else at_bot", "using that"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top\n  degree q = degree p\n\ngoal (1 subgoal):\n 1. LIM x at_top.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top\n                       else at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_top. poly q x / poly p x :> ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree q = degree p \\<Longrightarrow>\n  LIM x at_top. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "moreover"], ["proof (state)\nthis:\n  degree q = degree p \\<Longrightarrow>\n  LIM x at_top. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "have ?thesis when \"degree q>degree p\" \"sgn_pos_inf q * sgn_pos_inf p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "have \"filterlim (\\<lambda>x. (qq x / pp x) * dd x) at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. qq x / pp x * dd x :> at_top", "proof (subst filterlim_tendsto_pos_mult_at_top_iff[OF qqpp_tendsto])"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < lead_coeff q / lead_coeff p\n 2. filterlim dd at_top at_top", "show \"0 < lead_coeff q / lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lead_coeff q / lead_coeff p", "using that(2)"], ["proof (prove)\nusing this:\n  0 < sgn_pos_inf q * sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff q / lead_coeff p", "unfolding sgn_pos_inf_def"], ["proof (prove)\nusing this:\n  0 < sgn (lead_coeff q) * sgn (lead_coeff p)\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff q / lead_coeff p", "by (simp add: zero_less_divide_iff zero_less_mult_iff)"], ["proof (state)\nthis:\n  0 < lead_coeff q / lead_coeff p\n\ngoal (1 subgoal):\n 1. filterlim dd at_top at_top", "show \"filterlim dd at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim dd at_top at_top", "unfolding dd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_top", "using that(1)"], ["proof (prove)\nusing this:\n  degree p < degree q\n\ngoal (1 subgoal):\n 1. LIM x at_top.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_top", "by (auto intro!:filterlim_pow_at_top simp:filterlim_ident)"], ["proof (state)\nthis:\n  filterlim dd at_top at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at_top. qq x / pp x * dd x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  LIM x at_top. qq x / pp x * dd x :> at_top", "have \"LIM x at_top. poly q x / poly p x :> at_top\""], ["proof (prove)\nusing this:\n  LIM x at_top. qq x / pp x * dd x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> at_top", "using filterlim_cong[OF _ _ divide_cong]"], ["proof (prove)\nusing this:\n  LIM x at_top. qq x / pp x * dd x :> at_top\n  \\<lbrakk>?F1.0 = ?F1'; at_top = ?F2'\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_top. poly q x / poly p x :> ?F1.0) =\n                    (LIM x ?F2'. qq x / pp x * dd x :> ?F1')\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> at_top", "by blast"], ["proof (state)\nthis:\n  LIM x at_top. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  LIM x at_top. poly q x / poly p x :> at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "unfolding ll_def"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_top.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top\n                       else at_bot", "using that"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at_top\n  degree p < degree q\n  0 < sgn_pos_inf q * sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. LIM x at_top.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top\n                       else at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_top. poly q x / poly p x :> ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>degree p < degree q; 0 < sgn_pos_inf q * sgn_pos_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_top. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>degree p < degree q; 0 < sgn_pos_inf q * sgn_pos_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_top. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "have ?thesis  when \"degree q>degree p\" \"\\<not> sgn_pos_inf q * sgn_pos_inf p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "have \"filterlim (\\<lambda>x. (qq x / pp x) * dd x) at_bot at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. qq x / pp x * dd x :> at_bot", "proof (subst filterlim_tendsto_neg_mult_at_bot_iff[OF qqpp_tendsto])"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_coeff q / lead_coeff p < 0\n 2. filterlim dd at_top at_top", "show \"lead_coeff q / lead_coeff p < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff q / lead_coeff p < 0", "using that(2) \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 0 < sgn_pos_inf q * sgn_pos_inf p\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff q / lead_coeff p < 0", "unfolding sgn_pos_inf_def"], ["proof (prove)\nusing this:\n  \\<not> 0 < sgn (lead_coeff q) * sgn (lead_coeff p)\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff q / lead_coeff p < 0", "by (metis divide_eq_0_iff divide_sgn leading_coeff_0_iff \n            linorder_neqE_linordered_idom sgn_divide sgn_greater)"], ["proof (state)\nthis:\n  lead_coeff q / lead_coeff p < 0\n\ngoal (1 subgoal):\n 1. filterlim dd at_top at_top", "show \"filterlim dd at_top at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim dd at_top at_top", "unfolding dd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_top", "using that(1)"], ["proof (prove)\nusing this:\n  degree p < degree q\n\ngoal (1 subgoal):\n 1. LIM x at_top.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_top", "by (auto intro!:filterlim_pow_at_top simp:filterlim_ident)"], ["proof (state)\nthis:\n  filterlim dd at_top at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at_top. qq x / pp x * dd x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  LIM x at_top. qq x / pp x * dd x :> at_bot", "have \"LIM x at_top. poly q x / poly p x :> at_bot\""], ["proof (prove)\nusing this:\n  LIM x at_top. qq x / pp x * dd x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> at_bot", "using filterlim_cong[OF _ _ divide_cong]"], ["proof (prove)\nusing this:\n  LIM x at_top. qq x / pp x * dd x :> at_bot\n  \\<lbrakk>?F1.0 = ?F1'; at_top = ?F2'\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_top. poly q x / poly p x :> ?F1.0) =\n                    (LIM x ?F2'. qq x / pp x * dd x :> ?F1')\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> at_bot", "by blast"], ["proof (state)\nthis:\n  LIM x at_top. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  LIM x at_top. poly q x / poly p x :> at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "unfolding ll_def"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_top.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top\n                       else at_bot", "using that"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at_bot\n  degree p < degree q\n  \\<not> 0 < sgn_pos_inf q * sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. LIM x at_top.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top\n                       else at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_top. poly q x / poly p x :> ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>degree p < degree q;\n   \\<not> 0 < sgn_pos_inf q * sgn_pos_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_top. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "ultimately"], ["proof (chain)\npicking this:\n  degree q < degree p \\<Longrightarrow>\n  LIM x at_top. poly q x / poly p x :> ll\n  degree q = degree p \\<Longrightarrow>\n  LIM x at_top. poly q x / poly p x :> ll\n  \\<lbrakk>degree p < degree q; 0 < sgn_pos_inf q * sgn_pos_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_top. poly q x / poly p x :> ll\n  \\<lbrakk>degree p < degree q;\n   \\<not> 0 < sgn_pos_inf q * sgn_pos_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_top. poly q x / poly p x :> ll", "show ?thesis"], ["proof (prove)\nusing this:\n  degree q < degree p \\<Longrightarrow>\n  LIM x at_top. poly q x / poly p x :> ll\n  degree q = degree p \\<Longrightarrow>\n  LIM x at_top. poly q x / poly p x :> ll\n  \\<lbrakk>degree p < degree q; 0 < sgn_pos_inf q * sgn_pos_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_top. poly q x / poly p x :> ll\n  \\<lbrakk>degree p < degree q;\n   \\<not> 0 < sgn_pos_inf q * sgn_pos_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_top. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> ll", "by linarith"], ["proof (state)\nthis:\n  LIM x at_top. poly q x / poly p x :> ll\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_divide_filterlim_at_bot: \n  fixes p q::\"real poly\"\n  defines \"ll\\<equiv>( if degree q<degree p then \n                    at 0 \n                else if degree q=degree p then \n                    nhds (lead_coeff q / lead_coeff p)\n                else if sgn_neg_inf q * sgn_neg_inf p > 0 then \n                    at_top\n                else \n                    at_bot)\"\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"filterlim (\\<lambda>x. poly q x / poly p x) ll at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "define pp where \"pp=(\\<lambda>x. poly p x / x^(degree p))\""], ["proof (state)\nthis:\n  pp = (\\<lambda>x. poly p x / x ^ degree p)\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "define qq where \"qq=(\\<lambda>x. poly q x / x^(degree q))\""], ["proof (state)\nthis:\n  qq = (\\<lambda>x. poly q x / x ^ degree q)\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "define dd where \"dd=(\\<lambda>x::real. if degree p>degree q then 1/x^(degree p - degree q) else \n                                x^(degree q - degree p))\""], ["proof (state)\nthis:\n  dd =\n  (\\<lambda>x.\n      if degree q < degree p then 1 / x ^ (degree p - degree q)\n      else x ^ (degree q - degree p))\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have divide_cong:\"\\<forall>\\<^sub>Fx in at_bot. poly q x / poly p x = qq x / pp x * dd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot. poly q x / poly p x = qq x / pp x * dd x", "proof (rule eventually_at_bot_linorderI[of \"-1\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<le> - 1 \\<Longrightarrow>\n       poly q x / poly p x = qq x / pp x * dd x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<le> - 1 \\<Longrightarrow>\n       poly q x / poly p x = qq x / pp x * dd x", "assume \"(x::real)\\<le>-1\""], ["proof (state)\nthis:\n  x \\<le> - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<le> - 1 \\<Longrightarrow>\n       poly q x / poly p x = qq x / pp x * dd x", "then"], ["proof (chain)\npicking this:\n  x \\<le> - 1", "have \"x\\<noteq>0\""], ["proof (prove)\nusing this:\n  x \\<le> - 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<le> - 1 \\<Longrightarrow>\n       poly q x / poly p x = qq x / pp x * dd x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "show \"poly q x / poly p x = qq x / pp x * dd x\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x / poly p x = qq x / pp x * dd x", "unfolding qq_def pp_def dd_def"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x / poly p x =\n    poly q x / x ^ degree q / (poly p x / x ^ degree p) *\n    (if degree q < degree p then 1 / x ^ (degree p - degree q)\n     else x ^ (degree q - degree p))", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  ll \\<equiv>\n  if degree q < degree p then at 0\n  else if degree q = degree p then nhds (lead_coeff q / lead_coeff p)\n       else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top else at_bot\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x / poly p x =\n    poly q x / x ^ degree q / (poly p x / x ^ degree p) *\n    (if degree q < degree p then 1 / x ^ (degree p - degree q)\n     else x ^ (degree q - degree p))", "by (auto simp add:field_simps power_diff)"], ["proof (state)\nthis:\n  poly q x / poly p x = qq x / pp x * dd x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_bot. poly q x / poly p x = qq x / pp x * dd x\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have qqpp_tendsto:\"((\\<lambda>x. qq x / pp x) \\<longlongrightarrow> lead_coeff q / lead_coeff p) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "have \"(qq \\<longlongrightarrow> lead_coeff q) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (qq \\<longlongrightarrow> lead_coeff q) at_bot", "unfolding qq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / x ^ degree q) \\<longlongrightarrow>\n     lead_coeff q)\n     at_bot", "using poly_divide_tendsto_aux[of q]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / x ^ degree q) \\<longlongrightarrow> lead_coeff q)\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / x ^ degree q) \\<longlongrightarrow>\n     lead_coeff q)\n     at_bot", "by (auto elim!:filterlim_mono simp:at_bot_le_at_infinity)"], ["proof (state)\nthis:\n  (qq \\<longlongrightarrow> lead_coeff q) at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "moreover"], ["proof (state)\nthis:\n  (qq \\<longlongrightarrow> lead_coeff q) at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "have \"(pp \\<longlongrightarrow> lead_coeff p) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pp \\<longlongrightarrow> lead_coeff p) at_bot", "unfolding pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n     lead_coeff p)\n     at_bot", "using poly_divide_tendsto_aux[of p]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow> lead_coeff p)\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly p x / x ^ degree p) \\<longlongrightarrow>\n     lead_coeff p)\n     at_bot", "by (auto elim!:filterlim_mono simp:at_bot_le_at_infinity)"], ["proof (state)\nthis:\n  (pp \\<longlongrightarrow> lead_coeff p) at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "ultimately"], ["proof (chain)\npicking this:\n  (qq \\<longlongrightarrow> lead_coeff q) at_bot\n  (pp \\<longlongrightarrow> lead_coeff p) at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  (qq \\<longlongrightarrow> lead_coeff q) at_bot\n  (pp \\<longlongrightarrow> lead_coeff p) at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  (qq \\<longlongrightarrow> lead_coeff q) at_bot\n  (pp \\<longlongrightarrow> lead_coeff p) at_bot\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "by (auto intro!:tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have ?thesis when \"degree q<degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have \"filterlim (\\<lambda>x. poly q x / poly p x) (at 0) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> at 0", "proof (rule filterlim_atI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_bot\n 2. \\<forall>\\<^sub>F x in at_bot. poly q x / poly p x \\<noteq> 0", "show \"((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_bot", "using poly_divide_tendsto_0_at_infinity[OF that]"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_bot", "by (auto elim:filterlim_mono simp:at_bot_le_at_infinity)"], ["proof (state)\nthis:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> 0) at_bot\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot. poly q x / poly p x \\<noteq> 0", "have \"\\<forall>\\<^sub>F x in at_bot. poly q x \\<noteq>0\" \"\\<forall>\\<^sub>F x in at_bot. poly p x \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot. poly q x \\<noteq> 0 &&&\n    \\<forall>\\<^sub>F x in at_bot. poly p x \\<noteq> 0", "using poly_eventually_not_zero[OF \\<open>q\\<noteq>0\\<close>] poly_eventually_not_zero[OF \\<open>p\\<noteq>0\\<close>]\n              filter_leD[OF at_bot_le_at_infinity]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_infinity. poly q x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at_infinity. poly p x \\<noteq> 0\n  eventually ?P at_infinity \\<Longrightarrow> eventually ?P at_bot\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot. poly q x \\<noteq> 0 &&&\n    \\<forall>\\<^sub>F x in at_bot. poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_bot. poly q x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at_bot. poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot. poly q x / poly p x \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_bot. poly q x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at_bot. poly p x \\<noteq> 0", "show \"\\<forall>\\<^sub>F x in at_bot. poly q x / poly p x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_bot. poly q x \\<noteq> 0\n  \\<forall>\\<^sub>F x in at_bot. poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot. poly q x / poly p x \\<noteq> 0", "by eventually_elim auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_bot. poly q x / poly p x \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LIM x at_bot. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  LIM x at_bot. poly q x / poly p x :> at 0", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "unfolding ll_def"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top\n                       else at_bot", "using that"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at 0\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top\n                       else at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_bot. poly q x / poly p x :> ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree q < degree p \\<Longrightarrow>\n  LIM x at_bot. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "moreover"], ["proof (state)\nthis:\n  degree q < degree p \\<Longrightarrow>\n  LIM x at_bot. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have ?thesis when \"degree q=degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have \"((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> lead_coeff q / lead_coeff p) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "using divide_cong qqpp_tendsto that"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_bot. poly q x / poly p x = qq x / pp x * dd x\n  ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot\n  degree q = degree p\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "unfolding dd_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_bot.\n     poly q x / poly p x =\n     qq x / pp x *\n     (if degree q < degree p then 1 / x ^ (degree p - degree q)\n      else x ^ (degree q - degree p))\n  ((\\<lambda>x. qq x / pp x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot\n  degree q = degree p\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "by (auto dest:tendsto_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "unfolding ll_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top\n                       else at_bot", "using that"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot\n  degree q = degree p\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top\n                       else at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_bot. poly q x / poly p x :> ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree q = degree p \\<Longrightarrow>\n  LIM x at_bot. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "moreover"], ["proof (state)\nthis:\n  degree q = degree p \\<Longrightarrow>\n  LIM x at_bot. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have ?thesis when \"degree q>degree p\" \"sgn_neg_inf q * sgn_neg_inf p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "define cc where \"cc=lead_coeff q / lead_coeff p\""], ["proof (state)\nthis:\n  cc = lead_coeff q / lead_coeff p\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have \"(cc > 0 \\<and> even (degree q - degree p)) \\<or> (cc<0 \\<and> odd (degree q - degree p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < cc \\<and> even (degree q - degree p) \\<or>\n    cc < 0 \\<and> odd (degree q - degree p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < cc \\<and> even (degree q - degree p) \\<or>\n    cc < 0 \\<and> odd (degree q - degree p)", "have \"even (degree q - degree p) \\<longleftrightarrow> \n            (even (degree q) \\<and> even (degree p)) \\<or> (odd (degree q) \\<and> odd (degree p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree q - degree p) =\n    (even (degree q) \\<and> even (degree p) \\<or>\n     odd (degree q) \\<and> odd (degree p))", "using \\<open>degree q>degree p\\<close>"], ["proof (prove)\nusing this:\n  degree p < degree q\n\ngoal (1 subgoal):\n 1. even (degree q - degree p) =\n    (even (degree q) \\<and> even (degree p) \\<or>\n     odd (degree q) \\<and> odd (degree p))", "by auto"], ["proof (state)\nthis:\n  even (degree q - degree p) =\n  (even (degree q) \\<and> even (degree p) \\<or>\n   odd (degree q) \\<and> odd (degree p))\n\ngoal (1 subgoal):\n 1. 0 < cc \\<and> even (degree q - degree p) \\<or>\n    cc < 0 \\<and> odd (degree q - degree p)", "then"], ["proof (chain)\npicking this:\n  even (degree q - degree p) =\n  (even (degree q) \\<and> even (degree p) \\<or>\n   odd (degree q) \\<and> odd (degree p))", "show ?thesis"], ["proof (prove)\nusing this:\n  even (degree q - degree p) =\n  (even (degree q) \\<and> even (degree p) \\<or>\n   odd (degree q) \\<and> odd (degree p))\n\ngoal (1 subgoal):\n 1. 0 < cc \\<and> even (degree q - degree p) \\<or>\n    cc < 0 \\<and> odd (degree q - degree p)", "using that \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  even (degree q - degree p) =\n  (even (degree q) \\<and> even (degree p) \\<or>\n   odd (degree q) \\<and> odd (degree p))\n  degree p < degree q\n  0 < sgn_neg_inf q * sgn_neg_inf p\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < cc \\<and> even (degree q - degree p) \\<or>\n    cc < 0 \\<and> odd (degree q - degree p)", "unfolding sgn_neg_inf_def cc_def zero_less_mult_iff \n          divide_less_0_iff zero_less_divide_iff"], ["proof (prove)\nusing this:\n  even (degree q - degree p) =\n  (even (degree q) \\<and> even (degree p) \\<or>\n   odd (degree q) \\<and> odd (degree p))\n  degree p < degree q\n  0 < (if even (degree q) then sgn (lead_coeff q)\n       else - sgn (lead_coeff q)) \\<and>\n  0 < (if even (degree p) then sgn (lead_coeff p)\n       else - sgn (lead_coeff p)) \\<or>\n  (if even (degree q) then sgn (lead_coeff q) else - sgn (lead_coeff q))\n  < 0 \\<and>\n  (if even (degree p) then sgn (lead_coeff p) else - sgn (lead_coeff p)) < 0\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < lead_coeff q \\<and> 0 < lead_coeff p \\<or>\n     lead_coeff q < 0 \\<and> lead_coeff p < 0) \\<and>\n    even (degree q - degree p) \\<or>\n    (0 < lead_coeff q \\<and> lead_coeff p < 0 \\<or>\n     lead_coeff q < 0 \\<and> 0 < lead_coeff p) \\<and>\n    odd (degree q - degree p)", "apply (simp add:if_split[of \"(<) 0\"] if_split[of \"(>) 0\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(even (degree q) = even (degree p)) =\n             (even (degree q) \\<and> even (degree p) \\<or>\n              odd (degree q) \\<and> odd (degree p));\n     degree p < degree q;\n     (even (degree q) \\<longrightarrow> 0 < lead_coeff q) \\<and>\n     (odd (degree q) \\<longrightarrow> lead_coeff q < 0) \\<and>\n     (even (degree p) \\<longrightarrow> 0 < lead_coeff p) \\<and>\n     (odd (degree p) \\<longrightarrow> lead_coeff p < 0) \\<or>\n     (even (degree q) \\<longrightarrow> lead_coeff q < 0) \\<and>\n     (odd (degree q) \\<longrightarrow> 0 < lead_coeff q) \\<and>\n     (even (degree p) \\<longrightarrow> lead_coeff p < 0) \\<and>\n     (odd (degree p) \\<longrightarrow> 0 < lead_coeff p);\n     p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (0 < lead_coeff q \\<and> 0 < lead_coeff p \\<or>\n                       lead_coeff q < 0 \\<and> lead_coeff p < 0) \\<and>\n                      (even (degree q) \\<and> even (degree p) \\<or>\n                       odd (degree q) \\<and> odd (degree p)) \\<or>\n                      (0 < lead_coeff q \\<and> lead_coeff p < 0 \\<or>\n                       lead_coeff q < 0 \\<and> 0 < lead_coeff p) \\<and>\n                      (even (degree q) \\<longrightarrow>\n                       odd (degree p)) \\<and>\n                      (even (degree q) \\<or> even (degree p))", "by argo"], ["proof (state)\nthis:\n  0 < cc \\<and> even (degree q - degree p) \\<or>\n  cc < 0 \\<and> odd (degree q - degree p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < cc \\<and> even (degree q - degree p) \\<or>\n  cc < 0 \\<and> odd (degree q - degree p)\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "moreover"], ["proof (state)\nthis:\n  0 < cc \\<and> even (degree q - degree p) \\<or>\n  cc < 0 \\<and> odd (degree q - degree p)\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have \"filterlim (\\<lambda>x. (qq x / pp x) * dd x) at_top at_bot\"\n      when \"cc>0\" \"even (degree q - degree p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. qq x / pp x * dd x :> at_top", "proof (subst filterlim_tendsto_pos_mult_at_top_iff[OF qqpp_tendsto])"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < lead_coeff q / lead_coeff p\n 2. filterlim dd at_top at_bot", "show \"0 < lead_coeff q / lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lead_coeff q / lead_coeff p", "using \\<open>cc>0\\<close>"], ["proof (prove)\nusing this:\n  0 < cc\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff q / lead_coeff p", "unfolding cc_def"], ["proof (prove)\nusing this:\n  0 < lead_coeff q / lead_coeff p\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff q / lead_coeff p", "by auto"], ["proof (state)\nthis:\n  0 < lead_coeff q / lead_coeff p\n\ngoal (1 subgoal):\n 1. filterlim dd at_top at_bot", "show \"filterlim dd at_top at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim dd at_top at_bot", "unfolding dd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_top", "using \\<open>degree q>degree p\\<close> that(2)"], ["proof (prove)\nusing this:\n  degree p < degree q\n  even (degree q - degree p)\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_top", "by (auto intro!:filterlim_pow_at_bot_even simp:filterlim_ident)"], ["proof (state)\nthis:\n  filterlim dd at_top at_bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < cc; even (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < cc; even (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have \"filterlim (\\<lambda>x. (qq x / pp x) * dd x) at_top at_bot\"\n      when \"cc<0\" \"odd (degree q - degree p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. qq x / pp x * dd x :> at_top", "proof (subst filterlim_tendsto_neg_mult_at_top_iff[OF qqpp_tendsto])"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_coeff q / lead_coeff p < 0\n 2. filterlim dd at_bot at_bot", "show \"0 > lead_coeff q / lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff q / lead_coeff p < 0", "using \\<open>cc<0\\<close>"], ["proof (prove)\nusing this:\n  cc < 0\n\ngoal (1 subgoal):\n 1. lead_coeff q / lead_coeff p < 0", "unfolding cc_def"], ["proof (prove)\nusing this:\n  lead_coeff q / lead_coeff p < 0\n\ngoal (1 subgoal):\n 1. lead_coeff q / lead_coeff p < 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff q / lead_coeff p < 0\n\ngoal (1 subgoal):\n 1. filterlim dd at_bot at_bot", "show \"filterlim dd at_bot at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim dd at_bot at_bot", "unfolding dd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_bot", "using \\<open>degree q>degree p\\<close> that(2)"], ["proof (prove)\nusing this:\n  degree p < degree q\n  odd (degree q - degree p)\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_bot", "by (auto intro!:filterlim_pow_at_bot_odd simp:filterlim_ident)"], ["proof (state)\nthis:\n  filterlim dd at_bot at_bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>cc < 0; odd (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "ultimately"], ["proof (chain)\npicking this:\n  0 < cc \\<and> even (degree q - degree p) \\<or>\n  cc < 0 \\<and> odd (degree q - degree p)\n  \\<lbrakk>0 < cc; even (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_top\n  \\<lbrakk>cc < 0; odd (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_top", "have \"filterlim (\\<lambda>x. (qq x / pp x) * dd x) at_top at_bot\""], ["proof (prove)\nusing this:\n  0 < cc \\<and> even (degree q - degree p) \\<or>\n  cc < 0 \\<and> odd (degree q - degree p)\n  \\<lbrakk>0 < cc; even (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_top\n  \\<lbrakk>cc < 0; odd (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_bot. qq x / pp x * dd x :> at_top", "by blast"], ["proof (state)\nthis:\n  LIM x at_bot. qq x / pp x * dd x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  LIM x at_bot. qq x / pp x * dd x :> at_top", "have \"LIM x at_bot. poly q x / poly p x :> at_top\""], ["proof (prove)\nusing this:\n  LIM x at_bot. qq x / pp x * dd x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> at_top", "using filterlim_cong[OF _ _ divide_cong]"], ["proof (prove)\nusing this:\n  LIM x at_bot. qq x / pp x * dd x :> at_top\n  \\<lbrakk>?F1.0 = ?F1'; at_bot = ?F2'\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_bot. poly q x / poly p x :> ?F1.0) =\n                    (LIM x ?F2'. qq x / pp x * dd x :> ?F1')\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> at_top", "by blast"], ["proof (state)\nthis:\n  LIM x at_bot. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  LIM x at_bot. poly q x / poly p x :> at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "unfolding ll_def"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top\n                       else at_bot", "using that"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at_top\n  degree p < degree q\n  0 < sgn_neg_inf q * sgn_neg_inf p\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top\n                       else at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_bot. poly q x / poly p x :> ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>degree p < degree q; 0 < sgn_neg_inf q * sgn_neg_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>degree p < degree q; 0 < sgn_neg_inf q * sgn_neg_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have ?thesis  when \"degree q>degree p\" \"\\<not> sgn_neg_inf q * sgn_neg_inf p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "define cc where \"cc=lead_coeff q / lead_coeff p\""], ["proof (state)\nthis:\n  cc = lead_coeff q / lead_coeff p\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have \"(cc < 0 \\<and> even (degree q - degree p)) \\<or> (cc > 0 \\<and> odd (degree q - degree p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cc < 0 \\<and> even (degree q - degree p) \\<or>\n    0 < cc \\<and> odd (degree q - degree p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cc < 0 \\<and> even (degree q - degree p) \\<or>\n    0 < cc \\<and> odd (degree q - degree p)", "have \"even (degree q - degree p) \\<longleftrightarrow> \n            (even (degree q) \\<and> even (degree p)) \\<or> (odd (degree q) \\<and> odd (degree p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (degree q - degree p) =\n    (even (degree q) \\<and> even (degree p) \\<or>\n     odd (degree q) \\<and> odd (degree p))", "using \\<open>degree q>degree p\\<close>"], ["proof (prove)\nusing this:\n  degree p < degree q\n\ngoal (1 subgoal):\n 1. even (degree q - degree p) =\n    (even (degree q) \\<and> even (degree p) \\<or>\n     odd (degree q) \\<and> odd (degree p))", "by auto"], ["proof (state)\nthis:\n  even (degree q - degree p) =\n  (even (degree q) \\<and> even (degree p) \\<or>\n   odd (degree q) \\<and> odd (degree p))\n\ngoal (1 subgoal):\n 1. cc < 0 \\<and> even (degree q - degree p) \\<or>\n    0 < cc \\<and> odd (degree q - degree p)", "then"], ["proof (chain)\npicking this:\n  even (degree q - degree p) =\n  (even (degree q) \\<and> even (degree p) \\<or>\n   odd (degree q) \\<and> odd (degree p))", "show ?thesis"], ["proof (prove)\nusing this:\n  even (degree q - degree p) =\n  (even (degree q) \\<and> even (degree p) \\<or>\n   odd (degree q) \\<and> odd (degree p))\n\ngoal (1 subgoal):\n 1. cc < 0 \\<and> even (degree q - degree p) \\<or>\n    0 < cc \\<and> odd (degree q - degree p)", "using that \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  even (degree q - degree p) =\n  (even (degree q) \\<and> even (degree p) \\<or>\n   odd (degree q) \\<and> odd (degree p))\n  degree p < degree q\n  \\<not> 0 < sgn_neg_inf q * sgn_neg_inf p\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cc < 0 \\<and> even (degree q - degree p) \\<or>\n    0 < cc \\<and> odd (degree q - degree p)", "unfolding sgn_neg_inf_def cc_def zero_less_mult_iff \n          divide_less_0_iff zero_less_divide_iff"], ["proof (prove)\nusing this:\n  even (degree q - degree p) =\n  (even (degree q) \\<and> even (degree p) \\<or>\n   odd (degree q) \\<and> odd (degree p))\n  degree p < degree q\n  \\<not> (0 < (if even (degree q) then sgn (lead_coeff q)\n               else - sgn (lead_coeff q)) \\<and>\n          0 < (if even (degree p) then sgn (lead_coeff p)\n               else - sgn (lead_coeff p)) \\<or>\n          (if even (degree q) then sgn (lead_coeff q)\n           else - sgn (lead_coeff q))\n          < 0 \\<and>\n          (if even (degree p) then sgn (lead_coeff p)\n           else - sgn (lead_coeff p))\n          < 0)\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < lead_coeff q \\<and> lead_coeff p < 0 \\<or>\n     lead_coeff q < 0 \\<and> 0 < lead_coeff p) \\<and>\n    even (degree q - degree p) \\<or>\n    (0 < lead_coeff q \\<and> 0 < lead_coeff p \\<or>\n     lead_coeff q < 0 \\<and> lead_coeff p < 0) \\<and>\n    odd (degree q - degree p)", "apply (simp add:if_split[of \"(<) 0\"] if_split[of \"(>) 0\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(even (degree q) = even (degree p)) =\n             (even (degree q) \\<and> even (degree p) \\<or>\n              odd (degree q) \\<and> odd (degree p));\n     degree p < degree q;\n     (even (degree q) \\<and> \\<not> 0 < lead_coeff q \\<or>\n      odd (degree q) \\<and> \\<not> lead_coeff q < 0 \\<or>\n      even (degree p) \\<and> \\<not> 0 < lead_coeff p \\<or>\n      odd (degree p) \\<and> \\<not> lead_coeff p < 0) \\<and>\n     (even (degree q) \\<and> \\<not> lead_coeff q < 0 \\<or>\n      odd (degree q) \\<and> \\<not> 0 < lead_coeff q \\<or>\n      even (degree p) \\<and> \\<not> lead_coeff p < 0 \\<or>\n      odd (degree p) \\<and> \\<not> 0 < lead_coeff p);\n     p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (0 < lead_coeff q \\<and> lead_coeff p < 0 \\<or>\n                       lead_coeff q < 0 \\<and> 0 < lead_coeff p) \\<and>\n                      (even (degree q) \\<and> even (degree p) \\<or>\n                       odd (degree q) \\<and> odd (degree p)) \\<or>\n                      (0 < lead_coeff q \\<and> 0 < lead_coeff p \\<or>\n                       lead_coeff q < 0 \\<and> lead_coeff p < 0) \\<and>\n                      (even (degree q) \\<longrightarrow>\n                       odd (degree p)) \\<and>\n                      (even (degree q) \\<or> even (degree p))", "by (metis leading_coeff_0_iff linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  cc < 0 \\<and> even (degree q - degree p) \\<or>\n  0 < cc \\<and> odd (degree q - degree p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cc < 0 \\<and> even (degree q - degree p) \\<or>\n  0 < cc \\<and> odd (degree q - degree p)\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "moreover"], ["proof (state)\nthis:\n  cc < 0 \\<and> even (degree q - degree p) \\<or>\n  0 < cc \\<and> odd (degree q - degree p)\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have \"filterlim (\\<lambda>x. (qq x / pp x) * dd x) at_bot at_bot\"\n      when \"cc<0\" \"even (degree q - degree p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. qq x / pp x * dd x :> at_bot", "proof (subst filterlim_tendsto_neg_mult_at_bot_iff[OF qqpp_tendsto])"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_coeff q / lead_coeff p < 0\n 2. filterlim dd at_top at_bot", "show \"0 > lead_coeff q / lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff q / lead_coeff p < 0", "using \\<open>cc<0\\<close>"], ["proof (prove)\nusing this:\n  cc < 0\n\ngoal (1 subgoal):\n 1. lead_coeff q / lead_coeff p < 0", "unfolding cc_def"], ["proof (prove)\nusing this:\n  lead_coeff q / lead_coeff p < 0\n\ngoal (1 subgoal):\n 1. lead_coeff q / lead_coeff p < 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff q / lead_coeff p < 0\n\ngoal (1 subgoal):\n 1. filterlim dd at_top at_bot", "show \"filterlim dd at_top at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim dd at_top at_bot", "unfolding dd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_top", "using \\<open>degree q>degree p\\<close> that(2)"], ["proof (prove)\nusing this:\n  degree p < degree q\n  even (degree q - degree p)\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_top", "by (auto intro!:filterlim_pow_at_bot_even simp:filterlim_ident)"], ["proof (state)\nthis:\n  filterlim dd at_top at_bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>cc < 0; even (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>cc < 0; even (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "have \"filterlim (\\<lambda>x. (qq x / pp x) * dd x) at_bot at_bot\"\n      when \"cc>0\" \"odd (degree q - degree p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. qq x / pp x * dd x :> at_bot", "proof (subst filterlim_tendsto_pos_mult_at_bot_iff[OF qqpp_tendsto])"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < lead_coeff q / lead_coeff p\n 2. filterlim dd at_bot at_bot", "show \"0 < lead_coeff q / lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lead_coeff q / lead_coeff p", "using \\<open>cc>0\\<close>"], ["proof (prove)\nusing this:\n  0 < cc\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff q / lead_coeff p", "unfolding cc_def"], ["proof (prove)\nusing this:\n  0 < lead_coeff q / lead_coeff p\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff q / lead_coeff p", "by auto"], ["proof (state)\nthis:\n  0 < lead_coeff q / lead_coeff p\n\ngoal (1 subgoal):\n 1. filterlim dd at_bot at_bot", "show \"filterlim dd at_bot at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim dd at_bot at_bot", "unfolding dd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_bot", "using \\<open>degree q>degree p\\<close> that(2)"], ["proof (prove)\nusing this:\n  degree p < degree q\n  odd (degree q - degree p)\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       if degree q < degree p then 1 / x ^ (degree p - degree q)\n       else x ^ (degree q - degree p) :> at_bot", "by (auto intro!:filterlim_pow_at_bot_odd simp:filterlim_ident)"], ["proof (state)\nthis:\n  filterlim dd at_bot at_bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < cc; odd (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "ultimately"], ["proof (chain)\npicking this:\n  cc < 0 \\<and> even (degree q - degree p) \\<or>\n  0 < cc \\<and> odd (degree q - degree p)\n  \\<lbrakk>cc < 0; even (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_bot\n  \\<lbrakk>0 < cc; odd (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_bot", "have \"filterlim (\\<lambda>x. (qq x / pp x) * dd x) at_bot at_bot\""], ["proof (prove)\nusing this:\n  cc < 0 \\<and> even (degree q - degree p) \\<or>\n  0 < cc \\<and> odd (degree q - degree p)\n  \\<lbrakk>cc < 0; even (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_bot\n  \\<lbrakk>0 < cc; odd (degree q - degree p)\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. qq x / pp x * dd x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot. qq x / pp x * dd x :> at_bot", "by blast"], ["proof (state)\nthis:\n  LIM x at_bot. qq x / pp x * dd x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  LIM x at_bot. qq x / pp x * dd x :> at_bot", "have \"LIM x at_bot. poly q x / poly p x :> at_bot\""], ["proof (prove)\nusing this:\n  LIM x at_bot. qq x / pp x * dd x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> at_bot", "using filterlim_cong[OF _ _ divide_cong]"], ["proof (prove)\nusing this:\n  LIM x at_bot. qq x / pp x * dd x :> at_bot\n  \\<lbrakk>?F1.0 = ?F1'; at_bot = ?F2'\\<rbrakk>\n  \\<Longrightarrow> (LIM x at_bot. poly q x / poly p x :> ?F1.0) =\n                    (LIM x ?F2'. qq x / pp x * dd x :> ?F1')\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> at_bot", "by blast"], ["proof (state)\nthis:\n  LIM x at_bot. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "then"], ["proof (chain)\npicking this:\n  LIM x at_bot. poly q x / poly p x :> at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "unfolding ll_def"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top\n                       else at_bot", "using that"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at_bot\n  degree p < degree q\n  \\<not> 0 < sgn_neg_inf q * sgn_neg_inf p\n\ngoal (1 subgoal):\n 1. LIM x at_bot.\n       poly q x /\n       poly p\n        x :> if degree q < degree p then at 0\n             else if degree q = degree p\n                  then nhds (lead_coeff q / lead_coeff p)\n                  else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top\n                       else at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_bot. poly q x / poly p x :> ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>degree p < degree q;\n   \\<not> 0 < sgn_neg_inf q * sgn_neg_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "ultimately"], ["proof (chain)\npicking this:\n  degree q < degree p \\<Longrightarrow>\n  LIM x at_bot. poly q x / poly p x :> ll\n  degree q = degree p \\<Longrightarrow>\n  LIM x at_bot. poly q x / poly p x :> ll\n  \\<lbrakk>degree p < degree q; 0 < sgn_neg_inf q * sgn_neg_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. poly q x / poly p x :> ll\n  \\<lbrakk>degree p < degree q;\n   \\<not> 0 < sgn_neg_inf q * sgn_neg_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. poly q x / poly p x :> ll", "show ?thesis"], ["proof (prove)\nusing this:\n  degree q < degree p \\<Longrightarrow>\n  LIM x at_bot. poly q x / poly p x :> ll\n  degree q = degree p \\<Longrightarrow>\n  LIM x at_bot. poly q x / poly p x :> ll\n  \\<lbrakk>degree p < degree q; 0 < sgn_neg_inf q * sgn_neg_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. poly q x / poly p x :> ll\n  \\<lbrakk>degree p < degree q;\n   \\<not> 0 < sgn_neg_inf q * sgn_neg_inf p\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot. poly q x / poly p x :> ll\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> ll", "by linarith"], ["proof (state)\nthis:\n  LIM x at_bot. poly q x / poly p x :> ll\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Alternative definition of cross\\<close>"], ["", "definition cross_alt :: \"real poly \\<Rightarrow>real poly \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> int\" where\n  \"cross_alt p q a b=\\<bar>sign (poly p a) - sign (poly q a)\\<bar> - \\<bar>sign (poly p b) - sign(poly q b)\\<bar>\""], ["", "lemma cross_alt_coprime_0:\n  assumes \"coprime p q\" \"p=0\\<or>q=0\"\n  shows \"cross_alt p q a b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "have ?thesis when \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "have \"is_unit q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit q", "using that \\<open>coprime p q\\<close>"], ["proof (prove)\nusing this:\n  p = 0\n  coprime p q\n\ngoal (1 subgoal):\n 1. is_unit q", "by simp"], ["proof (state)\nthis:\n  is_unit q\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "then"], ["proof (chain)\npicking this:\n  is_unit q", "obtain a where \"a\\<noteq>0\" \"q=[:a:]\""], ["proof (prove)\nusing this:\n  is_unit q\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<noteq> 0; q = [:a:]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using is_unit_pCons_ex_iff"], ["proof (prove)\nusing this:\n  is_unit q\n  is_unit ?p = (\\<exists>a. a \\<noteq> (0::?'a) \\<and> ?p = [:a:])\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<noteq> 0; q = [:a:]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  q = [:a:]\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  q = [:a:]", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  q = [:a:]\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "using that"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  q = [:a:]\n  p = 0\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "unfolding cross_alt_def"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  q = [:a:]\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<bar>sign (poly p a) - sign (poly q a)\\<bar> -\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    0", "by auto"], ["proof (state)\nthis:\n  cross_alt p q a b = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow> cross_alt p q a b = 0\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow> cross_alt p q a b = 0\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "have ?thesis when \"q=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "have \"is_unit p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit p", "using that \\<open>coprime p q\\<close>"], ["proof (prove)\nusing this:\n  q = 0\n  coprime p q\n\ngoal (1 subgoal):\n 1. is_unit p", "by simp"], ["proof (state)\nthis:\n  is_unit p\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "then"], ["proof (chain)\npicking this:\n  is_unit p", "obtain a where \"a\\<noteq>0\" \"p=[:a:]\""], ["proof (prove)\nusing this:\n  is_unit p\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<noteq> 0; p = [:a:]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using is_unit_pCons_ex_iff"], ["proof (prove)\nusing this:\n  is_unit p\n  is_unit ?p = (\\<exists>a. a \\<noteq> (0::?'a) \\<and> ?p = [:a:])\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<noteq> 0; p = [:a:]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  p = [:a:]", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "using that"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  p = [:a:]\n  q = 0\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "unfolding cross_alt_def"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  p = [:a:]\n  q = 0\n\ngoal (1 subgoal):\n 1. \\<bar>sign (poly p a) - sign (poly q a)\\<bar> -\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    0", "by auto"], ["proof (state)\nthis:\n  cross_alt p q a b = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q = 0 \\<Longrightarrow> cross_alt p q a b = 0\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<Longrightarrow> cross_alt p q a b = 0\n  q = 0 \\<Longrightarrow> cross_alt p q a b = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<Longrightarrow> cross_alt p q a b = 0\n  q = 0 \\<Longrightarrow> cross_alt p q a b = 0\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "using \\<open>p=0\\<or>q=0\\<close>"], ["proof (prove)\nusing this:\n  p = 0 \\<Longrightarrow> cross_alt p q a b = 0\n  q = 0 \\<Longrightarrow> cross_alt p q a b = 0\n  p = 0 \\<or> q = 0\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = 0", "by auto"], ["proof (state)\nthis:\n  cross_alt p q a b = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cross_alt_0[simp]: \"cross_alt 0 0 a b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_alt 0 0 a b = 0", "unfolding cross_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>sign (poly 0 a) - sign (poly 0 a)\\<bar> -\n    \\<bar>sign (poly 0 b) - sign (poly 0 b)\\<bar> =\n    0", "by auto"], ["", "lemma cross_alt_poly_commute:\n  \"cross_alt p q a b = cross_alt q p a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_alt p q a b = cross_alt q p a b", "unfolding cross_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>sign (poly p a) - sign (poly q a)\\<bar> -\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>sign (poly q a) - sign (poly p a)\\<bar> -\n    \\<bar>sign (poly q b) - sign (poly p b)\\<bar>", "by auto"], ["", "lemma cross_alt_clear_n:\n  assumes \"coprime p q\"\n  shows \"cross_alt p q a b = cross_alt 1 (p*q) a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cross_alt p q a b = cross_alt 1 (p * q) a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cross_alt p q a b = cross_alt 1 (p * q) a b", "have \"\\<bar>sign (poly p a) - sign (poly q a)\\<bar>  = \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>", "proof (cases \"poly p a=0 \\<and> poly q a=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly p a = 0 \\<and> poly q a = 0 \\<Longrightarrow>\n    \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>\n 2. \\<not> (poly p a = 0 \\<and> poly q a = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>", "case True"], ["proof (state)\nthis:\n  poly p a = 0 \\<and> poly q a = 0\n\ngoal (2 subgoals):\n 1. poly p a = 0 \\<and> poly q a = 0 \\<Longrightarrow>\n    \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>\n 2. \\<not> (poly p a = 0 \\<and> poly q a = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>", "then"], ["proof (chain)\npicking this:\n  poly p a = 0 \\<and> poly q a = 0", "have False"], ["proof (prove)\nusing this:\n  poly p a = 0 \\<and> poly q a = 0\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  poly p a = 0 \\<and> poly q a = 0\n  coprime p q\n\ngoal (1 subgoal):\n 1. False", "using coprime_poly_0"], ["proof (prove)\nusing this:\n  poly p a = 0 \\<and> poly q a = 0\n  coprime p q\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. poly p a = 0 \\<and> poly q a = 0 \\<Longrightarrow>\n    \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>\n 2. \\<not> (poly p a = 0 \\<and> poly q a = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n  \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> (poly p a = 0 \\<and> poly q a = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (poly p a = 0 \\<and> poly q a = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>", "case False"], ["proof (state)\nthis:\n  \\<not> (poly p a = 0 \\<and> poly q a = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (poly p a = 0 \\<and> poly q a = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>", "then"], ["proof (chain)\npicking this:\n  \\<not> (poly p a = 0 \\<and> poly q a = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (poly p a = 0 \\<and> poly q a = 0)\n\ngoal (1 subgoal):\n 1. \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n    \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>", "unfolding Sturm_Tarski.sign_def"], ["proof (prove)\nusing this:\n  \\<not> (poly p a = 0 \\<and> poly q a = 0)\n\ngoal (1 subgoal):\n 1. \\<bar>(if 0 < poly p a then 1 else if poly p a = 0 then 0 else - 1) -\n          (if 0 < poly q a then 1\n           else if poly q a = 0 then 0 else - 1)\\<bar> =\n    \\<bar>1 -\n          (if 0 < poly p a then 1 else if poly p a = 0 then 0 else - 1) *\n          (if 0 < poly q a then 1\n           else if poly q a = 0 then 0 else - 1)\\<bar>", "by force"], ["proof (state)\nthis:\n  \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n  \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n  \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = cross_alt 1 (p * q) a b", "moreover"], ["proof (state)\nthis:\n  \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n  \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = cross_alt 1 (p * q) a b", "have \"\\<bar>sign (poly p b) - sign (poly q b)\\<bar>  = \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>", "proof (cases \"poly p b=0 \\<and> poly q b=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly p b = 0 \\<and> poly q b = 0 \\<Longrightarrow>\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>\n 2. \\<not> (poly p b = 0 \\<and> poly q b = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>", "case True"], ["proof (state)\nthis:\n  poly p b = 0 \\<and> poly q b = 0\n\ngoal (2 subgoals):\n 1. poly p b = 0 \\<and> poly q b = 0 \\<Longrightarrow>\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>\n 2. \\<not> (poly p b = 0 \\<and> poly q b = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>", "then"], ["proof (chain)\npicking this:\n  poly p b = 0 \\<and> poly q b = 0", "have False"], ["proof (prove)\nusing this:\n  poly p b = 0 \\<and> poly q b = 0\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  poly p b = 0 \\<and> poly q b = 0\n  coprime p q\n\ngoal (1 subgoal):\n 1. False", "using coprime_poly_0"], ["proof (prove)\nusing this:\n  poly p b = 0 \\<and> poly q b = 0\n  coprime p q\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. poly p b = 0 \\<and> poly q b = 0 \\<Longrightarrow>\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>\n 2. \\<not> (poly p b = 0 \\<and> poly q b = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n  \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> (poly p b = 0 \\<and> poly q b = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (poly p b = 0 \\<and> poly q b = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>", "case False"], ["proof (state)\nthis:\n  \\<not> (poly p b = 0 \\<and> poly q b = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (poly p b = 0 \\<and> poly q b = 0) \\<Longrightarrow>\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>", "then"], ["proof (chain)\npicking this:\n  \\<not> (poly p b = 0 \\<and> poly q b = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (poly p b = 0 \\<and> poly q b = 0)\n\ngoal (1 subgoal):\n 1. \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n    \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>", "unfolding Sturm_Tarski.sign_def"], ["proof (prove)\nusing this:\n  \\<not> (poly p b = 0 \\<and> poly q b = 0)\n\ngoal (1 subgoal):\n 1. \\<bar>(if 0 < poly p b then 1 else if poly p b = 0 then 0 else - 1) -\n          (if 0 < poly q b then 1\n           else if poly q b = 0 then 0 else - 1)\\<bar> =\n    \\<bar>1 -\n          (if 0 < poly p b then 1 else if poly p b = 0 then 0 else - 1) *\n          (if 0 < poly q b then 1\n           else if poly q b = 0 then 0 else - 1)\\<bar>", "by force"], ["proof (state)\nthis:\n  \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n  \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n  \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = cross_alt 1 (p * q) a b", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n  \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>\n  \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n  \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>sign (poly p a) - sign (poly q a)\\<bar> =\n  \\<bar>1 - sign (poly p a) * sign (poly q a)\\<bar>\n  \\<bar>sign (poly p b) - sign (poly q b)\\<bar> =\n  \\<bar>1 - sign (poly p b) * sign (poly q b)\\<bar>\n\ngoal (1 subgoal):\n 1. cross_alt p q a b = cross_alt 1 (p * q) a b", "by (simp add: cross_alt_def sign_times)"], ["proof (state)\nthis:\n  cross_alt p q a b = cross_alt 1 (p * q) a b\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Alternative sign variation sequencse\\<close>"], ["", "fun changes_alt:: \"('a ::linordered_idom) list \\<Rightarrow> int\" where\n  \"changes_alt [] = 0\"|\n  \"changes_alt [_] = 0\" |\n  \"changes_alt (x1#x2#xs) = abs(sign x1 - sign x2) + changes_alt (x2#xs)\""], ["", "definition changes_alt_poly_at::\"('a ::linordered_idom) poly list \\<Rightarrow> 'a \\<Rightarrow> int\" where\n  \"changes_alt_poly_at ps a= changes_alt (map (\\<lambda>p. poly p a) ps)\""], ["", "definition changes_alt_itv_smods:: \"real \\<Rightarrow> real \\<Rightarrow>real poly \\<Rightarrow> real poly \\<Rightarrow>  int\" where\n  \"changes_alt_itv_smods a b p q= (let ps= smods p q \n                                    in changes_alt_poly_at ps a - changes_alt_poly_at ps b)\""], ["", "lemma changes_alt_itv_smods_rec:\n  assumes \"a<b\" \"coprime p q\" \n  shows \"changes_alt_itv_smods a b p q  = cross_alt p q a b + changes_alt_itv_smods a b q (-(p mod q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "proof (cases \"p = 0 \\<or> q = 0 \\<or> q dvd p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> q dvd p \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "case True"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<or> q dvd p\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> q dvd p \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<or> q dvd p\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> q dvd p \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "have \"p=0 \\<or> q=0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "using cross_alt_coprime_0[OF \\<open>coprime p q\\<close>]"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> cross_alt p q ?a ?b = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "unfolding changes_alt_itv_smods_def changes_alt_poly_at_def"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> cross_alt p q ?a ?b = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    (let ps = smods p q\n     in changes_alt (map (\\<lambda>p. poly p a) ps) -\n        changes_alt (map (\\<lambda>p. poly p b) ps)) =\n    cross_alt p q a b +\n    (let ps = smods q (- (p mod q))\n     in changes_alt (map (\\<lambda>p. poly p a) ps) -\n        changes_alt (map (\\<lambda>p. poly p b) ps))", "by fastforce"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<Longrightarrow>\n  changes_alt_itv_smods a b p q =\n  cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> q dvd p \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<Longrightarrow>\n  changes_alt_itv_smods a b p q =\n  cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> q dvd p \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "have \"\\<lbrakk>p\\<noteq>0;q\\<noteq>0;p mod q = 0\\<rbrakk> \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; p mod q = 0\\<rbrakk>\n    \\<Longrightarrow> changes_alt_itv_smods a b p q =\n                      cross_alt p q a b +\n                      changes_alt_itv_smods a b q (- (p mod q))", "unfolding changes_alt_itv_smods_def changes_alt_poly_at_def cross_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; p mod q = 0\\<rbrakk>\n    \\<Longrightarrow> (let ps = smods p q\n                       in changes_alt (map (\\<lambda>p. poly p a) ps) -\n                          changes_alt (map (\\<lambda>p. poly p b) ps)) =\n                      \\<bar>sign (poly p a) - sign (poly q a)\\<bar> -\n                      \\<bar>sign (poly p b) - sign (poly q b)\\<bar> +\n                      (let ps = smods q (- (p mod q))\n                       in changes_alt (map (\\<lambda>p. poly p a) ps) -\n                          changes_alt (map (\\<lambda>p. poly p b) ps))", "by (simp add:sign_times)"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; p mod q = 0\\<rbrakk>\n  \\<Longrightarrow> changes_alt_itv_smods a b p q =\n                    cross_alt p q a b +\n                    changes_alt_itv_smods a b q (- (p mod q))\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> q dvd p \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<or> q = 0 \\<or> q dvd p\n  p = 0 \\<or> q = 0 \\<Longrightarrow>\n  changes_alt_itv_smods a b p q =\n  cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; p mod q = 0\\<rbrakk>\n  \\<Longrightarrow> changes_alt_itv_smods a b p q =\n                    cross_alt p q a b +\n                    changes_alt_itv_smods a b q (- (p mod q))", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<or> q dvd p\n  p = 0 \\<or> q = 0 \\<Longrightarrow>\n  changes_alt_itv_smods a b p q =\n  cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; p mod q = 0\\<rbrakk>\n  \\<Longrightarrow> changes_alt_itv_smods a b p q =\n                    cross_alt p q a b +\n                    changes_alt_itv_smods a b q (- (p mod q))\n\ngoal (1 subgoal):\n 1. changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "by auto (auto elim: dvdE)"], ["proof (state)\nthis:\n  changes_alt_itv_smods a b p q =\n  cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "hence \"p\\<noteq>0\" \"q\\<noteq>0\" \"p mod q\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0 &&& p mod q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  p mod q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  p mod q \\<noteq> 0", "obtain ps where ps:\"smods p q=p#q#-(p mod q)#ps\" \"smods q (-(p mod q)) = q#-(p mod q)#ps\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  p mod q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>smods p q = p # q # - (p mod q) # ps;\n         smods q (- (p mod q)) = q # - (p mod q) # ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  smods p q = p # q # - (p mod q) # ps\n  smods q (- (p mod q)) = q # - (p mod q) # ps\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "define changes_diff where \"changes_diff\\<equiv>\\<lambda>x. changes_alt_poly_at (p#q#-(p mod q)#ps) x \n    - changes_alt_poly_at (q#-(p mod q)#ps) x\""], ["proof (state)\nthis:\n  changes_diff \\<equiv>\n  \\<lambda>x.\n     changes_alt_poly_at (p # q # - (p mod q) # ps) x -\n     changes_alt_poly_at (q # - (p mod q) # ps) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "have \"changes_diff a - changes_diff b=cross_alt p q a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_diff a - changes_diff b = cross_alt p q a b", "unfolding changes_diff_def changes_alt_poly_at_def cross_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_alt (map (\\<lambda>p. poly p a) (p # q # - (p mod q) # ps)) -\n    changes_alt (map (\\<lambda>p. poly p a) (q # - (p mod q) # ps)) -\n    (changes_alt (map (\\<lambda>p. poly p b) (p # q # - (p mod q) # ps)) -\n     changes_alt (map (\\<lambda>p. poly p b) (q # - (p mod q) # ps))) =\n    \\<bar>sign (poly p a) - sign (poly q a)\\<bar> -\n    \\<bar>sign (poly p b) - sign (poly q b)\\<bar>", "by simp"], ["proof (state)\nthis:\n  changes_diff a - changes_diff b = cross_alt p q a b\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> q dvd p) \\<Longrightarrow>\n    changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_diff a - changes_diff b = cross_alt p q a b\n\ngoal (1 subgoal):\n 1. changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))", "unfolding changes_alt_itv_smods_def changes_diff_def changes_alt_poly_at_def ps"], ["proof (prove)\nusing this:\n  changes_alt (map (\\<lambda>p. poly p a) (p # q # - (p mod q) # ps)) -\n  changes_alt (map (\\<lambda>p. poly p a) (q # - (p mod q) # ps)) -\n  (changes_alt (map (\\<lambda>p. poly p b) (p # q # - (p mod q) # ps)) -\n   changes_alt (map (\\<lambda>p. poly p b) (q # - (p mod q) # ps))) =\n  cross_alt p q a b\n\ngoal (1 subgoal):\n 1. (let ps = p # q # - (p mod q) # ps\n     in changes_alt (map (\\<lambda>p. poly p a) ps) -\n        changes_alt (map (\\<lambda>p. poly p b) ps)) =\n    cross_alt p q a b +\n    (let ps = q # - (p mod q) # ps\n     in changes_alt (map (\\<lambda>p. poly p a) ps) -\n        changes_alt (map (\\<lambda>p. poly p b) ps))", "by force"], ["proof (state)\nthis:\n  changes_alt_itv_smods a b p q =\n  cross_alt p q a b + changes_alt_itv_smods a b q (- (p mod q))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>jumpF on polynomials\\<close>"], ["", "definition jumpF_polyR:: \"real poly \\<Rightarrow> real poly \\<Rightarrow> real \\<Rightarrow> real\" where\n  \"jumpF_polyR q p a = jumpF (\\<lambda>x. poly q x / poly p x) (at_right a)\""], ["", "definition jumpF_polyL:: \"real poly \\<Rightarrow> real poly \\<Rightarrow> real \\<Rightarrow> real\" where\n  \"jumpF_polyL q p a = jumpF (\\<lambda>x. poly q x / poly p x) (at_left a)\""], ["", "definition jumpF_poly_top:: \"real poly \\<Rightarrow> real poly \\<Rightarrow> real\" where\n  \"jumpF_poly_top q p = jumpF (\\<lambda>x. poly q x / poly p x) at_top\""], ["", "definition jumpF_poly_bot:: \"real poly \\<Rightarrow> real poly \\<Rightarrow> real\" where\n  \"jumpF_poly_bot q p = jumpF (\\<lambda>x. poly q x / poly p x) at_bot\""], ["", "lemma jumpF_polyR_0[simp]: \"jumpF_polyR 0 p a = 0\" \"jumpF_polyR q 0 a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 0 p a = 0 &&& jumpF_polyR q 0 a = 0", "unfolding jumpF_polyR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly 0 x / poly p x) (at_right a) = 0 &&&\n    jumpF (\\<lambda>x. poly q x / poly 0 x) (at_right a) = 0", "by auto"], ["", "lemma jumpF_polyL_0[simp]: \"jumpF_polyL 0 p a = 0\" \"jumpF_polyL q 0 a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL 0 p a = 0 &&& jumpF_polyL q 0 a = 0", "unfolding jumpF_polyL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly 0 x / poly p x) (at_left a) = 0 &&&\n    jumpF (\\<lambda>x. poly q x / poly 0 x) (at_left a) = 0", "by auto"], ["", "lemma jumpF_polyR_mult_cancel:\n  assumes \"p'\\<noteq>0\"\n  shows \"jumpF_polyR (p' * q) (p' * p) a = jumpF_polyR q p a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR (p' * q) (p' * p) a = jumpF_polyR q p a", "unfolding jumpF_polyR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly (p' * q) x / poly (p' * p) x) (at_right a) =\n    jumpF (\\<lambda>x. poly q x / poly p x) (at_right a)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_right a = at_right a\n 2. \\<forall>\\<^sub>F x in at_right a.\n       poly (p' * q) x / poly (p' * p) x = poly q x / poly p x", "obtain ub where \"a < ub\" \"\\<forall>z. a < z \\<and> z \\<le> ub \\<longrightarrow> poly p' z \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>a < ub;\n         \\<forall>z.\n            a < z \\<and> z \\<le> ub \\<longrightarrow>\n            poly p' z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using next_non_root_interval[OF \\<open>p'\\<noteq>0\\<close>,of a]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>a < ub;\n       \\<forall>z.\n          a < z \\<and> z \\<le> ub \\<longrightarrow>\n          poly p' z \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>a < ub;\n         \\<forall>z.\n            a < z \\<and> z \\<le> ub \\<longrightarrow>\n            poly p' z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a < ub\n  \\<forall>z. a < z \\<and> z \\<le> ub \\<longrightarrow> poly p' z \\<noteq> 0\n\ngoal (2 subgoals):\n 1. at_right a = at_right a\n 2. \\<forall>\\<^sub>F x in at_right a.\n       poly (p' * q) x / poly (p' * p) x = poly q x / poly p x", "then"], ["proof (chain)\npicking this:\n  a < ub\n  \\<forall>z. a < z \\<and> z \\<le> ub \\<longrightarrow> poly p' z \\<noteq> 0", "show \"\\<forall>\\<^sub>F x in at_right a. poly (p' * q) x / poly (p' * p) x = poly q x / poly p x\""], ["proof (prove)\nusing this:\n  a < ub\n  \\<forall>z. a < z \\<and> z \\<le> ub \\<longrightarrow> poly p' z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right a.\n       poly (p' * q) x / poly (p' * p) x = poly q x / poly p x", "apply (unfold eventually_at_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < ub;\n     \\<forall>z.\n        a < z \\<and> z \\<le> ub \\<longrightarrow>\n        poly p' z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b>a.\n                         \\<forall>y>a.\n                            y < b \\<longrightarrow>\n                            poly (p' * q) y / poly (p' * p) y =\n                            poly q y / poly p y", "apply (intro exI[where x=ub])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < ub;\n     \\<forall>z.\n        a < z \\<and> z \\<le> ub \\<longrightarrow>\n        poly p' z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> a < ub \\<and>\n                      (\\<forall>y>a.\n                          y < ub \\<longrightarrow>\n                          poly (p' * q) y / poly (p' * p) y =\n                          poly q y / poly p y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_right a.\n     poly (p' * q) x / poly (p' * p) x = poly q x / poly p x\n\ngoal (1 subgoal):\n 1. at_right a = at_right a", "qed simp"], ["", "lemma jumpF_polyL_mult_cancel:\n  assumes \"p'\\<noteq>0\"\n  shows \"jumpF_polyL (p' * q) (p' * p) a = jumpF_polyL q p a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL (p' * q) (p' * p) a = jumpF_polyL q p a", "unfolding jumpF_polyL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly (p' * q) x / poly (p' * p) x) (at_left a) =\n    jumpF (\\<lambda>x. poly q x / poly p x) (at_left a)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_left a = at_left a\n 2. \\<forall>\\<^sub>F x in at_left a.\n       poly (p' * q) x / poly (p' * p) x = poly q x / poly p x", "obtain lb where \"lb < a\" \"\\<forall>z. lb \\<le> z \\<and> z < a \\<longrightarrow> poly p' z \\<noteq> 0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>lb < a;\n         \\<forall>z.\n            lb \\<le> z \\<and> z < a \\<longrightarrow>\n            poly p' z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using last_non_root_interval[OF \\<open>p'\\<noteq>0\\<close>,of a]"], ["proof (prove)\nusing this:\n  (\\<And>lb.\n      \\<lbrakk>lb < a;\n       \\<forall>z.\n          lb \\<le> z \\<and> z < a \\<longrightarrow>\n          poly p' z \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>lb < a;\n         \\<forall>z.\n            lb \\<le> z \\<and> z < a \\<longrightarrow>\n            poly p' z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lb < a\n  \\<forall>z. lb \\<le> z \\<and> z < a \\<longrightarrow> poly p' z \\<noteq> 0\n\ngoal (2 subgoals):\n 1. at_left a = at_left a\n 2. \\<forall>\\<^sub>F x in at_left a.\n       poly (p' * q) x / poly (p' * p) x = poly q x / poly p x", "then"], ["proof (chain)\npicking this:\n  lb < a\n  \\<forall>z. lb \\<le> z \\<and> z < a \\<longrightarrow> poly p' z \\<noteq> 0", "show \"\\<forall>\\<^sub>F x in at_left a. poly (p' * q) x / poly (p' * p) x = poly q x / poly p x\""], ["proof (prove)\nusing this:\n  lb < a\n  \\<forall>z. lb \\<le> z \\<and> z < a \\<longrightarrow> poly p' z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left a.\n       poly (p' * q) x / poly (p' * p) x = poly q x / poly p x", "apply (unfold eventually_at_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lb < a;\n     \\<forall>z.\n        lb \\<le> z \\<and> z < a \\<longrightarrow>\n        poly p' z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b<a.\n                         \\<forall>y>b.\n                            y < a \\<longrightarrow>\n                            poly (p' * q) y / poly (p' * p) y =\n                            poly q y / poly p y", "apply (intro exI[where x=lb])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lb < a;\n     \\<forall>z.\n        lb \\<le> z \\<and> z < a \\<longrightarrow>\n        poly p' z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> lb < a \\<and>\n                      (\\<forall>y>lb.\n                          y < a \\<longrightarrow>\n                          poly (p' * q) y / poly (p' * p) y =\n                          poly q y / poly p y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left a.\n     poly (p' * q) x / poly (p' * p) x = poly q x / poly p x\n\ngoal (1 subgoal):\n 1. at_left a = at_left a", "qed simp"], ["", "lemma jumpF_poly_noroot: \n  assumes \"poly p a\\<noteq>0\"\n  shows \"jumpF_polyL q p a = 0\" \"jumpF_polyR q p a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p a = 0 &&& jumpF_polyR q p a = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p a = 0", "unfolding jumpF_polyL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at_left a) = 0", "using assms"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at_left a) = 0", "apply (intro jumpF_not_infinity)"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly p a \\<noteq> 0 \\<Longrightarrow>\n    continuous (at_left a) (\\<lambda>x. poly q x / poly p x)\n 2. poly p a \\<noteq> 0 \\<Longrightarrow> at_left a \\<noteq> bot", "by (auto intro!:continuous_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p a = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p a = 0", "unfolding jumpF_polyR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at_right a) = 0", "using assms"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at_right a) = 0", "apply (intro jumpF_not_infinity)"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly p a \\<noteq> 0 \\<Longrightarrow>\n    continuous (at_right a) (\\<lambda>x. poly q x / poly p x)\n 2. poly p a \\<noteq> 0 \\<Longrightarrow> at_right a \\<noteq> bot", "by (auto intro!:continuous_intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma jumpF_polyR_coprime:\n  assumes \"coprime p q\"\n  shows \"jumpF_polyR q p x = (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x=0 then \n                                if sign_r_pos p x \\<longleftrightarrow> poly q x>0 then 1/2 else - 1/2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "proof (cases \"p=0 \\<or> q=0 \\<or> poly p x\\<noteq>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "case True"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "using jumpF_poly_noroot"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "by fastforce"], ["proof (state)\nthis:\n  jumpF_polyR q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0)", "have asm:\"p\\<noteq>0\" \"q\\<noteq>0\" \"poly p x=0\""], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0 &&& poly p x = 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  poly p x = 0", "have \"poly q x\\<noteq>0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  poly p x = 0\n  coprime p q\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "using coprime_poly_0"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  poly p x = 0\n  coprime p q\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "have ?thesis when \"sign_r_pos p x \\<longleftrightarrow> poly q x>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "have \"(poly p has_sgnx sgn (poly q x)) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx sgn (poly q x)) (at_right x)", "by (metis False \\<open>poly q x \\<noteq> 0\\<close> add.inverse_neutral has_sgnx_imp_sgnx less_not_sym \n          neg_less_iff_less poly_has_sgnx_values(2) sgn_if sign_r_pos_sgnx_iff that \n          trivial_limit_at_right_real zero_less_one)"], ["proof (state)\nthis:\n  (poly p has_sgnx sgn (poly q x)) (at_right x)\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx sgn (poly q x)) (at_right x)", "have \"LIM x at_right x. poly q x / poly p x :> at_top\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx sgn (poly q x)) (at_right x)\n\ngoal (1 subgoal):\n 1. LIM x at_right x. poly q x / poly p x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"poly q x\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (poly p has_sgnx sgn (poly q x)) (at_right x) \\<Longrightarrow>\n    (poly q \\<longlongrightarrow> poly q x) (at_right x)\n 2. (poly p has_sgnx sgn (poly q x)) (at_right x) \\<Longrightarrow>\n    poly q x \\<noteq> 0\n 3. (poly p has_sgnx sgn (poly q x)) (at_right x) \\<Longrightarrow>\n    (poly p \\<longlongrightarrow> 0) (at_right x) \\<and>\n    (poly p has_sgnx sgn (poly q x)) (at_right x)", "apply (auto simp add:\\<open>poly q x\\<noteq>0\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx sgn (poly q x)) (at_right x) \\<Longrightarrow>\n    (poly p \\<longlongrightarrow> 0) (at_right x)", "by (metis asm(3) poly_tendsto(3))"], ["proof (state)\nthis:\n  LIM x at_right x. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_right x. poly q x / poly p x :> at_top", "have \"jumpF_polyR q p x = 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_right x. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x = 1 / 2", "unfolding jumpF_polyR_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right x. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM x at_right x. poly q x / poly p x :> at_top then 1 / 2\n     else if LIM x at_right x. poly q x / poly p x :> at_bot then - 1 / 2\n          else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p x = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF_polyR q p x = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyR q p x = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "using that False"], ["proof (prove)\nusing this:\n  jumpF_polyR q p x = 1 / 2\n  sign_r_pos p x = (0 < poly q x)\n  \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_r_pos p x = (0 < poly q x) \\<Longrightarrow>\n  jumpF_polyR q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "moreover"], ["proof (state)\nthis:\n  sign_r_pos p x = (0 < poly q x) \\<Longrightarrow>\n  jumpF_polyR q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "have ?thesis when \"\\<not> (sign_r_pos p x \\<longleftrightarrow> poly q x>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "have \"(poly p has_sgnx - sgn (poly q x)) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx - sgn (poly q x)) (at_right x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly p has_sgnx - sgn (poly q x)) (at_right x)", "have \"(0::real) < 1 \\<or> \\<not> (1::real) < 0 \\<and> sign_r_pos p x \n          \\<or> (poly p has_sgnx - sgn (poly q x)) (at_right x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 \\<or>\n    \\<not> 1 < 0 \\<and> sign_r_pos p x \\<or>\n    (poly p has_sgnx - sgn (poly q x)) (at_right x)", "by simp"], ["proof (state)\nthis:\n  0 < 1 \\<or>\n  \\<not> 1 < 0 \\<and> sign_r_pos p x \\<or>\n  (poly p has_sgnx - sgn (poly q x)) (at_right x)\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx - sgn (poly q x)) (at_right x)", "then"], ["proof (chain)\npicking this:\n  0 < 1 \\<or>\n  \\<not> 1 < 0 \\<and> sign_r_pos p x \\<or>\n  (poly p has_sgnx - sgn (poly q x)) (at_right x)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < 1 \\<or>\n  \\<not> 1 < 0 \\<and> sign_r_pos p x \\<or>\n  (poly p has_sgnx - sgn (poly q x)) (at_right x)\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx - sgn (poly q x)) (at_right x)", "by (metis (no_types) False \\<open>poly q x \\<noteq> 0\\<close> add.inverse_inverse has_sgnx_imp_sgnx \n            neg_less_0_iff_less poly_has_sgnx_values(2) sgn_if sgn_less sign_r_pos_sgnx_iff \n            that trivial_limit_at_right_real)"], ["proof (state)\nthis:\n  (poly p has_sgnx - sgn (poly q x)) (at_right x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (poly p has_sgnx - sgn (poly q x)) (at_right x)\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx - sgn (poly q x)) (at_right x)", "have \"LIM x at_right x. poly q x / poly p x :> at_bot\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx - sgn (poly q x)) (at_right x)\n\ngoal (1 subgoal):\n 1. LIM x at_right x. poly q x / poly p x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"poly q x\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (poly p has_sgnx - sgn (poly q x)) (at_right x) \\<Longrightarrow>\n    (poly q \\<longlongrightarrow> poly q x) (at_right x)\n 2. (poly p has_sgnx - sgn (poly q x)) (at_right x) \\<Longrightarrow>\n    poly q x \\<noteq> 0\n 3. (poly p has_sgnx - sgn (poly q x)) (at_right x) \\<Longrightarrow>\n    (poly p \\<longlongrightarrow> 0) (at_right x) \\<and>\n    (poly p has_sgnx - sgn (poly q x)) (at_right x)", "apply (auto simp add:\\<open>poly q x\\<noteq>0\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx - sgn (poly q x)) (at_right x) \\<Longrightarrow>\n    (poly p \\<longlongrightarrow> 0) (at_right x)", "by (metis asm(3) poly_tendsto(3))"], ["proof (state)\nthis:\n  LIM x at_right x. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_right x. poly q x / poly p x :> at_bot", "have \"jumpF_polyR q p x = - 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_right x. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x = - 1 / 2", "unfolding jumpF_polyR_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_right x. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM x at_right x. poly q x / poly p x :> at_top then 1 / 2\n     else if LIM x at_right x. poly q x / poly p x :> at_bot then - 1 / 2\n          else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p x = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF_polyR q p x = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyR q p x = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "using that False"], ["proof (prove)\nusing this:\n  jumpF_polyR q p x = - 1 / 2\n  sign_r_pos p x \\<noteq> (0 < poly q x)\n  \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign_r_pos p x \\<noteq> (0 < poly q x) \\<Longrightarrow>\n  jumpF_polyR q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  sign_r_pos p x = (0 < poly q x) \\<Longrightarrow>\n  jumpF_polyR q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n  sign_r_pos p x \\<noteq> (0 < poly q x) \\<Longrightarrow>\n  jumpF_polyR q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos p x = (0 < poly q x) \\<Longrightarrow>\n  jumpF_polyR q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n  sign_r_pos p x \\<noteq> (0 < poly q x) \\<Longrightarrow>\n  jumpF_polyR q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_polyL_coprime:\n  assumes \"coprime p q\"\n  shows \"jumpF_polyL q p x = (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x=0 then \n                if even (order x p) \\<longleftrightarrow> sign_r_pos p x \\<longleftrightarrow> poly q x>0 then 1/2 else - 1/2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "proof (cases \"p=0 \\<or> q=0 \\<or> poly p x\\<noteq>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "case True"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)\n 2. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "using jumpF_poly_noroot"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "by fastforce"], ["proof (state)\nthis:\n  jumpF_polyL q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n        else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0)", "have asm:\"p\\<noteq>0\" \"q\\<noteq>0\" \"poly p x=0\""], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0 &&& poly p x = 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  poly p x = 0", "have \"poly q x\\<noteq>0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  poly p x = 0\n  coprime p q\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "using coprime_poly_0"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  poly p x = 0\n  coprime p q\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "have ?thesis when \"even (order x p) \\<longleftrightarrow> sign_r_pos p x \\<longleftrightarrow> poly q x>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "consider (lt) \"poly q x>0\" | (gt) \" poly q x<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly q x \\<Longrightarrow> thesis;\n     poly q x < 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using \\<open>poly q x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly q x \\<Longrightarrow> thesis;\n     poly q x < 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>0 < poly q x \\<Longrightarrow> ?thesis;\n   poly q x < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < poly q x \\<Longrightarrow> ?thesis;\n   poly q x < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"sgnx (poly p) (at_left x) = sgn (poly q x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < poly q x \\<Longrightarrow> ?thesis;\n   poly q x < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left x) = sgn (poly q x)", "apply cases"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < poly q x \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = sgn (poly q x)\n 2. poly q x < 0 \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = sgn (poly q x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly q x \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = sgn (poly q x)", "using that sign_r_pos_sgnx_iff poly_sgnx_values[OF \\<open>p\\<noteq>0\\<close>,of x]"], ["proof (prove)\nusing this:\n  even (order x p) = (sign_r_pos p x = (0 < poly q x))\n  sign_r_pos ?p ?a = (0 < sgnx (poly ?p) (at_right ?a))\n  sgnx (poly p) (at_left x) = 1 \\<or> sgnx (poly p) (at_left x) = - 1\n  sgnx (poly p) (at_right x) = 1 \\<or> sgnx (poly p) (at_right x) = - 1\n\ngoal (1 subgoal):\n 1. 0 < poly q x \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = sgn (poly q x)", "apply (subst poly_sgnx_left_right[OF \\<open>p\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly q x;\n     even (order x p) = (sign_r_pos p x = (0 < poly q x));\n     \\<And>p a. sign_r_pos p a = (0 < sgnx (poly p) (at_right a));\n     sgnx (poly p) (at_left x) = 1 \\<or> sgnx (poly p) (at_left x) = - 1;\n     sgnx (poly p) (at_right x) = 1 \\<or>\n     sgnx (poly p) (at_right x) = - 1\\<rbrakk>\n    \\<Longrightarrow> (if even (order x p) then sgnx (poly p) (at_right x)\n                       else - sgnx (poly p) (at_right x)) =\n                      sgn (poly q x)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x < 0 \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = sgn (poly q x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x < 0 \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = sgn (poly q x)", "using that sign_r_pos_sgnx_iff poly_sgnx_values[OF \\<open>p\\<noteq>0\\<close>,of x]"], ["proof (prove)\nusing this:\n  even (order x p) = (sign_r_pos p x = (0 < poly q x))\n  sign_r_pos ?p ?a = (0 < sgnx (poly ?p) (at_right ?a))\n  sgnx (poly p) (at_left x) = 1 \\<or> sgnx (poly p) (at_left x) = - 1\n  sgnx (poly p) (at_right x) = 1 \\<or> sgnx (poly p) (at_right x) = - 1\n\ngoal (1 subgoal):\n 1. poly q x < 0 \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = sgn (poly q x)", "apply (subst poly_sgnx_left_right[OF \\<open>p\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly q x < 0;\n     even (order x p) = (sign_r_pos p x = (0 < poly q x));\n     \\<And>p a. sign_r_pos p a = (0 < sgnx (poly p) (at_right a));\n     sgnx (poly p) (at_left x) = 1 \\<or> sgnx (poly p) (at_left x) = - 1;\n     sgnx (poly p) (at_right x) = 1 \\<or>\n     sgnx (poly p) (at_right x) = - 1\\<rbrakk>\n    \\<Longrightarrow> (if even (order x p) then sgnx (poly p) (at_right x)\n                       else - sgnx (poly p) (at_right x)) =\n                      sgn (poly q x)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left x) = sgn (poly q x)\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_left x) = sgn (poly q x)", "have \"(poly p has_sgnx sgn (poly q x)) (at_left x)\""], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_left x) = sgn (poly q x)\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx sgn (poly q x)) (at_left x)", "by (metis sgnx_able_poly(2) sgnx_able_sgnx)"], ["proof (state)\nthis:\n  (poly p has_sgnx sgn (poly q x)) (at_left x)\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx sgn (poly q x)) (at_left x)", "have \"LIM x at_left x. poly q x / poly p x :> at_top\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx sgn (poly q x)) (at_left x)\n\ngoal (1 subgoal):\n 1. LIM x at_left x. poly q x / poly p x :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"poly q x\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (poly p has_sgnx sgn (poly q x)) (at_left x) \\<Longrightarrow>\n    (poly q \\<longlongrightarrow> poly q x) (at_left x)\n 2. (poly p has_sgnx sgn (poly q x)) (at_left x) \\<Longrightarrow>\n    poly q x \\<noteq> 0\n 3. (poly p has_sgnx sgn (poly q x)) (at_left x) \\<Longrightarrow>\n    (poly p \\<longlongrightarrow> 0) (at_left x) \\<and>\n    (poly p has_sgnx sgn (poly q x)) (at_left x)", "apply (auto simp add:\\<open>poly q x\\<noteq>0\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx sgn (poly q x)) (at_left x) \\<Longrightarrow>\n    (poly p \\<longlongrightarrow> 0) (at_left x)", "by (metis asm(3) poly_tendsto(2))"], ["proof (state)\nthis:\n  LIM x at_left x. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_left x. poly q x / poly p x :> at_top", "have \"jumpF_polyL q p x = 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_left x. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x = 1 / 2", "unfolding jumpF_polyL_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left x. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM x at_left x. poly q x / poly p x :> at_top then 1 / 2\n     else if LIM x at_left x. poly q x / poly p x :> at_bot then - 1 / 2\n          else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p x = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF_polyL q p x = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyL q p x = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "using that False"], ["proof (prove)\nusing this:\n  jumpF_polyL q p x = 1 / 2\n  even (order x p) = (sign_r_pos p x = (0 < poly q x))\n  \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n        else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  even (order x p) = (sign_r_pos p x = (0 < poly q x)) \\<Longrightarrow>\n  jumpF_polyL q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n        else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  even (order x p) = (sign_r_pos p x = (0 < poly q x)) \\<Longrightarrow>\n  jumpF_polyL q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n        else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "have ?thesis when \"\\<not> (even (order x p) \\<longleftrightarrow> sign_r_pos p x \\<longleftrightarrow> poly q x>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "consider (lt) \"poly q x>0\" | (gt) \" poly q x<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly q x \\<Longrightarrow> thesis;\n     poly q x < 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using \\<open>poly q x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly q x \\<Longrightarrow> thesis;\n     poly q x < 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>0 < poly q x \\<Longrightarrow> ?thesis;\n   poly q x < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < poly q x \\<Longrightarrow> ?thesis;\n   poly q x < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"sgnx (poly p) (at_left x) = - sgn (poly q x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < poly q x \\<Longrightarrow> ?thesis;\n   poly q x < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_left x) = - sgn (poly q x)", "apply cases"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < poly q x \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = - sgn (poly q x)\n 2. poly q x < 0 \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = - sgn (poly q x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly q x \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = - sgn (poly q x)", "using that sign_r_pos_sgnx_iff poly_sgnx_values[OF \\<open>p\\<noteq>0\\<close>,of x]"], ["proof (prove)\nusing this:\n  even (order x p) \\<noteq> (sign_r_pos p x = (0 < poly q x))\n  sign_r_pos ?p ?a = (0 < sgnx (poly ?p) (at_right ?a))\n  sgnx (poly p) (at_left x) = 1 \\<or> sgnx (poly p) (at_left x) = - 1\n  sgnx (poly p) (at_right x) = 1 \\<or> sgnx (poly p) (at_right x) = - 1\n\ngoal (1 subgoal):\n 1. 0 < poly q x \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = - sgn (poly q x)", "apply (subst poly_sgnx_left_right[OF \\<open>p\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly q x;\n     even (order x p) \\<noteq> (sign_r_pos p x = (0 < poly q x));\n     \\<And>p a. sign_r_pos p a = (0 < sgnx (poly p) (at_right a));\n     sgnx (poly p) (at_left x) = 1 \\<or> sgnx (poly p) (at_left x) = - 1;\n     sgnx (poly p) (at_right x) = 1 \\<or>\n     sgnx (poly p) (at_right x) = - 1\\<rbrakk>\n    \\<Longrightarrow> (if even (order x p) then sgnx (poly p) (at_right x)\n                       else - sgnx (poly p) (at_right x)) =\n                      - sgn (poly q x)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x < 0 \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = - sgn (poly q x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x < 0 \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = - sgn (poly q x)", "using that sign_r_pos_sgnx_iff poly_sgnx_values[OF \\<open>p\\<noteq>0\\<close>,of x]"], ["proof (prove)\nusing this:\n  even (order x p) \\<noteq> (sign_r_pos p x = (0 < poly q x))\n  sign_r_pos ?p ?a = (0 < sgnx (poly ?p) (at_right ?a))\n  sgnx (poly p) (at_left x) = 1 \\<or> sgnx (poly p) (at_left x) = - 1\n  sgnx (poly p) (at_right x) = 1 \\<or> sgnx (poly p) (at_right x) = - 1\n\ngoal (1 subgoal):\n 1. poly q x < 0 \\<Longrightarrow>\n    sgnx (poly p) (at_left x) = - sgn (poly q x)", "apply (subst poly_sgnx_left_right[OF \\<open>p\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly q x < 0;\n     even (order x p) \\<noteq> (sign_r_pos p x = (0 < poly q x));\n     \\<And>p a. sign_r_pos p a = (0 < sgnx (poly p) (at_right a));\n     sgnx (poly p) (at_left x) = 1 \\<or> sgnx (poly p) (at_left x) = - 1;\n     sgnx (poly p) (at_right x) = 1 \\<or>\n     sgnx (poly p) (at_right x) = - 1\\<rbrakk>\n    \\<Longrightarrow> (if even (order x p) then sgnx (poly p) (at_right x)\n                       else - sgnx (poly p) (at_right x)) =\n                      - sgn (poly q x)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sgnx (poly p) (at_left x) = - sgn (poly q x)\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_left x) = - sgn (poly q x)", "have \"(poly p has_sgnx - sgn (poly q x)) (at_left x)\""], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_left x) = - sgn (poly q x)\n\ngoal (1 subgoal):\n 1. (poly p has_sgnx - sgn (poly q x)) (at_left x)", "by (metis sgnx_able_poly(2) sgnx_able_sgnx)"], ["proof (state)\nthis:\n  (poly p has_sgnx - sgn (poly q x)) (at_left x)\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  (poly p has_sgnx - sgn (poly q x)) (at_left x)", "have \"LIM x at_left x. poly q x / poly p x :> at_bot\""], ["proof (prove)\nusing this:\n  (poly p has_sgnx - sgn (poly q x)) (at_left x)\n\ngoal (1 subgoal):\n 1. LIM x at_left x. poly q x / poly p x :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"poly q x\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (poly p has_sgnx - sgn (poly q x)) (at_left x) \\<Longrightarrow>\n    (poly q \\<longlongrightarrow> poly q x) (at_left x)\n 2. (poly p has_sgnx - sgn (poly q x)) (at_left x) \\<Longrightarrow>\n    poly q x \\<noteq> 0\n 3. (poly p has_sgnx - sgn (poly q x)) (at_left x) \\<Longrightarrow>\n    (poly p \\<longlongrightarrow> 0) (at_left x) \\<and>\n    (poly p has_sgnx - sgn (poly q x)) (at_left x)", "apply (auto simp add:\\<open>poly q x\\<noteq>0\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p has_sgnx - sgn (poly q x)) (at_left x) \\<Longrightarrow>\n    (poly p \\<longlongrightarrow> 0) (at_left x)", "by (metis asm(3) poly_tendsto(2))"], ["proof (state)\nthis:\n  LIM x at_left x. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_left x. poly q x / poly p x :> at_bot", "have \"jumpF_polyL q p x = - 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_left x. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x = - 1 / 2", "unfolding jumpF_polyL_def jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_left x. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM x at_left x. poly q x / poly p x :> at_top then 1 / 2\n     else if LIM x at_left x. poly q x / poly p x :> at_bot then - 1 / 2\n          else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p x = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF_polyL q p x = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyL q p x = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "using that False"], ["proof (prove)\nusing this:\n  jumpF_polyL q p x = - 1 / 2\n  even (order x p) \\<noteq> (sign_r_pos p x = (0 < poly q x))\n  \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n        else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  even (order x p) \\<noteq>\n  (sign_r_pos p x = (0 < poly q x)) \\<Longrightarrow>\n  jumpF_polyL q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n        else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0 \\<or> poly p x \\<noteq> 0) \\<Longrightarrow>\n    jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  even (order x p) = (sign_r_pos p x = (0 < poly q x)) \\<Longrightarrow>\n  jumpF_polyL q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n        else - 1 / 2\n   else 0)\n  even (order x p) \\<noteq>\n  (sign_r_pos p x = (0 < poly q x)) \\<Longrightarrow>\n  jumpF_polyL q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n        else - 1 / 2\n   else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  even (order x p) = (sign_r_pos p x = (0 < poly q x)) \\<Longrightarrow>\n  jumpF_polyL q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n        else - 1 / 2\n   else 0)\n  even (order x p) \\<noteq>\n  (sign_r_pos p x = (0 < poly q x)) \\<Longrightarrow>\n  jumpF_polyL q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n        else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p x =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n   then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n        else - 1 / 2\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_times:\n  assumes tendsto:\"(f \\<longlongrightarrow> c) F\" and \"c\\<noteq>0\" \"F\\<noteq>bot\"\n  shows \"jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "have \"c>0 \\<or> c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c \\<or> c < 0", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < c \\<or> c < 0", "by auto"], ["proof (state)\nthis:\n  0 < c \\<or> c < 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "moreover"], ["proof (state)\nthis:\n  0 < c \\<or> c < 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "have ?thesis when \"c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "note filterlim_tendsto_pos_mult_at_top_iff[OF tendsto \\<open>c>0\\<close>,of g]"], ["proof (state)\nthis:\n  (LIM x F. f x * g x :> at_top) = filterlim g at_top F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "moreover"], ["proof (state)\nthis:\n  (LIM x F. f x * g x :> at_top) = filterlim g at_top F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "note filterlim_tendsto_pos_mult_at_bot_iff[OF tendsto \\<open>c>0\\<close>,of g]"], ["proof (state)\nthis:\n  (LIM x F. f x * g x :> at_bot) = filterlim g at_bot F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "moreover"], ["proof (state)\nthis:\n  (LIM x F. f x * g x :> at_bot) = filterlim g at_bot F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "have \"sgn c = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn c = 1", "using \\<open>c>0\\<close>"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. sgn c = 1", "by auto"], ["proof (state)\nthis:\n  sgn c = 1\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "ultimately"], ["proof (chain)\npicking this:\n  (LIM x F. f x * g x :> at_top) = filterlim g at_top F\n  (LIM x F. f x * g x :> at_bot) = filterlim g at_bot F\n  sgn c = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  (LIM x F. f x * g x :> at_top) = filterlim g at_top F\n  (LIM x F. f x * g x :> at_bot) = filterlim g at_bot F\n  sgn c = 1\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  (LIM x F. f x * g x :> at_top) = filterlim g at_top F\n  (LIM x F. f x * g x :> at_bot) = filterlim g at_bot F\n  sgn c = 1\n\ngoal (1 subgoal):\n 1. (if LIM x F. f x * g x :> at_top then 1 / 2\n     else if LIM x F. f x * g x :> at_bot then - 1 / 2 else 0) =\n    sgn c *\n    (if filterlim g at_top F then 1 / 2\n     else if filterlim g at_bot F then - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c \\<Longrightarrow>\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "moreover"], ["proof (state)\nthis:\n  0 < c \\<Longrightarrow>\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "have ?thesis when \"c<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "define atbot where \"atbot = filterlim g at_bot F\""], ["proof (state)\nthis:\n  atbot = filterlim g at_bot F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "define attop where \"attop = filterlim g at_top F\""], ["proof (state)\nthis:\n  attop = filterlim g at_top F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "have \"jumpF (\\<lambda>x. f x * g x) F = (if atbot then 1 / 2 else if attop then - 1 / 2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F =\n    (if atbot then 1 / 2 else if attop then - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F =\n    (if atbot then 1 / 2 else if attop then - 1 / 2 else 0)", "note filterlim_tendsto_neg_mult_at_top_iff[OF tendsto \\<open>c<0\\<close>,of g]"], ["proof (state)\nthis:\n  (LIM x F. f x * g x :> at_top) = filterlim g at_bot F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F =\n    (if atbot then 1 / 2 else if attop then - 1 / 2 else 0)", "moreover"], ["proof (state)\nthis:\n  (LIM x F. f x * g x :> at_top) = filterlim g at_bot F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F =\n    (if atbot then 1 / 2 else if attop then - 1 / 2 else 0)", "note filterlim_tendsto_neg_mult_at_bot_iff[OF tendsto \\<open>c<0\\<close>,of g]"], ["proof (state)\nthis:\n  (LIM x F. f x * g x :> at_bot) = filterlim g at_top F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F =\n    (if atbot then 1 / 2 else if attop then - 1 / 2 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  (LIM x F. f x * g x :> at_top) = filterlim g at_bot F\n  (LIM x F. f x * g x :> at_bot) = filterlim g at_top F", "show ?thesis"], ["proof (prove)\nusing this:\n  (LIM x F. f x * g x :> at_top) = filterlim g at_bot F\n  (LIM x F. f x * g x :> at_bot) = filterlim g at_top F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F =\n    (if atbot then 1 / 2 else if attop then - 1 / 2 else 0)", "unfolding jumpF_def atbot_def attop_def"], ["proof (prove)\nusing this:\n  (LIM x F. f x * g x :> at_top) = filterlim g at_bot F\n  (LIM x F. f x * g x :> at_bot) = filterlim g at_top F\n\ngoal (1 subgoal):\n 1. (if LIM x F. f x * g x :> at_top then 1 / 2\n     else if LIM x F. f x * g x :> at_bot then - 1 / 2 else 0) =\n    (if filterlim g at_bot F then 1 / 2\n     else if filterlim g at_top F then - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x * g x) F =\n  (if atbot then 1 / 2 else if attop then - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x * g x) F =\n  (if atbot then 1 / 2 else if attop then - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "also"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x * g x) F =\n  (if atbot then 1 / 2 else if attop then - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "have \"... = - (if attop then 1 / 2 else if atbot then - 1 / 2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if atbot then 1 / 2 else if attop then - 1 / 2 else 0) =\n    - (if attop then 1 / 2 else if atbot then - 1 / 2 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if atbot then 1 / 2 else if attop then - 1 / 2 else 0) =\n    - (if attop then 1 / 2 else if atbot then - 1 / 2 else 0)", "have False when atbot attop"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using filterlim_at_top_at_bot[OF _ _ \\<open>F\\<noteq>bot\\<close>] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>filterlim ?f at_top F; filterlim ?f at_bot F\\<rbrakk>\n  \\<Longrightarrow> False\n  atbot\n  attop\n\ngoal (1 subgoal):\n 1. False", "unfolding atbot_def attop_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>filterlim ?f at_top F; filterlim ?f at_bot F\\<rbrakk>\n  \\<Longrightarrow> False\n  filterlim g at_bot F\n  filterlim g at_top F\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>atbot; attop\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (if atbot then 1 / 2 else if attop then - 1 / 2 else 0) =\n    - (if attop then 1 / 2 else if atbot then - 1 / 2 else 0)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>atbot; attop\\<rbrakk> \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>atbot; attop\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (if atbot then 1 / 2 else if attop then - 1 / 2 else 0) =\n    - (if attop then 1 / 2 else if atbot then - 1 / 2 else 0)", "by fastforce"], ["proof (state)\nthis:\n  (if atbot then 1 / 2 else if attop then - 1 / 2 else 0) =\n  - (if attop then 1 / 2 else if atbot then - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if atbot then 1 / 2 else if attop then - 1 / 2 else 0) =\n  - (if attop then 1 / 2 else if atbot then - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "also"], ["proof (state)\nthis:\n  (if atbot then 1 / 2 else if attop then - 1 / 2 else 0) =\n  - (if attop then 1 / 2 else if atbot then - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "have \"... = sgn c * jumpF g F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (if attop then 1 / 2 else if atbot then - 1 / 2 else 0) =\n    sgn c * jumpF g F", "using \\<open>c<0\\<close>"], ["proof (prove)\nusing this:\n  c < 0\n\ngoal (1 subgoal):\n 1. - (if attop then 1 / 2 else if atbot then - 1 / 2 else 0) =\n    sgn c * jumpF g F", "unfolding jumpF_def attop_def atbot_def"], ["proof (prove)\nusing this:\n  c < 0\n\ngoal (1 subgoal):\n 1. - (if filterlim g at_top F then 1 / 2\n       else if filterlim g at_bot F then - 1 / 2 else 0) =\n    sgn c *\n    (if filterlim g at_top F then 1 / 2\n     else if filterlim g at_bot F then - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  - (if attop then 1 / 2 else if atbot then - 1 / 2 else 0) =\n  sgn c * jumpF g F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "finally"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "."], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c < 0 \\<Longrightarrow>\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "ultimately"], ["proof (chain)\npicking this:\n  0 < c \\<or> c < 0\n  0 < c \\<Longrightarrow>\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\n  c < 0 \\<Longrightarrow>\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < c \\<or> c < 0\n  0 < c \\<Longrightarrow>\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\n  c < 0 \\<Longrightarrow>\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x * g x) F = sgn c * jumpF g F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_polyR_inverse_add:\n  assumes \"coprime p q\"\n  shows \"jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q*p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "proof (cases \"p=0 \\<or> q=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "case True"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  p = 0 \\<or> q = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> q = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "have jumpF_add:\n    \"jumpF_polyR q p x= jumpF_polyR 1 (q*p) x\" when \"poly p x=0\" \"coprime p q\" for p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> jumpF_polyR q p x = jumpF_polyR 1 (q * p) x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> jumpF_polyR q p x = jumpF_polyR 1 (q * p) x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p x = jumpF_polyR 1 (q * p) x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "have \"poly q x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "using that coprime_poly_0"], ["proof (prove)\nusing this:\n  poly p x = 0\n  coprime p q\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  poly q x \\<noteq> 0", "have \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "moreover"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "have \"sign_r_pos p x = (0 < poly q x) \\<longleftrightarrow> sign_r_pos (q * p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x", "using sign_r_pos_mult[OF \\<open>q\\<noteq>0\\<close> \\<open>p\\<noteq>0\\<close>] sign_r_pos_rec[OF \\<open>q\\<noteq>0\\<close>] \\<open>poly q x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos (q * p) ?x = (sign_r_pos q ?x = sign_r_pos p ?x)\n  sign_r_pos q ?x =\n  (if poly q ?x = 0 then sign_r_pos (pderiv q) ?x else 0 < poly q ?x)\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x", "by auto"], ["proof (state)\nthis:\n  (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "ultimately"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "using \\<open>poly p x=0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x = jumpF_polyR 1 (q * p) x", "unfolding jumpF_polyR_coprime[OF \\<open>coprime p q\\<close>,of x] jumpF_polyR_coprime[of \"q*p\" 1 x,simplified]"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if sign_r_pos p x = (0 < poly q x) then 1 / 2 else - 1 / 2\n     else 0) =\n    (if q \\<noteq> 0 \\<and>\n        p \\<noteq> 0 \\<and> (poly q x = 0 \\<or> poly p x = 0)\n     then if sign_r_pos (q * p) x = (0 < poly 1 x) then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p x = jumpF_polyR 1 (q * p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly ?p x = 0; coprime ?p ?q\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR ?q ?p x = jumpF_polyR 1 (?q * ?p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "have False when \"poly p x=0\" \"poly q x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using \\<open>coprime p q\\<close> that coprime_poly_0"], ["proof (prove)\nusing this:\n  coprime p q\n  poly p x = 0\n  poly q x = 0\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x = 0; poly q x = 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x = 0; poly q x = 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "have ?thesis when \"poly p x=0\" \"poly q x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "have \"jumpF_polyR p q x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR p q x = 0", "using jumpF_poly_noroot[OF \\<open>poly q x\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  jumpF_polyL ?q q x = 0\n  jumpF_polyR ?q q x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR p q x = 0", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR p q x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  jumpF_polyR p q x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyR p q x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "using jumpF_add[OF \\<open>poly p x=0\\<close> \\<open>coprime p q\\<close>]"], ["proof (prove)\nusing this:\n  jumpF_polyR p q x = 0\n  jumpF_polyR q p x = jumpF_polyR 1 (q * p) x\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x = 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR q p x + jumpF_polyR p q x =\n                    jumpF_polyR 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x = 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR q p x + jumpF_polyR p q x =\n                    jumpF_polyR 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "have ?thesis when \"poly p x\\<noteq>0\" \"poly q x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "have \"jumpF_polyR q p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x = 0", "using jumpF_poly_noroot[OF \\<open>poly p x\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  jumpF_polyL ?q p x = 0\n  jumpF_polyR ?q p x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x = 0", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  jumpF_polyR q p x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyR q p x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "using jumpF_add[OF \\<open>poly q x=0\\<close>,of p] \\<open>coprime p q\\<close>"], ["proof (prove)\nusing this:\n  jumpF_polyR q p x = 0\n  coprime q p \\<Longrightarrow> jumpF_polyR p q x = jumpF_polyR 1 (p * q) x\n  coprime p q\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR q p x + jumpF_polyR p q x =\n                    jumpF_polyR 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR q p x + jumpF_polyR p q x =\n                    jumpF_polyR 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "have ?thesis when \"poly p x\\<noteq>0\" \"poly q x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "by (simp add: jumpF_poly_noroot(2) that(1) that(2))"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR q p x + jumpF_polyR p q x =\n                    jumpF_polyR 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>poly p x = 0; poly q x = 0\\<rbrakk> \\<Longrightarrow> False\n  \\<lbrakk>poly p x = 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR q p x + jumpF_polyR p q x =\n                    jumpF_polyR 1 (q * p) x\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR q p x + jumpF_polyR p q x =\n                    jumpF_polyR 1 (q * p) x\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR q p x + jumpF_polyR p q x =\n                    jumpF_polyR 1 (q * p) x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>poly p x = 0; poly q x = 0\\<rbrakk> \\<Longrightarrow> False\n  \\<lbrakk>poly p x = 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR q p x + jumpF_polyR p q x =\n                    jumpF_polyR 1 (q * p) x\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR q p x + jumpF_polyR p q x =\n                    jumpF_polyR 1 (q * p) x\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR q p x + jumpF_polyR p q x =\n                    jumpF_polyR 1 (q * p) x\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p x + jumpF_polyR p q x = jumpF_polyR 1 (q * p) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_polyL_inverse_add:\n  assumes \"coprime p q\"\n  shows \"jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q*p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "proof (cases \"p=0 \\<or> q=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "case True"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  p = 0 \\<or> q = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> q = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "have jumpF_add:\n    \"jumpF_polyL q p x= jumpF_polyL 1 (q*p) x\" when \"poly p x=0\" \"coprime p q\" for p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> jumpF_polyL q p x = jumpF_polyL 1 (q * p) x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> jumpF_polyL q p x = jumpF_polyL 1 (q * p) x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p x = jumpF_polyL 1 (q * p) x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "have \"poly q x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "using that coprime_poly_0"], ["proof (prove)\nusing this:\n  poly p x = 0\n  coprime p q\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. poly q x \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  poly q x \\<noteq> 0", "have \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "moreover"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "have \"sign_r_pos p x = (0 < poly q x) \\<longleftrightarrow> sign_r_pos (q * p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x", "using sign_r_pos_mult[OF \\<open>q\\<noteq>0\\<close> \\<open>p\\<noteq>0\\<close>] sign_r_pos_rec[OF \\<open>q\\<noteq>0\\<close>] \\<open>poly q x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos (q * p) ?x = (sign_r_pos q ?x = sign_r_pos p ?x)\n  sign_r_pos q ?x =\n  (if poly q ?x = 0 then sign_r_pos (pderiv q) ?x else 0 < poly q ?x)\n  poly q x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x", "by auto"], ["proof (state)\nthis:\n  (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "moreover"], ["proof (state)\nthis:\n  (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "have \"order x p = order x (q * p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = order x (q * p)", "by (metis \\<open>poly q x \\<noteq> 0\\<close> add_cancel_right_left divisors_zero order_mult order_root)"], ["proof (state)\nthis:\n  order x p = order x (q * p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "ultimately"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x\n  order x p = order x (q * p)", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x\n  order x p = order x (q * p)\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "using \\<open>poly p x=0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x\n  order x p = order x (q * p)\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x = jumpF_polyL 1 (q * p) x", "unfolding jumpF_polyL_coprime[OF \\<open>coprime p q\\<close>,of x] jumpF_polyL_coprime[of \"q*p\" 1 x,simplified]"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  (sign_r_pos p x = (0 < poly q x)) = sign_r_pos (q * p) x\n  order x p = order x (q * p)\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> poly p x = 0\n     then if even (order x p) = (sign_r_pos p x = (0 < poly q x)) then 1 / 2\n          else - 1 / 2\n     else 0) =\n    (if q \\<noteq> 0 \\<and>\n        p \\<noteq> 0 \\<and> (poly q x = 0 \\<or> poly p x = 0)\n     then if even (order x (q * p)) =\n             (sign_r_pos (q * p) x = (0 < poly 1 x))\n          then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p x = jumpF_polyL 1 (q * p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly ?p x = 0; coprime ?p ?q\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL ?q ?p x = jumpF_polyL 1 (?q * ?p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "have False when \"poly p x=0\" \"poly q x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using \\<open>coprime p q\\<close> that coprime_poly_0"], ["proof (prove)\nusing this:\n  coprime p q\n  poly p x = 0\n  poly q x = 0\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x = 0; poly q x = 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x = 0; poly q x = 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "have ?thesis when \"poly p x=0\" \"poly q x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "have \"jumpF_polyL p q x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL p q x = 0", "using jumpF_poly_noroot[OF \\<open>poly q x\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  jumpF_polyL ?q q x = 0\n  jumpF_polyR ?q q x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL p q x = 0", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL p q x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  jumpF_polyL p q x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyL p q x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "using jumpF_add[OF \\<open>poly p x=0\\<close> \\<open>coprime p q\\<close>]"], ["proof (prove)\nusing this:\n  jumpF_polyL p q x = 0\n  jumpF_polyL q p x = jumpF_polyL 1 (q * p) x\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x = 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL q p x + jumpF_polyL p q x =\n                    jumpF_polyL 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x = 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL q p x + jumpF_polyL p q x =\n                    jumpF_polyL 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "have ?thesis when \"poly p x\\<noteq>0\" \"poly q x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "have \"jumpF_polyL q p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x = 0", "using jumpF_poly_noroot[OF \\<open>poly p x\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  jumpF_polyL ?q p x = 0\n  jumpF_polyR ?q p x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x = 0", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "then"], ["proof (chain)\npicking this:\n  jumpF_polyL q p x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyL q p x = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "using jumpF_add[OF \\<open>poly q x=0\\<close>,of p] \\<open>coprime p q\\<close>"], ["proof (prove)\nusing this:\n  jumpF_polyL q p x = 0\n  coprime q p \\<Longrightarrow> jumpF_polyL p q x = jumpF_polyL 1 (p * q) x\n  coprime p q\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL q p x + jumpF_polyL p q x =\n                    jumpF_polyL 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL q p x + jumpF_polyL p q x =\n                    jumpF_polyL 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "have ?thesis when \"poly p x\\<noteq>0\" \"poly q x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "by (simp add: jumpF_poly_noroot that(1) that(2))"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL q p x + jumpF_polyL p q x =\n                    jumpF_polyL 1 (q * p) x\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>poly p x = 0; poly q x = 0\\<rbrakk> \\<Longrightarrow> False\n  \\<lbrakk>poly p x = 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL q p x + jumpF_polyL p q x =\n                    jumpF_polyL 1 (q * p) x\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL q p x + jumpF_polyL p q x =\n                    jumpF_polyL 1 (q * p) x\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL q p x + jumpF_polyL p q x =\n                    jumpF_polyL 1 (q * p) x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>poly p x = 0; poly q x = 0\\<rbrakk> \\<Longrightarrow> False\n  \\<lbrakk>poly p x = 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL q p x + jumpF_polyL p q x =\n                    jumpF_polyL 1 (q * p) x\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x = 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL q p x + jumpF_polyL p q x =\n                    jumpF_polyL 1 (q * p) x\n  \\<lbrakk>poly p x \\<noteq> 0; poly q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyL q p x + jumpF_polyL p q x =\n                    jumpF_polyL 1 (q * p) x\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p x + jumpF_polyL p q x = jumpF_polyL 1 (q * p) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_polyL_smult_1:\n  \"jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x", "proof (cases \"c=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x", "then"], ["proof (chain)\npicking this:\n  c \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x", "unfolding jumpF_polyL_def"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly (smult c q) x / poly p x) (at_left x) =\n    sgn c * jumpF (\\<lambda>x. poly q x / poly p x) (at_left x)", "apply (subst jumpF_times[of \"\\<lambda>_. c\",symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>_. c) \\<longlongrightarrow> c) (at_left x)\n 2. c \\<noteq> 0 \\<Longrightarrow> c \\<noteq> 0\n 3. c \\<noteq> 0 \\<Longrightarrow> at_left x \\<noteq> bot\n 4. c \\<noteq> 0 \\<Longrightarrow>\n    jumpF (\\<lambda>x. poly (smult c q) x / poly p x) (at_left x) =\n    jumpF (\\<lambda>x. c * (poly q x / poly p x)) (at_left x)", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL (smult c q) p x = sgn c * jumpF_polyL q p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_polyR_smult_1:\n  \"jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x", "proof (cases \"c=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x", "then"], ["proof (chain)\npicking this:\n  c \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x", "unfolding jumpF_polyR_def"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly (smult c q) x / poly p x) (at_right x) =\n    sgn c * jumpF (\\<lambda>x. poly q x / poly p x) (at_right x)", "using False"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly (smult c q) x / poly p x) (at_right x) =\n    sgn c * jumpF (\\<lambda>x. poly q x / poly p x) (at_right x)", "apply (subst jumpF_times[of \"\\<lambda>_. c\",symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>c \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>_. c) \\<longlongrightarrow> c) (at_right x)\n 2. \\<lbrakk>c \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> c \\<noteq> 0\n 3. \\<lbrakk>c \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> at_right x \\<noteq> bot\n 4. \\<lbrakk>c \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> jumpF (\\<lambda>x. poly (smult c q) x / poly p x)\n                       (at_right x) =\n                      jumpF (\\<lambda>x. c * (poly q x / poly p x))\n                       (at_right x)", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR (smult c q) p x = sgn c * jumpF_polyR q p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  shows jumpF_polyR_mod:\"jumpF_polyR q p x = jumpF_polyR (q mod p) p x\" and\n        jumpF_polyL_mod:\"jumpF_polyL q p x = jumpF_polyL (q mod p) p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x = jumpF_polyR (q mod p) p x &&&\n    jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF_polyR q p x = jumpF_polyR (q mod p) p x\n 2. jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "define f where \"f=(\\<lambda>x. poly (q div p) x)\""], ["proof (state)\nthis:\n  f = poly (q div p)\n\ngoal (2 subgoals):\n 1. jumpF_polyR q p x = jumpF_polyR (q mod p) p x\n 2. jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "define g where \"g=(\\<lambda>x. poly (q mod p) x / poly p x)\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. poly (q mod p) x / poly p x)\n\ngoal (2 subgoals):\n 1. jumpF_polyR q p x = jumpF_polyR (q mod p) p x\n 2. jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "have jumpF_eq:\"jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) = jumpF g (at y within S)\" \n    when \"p\\<noteq>0\" for y S"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n    jumpF g (at y within S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n    jumpF g (at y within S)", "let ?F = \"at y within S\""], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n    jumpF g (at y within S)", "have \"\\<forall>\\<^sub>F x in at y within S. poly p x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at y within S. poly p x \\<noteq> 0", "using eventually_poly_nz_at_within[OF \\<open>p\\<noteq>0\\<close>,of y S]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at y within S. poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at y within S. poly p x \\<noteq> 0", "."], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at y within S. poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n    jumpF g (at y within S)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at y within S. poly p x \\<noteq> 0", "have \"eventually (\\<lambda>x. (poly q x / poly p x) = (f x+ g x)) ?F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at y within S. poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at y within S. poly q x / poly p x = f x + g x", "proof (rule eventually_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x \\<noteq> 0 \\<Longrightarrow> poly q x / poly p x = f x + g x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x \\<noteq> 0 \\<Longrightarrow> poly q x / poly p x = f x + g x", "assume P: \"poly p x \\<noteq> 0\""], ["proof (state)\nthis:\n  poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x \\<noteq> 0 \\<Longrightarrow> poly q x / poly p x = f x + g x", "have \"poly q x = poly (q div p * p + q mod p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x = poly (q div p * p + q mod p) x", "by simp"], ["proof (state)\nthis:\n  poly q x = poly (q div p * p + q mod p) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x \\<noteq> 0 \\<Longrightarrow> poly q x / poly p x = f x + g x", "also"], ["proof (state)\nthis:\n  poly q x = poly (q div p * p + q mod p) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x \\<noteq> 0 \\<Longrightarrow> poly q x / poly p x = f x + g x", "have \"\\<dots> = f x * poly p x + poly (q mod p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (q div p * p + q mod p) x = f x * poly p x + poly (q mod p) x", "by (simp only: poly_add poly_mult f_def g_def)"], ["proof (state)\nthis:\n  poly (q div p * p + q mod p) x = f x * poly p x + poly (q mod p) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x \\<noteq> 0 \\<Longrightarrow> poly q x / poly p x = f x + g x", "moreover"], ["proof (state)\nthis:\n  poly (q div p * p + q mod p) x = f x * poly p x + poly (q mod p) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x \\<noteq> 0 \\<Longrightarrow> poly q x / poly p x = f x + g x", "have \"poly (q mod p) x = g x * poly p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (q mod p) x = g x * poly p x", "using P"], ["proof (prove)\nusing this:\n  poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (q mod p) x = g x * poly p x", "by (simp add: g_def)"], ["proof (state)\nthis:\n  poly (q mod p) x = g x * poly p x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       poly p x \\<noteq> 0 \\<Longrightarrow> poly q x / poly p x = f x + g x", "ultimately"], ["proof (chain)\npicking this:\n  poly q x = poly (q div p * p + q mod p) x\n  poly (q div p * p + q mod p) x = f x * poly p x + poly (q mod p) x\n  poly (q mod p) x = g x * poly p x", "show \"poly q x / poly p x = f x + g x\""], ["proof (prove)\nusing this:\n  poly q x = poly (q div p * p + q mod p) x\n  poly (q div p * p + q mod p) x = f x * poly p x + poly (q mod p) x\n  poly (q mod p) x = g x * poly p x\n\ngoal (1 subgoal):\n 1. poly q x / poly p x = f x + g x", "using P"], ["proof (prove)\nusing this:\n  poly q x = poly (q div p * p + q mod p) x\n  poly (q div p * p + q mod p) x = f x * poly p x + poly (q mod p) x\n  poly (q mod p) x = g x * poly p x\n  poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q x / poly p x = f x + g x", "by simp"], ["proof (state)\nthis:\n  poly q x / poly p x = f x + g x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at y within S. poly q x / poly p x = f x + g x\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n    jumpF g (at y within S)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at y within S. poly q x / poly p x = f x + g x", "have \"jumpF (\\<lambda>x. poly q x / poly p x) ?F = jumpF (\\<lambda>x. f x+ g x) ?F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at y within S. poly q x / poly p x = f x + g x\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n    jumpF (\\<lambda>x. f x + g x) (at y within S)", "by (intro jumpF_cong,auto)"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n  jumpF (\\<lambda>x. f x + g x) (at y within S)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n    jumpF g (at y within S)", "also"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n  jumpF (\\<lambda>x. f x + g x) (at y within S)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n    jumpF g (at y within S)", "have \"... = jumpF g ?F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x + g x) (at y within S) = jumpF g (at y within S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x + g x) (at y within S) = jumpF g (at y within S)", "have \"(f \\<longlongrightarrow> f y) (at y within S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f y) (at y within S)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (q div p) \\<longlongrightarrow> poly (q div p) y) (at y within S)", "by (intro tendsto_intros)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f y) (at y within S)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x + g x) (at y within S) = jumpF g (at y within S)", "from filterlim_tendsto_add_at_bot_iff[OF this,of g] filterlim_tendsto_add_at_top_iff[OF this,of g]"], ["proof (chain)\npicking this:\n  (LIM x at y within S. f x + g x :> at_bot) =\n  filterlim g at_bot (at y within S)\n  (LIM x at y within S. f x + g x :> at_top) =\n  filterlim g at_top (at y within S)", "show ?thesis"], ["proof (prove)\nusing this:\n  (LIM x at y within S. f x + g x :> at_bot) =\n  filterlim g at_bot (at y within S)\n  (LIM x at y within S. f x + g x :> at_top) =\n  filterlim g at_top (at y within S)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x + g x) (at y within S) = jumpF g (at y within S)", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  (LIM x at y within S. f x + g x :> at_bot) =\n  filterlim g at_bot (at y within S)\n  (LIM x at y within S. f x + g x :> at_top) =\n  filterlim g at_top (at y within S)\n\ngoal (1 subgoal):\n 1. (if LIM x at y within S. f x + g x :> at_top then 1 / 2\n     else if LIM x at y within S. f x + g x :> at_bot then - 1 / 2 else 0) =\n    (if filterlim g at_top (at y within S) then 1 / 2\n     else if filterlim g at_bot (at y within S) then - 1 / 2 else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x + g x) (at y within S) = jumpF g (at y within S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x + g x) (at y within S) = jumpF g (at y within S)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n    jumpF g (at y within S)", "finally"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n  jumpF g (at y within S)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n  jumpF g (at y within S)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n    jumpF g (at y within S)", "."], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. poly q x / poly p x) (at y within S) =\n  jumpF g (at y within S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  jumpF (\\<lambda>x. poly q x / poly p x) (at ?y within ?S) =\n  jumpF g (at ?y within ?S)\n\ngoal (2 subgoals):\n 1. jumpF_polyR q p x = jumpF_polyR (q mod p) p x\n 2. jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "show \"jumpF_polyR q p x = jumpF_polyR (q mod p) p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x = jumpF_polyR (q mod p) p x", "apply (cases \"p=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> jumpF_polyR q p x = jumpF_polyR (q mod p) p x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR (q mod p) p x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> jumpF_polyR q p x = jumpF_polyR (q mod p) p x", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR (q mod p) p x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR (q mod p) p x", "using jumpF_eq"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  jumpF (\\<lambda>x. poly q x / poly p x) (at ?y within ?S) =\n  jumpF g (at ?y within ?S)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyR q p x = jumpF_polyR (q mod p) p x", "unfolding g_def jumpF_polyR_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  jumpF (\\<lambda>x. poly q x / poly p x) (at ?y within ?S) =\n  jumpF (\\<lambda>x. poly (q mod p) x / poly p x) (at ?y within ?S)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF (\\<lambda>x. poly q x / poly p x) (at_right x) =\n    jumpF (\\<lambda>x. poly (q mod p) x / poly p x) (at_right x)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  jumpF_polyR q p x = jumpF_polyR (q mod p) p x\n\ngoal (1 subgoal):\n 1. jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "show \"jumpF_polyL q p x = jumpF_polyL (q mod p) p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "apply (cases \"p=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> jumpF_polyL q p x = jumpF_polyL (q mod p) p x\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "using jumpF_eq"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  jumpF (\\<lambda>x. poly q x / poly p x) (at ?y within ?S) =\n  jumpF g (at ?y within ?S)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF_polyL q p x = jumpF_polyL (q mod p) p x", "unfolding g_def jumpF_polyL_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  jumpF (\\<lambda>x. poly q x / poly p x) (at ?y within ?S) =\n  jumpF (\\<lambda>x. poly (q mod p) x / poly p x) (at ?y within ?S)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    jumpF (\\<lambda>x. poly q x / poly p x) (at_left x) =\n    jumpF (\\<lambda>x. poly (q mod p) x / poly p x) (at_left x)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  jumpF_polyL q p x = jumpF_polyL (q mod p) p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_poly_top_0[simp]: \"jumpF_poly_top 0 p = 0\" \"jumpF_poly_top q 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_poly_top 0 p = 0 &&& jumpF_poly_top q 0 = 0", "unfolding jumpF_poly_top_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly 0 x / poly p x) at_top = 0 &&&\n    jumpF (\\<lambda>x. poly q x / poly 0 x) at_top = 0", "by auto"], ["", "lemma jumpF_poly_bot_0[simp]: \"jumpF_poly_bot 0 p = 0\" \"jumpF_poly_bot q 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_poly_bot 0 p = 0 &&& jumpF_poly_bot q 0 = 0", "unfolding jumpF_poly_bot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly 0 x / poly p x) at_bot = 0 &&&\n    jumpF (\\<lambda>x. poly q x / poly 0 x) at_bot = 0", "by auto"], ["", "lemma jumpF_poly_top_code:\n  \"jumpF_poly_top q p = (if p\\<noteq>0 \\<and> q\\<noteq>0 \\<and> degree q>degree p then \n          if sgn_pos_inf q * sgn_pos_inf p > 0 then 1/2 else -1/2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "proof (cases \"p\\<noteq>0 \\<and> q\\<noteq>0 \\<and> degree q>degree p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and>\n    q \\<noteq> 0 \\<and> degree p < degree q \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)\n 2. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "case True"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and>\n    q \\<noteq> 0 \\<and> degree p < degree q \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)\n 2. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"sgn_pos_inf q * sgn_pos_inf p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have \"LIM x at_top. poly q x / poly p x :> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> at_top", "using poly_divide_filterlim_at_top[of p q] True that"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> LIM x at_top.\n                       poly q x /\n                       poly p\n                        x :> if degree q < degree p then at 0\n                             else if degree q = degree p\n                                  then nhds (lead_coeff q / lead_coeff p)\n                                  else if 0 < sgn_pos_inf q * sgn_pos_inf p\n then at_top else at_bot\n  p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n  0 < sgn_pos_inf q * sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> at_top", "by auto"], ["proof (state)\nthis:\n  LIM x at_top. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_top. poly q x / poly p x :> at_top", "have \"jumpF (\\<lambda>x. poly q x / poly p x) at_top = 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_top = 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM x at_top. poly q x / poly p x :> at_top then 1 / 2\n     else if LIM x at_top. poly q x / poly p x :> at_bot then - 1 / 2\n          else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "unfolding jumpF_poly_top_def"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_top =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "using that True"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = 1 / 2\n  0 < sgn_pos_inf q * sgn_pos_inf p\n  p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_top =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_poly_top q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < sgn_pos_inf q * sgn_pos_inf p \\<Longrightarrow>\n  jumpF_poly_top q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and>\n    q \\<noteq> 0 \\<and> degree p < degree q \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)\n 2. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  0 < sgn_pos_inf q * sgn_pos_inf p \\<Longrightarrow>\n  jumpF_poly_top q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and>\n    q \\<noteq> 0 \\<and> degree p < degree q \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)\n 2. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"\\<not> sgn_pos_inf q * sgn_pos_inf p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have \"LIM x at_top. poly q x / poly p x :> at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> at_bot", "using poly_divide_filterlim_at_top[of p q] True that"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> LIM x at_top.\n                       poly q x /\n                       poly p\n                        x :> if degree q < degree p then at 0\n                             else if degree q = degree p\n                                  then nhds (lead_coeff q / lead_coeff p)\n                                  else if 0 < sgn_pos_inf q * sgn_pos_inf p\n then at_top else at_bot\n  p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n  \\<not> 0 < sgn_pos_inf q * sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_top. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_top. poly q x / poly p x :> at_bot", "have \"jumpF (\\<lambda>x. poly q x / poly p x) at_top = - 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_top = - 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM x at_top. poly q x / poly p x :> at_top then 1 / 2\n     else if LIM x at_top. poly q x / poly p x :> at_bot then - 1 / 2\n          else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "unfolding jumpF_poly_top_def"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_top =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "using that True"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = - 1 / 2\n  \\<not> 0 < sgn_pos_inf q * sgn_pos_inf p\n  p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_top =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_poly_top q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> 0 < sgn_pos_inf q * sgn_pos_inf p \\<Longrightarrow>\n  jumpF_poly_top q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and>\n    q \\<noteq> 0 \\<and> degree p < degree q \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)\n 2. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  0 < sgn_pos_inf q * sgn_pos_inf p \\<Longrightarrow>\n  jumpF_poly_top q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2 else 0)\n  \\<not> 0 < sgn_pos_inf q * sgn_pos_inf p \\<Longrightarrow>\n  jumpF_poly_top q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < sgn_pos_inf q * sgn_pos_inf p \\<Longrightarrow>\n  jumpF_poly_top q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2 else 0)\n  \\<not> 0 < sgn_pos_inf q * sgn_pos_inf p \\<Longrightarrow>\n  jumpF_poly_top q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_poly_top q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> (p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q)\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "define P where \"P= (\\<not> (LIM x at_top. poly q x / poly p x :> at_bot) \n                      \\<and> \\<not> (LIM x at_top. poly q x / poly p x :> at_top))\""], ["proof (state)\nthis:\n  P =\n  (\\<not> (LIM x at_top. poly q x / poly p x :> at_bot) \\<and>\n   \\<not> (LIM x at_top. poly q x / poly p x :> at_top))\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have P when \"p=0 \\<or> q=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_top. poly q x / poly p x :> at_bot) \\<and>\n    \\<not> (LIM x at_top. poly q x / poly p x :> at_top)", "using that"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0\n\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_top. poly q x / poly p x :> at_bot) \\<and>\n    \\<not> (LIM x at_top. poly q x / poly p x :> at_top)", "by (auto elim!:filterlim_at_bot_nhds filterlim_at_top_nhds)"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have P when \"p\\<noteq>0\" \"q\\<noteq>0\" \"degree p> degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have \"LIM x at_top. poly q x / poly p x :> at 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> at 0", "using poly_divide_filterlim_at_top[OF that(1,2)] that(3)"], ["proof (prove)\nusing this:\n  LIM x at_top.\n     poly q x /\n     poly p\n      x :> if degree q < degree p then at 0\n           else if degree q = degree p\n                then nhds (lead_coeff q / lead_coeff p)\n                else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top\n                     else at_bot\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. LIM x at_top. poly q x / poly p x :> at 0", "by auto"], ["proof (state)\nthis:\n  LIM x at_top. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. P", "then"], ["proof (chain)\npicking this:\n  LIM x at_top. poly q x / poly p x :> at 0", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. P", "unfolding P_def"], ["proof (prove)\nusing this:\n  LIM x at_top. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_top. poly q x / poly p x :> at_bot) \\<and>\n    \\<not> (LIM x at_top. poly q x / poly p x :> at_top)", "by (auto elim!:filterlim_at_bot_nhds filterlim_at_top_nhds simp:filterlim_at)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree q < degree p\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree q < degree p\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have P when \"p\\<noteq>0\" \"q\\<noteq>0\" \"degree p = degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have \"((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> lead_coeff q / lead_coeff p) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "using poly_divide_filterlim_at_top[OF that(1,2)]"], ["proof (prove)\nusing this:\n  LIM x at_top.\n     poly q x /\n     poly p\n      x :> if degree q < degree p then at 0\n           else if degree q = degree p\n                then nhds (lead_coeff q / lead_coeff p)\n                else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top\n                     else at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "using that"], ["proof (prove)\nusing this:\n  LIM x at_top.\n     poly q x /\n     poly p\n      x :> if degree q < degree p then at 0\n           else if degree q = degree p\n                then nhds (lead_coeff q / lead_coeff p)\n                else if 0 < sgn_pos_inf q * sgn_pos_inf p then at_top\n                     else at_bot\n  p \\<noteq> 0\n  q \\<noteq> 0\n  degree p = degree q\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top\n\ngoal (1 subgoal):\n 1. P", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top\n\ngoal (1 subgoal):\n 1. P", "unfolding P_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_top. poly q x / poly p x :> at_bot) \\<and>\n    \\<not> (LIM x at_top. poly q x / poly p x :> at_top)", "by (auto elim!:filterlim_at_bot_nhds filterlim_at_top_nhds)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree p = degree q\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree q < degree p\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree p = degree q\\<rbrakk>\n  \\<Longrightarrow> P", "have P"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree q < degree p\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree p = degree q\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "using False"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree q < degree p\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree p = degree q\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<not> (p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q)\n\ngoal (1 subgoal):\n 1. P", "by fastforce"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  P", "have \"jumpF (\\<lambda>x. poly q x / poly p x) at_top = 0\""], ["proof (prove)\nusing this:\n  P\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_top = 0", "unfolding jumpF_def P_def"], ["proof (prove)\nusing this:\n  \\<not> (LIM x at_top. poly q x / poly p x :> at_bot) \\<and>\n  \\<not> (LIM x at_top. poly q x / poly p x :> at_top)\n\ngoal (1 subgoal):\n 1. (if LIM x at_top. poly q x / poly p x :> at_top then 1 / 2\n     else if LIM x at_top. poly q x / poly p x :> at_bot then - 1 / 2\n          else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = 0\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = 0\n\ngoal (1 subgoal):\n 1. jumpF_poly_top q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "unfolding jumpF_poly_top_def"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_top =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "using False"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_top = 0\n  \\<not> (p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_top =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2\n     else 0)", "by presburger"], ["proof (state)\nthis:\n  jumpF_poly_top q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_pos_inf q * sgn_pos_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma jumpF_poly_bot_code:\n  \"jumpF_poly_bot q p = (if p\\<noteq>0 \\<and> q\\<noteq>0 \\<and> degree q>degree p then \n          if sgn_neg_inf q * sgn_neg_inf p > 0 then 1/2 else -1/2 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "proof (cases \"p\\<noteq>0 \\<and> q\\<noteq>0 \\<and> degree q>degree p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and>\n    q \\<noteq> 0 \\<and> degree p < degree q \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)\n 2. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "case True"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and>\n    q \\<noteq> 0 \\<and> degree p < degree q \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)\n 2. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"sgn_neg_inf q * sgn_neg_inf p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have \"LIM x at_bot. poly q x / poly p x :> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> at_top", "using poly_divide_filterlim_at_bot[of p q] True that"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot.\n                       poly q x /\n                       poly p\n                        x :> if degree q < degree p then at 0\n                             else if degree q = degree p\n                                  then nhds (lead_coeff q / lead_coeff p)\n                                  else if 0 < sgn_neg_inf q * sgn_neg_inf p\n then at_top else at_bot\n  p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n  0 < sgn_neg_inf q * sgn_neg_inf p\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> at_top", "by auto"], ["proof (state)\nthis:\n  LIM x at_bot. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_bot. poly q x / poly p x :> at_top", "have \"jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at_top\n\ngoal (1 subgoal):\n 1. (if LIM x at_bot. poly q x / poly p x :> at_top then 1 / 2\n     else if LIM x at_bot. poly q x / poly p x :> at_bot then - 1 / 2\n          else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "unfolding jumpF_poly_bot_def"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_bot =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "using that True"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 1 / 2\n  0 < sgn_neg_inf q * sgn_neg_inf p\n  p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_bot =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_poly_bot q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < sgn_neg_inf q * sgn_neg_inf p \\<Longrightarrow>\n  jumpF_poly_bot q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and>\n    q \\<noteq> 0 \\<and> degree p < degree q \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)\n 2. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  0 < sgn_neg_inf q * sgn_neg_inf p \\<Longrightarrow>\n  jumpF_poly_bot q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and>\n    q \\<noteq> 0 \\<and> degree p < degree q \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)\n 2. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have ?thesis when \"\\<not> sgn_neg_inf q * sgn_neg_inf p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have \"LIM x at_bot. poly q x / poly p x :> at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> at_bot", "using poly_divide_filterlim_at_bot[of p q] True that"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> LIM x at_bot.\n                       poly q x /\n                       poly p\n                        x :> if degree q < degree p then at 0\n                             else if degree q = degree p\n                                  then nhds (lead_coeff q / lead_coeff p)\n                                  else if 0 < sgn_neg_inf q * sgn_neg_inf p\n then at_top else at_bot\n  p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n  \\<not> 0 < sgn_neg_inf q * sgn_neg_inf p\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> at_bot", "by auto"], ["proof (state)\nthis:\n  LIM x at_bot. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  LIM x at_bot. poly q x / poly p x :> at_bot", "have \"jumpF (\\<lambda>x. poly q x / poly p x) at_bot = - 1/2\""], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_bot = - 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at_bot\n\ngoal (1 subgoal):\n 1. (if LIM x at_bot. poly q x / poly p x :> at_top then 1 / 2\n     else if LIM x at_bot. poly q x / poly p x :> at_bot then - 1 / 2\n          else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "unfolding jumpF_poly_bot_def"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_bot =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "using that True"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = - 1 / 2\n  \\<not> 0 < sgn_neg_inf q * sgn_neg_inf p\n  p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_bot =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_poly_bot q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> 0 < sgn_neg_inf q * sgn_neg_inf p \\<Longrightarrow>\n  jumpF_poly_bot q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<and>\n    q \\<noteq> 0 \\<and> degree p < degree q \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)\n 2. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  0 < sgn_neg_inf q * sgn_neg_inf p \\<Longrightarrow>\n  jumpF_poly_bot q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2 else 0)\n  \\<not> 0 < sgn_neg_inf q * sgn_neg_inf p \\<Longrightarrow>\n  jumpF_poly_bot q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < sgn_neg_inf q * sgn_neg_inf p \\<Longrightarrow>\n  jumpF_poly_bot q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2 else 0)\n  \\<not> 0 < sgn_neg_inf q * sgn_neg_inf p \\<Longrightarrow>\n  jumpF_poly_bot q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "by auto"], ["proof (state)\nthis:\n  jumpF_poly_bot q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> (p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q)\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "define P where \"P= (\\<not> (LIM x at_bot. poly q x / poly p x :> at_bot) \n                      \\<and> \\<not> (LIM x at_bot. poly q x / poly p x :> at_top))\""], ["proof (state)\nthis:\n  P =\n  (\\<not> (LIM x at_bot. poly q x / poly p x :> at_bot) \\<and>\n   \\<not> (LIM x at_bot. poly q x / poly p x :> at_top))\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have P when \"p=0 \\<or> q=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_bot. poly q x / poly p x :> at_bot) \\<and>\n    \\<not> (LIM x at_bot. poly q x / poly p x :> at_top)", "using that"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0\n\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_bot. poly q x / poly p x :> at_bot) \\<and>\n    \\<not> (LIM x at_bot. poly q x / poly p x :> at_top)", "by (auto elim!:filterlim_at_bot_nhds filterlim_at_top_nhds)"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have P when \"p\\<noteq>0\" \"q\\<noteq>0\" \"degree p> degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have \"LIM x at_bot. poly q x / poly p x :> at 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> at 0", "using poly_divide_filterlim_at_bot[OF that(1,2)] that(3)"], ["proof (prove)\nusing this:\n  LIM x at_bot.\n     poly q x /\n     poly p\n      x :> if degree q < degree p then at 0\n           else if degree q = degree p\n                then nhds (lead_coeff q / lead_coeff p)\n                else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top\n                     else at_bot\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. LIM x at_bot. poly q x / poly p x :> at 0", "by auto"], ["proof (state)\nthis:\n  LIM x at_bot. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. P", "then"], ["proof (chain)\npicking this:\n  LIM x at_bot. poly q x / poly p x :> at 0", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. P", "unfolding P_def"], ["proof (prove)\nusing this:\n  LIM x at_bot. poly q x / poly p x :> at 0\n\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_bot. poly q x / poly p x :> at_bot) \\<and>\n    \\<not> (LIM x at_bot. poly q x / poly p x :> at_top)", "by (auto elim!:filterlim_at_bot_nhds filterlim_at_top_nhds simp:filterlim_at)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree q < degree p\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree q < degree p\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "have P when \"p\\<noteq>0\" \"q\\<noteq>0\" \"degree p = degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "have \"((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow> lead_coeff q / lead_coeff p) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "using poly_divide_filterlim_at_bot[OF that(1,2)]"], ["proof (prove)\nusing this:\n  LIM x at_bot.\n     poly q x /\n     poly p\n      x :> if degree q < degree p then at 0\n           else if degree q = degree p\n                then nhds (lead_coeff q / lead_coeff p)\n                else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top\n                     else at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "using that"], ["proof (prove)\nusing this:\n  LIM x at_bot.\n     poly q x /\n     poly p\n      x :> if degree q < degree p then at 0\n           else if degree q = degree p\n                then nhds (lead_coeff q / lead_coeff p)\n                else if 0 < sgn_neg_inf q * sgn_neg_inf p then at_top\n                     else at_bot\n  p \\<noteq> 0\n  q \\<noteq> 0\n  degree p = degree q\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n     lead_coeff q / lead_coeff p)\n     at_bot", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot\n\ngoal (1 subgoal):\n 1. P", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot\n\ngoal (1 subgoal):\n 1. P", "unfolding P_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. poly q x / poly p x) \\<longlongrightarrow>\n   lead_coeff q / lead_coeff p)\n   at_bot\n\ngoal (1 subgoal):\n 1. \\<not> (LIM x at_bot. poly q x / poly p x :> at_bot) \\<and>\n    \\<not> (LIM x at_bot. poly q x / poly p x :> at_top)", "by (auto elim!:filterlim_at_bot_nhds filterlim_at_top_nhds)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree p = degree q\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree q < degree p\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree p = degree q\\<rbrakk>\n  \\<Longrightarrow> P", "have P"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree q < degree p\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree p = degree q\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "using False"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0 \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree q < degree p\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; degree p = degree q\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<not> (p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q)\n\ngoal (1 subgoal):\n 1. P", "by fastforce"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  P", "have \"jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 0\""], ["proof (prove)\nusing this:\n  P\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 0", "unfolding jumpF_def P_def"], ["proof (prove)\nusing this:\n  \\<not> (LIM x at_bot. poly q x / poly p x :> at_bot) \\<and>\n  \\<not> (LIM x at_bot. poly q x / poly p x :> at_top)\n\ngoal (1 subgoal):\n 1. (if LIM x at_bot. poly q x / poly p x :> at_top then 1 / 2\n     else if LIM x at_bot. poly q x / poly p x :> at_bot then - 1 / 2\n          else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 0\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<noteq> 0 \\<and>\n            q \\<noteq> 0 \\<and> degree p < degree q) \\<Longrightarrow>\n    jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "then"], ["proof (chain)\npicking this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 0\n\ngoal (1 subgoal):\n 1. jumpF_poly_bot q p =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "unfolding jumpF_poly_bot_def"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_bot =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "using False"], ["proof (prove)\nusing this:\n  jumpF (\\<lambda>x. poly q x / poly p x) at_bot = 0\n  \\<not> (p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q)\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) at_bot =\n    (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n     then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2\n     else 0)", "by presburger"], ["proof (state)\nthis:\n  jumpF_poly_bot q p =\n  (if p \\<noteq> 0 \\<and> q \\<noteq> 0 \\<and> degree p < degree q\n   then if 0 < sgn_neg_inf q * sgn_neg_inf p then 1 / 2 else - 1 / 2 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The extended Cauchy index on polynomials\\<close>"], ["", "definition cindex_polyE:: \"real \\<Rightarrow> real \\<Rightarrow> real poly \\<Rightarrow> real poly \\<Rightarrow> real\" where\n  \"cindex_polyE a b q p = jumpF_polyR q p a + cindex_poly a b q p - jumpF_polyL q p b\""], ["", "definition cindex_poly_ubd::\"real poly \\<Rightarrow> real poly \\<Rightarrow> int\" where\n  \"cindex_poly_ubd q p = (THE l. (\\<forall>\\<^sub>F r in at_top. cindexE (-r) r (\\<lambda>x. poly q x/poly p x) = of_int l))\""], ["", "lemma cindex_polyE_0[simp]: \"cindex_polyE a b 0 p = 0\" \"cindex_polyE a b q 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b 0 p = 0 &&& cindex_polyE a b q 0 = 0", "unfolding cindex_polyE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 0 p a + real_of_int (cindex_poly a b 0 p) -\n    jumpF_polyL 0 p b =\n    0 &&&\n    jumpF_polyR q 0 a + real_of_int (cindex_poly a b q 0) -\n    jumpF_polyL q 0 b =\n    0", "by auto"], ["", "lemma cindex_polyE_mult_cancel:\n  fixes p q p'::\"real poly\"\n  assumes \"p'\\<noteq> 0\"  \n  shows \"cindex_polyE a b (p' * q ) (p' * p) = cindex_polyE a b q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b (p' * q) (p' * p) = cindex_polyE a b q p", "unfolding cindex_polyE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR (p' * q) (p' * p) a +\n    real_of_int (cindex_poly a b (p' * q) (p' * p)) -\n    jumpF_polyL (p' * q) (p' * p) b =\n    jumpF_polyR q p a + real_of_int (cindex_poly a b q p) -\n    jumpF_polyL q p b", "using cindex_poly_mult[OF \\<open>p'\\<noteq>0\\<close>] jumpF_polyL_mult_cancel[OF \\<open>p'\\<noteq>0\\<close>] \n    jumpF_polyR_mult_cancel[OF \\<open>p'\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  cindex_poly ?a ?b (p' * ?q) (p' * ?p) = cindex_poly ?a ?b ?q ?p\n  jumpF_polyL (p' * ?q) (p' * ?p) ?a = jumpF_polyL ?q ?p ?a\n  jumpF_polyR (p' * ?q) (p' * ?p) ?a = jumpF_polyR ?q ?p ?a\n\ngoal (1 subgoal):\n 1. jumpF_polyR (p' * q) (p' * p) a +\n    real_of_int (cindex_poly a b (p' * q) (p' * p)) -\n    jumpF_polyL (p' * q) (p' * p) b =\n    jumpF_polyR q p a + real_of_int (cindex_poly a b q p) -\n    jumpF_polyL q p b", "by simp"], ["", "lemma cindexE_eq_cindex_polyE: \n  assumes \"a<b\"\n  shows \"cindexE a b (\\<lambda>x. poly q x/poly p x) = cindex_polyE a b q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "proof (cases \"p=0 \\<or> q=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "case True"], ["proof (state)\nthis:\n  p = 0 \\<or> q = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "then"], ["proof (chain)\npicking this:\n  p = 0 \\<or> q = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0\n\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "by (auto simp add: cindexE_constI)"], ["proof (state)\nthis:\n  cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> q = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "then"], ["proof (chain)\npicking this:\n  \\<not> (p = 0 \\<or> q = 0)", "have \"p\\<noteq>0\" \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> q = 0)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "define g where \"g=gcd p q\""], ["proof (state)\nthis:\n  g = gcd p q\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "define p' q' where \"p'=p div g\" and \"q' = q div g\""], ["proof (state)\nthis:\n  p' = p div g\n  q' = q div g\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "define f' where \"f'=(\\<lambda>x. poly q' x / poly p' x)\""], ["proof (state)\nthis:\n  f' = (\\<lambda>x. poly q' x / poly p' x)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "have \"g\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "using False g_def"], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> q = 0)\n  g = gcd p q\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "have pq_f:\"p=g*p'\" \"q=g*q'\" and \"coprime p' q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = g * p' &&& q = g * q') &&& coprime p' q'", "unfolding g_def p'_def q'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p = gcd p q * (p div gcd p q) &&& q = gcd p q * (q div gcd p q)) &&&\n    coprime (p div gcd p q) (q div gcd p q)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (p div gcd p q) (q div gcd p q)", "using False div_gcd_coprime"], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> q = 0)\n  ?a \\<noteq> (0::?'a) \\<or> ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  coprime (?a div gcd ?a ?b) (?b div gcd ?a ?b)\n\ngoal (1 subgoal):\n 1. coprime (p div gcd p q) (q div gcd p q)", "by blast"], ["proof (state)\nthis:\n  p = g * p'\n  q = g * q'\n  coprime p' q'\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "have \"cindexE a b (\\<lambda>x. poly q x/poly p x) = cindexE a b (\\<lambda>x. poly q' x/poly p' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q x / poly p x) =\n    cindexE a b (\\<lambda>x. poly q' x / poly p' x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q x / poly p x) =\n    cindexE a b (\\<lambda>x. poly q' x / poly p' x)", "define f where \"f=(\\<lambda>x. poly q x / poly p x)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. poly q x / poly p x)\n\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q x / poly p x) =\n    cindexE a b (\\<lambda>x. poly q' x / poly p' x)", "define f' where \"f'=(\\<lambda>x. poly q' x / poly p' x)\""], ["proof (state)\nthis:\n  f' = (\\<lambda>x. poly q' x / poly p' x)\n\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q x / poly p x) =\n    cindexE a b (\\<lambda>x. poly q' x / poly p' x)", "have \"jumpF f (at_right x) = jumpF f' (at_right x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = jumpF f' (at_right x)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_right x = at_right x\n 2. \\<forall>\\<^sub>F x in at_right x. f x = f' x", "obtain ub where \"x < ub\" \"\\<forall>z. x < z \\<and> z \\<le> ub \\<longrightarrow> poly g z \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>x < ub;\n         \\<forall>z.\n            x < z \\<and> z \\<le> ub \\<longrightarrow>\n            poly g z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using next_non_root_interval[OF \\<open>g\\<noteq>0\\<close>,of x]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>x < ub;\n       \\<forall>z.\n          x < z \\<and> z \\<le> ub \\<longrightarrow>\n          poly g z \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>x < ub;\n         \\<forall>z.\n            x < z \\<and> z \\<le> ub \\<longrightarrow>\n            poly g z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x < ub\n  \\<forall>z. x < z \\<and> z \\<le> ub \\<longrightarrow> poly g z \\<noteq> 0\n\ngoal (2 subgoals):\n 1. at_right x = at_right x\n 2. \\<forall>\\<^sub>F x in at_right x. f x = f' x", "then"], ["proof (chain)\npicking this:\n  x < ub\n  \\<forall>z. x < z \\<and> z \\<le> ub \\<longrightarrow> poly g z \\<noteq> 0", "show \"\\<forall>\\<^sub>F x in at_right x. f x = f' x\""], ["proof (prove)\nusing this:\n  x < ub\n  \\<forall>z. x < z \\<and> z \\<le> ub \\<longrightarrow> poly g z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right x. f x = f' x", "unfolding eventually_at_right f_def f'_def pq_f"], ["proof (prove)\nusing this:\n  x < ub\n  \\<forall>z. x < z \\<and> z \\<le> ub \\<longrightarrow> poly g z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>b>x.\n       \\<forall>y>x.\n          y < b \\<longrightarrow>\n          poly (g * q') y / poly (g * p') y = poly q' y / poly p' y", "apply (intro exI[where x=ub])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < ub;\n     \\<forall>z.\n        x < z \\<and> z \\<le> ub \\<longrightarrow>\n        poly g z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x < ub \\<and>\n                      (\\<forall>y>x.\n                          y < ub \\<longrightarrow>\n                          poly (g * q') y / poly (g * p') y =\n                          poly q' y / poly p' y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_right x. f x = f' x\n\ngoal (1 subgoal):\n 1. at_right x = at_right x", "qed simp"], ["proof (state)\nthis:\n  jumpF f (at_right ?x) = jumpF f' (at_right ?x)\n\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q x / poly p x) =\n    cindexE a b (\\<lambda>x. poly q' x / poly p' x)", "moreover"], ["proof (state)\nthis:\n  jumpF f (at_right ?x) = jumpF f' (at_right ?x)\n\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q x / poly p x) =\n    cindexE a b (\\<lambda>x. poly q' x / poly p' x)", "have \"jumpF f (at_left x) = jumpF f' (at_left x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = jumpF f' (at_left x)", "proof (rule jumpF_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. at_left x = at_left x\n 2. \\<forall>\\<^sub>F x in at_left x. f x = f' x", "obtain lb where \"lb < x\" \"\\<forall>z. lb \\<le> z \\<and> z < x \\<longrightarrow> poly g z \\<noteq> 0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>lb < x;\n         \\<forall>z.\n            lb \\<le> z \\<and> z < x \\<longrightarrow>\n            poly g z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using last_non_root_interval[OF \\<open>g\\<noteq>0\\<close>,of x]"], ["proof (prove)\nusing this:\n  (\\<And>lb.\n      \\<lbrakk>lb < x;\n       \\<forall>z.\n          lb \\<le> z \\<and> z < x \\<longrightarrow>\n          poly g z \\<noteq> 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>lb < x;\n         \\<forall>z.\n            lb \\<le> z \\<and> z < x \\<longrightarrow>\n            poly g z \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lb < x\n  \\<forall>z. lb \\<le> z \\<and> z < x \\<longrightarrow> poly g z \\<noteq> 0\n\ngoal (2 subgoals):\n 1. at_left x = at_left x\n 2. \\<forall>\\<^sub>F x in at_left x. f x = f' x", "then"], ["proof (chain)\npicking this:\n  lb < x\n  \\<forall>z. lb \\<le> z \\<and> z < x \\<longrightarrow> poly g z \\<noteq> 0", "show \"\\<forall>\\<^sub>F x in at_left x. f x = f' x\""], ["proof (prove)\nusing this:\n  lb < x\n  \\<forall>z. lb \\<le> z \\<and> z < x \\<longrightarrow> poly g z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left x. f x = f' x", "unfolding eventually_at_left f_def f'_def pq_f"], ["proof (prove)\nusing this:\n  lb < x\n  \\<forall>z. lb \\<le> z \\<and> z < x \\<longrightarrow> poly g z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>b<x.\n       \\<forall>y>b.\n          y < x \\<longrightarrow>\n          poly (g * q') y / poly (g * p') y = poly q' y / poly p' y", "apply (intro exI[where x=lb])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lb < x;\n     \\<forall>z.\n        lb \\<le> z \\<and> z < x \\<longrightarrow>\n        poly g z \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> lb < x \\<and>\n                      (\\<forall>y>lb.\n                          y < x \\<longrightarrow>\n                          poly (g * q') y / poly (g * p') y =\n                          poly q' y / poly p' y)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left x. f x = f' x\n\ngoal (1 subgoal):\n 1. at_left x = at_left x", "qed simp"], ["proof (state)\nthis:\n  jumpF f (at_left ?x) = jumpF f' (at_left ?x)\n\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q x / poly p x) =\n    cindexE a b (\\<lambda>x. poly q' x / poly p' x)", "ultimately"], ["proof (chain)\npicking this:\n  jumpF f (at_right ?x) = jumpF f' (at_right ?x)\n  jumpF f (at_left ?x) = jumpF f' (at_left ?x)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF f (at_right ?x) = jumpF f' (at_right ?x)\n  jumpF f (at_left ?x) = jumpF f' (at_left ?x)\n\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q x / poly p x) =\n    cindexE a b (\\<lambda>x. poly q' x / poly p' x)", "unfolding cindexE_def"], ["proof (prove)\nusing this:\n  jumpF f (at_right ?x) = jumpF f' (at_right ?x)\n  jumpF f (at_left ?x) = jumpF f' (at_left ?x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF (\\<lambda>x. poly q x / poly p x) (at_right x) \\<noteq>\n               0 \\<and>\n               a \\<le> x \\<and> x < b.\n       jumpF (\\<lambda>x. poly q x / poly p x) (at_right x)) -\n    (\\<Sum>x | jumpF (\\<lambda>x. poly q x / poly p x) (at_left x) \\<noteq>\n               0 \\<and>\n               a < x \\<and> x \\<le> b.\n       jumpF (\\<lambda>x. poly q x / poly p x) (at_left x)) =\n    (\\<Sum>x | jumpF (\\<lambda>x. poly q' x / poly p' x)\n                (at_right x) \\<noteq>\n               0 \\<and>\n               a \\<le> x \\<and> x < b.\n       jumpF (\\<lambda>x. poly q' x / poly p' x) (at_right x)) -\n    (\\<Sum>x | jumpF (\\<lambda>x. poly q' x / poly p' x)\n                (at_left x) \\<noteq>\n               0 \\<and>\n               a < x \\<and> x \\<le> b.\n       jumpF (\\<lambda>x. poly q' x / poly p' x) (at_left x))", "apply (fold f_def f'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. jumpF f (at_right x) = jumpF f' (at_right x);\n     \\<And>x. jumpF f (at_left x) = jumpF f' (at_left x)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n                                 a \\<le> x \\<and> x < b.\n                         jumpF f (at_right x)) -\n                      (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n                                 a < x \\<and> x \\<le> b.\n                         jumpF f (at_left x)) =\n                      (\\<Sum>x | jumpF f' (at_right x) \\<noteq> 0 \\<and>\n                                 a \\<le> x \\<and> x < b.\n                         jumpF f' (at_right x)) -\n                      (\\<Sum>x | jumpF f' (at_left x) \\<noteq> 0 \\<and>\n                                 a < x \\<and> x \\<le> b.\n                         jumpF f' (at_left x))", "by auto"], ["proof (state)\nthis:\n  cindexE a b (\\<lambda>x. poly q x / poly p x) =\n  cindexE a b (\\<lambda>x. poly q' x / poly p' x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE a b (\\<lambda>x. poly q x / poly p x) =\n  cindexE a b (\\<lambda>x. poly q' x / poly p' x)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "also"], ["proof (state)\nthis:\n  cindexE a b (\\<lambda>x. poly q x / poly p x) =\n  cindexE a b (\\<lambda>x. poly q' x / poly p' x)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "have \"... = jumpF f' (at_right a) + real_of_int (cindex a b f') - jumpF f' (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q' x / poly p' x) =\n    jumpF f' (at_right a) + real_of_int (cindex a b f') -\n    jumpF f' (at_left b)", "unfolding f'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q' x / poly p' x) =\n    jumpF (\\<lambda>x. poly q' x / poly p' x) (at_right a) +\n    real_of_int (cindex a b (\\<lambda>x. poly q' x / poly p' x)) -\n    jumpF (\\<lambda>x. poly q' x / poly p' x) (at_left b)", "apply (rule cindex_eq_cindexE_divide)"], ["proof (prove)\ngoal (5 subgoals):\n 1. a < b\n 2. finite\n     {x. (poly q' x = 0 \\<or> poly p' x = 0) \\<and>\n         a \\<le> x \\<and> x \\<le> b}\n 3. \\<forall>x\\<in>{a..b}.\n       poly p' x = 0 \\<longrightarrow> poly q' x \\<noteq> 0\n 4. continuous_on {a..b} (poly q')\n 5. continuous_on {a..b} (poly p')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b", "using \\<open>a<b\\<close>"], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. a < b", "."], ["proof (prove)\ngoal (4 subgoals):\n 1. finite\n     {x. (poly q' x = 0 \\<or> poly p' x = 0) \\<and>\n         a \\<le> x \\<and> x \\<le> b}\n 2. \\<forall>x\\<in>{a..b}.\n       poly p' x = 0 \\<longrightarrow> poly q' x \\<noteq> 0\n 3. continuous_on {a..b} (poly q')\n 4. continuous_on {a..b} (poly p')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {x. (poly q' x = 0 \\<or> poly p' x = 0) \\<and>\n         a \\<le> x \\<and> x \\<le> b}", "using False poly_roots_finite pq_f(1) pq_f(2)"], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> q = 0)\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n  p = g * p'\n  q = g * q'\n\ngoal (1 subgoal):\n 1. finite\n     {x. (poly q' x = 0 \\<or> poly p' x = 0) \\<and>\n         a \\<le> x \\<and> x \\<le> b}", "by fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>{a..b}.\n       poly p' x = 0 \\<longrightarrow> poly q' x \\<noteq> 0\n 2. continuous_on {a..b} (poly q')\n 3. continuous_on {a..b} (poly p')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{a..b}.\n       poly p' x = 0 \\<longrightarrow> poly q' x \\<noteq> 0", "using \\<open>coprime p' q'\\<close> poly_gcd_iff"], ["proof (prove)\nusing this:\n  coprime p' q'\n  (poly (gcd ?p ?q) ?x = (0::?'a)) =\n  (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{a..b}.\n       poly p' x = 0 \\<longrightarrow> poly q' x \\<noteq> 0", "by force"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {a..b} (poly q')\n 2. continuous_on {a..b} (poly p')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a..b} (poly q')", "by (auto intro:continuous_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a..b} (poly p')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a..b} (poly p')", "by (auto intro:continuous_intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cindexE a b (\\<lambda>x. poly q' x / poly p' x) =\n  jumpF f' (at_right a) + real_of_int (cindex a b f') - jumpF f' (at_left b)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "also"], ["proof (state)\nthis:\n  cindexE a b (\\<lambda>x. poly q' x / poly p' x) =\n  jumpF f' (at_right a) + real_of_int (cindex a b f') - jumpF f' (at_left b)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "have \"... = cindex_polyE a b q' p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f' (at_right a) + real_of_int (cindex a b f') -\n    jumpF f' (at_left b) =\n    cindex_polyE a b q' p'", "using cindex_eq_cindex_poly"], ["proof (prove)\nusing this:\n  cindex ?a ?b (\\<lambda>x. poly ?q x / poly ?p x) = cindex_poly ?a ?b ?q ?p\n\ngoal (1 subgoal):\n 1. jumpF f' (at_right a) + real_of_int (cindex a b f') -\n    jumpF f' (at_left b) =\n    cindex_polyE a b q' p'", "unfolding cindex_polyE_def jumpF_polyR_def jumpF_polyL_def f'_def"], ["proof (prove)\nusing this:\n  cindex ?a ?b (\\<lambda>x. poly ?q x / poly ?p x) = cindex_poly ?a ?b ?q ?p\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q' x / poly p' x) (at_right a) +\n    real_of_int (cindex a b (\\<lambda>x. poly q' x / poly p' x)) -\n    jumpF (\\<lambda>x. poly q' x / poly p' x) (at_left b) =\n    jumpF (\\<lambda>x. poly q' x / poly p' x) (at_right a) +\n    real_of_int (cindex_poly a b q' p') -\n    jumpF (\\<lambda>x. poly q' x / poly p' x) (at_left b)", "by auto"], ["proof (state)\nthis:\n  jumpF f' (at_right a) + real_of_int (cindex a b f') -\n  jumpF f' (at_left b) =\n  cindex_polyE a b q' p'\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "also"], ["proof (state)\nthis:\n  jumpF f' (at_right a) + real_of_int (cindex a b f') -\n  jumpF f' (at_left b) =\n  cindex_polyE a b q' p'\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "have \"... = cindex_polyE a b q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b q' p' = cindex_polyE a b q p", "using cindex_polyE_mult_cancel[OF \\<open>g\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  cindex_polyE ?a ?b (g * ?q) (g * ?p) = cindex_polyE ?a ?b ?q ?p\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q' p' = cindex_polyE a b q p", "unfolding pq_f"], ["proof (prove)\nusing this:\n  cindex_polyE ?a ?b (g * ?q) (g * ?p) = cindex_polyE ?a ?b ?q ?p\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q' p' = cindex_polyE a b (g * q') (g * p')", "by auto"], ["proof (state)\nthis:\n  cindex_polyE a b q' p' = cindex_polyE a b q p\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "finally"], ["proof (chain)\npicking this:\n  cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p\n\ngoal (1 subgoal):\n 1. cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p", "."], ["proof (state)\nthis:\n  cindexE a b (\\<lambda>x. poly q x / poly p x) = cindex_polyE a b q p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_polyE_cross:\n  fixes p::\"real poly\" and a b::real\n  assumes \"a<b\" \n  shows \"cindex_polyE a b 1 p = cross_alt 1 p a b / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "proof (induct \"degree p\" arbitrary:p rule:nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>m<degree p.\n          \\<forall>x.\n             m = degree x \\<longrightarrow>\n             cindex_polyE a b 1 x =\n             real_of_int (cross_alt 1 x a b) / 2 \\<Longrightarrow>\n       cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "case induct:1"], ["proof (state)\nthis:\n  \\<forall>m<degree p.\n     \\<forall>x.\n        m = degree x \\<longrightarrow>\n        cindex_polyE a b 1 x = real_of_int (cross_alt 1 x a b) / 2\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>m<degree p.\n          \\<forall>x.\n             m = degree x \\<longrightarrow>\n             cindex_polyE a b 1 x =\n             real_of_int (cross_alt 1 x a b) / 2 \\<Longrightarrow>\n       cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "have ?case when \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "using that"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "unfolding cross_alt_def"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p =\n    real_of_int\n     (\\<bar>sign (poly 1 a) - sign (poly p a)\\<bar> -\n      \\<bar>sign (poly 1 b) - sign (poly p b)\\<bar>) /\n    2", "by auto"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow>\n  cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>m<degree p.\n          \\<forall>x.\n             m = degree x \\<longrightarrow>\n             cindex_polyE a b 1 x =\n             real_of_int (cross_alt 1 x a b) / 2 \\<Longrightarrow>\n       cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow>\n  cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>m<degree p.\n          \\<forall>x.\n             m = degree x \\<longrightarrow>\n             cindex_polyE a b 1 x =\n             real_of_int (cross_alt 1 x a b) / 2 \\<Longrightarrow>\n       cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "have ?case when \"p\\<noteq>0\" and noroot:\"{x.  a< x\\<and> x< b \\<and> poly p x=0 } = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "have \"cindex_polyE a b 1 p = jumpF_polyR 1 p a  - jumpF_polyL 1 p b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = jumpF_polyR 1 p a - jumpF_polyL 1 p b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = jumpF_polyR 1 p a - jumpF_polyL 1 p b", "have \"cindex_poly a b 1 p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly a b 1 p = 0", "unfolding cindex_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly 1 p x) = 0", "apply (rule sum.neutral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. poly p x = 0 \\<and> a < x \\<and> x < b}.\n       jump_poly 1 p x = 0", "using that"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  {x. a < x \\<and> x < b \\<and> poly p x = 0} = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. poly p x = 0 \\<and> a < x \\<and> x < b}.\n       jump_poly 1 p x = 0", "by auto"], ["proof (state)\nthis:\n  cindex_poly a b 1 p = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = jumpF_polyR 1 p a - jumpF_polyL 1 p b", "then"], ["proof (chain)\npicking this:\n  cindex_poly a b 1 p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_poly a b 1 p = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = jumpF_polyR 1 p a - jumpF_polyL 1 p b", "unfolding cindex_polyE_def"], ["proof (prove)\nusing this:\n  cindex_poly a b 1 p = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a + real_of_int (cindex_poly a b 1 p) -\n    jumpF_polyL 1 p b =\n    jumpF_polyR 1 p a - jumpF_polyL 1 p b", "by auto"], ["proof (state)\nthis:\n  cindex_polyE a b 1 p = jumpF_polyR 1 p a - jumpF_polyL 1 p b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_polyE a b 1 p = jumpF_polyR 1 p a - jumpF_polyL 1 p b\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "also"], ["proof (state)\nthis:\n  cindex_polyE a b 1 p = jumpF_polyR 1 p a - jumpF_polyL 1 p b\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "have \"... = cross_alt 1 p a b / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "define f where \"f = (\\<lambda>x. 1 / poly p x)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. 1 / poly p x)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "define ja where \"ja = jumpF f (at_right a)\""], ["proof (state)\nthis:\n  ja = jumpF f (at_right a)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "define jb where \"jb = jumpF f (at_left b)\""], ["proof (state)\nthis:\n  jb = jumpF f (at_left b)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "define right where \"right = (\\<lambda>R. R ja (0::real) \\<or> (continuous (at_right a) f \\<and> R (poly p a) 0))\""], ["proof (state)\nthis:\n  right =\n  (\\<lambda>R. R ja 0 \\<or> continuous (at_right a) f \\<and> R (poly p a) 0)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "define left where \"left = (\\<lambda>R. R jb (0::real) \\<or> (continuous (at_left b) f \\<and> R (poly p b) 0))\""], ["proof (state)\nthis:\n  left =\n  (\\<lambda>R. R jb 0 \\<or> continuous (at_left b) f \\<and> R (poly p b) 0)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "note ja_alt=jumpF_polyR_coprime[of p 1 a,unfolded jumpF_polyR_def,simplified,folded f_def ja_def]"], ["proof (state)\nthis:\n  ja =\n  (if p \\<noteq> 0 \\<and> poly p a = 0\n   then if sign_r_pos p a = (0 < poly 1 a) then 1 / 2 else - 1 / 2 else 0)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "note jb_alt=jumpF_polyL_coprime[of p 1 b,unfolded jumpF_polyL_def,simplified,folded f_def jb_def]"], ["proof (state)\nthis:\n  jb =\n  (if p \\<noteq> 0 \\<and> poly p b = 0\n   then if even (order b p) = (sign_r_pos p b = (0 < poly 1 b)) then 1 / 2\n        else - 1 / 2\n   else 0)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have [simp]:\"0 < ja \\<longleftrightarrow> jumpF_polyR 1 p a = 1/2\" \"0 > ja \\<longleftrightarrow> jumpF_polyR 1 p a = -1/2\"\n           \"0 < jb \\<longleftrightarrow> jumpF_polyL 1 p b = 1/2\" \"0 > jb \\<longleftrightarrow> jumpF_polyL 1 p b = -1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0 < ja) = (jumpF_polyR 1 p a = 1 / 2) &&&\n     (ja < 0) = (jumpF_polyR 1 p a = - 1 / 2)) &&&\n    (0 < jb) = (jumpF_polyL 1 p b = 1 / 2) &&&\n    (jb < 0) = (jumpF_polyL 1 p b = - 1 / 2)", "unfolding ja_def jb_def jumpF_polyR_def jumpF_polyL_def f_def jumpF_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0 < (if LIM x at_right a. 1 / poly p x :> at_top then 1 / 2\n           else if LIM x at_right a. 1 / poly p x :> at_bot then - 1 / 2\n                else 0)) =\n     ((if LIM x at_right a. poly 1 x / poly p x :> at_top then 1 / 2\n       else if LIM x at_right a. poly 1 x / poly p x :> at_bot then - 1 / 2\n            else 0) =\n      1 / 2) &&&\n     ((if LIM x at_right a. 1 / poly p x :> at_top then 1 / 2\n       else if LIM x at_right a. 1 / poly p x :> at_bot then - 1 / 2 else 0)\n      < 0) =\n     ((if LIM x at_right a. poly 1 x / poly p x :> at_top then 1 / 2\n       else if LIM x at_right a. poly 1 x / poly p x :> at_bot then - 1 / 2\n            else 0) =\n      - 1 / 2)) &&&\n    (0 < (if LIM x at_left b. 1 / poly p x :> at_top then 1 / 2\n          else if LIM x at_left b. 1 / poly p x :> at_bot then - 1 / 2\n               else 0)) =\n    ((if LIM x at_left b. poly 1 x / poly p x :> at_top then 1 / 2\n      else if LIM x at_left b. poly 1 x / poly p x :> at_bot then - 1 / 2\n           else 0) =\n     1 / 2) &&&\n    ((if LIM x at_left b. 1 / poly p x :> at_top then 1 / 2\n      else if LIM x at_left b. 1 / poly p x :> at_bot then - 1 / 2 else 0)\n     < 0) =\n    ((if LIM x at_left b. poly 1 x / poly p x :> at_top then 1 / 2\n      else if LIM x at_left b. poly 1 x / poly p x :> at_bot then - 1 / 2\n           else 0) =\n     - 1 / 2)", "by auto"], ["proof (state)\nthis:\n  (0 < ja) = (jumpF_polyR 1 p a = 1 / 2)\n  (ja < 0) = (jumpF_polyR 1 p a = - 1 / 2)\n  (0 < jb) = (jumpF_polyL 1 p b = 1 / 2)\n  (jb < 0) = (jumpF_polyL 1 p b = - 1 / 2)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have [simp]: \n          \"poly p a \\<noteq>0 \\<Longrightarrow> continuous (at_right a) f\"\n          \"poly p b \\<noteq>0 \\<Longrightarrow> continuous (at_left b) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p a \\<noteq> 0 \\<Longrightarrow> continuous (at_right a) f) &&&\n    (poly p b \\<noteq> 0 \\<Longrightarrow> continuous (at_left b) f)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p a \\<noteq> 0 \\<Longrightarrow>\n     continuous (at_right a) (\\<lambda>x. 1 / poly p x)) &&&\n    (poly p b \\<noteq> 0 \\<Longrightarrow>\n     continuous (at_left b) (\\<lambda>x. 1 / poly p x))", "by (auto intro!: continuous_intros )"], ["proof (state)\nthis:\n  poly p a \\<noteq> 0 \\<Longrightarrow> continuous (at_right a) f\n  poly p b \\<noteq> 0 \\<Longrightarrow> continuous (at_left b) f\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have not_right_left: False when \"(right greater \\<and> left less \\<or> right less \\<and> left greater)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have [simp]: \"f a > 0 \\<longleftrightarrow> poly p a > 0\" \"f a < 0 \\<longleftrightarrow> poly p a < 0\"\n             \"f b > 0 \\<longleftrightarrow> poly p b > 0\" \"f b < 0 \\<longleftrightarrow> poly p b < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0 < f a) = (0 < poly p a) &&& (f a < 0) = (poly p a < 0)) &&&\n    (0 < f b) = (0 < poly p b) &&& (f b < 0) = (poly p b < 0)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0 < 1 / poly p a) = (0 < poly p a) &&&\n     (1 / poly p a < 0) = (poly p a < 0)) &&&\n    (0 < 1 / poly p b) = (0 < poly p b) &&&\n    (1 / poly p b < 0) = (poly p b < 0)", "by auto"], ["proof (state)\nthis:\n  (0 < f a) = (0 < poly p a)\n  (f a < 0) = (poly p a < 0)\n  (0 < f b) = (0 < poly p b)\n  (f b < 0) = (poly p b < 0)\n\ngoal (1 subgoal):\n 1. False", "have \"continuous_on {a<..<b} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a<..<b} f", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {a<..<b} (\\<lambda>x. 1 / poly p x)", "using noroot"], ["proof (prove)\nusing this:\n  {x. a < x \\<and> x < b \\<and> poly p x = 0} = {}\n\ngoal (1 subgoal):\n 1. continuous_on {a<..<b} (\\<lambda>x. 1 / poly p x)", "by (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {a<..<b} f\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  continuous_on {a<..<b} f", "have \"\\<exists>x>a. x < b \\<and> f x = 0\""], ["proof (prove)\nusing this:\n  continuous_on {a<..<b} f\n\ngoal (1 subgoal):\n 1. \\<exists>x>a. x < b \\<and> f x = 0", "apply (elim jumpF_IVT[OF \\<open>a<b\\<close>,of f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < jumpF f (at_right a) \\<or>\n     continuous (at_right a) f \\<and> 0 < f a) \\<and>\n    (jumpF f (at_left b) < 0 \\<or>\n     continuous (at_left b) f \\<and> f b < 0) \\<or>\n    (jumpF f (at_right a) < 0 \\<or>\n     continuous (at_right a) f \\<and> f a < 0) \\<and>\n    (0 < jumpF f (at_left b) \\<or> continuous (at_left b) f \\<and> 0 < f b)", "using that"], ["proof (prove)\nusing this:\n  right (\\<lambda>x y. y < x) \\<and> left (<) \\<or>\n  right (<) \\<and> left (\\<lambda>x y. y < x)\n\ngoal (1 subgoal):\n 1. (0 < jumpF f (at_right a) \\<or>\n     continuous (at_right a) f \\<and> 0 < f a) \\<and>\n    (jumpF f (at_left b) < 0 \\<or>\n     continuous (at_left b) f \\<and> f b < 0) \\<or>\n    (jumpF f (at_right a) < 0 \\<or>\n     continuous (at_right a) f \\<and> f a < 0) \\<and>\n    (0 < jumpF f (at_left b) \\<or> continuous (at_left b) f \\<and> 0 < f b)", "unfolding right_def left_def"], ["proof (prove)\nusing this:\n  (0 < ja \\<or> continuous (at_right a) f \\<and> 0 < poly p a) \\<and>\n  (jb < 0 \\<or> continuous (at_left b) f \\<and> poly p b < 0) \\<or>\n  (ja < 0 \\<or> continuous (at_right a) f \\<and> poly p a < 0) \\<and>\n  (0 < jb \\<or> continuous (at_left b) f \\<and> 0 < poly p b)\n\ngoal (1 subgoal):\n 1. (0 < jumpF f (at_right a) \\<or>\n     continuous (at_right a) f \\<and> 0 < f a) \\<and>\n    (jumpF f (at_left b) < 0 \\<or>\n     continuous (at_left b) f \\<and> f b < 0) \\<or>\n    (jumpF f (at_right a) < 0 \\<or>\n     continuous (at_right a) f \\<and> f a < 0) \\<and>\n    (0 < jumpF f (at_left b) \\<or> continuous (at_left b) f \\<and> 0 < f b)", "by (fold ja_def jb_def,auto)"], ["proof (state)\nthis:\n  \\<exists>x>a. x < b \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>a. x < b \\<and> f x = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>x>a. x < b \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. False", "using noroot"], ["proof (prove)\nusing this:\n  \\<exists>x>a. x < b \\<and> f x = 0\n  {x. a < x \\<and> x < b \\<and> poly p x = 0} = {}\n\ngoal (1 subgoal):\n 1. False", "using f_def"], ["proof (prove)\nusing this:\n  \\<exists>x>a. x < b \\<and> f x = 0\n  {x. a < x \\<and> x < b \\<and> poly p x = 0} = {}\n  f = (\\<lambda>x. 1 / poly p x)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  right (\\<lambda>x y. y < x) \\<and> left (<) \\<or>\n  right (<) \\<and> left (\\<lambda>x y. y < x) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have ?thesis when \"poly p a>0 \\<and> poly p b>0 \\<or> poly p a<0 \\<and> poly p b<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "using that jumpF_poly_noroot"], ["proof (prove)\nusing this:\n  0 < poly p a \\<and> 0 < poly p b \\<or> poly p a < 0 \\<and> poly p b < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "unfolding cross_alt_def"], ["proof (prove)\nusing this:\n  0 < poly p a \\<and> 0 < poly p b \\<or> poly p a < 0 \\<and> poly p b < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int\n     (\\<bar>sign (poly 1 a) - sign (poly p a)\\<bar> -\n      \\<bar>sign (poly 1 b) - sign (poly p b)\\<bar>) /\n    2", "by auto"], ["proof (state)\nthis:\n  0 < poly p a \\<and> 0 < poly p b \\<or>\n  poly p a < 0 \\<and> poly p b < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  0 < poly p a \\<and> 0 < poly p b \\<or>\n  poly p a < 0 \\<and> poly p b < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have False when \"poly p a>0 \\<and> poly p b<0 \\<or> poly p a<0 \\<and> poly p b>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "apply (rule not_right_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. right (\\<lambda>x y. y < x) \\<and> left (<) \\<or>\n    right (<) \\<and> left (\\<lambda>x y. y < x)", "unfolding right_def left_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < ja \\<or> continuous (at_right a) f \\<and> 0 < poly p a) \\<and>\n    (jb < 0 \\<or> continuous (at_left b) f \\<and> poly p b < 0) \\<or>\n    (ja < 0 \\<or> continuous (at_right a) f \\<and> poly p a < 0) \\<and>\n    (0 < jb \\<or> continuous (at_left b) f \\<and> 0 < poly p b)", "using that"], ["proof (prove)\nusing this:\n  0 < poly p a \\<and> poly p b < 0 \\<or> poly p a < 0 \\<and> 0 < poly p b\n\ngoal (1 subgoal):\n 1. (0 < ja \\<or> continuous (at_right a) f \\<and> 0 < poly p a) \\<and>\n    (jb < 0 \\<or> continuous (at_left b) f \\<and> poly p b < 0) \\<or>\n    (ja < 0 \\<or> continuous (at_right a) f \\<and> poly p a < 0) \\<and>\n    (0 < jb \\<or> continuous (at_left b) f \\<and> 0 < poly p b)", "by auto"], ["proof (state)\nthis:\n  0 < poly p a \\<and> poly p b < 0 \\<or>\n  poly p a < 0 \\<and> 0 < poly p b \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  0 < poly p a \\<and> poly p b < 0 \\<or>\n  poly p a < 0 \\<and> 0 < poly p b \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have ?thesis when \"poly p a=0\" \"poly p b>0 \\<or> poly p b <0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have \"ja>0 \\<or> ja < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ja \\<or> ja < 0", "using ja_alt \\<open>p\\<noteq>0\\<close> \\<open>poly p a=0\\<close>"], ["proof (prove)\nusing this:\n  ja =\n  (if p \\<noteq> 0 \\<and> poly p a = 0\n   then if sign_r_pos p a = (0 < poly 1 a) then 1 / 2 else - 1 / 2 else 0)\n  p \\<noteq> 0\n  poly p a = 0\n\ngoal (1 subgoal):\n 1. 0 < ja \\<or> ja < 0", "by argo"], ["proof (state)\nthis:\n  0 < ja \\<or> ja < 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  0 < ja \\<or> ja < 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have False when \"ja > 0 \\<and> poly p b<0 \\<or> ja < 0 \\<and> poly p b>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "apply (rule not_right_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. right (\\<lambda>x y. y < x) \\<and> left (<) \\<or>\n    right (<) \\<and> left (\\<lambda>x y. y < x)", "unfolding right_def left_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < ja \\<or> continuous (at_right a) f \\<and> 0 < poly p a) \\<and>\n    (jb < 0 \\<or> continuous (at_left b) f \\<and> poly p b < 0) \\<or>\n    (ja < 0 \\<or> continuous (at_right a) f \\<and> poly p a < 0) \\<and>\n    (0 < jb \\<or> continuous (at_left b) f \\<and> 0 < poly p b)", "using that"], ["proof (prove)\nusing this:\n  0 < ja \\<and> poly p b < 0 \\<or> ja < 0 \\<and> 0 < poly p b\n\ngoal (1 subgoal):\n 1. (0 < ja \\<or> continuous (at_right a) f \\<and> 0 < poly p a) \\<and>\n    (jb < 0 \\<or> continuous (at_left b) f \\<and> poly p b < 0) \\<or>\n    (ja < 0 \\<or> continuous (at_right a) f \\<and> poly p a < 0) \\<and>\n    (0 < jb \\<or> continuous (at_left b) f \\<and> 0 < poly p b)", "by fastforce"], ["proof (state)\nthis:\n  0 < ja \\<and> poly p b < 0 \\<or>\n  ja < 0 \\<and> 0 < poly p b \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  0 < ja \\<and> poly p b < 0 \\<or>\n  ja < 0 \\<and> 0 < poly p b \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have ?thesis when \"ja >0 \\<and> poly p b>0 \\<or> ja < 0 \\<and> poly p b<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "using that jumpF_poly_noroot \\<open>poly p a=0\\<close>"], ["proof (prove)\nusing this:\n  0 < ja \\<and> 0 < poly p b \\<or> ja < 0 \\<and> poly p b < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n  poly p a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "unfolding cross_alt_def"], ["proof (prove)\nusing this:\n  0 < ja \\<and> 0 < poly p b \\<or> ja < 0 \\<and> poly p b < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n  poly p a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int\n     (\\<bar>sign (poly 1 a) - sign (poly p a)\\<bar> -\n      \\<bar>sign (poly 1 b) - sign (poly p b)\\<bar>) /\n    2", "by auto"], ["proof (state)\nthis:\n  0 < ja \\<and> 0 < poly p b \\<or>\n  ja < 0 \\<and> poly p b < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "ultimately"], ["proof (chain)\npicking this:\n  0 < ja \\<or> ja < 0\n  0 < ja \\<and> poly p b < 0 \\<or>\n  ja < 0 \\<and> 0 < poly p b \\<Longrightarrow>\n  False\n  0 < ja \\<and> 0 < poly p b \\<or>\n  ja < 0 \\<and> poly p b < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < ja \\<or> ja < 0\n  0 < ja \\<and> poly p b < 0 \\<or>\n  ja < 0 \\<and> 0 < poly p b \\<Longrightarrow>\n  False\n  0 < ja \\<and> 0 < poly p b \\<or>\n  ja < 0 \\<and> poly p b < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "using that jumpF_poly_noroot"], ["proof (prove)\nusing this:\n  0 < ja \\<or> ja < 0\n  0 < ja \\<and> poly p b < 0 \\<or>\n  ja < 0 \\<and> 0 < poly p b \\<Longrightarrow>\n  False\n  0 < ja \\<and> 0 < poly p b \\<or>\n  ja < 0 \\<and> poly p b < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n  poly p a = 0\n  0 < poly p b \\<or> poly p b < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "unfolding cross_alt_def"], ["proof (prove)\nusing this:\n  0 < ja \\<or> ja < 0\n  0 < ja \\<and> poly p b < 0 \\<or>\n  ja < 0 \\<and> 0 < poly p b \\<Longrightarrow>\n  False\n  0 < ja \\<and> 0 < poly p b \\<or>\n  ja < 0 \\<and> poly p b < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int\n   (\\<bar>sign (poly 1 a) - sign (poly p a)\\<bar> -\n    \\<bar>sign (poly 1 b) - sign (poly p b)\\<bar>) /\n  2\n  poly p a = 0\n  0 < poly p b \\<or> poly p b < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int\n     (\\<bar>sign (poly 1 a) - sign (poly p a)\\<bar> -\n      \\<bar>sign (poly 1 b) - sign (poly p b)\\<bar>) /\n    2", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p a = 0; 0 < poly p b \\<or> poly p b < 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n                    real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p a = 0; 0 < poly p b \\<or> poly p b < 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n                    real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have ?thesis when \"poly p b=0\" \"poly p a>0 \\<or> poly p a <0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have \"jb>0 \\<or> jb < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < jb \\<or> jb < 0", "using jb_alt \\<open>p\\<noteq>0\\<close> \\<open>poly p b=0\\<close>"], ["proof (prove)\nusing this:\n  jb =\n  (if p \\<noteq> 0 \\<and> poly p b = 0\n   then if even (order b p) = (sign_r_pos p b = (0 < poly 1 b)) then 1 / 2\n        else - 1 / 2\n   else 0)\n  p \\<noteq> 0\n  poly p b = 0\n\ngoal (1 subgoal):\n 1. 0 < jb \\<or> jb < 0", "by argo"], ["proof (state)\nthis:\n  0 < jb \\<or> jb < 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  0 < jb \\<or> jb < 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have False when \"jb > 0 \\<and> poly p a<0 \\<or> jb < 0 \\<and> poly p a>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "apply (rule not_right_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. right (\\<lambda>x y. y < x) \\<and> left (<) \\<or>\n    right (<) \\<and> left (\\<lambda>x y. y < x)", "unfolding right_def left_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < ja \\<or> continuous (at_right a) f \\<and> 0 < poly p a) \\<and>\n    (jb < 0 \\<or> continuous (at_left b) f \\<and> poly p b < 0) \\<or>\n    (ja < 0 \\<or> continuous (at_right a) f \\<and> poly p a < 0) \\<and>\n    (0 < jb \\<or> continuous (at_left b) f \\<and> 0 < poly p b)", "using that"], ["proof (prove)\nusing this:\n  0 < jb \\<and> poly p a < 0 \\<or> jb < 0 \\<and> 0 < poly p a\n\ngoal (1 subgoal):\n 1. (0 < ja \\<or> continuous (at_right a) f \\<and> 0 < poly p a) \\<and>\n    (jb < 0 \\<or> continuous (at_left b) f \\<and> poly p b < 0) \\<or>\n    (ja < 0 \\<or> continuous (at_right a) f \\<and> poly p a < 0) \\<and>\n    (0 < jb \\<or> continuous (at_left b) f \\<and> 0 < poly p b)", "by fastforce"], ["proof (state)\nthis:\n  0 < jb \\<and> poly p a < 0 \\<or>\n  jb < 0 \\<and> 0 < poly p a \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  0 < jb \\<and> poly p a < 0 \\<or>\n  jb < 0 \\<and> 0 < poly p a \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have ?thesis when \"jb >0 \\<and> poly p a>0 \\<or> jb < 0 \\<and> poly p a<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "using that jumpF_poly_noroot \\<open>poly p b=0\\<close>"], ["proof (prove)\nusing this:\n  0 < jb \\<and> 0 < poly p a \\<or> jb < 0 \\<and> poly p a < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n  poly p b = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "unfolding cross_alt_def"], ["proof (prove)\nusing this:\n  0 < jb \\<and> 0 < poly p a \\<or> jb < 0 \\<and> poly p a < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n  poly p b = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int\n     (\\<bar>sign (poly 1 a) - sign (poly p a)\\<bar> -\n      \\<bar>sign (poly 1 b) - sign (poly p b)\\<bar>) /\n    2", "by auto"], ["proof (state)\nthis:\n  0 < jb \\<and> 0 < poly p a \\<or>\n  jb < 0 \\<and> poly p a < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "ultimately"], ["proof (chain)\npicking this:\n  0 < jb \\<or> jb < 0\n  0 < jb \\<and> poly p a < 0 \\<or>\n  jb < 0 \\<and> 0 < poly p a \\<Longrightarrow>\n  False\n  0 < jb \\<and> 0 < poly p a \\<or>\n  jb < 0 \\<and> poly p a < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < jb \\<or> jb < 0\n  0 < jb \\<and> poly p a < 0 \\<or>\n  jb < 0 \\<and> 0 < poly p a \\<Longrightarrow>\n  False\n  0 < jb \\<and> 0 < poly p a \\<or>\n  jb < 0 \\<and> poly p a < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "using that jumpF_poly_noroot"], ["proof (prove)\nusing this:\n  0 < jb \\<or> jb < 0\n  0 < jb \\<and> poly p a < 0 \\<or>\n  jb < 0 \\<and> 0 < poly p a \\<Longrightarrow>\n  False\n  0 < jb \\<and> 0 < poly p a \\<or>\n  jb < 0 \\<and> poly p a < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n  poly p b = 0\n  0 < poly p a \\<or> poly p a < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "unfolding cross_alt_def"], ["proof (prove)\nusing this:\n  0 < jb \\<or> jb < 0\n  0 < jb \\<and> poly p a < 0 \\<or>\n  jb < 0 \\<and> 0 < poly p a \\<Longrightarrow>\n  False\n  0 < jb \\<and> 0 < poly p a \\<or>\n  jb < 0 \\<and> poly p a < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int\n   (\\<bar>sign (poly 1 a) - sign (poly p a)\\<bar> -\n    \\<bar>sign (poly 1 b) - sign (poly p b)\\<bar>) /\n  2\n  poly p b = 0\n  0 < poly p a \\<or> poly p a < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int\n     (\\<bar>sign (poly 1 a) - sign (poly p a)\\<bar> -\n      \\<bar>sign (poly 1 b) - sign (poly p b)\\<bar>) /\n    2", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p b = 0; 0 < poly p a \\<or> poly p a < 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n                    real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p b = 0; 0 < poly p a \\<or> poly p a < 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n                    real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have ?thesis when \"poly p a=0\" \"poly p b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have \"jb>0 \\<or> jb < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < jb \\<or> jb < 0", "using jb_alt \\<open>p\\<noteq>0\\<close> \\<open>poly p b=0\\<close>"], ["proof (prove)\nusing this:\n  jb =\n  (if p \\<noteq> 0 \\<and> poly p b = 0\n   then if even (order b p) = (sign_r_pos p b = (0 < poly 1 b)) then 1 / 2\n        else - 1 / 2\n   else 0)\n  p \\<noteq> 0\n  poly p b = 0\n\ngoal (1 subgoal):\n 1. 0 < jb \\<or> jb < 0", "by argo"], ["proof (state)\nthis:\n  0 < jb \\<or> jb < 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  0 < jb \\<or> jb < 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have \"ja>0 \\<or> ja < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ja \\<or> ja < 0", "using ja_alt \\<open>p\\<noteq>0\\<close> \\<open>poly p a=0\\<close>"], ["proof (prove)\nusing this:\n  ja =\n  (if p \\<noteq> 0 \\<and> poly p a = 0\n   then if sign_r_pos p a = (0 < poly 1 a) then 1 / 2 else - 1 / 2 else 0)\n  p \\<noteq> 0\n  poly p a = 0\n\ngoal (1 subgoal):\n 1. 0 < ja \\<or> ja < 0", "by argo"], ["proof (state)\nthis:\n  0 < ja \\<or> ja < 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  0 < ja \\<or> ja < 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have False when \"ja>0 \\<and> jb<0 \\<or> ja<0 \\<and> jb>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "apply (rule not_right_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. right (\\<lambda>x y. y < x) \\<and> left (<) \\<or>\n    right (<) \\<and> left (\\<lambda>x y. y < x)", "unfolding right_def left_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < ja \\<or> continuous (at_right a) f \\<and> 0 < poly p a) \\<and>\n    (jb < 0 \\<or> continuous (at_left b) f \\<and> poly p b < 0) \\<or>\n    (ja < 0 \\<or> continuous (at_right a) f \\<and> poly p a < 0) \\<and>\n    (0 < jb \\<or> continuous (at_left b) f \\<and> 0 < poly p b)", "using that"], ["proof (prove)\nusing this:\n  0 < ja \\<and> jb < 0 \\<or> ja < 0 \\<and> 0 < jb\n\ngoal (1 subgoal):\n 1. (0 < ja \\<or> continuous (at_right a) f \\<and> 0 < poly p a) \\<and>\n    (jb < 0 \\<or> continuous (at_left b) f \\<and> poly p b < 0) \\<or>\n    (ja < 0 \\<or> continuous (at_right a) f \\<and> poly p a < 0) \\<and>\n    (0 < jb \\<or> continuous (at_left b) f \\<and> 0 < poly p b)", "by fastforce"], ["proof (state)\nthis:\n  0 < ja \\<and> jb < 0 \\<or> ja < 0 \\<and> 0 < jb \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  0 < ja \\<and> jb < 0 \\<or> ja < 0 \\<and> 0 < jb \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "have ?thesis when \"ja>0 \\<and> jb>0 \\<or> ja<0 \\<and> jb<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "using that jumpF_poly_noroot \\<open>poly p b=0\\<close> \\<open>poly p a=0\\<close>"], ["proof (prove)\nusing this:\n  0 < ja \\<and> 0 < jb \\<or> ja < 0 \\<and> jb < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n  poly p b = 0\n  poly p a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "unfolding cross_alt_def"], ["proof (prove)\nusing this:\n  0 < ja \\<and> 0 < jb \\<or> ja < 0 \\<and> jb < 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyL ?q ?p ?a = 0\n  poly ?p ?a \\<noteq> 0 \\<Longrightarrow> jumpF_polyR ?q ?p ?a = 0\n  poly p b = 0\n  poly p a = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int\n     (\\<bar>sign (poly 1 a) - sign (poly p a)\\<bar> -\n      \\<bar>sign (poly 1 b) - sign (poly p b)\\<bar>) /\n    2", "by auto"], ["proof (state)\nthis:\n  0 < ja \\<and> 0 < jb \\<or> ja < 0 \\<and> jb < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "ultimately"], ["proof (chain)\npicking this:\n  0 < jb \\<or> jb < 0\n  0 < ja \\<or> ja < 0\n  0 < ja \\<and> jb < 0 \\<or> ja < 0 \\<and> 0 < jb \\<Longrightarrow> False\n  0 < ja \\<and> 0 < jb \\<or> ja < 0 \\<and> jb < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < jb \\<or> jb < 0\n  0 < ja \\<or> ja < 0\n  0 < ja \\<and> jb < 0 \\<or> ja < 0 \\<and> 0 < jb \\<Longrightarrow> False\n  0 < ja \\<and> 0 < jb \\<or> ja < 0 \\<and> jb < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "by blast"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p a = 0; poly p b = 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n                    real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "ultimately"], ["proof (chain)\npicking this:\n  0 < poly p a \\<and> 0 < poly p b \\<or>\n  poly p a < 0 \\<and> poly p b < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n  0 < poly p a \\<and> poly p b < 0 \\<or>\n  poly p a < 0 \\<and> 0 < poly p b \\<Longrightarrow>\n  False\n  \\<lbrakk>poly p a = 0; 0 < poly p b \\<or> poly p b < 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n                    real_of_int (cross_alt 1 p a b) / 2\n  \\<lbrakk>poly p b = 0; 0 < poly p a \\<or> poly p a < 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n                    real_of_int (cross_alt 1 p a b) / 2\n  \\<lbrakk>poly p a = 0; poly p b = 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n                    real_of_int (cross_alt 1 p a b) / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < poly p a \\<and> 0 < poly p b \\<or>\n  poly p a < 0 \\<and> poly p b < 0 \\<Longrightarrow>\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n  0 < poly p a \\<and> poly p b < 0 \\<or>\n  poly p a < 0 \\<and> 0 < poly p b \\<Longrightarrow>\n  False\n  \\<lbrakk>poly p a = 0; 0 < poly p b \\<or> poly p b < 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n                    real_of_int (cross_alt 1 p a b) / 2\n  \\<lbrakk>poly p b = 0; 0 < poly p a \\<or> poly p a < 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n                    real_of_int (cross_alt 1 p a b) / 2\n  \\<lbrakk>poly p a = 0; poly p b = 0\\<rbrakk>\n  \\<Longrightarrow> jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n                    real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n    real_of_int (cross_alt 1 p a b) / 2", "by argo"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a - jumpF_polyL 1 p b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "finally"], ["proof (chain)\npicking this:\n  cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "."], ["proof (state)\nthis:\n  cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0;\n   {x. a < x \\<and> x < b \\<and> poly p x = 0} = {}\\<rbrakk>\n  \\<Longrightarrow> cindex_polyE a b 1 p =\n                    real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>m<degree p.\n          \\<forall>x.\n             m = degree x \\<longrightarrow>\n             cindex_polyE a b 1 x =\n             real_of_int (cross_alt 1 x a b) / 2 \\<Longrightarrow>\n       cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0;\n   {x. a < x \\<and> x < b \\<and> poly p x = 0} = {}\\<rbrakk>\n  \\<Longrightarrow> cindex_polyE a b 1 p =\n                    real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>m<degree p.\n          \\<forall>x.\n             m = degree x \\<longrightarrow>\n             cindex_polyE a b 1 x =\n             real_of_int (cross_alt 1 x a b) / 2 \\<Longrightarrow>\n       cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "have ?case when \"p\\<noteq>0\" and no_empty:\"{x.  a< x\\<and> x< b \\<and> poly p x=0 } \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "define roots where \"roots\\<equiv>{x.  a< x\\<and> x< b \\<and> poly p x=0 }\""], ["proof (state)\nthis:\n  roots \\<equiv> {x. a < x \\<and> x < b \\<and> poly p x = 0}\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "have \"finite roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite roots", "unfolding roots_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. a < x \\<and> x < b \\<and> poly p x = 0}", "using poly_roots_finite[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. a < x \\<and> x < b \\<and> poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  finite roots\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "define max_r where \"max_r\\<equiv>Max roots\""], ["proof (state)\nthis:\n  max_r \\<equiv> Max roots\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "hence \"poly p max_r=0\" and \"a<max_r\" and \"max_r<b\""], ["proof (prove)\nusing this:\n  max_r \\<equiv> Max roots\n\ngoal (1 subgoal):\n 1. poly p max_r = 0 &&& a < max_r &&& max_r < b", "using Max_in[OF \\<open>finite roots\\<close>] no_empty"], ["proof (prove)\nusing this:\n  max_r \\<equiv> Max roots\n  roots \\<noteq> {} \\<Longrightarrow> Max roots \\<in> roots\n  {x. a < x \\<and> x < b \\<and> poly p x = 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. poly p max_r = 0 &&& a < max_r &&& max_r < b", "unfolding roots_def"], ["proof (prove)\nusing this:\n  max_r \\<equiv> Max {x. a < x \\<and> x < b \\<and> poly p x = 0}\n  {x. a < x \\<and> x < b \\<and> poly p x = 0} \\<noteq> {} \\<Longrightarrow>\n  Max {x. a < x \\<and> x < b \\<and> poly p x = 0}\n  \\<in> {x. a < x \\<and> x < b \\<and> poly p x = 0}\n  {x. a < x \\<and> x < b \\<and> poly p x = 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. poly p max_r = 0 &&& a < max_r &&& max_r < b", "by auto"], ["proof (state)\nthis:\n  poly p max_r = 0\n  a < max_r\n  max_r < b\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "define max_rp where \"max_rp\\<equiv>[:-max_r,1:]^order max_r p\""], ["proof (state)\nthis:\n  max_rp \\<equiv> [:- max_r, 1:] ^ order max_r p\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "then"], ["proof (chain)\npicking this:\n  max_rp \\<equiv> [:- max_r, 1:] ^ order max_r p", "obtain p' where p'_def:\"p=p'*max_rp\" and \"\\<not> [:-max_r,1:] dvd p'\""], ["proof (prove)\nusing this:\n  max_rp \\<equiv> [:- max_r, 1:] ^ order max_r p\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p = p' * max_rp; \\<not> [:- max_r, 1:] dvd p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>p\\<noteq>0\\<close> mult.commute order_decomp)"], ["proof (state)\nthis:\n  p = p' * max_rp\n  \\<not> [:- max_r, 1:] dvd p'\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "hence \"p'\\<noteq>0\" and \"max_rp\\<noteq>0\" and max_r_nz:\"poly p' max_r\\<noteq>0\""], ["proof (prove)\nusing this:\n  p = p' * max_rp\n  \\<not> [:- max_r, 1:] dvd p'\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0 &&& max_rp \\<noteq> 0 &&& poly p' max_r \\<noteq> 0", "(*and \"poly p' a\\<noteq>0\" and \"poly p' b\\<noteq>0\" *)\n      (*and  \"poly max_rp a\\<noteq>0\" and \"poly max_rp b\\<noteq>0\"*)"], ["proof (prove)\nusing this:\n  p = p' * max_rp\n  \\<not> [:- max_r, 1:] dvd p'\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0 &&& max_rp \\<noteq> 0 &&& poly p' max_r \\<noteq> 0", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = p' * max_rp\n  \\<not> [:- max_r, 1:] dvd p'\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0 &&& max_rp \\<noteq> 0 &&& poly p' max_r \\<noteq> 0", "by (auto simp add: dvd_iff_poly_eq_0)"], ["proof (state)\nthis:\n  p' \\<noteq> 0\n  max_rp \\<noteq> 0\n  poly p' max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "define max_r_sign where \"max_r_sign\\<equiv>if odd(order max_r p) then -1 else 1::int\""], ["proof (state)\nthis:\n  max_r_sign \\<equiv> if odd (order max_r p) then - 1 else 1\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "define roots' where \"roots'\\<equiv>{x.  a< x\\<and> x< b \\<and> poly p' x=0}\""], ["proof (state)\nthis:\n  roots' \\<equiv> {x. a < x \\<and> x < b \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "have \"cindex_polyE a b 1 p = jumpF_polyR 1 p a + (\\<Sum>x\\<in>roots. jump_poly 1 p x) - jumpF_polyL 1 p b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p =\n    jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n    jumpF_polyL 1 p b", "unfolding cindex_polyE_def cindex_poly_def roots_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a +\n    real_of_int\n     (\\<Sum>x | poly p x = 0 \\<and> a < x \\<and> x < b. jump_poly 1 p x) -\n    jumpF_polyL 1 p b =\n    jumpF_polyR 1 p a +\n    real_of_int\n     (\\<Sum>x | a < x \\<and> x < b \\<and> poly p x = 0. jump_poly 1 p x) -\n    jumpF_polyL 1 p b", "by (simp,meson)"], ["proof (state)\nthis:\n  cindex_polyE a b 1 p =\n  jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n  jumpF_polyL 1 p b\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "also"], ["proof (state)\nthis:\n  cindex_polyE a b 1 p =\n  jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n  jumpF_polyL 1 p b\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "have \"... = max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r \n        + max_r_sign * jumpF_polyR 1 p' a - jumpF_polyL 1 p' b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n    jumpF_polyL 1 p b =\n    real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n    real_of_int max_r_sign * jumpF_polyR 1 p' a -\n    jumpF_polyL 1 p' b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n    jumpF_polyL 1 p b =\n    real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n    real_of_int max_r_sign * jumpF_polyR 1 p' a -\n    jumpF_polyL 1 p' b", "have \"(\\<Sum>x\\<in>roots. jump_poly 1 p x) = max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r", "have \"(\\<Sum>x\\<in>roots. jump_poly 1 p x)= (\\<Sum>x\\<in>roots'. jump_poly 1 p x)+ jump_poly 1 p max_r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "have \"roots = insert max_r roots'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. roots = insert max_r roots'", "unfolding roots_def roots'_def p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x < b \\<and> poly (p' * max_rp) x = 0} =\n    insert max_r {x. a < x \\<and> x < b \\<and> poly p' x = 0}", "using \\<open>poly p max_r=0\\<close> \\<open>a<max_r\\<close> \\<open>max_r<b\\<close> \\<open>p\\<noteq>0\\<close> order_root"], ["proof (prove)\nusing this:\n  poly p max_r = 0\n  a < max_r\n  max_r < b\n  p \\<noteq> 0\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. {x. a < x \\<and> x < b \\<and> poly (p' * max_rp) x = 0} =\n    insert max_r {x. a < x \\<and> x < b \\<and> poly p' x = 0}", "apply (subst max_rp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly p max_r = 0; a < max_r; max_r < b; p \\<noteq> 0;\n     \\<And>p a.\n        (poly p a = (0::?'a4)) = (p = 0 \\<or> order a p \\<noteq> 0)\\<rbrakk>\n    \\<Longrightarrow> {x. a < x \\<and>\n                          x < b \\<and>\n                          poly (p' * [:- max_r, 1:] ^ order max_r p) x =\n                          0} =\n                      insert max_r\n                       {x. a < x \\<and> x < b \\<and> poly p' x = 0}", "by auto"], ["proof (state)\nthis:\n  roots = insert max_r roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "moreover"], ["proof (state)\nthis:\n  roots = insert max_r roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "have \"finite roots'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite roots'", "unfolding roots'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. a < x \\<and> x < b \\<and> poly p' x = 0}", "using poly_roots_finite[OF \\<open>p'\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  finite {x. poly p' x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. a < x \\<and> x < b \\<and> poly p' x = 0}", "by auto"], ["proof (state)\nthis:\n  finite roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "moreover"], ["proof (state)\nthis:\n  finite roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "have \"max_r \\<notin> roots'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_r \\<notin> roots'", "unfolding roots'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_r \\<notin> {x. a < x \\<and> x < b \\<and> poly p' x = 0}", "using max_r_nz"], ["proof (prove)\nusing this:\n  poly p' max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. max_r \\<notin> {x. a < x \\<and> x < b \\<and> poly p' x = 0}", "by auto"], ["proof (state)\nthis:\n  max_r \\<notin> roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "ultimately"], ["proof (chain)\npicking this:\n  roots = insert max_r roots'\n  finite roots'\n  max_r \\<notin> roots'", "show ?thesis"], ["proof (prove)\nusing this:\n  roots = insert max_r roots'\n  finite roots'\n  max_r \\<notin> roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "using sum.insert[of roots' max_r]"], ["proof (prove)\nusing this:\n  roots = insert max_r roots'\n  finite roots'\n  max_r \\<notin> roots'\n  \\<lbrakk>finite roots'; max_r \\<notin> roots'\\<rbrakk>\n  \\<Longrightarrow> sum ?g (insert max_r roots') = ?g max_r + sum ?g roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    sum (jump_poly 1 p) roots' + jump_poly 1 p max_r", "by auto"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots =\n  sum (jump_poly 1 p) roots' + jump_poly 1 p max_r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots =\n  sum (jump_poly 1 p) roots' + jump_poly 1 p max_r\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r", "moreover"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots =\n  sum (jump_poly 1 p) roots' + jump_poly 1 p max_r\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r", "have \"(\\<Sum>x\\<in>roots'. jump_poly 1 p x) = max_r_sign * cindex_poly a b 1 p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'", "have \"(\\<Sum>x\\<in>roots'. jump_poly 1 p x) = (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' =\n    (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x)", "proof (rule sum.cong,rule refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "assume \"x \\<in> roots'\""], ["proof (state)\nthis:\n  x \\<in> roots'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "hence \"x\\<noteq>max_r\""], ["proof (prove)\nusing this:\n  x \\<in> roots'\n\ngoal (1 subgoal):\n 1. x \\<noteq> max_r", "using max_r_nz"], ["proof (prove)\nusing this:\n  x \\<in> roots'\n  poly p' max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> max_r", "unfolding roots'_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. a < x \\<and> x < b \\<and> poly p' x = 0}\n  poly p' max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> max_r", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> max_r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "hence \"poly max_rp x\\<noteq>0\""], ["proof (prove)\nusing this:\n  x \\<noteq> max_r\n\ngoal (1 subgoal):\n 1. poly max_rp x \\<noteq> 0", "using poly_power_n_eq"], ["proof (prove)\nusing this:\n  x \\<noteq> max_r\n  ?n \\<noteq> 0 \\<Longrightarrow>\n  (poly ([:- ?a, 1::?'a:] ^ ?n) ?x = (0::?'a)) = (?x = ?a)\n\ngoal (1 subgoal):\n 1. poly max_rp x \\<noteq> 0", "unfolding max_rp_def"], ["proof (prove)\nusing this:\n  x \\<noteq> max_r\n  ?n \\<noteq> 0 \\<Longrightarrow>\n  (poly ([:- ?a, 1::?'a:] ^ ?n) ?x = (0::?'a)) = (?x = ?a)\n\ngoal (1 subgoal):\n 1. poly ([:- max_r, 1:] ^ order max_r p) x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly max_rp x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "hence \"order x max_rp=0\""], ["proof (prove)\nusing this:\n  poly max_rp x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x max_rp = 0", "by (metis order_root)"], ["proof (state)\nthis:\n  order x max_rp = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "moreover"], ["proof (state)\nthis:\n  order x max_rp = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "have \"jump_poly 1 max_rp x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly 1 max_rp x = 0", "using \\<open>poly max_rp x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly max_rp x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 max_rp x = 0", "by (metis jump_poly_not_root)"], ["proof (state)\nthis:\n  jump_poly 1 max_rp x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "moreover"], ["proof (state)\nthis:\n  jump_poly 1 max_rp x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "have \"x\\<in>roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> roots", "using \\<open>x \\<in> roots'\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> roots'\n\ngoal (1 subgoal):\n 1. x \\<in> roots", "unfolding roots_def roots'_def p'_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. a < x \\<and> x < b \\<and> poly p' x = 0}\n\ngoal (1 subgoal):\n 1. x \\<in> {x. a < x \\<and> x < b \\<and> poly (p' * max_rp) x = 0}", "by auto"], ["proof (state)\nthis:\n  x \\<in> roots\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "hence \"x<max_r\""], ["proof (prove)\nusing this:\n  x \\<in> roots\n\ngoal (1 subgoal):\n 1. x < max_r", "using Max_ge[OF \\<open>finite roots\\<close>,of x] \\<open>x\\<noteq>max_r\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> roots\n  x \\<in> roots \\<Longrightarrow> x \\<le> Max roots\n  x \\<noteq> max_r\n\ngoal (1 subgoal):\n 1. x < max_r", "by (fold max_r_def,auto)"], ["proof (state)\nthis:\n  x < max_r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "hence \"sign (poly max_rp x) = max_r_sign\""], ["proof (prove)\nusing this:\n  x < max_r\n\ngoal (1 subgoal):\n 1. sign (poly max_rp x) = max_r_sign", "using \\<open>poly max_rp x \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  x < max_r\n  poly max_rp x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign (poly max_rp x) = max_r_sign", "unfolding max_r_sign_def max_rp_def sign_def"], ["proof (prove)\nusing this:\n  x < max_r\n  poly ([:- max_r, 1:] ^ order max_r p) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if 0 < poly ([:- max_r, 1:] ^ order max_r p) x then 1\n     else if poly ([:- max_r, 1:] ^ order max_r p) x = 0 then 0 else - 1) =\n    (if odd (order max_r p) then - 1 else 1)", "by (subst poly_power,simp add:linorder_class.not_less zero_less_power_eq)"], ["proof (state)\nthis:\n  sign (poly max_rp x) = max_r_sign\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> roots' \\<Longrightarrow>\n       jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "ultimately"], ["proof (chain)\npicking this:\n  order x max_rp = 0\n  jump_poly 1 max_rp x = 0\n  sign (poly max_rp x) = max_r_sign", "show \"jump_poly 1 p x = max_r_sign * jump_poly 1 p' x\""], ["proof (prove)\nusing this:\n  order x max_rp = 0\n  jump_poly 1 max_rp x = 0\n  sign (poly max_rp x) = max_r_sign\n\ngoal (1 subgoal):\n 1. jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "using jump_poly_1_mult[of p' x max_rp]"], ["proof (prove)\nusing this:\n  order x max_rp = 0\n  jump_poly 1 max_rp x = 0\n  sign (poly max_rp x) = max_r_sign\n  poly p' x \\<noteq> 0 \\<or> poly max_rp x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p' * max_rp) x =\n  sign (poly max_rp x) * jump_poly 1 p' x +\n  sign (poly p' x) * jump_poly 1 max_rp x\n\ngoal (1 subgoal):\n 1. jump_poly 1 p x = max_r_sign * jump_poly 1 p' x", "unfolding p'_def"], ["proof (prove)\nusing this:\n  order x max_rp = 0\n  jump_poly 1 max_rp x = 0\n  sign (poly max_rp x) = max_r_sign\n  poly p' x \\<noteq> 0 \\<or> poly max_rp x \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p' * max_rp) x =\n  sign (poly max_rp x) * jump_poly 1 p' x +\n  sign (poly p' x) * jump_poly 1 max_rp x\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p' * max_rp) x = max_r_sign * jump_poly 1 p' x", "by (simp add: \\<open>poly max_rp x \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  jump_poly 1 p x = max_r_sign * jump_poly 1 p' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots' =\n  (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x)\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'", "also"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots' =\n  (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x)\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'", "have \"... = max_r_sign * (\\<Sum>x\\<in>roots'. jump_poly 1 p' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x) =\n    max_r_sign * sum (jump_poly 1 p') roots'", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x) =\n  max_r_sign * sum (jump_poly 1 p') roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>roots'. max_r_sign * jump_poly 1 p' x) =\n  max_r_sign * sum (jump_poly 1 p') roots'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'", "have \"... = max_r_sign * cindex_poly a b 1 p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_r_sign * sum (jump_poly 1 p') roots' =\n    max_r_sign * cindex_poly a b 1 p'", "unfolding cindex_poly_def roots'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_r_sign *\n    (\\<Sum>x | a < x \\<and> x < b \\<and> poly p' x = 0. jump_poly 1 p' x) =\n    max_r_sign *\n    (\\<Sum>x | poly p' x = 0 \\<and> a < x \\<and> x < b. jump_poly 1 p' x)", "by meson"], ["proof (state)\nthis:\n  max_r_sign * sum (jump_poly 1 p') roots' =\n  max_r_sign * cindex_poly a b 1 p'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'", "finally"], ["proof (chain)\npicking this:\n  sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'", "show ?thesis"], ["proof (prove)\nusing this:\n  sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'", "."], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r", "ultimately"], ["proof (chain)\npicking this:\n  sum (jump_poly 1 p) roots =\n  sum (jump_poly 1 p) roots' + jump_poly 1 p max_r\n  sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'", "show ?thesis"], ["proof (prove)\nusing this:\n  sum (jump_poly 1 p) roots =\n  sum (jump_poly 1 p) roots' + jump_poly 1 p max_r\n  sum (jump_poly 1 p) roots' = max_r_sign * cindex_poly a b 1 p'\n\ngoal (1 subgoal):\n 1. sum (jump_poly 1 p) roots =\n    max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r", "by simp"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots =\n  max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots =\n  max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n    jumpF_polyL 1 p b =\n    real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n    real_of_int max_r_sign * jumpF_polyR 1 p' a -\n    jumpF_polyL 1 p' b", "moreover"], ["proof (state)\nthis:\n  sum (jump_poly 1 p) roots =\n  max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n    jumpF_polyL 1 p b =\n    real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n    real_of_int max_r_sign * jumpF_polyR 1 p' a -\n    jumpF_polyL 1 p' b", "have \"jumpF_polyR 1 p a = max_r_sign * jumpF_polyR 1 p' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a", "define f where \"f = (\\<lambda>x. 1 / poly max_rp x)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. 1 / poly max_rp x)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a", "define g where \"g = (\\<lambda>x. 1 / poly p' x)\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. 1 / poly p' x)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a", "have \"jumpF_polyR 1 p a = jumpF (\\<lambda>x. f x * g x) (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a = jumpF (\\<lambda>x. f x * g x) (at_right a)", "unfolding jumpF_polyR_def f_def g_def p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly 1 x / poly (p' * max_rp) x) (at_right a) =\n    jumpF (\\<lambda>x. 1 / poly max_rp x * (1 / poly p' x)) (at_right a)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a = jumpF (\\<lambda>x. f x * g x) (at_right a)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a", "also"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a = jumpF (\\<lambda>x. f x * g x) (at_right a)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a", "have \"... = sgn (f a) * jumpF g (at_right a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) (at_right a) =\n    sgn (f a) * jumpF g (at_right a)", "proof (rule jumpF_times)"], ["proof (state)\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f a) (at_right a)\n 2. f a \\<noteq> 0\n 3. at_right a \\<noteq> bot", "have [simp]: \"poly max_rp a \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly max_rp a \\<noteq> 0", "unfolding max_rp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ([:- max_r, 1:] ^ order max_r p) a \\<noteq> 0", "using \\<open>max_r>a\\<close>"], ["proof (prove)\nusing this:\n  a < max_r\n\ngoal (1 subgoal):\n 1. poly ([:- max_r, 1:] ^ order max_r p) a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly max_rp a \\<noteq> 0\n\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f a) (at_right a)\n 2. f a \\<noteq> 0\n 3. at_right a \\<noteq> bot", "show \"(f \\<longlongrightarrow> f a) (at_right a)\" \"f a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f a) (at_right a) &&& f a \\<noteq> 0", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. 1 / poly max_rp x) \\<longlongrightarrow>\n     1 / poly max_rp a)\n     (at_right a) &&&\n    1 / poly max_rp a \\<noteq> 0", "by (auto intro:tendsto_intros)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f a) (at_right a)\n  f a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. at_right a \\<noteq> bot", "qed auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x * g x) (at_right a) =\n  sgn (f a) * jumpF g (at_right a)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a", "also"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x * g x) (at_right a) =\n  sgn (f a) * jumpF g (at_right a)\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a", "have \"... = max_r_sign * jumpF_polyR 1 p' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (f a) * jumpF g (at_right a) =\n    real_of_int max_r_sign * jumpF_polyR 1 p' a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn (f a) * jumpF g (at_right a) =\n    real_of_int max_r_sign * jumpF_polyR 1 p' a", "have \"sgn (f a) = max_r_sign\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (f a) = real_of_int max_r_sign", "unfolding max_r_sign_def f_def max_rp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (1 / poly ([:- max_r, 1:] ^ order max_r p) a) =\n    real_of_int (if odd (order max_r p) then - 1 else 1)", "using \\<open>a<max_r\\<close>"], ["proof (prove)\nusing this:\n  a < max_r\n\ngoal (1 subgoal):\n 1. sgn (1 / poly ([:- max_r, 1:] ^ order max_r p) a) =\n    real_of_int (if odd (order max_r p) then - 1 else 1)", "by (auto simp add:sgn_power)"], ["proof (state)\nthis:\n  sgn (f a) = real_of_int max_r_sign\n\ngoal (1 subgoal):\n 1. sgn (f a) * jumpF g (at_right a) =\n    real_of_int max_r_sign * jumpF_polyR 1 p' a", "then"], ["proof (chain)\npicking this:\n  sgn (f a) = real_of_int max_r_sign", "show ?thesis"], ["proof (prove)\nusing this:\n  sgn (f a) = real_of_int max_r_sign\n\ngoal (1 subgoal):\n 1. sgn (f a) * jumpF g (at_right a) =\n    real_of_int max_r_sign * jumpF_polyR 1 p' a", "unfolding jumpF_polyR_def g_def"], ["proof (prove)\nusing this:\n  sgn (f a) = real_of_int max_r_sign\n\ngoal (1 subgoal):\n 1. sgn (f a) * jumpF (\\<lambda>x. 1 / poly p' x) (at_right a) =\n    real_of_int max_r_sign *\n    jumpF (\\<lambda>x. poly 1 x / poly p' x) (at_right a)", "by auto"], ["proof (state)\nthis:\n  sgn (f a) * jumpF g (at_right a) =\n  real_of_int max_r_sign * jumpF_polyR 1 p' a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn (f a) * jumpF g (at_right a) =\n  real_of_int max_r_sign * jumpF_polyR 1 p' a\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a", "finally"], ["proof (chain)\npicking this:\n  jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a", "."], ["proof (state)\nthis:\n  jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n    jumpF_polyL 1 p b =\n    real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n    real_of_int max_r_sign * jumpF_polyR 1 p' a -\n    jumpF_polyL 1 p' b", "moreover"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n    jumpF_polyL 1 p b =\n    real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n    real_of_int max_r_sign * jumpF_polyR 1 p' a -\n    jumpF_polyL 1 p' b", "have \"jumpF_polyL 1 p b =  jumpF_polyL 1 p' b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "define f where \"f = (\\<lambda>x. 1 / poly max_rp x)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. 1 / poly max_rp x)\n\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "define g where \"g = (\\<lambda>x. 1 / poly p' x)\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. 1 / poly p' x)\n\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "have \"jumpF_polyL 1 p b = jumpF (\\<lambda>x. f x * g x) (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p b = jumpF (\\<lambda>x. f x * g x) (at_left b)", "unfolding jumpF_polyL_def f_def g_def p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly 1 x / poly (p' * max_rp) x) (at_left b) =\n    jumpF (\\<lambda>x. 1 / poly max_rp x * (1 / poly p' x)) (at_left b)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  jumpF_polyL 1 p b = jumpF (\\<lambda>x. f x * g x) (at_left b)\n\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "also"], ["proof (state)\nthis:\n  jumpF_polyL 1 p b = jumpF (\\<lambda>x. f x * g x) (at_left b)\n\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "have \"... = sgn (f b) * jumpF g (at_left b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. f x * g x) (at_left b) =\n    sgn (f b) * jumpF g (at_left b)", "proof (rule jumpF_times)"], ["proof (state)\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f b) (at_left b)\n 2. f b \\<noteq> 0\n 3. at_left b \\<noteq> bot", "have [simp]: \"poly max_rp b \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly max_rp b \\<noteq> 0", "unfolding max_rp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ([:- max_r, 1:] ^ order max_r p) b \\<noteq> 0", "using \\<open>max_r<b\\<close>"], ["proof (prove)\nusing this:\n  max_r < b\n\ngoal (1 subgoal):\n 1. poly ([:- max_r, 1:] ^ order max_r p) b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly max_rp b \\<noteq> 0\n\ngoal (3 subgoals):\n 1. (f \\<longlongrightarrow> f b) (at_left b)\n 2. f b \\<noteq> 0\n 3. at_left b \\<noteq> bot", "show \"(f \\<longlongrightarrow> f b) (at_left b)\" \"f b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f b) (at_left b) &&& f b \\<noteq> 0", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. 1 / poly max_rp x) \\<longlongrightarrow>\n     1 / poly max_rp b)\n     (at_left b) &&&\n    1 / poly max_rp b \\<noteq> 0", "by (auto intro:tendsto_intros)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> f b) (at_left b)\n  f b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. at_left b \\<noteq> bot", "qed auto"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x * g x) (at_left b) =\n  sgn (f b) * jumpF g (at_left b)\n\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "also"], ["proof (state)\nthis:\n  jumpF (\\<lambda>x. f x * g x) (at_left b) =\n  sgn (f b) * jumpF g (at_left b)\n\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "have \"... = jumpF_polyL 1 p' b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (f b) * jumpF g (at_left b) = jumpF_polyL 1 p' b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn (f b) * jumpF g (at_left b) = jumpF_polyL 1 p' b", "have \"sgn (f b) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (f b) = 1", "unfolding max_r_sign_def f_def max_rp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (1 / poly ([:- max_r, 1:] ^ order max_r p) b) = 1", "using \\<open>b>max_r\\<close>"], ["proof (prove)\nusing this:\n  max_r < b\n\ngoal (1 subgoal):\n 1. sgn (1 / poly ([:- max_r, 1:] ^ order max_r p) b) = 1", "by (auto simp add:sgn_power)"], ["proof (state)\nthis:\n  sgn (f b) = 1\n\ngoal (1 subgoal):\n 1. sgn (f b) * jumpF g (at_left b) = jumpF_polyL 1 p' b", "then"], ["proof (chain)\npicking this:\n  sgn (f b) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  sgn (f b) = 1\n\ngoal (1 subgoal):\n 1. sgn (f b) * jumpF g (at_left b) = jumpF_polyL 1 p' b", "unfolding jumpF_polyL_def g_def"], ["proof (prove)\nusing this:\n  sgn (f b) = 1\n\ngoal (1 subgoal):\n 1. sgn (f b) * jumpF (\\<lambda>x. 1 / poly p' x) (at_left b) =\n    jumpF (\\<lambda>x. poly 1 x / poly p' x) (at_left b)", "by auto"], ["proof (state)\nthis:\n  sgn (f b) * jumpF g (at_left b) = jumpF_polyL 1 p' b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn (f b) * jumpF g (at_left b) = jumpF_polyL 1 p' b\n\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "finally"], ["proof (chain)\npicking this:\n  jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyL 1 p b = jumpF_polyL 1 p' b\n\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "."], ["proof (state)\nthis:\n  jumpF_polyL 1 p b = jumpF_polyL 1 p' b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_polyL 1 p b = jumpF_polyL 1 p' b\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n    jumpF_polyL 1 p b =\n    real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n    real_of_int max_r_sign * jumpF_polyR 1 p' a -\n    jumpF_polyL 1 p' b", "ultimately"], ["proof (chain)\npicking this:\n  sum (jump_poly 1 p) roots =\n  max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r\n  jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a\n  jumpF_polyL 1 p b = jumpF_polyL 1 p' b", "show ?thesis"], ["proof (prove)\nusing this:\n  sum (jump_poly 1 p) roots =\n  max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r\n  jumpF_polyR 1 p a = real_of_int max_r_sign * jumpF_polyR 1 p' a\n  jumpF_polyL 1 p b = jumpF_polyL 1 p' b\n\ngoal (1 subgoal):\n 1. jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n    jumpF_polyL 1 p b =\n    real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n    real_of_int max_r_sign * jumpF_polyR 1 p' a -\n    jumpF_polyL 1 p' b", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n  jumpF_polyL 1 p b =\n  real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n  real_of_int max_r_sign * jumpF_polyR 1 p' a -\n  jumpF_polyL 1 p' b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n  jumpF_polyL 1 p b =\n  real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n  real_of_int max_r_sign * jumpF_polyR 1 p' a -\n  jumpF_polyL 1 p' b\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "also"], ["proof (state)\nthis:\n  jumpF_polyR 1 p a + real_of_int (sum (jump_poly 1 p) roots) -\n  jumpF_polyL 1 p b =\n  real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n  real_of_int max_r_sign * jumpF_polyR 1 p' a -\n  jumpF_polyL 1 p' b\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "have \"... = max_r_sign * cindex_polyE a b 1 p' + jump_poly 1 p max_r \n        + (max_r_sign - 1) * jumpF_polyL 1 p' b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n    real_of_int max_r_sign * jumpF_polyR 1 p' a -\n    jumpF_polyL 1 p' b =\n    real_of_int max_r_sign * cindex_polyE a b 1 p' +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b", "unfolding cindex_polyE_def roots'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n    real_of_int max_r_sign * jumpF_polyR 1 p' a -\n    jumpF_polyL 1 p' b =\n    real_of_int max_r_sign *\n    (jumpF_polyR 1 p' a + real_of_int (cindex_poly a b 1 p') -\n     jumpF_polyL 1 p' b) +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n  real_of_int max_r_sign * jumpF_polyR 1 p' a -\n  jumpF_polyL 1 p' b =\n  real_of_int max_r_sign * cindex_polyE a b 1 p' +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "also"], ["proof (state)\nthis:\n  real_of_int (max_r_sign * cindex_poly a b 1 p' + jump_poly 1 p max_r) +\n  real_of_int max_r_sign * jumpF_polyR 1 p' a -\n  jumpF_polyL 1 p' b =\n  real_of_int max_r_sign * cindex_polyE a b 1 p' +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "have \"... = max_r_sign * cross_alt 1 p' a b / 2 + jump_poly 1 p max_r \n        + (max_r_sign - 1) * jumpF_polyL 1 p' b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int max_r_sign * cindex_polyE a b 1 p' +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int max_r_sign * cindex_polyE a b 1 p' +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b", "have \"degree max_rp>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree max_rp", "unfolding max_rp_def degree_linear_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order max_r p", "using \\<open>poly p max_r=0\\<close> order_root \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly p max_r = 0\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < order max_r p", "by blast"], ["proof (state)\nthis:\n  0 < degree max_rp\n\ngoal (1 subgoal):\n 1. real_of_int max_r_sign * cindex_polyE a b 1 p' +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b", "then"], ["proof (chain)\npicking this:\n  0 < degree max_rp", "have \"degree p'<degree p\""], ["proof (prove)\nusing this:\n  0 < degree max_rp\n\ngoal (1 subgoal):\n 1. degree p' < degree p", "unfolding p'_def"], ["proof (prove)\nusing this:\n  0 < degree max_rp\n\ngoal (1 subgoal):\n 1. degree p' < degree (p' * max_rp)", "using degree_mult_eq[OF \\<open>p'\\<noteq>0\\<close> \\<open>max_rp\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  0 < degree max_rp\n  degree (p' * max_rp) = degree p' + degree max_rp\n\ngoal (1 subgoal):\n 1. degree p' < degree (p' * max_rp)", "by auto"], ["proof (state)\nthis:\n  degree p' < degree p\n\ngoal (1 subgoal):\n 1. real_of_int max_r_sign * cindex_polyE a b 1 p' +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b", "from induct[rule_format, OF this]"], ["proof (chain)\npicking this:\n  degree p' = degree ?x \\<Longrightarrow>\n  cindex_polyE a b 1 ?x = real_of_int (cross_alt 1 ?x a b) / 2", "have \"cindex_polyE a b 1 p' = real_of_int (cross_alt 1 p' a b) / 2\""], ["proof (prove)\nusing this:\n  degree p' = degree ?x \\<Longrightarrow>\n  cindex_polyE a b 1 ?x = real_of_int (cross_alt 1 ?x a b) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p' = real_of_int (cross_alt 1 p' a b) / 2", "by auto"], ["proof (state)\nthis:\n  cindex_polyE a b 1 p' = real_of_int (cross_alt 1 p' a b) / 2\n\ngoal (1 subgoal):\n 1. real_of_int max_r_sign * cindex_polyE a b 1 p' +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b", "then"], ["proof (chain)\npicking this:\n  cindex_polyE a b 1 p' = real_of_int (cross_alt 1 p' a b) / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_polyE a b 1 p' = real_of_int (cross_alt 1 p' a b) / 2\n\ngoal (1 subgoal):\n 1. real_of_int max_r_sign * cindex_polyE a b 1 p' +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b", "by auto"], ["proof (state)\nthis:\n  real_of_int max_r_sign * cindex_polyE a b 1 p' +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int max_r_sign * cindex_polyE a b 1 p' +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "also"], ["proof (state)\nthis:\n  real_of_int max_r_sign * cindex_polyE a b 1 p' +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "have \"... = real_of_int (cross_alt 1 p a b) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "have sjump_p:\"jump_poly 1 p max_r = (if odd (order max_r p) then sign (poly p' max_r) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "note max_r_nz"], ["proof (state)\nthis:\n  poly p' max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "moreover"], ["proof (state)\nthis:\n  poly p' max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "then"], ["proof (chain)\npicking this:\n  poly p' max_r \\<noteq> 0", "have \"poly max_rp max_r=0\""], ["proof (prove)\nusing this:\n  poly p' max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly max_rp max_r = 0", "using \\<open>poly p max_r = 0\\<close> p'_def"], ["proof (prove)\nusing this:\n  poly p' max_r \\<noteq> 0\n  poly p max_r = 0\n  p = p' * max_rp\n\ngoal (1 subgoal):\n 1. poly max_rp max_r = 0", "by auto"], ["proof (state)\nthis:\n  poly max_rp max_r = 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "ultimately"], ["proof (chain)\npicking this:\n  poly p' max_r \\<noteq> 0\n  poly max_rp max_r = 0", "have \"jump_poly 1 p max_r = sign (poly p' max_r) * jump_poly 1 max_rp max_r\""], ["proof (prove)\nusing this:\n  poly p' max_r \\<noteq> 0\n  poly max_rp max_r = 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r = sign (poly p' max_r) * jump_poly 1 max_rp max_r", "unfolding p'_def"], ["proof (prove)\nusing this:\n  poly p' max_r \\<noteq> 0\n  poly max_rp max_r = 0\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p' * max_rp) max_r =\n    sign (poly p' max_r) * jump_poly 1 max_rp max_r", "using jump_poly_1_mult[of p' max_r max_rp]"], ["proof (prove)\nusing this:\n  poly p' max_r \\<noteq> 0\n  poly max_rp max_r = 0\n  poly p' max_r \\<noteq> 0 \\<or>\n  poly max_rp max_r \\<noteq> 0 \\<Longrightarrow>\n  jump_poly 1 (p' * max_rp) max_r =\n  sign (poly max_rp max_r) * jump_poly 1 p' max_r +\n  sign (poly p' max_r) * jump_poly 1 max_rp max_r\n\ngoal (1 subgoal):\n 1. jump_poly 1 (p' * max_rp) max_r =\n    sign (poly p' max_r) * jump_poly 1 max_rp max_r", "by auto"], ["proof (state)\nthis:\n  jump_poly 1 p max_r = sign (poly p' max_r) * jump_poly 1 max_rp max_r\n\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "also"], ["proof (state)\nthis:\n  jump_poly 1 p max_r = sign (poly p' max_r) * jump_poly 1 max_rp max_r\n\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "have \"... = (if odd (order max_r max_rp) then sign (poly p' max_r) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (poly p' max_r) * jump_poly 1 max_rp max_r =\n    (if odd (order max_r max_rp) then sign (poly p' max_r) else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign (poly p' max_r) * jump_poly 1 max_rp max_r =\n    (if odd (order max_r max_rp) then sign (poly p' max_r) else 0)", "have \"sign_r_pos max_rp max_r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos max_rp max_r", "unfolding max_rp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos ([:- max_r, 1:] ^ order max_r p) max_r", "using sign_r_pos_power"], ["proof (prove)\nusing this:\n  sign_r_pos ([:- ?a, 1:] ^ ?n) ?a\n\ngoal (1 subgoal):\n 1. sign_r_pos ([:- max_r, 1:] ^ order max_r p) max_r", "by auto"], ["proof (state)\nthis:\n  sign_r_pos max_rp max_r\n\ngoal (1 subgoal):\n 1. sign (poly p' max_r) * jump_poly 1 max_rp max_r =\n    (if odd (order max_r max_rp) then sign (poly p' max_r) else 0)", "then"], ["proof (chain)\npicking this:\n  sign_r_pos max_rp max_r", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_r_pos max_rp max_r\n\ngoal (1 subgoal):\n 1. sign (poly p' max_r) * jump_poly 1 max_rp max_r =\n    (if odd (order max_r max_rp) then sign (poly p' max_r) else 0)", "using \\<open>max_rp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  sign_r_pos max_rp max_r\n  max_rp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign (poly p' max_r) * jump_poly 1 max_rp max_r =\n    (if odd (order max_r max_rp) then sign (poly p' max_r) else 0)", "unfolding jump_poly_def"], ["proof (prove)\nusing this:\n  sign_r_pos max_rp max_r\n  max_rp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign (poly p' max_r) *\n    (if max_rp \\<noteq> 0 \\<and>\n        1 \\<noteq> 0 \\<and> odd (order max_r max_rp - order max_r 1)\n     then if sign_r_pos (1 * max_rp) max_r then 1 else - 1 else 0) =\n    (if odd (order max_r max_rp) then sign (poly p' max_r) else 0)", "by auto"], ["proof (state)\nthis:\n  sign (poly p' max_r) * jump_poly 1 max_rp max_r =\n  (if odd (order max_r max_rp) then sign (poly p' max_r) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign (poly p' max_r) * jump_poly 1 max_rp max_r =\n  (if odd (order max_r max_rp) then sign (poly p' max_r) else 0)\n\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "also"], ["proof (state)\nthis:\n  sign (poly p' max_r) * jump_poly 1 max_rp max_r =\n  (if odd (order max_r max_rp) then sign (poly p' max_r) else 0)\n\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "have \"... = (if odd (order max_r p) then sign (poly p' max_r) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if odd (order max_r max_rp) then sign (poly p' max_r) else 0) =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if odd (order max_r max_rp) then sign (poly p' max_r) else 0) =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "have \"order max_r p'=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order max_r p' = 0", "by (simp add: \\<open>poly p' max_r \\<noteq> 0\\<close> order_0I)"], ["proof (state)\nthis:\n  order max_r p' = 0\n\ngoal (1 subgoal):\n 1. (if odd (order max_r max_rp) then sign (poly p' max_r) else 0) =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "then"], ["proof (chain)\npicking this:\n  order max_r p' = 0", "have \"order max_r max_rp = order max_r p\""], ["proof (prove)\nusing this:\n  order max_r p' = 0\n\ngoal (1 subgoal):\n 1. order max_r max_rp = order max_r p", "unfolding p'_def"], ["proof (prove)\nusing this:\n  order max_r p' = 0\n\ngoal (1 subgoal):\n 1. order max_r max_rp = order max_r (p' * max_rp)", "using \\<open>p'\\<noteq>0\\<close> \\<open>max_rp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  order max_r p' = 0\n  p' \\<noteq> 0\n  max_rp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order max_r max_rp = order max_r (p' * max_rp)", "apply (subst order_mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>order max_r p' = 0; p' \\<noteq> 0; max_rp \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> p' * max_rp \\<noteq> 0\n 2. \\<lbrakk>order max_r p' = 0; p' \\<noteq> 0; max_rp \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> order max_r max_rp =\n                      order max_r p' + order max_r max_rp", "by auto"], ["proof (state)\nthis:\n  order max_r max_rp = order max_r p\n\ngoal (1 subgoal):\n 1. (if odd (order max_r max_rp) then sign (poly p' max_r) else 0) =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "then"], ["proof (chain)\npicking this:\n  order max_r max_rp = order max_r p", "show ?thesis"], ["proof (prove)\nusing this:\n  order max_r max_rp = order max_r p\n\ngoal (1 subgoal):\n 1. (if odd (order max_r max_rp) then sign (poly p' max_r) else 0) =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "by auto"], ["proof (state)\nthis:\n  (if odd (order max_r max_rp) then sign (poly p' max_r) else 0) =\n  (if odd (order max_r p) then sign (poly p' max_r) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if odd (order max_r max_rp) then sign (poly p' max_r) else 0) =\n  (if odd (order max_r p) then sign (poly p' max_r) else 0)\n\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "finally"], ["proof (chain)\npicking this:\n  jump_poly 1 p max_r =\n  (if odd (order max_r p) then sign (poly p' max_r) else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  jump_poly 1 p max_r =\n  (if odd (order max_r p) then sign (poly p' max_r) else 0)\n\ngoal (1 subgoal):\n 1. jump_poly 1 p max_r =\n    (if odd (order max_r p) then sign (poly p' max_r) else 0)", "."], ["proof (state)\nthis:\n  jump_poly 1 p max_r =\n  (if odd (order max_r p) then sign (poly p' max_r) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jump_poly 1 p max_r =\n  (if odd (order max_r p) then sign (poly p' max_r) else 0)\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "have ?thesis when \"even (order max_r p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "have \"sign (poly p x) =  sign (poly p' x)\" when \"x\\<noteq>max_r\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (poly p x) = sign (poly p' x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign (poly p x) = sign (poly p' x)", "have \"sign (poly max_rp x) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (poly max_rp x) = 1", "unfolding max_rp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (poly ([:- max_r, 1:] ^ order max_r p) x) = 1", "using \\<open>even (order max_r p)\\<close> that"], ["proof (prove)\nusing this:\n  even (order max_r p)\n  x \\<noteq> max_r\n\ngoal (1 subgoal):\n 1. sign (poly ([:- max_r, 1:] ^ order max_r p) x) = 1", "apply (simp add:sign_power )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (order max_r p); x \\<noteq> max_r\\<rbrakk>\n    \\<Longrightarrow> 0 < order max_r p \\<longrightarrow>\n                      \\<bar>sign (x - max_r)\\<bar> = 1", "by (simp add: Sturm_Tarski.sign_def)"], ["proof (state)\nthis:\n  sign (poly max_rp x) = 1\n\ngoal (1 subgoal):\n 1. sign (poly p x) = sign (poly p' x)", "then"], ["proof (chain)\npicking this:\n  sign (poly max_rp x) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  sign (poly max_rp x) = 1\n\ngoal (1 subgoal):\n 1. sign (poly p x) = sign (poly p' x)", "unfolding p'_def"], ["proof (prove)\nusing this:\n  sign (poly max_rp x) = 1\n\ngoal (1 subgoal):\n 1. sign (poly (p' * max_rp) x) = sign (poly p' x)", "by (simp add:sign_times)"], ["proof (state)\nthis:\n  sign (poly p x) = sign (poly p' x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<noteq> max_r \\<Longrightarrow> sign (poly p ?x) = sign (poly p' ?x)\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "from this[of a] this[of b] \\<open>a<max_r\\<close> \\<open>max_r<b\\<close>"], ["proof (chain)\npicking this:\n  a \\<noteq> max_r \\<Longrightarrow> sign (poly p a) = sign (poly p' a)\n  b \\<noteq> max_r \\<Longrightarrow> sign (poly p b) = sign (poly p' b)\n  a < max_r\n  max_r < b", "have \"cross_alt 1 p' a b = cross_alt 1 p a b\""], ["proof (prove)\nusing this:\n  a \\<noteq> max_r \\<Longrightarrow> sign (poly p a) = sign (poly p' a)\n  b \\<noteq> max_r \\<Longrightarrow> sign (poly p b) = sign (poly p' b)\n  a < max_r\n  max_r < b\n\ngoal (1 subgoal):\n 1. cross_alt 1 p' a b = cross_alt 1 p a b", "unfolding cross_alt_def"], ["proof (prove)\nusing this:\n  a \\<noteq> max_r \\<Longrightarrow> sign (poly p a) = sign (poly p' a)\n  b \\<noteq> max_r \\<Longrightarrow> sign (poly p b) = sign (poly p' b)\n  a < max_r\n  max_r < b\n\ngoal (1 subgoal):\n 1. \\<bar>sign (poly 1 a) - sign (poly p' a)\\<bar> -\n    \\<bar>sign (poly 1 b) - sign (poly p' b)\\<bar> =\n    \\<bar>sign (poly 1 a) - sign (poly p a)\\<bar> -\n    \\<bar>sign (poly 1 b) - sign (poly p b)\\<bar>", "by auto"], ["proof (state)\nthis:\n  cross_alt 1 p' a b = cross_alt 1 p a b\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "then"], ["proof (chain)\npicking this:\n  cross_alt 1 p' a b = cross_alt 1 p a b", "show ?thesis"], ["proof (prove)\nusing this:\n  cross_alt 1 p' a b = cross_alt 1 p a b\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "using that"], ["proof (prove)\nusing this:\n  cross_alt 1 p' a b = cross_alt 1 p a b\n  even (order max_r p)\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "unfolding max_r_sign_def sjump_p"], ["proof (prove)\nusing this:\n  cross_alt 1 p' a b = cross_alt 1 p a b\n  even (order max_r p)\n\ngoal (1 subgoal):\n 1. real_of_int\n     ((if odd (order max_r p) then - 1 else 1) * cross_alt 1 p' a b) /\n    2 +\n    real_of_int (if odd (order max_r p) then sign (poly p' max_r) else 0) +\n    real_of_int ((if odd (order max_r p) then - 1 else 1) - 1) *\n    jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "by auto"], ["proof (state)\nthis:\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  even (order max_r p) \\<Longrightarrow>\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  even (order max_r p) \\<Longrightarrow>\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "have ?thesis when \"odd (order max_r p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "let ?thesis2 = \"sign (poly p' max_r) * 2 - cross_alt 1 p' a b - 4 * jumpF_polyL 1 p' b \n              = cross_alt 1 p a b\""], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "have ?thesis2 when \"poly p' b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have \"jumpF_polyL 1 p' b = 1/2 \\<or> jumpF_polyL 1 p' b=-1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p' b = 1 / 2 \\<or> jumpF_polyL 1 p' b = - 1 / 2", "using jumpF_polyL_coprime[of p' 1 b,simplified] \\<open>p'\\<noteq>0\\<close> \\<open>poly p' b=0\\<close>"], ["proof (prove)\nusing this:\n  jumpF_polyL 1 p' b =\n  (if p' \\<noteq> 0 \\<and> poly p' b = 0\n   then if even (order b p') = (sign_r_pos p' b = (0 < poly 1 b)) then 1 / 2\n        else - 1 / 2\n   else 0)\n  p' \\<noteq> 0\n  poly p' b = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p' b = 1 / 2 \\<or> jumpF_polyL 1 p' b = - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL 1 p' b = 1 / 2 \\<or> jumpF_polyL 1 p' b = - 1 / 2\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "moreover"], ["proof (state)\nthis:\n  jumpF_polyL 1 p' b = 1 / 2 \\<or> jumpF_polyL 1 p' b = - 1 / 2\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have \"poly p' max_r>0 \\<or> poly p' max_r<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p' max_r \\<or> poly p' max_r < 0", "using max_r_nz"], ["proof (prove)\nusing this:\n  poly p' max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly p' max_r \\<or> poly p' max_r < 0", "by auto"], ["proof (state)\nthis:\n  0 < poly p' max_r \\<or> poly p' max_r < 0\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "moreover"], ["proof (state)\nthis:\n  0 < poly p' max_r \\<or> poly p' max_r < 0\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have False when \"poly p' max_r>0 \\<and> jumpF_polyL 1 p' b=-1/2 \n                \\<or> poly p' max_r<0 \\<and> jumpF_polyL 1 p' b=1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "define f where \"f= (\\<lambda>x. 1/ poly p' x)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. 1 / poly p' x)\n\ngoal (1 subgoal):\n 1. False", "have noroots:\"poly p' x\\<noteq>0\" when \"x\\<in>{max_r<..<b}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p' x \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> poly p' x \\<noteq> 0 \\<Longrightarrow> False", "assume \" \\<not> poly p' x \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> poly p' x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> poly p' x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> poly p' x \\<noteq> 0", "have \"poly p x =0\""], ["proof (prove)\nusing this:\n  \\<not> poly p' x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p x = 0", "unfolding p'_def"], ["proof (prove)\nusing this:\n  \\<not> poly p' x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (p' * max_rp) x = 0", "by auto"], ["proof (state)\nthis:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<not> poly p' x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly p x = 0", "have \"x\\<in>roots\""], ["proof (prove)\nusing this:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> roots", "unfolding roots_def"], ["proof (prove)\nusing this:\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. a < x \\<and> x < b \\<and> poly p x = 0}", "using that \\<open>a<max_r\\<close>"], ["proof (prove)\nusing this:\n  poly p x = 0\n  x \\<in> {max_r<..<b}\n  a < max_r\n\ngoal (1 subgoal):\n 1. x \\<in> {x. a < x \\<and> x < b \\<and> poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  x \\<in> roots\n\ngoal (1 subgoal):\n 1. \\<not> poly p' x \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> roots", "have \"x\\<le>max_r\""], ["proof (prove)\nusing this:\n  x \\<in> roots\n\ngoal (1 subgoal):\n 1. x \\<le> max_r", "using Max_ge[OF \\<open>finite roots\\<close>]"], ["proof (prove)\nusing this:\n  x \\<in> roots\n  ?x \\<in> roots \\<Longrightarrow> ?x \\<le> Max roots\n\ngoal (1 subgoal):\n 1. x \\<le> max_r", "unfolding max_r_def"], ["proof (prove)\nusing this:\n  x \\<in> roots\n  ?x \\<in> roots \\<Longrightarrow> ?x \\<le> Max roots\n\ngoal (1 subgoal):\n 1. x \\<le> Max roots", "by auto"], ["proof (state)\nthis:\n  x \\<le> max_r\n\ngoal (1 subgoal):\n 1. \\<not> poly p' x \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  x \\<le> max_r\n\ngoal (1 subgoal):\n 1. \\<not> poly p' x \\<noteq> 0 \\<Longrightarrow> False", "have \"x>max_r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_r < x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {max_r<..<b}\n\ngoal (1 subgoal):\n 1. max_r < x", "by auto"], ["proof (state)\nthis:\n  max_r < x\n\ngoal (1 subgoal):\n 1. \\<not> poly p' x \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  x \\<le> max_r\n  max_r < x", "show False"], ["proof (prove)\nusing this:\n  x \\<le> max_r\n  max_r < x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {max_r<..<b} \\<Longrightarrow> poly p' ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "have \"continuous_on {max_r<..<b} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {max_r<..<b} f", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {max_r<..<b} (\\<lambda>x. 1 / poly p' x)", "using noroots"], ["proof (prove)\nusing this:\n  ?x \\<in> {max_r<..<b} \\<Longrightarrow> poly p' ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. continuous_on {max_r<..<b} (\\<lambda>x. 1 / poly p' x)", "by (auto intro!:continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {max_r<..<b} f\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  continuous_on {max_r<..<b} f\n\ngoal (1 subgoal):\n 1. False", "have \"continuous (at_right max_r) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at_right max_r) f", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at_right max_r) (\\<lambda>x. 1 / poly p' x)", "using max_r_nz"], ["proof (prove)\nusing this:\n  poly p' max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. continuous (at_right max_r) (\\<lambda>x. 1 / poly p' x)", "by (auto intro!:continuous_intros)"], ["proof (state)\nthis:\n  continuous (at_right max_r) f\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  continuous (at_right max_r) f\n\ngoal (1 subgoal):\n 1. False", "have \"f max_r>0 \\<and> jumpF f (at_left b)<0 \n                \\<or> f max_r<0 \\<and> jumpF f (at_left b)>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < f max_r \\<and> jumpF f (at_left b) < 0 \\<or>\n    f max_r < 0 \\<and> 0 < jumpF f (at_left b)", "using that"], ["proof (prove)\nusing this:\n  0 < poly p' max_r \\<and> jumpF_polyL 1 p' b = - 1 / 2 \\<or>\n  poly p' max_r < 0 \\<and> jumpF_polyL 1 p' b = 1 / 2\n\ngoal (1 subgoal):\n 1. 0 < f max_r \\<and> jumpF f (at_left b) < 0 \\<or>\n    f max_r < 0 \\<and> 0 < jumpF f (at_left b)", "unfolding f_def jumpF_polyL_def"], ["proof (prove)\nusing this:\n  0 < poly p' max_r \\<and>\n  jumpF (\\<lambda>x. poly 1 x / poly p' x) (at_left b) = - 1 / 2 \\<or>\n  poly p' max_r < 0 \\<and>\n  jumpF (\\<lambda>x. poly 1 x / poly p' x) (at_left b) = 1 / 2\n\ngoal (1 subgoal):\n 1. 0 < 1 / poly p' max_r \\<and>\n    jumpF (\\<lambda>x. 1 / poly p' x) (at_left b) < 0 \\<or>\n    1 / poly p' max_r < 0 \\<and>\n    0 < jumpF (\\<lambda>x. 1 / poly p' x) (at_left b)", "by auto"], ["proof (state)\nthis:\n  0 < f max_r \\<and> jumpF f (at_left b) < 0 \\<or>\n  f max_r < 0 \\<and> 0 < jumpF f (at_left b)\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  continuous_on {max_r<..<b} f\n  continuous (at_right max_r) f\n  0 < f max_r \\<and> jumpF f (at_left b) < 0 \\<or>\n  f max_r < 0 \\<and> 0 < jumpF f (at_left b)", "have \"\\<exists>x>max_r. x < b \\<and> f x = 0\""], ["proof (prove)\nusing this:\n  continuous_on {max_r<..<b} f\n  continuous (at_right max_r) f\n  0 < f max_r \\<and> jumpF f (at_left b) < 0 \\<or>\n  f max_r < 0 \\<and> 0 < jumpF f (at_left b)\n\ngoal (1 subgoal):\n 1. \\<exists>x>max_r. x < b \\<and> f x = 0", "apply (intro jumpF_IVT[OF \\<open>max_r<b\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>continuous_on {max_r<..<b} f; continuous (at_right max_r) f;\n     0 < f max_r \\<and> jumpF f (at_left b) < 0 \\<or>\n     f max_r < 0 \\<and> 0 < jumpF f (at_left b)\\<rbrakk>\n    \\<Longrightarrow> continuous_on {max_r<..<b} f\n 2. \\<lbrakk>continuous_on {max_r<..<b} f; continuous (at_right max_r) f;\n     0 < f max_r \\<and> jumpF f (at_left b) < 0 \\<or>\n     f max_r < 0 \\<and> 0 < jumpF f (at_left b)\\<rbrakk>\n    \\<Longrightarrow> (0 < jumpF f (at_right max_r) \\<or>\n                       continuous (at_right max_r) f \\<and>\n                       0 < f max_r) \\<and>\n                      (jumpF f (at_left b) < 0 \\<or>\n                       continuous (at_left b) f \\<and> f b < 0) \\<or>\n                      (jumpF f (at_right max_r) < 0 \\<or>\n                       continuous (at_right max_r) f \\<and>\n                       f max_r < 0) \\<and>\n                      (0 < jumpF f (at_left b) \\<or>\n                       continuous (at_left b) f \\<and> 0 < f b)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x>max_r. x < b \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>max_r. x < b \\<and> f x = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>x>max_r. x < b \\<and> f x = 0\n\ngoal (1 subgoal):\n 1. False", "using noroots"], ["proof (prove)\nusing this:\n  \\<exists>x>max_r. x < b \\<and> f x = 0\n  ?x \\<in> {max_r<..<b} \\<Longrightarrow> poly p' ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<exists>x>max_r. x < b \\<and> 1 / poly p' x = 0\n  ?x \\<in> {max_r<..<b} \\<Longrightarrow> poly p' ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < poly p' max_r \\<and> jumpF_polyL 1 p' b = - 1 / 2 \\<or>\n  poly p' max_r < 0 \\<and> jumpF_polyL 1 p' b = 1 / 2 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "moreover"], ["proof (state)\nthis:\n  0 < poly p' max_r \\<and> jumpF_polyL 1 p' b = - 1 / 2 \\<or>\n  poly p' max_r < 0 \\<and> jumpF_polyL 1 p' b = 1 / 2 \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have ?thesis when \"poly p' max_r>0 \\<and> jumpF_polyL 1 p' b=1/2\n              \\<or> poly p' max_r<0 \\<and> jumpF_polyL 1 p' b=-1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have \"poly max_rp a < 0\" \"poly max_rp b>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly max_rp a < 0 &&& 0 < poly max_rp b", "unfolding max_rp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ([:- max_r, 1:] ^ order max_r p) a < 0 &&&\n    0 < poly ([:- max_r, 1:] ^ order max_r p) b", "using \\<open>odd (order max_r p)\\<close> \\<open>a<max_r\\<close> \\<open>max_r<b\\<close>"], ["proof (prove)\nusing this:\n  odd (order max_r p)\n  a < max_r\n  max_r < b\n\ngoal (1 subgoal):\n 1. poly ([:- max_r, 1:] ^ order max_r p) a < 0 &&&\n    0 < poly ([:- max_r, 1:] ^ order max_r p) b", "by (simp_all add:zero_less_power_eq)"], ["proof (state)\nthis:\n  poly max_rp a < 0\n  0 < poly max_rp b\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "then"], ["proof (chain)\npicking this:\n  poly max_rp a < 0\n  0 < poly max_rp b", "have \"cross_alt 1 p a b = - cross_alt 1 p' a b\""], ["proof (prove)\nusing this:\n  poly max_rp a < 0\n  0 < poly max_rp b\n\ngoal (1 subgoal):\n 1. cross_alt 1 p a b = - cross_alt 1 p' a b", "unfolding cross_alt_def p'_def"], ["proof (prove)\nusing this:\n  poly max_rp a < 0\n  0 < poly max_rp b\n\ngoal (1 subgoal):\n 1. \\<bar>sign (poly 1 a) - sign (poly (p' * max_rp) a)\\<bar> -\n    \\<bar>sign (poly 1 b) - sign (poly (p' * max_rp) b)\\<bar> =\n    - (\\<bar>sign (poly 1 a) - sign (poly p' a)\\<bar> -\n       \\<bar>sign (poly 1 b) - sign (poly p' b)\\<bar>)", "using \\<open>poly p' b=0\\<close>"], ["proof (prove)\nusing this:\n  poly max_rp a < 0\n  0 < poly max_rp b\n  poly p' b = 0\n\ngoal (1 subgoal):\n 1. \\<bar>sign (poly 1 a) - sign (poly (p' * max_rp) a)\\<bar> -\n    \\<bar>sign (poly 1 b) - sign (poly (p' * max_rp) b)\\<bar> =\n    - (\\<bar>sign (poly 1 a) - sign (poly p' a)\\<bar> -\n       \\<bar>sign (poly 1 b) - sign (poly p' b)\\<bar>)", "apply (simp add:sign_times)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly max_rp a < 0; 0 < poly max_rp b; poly p' b = 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>1 + sign (poly p' a)\\<bar> =\n                      2 - \\<bar>1 - sign (poly p' a)\\<bar>", "by (simp add: Sturm_Tarski.sign_def)"], ["proof (state)\nthis:\n  cross_alt 1 p a b = - cross_alt 1 p' a b\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "with that"], ["proof (chain)\npicking this:\n  0 < poly p' max_r \\<and> jumpF_polyL 1 p' b = 1 / 2 \\<or>\n  poly p' max_r < 0 \\<and> jumpF_polyL 1 p' b = - 1 / 2\n  cross_alt 1 p a b = - cross_alt 1 p' a b", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < poly p' max_r \\<and> jumpF_polyL 1 p' b = 1 / 2 \\<or>\n  poly p' max_r < 0 \\<and> jumpF_polyL 1 p' b = - 1 / 2\n  cross_alt 1 p a b = - cross_alt 1 p' a b\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "by auto"], ["proof (state)\nthis:\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < poly p' max_r \\<and> jumpF_polyL 1 p' b = 1 / 2 \\<or>\n  poly p' max_r < 0 \\<and> jumpF_polyL 1 p' b = - 1 / 2 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "ultimately"], ["proof (chain)\npicking this:\n  jumpF_polyL 1 p' b = 1 / 2 \\<or> jumpF_polyL 1 p' b = - 1 / 2\n  0 < poly p' max_r \\<or> poly p' max_r < 0\n  0 < poly p' max_r \\<and> jumpF_polyL 1 p' b = - 1 / 2 \\<or>\n  poly p' max_r < 0 \\<and> jumpF_polyL 1 p' b = 1 / 2 \\<Longrightarrow>\n  False\n  0 < poly p' max_r \\<and> jumpF_polyL 1 p' b = 1 / 2 \\<or>\n  poly p' max_r < 0 \\<and> jumpF_polyL 1 p' b = - 1 / 2 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyL 1 p' b = 1 / 2 \\<or> jumpF_polyL 1 p' b = - 1 / 2\n  0 < poly p' max_r \\<or> poly p' max_r < 0\n  0 < poly p' max_r \\<and> jumpF_polyL 1 p' b = - 1 / 2 \\<or>\n  poly p' max_r < 0 \\<and> jumpF_polyL 1 p' b = 1 / 2 \\<Longrightarrow>\n  False\n  0 < poly p' max_r \\<and> jumpF_polyL 1 p' b = 1 / 2 \\<or>\n  poly p' max_r < 0 \\<and> jumpF_polyL 1 p' b = - 1 / 2 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "by blast"], ["proof (state)\nthis:\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p' b = 0 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "moreover"], ["proof (state)\nthis:\n  poly p' b = 0 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "have ?thesis2 when \"poly p' b\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have [simp]:\"jumpF_polyL 1 p' b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p' b = 0", "using jumpF_polyL_coprime[of p' 1 b,simplified] \\<open>poly p' b\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  jumpF_polyL 1 p' b =\n  (if p' \\<noteq> 0 \\<and> poly p' b = 0\n   then if even (order b p') = (sign_r_pos p' b = (0 < poly 1 b)) then 1 / 2\n        else - 1 / 2\n   else 0)\n  poly p' b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF_polyL 1 p' b = 0", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL 1 p' b = 0\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have [simp]:\"poly max_rp a < 0\" \"poly max_rp b>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly max_rp a < 0 &&& 0 < poly max_rp b", "unfolding max_rp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ([:- max_r, 1:] ^ order max_r p) a < 0 &&&\n    0 < poly ([:- max_r, 1:] ^ order max_r p) b", "using \\<open>odd (order max_r p)\\<close> \\<open>a<max_r\\<close> \\<open>max_r<b\\<close>"], ["proof (prove)\nusing this:\n  odd (order max_r p)\n  a < max_r\n  max_r < b\n\ngoal (1 subgoal):\n 1. poly ([:- max_r, 1:] ^ order max_r p) a < 0 &&&\n    0 < poly ([:- max_r, 1:] ^ order max_r p) b", "by (simp_all add:zero_less_power_eq)"], ["proof (state)\nthis:\n  poly max_rp a < 0\n  0 < poly max_rp b\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have \"poly p' b>0 \\<or> poly p' b<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p' b \\<or> poly p' b < 0", "using \\<open>poly p' b\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly p' b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly p' b \\<or> poly p' b < 0", "by auto"], ["proof (state)\nthis:\n  0 < poly p' b \\<or> poly p' b < 0\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "moreover"], ["proof (state)\nthis:\n  0 < poly p' b \\<or> poly p' b < 0\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have \"poly p' max_r>0 \\<or> poly p' max_r<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p' max_r \\<or> poly p' max_r < 0", "using max_r_nz"], ["proof (prove)\nusing this:\n  poly p' max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < poly p' max_r \\<or> poly p' max_r < 0", "by auto"], ["proof (state)\nthis:\n  0 < poly p' max_r \\<or> poly p' max_r < 0\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "moreover"], ["proof (state)\nthis:\n  0 < poly p' max_r \\<or> poly p' max_r < 0\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have ?thesis when \"poly p' b>0 \\<and> poly p' max_r>0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "using that"], ["proof (prove)\nusing this:\n  0 < poly p' b \\<and> 0 < poly p' max_r\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "unfolding cross_alt_def p'_def"], ["proof (prove)\nusing this:\n  0 < poly p' b \\<and> 0 < poly p' max_r\n\ngoal (1 subgoal):\n 1. real_of_int\n     (sign (poly p' max_r) * 2 -\n      (\\<bar>sign (poly 1 a) - sign (poly p' a)\\<bar> -\n       \\<bar>sign (poly 1 b) - sign (poly p' b)\\<bar>)) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int\n     (\\<bar>sign (poly 1 a) - sign (poly (p' * max_rp) a)\\<bar> -\n      \\<bar>sign (poly 1 b) - sign (poly (p' * max_rp) b)\\<bar>)", "apply (simp add:sign_times)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < poly p' b \\<and> 0 < poly p' max_r \\<Longrightarrow>\n    2 - \\<bar>1 - real_of_int (sign (poly p' a))\\<bar> =\n    \\<bar>1 + real_of_int (sign (poly p' a))\\<bar>", "by (simp add: Sturm_Tarski.sign_def)"], ["proof (state)\nthis:\n  0 < poly p' b \\<and> 0 < poly p' max_r \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "moreover"], ["proof (state)\nthis:\n  0 < poly p' b \\<and> 0 < poly p' max_r \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have ?thesis when \"poly p' b<0 \\<and> poly p' max_r<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "using that"], ["proof (prove)\nusing this:\n  poly p' b < 0 \\<and> poly p' max_r < 0\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "unfolding cross_alt_def p'_def"], ["proof (prove)\nusing this:\n  poly p' b < 0 \\<and> poly p' max_r < 0\n\ngoal (1 subgoal):\n 1. real_of_int\n     (sign (poly p' max_r) * 2 -\n      (\\<bar>sign (poly 1 a) - sign (poly p' a)\\<bar> -\n       \\<bar>sign (poly 1 b) - sign (poly p' b)\\<bar>)) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int\n     (\\<bar>sign (poly 1 a) - sign (poly (p' * max_rp) a)\\<bar> -\n      \\<bar>sign (poly 1 b) - sign (poly (p' * max_rp) b)\\<bar>)", "apply (simp add:sign_times)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p' b < 0 \\<and> poly p' max_r < 0 \\<Longrightarrow>\n    - \\<bar>1 - real_of_int (sign (poly p' a))\\<bar> =\n    \\<bar>1 + real_of_int (sign (poly p' a))\\<bar> - 2", "by (simp add: Sturm_Tarski.sign_def)"], ["proof (state)\nthis:\n  poly p' b < 0 \\<and> poly p' max_r < 0 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "moreover"], ["proof (state)\nthis:\n  poly p' b < 0 \\<and> poly p' max_r < 0 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "have False when \"poly p' b>0 \\<and> poly p' max_r<0 \\<or> poly p' b<0 \\<and> poly p' max_r>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<exists>x>max_r. x < b \\<and> poly p' x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>max_r. x < b \\<and> poly p' x = 0", "apply (rule poly_IVT[OF \\<open>max_r<b\\<close>,of p'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p' max_r * poly p' b < 0", "using that mult_less_0_iff"], ["proof (prove)\nusing this:\n  0 < poly p' b \\<and> poly p' max_r < 0 \\<or>\n  poly p' b < 0 \\<and> 0 < poly p' max_r\n  (?a * ?b < (0::?'a)) =\n  ((0::?'a) < ?a \\<and> ?b < (0::?'a) \\<or>\n   ?a < (0::?'a) \\<and> (0::?'a) < ?b)\n\ngoal (1 subgoal):\n 1. poly p' max_r * poly p' b < 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>x>max_r. x < b \\<and> poly p' x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>max_r. x < b \\<and> poly p' x = 0", "obtain x where \"max_r<x\" \"x<b\" \"poly p x=0\""], ["proof (prove)\nusing this:\n  \\<exists>x>max_r. x < b \\<and> poly p' x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>max_r < x; x < b; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding p'_def"], ["proof (prove)\nusing this:\n  \\<exists>x>max_r. x < b \\<and> poly p' x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>max_r < x; x < b; poly (p' * max_rp) x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  max_r < x\n  x < b\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  max_r < x\n  x < b\n  poly p x = 0", "have \"x\\<in>roots\""], ["proof (prove)\nusing this:\n  max_r < x\n  x < b\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> roots", "using \\<open>a<max_r\\<close>"], ["proof (prove)\nusing this:\n  max_r < x\n  x < b\n  poly p x = 0\n  a < max_r\n\ngoal (1 subgoal):\n 1. x \\<in> roots", "unfolding roots_def"], ["proof (prove)\nusing this:\n  max_r < x\n  x < b\n  poly p x = 0\n  a < max_r\n\ngoal (1 subgoal):\n 1. x \\<in> {x. a < x \\<and> x < b \\<and> poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  x \\<in> roots\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  x \\<in> roots", "have \"x\\<le>max_r\""], ["proof (prove)\nusing this:\n  x \\<in> roots\n\ngoal (1 subgoal):\n 1. x \\<le> max_r", "unfolding max_r_def"], ["proof (prove)\nusing this:\n  x \\<in> roots\n\ngoal (1 subgoal):\n 1. x \\<le> Max roots", "using Max_ge[OF \\<open>finite roots\\<close>]"], ["proof (prove)\nusing this:\n  x \\<in> roots\n  ?x \\<in> roots \\<Longrightarrow> ?x \\<le> Max roots\n\ngoal (1 subgoal):\n 1. x \\<le> Max roots", "by auto"], ["proof (state)\nthis:\n  x \\<le> max_r\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  x \\<le> max_r", "show False"], ["proof (prove)\nusing this:\n  x \\<le> max_r\n\ngoal (1 subgoal):\n 1. False", "using \\<open>max_r<x\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> max_r\n  max_r < x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < poly p' b \\<and> poly p' max_r < 0 \\<or>\n  poly p' b < 0 \\<and> 0 < poly p' max_r \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "ultimately"], ["proof (chain)\npicking this:\n  0 < poly p' b \\<or> poly p' b < 0\n  0 < poly p' max_r \\<or> poly p' max_r < 0\n  0 < poly p' b \\<and> 0 < poly p' max_r \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n  poly p' b < 0 \\<and> poly p' max_r < 0 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n  0 < poly p' b \\<and> poly p' max_r < 0 \\<or>\n  poly p' b < 0 \\<and> 0 < poly p' max_r \\<Longrightarrow>\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < poly p' b \\<or> poly p' b < 0\n  0 < poly p' max_r \\<or> poly p' max_r < 0\n  0 < poly p' b \\<and> 0 < poly p' max_r \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n  poly p' b < 0 \\<and> poly p' max_r < 0 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n  0 < poly p' b \\<and> poly p' max_r < 0 \\<or>\n  poly p' b < 0 \\<and> 0 < poly p' max_r \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "by blast"], ["proof (state)\nthis:\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p' b \\<noteq> 0 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "ultimately"], ["proof (chain)\npicking this:\n  poly p' b = 0 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n  poly p' b \\<noteq> 0 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)", "have ?thesis2"], ["proof (prove)\nusing this:\n  poly p' b = 0 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n  poly p' b \\<noteq> 0 \\<Longrightarrow>\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n    4 * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b)", "by auto"], ["proof (state)\nthis:\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "then"], ["proof (chain)\npicking this:\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "unfolding max_r_sign_def sjump_p"], ["proof (prove)\nusing this:\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n\ngoal (1 subgoal):\n 1. real_of_int\n     ((if odd (order max_r p) then - 1 else 1) * cross_alt 1 p' a b) /\n    2 +\n    real_of_int (if odd (order max_r p) then sign (poly p' max_r) else 0) +\n    real_of_int ((if odd (order max_r p) then - 1 else 1) - 1) *\n    jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "using that"], ["proof (prove)\nusing this:\n  real_of_int (sign (poly p' max_r) * 2 - cross_alt 1 p' a b) -\n  4 * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b)\n  odd (order max_r p)\n\ngoal (1 subgoal):\n 1. real_of_int\n     ((if odd (order max_r p) then - 1 else 1) * cross_alt 1 p' a b) /\n    2 +\n    real_of_int (if odd (order max_r p) then sign (poly p' max_r) else 0) +\n    real_of_int ((if odd (order max_r p) then - 1 else 1) - 1) *\n    jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "by simp"], ["proof (state)\nthis:\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd (order max_r p) \\<Longrightarrow>\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "ultimately"], ["proof (chain)\npicking this:\n  even (order max_r p) \\<Longrightarrow>\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b) / 2\n  odd (order max_r p) \\<Longrightarrow>\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b) / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  even (order max_r p) \\<Longrightarrow>\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b) / 2\n  odd (order max_r p) \\<Longrightarrow>\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n    real_of_int (jump_poly 1 p max_r) +\n    real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n    real_of_int (cross_alt 1 p a b) / 2", "by auto"], ["proof (state)\nthis:\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int (max_r_sign * cross_alt 1 p' a b) / 2 +\n  real_of_int (jump_poly 1 p max_r) +\n  real_of_int (max_r_sign - 1) * jumpF_polyL 1 p' b =\n  real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "finally"], ["proof (chain)\npicking this:\n  cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "."], ["proof (state)\nthis:\n  cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0;\n   {x. a < x \\<and> x < b \\<and> poly p x = 0} \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> cindex_polyE a b 1 p =\n                    real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>m<degree p.\n          \\<forall>x.\n             m = degree x \\<longrightarrow>\n             cindex_polyE a b 1 x =\n             real_of_int (cross_alt 1 x a b) / 2 \\<Longrightarrow>\n       cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<Longrightarrow>\n  cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2\n  \\<lbrakk>p \\<noteq> 0;\n   {x. a < x \\<and> x < b \\<and> poly p x = 0} = {}\\<rbrakk>\n  \\<Longrightarrow> cindex_polyE a b 1 p =\n                    real_of_int (cross_alt 1 p a b) / 2\n  \\<lbrakk>p \\<noteq> 0;\n   {x. a < x \\<and> x < b \\<and> poly p x = 0} \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> cindex_polyE a b 1 p =\n                    real_of_int (cross_alt 1 p a b) / 2", "show ?case"], ["proof (prove)\nusing this:\n  p = 0 \\<Longrightarrow>\n  cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2\n  \\<lbrakk>p \\<noteq> 0;\n   {x. a < x \\<and> x < b \\<and> poly p x = 0} = {}\\<rbrakk>\n  \\<Longrightarrow> cindex_polyE a b 1 p =\n                    real_of_int (cross_alt 1 p a b) / 2\n  \\<lbrakk>p \\<noteq> 0;\n   {x. a < x \\<and> x < b \\<and> poly p x = 0} \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> cindex_polyE a b 1 p =\n                    real_of_int (cross_alt 1 p a b) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2", "by fast"], ["proof (state)\nthis:\n  cindex_polyE a b 1 p = real_of_int (cross_alt 1 p a b) / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_polyE_inverse_add:\n  fixes p q::\"real poly\" \n  assumes cp:\"coprime p q\"\n  shows \"cindex_polyE a b q p + cindex_polyE a b p q=cindex_polyE a b 1 (q*p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b q p + cindex_polyE a b p q = cindex_polyE a b 1 (q * p)", "unfolding cindex_polyE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p a + real_of_int (cindex_poly a b q p) -\n    jumpF_polyL q p b +\n    (jumpF_polyR p q a + real_of_int (cindex_poly a b p q) -\n     jumpF_polyL p q b) =\n    jumpF_polyR 1 (q * p) a + real_of_int (cindex_poly a b 1 (q * p)) -\n    jumpF_polyL 1 (q * p) b", "using cindex_poly_inverse_add[OF cp,symmetric] jumpF_polyR_inverse_add[OF cp,symmetric] \n    jumpF_polyL_inverse_add[OF cp,symmetric]"], ["proof (prove)\nusing this:\n  cindex_poly ?a ?b 1 (q * p) =\n  cindex_poly ?a ?b q p + cindex_poly ?a ?b p q\n  jumpF_polyR 1 (q * p) ?x = jumpF_polyR q p ?x + jumpF_polyR p q ?x\n  jumpF_polyL 1 (q * p) ?x = jumpF_polyL q p ?x + jumpF_polyL p q ?x\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p a + real_of_int (cindex_poly a b q p) -\n    jumpF_polyL q p b +\n    (jumpF_polyR p q a + real_of_int (cindex_poly a b p q) -\n     jumpF_polyL p q b) =\n    jumpF_polyR 1 (q * p) a + real_of_int (cindex_poly a b 1 (q * p)) -\n    jumpF_polyL 1 (q * p) b", "by auto"], ["", "lemma cindex_polyE_inverse_add_cross:\n  fixes p q::\"real poly\"\n  assumes \"a < b\" \"coprime p q\" \n  shows \"cindex_polyE a b q p  + cindex_polyE a b p q = cross_alt p q a b / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b q p + cindex_polyE a b p q =\n    real_of_int (cross_alt p q a b) / 2", "apply (subst cindex_polyE_inverse_add[OF \\<open>coprime p q\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b 1 (q * p) = real_of_int (cross_alt p q a b) / 2", "apply (subst cindex_polyE_cross[OF \\<open>a<b\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (cross_alt 1 (q * p) a b) / 2 =\n    real_of_int (cross_alt p q a b) / 2", "apply (subst mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (cross_alt 1 (p * q) a b) / 2 =\n    real_of_int (cross_alt p q a b) / 2", "apply (subst cross_alt_clear_n[OF \\<open>coprime p q\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (cross_alt 1 (p * q) a b) / 2 =\n    real_of_int (cross_alt 1 (p * q) a b) / 2", "by simp"], ["", "lemma cindex_polyE_smult_1: \n  fixes p q::\"real poly\" and c::real\n  shows \"cindex_polyE a b (smult c q) p =  (sgn c) * cindex_polyE a b q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b (smult c q) p = sgn c * cindex_polyE a b q p", "unfolding cindex_polyE_def jumpF_polyL_smult_1 jumpF_polyR_smult_1 cindex_poly_smult_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn c * jumpF_polyR q p a + real_of_int (sign c * cindex_poly a b q p) -\n    sgn c * jumpF_polyL q p b =\n    sgn c *\n    (jumpF_polyR q p a + real_of_int (cindex_poly a b q p) -\n     jumpF_polyL q p b)", "by (auto simp add:sgn_sign_eq[symmetric] algebra_simps)"], ["", "lemma cindex_polyE_mod:\n  fixes p q::\"real poly\" \n  shows \"cindex_polyE a b q p =  cindex_polyE a b (q mod p) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = cindex_polyE a b (q mod p) p", "unfolding cindex_polyE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p a + real_of_int (cindex_poly a b q p) -\n    jumpF_polyL q p b =\n    jumpF_polyR (q mod p) p a + real_of_int (cindex_poly a b (q mod p) p) -\n    jumpF_polyL (q mod p) p b", "apply (subst cindex_poly_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p a + real_of_int (cindex_poly a b (q mod p) p) -\n    jumpF_polyL q p b =\n    jumpF_polyR (q mod p) p a + real_of_int (cindex_poly a b (q mod p) p) -\n    jumpF_polyL (q mod p) p b", "apply (subst jumpF_polyR_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR (q mod p) p a + real_of_int (cindex_poly a b (q mod p) p) -\n    jumpF_polyL q p b =\n    jumpF_polyR (q mod p) p a + real_of_int (cindex_poly a b (q mod p) p) -\n    jumpF_polyL (q mod p) p b", "apply (subst jumpF_polyL_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR (q mod p) p a + real_of_int (cindex_poly a b (q mod p) p) -\n    jumpF_polyL (q mod p) p b =\n    jumpF_polyR (q mod p) p a + real_of_int (cindex_poly a b (q mod p) p) -\n    jumpF_polyL (q mod p) p b", "by simp"], ["", "lemma cindex_polyE_rec:\n  fixes p q::\"real poly\"\n  assumes \"a < b\" \"coprime p q\"\n  shows \"cindex_polyE a b q p  = cross_alt q p a b/2  +  cindex_polyE a b (- (p mod q)) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b q p =\n    real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b (- (p mod q)) q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_polyE a b q p =\n    real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b (- (p mod q)) q", "note cindex_polyE_inverse_add_cross[OF assms]"], ["proof (state)\nthis:\n  cindex_polyE a b q p + cindex_polyE a b p q =\n  real_of_int (cross_alt p q a b) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p =\n    real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b (- (p mod q)) q", "moreover"], ["proof (state)\nthis:\n  cindex_polyE a b q p + cindex_polyE a b p q =\n  real_of_int (cross_alt p q a b) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p =\n    real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b (- (p mod q)) q", "have \"cindex_polyE a b (- (p mod q)) q = - cindex_polyE a b p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b (- (p mod q)) q = - cindex_polyE a b p q", "using cindex_polyE_mod cindex_polyE_smult_1[of a b \"-1\"]"], ["proof (prove)\nusing this:\n  cindex_polyE ?a ?b ?q ?p = cindex_polyE ?a ?b (?q mod ?p) ?p\n  cindex_polyE a b (smult (- 1) ?q) ?p = sgn (- 1) * cindex_polyE a b ?q ?p\n\ngoal (1 subgoal):\n 1. cindex_polyE a b (- (p mod q)) q = - cindex_polyE a b p q", "by auto"], ["proof (state)\nthis:\n  cindex_polyE a b (- (p mod q)) q = - cindex_polyE a b p q\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p =\n    real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b (- (p mod q)) q", "ultimately"], ["proof (chain)\npicking this:\n  cindex_polyE a b q p + cindex_polyE a b p q =\n  real_of_int (cross_alt p q a b) / 2\n  cindex_polyE a b (- (p mod q)) q = - cindex_polyE a b p q", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_polyE a b q p + cindex_polyE a b p q =\n  real_of_int (cross_alt p q a b) / 2\n  cindex_polyE a b (- (p mod q)) q = - cindex_polyE a b p q\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p =\n    real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b (- (p mod q)) q", "by (auto simp add:field_simps cross_alt_poly_commute)"], ["proof (state)\nthis:\n  cindex_polyE a b q p =\n  real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b (- (p mod q)) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_polyE_changes_alt_itv_mods: \n  assumes \"a<b\" \"coprime p q\"\n  shows \"cindex_polyE a b q p = changes_alt_itv_smods a b p q / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "using \\<open>coprime p q\\<close>"], ["proof (prove)\nusing this:\n  coprime p q\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "proof (induct \"smods p q\" arbitrary:p q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>[] = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2\n 2. \\<And>aa x p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>x = smods p q; coprime p q\\<rbrakk>\n                   \\<Longrightarrow> cindex_polyE a b q p =\n                                     real_of_int\n(changes_alt_itv_smods a b p q) /\n                                     2;\n        aa # x = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2", "case Nil"], ["proof (state)\nthis:\n  [] = smods p q\n  coprime p q\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>[] = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2\n 2. \\<And>aa x p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>x = smods p q; coprime p q\\<rbrakk>\n                   \\<Longrightarrow> cindex_polyE a b q p =\n                                     real_of_int\n(changes_alt_itv_smods a b p q) /\n                                     2;\n        aa # x = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2", "then"], ["proof (chain)\npicking this:\n  [] = smods p q\n  coprime p q", "have \"p=0\""], ["proof (prove)\nusing this:\n  [] = smods p q\n  coprime p q\n\ngoal (1 subgoal):\n 1. p = 0", "by (metis smods_nil_eq)"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>[] = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2\n 2. \\<And>aa x p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>x = smods p q; coprime p q\\<rbrakk>\n                   \\<Longrightarrow> cindex_polyE a b q p =\n                                     real_of_int\n(changes_alt_itv_smods a b p q) /\n                                     2;\n        aa # x = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?case"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "by (simp add:changes_alt_itv_smods_def changes_alt_poly_at_def)"], ["proof (state)\nthis:\n  cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2\n\ngoal (1 subgoal):\n 1. \\<And>aa x p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>x = smods p q; coprime p q\\<rbrakk>\n                   \\<Longrightarrow> cindex_polyE a b q p =\n                                     real_of_int\n(changes_alt_itv_smods a b p q) /\n                                     2;\n        aa # x = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa x p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>x = smods p q; coprime p q\\<rbrakk>\n                   \\<Longrightarrow> cindex_polyE a b q p =\n                                     real_of_int\n(changes_alt_itv_smods a b p q) /\n                                     2;\n        aa # x = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>xs = smods ?p ?q; coprime ?p ?q\\<rbrakk>\n  \\<Longrightarrow> cindex_polyE a b ?q ?p =\n                    real_of_int (changes_alt_itv_smods a b ?p ?q) / 2\n  x # xs = smods p q\n  coprime p q\n\ngoal (1 subgoal):\n 1. \\<And>aa x p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>x = smods p q; coprime p q\\<rbrakk>\n                   \\<Longrightarrow> cindex_polyE a b q p =\n                                     real_of_int\n(changes_alt_itv_smods a b p q) /\n                                     2;\n        aa # x = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>xs = smods ?p ?q; coprime ?p ?q\\<rbrakk>\n  \\<Longrightarrow> cindex_polyE a b ?q ?p =\n                    real_of_int (changes_alt_itv_smods a b ?p ?q) / 2\n  x # xs = smods p q\n  coprime p q", "have \"p\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>xs = smods ?p ?q; coprime ?p ?q\\<rbrakk>\n  \\<Longrightarrow> cindex_polyE a b ?q ?p =\n                    real_of_int (changes_alt_itv_smods a b ?p ?q) / 2\n  x # xs = smods p q\n  coprime p q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>aa x p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>x = smods p q; coprime p q\\<rbrakk>\n                   \\<Longrightarrow> cindex_polyE a b q p =\n                                     real_of_int\n(changes_alt_itv_smods a b p q) /\n                                     2;\n        aa # x = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2", "have ?case when \"q=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "using that"], ["proof (prove)\nusing this:\n  q = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "by (simp add:changes_alt_itv_smods_def changes_alt_poly_at_def)"], ["proof (state)\nthis:\n  q = 0 \\<Longrightarrow>\n  cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2\n\ngoal (1 subgoal):\n 1. \\<And>aa x p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>x = smods p q; coprime p q\\<rbrakk>\n                   \\<Longrightarrow> cindex_polyE a b q p =\n                                     real_of_int\n(changes_alt_itv_smods a b p q) /\n                                     2;\n        aa # x = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2", "moreover"], ["proof (state)\nthis:\n  q = 0 \\<Longrightarrow>\n  cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2\n\ngoal (1 subgoal):\n 1. \\<And>aa x p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>x = smods p q; coprime p q\\<rbrakk>\n                   \\<Longrightarrow> cindex_polyE a b q p =\n                                     real_of_int\n(changes_alt_itv_smods a b p q) /\n                                     2;\n        aa # x = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2", "have ?case when \"q\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "define r where \"r\\<equiv>- (p mod q)\""], ["proof (state)\nthis:\n  r \\<equiv> - (p mod q)\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "obtain ps where ps:\"smods p q=p#q#ps\" \"smods q r=q#ps\" and \"xs=q#ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>smods p q = p # q # ps; smods q r = q # ps;\n         xs = q # ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>smods p q = p # q # ps; smods q (- (p mod q)) = q # ps;\n         xs = q # ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>q\\<noteq>0\\<close> \\<open>p\\<noteq>0\\<close> \\<open>x # xs = smods p q\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  p \\<noteq> 0\n  x # xs = smods p q\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>smods p q = p # q # ps; smods q (- (p mod q)) = q # ps;\n         xs = q # ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.inject smods.simps)"], ["proof (state)\nthis:\n  smods p q = p # q # ps\n  smods q r = q # ps\n  xs = q # ps\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "from Cons.prems \\<open>q \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  coprime p q\n  q \\<noteq> 0", "have \"coprime q r\""], ["proof (prove)\nusing this:\n  coprime p q\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coprime q r", "by (simp add: r_def ac_simps)"], ["proof (state)\nthis:\n  coprime q r\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "then"], ["proof (chain)\npicking this:\n  coprime q r", "have \"cindex_polyE a b r q = real_of_int (changes_alt_itv_smods a b q r) / 2\""], ["proof (prove)\nusing this:\n  coprime q r\n\ngoal (1 subgoal):\n 1. cindex_polyE a b r q = real_of_int (changes_alt_itv_smods a b q r) / 2", "apply (rule_tac Cons.hyps(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. coprime q r \\<Longrightarrow> xs = smods q r\n 2. coprime q r \\<Longrightarrow> coprime q r", "using ps \\<open>xs=q#ps\\<close>"], ["proof (prove)\nusing this:\n  smods p q = p # q # ps\n  smods q r = q # ps\n  xs = q # ps\n\ngoal (2 subgoals):\n 1. coprime q r \\<Longrightarrow> xs = smods q r\n 2. coprime q r \\<Longrightarrow> coprime q r", "by simp_all"], ["proof (state)\nthis:\n  cindex_polyE a b r q = real_of_int (changes_alt_itv_smods a b q r) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "moreover"], ["proof (state)\nthis:\n  cindex_polyE a b r q = real_of_int (changes_alt_itv_smods a b q r) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "have \"changes_alt_itv_smods a b p q = cross_alt p q a b + changes_alt_itv_smods a b q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q r", "using changes_alt_itv_smods_rec[OF \\<open>a<b\\<close> \\<open>coprime p q\\<close>,folded r_def]"], ["proof (prove)\nusing this:\n  changes_alt_itv_smods a b p q =\n  cross_alt p q a b + changes_alt_itv_smods a b q r\n\ngoal (1 subgoal):\n 1. changes_alt_itv_smods a b p q =\n    cross_alt p q a b + changes_alt_itv_smods a b q r", "."], ["proof (state)\nthis:\n  changes_alt_itv_smods a b p q =\n  cross_alt p q a b + changes_alt_itv_smods a b q r\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "moreover"], ["proof (state)\nthis:\n  changes_alt_itv_smods a b p q =\n  cross_alt p q a b + changes_alt_itv_smods a b q r\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "have \"cindex_polyE a b q p = real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b r q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE a b q p =\n    real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b r q", "using cindex_polyE_rec[OF \\<open>a<b\\<close> \\<open>coprime p q\\<close>,folded r_def]"], ["proof (prove)\nusing this:\n  cindex_polyE a b q p =\n  real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b r q\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p =\n    real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b r q", "."], ["proof (state)\nthis:\n  cindex_polyE a b q p =\n  real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b r q\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "ultimately"], ["proof (chain)\npicking this:\n  cindex_polyE a b r q = real_of_int (changes_alt_itv_smods a b q r) / 2\n  changes_alt_itv_smods a b p q =\n  cross_alt p q a b + changes_alt_itv_smods a b q r\n  cindex_polyE a b q p =\n  real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b r q", "show ?case"], ["proof (prove)\nusing this:\n  cindex_polyE a b r q = real_of_int (changes_alt_itv_smods a b q r) / 2\n  changes_alt_itv_smods a b p q =\n  cross_alt p q a b + changes_alt_itv_smods a b q r\n  cindex_polyE a b q p =\n  real_of_int (cross_alt q p a b) / 2 + cindex_polyE a b r q\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "by (auto simp add:field_simps cross_alt_poly_commute)"], ["proof (state)\nthis:\n  cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<noteq> 0 \\<Longrightarrow>\n  cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2\n\ngoal (1 subgoal):\n 1. \\<And>aa x p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>x = smods p q; coprime p q\\<rbrakk>\n                   \\<Longrightarrow> cindex_polyE a b q p =\n                                     real_of_int\n(changes_alt_itv_smods a b p q) /\n                                     2;\n        aa # x = smods p q; coprime p q\\<rbrakk>\n       \\<Longrightarrow> cindex_polyE a b q p =\n                         real_of_int (changes_alt_itv_smods a b p q) / 2", "ultimately"], ["proof (chain)\npicking this:\n  q = 0 \\<Longrightarrow>\n  cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2\n  q \\<noteq> 0 \\<Longrightarrow>\n  cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "show ?case"], ["proof (prove)\nusing this:\n  q = 0 \\<Longrightarrow>\n  cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2\n  q \\<noteq> 0 \\<Longrightarrow>\n  cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2", "by blast"], ["proof (state)\nthis:\n  cindex_polyE a b q p = real_of_int (changes_alt_itv_smods a b p q) / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_poly_ubd_eventually:\n  shows \"\\<forall>\\<^sub>F r in at_top. cindexE (-r) r (\\<lambda>x. poly q x/poly p x) = of_int (cindex_poly_ubd q p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "define f where \"f=(\\<lambda>x. poly q x/poly p x)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. poly q x / poly p x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "obtain R where R_def: \"R>0\" \"proots p \\<subseteq> {-R<..<R}\"\n    if \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < R;\n         p \\<noteq> 0 \\<Longrightarrow>\n         proots p \\<subseteq> {- R<..<R}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < R;\n                 p \\<noteq> 0 \\<Longrightarrow>\n                 proots p \\<subseteq> {- R<..<R}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>R.\n                \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < R;\n                 p \\<noteq> 0 \\<Longrightarrow>\n                 proots p \\<subseteq> {- R<..<R}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < R;\n                 p \\<noteq> 0 \\<Longrightarrow>\n                 proots p \\<subseteq> {- R<..<R}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>R.\n                \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < R;\n                 p \\<noteq> 0 \\<Longrightarrow>\n                 proots p \\<subseteq> {- R<..<R}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. thesis", "using that[of 1]"], ["proof (prove)\nusing this:\n  p = 0\n  \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < 1;\n   p \\<noteq> 0 \\<Longrightarrow> proots p \\<subseteq> {- 1<..<1}\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < R;\n                 p \\<noteq> 0 \\<Longrightarrow>\n                 proots p \\<subseteq> {- R<..<R}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < R;\n                 p \\<noteq> 0 \\<Longrightarrow>\n                 proots p \\<subseteq> {- R<..<R}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < R;\n                 p \\<noteq> 0 \\<Longrightarrow>\n                 proots p \\<subseteq> {- R<..<R}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"finite (proots p)\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (proots p)", "by auto"], ["proof (state)\nthis:\n  finite (proots p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < R;\n                 p \\<noteq> 0 \\<Longrightarrow>\n                 proots p \\<subseteq> {- R<..<R}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "from finite_ball_include[OF this,of 0]"], ["proof (chain)\npicking this:\n  \\<exists>e>0. proots p \\<subseteq> ball 0 e", "obtain r where \"r>0\" and r_ball:\"proots p \\<subseteq> ball 0 r\""], ["proof (prove)\nusing this:\n  \\<exists>e>0. proots p \\<subseteq> ball 0 e\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>0 < r; proots p \\<subseteq> ball 0 r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < r\n  proots p \\<subseteq> ball 0 r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < R;\n                 p \\<noteq> 0 \\<Longrightarrow>\n                 proots p \\<subseteq> {- R<..<R}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"proots p \\<subseteq> {-r<..<r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots p \\<subseteq> {- r<..<r}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> proots p \\<Longrightarrow> x \\<in> {- r<..<r}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> proots p \\<Longrightarrow> x \\<in> {- r<..<r}", "assume \"x \\<in> proots p\""], ["proof (state)\nthis:\n  x \\<in> proots p\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> proots p \\<Longrightarrow> x \\<in> {- r<..<r}", "then"], ["proof (chain)\npicking this:\n  x \\<in> proots p", "have \"x\\<in>ball 0 r\""], ["proof (prove)\nusing this:\n  x \\<in> proots p\n\ngoal (1 subgoal):\n 1. x \\<in> ball 0 r", "using r_ball"], ["proof (prove)\nusing this:\n  x \\<in> proots p\n  proots p \\<subseteq> ball 0 r\n\ngoal (1 subgoal):\n 1. x \\<in> ball 0 r", "by auto"], ["proof (state)\nthis:\n  x \\<in> ball 0 r\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> proots p \\<Longrightarrow> x \\<in> {- r<..<r}", "then"], ["proof (chain)\npicking this:\n  x \\<in> ball 0 r", "have \"abs x<r\""], ["proof (prove)\nusing this:\n  x \\<in> ball 0 r\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> < r", "using mem_ball_0"], ["proof (prove)\nusing this:\n  x \\<in> ball 0 r\n  (?x \\<in> ball (0::?'a) ?e) = (norm ?x < ?e)\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> < r", "by auto"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> < r\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> proots p \\<Longrightarrow> x \\<in> {- r<..<r}", "then"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> < r", "show \"x \\<in> {- r<..<r}\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> < r\n\ngoal (1 subgoal):\n 1. x \\<in> {- r<..<r}", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> < r\n  0 < r\n\ngoal (1 subgoal):\n 1. x \\<in> {- r<..<r}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {- r<..<r}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots p \\<subseteq> {- r<..<r}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>R.\n                \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < R;\n                 p \\<noteq> 0 \\<Longrightarrow>\n                 proots p \\<subseteq> {- R<..<R}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  proots p \\<subseteq> {- r<..<r}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots p \\<subseteq> {- r<..<r}\n\ngoal (1 subgoal):\n 1. thesis", "using that[of r] False \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  proots p \\<subseteq> {- r<..<r}\n  \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> 0 < r;\n   p \\<noteq> 0 \\<Longrightarrow> proots p \\<subseteq> {- r<..<r}\\<rbrakk>\n  \\<Longrightarrow> thesis\n  p \\<noteq> 0\n  0 < r\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow> 0 < R\n  p \\<noteq> 0 \\<Longrightarrow> proots p \\<subseteq> {- R<..<R}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "define l where \"l=(if p=0  then 0 else cindex_poly (-R) R q p)\""], ["proof (state)\nthis:\n  l = (if p = 0 then 0 else cindex_poly (- R) R q p)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "define P where \"P=(\\<lambda>l. (\\<forall>\\<^sub>F r in at_top. cindexE (-r) r f = of_int l))\""], ["proof (state)\nthis:\n  P =\n  (\\<lambda>l.\n      \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int l)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "have \"P l \""], ["proof (prove)\ngoal (1 subgoal):\n 1. P l", "proof (cases \"p=0 \")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P l\n 2. p \\<noteq> 0 \\<Longrightarrow> P l", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P l\n 2. p \\<noteq> 0 \\<Longrightarrow> P l", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. P l", "unfolding P_def f_def l_def"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (if p = 0 then 0 else cindex_poly (- R) R q p)", "using True"], ["proof (prove)\nusing this:\n  p = 0\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (if p = 0 then 0 else cindex_poly (- R) R q p)", "by (auto intro!: eventuallyI cindexE_constI)"], ["proof (state)\nthis:\n  P l\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> P l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> P l", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> P l", "have \"P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P l", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int l", "proof (rule eventually_at_top_linorderI[of R])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. R \\<le> x \\<Longrightarrow> cindexE (- x) x f = real_of_int l", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. R \\<le> x \\<Longrightarrow> cindexE (- x) x f = real_of_int l", "assume \"R \\<le> r\""], ["proof (state)\nthis:\n  R \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x. R \\<le> x \\<Longrightarrow> cindexE (- x) x f = real_of_int l", "then"], ["proof (chain)\npicking this:\n  R \\<le> r", "have \"cindexE (- r) r f =  cindex_polyE (-r) r q p\""], ["proof (prove)\nusing this:\n  R \\<le> r\n\ngoal (1 subgoal):\n 1. cindexE (- r) r f = cindex_polyE (- r) r q p", "unfolding f_def"], ["proof (prove)\nusing this:\n  R \\<le> r\n\ngoal (1 subgoal):\n 1. cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n    cindex_polyE (- r) r q p", "using R_def[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  R \\<le> r\n  0 < R\n  proots p \\<subseteq> {- R<..<R}\n\ngoal (1 subgoal):\n 1. cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n    cindex_polyE (- r) r q p", "by (auto intro: cindexE_eq_cindex_polyE)"], ["proof (state)\nthis:\n  cindexE (- r) r f = cindex_polyE (- r) r q p\n\ngoal (1 subgoal):\n 1. \\<And>x. R \\<le> x \\<Longrightarrow> cindexE (- x) x f = real_of_int l", "also"], ["proof (state)\nthis:\n  cindexE (- r) r f = cindex_polyE (- r) r q p\n\ngoal (1 subgoal):\n 1. \\<And>x. R \\<le> x \\<Longrightarrow> cindexE (- x) x f = real_of_int l", "have \"... = of_int (cindex_poly (- r) r q p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "have \"jumpF_polyR q p (- r) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p (- r) = 0", "apply (rule jumpF_poly_noroot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (- r) \\<noteq> 0", "using \\<open>R\\<le>r\\<close> R_def[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  R \\<le> r\n  0 < R\n  proots p \\<subseteq> {- R<..<R}\n\ngoal (1 subgoal):\n 1. poly p (- r) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  jumpF_polyR q p (- r) = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "moreover"], ["proof (state)\nthis:\n  jumpF_polyR q p (- r) = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "have \"jumpF_polyL q p r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p r = 0", "apply (rule jumpF_poly_noroot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p r \\<noteq> 0", "using \\<open>R\\<le>r\\<close> R_def[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  R \\<le> r\n  0 < R\n  proots p \\<subseteq> {- R<..<R}\n\ngoal (1 subgoal):\n 1. poly p r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  jumpF_polyL q p r = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "ultimately"], ["proof (chain)\npicking this:\n  jumpF_polyR q p (- r) = 0\n  jumpF_polyL q p r = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyR q p (- r) = 0\n  jumpF_polyL q p r = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "unfolding cindex_polyE_def"], ["proof (prove)\nusing this:\n  jumpF_polyR q p (- r) = 0\n  jumpF_polyL q p r = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p (- r) + real_of_int (cindex_poly (- r) r q p) -\n    jumpF_polyL q p r =\n    real_of_int (cindex_poly (- r) r q p)", "by auto"], ["proof (state)\nthis:\n  cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)\n\ngoal (1 subgoal):\n 1. \\<And>x. R \\<le> x \\<Longrightarrow> cindexE (- x) x f = real_of_int l", "also"], ["proof (state)\nthis:\n  cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)\n\ngoal (1 subgoal):\n 1. \\<And>x. R \\<le> x \\<Longrightarrow> cindexE (- x) x f = real_of_int l", "have \"... = of_int (cindex_poly (- R) R q p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (cindex_poly (- r) r q p) =\n    real_of_int (cindex_poly (- R) R q p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (cindex_poly (- r) r q p) =\n    real_of_int (cindex_poly (- R) R q p)", "define rs where \"rs={x. poly p x = 0 \\<and> - r < x \\<and> x < r}\""], ["proof (state)\nthis:\n  rs = {x. poly p x = 0 \\<and> - r < x \\<and> x < r}\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_poly (- r) r q p) =\n    real_of_int (cindex_poly (- R) R q p)", "define Rs where \"Rs={x. poly p x = 0 \\<and> - R < x \\<and> x < R}\""], ["proof (state)\nthis:\n  Rs = {x. poly p x = 0 \\<and> - R < x \\<and> x < R}\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_poly (- r) r q p) =\n    real_of_int (cindex_poly (- R) R q p)", "have \"rs=Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs = Rs", "using R_def[OF \\<open>p\\<noteq>0\\<close>] \\<open>R\\<le>r\\<close>"], ["proof (prove)\nusing this:\n  0 < R\n  proots p \\<subseteq> {- R<..<R}\n  R \\<le> r\n\ngoal (1 subgoal):\n 1. rs = Rs", "unfolding rs_def Rs_def"], ["proof (prove)\nusing this:\n  0 < R\n  proots p \\<subseteq> {- R<..<R}\n  R \\<le> r\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0 \\<and> - r < x \\<and> x < r} =\n    {x. poly p x = 0 \\<and> - R < x \\<and> x < R}", "by force"], ["proof (state)\nthis:\n  rs = Rs\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_poly (- r) r q p) =\n    real_of_int (cindex_poly (- R) R q p)", "then"], ["proof (chain)\npicking this:\n  rs = Rs", "show ?thesis"], ["proof (prove)\nusing this:\n  rs = Rs\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_poly (- r) r q p) =\n    real_of_int (cindex_poly (- R) R q p)", "unfolding cindex_poly_def"], ["proof (prove)\nusing this:\n  rs = Rs\n\ngoal (1 subgoal):\n 1. real_of_int\n     (\\<Sum>x | poly p x = 0 \\<and> - r < x \\<and> x < r. jump_poly q p x) =\n    real_of_int\n     (\\<Sum>x | poly p x = 0 \\<and> - R < x \\<and> x < R. jump_poly q p x)", "by (fold rs_def Rs_def,auto)"], ["proof (state)\nthis:\n  real_of_int (cindex_poly (- r) r q p) =\n  real_of_int (cindex_poly (- R) R q p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int (cindex_poly (- r) r q p) =\n  real_of_int (cindex_poly (- R) R q p)\n\ngoal (1 subgoal):\n 1. \\<And>x. R \\<le> x \\<Longrightarrow> cindexE (- x) x f = real_of_int l", "also"], ["proof (state)\nthis:\n  real_of_int (cindex_poly (- r) r q p) =\n  real_of_int (cindex_poly (- R) R q p)\n\ngoal (1 subgoal):\n 1. \\<And>x. R \\<le> x \\<Longrightarrow> cindexE (- x) x f = real_of_int l", "have \"... = of_int l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (cindex_poly (- R) R q p) = real_of_int l", "unfolding l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (cindex_poly (- R) R q p) =\n    real_of_int (if p = 0 then 0 else cindex_poly (- R) R q p)", "using False"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int (cindex_poly (- R) R q p) =\n    real_of_int (if p = 0 then 0 else cindex_poly (- R) R q p)", "by auto"], ["proof (state)\nthis:\n  real_of_int (cindex_poly (- R) R q p) = real_of_int l\n\ngoal (1 subgoal):\n 1. \\<And>x. R \\<le> x \\<Longrightarrow> cindexE (- x) x f = real_of_int l", "finally"], ["proof (chain)\npicking this:\n  cindexE (- r) r f = real_of_int l", "show \"cindexE (- r) r f = real_of_int l\""], ["proof (prove)\nusing this:\n  cindexE (- r) r f = real_of_int l\n\ngoal (1 subgoal):\n 1. cindexE (- r) r f = real_of_int l", "."], ["proof (state)\nthis:\n  cindexE (- r) r f = real_of_int l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P l\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> P l", "then"], ["proof (chain)\npicking this:\n  P l", "show ?thesis"], ["proof (prove)\nusing this:\n  P l\n\ngoal (1 subgoal):\n 1. P l", "unfolding P_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int l", "by auto"], ["proof (state)\nthis:\n  P l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "moreover"], ["proof (state)\nthis:\n  P l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "have \"x=l\" when \"P x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = l", "have \"\\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x\"\n         \"\\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x &&&\n    \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int l", "using \\<open>P x\\<close> \\<open>P l\\<close>"], ["proof (prove)\nusing this:\n  P x\n  P l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x &&&\n    \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int l", "unfolding P_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x &&&\n    \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int l", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int l\n\ngoal (1 subgoal):\n 1. x = l", "from eventually_conj[OF this]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F xa in at_top.\n     cindexE (- xa) xa f = real_of_int x \\<and>\n     cindexE (- xa) xa f = real_of_int l", "have \"\\<forall>\\<^sub>F r::real in at_top. real_of_int x = real_of_int l\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F xa in at_top.\n     cindexE (- xa) xa f = real_of_int x \\<and>\n     cindexE (- xa) xa f = real_of_int l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top. real_of_int x = real_of_int l", "by (elim eventually_mono,auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top. real_of_int x = real_of_int l\n\ngoal (1 subgoal):\n 1. x = l", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F r in at_top. real_of_int x = real_of_int l", "have \"real_of_int x = real_of_int l\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top. real_of_int x = real_of_int l\n\ngoal (1 subgoal):\n 1. real_of_int x = real_of_int l", "by auto"], ["proof (state)\nthis:\n  real_of_int x = real_of_int l\n\ngoal (1 subgoal):\n 1. x = l", "then"], ["proof (chain)\npicking this:\n  real_of_int x = real_of_int l", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int x = real_of_int l\n\ngoal (1 subgoal):\n 1. x = l", "by simp"], ["proof (state)\nthis:\n  x = l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P ?x \\<Longrightarrow> ?x = l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "ultimately"], ["proof (chain)\npicking this:\n  P l\n  P ?x \\<Longrightarrow> ?x = l", "have \"P (THE x. P x)\""], ["proof (prove)\nusing this:\n  P l\n  P ?x \\<Longrightarrow> ?x = l\n\ngoal (1 subgoal):\n 1. P (THE x. P x)", "using theI[of P l]"], ["proof (prove)\nusing this:\n  P l\n  P ?x \\<Longrightarrow> ?x = l\n  \\<lbrakk>P l; \\<And>x. P x \\<Longrightarrow> x = l\\<rbrakk>\n  \\<Longrightarrow> P (THE x. P x)\n\ngoal (1 subgoal):\n 1. P (THE x. P x)", "by blast"], ["proof (state)\nthis:\n  P (THE x. P x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "then"], ["proof (chain)\npicking this:\n  P (THE x. P x)", "show ?thesis"], ["proof (prove)\nusing this:\n  P (THE x. P x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "unfolding P_def f_def cindex_poly_ubd_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n     real_of_int\n      (THE x.\n          \\<forall>\\<^sub>F r in at_top.\n             cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n             real_of_int x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int\n        (THE l.\n            \\<forall>\\<^sub>F r in at_top.\n               cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n               real_of_int l)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n     real_of_int (cindex_poly_ubd q p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_poly_ubd_0:\n  assumes \"p=0 \\<or> q=0\"\n  shows \"cindex_poly_ubd q p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly_ubd q p = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_poly_ubd q p = 0", "have \"\\<forall>\\<^sub>F r in at_top. cindexE (-r) r (\\<lambda>x. poly q x/poly p x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) = 0", "apply (rule eventuallyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. cindexE (- x) x (\\<lambda>x. poly q x / poly p x) = 0", "using assms"], ["proof (prove)\nusing this:\n  p = 0 \\<or> q = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. cindexE (- x) x (\\<lambda>x. poly q x / poly p x) = 0", "by (auto intro:cindexE_constI)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r (\\<lambda>x. poly q x / poly p x) = 0\n\ngoal (1 subgoal):\n 1. cindex_poly_ubd q p = 0", "from eventually_conj[OF this cindex_poly_ubd_eventually[of q p]]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top.\n     cindexE (- x) x (\\<lambda>x. poly q x / poly p x) = 0 \\<and>\n     cindexE (- x) x (\\<lambda>x. poly q x / poly p x) =\n     real_of_int (cindex_poly_ubd q p)", "have \"\\<forall>\\<^sub>F r::real in at_top.  (cindex_poly_ubd q p) = (0::int)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top.\n     cindexE (- x) x (\\<lambda>x. poly q x / poly p x) = 0 \\<and>\n     cindexE (- x) x (\\<lambda>x. poly q x / poly p x) =\n     real_of_int (cindex_poly_ubd q p)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top. cindex_poly_ubd q p = 0", "apply (elim eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cindexE (- x) x (\\<lambda>x. poly q x / poly p x) = 0 \\<and>\n       cindexE (- x) x (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p) \\<Longrightarrow>\n       cindex_poly_ubd q p = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top. cindex_poly_ubd q p = 0\n\ngoal (1 subgoal):\n 1. cindex_poly_ubd q p = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F r in at_top. cindex_poly_ubd q p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top. cindex_poly_ubd q p = 0\n\ngoal (1 subgoal):\n 1. cindex_poly_ubd q p = 0", "by auto"], ["proof (state)\nthis:\n  cindex_poly_ubd q p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindex_poly_ubd_code:\n  shows \"cindex_poly_ubd q p = changes_R_smods p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly_ubd q p = changes_R_smods p q", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q\n 2. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q\n 2. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. cindex_poly_ubd q p = changes_R_smods p q", "using cindex_poly_ubd_0"], ["proof (prove)\nusing this:\n  p = 0\n  ?p = 0 \\<or> ?q = 0 \\<Longrightarrow> cindex_poly_ubd ?q ?p = 0\n\ngoal (1 subgoal):\n 1. cindex_poly_ubd q p = changes_R_smods p q", "by auto"], ["proof (state)\nthis:\n  cindex_poly_ubd q p = changes_R_smods p q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "define ps where \"ps\\<equiv>smods p q\""], ["proof (state)\nthis:\n  ps \\<equiv> smods p q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "have \"p\\<in>set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set ps", "using ps_def \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  ps \\<equiv> smods p q\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<in> set ps", "by auto"], ["proof (state)\nthis:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "obtain lb where lb:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x>lb\"\n      and lb_sgn:\"\\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\"\n      and \"lb<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_lb[OF no_0_in_smods,of p q,folded ps_def]"], ["proof (prove)\nusing this:\n  (\\<And>lb.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n       \\<forall>x\\<le>lb.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n       lb < ?b\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\n  lb < 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "obtain ub where ub:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x<ub\"\n      and ub_sgn:\"\\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\"\n      and \"ub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         0 < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_ub[OF no_0_in_smods,of p q,folded ps_def]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n       \\<forall>x\\<ge>ub.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n       ?a < ub\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         0 < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  \\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\n  0 < ub\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "define f where \"f=(\\<lambda>t. poly q t/ poly p t)\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. poly q t / poly p t)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "define P where \"P=(\\<lambda>l. (\\<forall>\\<^sub>F r in at_top. cindexE (-r) r f = of_int l))\""], ["proof (state)\nthis:\n  P =\n  (\\<lambda>l.\n      \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int l)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "have \"P (changes_R_smods p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (changes_R_smods p q)", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r f = real_of_int (changes_R_smods p q)", "proof (rule eventually_at_top_linorderI[of \"max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> x \\<Longrightarrow>\n       cindexE (- x) x f = real_of_int (changes_R_smods p q)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> x \\<Longrightarrow>\n       cindexE (- x) x f = real_of_int (changes_R_smods p q)", "assume r_asm:\"r\\<ge>max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1\""], ["proof (state)\nthis:\n  max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> x \\<Longrightarrow>\n       cindexE (- x) x f = real_of_int (changes_R_smods p q)", "have \"cindexE (- r) r f =  cindex_polyE (-r) r q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (- r) r f = cindex_polyE (- r) r q p", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (- r) r (\\<lambda>t. poly q t / poly p t) =\n    cindex_polyE (- r) r q p", "using r_asm"], ["proof (prove)\nusing this:\n  max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. cindexE (- r) r (\\<lambda>t. poly q t / poly p t) =\n    cindex_polyE (- r) r q p", "by (auto intro: cindexE_eq_cindex_polyE)"], ["proof (state)\nthis:\n  cindexE (- r) r f = cindex_polyE (- r) r q p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> x \\<Longrightarrow>\n       cindexE (- x) x f = real_of_int (changes_R_smods p q)", "also"], ["proof (state)\nthis:\n  cindexE (- r) r f = cindex_polyE (- r) r q p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> x \\<Longrightarrow>\n       cindexE (- x) x f = real_of_int (changes_R_smods p q)", "have \"... = of_int (cindex_poly (- r) r q p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "have \"jumpF_polyR q p (- r) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p (- r) = 0", "apply (rule jumpF_poly_noroot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (- r) \\<noteq> 0", "using r_asm lb[rule_format,OF \\<open>p\\<in>set ps\\<close>,of \"-r\"]"], ["proof (prove)\nusing this:\n  max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> r\n  poly p (- r) = 0 \\<Longrightarrow> lb < - r\n\ngoal (1 subgoal):\n 1. poly p (- r) \\<noteq> 0", "by linarith"], ["proof (state)\nthis:\n  jumpF_polyR q p (- r) = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "moreover"], ["proof (state)\nthis:\n  jumpF_polyR q p (- r) = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "have \"jumpF_polyL q p r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p r = 0", "apply (rule jumpF_poly_noroot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p r \\<noteq> 0", "using r_asm ub[rule_format,OF \\<open>p\\<in>set ps\\<close>,of \"r\"]"], ["proof (prove)\nusing this:\n  max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> r\n  poly p r = 0 \\<Longrightarrow> r < ub\n\ngoal (1 subgoal):\n 1. poly p r \\<noteq> 0", "by linarith"], ["proof (state)\nthis:\n  jumpF_polyL q p r = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "ultimately"], ["proof (chain)\npicking this:\n  jumpF_polyR q p (- r) = 0\n  jumpF_polyL q p r = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF_polyR q p (- r) = 0\n  jumpF_polyL q p r = 0\n\ngoal (1 subgoal):\n 1. cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)", "unfolding cindex_polyE_def"], ["proof (prove)\nusing this:\n  jumpF_polyR q p (- r) = 0\n  jumpF_polyL q p r = 0\n\ngoal (1 subgoal):\n 1. jumpF_polyR q p (- r) + real_of_int (cindex_poly (- r) r q p) -\n    jumpF_polyL q p r =\n    real_of_int (cindex_poly (- r) r q p)", "by auto"], ["proof (state)\nthis:\n  cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> x \\<Longrightarrow>\n       cindexE (- x) x f = real_of_int (changes_R_smods p q)", "also"], ["proof (state)\nthis:\n  cindex_polyE (- r) r q p = real_of_int (cindex_poly (- r) r q p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> x \\<Longrightarrow>\n       cindexE (- x) x f = real_of_int (changes_R_smods p q)", "have \"... = of_int (changes_itv_smods (- r) r p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (cindex_poly (- r) r q p) =\n    real_of_int (changes_itv_smods (- r) r p q)", "apply (rule cindex_poly_changes_itv_mods[THEN arg_cong])"], ["proof (prove)\ngoal (3 subgoals):\n 1. - r < r\n 2. poly p (- r) \\<noteq> 0\n 3. poly p r \\<noteq> 0", "using r_asm lb[rule_format,OF \\<open>p\\<in>set ps\\<close>,of \"-r\"] ub[rule_format,OF \\<open>p\\<in>set ps\\<close>,of \"r\"]"], ["proof (prove)\nusing this:\n  max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> r\n  poly p (- r) = 0 \\<Longrightarrow> lb < - r\n  poly p r = 0 \\<Longrightarrow> r < ub\n\ngoal (3 subgoals):\n 1. - r < r\n 2. poly p (- r) \\<noteq> 0\n 3. poly p r \\<noteq> 0", "by linarith+"], ["proof (state)\nthis:\n  real_of_int (cindex_poly (- r) r q p) =\n  real_of_int (changes_itv_smods (- r) r p q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> x \\<Longrightarrow>\n       cindexE (- x) x f = real_of_int (changes_R_smods p q)", "also"], ["proof (state)\nthis:\n  real_of_int (cindex_poly (- r) r q p) =\n  real_of_int (changes_itv_smods (- r) r p q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> x \\<Longrightarrow>\n       cindexE (- x) x f = real_of_int (changes_R_smods p q)", "have \"... = of_int (changes_R_smods p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (changes_itv_smods (- r) r p q) =\n    real_of_int (changes_R_smods p q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (changes_itv_smods (- r) r p q) =\n    real_of_int (changes_R_smods p q)", "have \"map (sgn \\<circ> (\\<lambda>p. poly p (-r))) ps = map sgn_neg_inf ps\"\n          and \"map (sgn \\<circ> (\\<lambda>p. poly p r)) ps = map sgn_pos_inf ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p (- r))) ps = map sgn_neg_inf ps &&&\n    map (sgn \\<circ> (\\<lambda>p. poly p r)) ps = map sgn_pos_inf ps", "using lb_sgn[THEN spec,of \"-r\",simplified] ub_sgn[THEN spec,of r,simplified] r_asm"], ["proof (prove)\nusing this:\n  - r \\<le> lb \\<longrightarrow>\n  (\\<forall>p\\<in>set ps. sgn (poly p (- r)) = sgn_neg_inf p)\n  ub \\<le> r \\<longrightarrow>\n  (\\<forall>p\\<in>set ps. sgn (poly p r) = sgn_pos_inf p)\n  max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p (- r))) ps = map sgn_neg_inf ps &&&\n    map (sgn \\<circ> (\\<lambda>p. poly p r)) ps = map sgn_pos_inf ps", "by auto"], ["proof (state)\nthis:\n  map (sgn \\<circ> (\\<lambda>p. poly p (- r))) ps = map sgn_neg_inf ps\n  map (sgn \\<circ> (\\<lambda>p. poly p r)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. real_of_int (changes_itv_smods (- r) r p q) =\n    real_of_int (changes_R_smods p q)", "hence \"changes_poly_at ps (-r)=changes_poly_neg_inf ps\n          \\<and> changes_poly_at ps r=changes_poly_pos_inf ps\""], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p (- r))) ps = map sgn_neg_inf ps\n  map (sgn \\<circ> (\\<lambda>p. poly p r)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_poly_at ps (- r) = changes_poly_neg_inf ps \\<and>\n    changes_poly_at ps r = changes_poly_pos_inf ps", "unfolding changes_poly_neg_inf_def changes_poly_at_def changes_poly_pos_inf_def"], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p (- r))) ps = map sgn_neg_inf ps\n  map (sgn \\<circ> (\\<lambda>p. poly p r)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p (- r)) ps) =\n    changes (map sgn_neg_inf ps) \\<and>\n    changes (map (\\<lambda>p. poly p r) ps) = changes (map sgn_pos_inf ps)", "by (subst (1 3)  changes_map_sgn_eq,metis map_map)"], ["proof (state)\nthis:\n  changes_poly_at ps (- r) = changes_poly_neg_inf ps \\<and>\n  changes_poly_at ps r = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. real_of_int (changes_itv_smods (- r) r p q) =\n    real_of_int (changes_R_smods p q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at ps (- r) = changes_poly_neg_inf ps \\<and>\n  changes_poly_at ps r = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. real_of_int (changes_itv_smods (- r) r p q) =\n    real_of_int (changes_R_smods p q)", "unfolding changes_R_smods_def changes_itv_smods_def ps_def"], ["proof (prove)\nusing this:\n  changes_poly_at (smods p q) (- r) =\n  changes_poly_neg_inf (smods p q) \\<and>\n  changes_poly_at (smods p q) r = changes_poly_pos_inf (smods p q)\n\ngoal (1 subgoal):\n 1. real_of_int\n     (let ps = smods p q\n      in changes_poly_at ps (- r) - changes_poly_at ps r) =\n    real_of_int\n     (let ps = smods p q\n      in changes_poly_neg_inf ps - changes_poly_pos_inf ps)", "by metis"], ["proof (state)\nthis:\n  real_of_int (changes_itv_smods (- r) r p q) =\n  real_of_int (changes_R_smods p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int (changes_itv_smods (- r) r p q) =\n  real_of_int (changes_R_smods p q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max \\<bar>lb\\<bar> \\<bar>ub\\<bar> + 1 \\<le> x \\<Longrightarrow>\n       cindexE (- x) x f = real_of_int (changes_R_smods p q)", "finally"], ["proof (chain)\npicking this:\n  cindexE (- r) r f = real_of_int (changes_R_smods p q)", "show \"cindexE (- r) r f =  of_int (changes_R_smods p q)\""], ["proof (prove)\nusing this:\n  cindexE (- r) r f = real_of_int (changes_R_smods p q)\n\ngoal (1 subgoal):\n 1. cindexE (- r) r f = real_of_int (changes_R_smods p q)", "."], ["proof (state)\nthis:\n  cindexE (- r) r f = real_of_int (changes_R_smods p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (changes_R_smods p q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "moreover"], ["proof (state)\nthis:\n  P (changes_R_smods p q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "have \"x = changes_R_smods p q\" when \"P x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = changes_R_smods p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = changes_R_smods p q", "have \"\\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int (changes_R_smods p q)\" \n        \"\\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r f = real_of_int (changes_R_smods p q) &&&\n    \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x", "using \\<open>P (changes_R_smods p q)\\<close> \\<open>P x\\<close>"], ["proof (prove)\nusing this:\n  P (changes_R_smods p q)\n  P x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r f = real_of_int (changes_R_smods p q) &&&\n    \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x", "unfolding P_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r f = real_of_int (changes_R_smods p q)\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r f = real_of_int (changes_R_smods p q) &&&\n    \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r f = real_of_int (changes_R_smods p q)\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = real_of_int x\n\ngoal (1 subgoal):\n 1. x = changes_R_smods p q", "from eventually_conj[OF this]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F xa in at_top.\n     cindexE (- xa) xa f = real_of_int (changes_R_smods p q) \\<and>\n     cindexE (- xa) xa f = real_of_int x", "have \"\\<forall>\\<^sub>F (r::real) in at_top. of_int x = of_int (changes_R_smods p q)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F xa in at_top.\n     cindexE (- xa) xa f = real_of_int (changes_R_smods p q) \\<and>\n     cindexE (- xa) xa f = real_of_int x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top. of_int x = of_int (changes_R_smods p q)", "by (elim eventually_mono,auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top. of_int x = of_int (changes_R_smods p q)\n\ngoal (1 subgoal):\n 1. x = changes_R_smods p q", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F r in at_top. of_int x = of_int (changes_R_smods p q)", "have \"of_int x = of_int (changes_R_smods p q)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top. of_int x = of_int (changes_R_smods p q)\n\ngoal (1 subgoal):\n 1. of_int x = of_int (changes_R_smods p q)", "using eventually_const_iff"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top. of_int x = of_int (changes_R_smods p q)\n  (\\<forall>\\<^sub>F x in ?F. ?P) = (?P \\<or> ?F = bot)\n\ngoal (1 subgoal):\n 1. of_int x = of_int (changes_R_smods p q)", "by auto"], ["proof (state)\nthis:\n  of_int x = of_int (changes_R_smods p q)\n\ngoal (1 subgoal):\n 1. x = changes_R_smods p q", "then"], ["proof (chain)\npicking this:\n  of_int x = of_int (changes_R_smods p q)", "show ?thesis"], ["proof (prove)\nusing this:\n  of_int x = of_int (changes_R_smods p q)\n\ngoal (1 subgoal):\n 1. x = changes_R_smods p q", "using of_int_eq_iff"], ["proof (prove)\nusing this:\n  of_int x = of_int (changes_R_smods p q)\n  (of_int ?w = of_int ?z) = (?w = ?z)\n\ngoal (1 subgoal):\n 1. x = changes_R_smods p q", "by blast"], ["proof (state)\nthis:\n  x = changes_R_smods p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P ?x \\<Longrightarrow> ?x = changes_R_smods p q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "ultimately"], ["proof (chain)\npicking this:\n  P (changes_R_smods p q)\n  P ?x \\<Longrightarrow> ?x = changes_R_smods p q", "have \"(THE x. P x) = changes_R_smods p q\""], ["proof (prove)\nusing this:\n  P (changes_R_smods p q)\n  P ?x \\<Longrightarrow> ?x = changes_R_smods p q\n\ngoal (1 subgoal):\n 1. (THE x. P x) = changes_R_smods p q", "using the_equality[of P \"changes_R_smods p q\"]"], ["proof (prove)\nusing this:\n  P (changes_R_smods p q)\n  P ?x \\<Longrightarrow> ?x = changes_R_smods p q\n  \\<lbrakk>P (changes_R_smods p q);\n   \\<And>x. P x \\<Longrightarrow> x = changes_R_smods p q\\<rbrakk>\n  \\<Longrightarrow> (THE x. P x) = changes_R_smods p q\n\ngoal (1 subgoal):\n 1. (THE x. P x) = changes_R_smods p q", "by blast"], ["proof (state)\nthis:\n  (THE x. P x) = changes_R_smods p q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> cindex_poly_ubd q p = changes_R_smods p q", "then"], ["proof (chain)\npicking this:\n  (THE x. P x) = changes_R_smods p q", "show ?thesis"], ["proof (prove)\nusing this:\n  (THE x. P x) = changes_R_smods p q\n\ngoal (1 subgoal):\n 1. cindex_poly_ubd q p = changes_R_smods p q", "unfolding cindex_poly_ubd_def P_def f_def"], ["proof (prove)\nusing this:\n  (THE x.\n      \\<forall>\\<^sub>F r in at_top.\n         cindexE (- r) r (\\<lambda>t. poly q t / poly p t) =\n         real_of_int x) =\n  changes_R_smods p q\n\ngoal (1 subgoal):\n 1. (THE l.\n        \\<forall>\\<^sub>F r in at_top.\n           cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n           real_of_int l) =\n    changes_R_smods p q", "by auto"], ["proof (state)\nthis:\n  cindex_poly_ubd q p = changes_R_smods p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindexE_ubd_poly: \"cindexE_ubd (\\<lambda>x. poly q x/poly p x) = cindex_poly_ubd q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "using cindex_poly_ubd_0"], ["proof (prove)\nusing this:\n  p = 0\n  ?p = 0 \\<or> ?q = 0 \\<Longrightarrow> cindex_poly_ubd ?q ?p = 0\n\ngoal (1 subgoal):\n 1. cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "unfolding cindexE_ubd_def"], ["proof (prove)\nusing this:\n  p = 0\n  ?p = 0 \\<or> ?q = 0 \\<Longrightarrow> cindex_poly_ubd ?q ?p = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF (\\<lambda>x. poly q x / poly p x) (at_right x) \\<noteq>\n               0.\n       jumpF (\\<lambda>x. poly q x / poly p x) (at_right x)) -\n    (\\<Sum>x | jumpF (\\<lambda>x. poly q x / poly p x) (at_left x) \\<noteq>\n               0.\n       jumpF (\\<lambda>x. poly q x / poly p x) (at_left x)) =\n    real_of_int (cindex_poly_ubd q p)", "by auto"], ["proof (state)\nthis:\n  cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n  real_of_int (cindex_poly_ubd q p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "define mx mn where \"mx = Max {x. poly p x = 0}\" and \"mn = Min {x. poly p x=0}\""], ["proof (state)\nthis:\n  mx = Max {x. poly p x = 0}\n  mn = Min {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "define rr where \"rr= 1+ (max \\<bar>mx\\<bar> \\<bar>mn\\<bar>)\""], ["proof (state)\nthis:\n  rr = 1 + max \\<bar>mx\\<bar> \\<bar>mn\\<bar>\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "have rr:\"-rr < x \\<and> x< rr\" when \"poly p x = 0 \" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. - rr < x \\<and> x < rr", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - rr < x \\<and> x < rr", "have \"finite {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0}", "using \\<open>p\\<noteq>0\\<close> poly_roots_finite"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0}", "by blast"], ["proof (state)\nthis:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. - rr < x \\<and> x < rr", "then"], ["proof (chain)\npicking this:\n  finite {x. poly p x = 0}", "have \"mn \\<le> x\" \"x\\<le>mx\""], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. mn \\<le> x &&& x \\<le> mx", "using Max_ge Min_le that"], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> ?x \\<le> Max ?A\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> Min ?A \\<le> ?x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. mn \\<le> x &&& x \\<le> mx", "unfolding mn_def mx_def"], ["proof (prove)\nusing this:\n  finite {x. poly p x = 0}\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> ?x \\<le> Max ?A\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> Min ?A \\<le> ?x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. Min {x. poly p x = 0} \\<le> x &&& x \\<le> Max {x. poly p x = 0}", "by simp_all"], ["proof (state)\nthis:\n  mn \\<le> x\n  x \\<le> mx\n\ngoal (1 subgoal):\n 1. - rr < x \\<and> x < rr", "then"], ["proof (chain)\npicking this:\n  mn \\<le> x\n  x \\<le> mx", "show ?thesis"], ["proof (prove)\nusing this:\n  mn \\<le> x\n  x \\<le> mx\n\ngoal (1 subgoal):\n 1. - rr < x \\<and> x < rr", "unfolding rr_def"], ["proof (prove)\nusing this:\n  mn \\<le> x\n  x \\<le> mx\n\ngoal (1 subgoal):\n 1. - (1 + max \\<bar>mx\\<bar> \\<bar>mn\\<bar>) < x \\<and>\n    x < 1 + max \\<bar>mx\\<bar> \\<bar>mn\\<bar>", "by auto"], ["proof (state)\nthis:\n  - rr < x \\<and> x < rr\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p ?x = 0 \\<Longrightarrow> - rr < ?x \\<and> ?x < rr\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "define f where \"f=(\\<lambda>x. poly q x / poly p x)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. poly q x / poly p x)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "have \"\\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = cindexE_ubd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = cindexE_ubd f", "proof (rule eventually_at_top_linorderI[of rr])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. rr \\<le> x \\<Longrightarrow> cindexE (- x) x f = cindexE_ubd f", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. rr \\<le> x \\<Longrightarrow> cindexE (- x) x f = cindexE_ubd f", "assume \"r\\<ge>rr\""], ["proof (state)\nthis:\n  rr \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x. rr \\<le> x \\<Longrightarrow> cindexE (- x) x f = cindexE_ubd f", "define R1 R2 where \"R1={x. jumpF f (at_right x) \\<noteq> 0 \\<and> - r \\<le> x \\<and> x < r}\"\n                       and \"R2 = {x. jumpF f (at_right x) \\<noteq> 0}\""], ["proof (state)\nthis:\n  R1 = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> - r \\<le> x \\<and> x < r}\n  R2 = {x. jumpF f (at_right x) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<And>x. rr \\<le> x \\<Longrightarrow> cindexE (- x) x f = cindexE_ubd f", "define L1 L2 where \"L1={x. jumpF f (at_left x) \\<noteq> 0 \\<and> - r < x \\<and> x \\<le> r}\"\n                       and \"L2={x. jumpF f (at_left x) \\<noteq> 0}\""], ["proof (state)\nthis:\n  L1 = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> - r < x \\<and> x \\<le> r}\n  L2 = {x. jumpF f (at_left x) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<And>x. rr \\<le> x \\<Longrightarrow> cindexE (- x) x f = cindexE_ubd f", "have \"R1=R2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 = R2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R1 = R2", "have \"jumpF f (at_right x) = 0\" when \"\\<not> (- r \\<le> x \\<and> x < r)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0", "have \"jumpF f (at_right x) = jumpF_polyR q p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = jumpF_polyR q p x", "unfolding f_def jumpF_polyR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at_right x) =\n    jumpF (\\<lambda>x. poly q x / poly p x) (at_right x)", "by simp"], ["proof (state)\nthis:\n  jumpF f (at_right x) = jumpF_polyR q p x\n\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0", "also"], ["proof (state)\nthis:\n  jumpF f (at_right x) = jumpF_polyR q p x\n\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyR q p x = 0", "apply (rule jumpF_poly_noroot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0", "using  that \\<open>r\\<ge>rr\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (- r \\<le> x \\<and> x < r)\n  rr \\<le> r\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0", "by (auto dest:rr)"], ["proof (state)\nthis:\n  jumpF_polyR q p x = 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0", "finally"], ["proof (chain)\npicking this:\n  jumpF f (at_right x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF f (at_right x) = 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0", "."], ["proof (state)\nthis:\n  jumpF f (at_right x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (- r \\<le> ?x \\<and> ?x < r) \\<Longrightarrow>\n  jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. R1 = R2", "then"], ["proof (chain)\npicking this:\n  \\<not> (- r \\<le> ?x \\<and> ?x < r) \\<Longrightarrow>\n  jumpF f (at_right ?x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (- r \\<le> ?x \\<and> ?x < r) \\<Longrightarrow>\n  jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. R1 = R2", "unfolding R1_def R2_def"], ["proof (prove)\nusing this:\n  \\<not> (- r \\<le> ?x \\<and> ?x < r) \\<Longrightarrow>\n  jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_right x) \\<noteq> 0 \\<and> - r \\<le> x \\<and> x < r} =\n    {x. jumpF f (at_right x) \\<noteq> 0}", "by blast"], ["proof (state)\nthis:\n  R1 = R2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R1 = R2\n\ngoal (1 subgoal):\n 1. \\<And>x. rr \\<le> x \\<Longrightarrow> cindexE (- x) x f = cindexE_ubd f", "moreover"], ["proof (state)\nthis:\n  R1 = R2\n\ngoal (1 subgoal):\n 1. \\<And>x. rr \\<le> x \\<Longrightarrow> cindexE (- x) x f = cindexE_ubd f", "have \"L1=L2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L1 = L2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. L1 = L2", "have \"jumpF f (at_left x) = 0\" when \"\\<not> (- r < x \\<and> x \\<le> r)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0", "have \"jumpF f (at_left x) = jumpF_polyL q p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = jumpF_polyL q p x", "unfolding f_def jumpF_polyL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>x. poly q x / poly p x) (at_left x) =\n    jumpF (\\<lambda>x. poly q x / poly p x) (at_left x)", "by simp"], ["proof (state)\nthis:\n  jumpF f (at_left x) = jumpF_polyL q p x\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0", "also"], ["proof (state)\nthis:\n  jumpF f (at_left x) = jumpF_polyL q p x\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF_polyL q p x = 0", "apply (rule jumpF_poly_noroot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0", "using that \\<open>r\\<ge>rr\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (- r < x \\<and> x \\<le> r)\n  rr \\<le> r\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0", "by (auto dest:rr)"], ["proof (state)\nthis:\n  jumpF_polyL q p x = 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0", "finally"], ["proof (chain)\npicking this:\n  jumpF f (at_left x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  jumpF f (at_left x) = 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0", "."], ["proof (state)\nthis:\n  jumpF f (at_left x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (- r < ?x \\<and> ?x \\<le> r) \\<Longrightarrow>\n  jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. L1 = L2", "then"], ["proof (chain)\npicking this:\n  \\<not> (- r < ?x \\<and> ?x \\<le> r) \\<Longrightarrow>\n  jumpF f (at_left ?x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (- r < ?x \\<and> ?x \\<le> r) \\<Longrightarrow>\n  jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. L1 = L2", "unfolding L1_def L2_def"], ["proof (prove)\nusing this:\n  \\<not> (- r < ?x \\<and> ?x \\<le> r) \\<Longrightarrow>\n  jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> - r < x \\<and> x \\<le> r} =\n    {x. jumpF f (at_left x) \\<noteq> 0}", "by blast"], ["proof (state)\nthis:\n  L1 = L2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  L1 = L2\n\ngoal (1 subgoal):\n 1. \\<And>x. rr \\<le> x \\<Longrightarrow> cindexE (- x) x f = cindexE_ubd f", "ultimately"], ["proof (chain)\npicking this:\n  R1 = R2\n  L1 = L2", "show \"cindexE (- r) r f = cindexE_ubd f\""], ["proof (prove)\nusing this:\n  R1 = R2\n  L1 = L2\n\ngoal (1 subgoal):\n 1. cindexE (- r) r f = cindexE_ubd f", "unfolding cindexE_def cindexE_ubd_def"], ["proof (prove)\nusing this:\n  R1 = R2\n  L1 = L2\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               - r \\<le> x \\<and> x < r.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n               - r < x \\<and> x \\<le> r.\n       jumpF f (at_left x)) =\n    (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0. jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0. jumpF f (at_left x))", "apply (fold R1_def R2_def L1_def L2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 = R2; L1 = L2\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>R1. jumpF f (at_right x)) -\n                      (\\<Sum>x\\<in>L1. jumpF f (at_left x)) =\n                      (\\<Sum>x\\<in>R2. jumpF f (at_right x)) -\n                      (\\<Sum>x\\<in>L2. jumpF f (at_left x))", "by auto"], ["proof (state)\nthis:\n  cindexE (- r) r f = cindexE_ubd f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = cindexE_ubd f\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = cindexE_ubd f\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "have \"\\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = cindex_poly_ubd q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r f = real_of_int (cindex_poly_ubd q p)", "using cindex_poly_ubd_eventually"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r (\\<lambda>x. poly ?q x / poly ?p x) =\n     real_of_int (cindex_poly_ubd ?q ?p)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r f = real_of_int (cindex_poly_ubd q p)", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r (\\<lambda>x. poly ?q x / poly ?p x) =\n     real_of_int (cindex_poly_ubd ?q ?p)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r (\\<lambda>x. poly q x / poly p x) =\n       real_of_int (cindex_poly_ubd q p)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r f = real_of_int (cindex_poly_ubd q p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = cindexE_ubd f\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r f = real_of_int (cindex_poly_ubd q p)", "have \"\\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = cindexE_ubd f \n                          \\<and> cindexE (- r) r f = cindex_poly_ubd q p\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = cindexE_ubd f\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r f = real_of_int (cindex_poly_ubd q p)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r f = cindexE_ubd f \\<and>\n       cindexE (- r) r f = real_of_int (cindex_poly_ubd q p)", "using eventually_conj"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top. cindexE (- r) r f = cindexE_ubd f\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r f = real_of_int (cindex_poly_ubd q p)\n  \\<lbrakk>eventually ?P ?F; eventually ?Q ?F\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F x in ?F. ?P x \\<and> ?Q x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE (- r) r f = cindexE_ubd f \\<and>\n       cindexE (- r) r f = real_of_int (cindex_poly_ubd q p)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r f = cindexE_ubd f \\<and>\n     cindexE (- r) r f = real_of_int (cindex_poly_ubd q p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r f = cindexE_ubd f \\<and>\n     cindexE (- r) r f = real_of_int (cindex_poly_ubd q p)", "have \"\\<forall>\\<^sub>F (r::real) in at_top. cindexE_ubd f = cindex_poly_ubd q p\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r f = cindexE_ubd f \\<and>\n     cindexE (- r) r f = real_of_int (cindex_poly_ubd q p)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       cindexE_ubd f = real_of_int (cindex_poly_ubd q p)", "by (elim eventually_mono) auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE_ubd f = real_of_int (cindex_poly_ubd q p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE_ubd f = real_of_int (cindex_poly_ubd q p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE_ubd f = real_of_int (cindex_poly_ubd q p)\n\ngoal (1 subgoal):\n 1. cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n     real_of_int (cindex_poly_ubd q p)\n\ngoal (1 subgoal):\n 1. cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n    real_of_int (cindex_poly_ubd q p)", "by auto"], ["proof (state)\nthis:\n  cindexE_ubd (\\<lambda>x. poly q x / poly p x) =\n  real_of_int (cindex_poly_ubd q p)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}