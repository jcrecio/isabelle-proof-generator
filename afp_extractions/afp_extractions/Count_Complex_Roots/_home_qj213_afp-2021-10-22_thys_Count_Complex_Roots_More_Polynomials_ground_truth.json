{"file_name": "/home/qj213/afp-2021-10-22/thys/Count_Complex_Roots/More_Polynomials.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Count_Complex_Roots", "problem_names": ["lemma order_normalize[simp]:\"order x (normalize p) = order x p\"", "lemma order_gcd:\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"order x (gcd p q) = min (order x p) (order x q)\"", "lemma pderiv_power: \"pderiv (p ^ n) = smult (of_nat n) (p ^ (n-1)) * pderiv p\"", "lemma order_pderiv:\n  fixes p::\"'a::{idom,semiring_char_0} poly\"\n  assumes \"p\\<noteq>0\" \"poly p x=0\"\n  shows \"order x p = Suc (order x (pderiv p))\"", "lemma rsquarefree_0[simp]: \"\\<not> rsquarefree 0\"", "lemma rsquarefree_times:\n  assumes \"rsquarefree (p*q)\"\n  shows \"rsquarefree q\"", "lemma rsquarefree_smult_iff:\n  assumes \"s\\<noteq>0\"\n  shows \"rsquarefree (smult s p) \\<longleftrightarrow> rsquarefree p\"", "lemma card_proots_within_rsquarefree:\n  assumes \"rsquarefree p\"\n  shows \"proots_count p s = card (proots_within p s)\"", "lemma rsquarefree_gcd_pderiv:\n  fixes p::\"'a::{factorial_ring_gcd,semiring_gcd_mult_normalize,semiring_char_0} poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"rsquarefree (p div (gcd p (pderiv p)))\"", "lemma poly_gcd_pderiv_iff:\n  fixes p::\"'a::{semiring_char_0,factorial_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  shows \"poly (p div (gcd p (pderiv p))) x =0 \\<longleftrightarrow> poly p x=0\"", "lemma poly_circlepath_tan_eq:\n  fixes z0::complex and r::real and p::\"complex poly\"\n  defines \"q1\\<equiv> fcompose p [:(z0+r)*\\<i>,z0-r:] [:\\<i>,1:]\" and \"q2 \\<equiv> [:\\<i>,1:] ^ degree p\"\n  assumes \"0\\<le>t\" \"t\\<le>1\" \"t\\<noteq>1/2\"\n  shows \"poly p (circlepath z0 r t) = poly q1 (tan (pi*t)) / poly q2 (tan (pi*t))\" \n    (is \"?L = ?R\")"], "translations": [["", "lemma order_normalize[simp]:\"order x (normalize p) = order x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (normalize p) = order x p", "by (metis dvd_normalize_iff normalize_eq_0_iff order_1 order_2 order_unique_lemma)"], ["", "lemma order_gcd:\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"order x (gcd p q) = min (order x p) (order x q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "define xx op oq where \"xx=[:- x, 1:]\" and \"op = order x p\" and \"oq = order x q\""], ["proof (state)\nthis:\n  xx = [:- x, 1::'a:]\n  op = order x p\n  oq = order x q\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "obtain pp where pp:\"p = xx ^ op * pp\" \"\\<not> xx dvd pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pp.\n        \\<lbrakk>p = xx ^ op * pp; \\<not> xx dvd pp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using order_decomp[OF \\<open>p\\<noteq>0\\<close>,of x,folded xx_def op_def]"], ["proof (prove)\nusing this:\n  \\<exists>q. p = xx ^ op * q \\<and> \\<not> xx dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>pp.\n        \\<lbrakk>p = xx ^ op * pp; \\<not> xx dvd pp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = xx ^ op * pp\n  \\<not> xx dvd pp\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "obtain qq where qq:\"q = xx ^ oq * qq\" \"\\<not> xx dvd qq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qq.\n        \\<lbrakk>q = xx ^ oq * qq; \\<not> xx dvd qq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using order_decomp[OF \\<open>q\\<noteq>0\\<close>,of x,folded xx_def oq_def]"], ["proof (prove)\nusing this:\n  \\<exists>qa. q = xx ^ oq * qa \\<and> \\<not> xx dvd qa\n\ngoal (1 subgoal):\n 1. (\\<And>qq.\n        \\<lbrakk>q = xx ^ oq * qq; \\<not> xx dvd qq\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q = xx ^ oq * qq\n  \\<not> xx dvd qq\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "define pq where \"pq = gcd pp qq\""], ["proof (state)\nthis:\n  pq = gcd pp qq\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "have p_unfold:\"p = (pq * xx ^ (min op oq)) * ((pp div pq) * xx ^ (op - min op oq))\"\n        and [simp]:\"coprime xx (pp div pq)\" and \"pp\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = pq * xx ^ min op oq * (pp div pq * xx ^ (op - min op oq)) &&&\n    coprime xx (pp div pq) &&& pp \\<noteq> 0", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. p = pq * xx ^ min op oq * (pp div pq * xx ^ (op - min op oq))\n 2. coprime xx (pp div pq)\n 3. pp \\<noteq> 0", "have \"xx ^ op = xx ^ (min op oq) * xx ^ (op - min op oq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xx ^ op = xx ^ min op oq * xx ^ (op - min op oq)", "by (simp flip:power_add)"], ["proof (state)\nthis:\n  xx ^ op = xx ^ min op oq * xx ^ (op - min op oq)\n\ngoal (3 subgoals):\n 1. p = pq * xx ^ min op oq * (pp div pq * xx ^ (op - min op oq))\n 2. coprime xx (pp div pq)\n 3. pp \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  xx ^ op = xx ^ min op oq * xx ^ (op - min op oq)\n\ngoal (3 subgoals):\n 1. p = pq * xx ^ min op oq * (pp div pq * xx ^ (op - min op oq))\n 2. coprime xx (pp div pq)\n 3. pp \\<noteq> 0", "have \"pp = pq * (pp div pq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp = pq * (pp div pq)", "unfolding pq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp = gcd pp qq * (pp div gcd pp qq)", "by simp"], ["proof (state)\nthis:\n  pp = pq * (pp div pq)\n\ngoal (3 subgoals):\n 1. p = pq * xx ^ min op oq * (pp div pq * xx ^ (op - min op oq))\n 2. coprime xx (pp div pq)\n 3. pp \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  xx ^ op = xx ^ min op oq * xx ^ (op - min op oq)\n  pp = pq * (pp div pq)", "show \"p = (pq * xx ^ (min op oq)) * ((pp div pq) * xx ^ (op - min op oq))\""], ["proof (prove)\nusing this:\n  xx ^ op = xx ^ min op oq * xx ^ (op - min op oq)\n  pp = pq * (pp div pq)\n\ngoal (1 subgoal):\n 1. p = pq * xx ^ min op oq * (pp div pq * xx ^ (op - min op oq))", "unfolding pq_def pp"], ["proof (prove)\nusing this:\n  xx ^ op = xx ^ min op oq * xx ^ (op - min op oq)\n  pp = gcd pp qq * (pp div gcd pp qq)\n\ngoal (1 subgoal):\n 1. xx ^ op * pp =\n    gcd pp qq * xx ^ min op oq * (pp div gcd pp qq * xx ^ (op - min op oq))", "by(auto simp:algebra_simps)"], ["proof (state)\nthis:\n  p = pq * xx ^ min op oq * (pp div pq * xx ^ (op - min op oq))\n\ngoal (2 subgoals):\n 1. coprime xx (pp div pq)\n 2. pp \\<noteq> 0", "show \"coprime xx (pp div pq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime xx (pp div pq)", "apply (rule prime_elem_imp_coprime[OF \n                    prime_elem_linear_poly[of 1 \"-x\",simplified],folded xx_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> xx dvd pp div pq", "using \\<open>pp = pq * (pp div pq)\\<close> pp(2)"], ["proof (prove)\nusing this:\n  pp = pq * (pp div pq)\n  \\<not> xx dvd pp\n\ngoal (1 subgoal):\n 1. \\<not> xx dvd pp div pq", "by auto"], ["proof (state)\nthis:\n  coprime xx (pp div pq)\n\ngoal (1 subgoal):\n 1. pp \\<noteq> 0", "qed (use pp \\<open>p\\<noteq>0\\<close> in auto)"], ["proof (state)\nthis:\n  p = pq * xx ^ min op oq * (pp div pq * xx ^ (op - min op oq))\n  coprime xx (pp div pq)\n  pp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "have q_unfold:\"q = (pq * xx ^ (min op oq)) * ((qq div pq) * xx ^ (oq - min op oq))\"\n         and [simp]:\"coprime xx (qq div pq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = pq * xx ^ min op oq * (qq div pq * xx ^ (oq - min op oq)) &&&\n    coprime xx (qq div pq)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. q = pq * xx ^ min op oq * (qq div pq * xx ^ (oq - min op oq))\n 2. coprime xx (qq div pq)", "have \"xx ^ oq = xx ^ (min op oq) * xx ^ (oq - min op oq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xx ^ oq = xx ^ min op oq * xx ^ (oq - min op oq)", "by (simp flip:power_add)"], ["proof (state)\nthis:\n  xx ^ oq = xx ^ min op oq * xx ^ (oq - min op oq)\n\ngoal (2 subgoals):\n 1. q = pq * xx ^ min op oq * (qq div pq * xx ^ (oq - min op oq))\n 2. coprime xx (qq div pq)", "moreover"], ["proof (state)\nthis:\n  xx ^ oq = xx ^ min op oq * xx ^ (oq - min op oq)\n\ngoal (2 subgoals):\n 1. q = pq * xx ^ min op oq * (qq div pq * xx ^ (oq - min op oq))\n 2. coprime xx (qq div pq)", "have \"qq = pq * (qq div pq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qq = pq * (qq div pq)", "unfolding pq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. qq = gcd pp qq * (qq div gcd pp qq)", "by simp"], ["proof (state)\nthis:\n  qq = pq * (qq div pq)\n\ngoal (2 subgoals):\n 1. q = pq * xx ^ min op oq * (qq div pq * xx ^ (oq - min op oq))\n 2. coprime xx (qq div pq)", "ultimately"], ["proof (chain)\npicking this:\n  xx ^ oq = xx ^ min op oq * xx ^ (oq - min op oq)\n  qq = pq * (qq div pq)", "show \"q = (pq * xx ^ (min op oq)) * ((qq div pq) * xx ^ (oq - min op oq))\""], ["proof (prove)\nusing this:\n  xx ^ oq = xx ^ min op oq * xx ^ (oq - min op oq)\n  qq = pq * (qq div pq)\n\ngoal (1 subgoal):\n 1. q = pq * xx ^ min op oq * (qq div pq * xx ^ (oq - min op oq))", "unfolding pq_def qq"], ["proof (prove)\nusing this:\n  xx ^ oq = xx ^ min op oq * xx ^ (oq - min op oq)\n  qq = gcd pp qq * (qq div gcd pp qq)\n\ngoal (1 subgoal):\n 1. xx ^ oq * qq =\n    gcd pp qq * xx ^ min op oq * (qq div gcd pp qq * xx ^ (oq - min op oq))", "by(auto simp:algebra_simps)"], ["proof (state)\nthis:\n  q = pq * xx ^ min op oq * (qq div pq * xx ^ (oq - min op oq))\n\ngoal (1 subgoal):\n 1. coprime xx (qq div pq)", "show \"coprime xx (qq div pq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime xx (qq div pq)", "apply (rule prime_elem_imp_coprime[OF \n                    prime_elem_linear_poly[of 1 \"-x\",simplified],folded xx_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> xx dvd qq div pq", "using \\<open>qq = pq * (qq div pq)\\<close> qq(2)"], ["proof (prove)\nusing this:\n  qq = pq * (qq div pq)\n  \\<not> xx dvd qq\n\ngoal (1 subgoal):\n 1. \\<not> xx dvd qq div pq", "by auto"], ["proof (state)\nthis:\n  coprime xx (qq div pq)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q = pq * xx ^ min op oq * (qq div pq * xx ^ (oq - min op oq))\n  coprime xx (qq div pq)\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "have \"gcd p q=normalize (pq * xx ^ (min op oq))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p q = normalize (pq * xx ^ min op oq)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd p q = normalize (pq * xx ^ min op oq)", "have \"coprime (pp div pq * xx ^ (op - min op oq)) (qq div pq * xx ^ (oq - min op oq))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "proof (cases \"op>oq\")"], ["proof (state)\ngoal (2 subgoals):\n 1. oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))\n 2. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "case True"], ["proof (state)\nthis:\n  oq < op\n\ngoal (2 subgoals):\n 1. oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))\n 2. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "then"], ["proof (chain)\npicking this:\n  oq < op", "have \"oq - min op oq = 0\""], ["proof (prove)\nusing this:\n  oq < op\n\ngoal (1 subgoal):\n 1. oq - min op oq = 0", "by auto"], ["proof (state)\nthis:\n  oq - min op oq = 0\n\ngoal (2 subgoals):\n 1. oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))\n 2. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "moreover"], ["proof (state)\nthis:\n  oq - min op oq = 0\n\ngoal (2 subgoals):\n 1. oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))\n 2. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "have \"coprime (xx ^ (op - min op oq)) (qq div pq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (xx ^ (op - min op oq)) (qq div pq)", "by auto"], ["proof (state)\nthis:\n  coprime (xx ^ (op - min op oq)) (qq div pq)\n\ngoal (2 subgoals):\n 1. oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))\n 2. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "moreover"], ["proof (state)\nthis:\n  coprime (xx ^ (op - min op oq)) (qq div pq)\n\ngoal (2 subgoals):\n 1. oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))\n 2. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "have \"coprime (pp div pq) (qq div pq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (pp div pq) (qq div pq)", "apply (rule div_gcd_coprime[of pp qq,folded pq_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp \\<noteq> 0 \\<or> qq \\<noteq> 0", "using \\<open>pp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  pp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pp \\<noteq> 0 \\<or> qq \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  coprime (pp div pq) (qq div pq)\n\ngoal (2 subgoals):\n 1. oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))\n 2. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "ultimately"], ["proof (chain)\npicking this:\n  oq - min op oq = 0\n  coprime (xx ^ (op - min op oq)) (qq div pq)\n  coprime (pp div pq) (qq div pq)", "show ?thesis"], ["proof (prove)\nusing this:\n  oq - min op oq = 0\n  coprime (xx ^ (op - min op oq)) (qq div pq)\n  coprime (pp div pq) (qq div pq)\n\ngoal (1 subgoal):\n 1. coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "by auto"], ["proof (state)\nthis:\n  coprime (pp div pq * xx ^ (op - min op oq))\n   (qq div pq * xx ^ (oq - min op oq))\n\ngoal (1 subgoal):\n 1. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "case False"], ["proof (state)\nthis:\n  \\<not> oq < op\n\ngoal (1 subgoal):\n 1. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "then"], ["proof (chain)\npicking this:\n  \\<not> oq < op", "have \"op - min op oq = 0\""], ["proof (prove)\nusing this:\n  \\<not> oq < op\n\ngoal (1 subgoal):\n 1. op - min op oq = 0", "by auto"], ["proof (state)\nthis:\n  op - min op oq = 0\n\ngoal (1 subgoal):\n 1. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "moreover"], ["proof (state)\nthis:\n  op - min op oq = 0\n\ngoal (1 subgoal):\n 1. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "have \"coprime (pp div pq) (xx ^ (oq - min op oq))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (pp div pq) (xx ^ (oq - min op oq))", "by (auto simp:coprime_commute)"], ["proof (state)\nthis:\n  coprime (pp div pq) (xx ^ (oq - min op oq))\n\ngoal (1 subgoal):\n 1. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "moreover"], ["proof (state)\nthis:\n  coprime (pp div pq) (xx ^ (oq - min op oq))\n\ngoal (1 subgoal):\n 1. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "have \"coprime (pp div pq) (qq div pq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (pp div pq) (qq div pq)", "apply (rule div_gcd_coprime[of pp qq,folded pq_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp \\<noteq> 0 \\<or> qq \\<noteq> 0", "using \\<open>pp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  pp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pp \\<noteq> 0 \\<or> qq \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  coprime (pp div pq) (qq div pq)\n\ngoal (1 subgoal):\n 1. \\<not> oq < op \\<Longrightarrow>\n    coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "ultimately"], ["proof (chain)\npicking this:\n  op - min op oq = 0\n  coprime (pp div pq) (xx ^ (oq - min op oq))\n  coprime (pp div pq) (qq div pq)", "show ?thesis"], ["proof (prove)\nusing this:\n  op - min op oq = 0\n  coprime (pp div pq) (xx ^ (oq - min op oq))\n  coprime (pp div pq) (qq div pq)\n\ngoal (1 subgoal):\n 1. coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq))", "by auto"], ["proof (state)\nthis:\n  coprime (pp div pq * xx ^ (op - min op oq))\n   (qq div pq * xx ^ (oq - min op oq))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coprime (pp div pq * xx ^ (op - min op oq))\n   (qq div pq * xx ^ (oq - min op oq))\n\ngoal (1 subgoal):\n 1. gcd p q = normalize (pq * xx ^ min op oq)", "then"], ["proof (chain)\npicking this:\n  coprime (pp div pq * xx ^ (op - min op oq))\n   (qq div pq * xx ^ (oq - min op oq))", "show ?thesis"], ["proof (prove)\nusing this:\n  coprime (pp div pq * xx ^ (op - min op oq))\n   (qq div pq * xx ^ (oq - min op oq))\n\ngoal (1 subgoal):\n 1. gcd p q = normalize (pq * xx ^ min op oq)", "unfolding p_unfold q_unfold"], ["proof (prove)\nusing this:\n  coprime (pp div pq * xx ^ (op - min op oq))\n   (qq div pq * xx ^ (oq - min op oq))\n\ngoal (1 subgoal):\n 1. gcd (pq * xx ^ min op oq * (pp div pq * xx ^ (op - min op oq)))\n     (pq * xx ^ min op oq * (qq div pq * xx ^ (oq - min op oq))) =\n    normalize (pq * xx ^ min op oq)", "apply (subst gcd_mult_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (pp div pq * xx ^ (op - min op oq))\n     (qq div pq * xx ^ (oq - min op oq)) \\<Longrightarrow>\n    normalize\n     (pq * xx ^ min op oq *\n      gcd (pp div pq * xx ^ (op - min op oq))\n       (qq div pq * xx ^ (oq - min op oq))) =\n    normalize (pq * xx ^ min op oq)", "by auto"], ["proof (state)\nthis:\n  gcd p q = normalize (pq * xx ^ min op oq)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd p q = normalize (pq * xx ^ min op oq)\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "then"], ["proof (chain)\npicking this:\n  gcd p q = normalize (pq * xx ^ min op oq)", "have \"order x (gcd p q) = order x pq + order x (xx ^ (min op oq))\""], ["proof (prove)\nusing this:\n  gcd p q = normalize (pq * xx ^ min op oq)\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = order x pq + order x (xx ^ min op oq)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p q = normalize (pq * xx ^ min op oq) \\<Longrightarrow>\n    order x (pq * xx ^ min op oq) = order x pq + order x (xx ^ min op oq)", "apply (subst order_mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gcd p q = normalize (pq * xx ^ min op oq) \\<Longrightarrow>\n    pq * xx ^ min op oq \\<noteq> 0\n 2. gcd p q = normalize (pq * xx ^ min op oq) \\<Longrightarrow>\n    order x pq + order x (xx ^ min op oq) =\n    order x pq + order x (xx ^ min op oq)", "using assms(1) p_unfold"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = pq * xx ^ min op oq * (pp div pq * xx ^ (op - min op oq))\n\ngoal (2 subgoals):\n 1. gcd p q = normalize (pq * xx ^ min op oq) \\<Longrightarrow>\n    pq * xx ^ min op oq \\<noteq> 0\n 2. gcd p q = normalize (pq * xx ^ min op oq) \\<Longrightarrow>\n    order x pq + order x (xx ^ min op oq) =\n    order x pq + order x (xx ^ min op oq)", "by auto"], ["proof (state)\nthis:\n  order x (gcd p q) = order x pq + order x (xx ^ min op oq)\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "also"], ["proof (state)\nthis:\n  order x (gcd p q) = order x pq + order x (xx ^ min op oq)\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "have \"... = order x (xx ^ (min op oq))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x pq + order x (xx ^ min op oq) = order x (xx ^ min op oq)", "using pp(2) qq(2)"], ["proof (prove)\nusing this:\n  \\<not> xx dvd pp\n  \\<not> xx dvd qq\n\ngoal (1 subgoal):\n 1. order x pq + order x (xx ^ min op oq) = order x (xx ^ min op oq)", "unfolding pq_def xx_def"], ["proof (prove)\nusing this:\n  \\<not> [:- x, 1::'a:] dvd pp\n  \\<not> [:- x, 1::'a:] dvd qq\n\ngoal (1 subgoal):\n 1. order x (gcd pp qq) + order x ([:- x, 1::'a:] ^ min op oq) =\n    order x ([:- x, 1::'a:] ^ min op oq)", "by (auto simp add: order_0I poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  order x pq + order x (xx ^ min op oq) = order x (xx ^ min op oq)\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "also"], ["proof (state)\nthis:\n  order x pq + order x (xx ^ min op oq) = order x (xx ^ min op oq)\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "have \"... = min op oq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (xx ^ min op oq) = min op oq", "unfolding xx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x ([:- x, 1::'a:] ^ min op oq) = min op oq", "by (rule order_power_n_n)"], ["proof (state)\nthis:\n  order x (xx ^ min op oq) = min op oq\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "also"], ["proof (state)\nthis:\n  order x (xx ^ min op oq) = min op oq\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "have \"... = min (order x p) (order x q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min op oq = min (order x p) (order x q)", "unfolding op_def oq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min (order x p) (order x q) = min (order x p) (order x q)", "by simp"], ["proof (state)\nthis:\n  min op oq = min (order x p) (order x q)\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "finally"], ["proof (chain)\npicking this:\n  order x (gcd p q) = min (order x p) (order x q)", "show ?thesis"], ["proof (prove)\nusing this:\n  order x (gcd p q) = min (order x p) (order x q)\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "."], ["proof (state)\nthis:\n  order x (gcd p q) = min (order x p) (order x q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pderiv_power: \"pderiv (p ^ n) = smult (of_nat n) (p ^ (n-1)) * pderiv p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (p ^ n) = smult (of_nat n) (p ^ (n - 1)) * pderiv p", "apply (cases n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    pderiv (p ^ n) = smult (of_nat n) (p ^ (n - 1)) * pderiv p\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       pderiv (p ^ n) = smult (of_nat n) (p ^ (n - 1)) * pderiv p", "using pderiv_power_Suc"], ["proof (prove)\nusing this:\n  pderiv (?p ^ Suc ?n) = smult (of_nat (Suc ?n)) (?p ^ ?n) * pderiv ?p\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    pderiv (p ^ n) = smult (of_nat n) (p ^ (n - 1)) * pderiv p\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       pderiv (p ^ n) = smult (of_nat n) (p ^ (n - 1)) * pderiv p", "by auto"], ["", "(*TODO: to replace the one (with the same name) in the library, as this version does \n  not require 'a to be a field?*)"], ["", "lemma order_pderiv:\n  fixes p::\"'a::{idom,semiring_char_0} poly\"\n  assumes \"p\\<noteq>0\" \"poly p x=0\"\n  shows \"order x p = Suc (order x (pderiv p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = Suc (order x (pderiv p))", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. order x p = Suc (order x (pderiv p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> order x p = Suc (order x (pderiv p))", "define xx op where \"xx=[:- x, 1:]\" and \"op = order x p\""], ["proof (state)\nthis:\n  xx = [:- x, 1::'a:]\n  op = order x p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> order x p = Suc (order x (pderiv p))", "have \"op \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op \\<noteq> 0", "unfolding op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0", "using assms order_root"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly p x = (0::'a)\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. order x p \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  op \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> order x p = Suc (order x (pderiv p))", "obtain pp where pp:\"p = xx ^ op * pp\" \"\\<not> xx dvd pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pp.\n        \\<lbrakk>p = xx ^ op * pp; \\<not> xx dvd pp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using order_decomp[OF \\<open>p\\<noteq>0\\<close>,of x,folded xx_def op_def]"], ["proof (prove)\nusing this:\n  \\<exists>q. p = xx ^ op * q \\<and> \\<not> xx dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>pp.\n        \\<lbrakk>p = xx ^ op * pp; \\<not> xx dvd pp\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = xx ^ op * pp\n  \\<not> xx dvd pp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> order x p = Suc (order x (pderiv p))", "have p_der:\"pderiv p = smult (of_nat op) (xx^(op -1)) * pp + xx^op*pderiv pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p = smult (of_nat op) (xx ^ (op - 1)) * pp + xx ^ op * pderiv pp", "unfolding pp(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (xx ^ op * pp) =\n    smult (of_nat op) (xx ^ (op - 1)) * pp + xx ^ op * pderiv pp", "by (auto simp:pderiv_mult pderiv_power xx_def algebra_simps pderiv_pCons)"], ["proof (state)\nthis:\n  pderiv p = smult (of_nat op) (xx ^ (op - 1)) * pp + xx ^ op * pderiv pp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> order x p = Suc (order x (pderiv p))", "have \"xx^(op -1) dvd (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xx ^ (op - 1) dvd pderiv p", "unfolding p_der"], ["proof (prove)\ngoal (1 subgoal):\n 1. xx ^ (op - 1) dvd\n    smult (of_nat op) (xx ^ (op - 1)) * pp + xx ^ op * pderiv pp", "by (metis One_nat_def Suc_pred assms(1) assms(2) dvd_add dvd_mult_right dvd_triv_left \n        neq0_conv op_def order_root power_Suc smult_dvd_cancel)"], ["proof (state)\nthis:\n  xx ^ (op - 1) dvd pderiv p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> order x p = Suc (order x (pderiv p))", "moreover"], ["proof (state)\nthis:\n  xx ^ (op - 1) dvd pderiv p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> order x p = Suc (order x (pderiv p))", "have \"\\<not> xx^op dvd (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> xx ^ op dvd pderiv p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. xx ^ op dvd pderiv p \\<Longrightarrow> False", "assume \"xx ^ op dvd pderiv p\""], ["proof (state)\nthis:\n  xx ^ op dvd pderiv p\n\ngoal (1 subgoal):\n 1. xx ^ op dvd pderiv p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xx ^ op dvd pderiv p", "have \"xx ^ op dvd smult (of_nat op) (xx^(op -1) * pp)\""], ["proof (prove)\nusing this:\n  xx ^ op dvd pderiv p\n\ngoal (1 subgoal):\n 1. xx ^ op dvd smult (of_nat op) (xx ^ (op - 1) * pp)", "unfolding p_der"], ["proof (prove)\nusing this:\n  xx ^ op dvd smult (of_nat op) (xx ^ (op - 1)) * pp + xx ^ op * pderiv pp\n\ngoal (1 subgoal):\n 1. xx ^ op dvd smult (of_nat op) (xx ^ (op - 1) * pp)", "by (simp add: dvd_add_left_iff)"], ["proof (state)\nthis:\n  xx ^ op dvd smult (of_nat op) (xx ^ (op - 1) * pp)\n\ngoal (1 subgoal):\n 1. xx ^ op dvd pderiv p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xx ^ op dvd smult (of_nat op) (xx ^ (op - 1) * pp)", "have \"xx ^ op dvd (xx^(op -1)) * pp\""], ["proof (prove)\nusing this:\n  xx ^ op dvd smult (of_nat op) (xx ^ (op - 1) * pp)\n\ngoal (1 subgoal):\n 1. xx ^ op dvd xx ^ (op - 1) * pp", "apply (elim dvd_monic[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. of_nat op \\<noteq> (0::'a)\n 2. lead_coeff (xx ^ op) = (1::'a)", "using \\<open>op\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  op \\<noteq> 0\n\ngoal (2 subgoals):\n 1. of_nat op \\<noteq> (0::'a)\n 2. lead_coeff (xx ^ op) = (1::'a)", "by (auto simp:lead_coeff_power xx_def)"], ["proof (state)\nthis:\n  xx ^ op dvd xx ^ (op - 1) * pp\n\ngoal (1 subgoal):\n 1. xx ^ op dvd pderiv p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xx ^ op dvd xx ^ (op - 1) * pp", "have \"xx ^ (op-1) * xx dvd (xx^(op -1))\""], ["proof (prove)\nusing this:\n  xx ^ op dvd xx ^ (op - 1) * pp\n\ngoal (1 subgoal):\n 1. xx ^ (op - 1) * xx dvd xx ^ (op - 1)", "using \\<open>\\<not> xx dvd pp\\<close>"], ["proof (prove)\nusing this:\n  xx ^ op dvd xx ^ (op - 1) * pp\n  \\<not> xx dvd pp\n\ngoal (1 subgoal):\n 1. xx ^ (op - 1) * xx dvd xx ^ (op - 1)", "by (simp add: \\<open>op \\<noteq> 0\\<close> mult.commute power_eq_if)"], ["proof (state)\nthis:\n  xx ^ (op - 1) * xx dvd xx ^ (op - 1)\n\ngoal (1 subgoal):\n 1. xx ^ op dvd pderiv p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xx ^ (op - 1) * xx dvd xx ^ (op - 1)", "have \"xx dvd 1\""], ["proof (prove)\nusing this:\n  xx ^ (op - 1) * xx dvd xx ^ (op - 1)\n\ngoal (1 subgoal):\n 1. xx dvd 1", "using assms(1) pp(1)"], ["proof (prove)\nusing this:\n  xx ^ (op - 1) * xx dvd xx ^ (op - 1)\n  p \\<noteq> 0\n  p = xx ^ op * pp\n\ngoal (1 subgoal):\n 1. xx dvd 1", "by auto"], ["proof (state)\nthis:\n  xx dvd 1\n\ngoal (1 subgoal):\n 1. xx ^ op dvd pderiv p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xx dvd 1", "show False"], ["proof (prove)\nusing this:\n  xx dvd 1\n\ngoal (1 subgoal):\n 1. False", "unfolding xx_def"], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd 1\n\ngoal (1 subgoal):\n 1. False", "by (meson assms(1) dvd_trans one_dvd order_decomp)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> xx ^ op dvd pderiv p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> order x p = Suc (order x (pderiv p))", "ultimately"], ["proof (chain)\npicking this:\n  xx ^ (op - 1) dvd pderiv p\n  \\<not> xx ^ op dvd pderiv p", "have \"op - 1 = order x (pderiv p)\""], ["proof (prove)\nusing this:\n  xx ^ (op - 1) dvd pderiv p\n  \\<not> xx ^ op dvd pderiv p\n\ngoal (1 subgoal):\n 1. op - 1 = order x (pderiv p)", "using order_unique_lemma[of x \"op-1\" \"pderiv p\",folded xx_def] \\<open>op\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  xx ^ (op - 1) dvd pderiv p\n  \\<not> xx ^ op dvd pderiv p\n  \\<lbrakk>xx ^ (op - 1) dvd pderiv p;\n   \\<not> xx ^ Suc (op - 1) dvd pderiv p\\<rbrakk>\n  \\<Longrightarrow> order x (pderiv p) = op - 1\n  op \\<noteq> 0\n\ngoal (1 subgoal):\n 1. op - 1 = order x (pderiv p)", "by auto"], ["proof (state)\nthis:\n  op - 1 = order x (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> order x p = Suc (order x (pderiv p))", "then"], ["proof (chain)\npicking this:\n  op - 1 = order x (pderiv p)", "show ?thesis"], ["proof (prove)\nusing this:\n  op - 1 = order x (pderiv p)\n\ngoal (1 subgoal):\n 1. order x p = Suc (order x (pderiv p))", "using \\<open>op\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  op - 1 = order x (pderiv p)\n  op \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x p = Suc (order x (pderiv p))", "unfolding op_def"], ["proof (prove)\nusing this:\n  order x p - 1 = order x (pderiv p)\n  order x p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x p = Suc (order x (pderiv p))", "by auto"], ["proof (state)\nthis:\n  order x p = Suc (order x (pderiv p))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>More about @{term rsquarefree}\\<close>"], ["", "lemma rsquarefree_0[simp]: \"\\<not> rsquarefree 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> rsquarefree 0", "unfolding rsquarefree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (0 \\<noteq> 0 \\<and>\n            (\\<forall>a. order a 0 = 0 \\<or> order a 0 = 1))", "by simp"], ["", "lemma rsquarefree_times:\n  assumes \"rsquarefree (p*q)\"\n  shows \"rsquarefree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree q", "using assms"], ["proof (prove)\nusing this:\n  rsquarefree (p * q)\n\ngoal (1 subgoal):\n 1. rsquarefree q", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. rsquarefree (0 * q) \\<Longrightarrow> rsquarefree q\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        rsquarefree (p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q\n 3. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "case 0"], ["proof (state)\nthis:\n  rsquarefree (0 * q)\n\ngoal (3 subgoals):\n 1. rsquarefree (0 * q) \\<Longrightarrow> rsquarefree q\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        rsquarefree (p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q\n 3. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "then"], ["proof (chain)\npicking this:\n  rsquarefree (0 * q)", "show ?case"], ["proof (prove)\nusing this:\n  rsquarefree (0 * q)\n\ngoal (1 subgoal):\n 1. rsquarefree q", "by simp"], ["proof (state)\nthis:\n  rsquarefree q\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        rsquarefree (p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q\n 2. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        rsquarefree (p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q\n 2. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> (0::'a)\n  rsquarefree (p * q)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        rsquarefree (p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q\n 2. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "then"], ["proof (chain)\npicking this:\n  poly p ?a \\<noteq> (0::'a)\n  rsquarefree (p * q)", "have [simp]:\"p\\<noteq>0\" \"q\\<noteq>0\" \"\\<And>a. order a p = 0\""], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  rsquarefree (p * q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0 &&& (\\<And>a. order a p = 0)", "using order_0I"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  rsquarefree (p * q)\n  poly ?p ?a \\<noteq> (0::?'a) \\<Longrightarrow> order ?a ?p = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0 &&& (\\<And>a. order a p = 0)", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  order ?a p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        rsquarefree (p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q\n 2. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "have \"order a (p * q) = 0 \\<longleftrightarrow> order a q = 0\"\n       \"order a (p * q) = 1 \\<longleftrightarrow> order a q = 1\"\n       for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (order a (p * q) = 0) = (order a q = 0) &&&\n    (order a (p * q) = 1) = (order a q = 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (order a (p * q) = 0) = (order a q = 0)", "by (subst order_mult) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (order a (p * q) = 1) = (order a q = 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (order a (p * q) = 1) = (order a q = 1)", "by (subst order_mult) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (order ?a (p * q) = 0) = (order ?a q = 0)\n  (order ?a (p * q) = 1) = (order ?a q = 1)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        rsquarefree (p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q\n 2. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "then"], ["proof (chain)\npicking this:\n  (order ?a (p * q) = 0) = (order ?a q = 0)\n  (order ?a (p * q) = 1) = (order ?a q = 1)", "show ?case"], ["proof (prove)\nusing this:\n  (order ?a (p * q) = 0) = (order ?a q = 0)\n  (order ?a (p * q) = 1) = (order ?a q = 1)\n\ngoal (1 subgoal):\n 1. rsquarefree q", "using \\<open>rsquarefree (p * q)\\<close>"], ["proof (prove)\nusing this:\n  (order ?a (p * q) = 0) = (order ?a q = 0)\n  (order ?a (p * q) = 1) = (order ?a q = 1)\n  rsquarefree (p * q)\n\ngoal (1 subgoal):\n 1. rsquarefree q", "unfolding rsquarefree_def"], ["proof (prove)\nusing this:\n  (order ?a (p * q) = 0) = (order ?a q = 0)\n  (order ?a (p * q) = 1) = (order ?a q = 1)\n  p * q \\<noteq> 0 \\<and>\n  (\\<forall>a. order a (p * q) = 0 \\<or> order a (p * q) = 1)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<and> (\\<forall>a. order a q = 0 \\<or> order a q = 1)", "by simp"], ["proof (state)\nthis:\n  rsquarefree q\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "case (root a p)"], ["proof (state)\nthis:\n  rsquarefree (p * q) \\<Longrightarrow> rsquarefree q\n  rsquarefree ([:- a, 1::'a:] * p * q)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "define pq aa where \"pq = p * q\" and \"aa = [:- a, 1:]\""], ["proof (state)\nthis:\n  pq = p * q\n  aa = [:- a, 1::'a:]\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "have [simp]:\"pq\\<noteq>0\" \"aa\\<noteq>0\" \"order a aa=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pq \\<noteq> 0 &&& aa \\<noteq> 0 &&& order a aa = 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pq \\<noteq> 0", "using pq_def root.prems"], ["proof (prove)\nusing this:\n  pq = p * q\n  rsquarefree ([:- a, 1::'a:] * p * q)\n\ngoal (1 subgoal):\n 1. pq \\<noteq> 0", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. aa \\<noteq> 0\n 2. order a aa = 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. aa \\<noteq> 0", "by (simp add: aa_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. order a aa = 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. order a aa = 1", "by (metis aa_def order_power_n_n power_one_right)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pq \\<noteq> 0\n  aa \\<noteq> 0\n  order a aa = 1\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "have \"rsquarefree (aa * pq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree (aa * pq)", "unfolding aa_def pq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree ([:- a, 1::'a:] * (p * q))", "using root(2)"], ["proof (prove)\nusing this:\n  rsquarefree ([:- a, 1::'a:] * p * q)\n\ngoal (1 subgoal):\n 1. rsquarefree ([:- a, 1::'a:] * (p * q))", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  rsquarefree (aa * pq)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "then"], ["proof (chain)\npicking this:\n  rsquarefree (aa * pq)", "have \"rsquarefree pq\""], ["proof (prove)\nusing this:\n  rsquarefree (aa * pq)\n\ngoal (1 subgoal):\n 1. rsquarefree pq", "unfolding rsquarefree_def"], ["proof (prove)\nusing this:\n  aa * pq \\<noteq> 0 \\<and>\n  (\\<forall>a. order a (aa * pq) = 0 \\<or> order a (aa * pq) = 1)\n\ngoal (1 subgoal):\n 1. pq \\<noteq> 0 \\<and> (\\<forall>a. order a pq = 0 \\<or> order a pq = 1)", "by (auto simp add:order_mult)"], ["proof (state)\nthis:\n  rsquarefree pq\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>rsquarefree (p * q) \\<Longrightarrow> rsquarefree q;\n        rsquarefree ([:- a, 1::'a:] * p * q)\\<rbrakk>\n       \\<Longrightarrow> rsquarefree q", "from root(1)[OF this[unfolded pq_def]]"], ["proof (chain)\npicking this:\n  rsquarefree q", "show ?case"], ["proof (prove)\nusing this:\n  rsquarefree q\n\ngoal (1 subgoal):\n 1. rsquarefree q", "."], ["proof (state)\nthis:\n  rsquarefree q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rsquarefree_smult_iff:\n  assumes \"s\\<noteq>0\"\n  shows \"rsquarefree (smult s p) \\<longleftrightarrow> rsquarefree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree (smult s p) = rsquarefree p", "unfolding rsquarefree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (smult s p \\<noteq> 0 \\<and>\n     (\\<forall>a. order a (smult s p) = 0 \\<or> order a (smult s p) = 1)) =\n    (p \\<noteq> 0 \\<and> (\\<forall>a. order a p = 0 \\<or> order a p = 1))", "using assms"], ["proof (prove)\nusing this:\n  s \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (smult s p \\<noteq> 0 \\<and>\n     (\\<forall>a. order a (smult s p) = 0 \\<or> order a (smult s p) = 1)) =\n    (p \\<noteq> 0 \\<and> (\\<forall>a. order a p = 0 \\<or> order a p = 1))", "by (auto simp add:order_smult)"], ["", "lemma card_proots_within_rsquarefree:\n  assumes \"rsquarefree p\"\n  shows \"proots_count p s = card (proots_within p s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p s = card (proots_within p s)", "using assms"], ["proof (prove)\nusing this:\n  rsquarefree p\n\ngoal (1 subgoal):\n 1. proots_count p s = card (proots_within p s)", "proof (induct rule:poly_root_induct[of _ \"\\<lambda>x. x\\<in>s\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. rsquarefree 0 \\<Longrightarrow>\n    proots_count 0 s = card (proots_within 0 s)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        rsquarefree p\\<rbrakk>\n       \\<Longrightarrow> proots_count p s = card (proots_within p s)\n 3. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "case 0"], ["proof (state)\nthis:\n  rsquarefree 0\n\ngoal (3 subgoals):\n 1. rsquarefree 0 \\<Longrightarrow>\n    proots_count 0 s = card (proots_within 0 s)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        rsquarefree p\\<rbrakk>\n       \\<Longrightarrow> proots_count p s = card (proots_within p s)\n 3. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "then"], ["proof (chain)\npicking this:\n  rsquarefree 0", "have False"], ["proof (prove)\nusing this:\n  rsquarefree 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. rsquarefree 0 \\<Longrightarrow>\n    proots_count 0 s = card (proots_within 0 s)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        rsquarefree p\\<rbrakk>\n       \\<Longrightarrow> proots_count p s = card (proots_within p s)\n 3. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "then"], ["proof (chain)\npicking this:\n  False", "show ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. proots_count 0 s = card (proots_within 0 s)", "by simp"], ["proof (state)\nthis:\n  proots_count 0 s = card (proots_within 0 s)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        rsquarefree p\\<rbrakk>\n       \\<Longrightarrow> proots_count p s = card (proots_within p s)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        rsquarefree p\\<rbrakk>\n       \\<Longrightarrow> proots_count p s = card (proots_within p s)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "case (no_roots p)"], ["proof (state)\nthis:\n  ?a \\<in> s \\<Longrightarrow> poly p ?a \\<noteq> (0::'a)\n  rsquarefree p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        rsquarefree p\\<rbrakk>\n       \\<Longrightarrow> proots_count p s = card (proots_within p s)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "then"], ["proof (chain)\npicking this:\n  ?a \\<in> s \\<Longrightarrow> poly p ?a \\<noteq> (0::'a)\n  rsquarefree p", "show ?case"], ["proof (prove)\nusing this:\n  ?a \\<in> s \\<Longrightarrow> poly p ?a \\<noteq> (0::'a)\n  rsquarefree p\n\ngoal (1 subgoal):\n 1. proots_count p s = card (proots_within p s)", "by (metis all_not_in_conv card.empty proots_count_def proots_within_iff sum.empty)"], ["proof (state)\nthis:\n  proots_count p s = card (proots_within p s)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "case (root a p)"], ["proof (state)\nthis:\n  a \\<in> s\n  rsquarefree p \\<Longrightarrow>\n  proots_count p s = card (proots_within p s)\n  rsquarefree ([:a, - (1::'a):] * p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "have \"proots_count ([:a, - 1:] * p) s = 1 + proots_count p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count ([:a, - (1::'a):] * p) s = 1 + proots_count p s", "apply (subst proots_count_times)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p \\<noteq> 0\n 2. proots_count [:a, - (1::'a):] s + proots_count p s =\n    1 + proots_count p s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:a, - (1::'a):] * p \\<noteq> 0", "using root.prems rsquarefree_def"], ["proof (prove)\nusing this:\n  rsquarefree ([:a, - (1::'a):] * p)\n  rsquarefree ?p =\n  (?p \\<noteq> 0 \\<and> (\\<forall>a. order a ?p = 0 \\<or> order a ?p = 1))\n\ngoal (1 subgoal):\n 1. [:a, - (1::'a):] * p \\<noteq> 0", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count [:a, - (1::'a):] s + proots_count p s =\n    1 + proots_count p s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count [:a, - (1::'a):] s + proots_count p s =\n    1 + proots_count p s", "by (metis (no_types, hide_lams) add.inverse_inverse add.inverse_neutral \n                  minus_pCons proots_count_pCons_1_iff proots_count_uminus root.hyps(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  proots_count ([:a, - (1::'a):] * p) s = 1 + proots_count p s\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "also"], ["proof (state)\nthis:\n  proots_count ([:a, - (1::'a):] * p) s = 1 + proots_count p s\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "have \"... = 1 + card (proots_within p s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + proots_count p s = 1 + card (proots_within p s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 + proots_count p s = 1 + card (proots_within p s)", "have \"rsquarefree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree p", "using \\<open>rsquarefree ([:a, - 1:] * p)\\<close>"], ["proof (prove)\nusing this:\n  rsquarefree ([:a, - (1::'a):] * p)\n\ngoal (1 subgoal):\n 1. rsquarefree p", "by (elim rsquarefree_times)"], ["proof (state)\nthis:\n  rsquarefree p\n\ngoal (1 subgoal):\n 1. 1 + proots_count p s = 1 + card (proots_within p s)", "from root(2)[OF this]"], ["proof (chain)\npicking this:\n  proots_count p s = card (proots_within p s)", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count p s = card (proots_within p s)\n\ngoal (1 subgoal):\n 1. 1 + proots_count p s = 1 + card (proots_within p s)", "by simp"], ["proof (state)\nthis:\n  1 + proots_count p s = 1 + card (proots_within p s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 + proots_count p s = 1 + card (proots_within p s)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "also"], ["proof (state)\nthis:\n  1 + proots_count p s = 1 + card (proots_within p s)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "have \"... = card (proots_within ([:a, - 1:] * p) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + card (proots_within p s) =\n    card (proots_within ([:a, - (1::'a):] * p) s)", "unfolding proots_within_times"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + card (proots_within p s) =\n    card (proots_within [:a, - (1::'a):] s \\<union> proots_within p s)", "proof (subst card_Un_disjoint)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (proots_within [:a, - (1::'a):] s)\n 2. finite (proots_within p s)\n 3. proots_within [:a, - (1::'a):] s \\<inter> proots_within p s = {}\n 4. 1 + card (proots_within p s) =\n    card (proots_within [:a, - (1::'a):] s) + card (proots_within p s)", "have [simp]:\"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using root.prems"], ["proof (prove)\nusing this:\n  rsquarefree ([:a, - (1::'a):] * p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (4 subgoals):\n 1. finite (proots_within [:a, - (1::'a):] s)\n 2. finite (proots_within p s)\n 3. proots_within [:a, - (1::'a):] s \\<inter> proots_within p s = {}\n 4. 1 + card (proots_within p s) =\n    card (proots_within [:a, - (1::'a):] s) + card (proots_within p s)", "show \"finite (proots_within [:a, - 1:] s)\" \"finite (proots_within p s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within [:a, - (1::'a):] s) &&& finite (proots_within p s)", "by auto"], ["proof (state)\nthis:\n  finite (proots_within [:a, - (1::'a):] s)\n  finite (proots_within p s)\n\ngoal (2 subgoals):\n 1. proots_within [:a, - (1::'a):] s \\<inter> proots_within p s = {}\n 2. 1 + card (proots_within p s) =\n    card (proots_within [:a, - (1::'a):] s) + card (proots_within p s)", "show \" 1 + card (proots_within p s) = card (proots_within [:a, - 1:] s)\n               + card (proots_within p s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + card (proots_within p s) =\n    card (proots_within [:a, - (1::'a):] s) + card (proots_within p s)", "using \\<open>a \\<in> s\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> s\n\ngoal (1 subgoal):\n 1. 1 + card (proots_within p s) =\n    card (proots_within [:a, - (1::'a):] s) + card (proots_within p s)", "apply (subst proots_within_pCons_1_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> s \\<Longrightarrow>\n    1 + card (proots_within p s) =\n    card (if a \\<in> s then {a} else {}) + card (proots_within p s)", "by simp"], ["proof (state)\nthis:\n  1 + card (proots_within p s) =\n  card (proots_within [:a, - (1::'a):] s) + card (proots_within p s)\n\ngoal (1 subgoal):\n 1. proots_within [:a, - (1::'a):] s \\<inter> proots_within p s = {}", "have \"poly p a\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p a \\<noteq> (0::'a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> poly p a \\<noteq> (0::'a) \\<Longrightarrow> False", "assume \"\\<not> poly p a \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> poly p a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> poly p a \\<noteq> (0::'a) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> poly p a \\<noteq> (0::'a)", "have \"order a p >0\""], ["proof (prove)\nusing this:\n  \\<not> poly p a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < order a p", "by (simp add: order_root)"], ["proof (state)\nthis:\n  0 < order a p\n\ngoal (1 subgoal):\n 1. \\<not> poly p a \\<noteq> (0::'a) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  0 < order a p\n\ngoal (1 subgoal):\n 1. \\<not> poly p a \\<noteq> (0::'a) \\<Longrightarrow> False", "have \"order a [:a,-1:] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a [:a, - (1::'a):] = 1", "by (metis (no_types, hide_lams) add.inverse_inverse add.inverse_neutral minus_pCons \n            order_power_n_n order_uminus power_one_right)"], ["proof (state)\nthis:\n  order a [:a, - (1::'a):] = 1\n\ngoal (1 subgoal):\n 1. \\<not> poly p a \\<noteq> (0::'a) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  0 < order a p\n  order a [:a, - (1::'a):] = 1", "have \"order a  ([:a, - 1:] * p) > 1\""], ["proof (prove)\nusing this:\n  0 < order a p\n  order a [:a, - (1::'a):] = 1\n\ngoal (1 subgoal):\n 1. 1 < order a ([:a, - (1::'a):] * p)", "apply (subst order_mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < order a p; order a [:a, - (1::'a):] = 1\\<rbrakk>\n    \\<Longrightarrow> [:a, - (1::'a):] * p \\<noteq> 0\n 2. \\<lbrakk>0 < order a p; order a [:a, - (1::'a):] = 1\\<rbrakk>\n    \\<Longrightarrow> 1 < order a [:a, - (1::'a):] + order a p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < order a p; order a [:a, - (1::'a):] = 1\\<rbrakk>\n    \\<Longrightarrow> [:a, - (1::'a):] * p \\<noteq> 0", "using root.prems"], ["proof (prove)\nusing this:\n  rsquarefree ([:a, - (1::'a):] * p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < order a p; order a [:a, - (1::'a):] = 1\\<rbrakk>\n    \\<Longrightarrow> [:a, - (1::'a):] * p \\<noteq> 0", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < order a p; order a [:a, - (1::'a):] = 1\\<rbrakk>\n    \\<Longrightarrow> 1 < order a [:a, - (1::'a):] + order a p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < order a p; order a [:a, - (1::'a):] = 1\\<rbrakk>\n    \\<Longrightarrow> 1 < order a [:a, - (1::'a):] + order a p", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  1 < order a ([:a, - (1::'a):] * p)\n\ngoal (1 subgoal):\n 1. \\<not> poly p a \\<noteq> (0::'a) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  1 < order a ([:a, - (1::'a):] * p)", "show False"], ["proof (prove)\nusing this:\n  1 < order a ([:a, - (1::'a):] * p)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>rsquarefree ([:a, - 1:] * p)\\<close>"], ["proof (prove)\nusing this:\n  1 < order a ([:a, - (1::'a):] * p)\n  rsquarefree ([:a, - (1::'a):] * p)\n\ngoal (1 subgoal):\n 1. False", "unfolding rsquarefree_def"], ["proof (prove)\nusing this:\n  1 < order a ([:a, - (1::'a):] * p)\n  [:a, - (1::'a):] * p \\<noteq> 0 \\<and>\n  (\\<forall>aa.\n      order aa ([:a, - (1::'a):] * p) = 0 \\<or>\n      order aa ([:a, - (1::'a):] * p) = 1)\n\ngoal (1 subgoal):\n 1. False", "using gr_implies_not0 less_not_refl2"], ["proof (prove)\nusing this:\n  1 < order a ([:a, - (1::'a):] * p)\n  [:a, - (1::'a):] * p \\<noteq> 0 \\<and>\n  (\\<forall>aa.\n      order aa ([:a, - (1::'a):] * p) = 0 \\<or>\n      order aa ([:a, - (1::'a):] * p) = 1)\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> 0\n  ?n < ?m \\<Longrightarrow> ?m \\<noteq> ?n\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within [:a, - (1::'a):] s \\<inter> proots_within p s = {}", "then"], ["proof (chain)\npicking this:\n  poly p a \\<noteq> (0::'a)", "show \" proots_within [:a, - 1:] s \\<inter> proots_within p s = {}\""], ["proof (prove)\nusing this:\n  poly p a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within [:a, - (1::'a):] s \\<inter> proots_within p s = {}", "using proots_within_pCons_1_iff(2)"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> (0::'a)\n  proots_within [:?a, - (1::?'a):] ?s = (if ?a \\<in> ?s then {?a} else {})\n\ngoal (1 subgoal):\n 1. proots_within [:a, - (1::'a):] s \\<inter> proots_within p s = {}", "by auto"], ["proof (state)\nthis:\n  proots_within [:a, - (1::'a):] s \\<inter> proots_within p s = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 + card (proots_within p s) =\n  card (proots_within ([:a, - (1::'a):] * p) s)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        rsquarefree p \\<Longrightarrow>\n        proots_count p s = card (proots_within p s);\n        rsquarefree ([:a, - (1::'a):] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s =\n                         card (proots_within ([:a, - (1::'a):] * p) s)", "finally"], ["proof (chain)\npicking this:\n  proots_count ([:a, - (1::'a):] * p) s =\n  card (proots_within ([:a, - (1::'a):] * p) s)", "show ?case"], ["proof (prove)\nusing this:\n  proots_count ([:a, - (1::'a):] * p) s =\n  card (proots_within ([:a, - (1::'a):] * p) s)\n\ngoal (1 subgoal):\n 1. proots_count ([:a, - (1::'a):] * p) s =\n    card (proots_within ([:a, - (1::'a):] * p) s)", "."], ["proof (state)\nthis:\n  proots_count ([:a, - (1::'a):] * p) s =\n  card (proots_within ([:a, - (1::'a):] * p) s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rsquarefree_gcd_pderiv:\n  fixes p::\"'a::{factorial_ring_gcd,semiring_gcd_mult_normalize,semiring_char_0} poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"rsquarefree (p div (gcd p (pderiv p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree (p div gcd p (pderiv p))", "proof (cases \"pderiv p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pderiv p = 0 \\<Longrightarrow> rsquarefree (p div gcd p (pderiv p))\n 2. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    rsquarefree (p div gcd p (pderiv p))", "case True"], ["proof (state)\nthis:\n  pderiv p = 0\n\ngoal (2 subgoals):\n 1. pderiv p = 0 \\<Longrightarrow> rsquarefree (p div gcd p (pderiv p))\n 2. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    rsquarefree (p div gcd p (pderiv p))", "have \"poly (unit_factor p) x \\<noteq>0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (unit_factor p) x \\<noteq> (0::'a)", "using unit_factor_is_unit[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  is_unit (unit_factor p)\n\ngoal (1 subgoal):\n 1. poly (unit_factor p) x \\<noteq> (0::'a)", "by (meson assms dvd_trans order_decomp poly_eq_0_iff_dvd unit_factor_dvd)"], ["proof (state)\nthis:\n  poly (unit_factor p) ?x \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. pderiv p = 0 \\<Longrightarrow> rsquarefree (p div gcd p (pderiv p))\n 2. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    rsquarefree (p div gcd p (pderiv p))", "then"], ["proof (chain)\npicking this:\n  poly (unit_factor p) ?x \\<noteq> (0::'a)", "have \"order x (unit_factor p) = 0\" for x"], ["proof (prove)\nusing this:\n  poly (unit_factor p) ?x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. order x (unit_factor p) = 0", "using order_0I"], ["proof (prove)\nusing this:\n  poly (unit_factor p) ?x \\<noteq> (0::'a)\n  poly ?p ?a \\<noteq> (0::?'a) \\<Longrightarrow> order ?a ?p = 0\n\ngoal (1 subgoal):\n 1. order x (unit_factor p) = 0", "by blast"], ["proof (state)\nthis:\n  order ?x (unit_factor p) = 0\n\ngoal (2 subgoals):\n 1. pderiv p = 0 \\<Longrightarrow> rsquarefree (p div gcd p (pderiv p))\n 2. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    rsquarefree (p div gcd p (pderiv p))", "then"], ["proof (chain)\npicking this:\n  order ?x (unit_factor p) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  order ?x (unit_factor p) = 0\n\ngoal (1 subgoal):\n 1. rsquarefree (p div gcd p (pderiv p))", "using True \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  order ?x (unit_factor p) = 0\n  pderiv p = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rsquarefree (p div gcd p (pderiv p))", "unfolding rsquarefree_def"], ["proof (prove)\nusing this:\n  order ?x (unit_factor p) = 0\n  pderiv p = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p div gcd p (pderiv p) \\<noteq> 0 \\<and>\n    (\\<forall>a.\n        order a (p div gcd p (pderiv p)) = 0 \\<or>\n        order a (p div gcd p (pderiv p)) = 1)", "by simp"], ["proof (state)\nthis:\n  rsquarefree (p div gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    rsquarefree (p div gcd p (pderiv p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    rsquarefree (p div gcd p (pderiv p))", "case False"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    rsquarefree (p div gcd p (pderiv p))", "define q where \"q = p div (gcd p (pderiv p))\""], ["proof (state)\nthis:\n  q = p div gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    rsquarefree (p div gcd p (pderiv p))", "have \"q\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p div gcd p (pderiv p) \\<noteq> 0", "by (simp add: assms dvd_div_eq_0_iff)"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    rsquarefree (p div gcd p (pderiv p))", "have order_pq:\"order x p = order x q + min (order x p) (order x (pderiv p))\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = order x q + min (order x p) (order x (pderiv p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order x p = order x q + min (order x p) (order x (pderiv p))", "have *:\"p = q * gcd p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q * gcd p (pderiv p)", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p div gcd p (pderiv p) * gcd p (pderiv p)", "by simp"], ["proof (state)\nthis:\n  p = q * gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. order x p = order x q + min (order x p) (order x (pderiv p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = order x q + min (order x p) (order x (pderiv p))", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (q * gcd p (pderiv p)) =\n    order x q + min (order x p) (order x (pderiv p))", "using \\<open>q\\<noteq>0\\<close> \\<open>p\\<noteq>0\\<close> \\<open>pderiv p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  p \\<noteq> 0\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x (q * gcd p (pderiv p)) =\n    order x q + min (order x p) (order x (pderiv p))", "by (simp add:order_mult order_gcd)"], ["proof (state)\nthis:\n  order x p = order x q + min (order x p) (order x (pderiv p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order ?x p = order ?x q + min (order ?x p) (order ?x (pderiv p))\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    rsquarefree (p div gcd p (pderiv p))", "have \"order x q = 0 \\<or> order x q=1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x q = 0 \\<or> order x q = 1", "proof (cases \"poly p x=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly p x = (0::'a) \\<Longrightarrow> order x q = 0 \\<or> order x q = 1\n 2. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x q = 0 \\<or> order x q = 1", "case True"], ["proof (state)\nthis:\n  poly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. poly p x = (0::'a) \\<Longrightarrow> order x q = 0 \\<or> order x q = 1\n 2. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x q = 0 \\<or> order x q = 1", "from order_pderiv[OF \\<open>p\\<noteq>0\\<close> this]"], ["proof (chain)\npicking this:\n  order x p = Suc (order x (pderiv p))", "have \"order x p = order x (pderiv p) + 1\""], ["proof (prove)\nusing this:\n  order x p = Suc (order x (pderiv p))\n\ngoal (1 subgoal):\n 1. order x p = order x (pderiv p) + 1", "by simp"], ["proof (state)\nthis:\n  order x p = order x (pderiv p) + 1\n\ngoal (2 subgoals):\n 1. poly p x = (0::'a) \\<Longrightarrow> order x q = 0 \\<or> order x q = 1\n 2. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x q = 0 \\<or> order x q = 1", "then"], ["proof (chain)\npicking this:\n  order x p = order x (pderiv p) + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  order x p = order x (pderiv p) + 1\n\ngoal (1 subgoal):\n 1. order x q = 0 \\<or> order x q = 1", "using order_pq[of x]"], ["proof (prove)\nusing this:\n  order x p = order x (pderiv p) + 1\n  order x p = order x q + min (order x p) (order x (pderiv p))\n\ngoal (1 subgoal):\n 1. order x q = 0 \\<or> order x q = 1", "by auto"], ["proof (state)\nthis:\n  order x q = 0 \\<or> order x q = 1\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x q = 0 \\<or> order x q = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x q = 0 \\<or> order x q = 1", "case False"], ["proof (state)\nthis:\n  poly p x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x q = 0 \\<or> order x q = 1", "then"], ["proof (chain)\npicking this:\n  poly p x \\<noteq> (0::'a)", "have \"order x p = 0\""], ["proof (prove)\nusing this:\n  poly p x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. order x p = 0", "by (simp add: order_0I)"], ["proof (state)\nthis:\n  order x p = 0\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x q = 0 \\<or> order x q = 1", "then"], ["proof (chain)\npicking this:\n  order x p = 0", "have \"order x q = 0\""], ["proof (prove)\nusing this:\n  order x p = 0\n\ngoal (1 subgoal):\n 1. order x q = 0", "using order_pq[of x]"], ["proof (prove)\nusing this:\n  order x p = 0\n  order x p = order x q + min (order x p) (order x (pderiv p))\n\ngoal (1 subgoal):\n 1. order x q = 0", "by simp"], ["proof (state)\nthis:\n  order x q = 0\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    order x q = 0 \\<or> order x q = 1", "then"], ["proof (chain)\npicking this:\n  order x q = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  order x q = 0\n\ngoal (1 subgoal):\n 1. order x q = 0 \\<or> order x q = 1", "by simp"], ["proof (state)\nthis:\n  order x q = 0 \\<or> order x q = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order ?x q = 0 \\<or> order ?x q = 1\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    rsquarefree (p div gcd p (pderiv p))", "then"], ["proof (chain)\npicking this:\n  order ?x q = 0 \\<or> order ?x q = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  order ?x q = 0 \\<or> order ?x q = 1\n\ngoal (1 subgoal):\n 1. rsquarefree (p div gcd p (pderiv p))", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  order ?x q = 0 \\<or> order ?x q = 1\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rsquarefree (p div gcd p (pderiv p))", "unfolding rsquarefree_def q_def"], ["proof (prove)\nusing this:\n  order ?x (p div gcd p (pderiv p)) = 0 \\<or>\n  order ?x (p div gcd p (pderiv p)) = 1\n  p div gcd p (pderiv p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p div gcd p (pderiv p) \\<noteq> 0 \\<and>\n    (\\<forall>a.\n        order a (p div gcd p (pderiv p)) = 0 \\<or>\n        order a (p div gcd p (pderiv p)) = 1)", "by auto"], ["proof (state)\nthis:\n  rsquarefree (p div gcd p (pderiv p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_gcd_pderiv_iff:\n  fixes p::\"'a::{semiring_char_0,factorial_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  shows \"poly (p div (gcd p (pderiv p))) x =0 \\<longleftrightarrow> poly p x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "proof (cases \"pderiv p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pderiv p = 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))\n 2. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "case True"], ["proof (state)\nthis:\n  pderiv p = 0\n\ngoal (2 subgoals):\n 1. pderiv p = 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))\n 2. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "then"], ["proof (chain)\npicking this:\n  pderiv p = 0", "obtain a where \"p=[:a:]\""], ["proof (prove)\nusing this:\n  pderiv p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>a. p = [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using pderiv_iszero"], ["proof (prove)\nusing this:\n  pderiv p = 0\n  pderiv ?p = 0 \\<Longrightarrow> \\<exists>h. ?p = [:h:]\n\ngoal (1 subgoal):\n 1. (\\<And>a. p = [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = [:a:]\n\ngoal (2 subgoals):\n 1. pderiv p = 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))\n 2. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "then"], ["proof (chain)\npicking this:\n  p = [:a:]", "show ?thesis"], ["proof (prove)\nusing this:\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "by (auto simp add: unit_factor_poly_def)"], ["proof (state)\nthis:\n  (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "case False"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "then"], ["proof (chain)\npicking this:\n  pderiv p \\<noteq> 0", "have \"p\\<noteq>0\""], ["proof (prove)\nusing this:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using pderiv_0"], ["proof (prove)\nusing this:\n  pderiv p \\<noteq> 0\n  pderiv 0 = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "define q where \"q = p div (gcd p (pderiv p))\""], ["proof (state)\nthis:\n  q = p div gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "have \"q\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p div gcd p (pderiv p) \\<noteq> 0", "by (simp add: \\<open>p\\<noteq>0\\<close> dvd_div_eq_0_iff)"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "have order_pq:\"order x p = order x q + min (order x p) (order x (pderiv p))\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = order x q + min (order x p) (order x (pderiv p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order x p = order x q + min (order x p) (order x (pderiv p))", "have *:\"p = q * gcd p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q * gcd p (pderiv p)", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p div gcd p (pderiv p) * gcd p (pderiv p)", "by simp"], ["proof (state)\nthis:\n  p = q * gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. order x p = order x q + min (order x p) (order x (pderiv p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = order x q + min (order x p) (order x (pderiv p))", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (q * gcd p (pderiv p)) =\n    order x q + min (order x p) (order x (pderiv p))", "using \\<open>q\\<noteq>0\\<close> \\<open>p\\<noteq>0\\<close> \\<open>pderiv p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  p \\<noteq> 0\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x (q * gcd p (pderiv p)) =\n    order x q + min (order x p) (order x (pderiv p))", "by (simp add:order_mult order_gcd)"], ["proof (state)\nthis:\n  order x p = order x q + min (order x p) (order x (pderiv p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order ?x p = order ?x q + min (order ?x p) (order ?x (pderiv p))\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "have \"order x q =0 \\<longleftrightarrow> order x p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (order x q = 0) = (order x p = 0)", "proof (cases \"poly p x=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly p x = (0::'a) \\<Longrightarrow> (order x q = 0) = (order x p = 0)\n 2. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    (order x q = 0) = (order x p = 0)", "case True"], ["proof (state)\nthis:\n  poly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. poly p x = (0::'a) \\<Longrightarrow> (order x q = 0) = (order x p = 0)\n 2. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    (order x q = 0) = (order x p = 0)", "from order_pderiv[OF \\<open>p\\<noteq>0\\<close> this]"], ["proof (chain)\npicking this:\n  order x p = Suc (order x (pderiv p))", "have \"order x p = order x (pderiv p) + 1\""], ["proof (prove)\nusing this:\n  order x p = Suc (order x (pderiv p))\n\ngoal (1 subgoal):\n 1. order x p = order x (pderiv p) + 1", "by simp"], ["proof (state)\nthis:\n  order x p = order x (pderiv p) + 1\n\ngoal (2 subgoals):\n 1. poly p x = (0::'a) \\<Longrightarrow> (order x q = 0) = (order x p = 0)\n 2. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    (order x q = 0) = (order x p = 0)", "then"], ["proof (chain)\npicking this:\n  order x p = order x (pderiv p) + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  order x p = order x (pderiv p) + 1\n\ngoal (1 subgoal):\n 1. (order x q = 0) = (order x p = 0)", "using order_pq[of x]"], ["proof (prove)\nusing this:\n  order x p = order x (pderiv p) + 1\n  order x p = order x q + min (order x p) (order x (pderiv p))\n\ngoal (1 subgoal):\n 1. (order x q = 0) = (order x p = 0)", "by auto"], ["proof (state)\nthis:\n  (order x q = 0) = (order x p = 0)\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    (order x q = 0) = (order x p = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    (order x q = 0) = (order x p = 0)", "case False"], ["proof (state)\nthis:\n  poly p x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    (order x q = 0) = (order x p = 0)", "then"], ["proof (chain)\npicking this:\n  poly p x \\<noteq> (0::'a)", "have \"order x p = 0\""], ["proof (prove)\nusing this:\n  poly p x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. order x p = 0", "by (simp add: order_0I)"], ["proof (state)\nthis:\n  order x p = 0\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    (order x q = 0) = (order x p = 0)", "then"], ["proof (chain)\npicking this:\n  order x p = 0", "have \"order x q = 0\""], ["proof (prove)\nusing this:\n  order x p = 0\n\ngoal (1 subgoal):\n 1. order x q = 0", "using order_pq[of x]"], ["proof (prove)\nusing this:\n  order x p = 0\n  order x p = order x q + min (order x p) (order x (pderiv p))\n\ngoal (1 subgoal):\n 1. order x q = 0", "by simp"], ["proof (state)\nthis:\n  order x q = 0\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<Longrightarrow>\n    (order x q = 0) = (order x p = 0)", "then"], ["proof (chain)\npicking this:\n  order x q = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  order x q = 0\n\ngoal (1 subgoal):\n 1. (order x q = 0) = (order x p = 0)", "using \\<open>order x p = 0\\<close>"], ["proof (prove)\nusing this:\n  order x q = 0\n  order x p = 0\n\ngoal (1 subgoal):\n 1. (order x q = 0) = (order x p = 0)", "by simp"], ["proof (state)\nthis:\n  (order x q = 0) = (order x p = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (order x q = 0) = (order x p = 0)\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 \\<Longrightarrow>\n    (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "then"], ["proof (chain)\npicking this:\n  (order x q = 0) = (order x p = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (order x q = 0) = (order x p = 0)\n\ngoal (1 subgoal):\n 1. (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))", "apply (fold q_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (order x q = 0) = (order x p = 0) \\<Longrightarrow>\n    (poly q x = (0::'a)) = (poly p x = (0::'a))", "unfolding order_root"], ["proof (prove)\ngoal (1 subgoal):\n 1. (order x q = 0) = (order x p = 0) \\<Longrightarrow>\n    (q = 0 \\<or> order x q \\<noteq> 0) = (p = 0 \\<or> order x p \\<noteq> 0)", "using \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (order x q = 0) = (order x p = 0) \\<Longrightarrow>\n    (q = 0 \\<or> order x q \\<noteq> 0) = (p = 0 \\<or> order x p \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  (poly (p div gcd p (pderiv p)) x = (0::'a)) = (poly p x = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Composition of a polynomial and a circular path\\<close>"], ["", "lemma poly_circlepath_tan_eq:\n  fixes z0::complex and r::real and p::\"complex poly\"\n  defines \"q1\\<equiv> fcompose p [:(z0+r)*\\<i>,z0-r:] [:\\<i>,1:]\" and \"q2 \\<equiv> [:\\<i>,1:] ^ degree p\"\n  assumes \"0\\<le>t\" \"t\\<le>1\" \"t\\<noteq>1/2\"\n  shows \"poly p (circlepath z0 r t) = poly q1 (tan (pi*t)) / poly q2 (tan (pi*t))\" \n    (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (circlepath z0 r t) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p (circlepath z0 r t) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "have \"?L = poly p (z0+ r*exp (2 * of_real pi * \\<i>  * t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (circlepath z0 r t) =\n    poly p\n     (z0 +\n      complex_of_real r *\n      exp (2 * complex_of_real pi * \\<i> * complex_of_real t))", "unfolding circlepath"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      exp (2 * complex_of_real pi * \\<i> * complex_of_real t)) =\n    poly p\n     (z0 +\n      complex_of_real r *\n      exp (2 * complex_of_real pi * \\<i> * complex_of_real t))", "by simp"], ["proof (state)\nthis:\n  poly p (circlepath z0 r t) =\n  poly p\n   (z0 +\n    complex_of_real r *\n    exp (2 * complex_of_real pi * \\<i> * complex_of_real t))\n\ngoal (1 subgoal):\n 1. poly p (circlepath z0 r t) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "also"], ["proof (state)\nthis:\n  poly p (circlepath z0 r t) =\n  poly p\n   (z0 +\n    complex_of_real r *\n    exp (2 * complex_of_real pi * \\<i> * complex_of_real t))\n\ngoal (1 subgoal):\n 1. poly p (circlepath z0 r t) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "have \"... = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      exp (2 * complex_of_real pi * \\<i> * complex_of_real t)) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      exp (2 * complex_of_real pi * \\<i> * complex_of_real t)) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "define f where \"f = (poly p \\<circ> (\\<lambda>x::real. z0 + r * exp (\\<i> * x)))\""], ["proof (state)\nthis:\n  f =\n  poly p \\<circ>\n  (\\<lambda>x. z0 + complex_of_real r * exp (\\<i> * complex_of_real x))\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      exp (2 * complex_of_real pi * \\<i> * complex_of_real t)) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "have f_eq:\"f t = ((\\<lambda>x::real. poly q1 x / poly q2 x) o  (\\<lambda>x. tan (x/2)) ) t\" \n      when \"cos (t / 2) \\<noteq> 0\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. f t =\n    ((\\<lambda>x.\n         poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f t =\n    ((\\<lambda>x.\n         poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "have \"f t = poly p (z0 + r * (cos t + \\<i> * sin t)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. f t =\n    poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)))", "unfolding f_def exp_Euler"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p \\<circ>\n     (\\<lambda>x.\n         z0 +\n         complex_of_real r *\n         (cos (complex_of_real x) + \\<i> * sin (complex_of_real x))))\n     t =\n    poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)))", "by (auto simp add:cos_of_real sin_of_real)"], ["proof (state)\nthis:\n  f t =\n  poly p\n   (z0 +\n    complex_of_real r *\n    (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)))\n\ngoal (1 subgoal):\n 1. f t =\n    ((\\<lambda>x.\n         poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "also"], ["proof (state)\nthis:\n  f t =\n  poly p\n   (z0 +\n    complex_of_real r *\n    (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)))\n\ngoal (1 subgoal):\n 1. f t =\n    ((\\<lambda>x.\n         poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "have \"... = poly p ((\\<lambda>x. ((z0-r)*x+(z0+r)*\\<i>) / (\\<i>+x)) (tan (t/2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "define tt where \"tt=complex_of_real (tan (t / 2))\""], ["proof (state)\nthis:\n  tt = complex_of_real (tan (t / 2))\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "define rr where \"rr = complex_of_real r\""], ["proof (state)\nthis:\n  rr = complex_of_real r\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "have \"cos t = (1-tt*tt) / (1 + tt * tt)\" \n             \"sin t = 2*tt  / (1 + tt * tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (cos t) = (1 - tt * tt) / (1 + tt * tt) &&&\n    complex_of_real (sin t) = 2 * tt / (1 + tt * tt)", "unfolding sin_tan_half[of \"t/2\",simplified] cos_tan_half[of \"t/2\",OF that, simplified] tt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real\n     ((1 - (tan (t / 2))\\<^sup>2) / (1 + (tan (t / 2))\\<^sup>2)) =\n    (1 - complex_of_real (tan (t / 2)) * complex_of_real (tan (t / 2))) /\n    (1 + complex_of_real (tan (t / 2)) * complex_of_real (tan (t / 2))) &&&\n    complex_of_real (2 * tan (t / 2) / (1 + (tan (t / 2))\\<^sup>2)) =\n    2 * complex_of_real (tan (t / 2)) /\n    (1 + complex_of_real (tan (t / 2)) * complex_of_real (tan (t / 2)))", "by (auto simp add:power2_eq_square)"], ["proof (state)\nthis:\n  complex_of_real (cos t) = (1 - tt * tt) / (1 + tt * tt)\n  complex_of_real (sin t) = 2 * tt / (1 + tt * tt)\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "moreover"], ["proof (state)\nthis:\n  complex_of_real (cos t) = (1 - tt * tt) / (1 + tt * tt)\n  complex_of_real (sin t) = 2 * tt / (1 + tt * tt)\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "have \"1 + tt * tt \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + tt * tt \\<noteq> 0", "unfolding tt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 +\n    complex_of_real (tan (t / 2)) * complex_of_real (tan (t / 2)) \\<noteq>\n    0", "apply (fold of_real_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + complex_of_real (tan (t / 2) * tan (t / 2)) \\<noteq> 0", "by (metis (no_types, hide_lams) mult_numeral_1 numeral_One of_real_add of_real_eq_0_iff\n              of_real_numeral sum_squares_eq_zero_iff zero_neq_one)"], ["proof (state)\nthis:\n  1 + tt * tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "ultimately"], ["proof (chain)\npicking this:\n  complex_of_real (cos t) = (1 - tt * tt) / (1 + tt * tt)\n  complex_of_real (sin t) = 2 * tt / (1 + tt * tt)\n  1 + tt * tt \\<noteq> 0", "have \"z0 +  r * ( (cos t) + \\<i> * (sin t))\n            =(z0*(1+tt*tt)+rr*(1-tt*tt)+\\<i>*rr*2*tt ) / (1 + tt * tt) \""], ["proof (prove)\nusing this:\n  complex_of_real (cos t) = (1 - tt * tt) / (1 + tt * tt)\n  complex_of_real (sin t) = 2 * tt / (1 + tt * tt)\n  1 + tt * tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z0 +\n    complex_of_real r *\n    (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)) =\n    (z0 * (1 + tt * tt) + rr * (1 - tt * tt) + \\<i> * rr * 2 * tt) /\n    (1 + tt * tt)", "apply (fold rr_def,simp add:add_divide_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>complex_of_real (cos t) = (1 - tt * tt) / (1 + tt * tt);\n     complex_of_real (sin t) = 2 * tt / (1 + tt * tt);\n     1 + tt * tt \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> rr *\n                      ((1 - tt * tt) / (1 + tt * tt) +\n                       \\<i> * (2 * tt) / (1 + tt * tt)) =\n                      rr * (1 - tt * tt) / (1 + tt * tt) +\n                      \\<i> * rr * 2 * tt / (1 + tt * tt)", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  z0 +\n  complex_of_real r *\n  (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)) =\n  (z0 * (1 + tt * tt) + rr * (1 - tt * tt) + \\<i> * rr * 2 * tt) /\n  (1 + tt * tt)\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "also"], ["proof (state)\nthis:\n  z0 +\n  complex_of_real r *\n  (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)) =\n  (z0 * (1 + tt * tt) + rr * (1 - tt * tt) + \\<i> * rr * 2 * tt) /\n  (1 + tt * tt)\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "have \"... = ((z0-rr)*tt+z0*\\<i>+rr*\\<i>) / (tt + \\<i>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z0 * (1 + tt * tt) + rr * (1 - tt * tt) + \\<i> * rr * 2 * tt) /\n    (1 + tt * tt) =\n    ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (z0 * (1 + tt * tt) + rr * (1 - tt * tt) + \\<i> * rr * 2 * tt) /\n    (1 + tt * tt) =\n    ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)", "have \"tt + \\<i> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tt + \\<i> \\<noteq> 0", "using \\<open>1 + tt * tt \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  1 + tt * tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. tt + \\<i> \\<noteq> 0", "by (metis i_squared neg_eq_iff_add_eq_0 square_eq_iff)"], ["proof (state)\nthis:\n  tt + \\<i> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (z0 * (1 + tt * tt) + rr * (1 - tt * tt) + \\<i> * rr * 2 * tt) /\n    (1 + tt * tt) =\n    ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)", "then"], ["proof (chain)\npicking this:\n  tt + \\<i> \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  tt + \\<i> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (z0 * (1 + tt * tt) + rr * (1 - tt * tt) + \\<i> * rr * 2 * tt) /\n    (1 + tt * tt) =\n    ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)", "using \\<open>1 + tt * tt \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  tt + \\<i> \\<noteq> 0\n  1 + tt * tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (z0 * (1 + tt * tt) + rr * (1 - tt * tt) + \\<i> * rr * 2 * tt) /\n    (1 + tt * tt) =\n    ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)", "by (auto simp add:divide_simps algebra_simps)"], ["proof (state)\nthis:\n  (z0 * (1 + tt * tt) + rr * (1 - tt * tt) + \\<i> * rr * 2 * tt) /\n  (1 + tt * tt) =\n  ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (z0 * (1 + tt * tt) + rr * (1 - tt * tt) + \\<i> * rr * 2 * tt) /\n  (1 + tt * tt) =\n  ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "finally"], ["proof (chain)\npicking this:\n  z0 +\n  complex_of_real r *\n  (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)) =\n  ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)", "have \"z0 +  r * ( (cos t) + \\<i> * (sin t)) = ((z0-rr)*tt+z0*\\<i>+rr*\\<i>) / (tt + \\<i>)\""], ["proof (prove)\nusing this:\n  z0 +\n  complex_of_real r *\n  (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)) =\n  ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)\n\ngoal (1 subgoal):\n 1. z0 +\n    complex_of_real r *\n    (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)) =\n    ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)", "."], ["proof (state)\nthis:\n  z0 +\n  complex_of_real r *\n  (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)) =\n  ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "then"], ["proof (chain)\npicking this:\n  z0 +\n  complex_of_real r *\n  (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)) =\n  ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)", "show ?thesis"], ["proof (prove)\nusing this:\n  z0 +\n  complex_of_real r *\n  (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)) =\n  ((z0 - rr) * tt + z0 * \\<i> + rr * \\<i>) / (tt + \\<i>)\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "unfolding tt_def rr_def"], ["proof (prove)\nusing this:\n  z0 +\n  complex_of_real r *\n  (complex_of_real (cos t) + \\<i> * complex_of_real (sin t)) =\n  ((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) + z0 * \\<i> +\n   complex_of_real r * \\<i>) /\n  (complex_of_real (tan (t / 2)) + \\<i>)\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n    poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2))))", "by (auto simp add:algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  poly p\n   (z0 +\n    complex_of_real r *\n    (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n  poly p\n   (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n     (z0 + complex_of_real r) * \\<i>) /\n    (\\<i> + complex_of_real (tan (t / 2))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p\n   (z0 +\n    complex_of_real r *\n    (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n  poly p\n   (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n     (z0 + complex_of_real r) * \\<i>) /\n    (\\<i> + complex_of_real (tan (t / 2))))\n\ngoal (1 subgoal):\n 1. f t =\n    ((\\<lambda>x.\n         poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "also"], ["proof (state)\nthis:\n  poly p\n   (z0 +\n    complex_of_real r *\n    (complex_of_real (cos t) + \\<i> * complex_of_real (sin t))) =\n  poly p\n   (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n     (z0 + complex_of_real r) * \\<i>) /\n    (\\<i> + complex_of_real (tan (t / 2))))\n\ngoal (1 subgoal):\n 1. f t =\n    ((\\<lambda>x.\n         poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "have \"... = (poly p o ((\\<lambda>x. ((z0-r)*x+(z0+r)*\\<i>) / (\\<i>+x)) o (\\<lambda>x. tan (x/2)) )) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2)))) =\n    (poly p \\<circ>\n     ((\\<lambda>x.\n          ((z0 - complex_of_real r) * x + (z0 + complex_of_real r) * \\<i>) /\n          (\\<i> + x)) \\<circ>\n      (\\<lambda>x. tan (x / 2))))\n     (complex_of_real t)", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p\n     (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + complex_of_real (tan (t / 2)))) =\n    poly p\n     (((z0 - complex_of_real r) * tan (complex_of_real t / 2) +\n       (z0 + complex_of_real r) * \\<i>) /\n      (\\<i> + tan (complex_of_real t / 2)))", "by (auto simp:tan_of_real)"], ["proof (state)\nthis:\n  poly p\n   (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n     (z0 + complex_of_real r) * \\<i>) /\n    (\\<i> + complex_of_real (tan (t / 2)))) =\n  (poly p \\<circ>\n   ((\\<lambda>x.\n        ((z0 - complex_of_real r) * x + (z0 + complex_of_real r) * \\<i>) /\n        (\\<i> + x)) \\<circ>\n    (\\<lambda>x. tan (x / 2))))\n   (complex_of_real t)\n\ngoal (1 subgoal):\n 1. f t =\n    ((\\<lambda>x.\n         poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "also"], ["proof (state)\nthis:\n  poly p\n   (((z0 - complex_of_real r) * complex_of_real (tan (t / 2)) +\n     (z0 + complex_of_real r) * \\<i>) /\n    (\\<i> + complex_of_real (tan (t / 2)))) =\n  (poly p \\<circ>\n   ((\\<lambda>x.\n        ((z0 - complex_of_real r) * x + (z0 + complex_of_real r) * \\<i>) /\n        (\\<i> + x)) \\<circ>\n    (\\<lambda>x. tan (x / 2))))\n   (complex_of_real t)\n\ngoal (1 subgoal):\n 1. f t =\n    ((\\<lambda>x.\n         poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "have \"... = ((\\<lambda>x::real. poly q1 x / poly q2 x) o  (\\<lambda>x. tan (x/2)) ) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p \\<circ>\n     ((\\<lambda>x.\n          ((z0 - complex_of_real r) * x + (z0 + complex_of_real r) * \\<i>) /\n          (\\<i> + x)) \\<circ>\n      (\\<lambda>x. tan (x / 2))))\n     (complex_of_real t) =\n    ((\\<lambda>x.\n         poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "unfolding q2_def q1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p \\<circ>\n     ((\\<lambda>x.\n          ((z0 - complex_of_real r) * x + (z0 + complex_of_real r) * \\<i>) /\n          (\\<i> + x)) \\<circ>\n      (\\<lambda>x. tan (x / 2))))\n     (complex_of_real t) =\n    ((\\<lambda>x.\n         poly\n          (fcompose p\n            [:(z0 + complex_of_real r) * \\<i>, z0 - complex_of_real r:]\n            [:\\<i>, 1:])\n          (complex_of_real x) /\n         poly ([:\\<i>, 1:] ^ degree p) (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "apply (subst fcompose_poly[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. poly [:\\<i>, 1:] (complex_of_real x) \\<noteq> 0\n 2. (poly p \\<circ>\n     ((\\<lambda>x.\n          ((z0 - complex_of_real r) * x + (z0 + complex_of_real r) * \\<i>) /\n          (\\<i> + x)) \\<circ>\n      (\\<lambda>x. tan (x / 2))))\n     (complex_of_real t) =\n    ((\\<lambda>x.\n         poly p\n          (poly [:(z0 + complex_of_real r) * \\<i>, z0 - complex_of_real r:]\n            (complex_of_real x) /\n           poly [:\\<i>, 1:] (complex_of_real x))) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly [:\\<i>, 1:] (complex_of_real x) \\<noteq> 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> + complex_of_real x \\<noteq> 0", "by (metis Re_complex_of_real add_cancel_right_left complex_i_not_zero imaginary_unit.sel(1) plus_complex.sel(1) rcis_zero_arg rcis_zero_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p \\<circ>\n     ((\\<lambda>x.\n          ((z0 - complex_of_real r) * x + (z0 + complex_of_real r) * \\<i>) /\n          (\\<i> + x)) \\<circ>\n      (\\<lambda>x. tan (x / 2))))\n     (complex_of_real t) =\n    ((\\<lambda>x.\n         poly p\n          (poly [:(z0 + complex_of_real r) * \\<i>, z0 - complex_of_real r:]\n            (complex_of_real x) /\n           poly [:\\<i>, 1:] (complex_of_real x))) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p \\<circ>\n     ((\\<lambda>x.\n          ((z0 - complex_of_real r) * x + (z0 + complex_of_real r) * \\<i>) /\n          (\\<i> + x)) \\<circ>\n      (\\<lambda>x. tan (x / 2))))\n     (complex_of_real t) =\n    ((\\<lambda>x.\n         poly p\n          (poly [:(z0 + complex_of_real r) * \\<i>, z0 - complex_of_real r:]\n            (complex_of_real x) /\n           poly [:\\<i>, 1:] (complex_of_real x))) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "by (auto simp:tan_of_real algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (poly p \\<circ>\n   ((\\<lambda>x.\n        ((z0 - complex_of_real r) * x + (z0 + complex_of_real r) * \\<i>) /\n        (\\<i> + x)) \\<circ>\n    (\\<lambda>x. tan (x / 2))))\n   (complex_of_real t) =\n  ((\\<lambda>x.\n       poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n   (\\<lambda>x. tan (x / 2)))\n   t\n\ngoal (1 subgoal):\n 1. f t =\n    ((\\<lambda>x.\n         poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "finally"], ["proof (chain)\npicking this:\n  f t =\n  ((\\<lambda>x.\n       poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n   (\\<lambda>x. tan (x / 2)))\n   t", "show ?thesis"], ["proof (prove)\nusing this:\n  f t =\n  ((\\<lambda>x.\n       poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n   (\\<lambda>x. tan (x / 2)))\n   t\n\ngoal (1 subgoal):\n 1. f t =\n    ((\\<lambda>x.\n         poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n     (\\<lambda>x. tan (x / 2)))\n     t", "."], ["proof (state)\nthis:\n  f t =\n  ((\\<lambda>x.\n       poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n   (\\<lambda>x. tan (x / 2)))\n   t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cos (?t / 2) \\<noteq> 0 \\<Longrightarrow>\n  f ?t =\n  ((\\<lambda>x.\n       poly q1 (complex_of_real x) / poly q2 (complex_of_real x)) \\<circ>\n   (\\<lambda>x. tan (x / 2)))\n   ?t\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      exp (2 * complex_of_real pi * \\<i> * complex_of_real t)) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "have \"cos (pi * t) \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (pi * t) \\<noteq> 0", "unfolding cos_zero_iff_int2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>x. pi * t = real_of_int x * pi + pi / 2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. pi * t = real_of_int x * pi + pi / 2 \\<Longrightarrow> False", "assume \"\\<exists>i. pi * t = real_of_int i * pi + pi / 2\""], ["proof (state)\nthis:\n  \\<exists>i. pi * t = real_of_int i * pi + pi / 2\n\ngoal (1 subgoal):\n 1. \\<exists>x. pi * t = real_of_int x * pi + pi / 2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. pi * t = real_of_int i * pi + pi / 2", "obtain i where \"pi * t = real_of_int i * pi + pi / 2\""], ["proof (prove)\nusing this:\n  \\<exists>i. pi * t = real_of_int i * pi + pi / 2\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        pi * t = real_of_int i * pi + pi / 2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pi * t = real_of_int i * pi + pi / 2\n\ngoal (1 subgoal):\n 1. \\<exists>x. pi * t = real_of_int x * pi + pi / 2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  pi * t = real_of_int i * pi + pi / 2", "have \"pi * t=pi * (real_of_int i + 1 / 2)\""], ["proof (prove)\nusing this:\n  pi * t = real_of_int i * pi + pi / 2\n\ngoal (1 subgoal):\n 1. pi * t = pi * (real_of_int i + 1 / 2)", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  pi * t = pi * (real_of_int i + 1 / 2)\n\ngoal (1 subgoal):\n 1. \\<exists>x. pi * t = real_of_int x * pi + pi / 2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  pi * t = pi * (real_of_int i + 1 / 2)", "have \"t=real_of_int i + 1 / 2\""], ["proof (prove)\nusing this:\n  pi * t = pi * (real_of_int i + 1 / 2)\n\ngoal (1 subgoal):\n 1. t = real_of_int i + 1 / 2", "by auto"], ["proof (state)\nthis:\n  t = real_of_int i + 1 / 2\n\ngoal (1 subgoal):\n 1. \\<exists>x. pi * t = real_of_int x * pi + pi / 2 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t = real_of_int i + 1 / 2", "show False"], ["proof (prove)\nusing this:\n  t = real_of_int i + 1 / 2\n\ngoal (1 subgoal):\n 1. False", "using \\<open>0\\<le>t\\<close> \\<open>t\\<le>1\\<close> \\<open>t\\<noteq>1/2\\<close>"], ["proof (prove)\nusing this:\n  t = real_of_int i + 1 / 2\n  0 \\<le> t\n  t \\<le> 1\n  t \\<noteq> 1 / 2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cos (pi * t) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      exp (2 * complex_of_real pi * \\<i> * complex_of_real t)) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "from f_eq[of \"2*pi*t\",simplified,OF this]"], ["proof (chain)\npicking this:\n  f (2 * pi * t) =\n  poly q1 (complex_of_real (tan (pi * t))) /\n  poly q2 (complex_of_real (tan (pi * t)))", "show \"?thesis\""], ["proof (prove)\nusing this:\n  f (2 * pi * t) =\n  poly q1 (complex_of_real (tan (pi * t))) /\n  poly q2 (complex_of_real (tan (pi * t)))\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      exp (2 * complex_of_real pi * \\<i> * complex_of_real t)) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "unfolding f_def comp_def"], ["proof (prove)\nusing this:\n  poly p\n   (z0 + complex_of_real r * exp (\\<i> * complex_of_real (2 * pi * t))) =\n  poly q1 (complex_of_real (tan (pi * t))) /\n  poly q2 (complex_of_real (tan (pi * t)))\n\ngoal (1 subgoal):\n 1. poly p\n     (z0 +\n      complex_of_real r *\n      exp (2 * complex_of_real pi * \\<i> * complex_of_real t)) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  poly p\n   (z0 +\n    complex_of_real r *\n    exp (2 * complex_of_real pi * \\<i> * complex_of_real t)) =\n  poly q1 (complex_of_real (tan (pi * t))) /\n  poly q2 (complex_of_real (tan (pi * t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p\n   (z0 +\n    complex_of_real r *\n    exp (2 * complex_of_real pi * \\<i> * complex_of_real t)) =\n  poly q1 (complex_of_real (tan (pi * t))) /\n  poly q2 (complex_of_real (tan (pi * t)))\n\ngoal (1 subgoal):\n 1. poly p (circlepath z0 r t) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "finally"], ["proof (chain)\npicking this:\n  poly p (circlepath z0 r t) =\n  poly q1 (complex_of_real (tan (pi * t))) /\n  poly q2 (complex_of_real (tan (pi * t)))", "show ?thesis"], ["proof (prove)\nusing this:\n  poly p (circlepath z0 r t) =\n  poly q1 (complex_of_real (tan (pi * t))) /\n  poly q2 (complex_of_real (tan (pi * t)))\n\ngoal (1 subgoal):\n 1. poly p (circlepath z0 r t) =\n    poly q1 (complex_of_real (tan (pi * t))) /\n    poly q2 (complex_of_real (tan (pi * t)))", "."], ["proof (state)\nthis:\n  poly p (circlepath z0 r t) =\n  poly q1 (complex_of_real (tan (pi * t))) /\n  poly q2 (complex_of_real (tan (pi * t)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}