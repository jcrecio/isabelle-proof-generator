{"file_name": "/home/qj213/afp-2021-10-22/thys/Count_Complex_Roots/Count_Complex_Roots.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Count_Complex_Roots", "problem_names": ["lemma infinite_ball:\n  fixes a :: \"'a::euclidean_space\"\n  assumes \"r > 0\" \n  shows \"infinite (ball a r)\"", "lemma infinite_cball:\n  fixes a :: \"'a::euclidean_space\"\n  assumes \"r > 0\" \n  shows \"infinite (cball a r)\"", "lemma infinite_sphere:\n  fixes a :: complex\n  assumes \"r > 0\" \n  shows \"infinite (sphere a r)\"", "lemma infinite_halfspace_Im_gt: \"infinite {x. Im x > b}\"", "lemma (in ring_1) Ints_minus2: \"- a \\<in> \\<int> \\<Longrightarrow> a \\<in> \\<int>\"", "lemma dvd_divide_Ints_iff:\n  \"b dvd a \\<or> b=0 \\<longleftrightarrow> of_int a / of_int b \\<in> (\\<int> :: 'a :: {field,ring_char_0} set)\"", "lemma of_int_div_field:\n  assumes \"d dvd n\"\n  shows \"(of_int::_\\<Rightarrow>'a::field_char_0) (n div d) = of_int n / of_int d\"", "lemma powr_eq_1_iff:\n  assumes \"a>0\"\n  shows \"(a::real) powr b =1 \\<longleftrightarrow> a=1 \\<or> b=0\"", "lemma tan_inj_pi:\n  \"- (pi/2) < x \\<Longrightarrow> x < pi/2 \\<Longrightarrow> - (pi/2) < y \\<Longrightarrow> y < pi/2 \\<Longrightarrow> tan x = tan y \\<Longrightarrow> x = y\"", "lemma finite_ReZ_segments_poly_circlepath:\n          \"finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0\"", "lemma bij_betw_plane_ball:\"bij_betw (\\<lambda>x. (\\<i>-x)/(\\<i>+x)) {x. Im x>0} (ball 0 1)\"", "lemma bij_betw_axis_sphere:\"bij_betw (\\<lambda>x. (\\<i>-x)/(\\<i>+x)) {x. Im x=0} (sphere 0 1 - {-1})\"", "lemma bij_betw_ball_uball:\n  assumes \"r>0\"\n  shows \"bij_betw (\\<lambda>x. complex_of_real r*x + z0) (ball 0 1) (ball z0 r)\"", "lemma bij_betw_sphere_usphere:\n  assumes \"r>0\"\n  shows \"bij_betw (\\<lambda>x. complex_of_real r*x + z0) (sphere 0 1) (sphere z0 r)\"", "lemma proots_ball_plane_eq:\n  defines \"q1\\<equiv>[:\\<i>,-1:]\" and \"q2\\<equiv>[:\\<i>,1:]\"\n  assumes \"p\\<noteq>0\"\n  shows \"proots_count p (ball 0 1) = proots_count (fcompose p q1 q2) {x. 0 < Im x}\"", "lemma proots_sphere_axis_eq:\n  defines \"q1\\<equiv>[:\\<i>,-1:]\" and \"q2\\<equiv>[:\\<i>,1:]\"\n  assumes \"p\\<noteq>0\"\n  shows \"proots_count p (sphere 0 1 - {- 1}) = proots_count (fcompose p q1 q2) {x. 0 = Im x}\"", "lemma proots_card_ball_plane_eq:\n  defines \"q1\\<equiv>[:\\<i>,-1:]\" and \"q2\\<equiv>[:\\<i>,1:]\"\n  assumes \"p\\<noteq>0\"\n  shows \"card (proots_within p (ball 0 1)) = card (proots_within (fcompose p q1 q2) {x. 0 < Im x})\"", "lemma proots_card_sphere_axis_eq:\n  defines \"q1\\<equiv>[:\\<i>,-1:]\" and \"q2\\<equiv>[:\\<i>,1:]\"\n  assumes \"p\\<noteq>0\"\n  shows \"card (proots_within p (sphere 0 1 - {- 1})) \n            = card (proots_within (fcompose p q1 q2) {x. 0 = Im x})\"", "lemma proots_uball_eq:\n  fixes z0::complex and r::real\n  defines \"q\\<equiv>[:z0, of_real r:]\"\n  assumes \"p\\<noteq>0\" and \"r>0\"\n  shows \"proots_count p (ball z0 r) = proots_count (p \\<circ>\\<^sub>p q) (ball 0 1)\"", "lemma proots_card_uball_eq:\n  fixes z0::complex and r::real\n  defines \"q\\<equiv>[:z0, of_real r:]\"\n  assumes \"r>0\"\n  shows \"card (proots_within p (ball z0 r)) = card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))\"", "lemma proots_card_usphere_eq:\n  fixes z0::complex and r::real\n  defines \"q\\<equiv>[:z0, of_real r:]\"\n  assumes \"r>0\"\n  shows \"card (proots_within p (sphere z0 r)) = card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))\"", "lemma cpoly_of_eq_0_iff[iff]:\n  \"cpoly_of pR pI = 0 \\<longleftrightarrow> pR = 0 \\<and> pI = 0\"", "lemma cpoly_of_decompose:\n    \"p = cpoly_of (map_poly Re p) (map_poly Im p)\"", "lemma cpoly_of_dist_right:\n    \"cpoly_of (pR*g) (pI*g) = cpoly_of pR pI * (map_poly of_real g)\"", "lemma poly_cpoly_of_real:\n    \"poly (cpoly_of pR pI) (of_real x) = Complex (poly pR x) (poly pI x)\"", "lemma poly_cpoly_of_real_iff:\n  shows \"poly (cpoly_of pR pI) (of_real t) =0 \\<longleftrightarrow> poly pR t = 0 \\<and> poly pI t=0 \"", "lemma order_cpoly_gcd_eq:\n  assumes \"pR\\<noteq>0 \\<or> pI\\<noteq>0\"\n  shows \"order t (cpoly_of pR pI) = order t (gcd pR pI)\"", "lemma card_proots_open_segments:\n  assumes \"poly p st \\<noteq>0\" \"poly p tt \\<noteq> 0\"\n  shows \"card (proots_within p (open_segment st tt)) = \n                (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                 in changes_itv_smods 0 1 g (pderiv g))\" (is \"?L = ?R\")", "lemma unbounded_line_closed_segment: \"closed_segment a b \\<subseteq> unbounded_line a b\"", "lemma card_proots_unbounded_line:\n  assumes \"st\\<noteq>tt\"\n  shows \"card (proots_within p (unbounded_line st tt)) = \n                (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                 in nat (changes_R_smods g (pderiv g)))\" (is \"?L = ?R\")", "lemma proots_unbounded_line:\n  assumes \"st\\<noteq>tt\" \"p\\<noteq>0\"\n  shows \"(proots_count p (unbounded_line st tt)) = \n                (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                 in nat (changes_R_smods_ext g (pderiv g)))\" (is \"?L = ?R\")", "lemma proots_unbounded_line_card_code[code]:\n  \"proots_unbounded_line_card p st tt = \n              (if st\\<noteq>tt then \n                (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                 in nat (changes_R_smods g (pderiv g))) \n              else \n                  Code.abort (STR ''proots_unbounded_line_card fails due to invalid hyperplanes.'') \n                      (\\<lambda>_. proots_unbounded_line_card p st tt))\"", "lemma proots_unbounded_line_code[code]:\n  \"proots_unbounded_line p st tt = \n              ( if st\\<noteq>tt then \n                if p\\<noteq>0 then \n                  (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                  in nat (changes_R_smods_ext g (pderiv g)))\n                else \n                  Code.abort (STR ''proots_unbounded_line fails due to p=0'') \n                      (\\<lambda>_. proots_unbounded_line p st tt)\n                else \n                  Code.abort (STR ''proots_unbounded_line fails due to invalid hyperplanes.'') \n                      (\\<lambda>_. proots_unbounded_line p st tt) )\"", "lemma no_proots_line_code[code]: \"no_proots_line p st tt = (if poly p st \\<noteq>0 \\<and> poly p tt \\<noteq> 0 then \n                (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                 in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False) else False)\"\n            (is \"?L = ?R\")", "lemma closed_segment_imp_Re_Im:\n  fixes x::complex\n  assumes \"x\\<in>closed_segment lb ub\" \n  shows \"Re lb \\<le> Re ub \\<Longrightarrow> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\" \n        \"Im lb \\<le> Im ub \\<Longrightarrow> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\"", "lemma closed_segment_degen_complex:\n  \"\\<lbrakk>Re lb = Re ub; Im lb \\<le> Im ub \\<rbrakk> \n    \\<Longrightarrow> x \\<in> closed_segment lb ub \\<longleftrightarrow> Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub \"\n  \"\\<lbrakk>Im lb = Im ub; Re lb \\<le> Re ub \\<rbrakk> \n    \\<Longrightarrow> x \\<in> closed_segment lb ub \\<longleftrightarrow> Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub \"", "lemma complex_box_ne_empty: \n  fixes a b::complex\n  shows \n    \"cbox a b \\<noteq> {} \\<longleftrightarrow> (Re a \\<le> Re b \\<and> Im a \\<le> Im b)\"\n    \"box a b \\<noteq> {} \\<longleftrightarrow> (Re a < Re b \\<and> Im a < Im b)\"", "lemma proots_rectangle_code1:\n  \"proots_rectangle p lb ub = (if Re lb < Re ub \\<and> Im lb < Im ub then \n            if p\\<noteq>0 then \n            if no_proots_line p lb (Complex (Re ub) (Im lb))\n            \\<and> no_proots_line p (Complex (Re ub) (Im lb)) ub\n            \\<and> no_proots_line p ub (Complex (Re lb) (Im ub))\n            \\<and> no_proots_line p (Complex (Re lb) (Im ub)) lb then  \n            (\n            let p1 = pcompose p [:lb,  Complex (Re ub - Re lb) 0:];\n                pR1 = map_poly Re p1; pI1 = map_poly Im p1; gc1 = gcd pR1 pI1;\n                p2 = pcompose p [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):];\n                pR2 = map_poly Re p2; pI2 = map_poly Im p2; gc2 = gcd pR2 pI2;\n                p3 = pcompose p [:ub, Complex (Re lb - Re ub) 0:];\n                pR3 = map_poly Re p3; pI3 = map_poly Im p3; gc3 = gcd pR3 pI3;\n                p4 = pcompose p [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):];\n                pR4 = map_poly Re p4; pI4 = map_poly Im p4; gc4 = gcd pR4 pI4\n            in \n              nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1)\n                + changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2)\n                + changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3)\n                + changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4))  div 4)\n            )\n            else Code.abort (STR ''proots_rectangle fails when there is a root on the border.'') \n            (\\<lambda>_. proots_rectangle p lb ub)\n            else Code.abort (STR ''proots_rectangle fails when p=0.'') \n            (\\<lambda>_. proots_rectangle p lb ub)\n            else 0)\"", "lemma proots_rectangle_code2[code]:\n  \"proots_rectangle p lb ub = (if Re lb < Re ub \\<and> Im lb < Im ub then \n            if p\\<noteq>0 then \n            if poly p lb \\<noteq> 0 \\<and> poly p (Complex (Re ub) (Im lb)) \\<noteq>0 \n               \\<and> poly p ub \\<noteq>0 \\<and> poly p (Complex (Re lb) (Im ub)) \\<noteq>0 \n            then\n              (let p1 = pcompose p [:lb,  Complex (Re ub - Re lb) 0:];\n                pR1 = map_poly Re p1; pI1 = map_poly Im p1; gc1 = gcd pR1 pI1;\n                p2 = pcompose p [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):];\n                pR2 = map_poly Re p2; pI2 = map_poly Im p2; gc2 = gcd pR2 pI2;\n                p3 = pcompose p [:ub, Complex (Re lb - Re ub) 0:];\n                pR3 = map_poly Re p3; pI3 = map_poly Im p3; gc3 = gcd pR3 pI3;\n                p4 = pcompose p [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):];\n                pR4 = map_poly Re p4; pI4 = map_poly Im p4; gc4 = gcd pR4 pI4\n              in\n                if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0\n                   \\<and> changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \n                   \\<and> changes_itv_smods 0 1 gc3 (pderiv gc3) = 0\n                   \\<and> changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                then \n                   nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1)\n                    + changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2)\n                    + changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3)\n                    + changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) div 4)\n                else Code.abort (STR ''proots_rectangle fails when there is a root on the border.'') \n                        (\\<lambda>_. proots_rectangle p lb ub))\n            else Code.abort (STR ''proots_rectangle fails when there is a root on the border.'') \n              (\\<lambda>_. proots_rectangle p lb ub)  \n            else Code.abort (STR ''proots_rectangle fails when p=0.'') \n            (\\<lambda>_. proots_rectangle p lb ub)\n            else 0)\"", "lemma Im_Ln_tendsto_at_top: \"((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi/2 ) at_top \"", "lemma Im_Ln_tendsto_at_bot: \"((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi/2 ) at_bot \"", "lemma Re_winding_number_tendsto_part_circlepath:\n  shows \"((\\<lambda>r. Re (winding_number (part_circlepath z0 r 0 pi ) a)) \\<longlongrightarrow> 1/2 ) at_top\"", "lemma not_image_at_top_poly_part_circlepath:\n  assumes \"degree p>0\"\n  shows \"\\<forall>\\<^sub>F r in at_top. b\\<notin>path_image (poly p o part_circlepath z0 r st tt)\"", "lemma not_image_poly_part_circlepath:\n  assumes \"degree p>0\"\n  shows \"\\<exists>r>0.  b\\<notin>path_image (poly p o part_circlepath z0 r st tt)\"", "lemma Re_winding_number_poly_part_circlepath:\n  assumes \"degree p>0\"\n  shows \"((\\<lambda>r. Re (winding_number (poly p o part_circlepath z0 r 0 pi) 0)) \\<longlongrightarrow> degree p/2 ) at_top\"", "lemma Re_winding_number_poly_linepth:\n  fixes pp::\"complex poly\"\n  defines \"g \\<equiv> (\\<lambda>r. poly pp o linepath (-r) (of_real r))\"\n  assumes \"lead_coeff pp=1\" and no_real_zero:\"\\<forall>x\\<in>proots pp. Im x\\<noteq>0\"\n  shows \"((\\<lambda>r. 2*Re (winding_number (g r) 0) + cindex_pathE (g r) 0 ) \\<longlongrightarrow> 0 ) at_top\"", "lemma proots_upper_cindex_eq:\n  assumes \"lead_coeff p=1\" and no_real_roots:\"\\<forall>x\\<in>proots p. Im x\\<noteq>0\" \n  shows \"proots_upper p =\n             (degree p - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /2\"", "lemma cindexE_roots_on_horizontal_border:\n  fixes a::complex and s::real\n  defines \"g\\<equiv>linepath a (a + of_real s)\"\n  assumes pqr:\"p = q * r\" and r_monic:\"lead_coeff r=1\" and r_proots:\"\\<forall>x\\<in>proots r. Im x=Im a\"\n  shows \"cindexE lb ub (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n          cindexE lb ub (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\"", "lemma poly_decompose_by_proots:\n  fixes p ::\"'a::idom poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"\\<exists>q r. p = q * r \\<and> lead_coeff q=1 \\<and> (\\<forall>x\\<in>proots q. P x) \\<and> (\\<forall>x\\<in>proots r. \\<not>P x)\"", "lemma proots_upper_cindex_eq':\n  assumes \"lead_coeff p=1\"\n  shows \"proots_upper p = (degree p - proots_count p {x. Im x=0} \n              - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /2\"", "lemma proots_within_upper_squarefree:\n  assumes \"rsquarefree p\"\n  shows  \"card (proots_within p {x. Im x >0}) = (let \n            pp = smult (inverse (lead_coeff p)) p;\n            pI = map_poly Im pp;\n            pR = map_poly Re pp;\n            g = gcd pR pI\n        in\n            nat ((degree p - changes_R_smods g (pderiv g) - changes_R_smods pR pI) div 2)  \n      )\"", "lemma proots_upper_code1[code]:\n  \"proots_upper p = \n    (if p \\<noteq> 0 then\n       (let pp=smult (inverse (lead_coeff p)) p;\n            pI=map_poly Im pp;\n            pR=map_poly Re pp;\n            g = gcd pI pR\n        in\n            nat ((degree p - nat (changes_R_smods_ext g (pderiv g)) - changes_R_smods pR pI) div 2) \n        )\n    else \n      Code.abort (STR ''proots_upper fails when p=0.'') (\\<lambda>_. proots_upper p))\"", "lemma proots_upper_card_code[code]:\n  \"proots_upper_card p = (if p=0 then 0 else\n      (let\n            pf = p div (gcd p (pderiv p));\n            pp = smult (inverse (lead_coeff pf)) pf;\n            pI = map_poly Im pp;\n            pR = map_poly Re pp;\n            g = gcd pR pI\n        in\n            nat ((degree pf - changes_R_smods g (pderiv g) - changes_R_smods pR pI) div 2)  \n      ))\"", "lemma proots_half_empty:\n  assumes \"a=b\"\n  shows \"proots_half p a b = 0\"", "lemma proots_half_proots_upper:\n  assumes \"a\\<noteq>b\" \"p\\<noteq>0\"\n  shows \"proots_half p a b= proots_upper (pcompose p [:a, (b-a):])\"", "lemma proots_half_code1[code]:\n  \"proots_half p a b = (if a\\<noteq>b then \n                        if p\\<noteq>0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:]) \n                        else Code.abort (STR ''proots_half fails when p=0.'') \n                          (\\<lambda>_. proots_half p a b) \n                        else 0)\"", "lemma proots_ball_code1[code]:\n  \"proots_ball p z0 r = ( if r \\<le> 0 then \n                              0\n                          else if p\\<noteq>0 then\n                              proots_upper (fcompose (p \\<circ>\\<^sub>p [:z0, of_real r:]) [:\\<i>,-1:] [:\\<i>,1:]) \n                          else \n                              Code.abort (STR ''proots_ball fails when p=0.'') \n                                (\\<lambda>_. proots_ball p z0 r)\n                        )\"", "lemma proots_ball_card_code1[code]:\n  \"proots_ball_card p z0 r = \n                ( if r \\<le> 0 \\<or> p=0 then \n                      0\n                 else \n                    proots_upper_card (fcompose (p \\<circ>\\<^sub>p [:z0, of_real r:]) [:\\<i>,-1:] [:\\<i>,1:]) \n                        )\"", "lemma proots_sphere_card_code1[code]:\n  \"proots_sphere_card p z0 r = \n                ( if r=0 then \n                      (if poly p z0=0 then 1 else 0) \n                  else if r < 0 \\<or> p=0 then \n                      0\n                  else \n                    (if poly p (z0-r) =0 then 1 else 0) +\n                    proots_unbounded_line_card (fcompose (p \\<circ>\\<^sub>p [:z0, of_real r:]) [:\\<i>,-1:] [:\\<i>,1:])\n                      0 1 \n                )\"", "lemma proots_cball_card_code1[code]:\n  \"proots_cball_card p z0 r = \n                ( if r=0 then \n                      (if poly p z0=0 then 1 else 0) \n                  else if r < 0 \\<or> p=0 then \n                      0\n                  else \n                    ( let pp=fcompose (p \\<circ>\\<^sub>p [:z0, of_real r:]) [:\\<i>,-1:] [:\\<i>,1:] \n                      in \n                        (if poly p (z0-r) =0 then 1 else 0) \n                        + proots_unbounded_line_card pp 0 1 \n                        + proots_upper_card pp\n                    )\n                )\""], "translations": [["", "lemma infinite_ball:\n  fixes a :: \"'a::euclidean_space\"\n  assumes \"r > 0\" \n  shows \"infinite (ball a r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (ball a r)", "using uncountable_ball[OF assms, THEN uncountable_infinite]"], ["proof (prove)\nusing this:\n  infinite (ball ?a1 r)\n\ngoal (1 subgoal):\n 1. infinite (ball a r)", "."], ["", "lemma infinite_cball:\n  fixes a :: \"'a::euclidean_space\"\n  assumes \"r > 0\" \n  shows \"infinite (cball a r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (cball a r)", "using uncountable_cball[OF assms, THEN uncountable_infinite,of a]"], ["proof (prove)\nusing this:\n  infinite (cball a r)\n\ngoal (1 subgoal):\n 1. infinite (cball a r)", "."], ["", "(*FIXME: to generalise*)"], ["", "lemma infinite_sphere:\n  fixes a :: complex\n  assumes \"r > 0\" \n  shows \"infinite (sphere a r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (sphere a r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (sphere a r)", "have \"uncountable (path_image (circlepath a r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uncountable (path_image (circlepath a r))", "apply (rule simple_path_image_uncountable)"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_path (circlepath a r)", "using simple_path_circlepath assms"], ["proof (prove)\nusing this:\n  simple_path (circlepath ?z ?r) = (?r \\<noteq> 0)\n  0 < r\n\ngoal (1 subgoal):\n 1. simple_path (circlepath a r)", "by simp"], ["proof (state)\nthis:\n  uncountable (path_image (circlepath a r))\n\ngoal (1 subgoal):\n 1. infinite (sphere a r)", "then"], ["proof (chain)\npicking this:\n  uncountable (path_image (circlepath a r))", "have \"uncountable (sphere a r)\""], ["proof (prove)\nusing this:\n  uncountable (path_image (circlepath a r))\n\ngoal (1 subgoal):\n 1. uncountable (sphere a r)", "using assms"], ["proof (prove)\nusing this:\n  uncountable (path_image (circlepath a r))\n  0 < r\n\ngoal (1 subgoal):\n 1. uncountable (sphere a r)", "by simp"], ["proof (state)\nthis:\n  uncountable (sphere a r)\n\ngoal (1 subgoal):\n 1. infinite (sphere a r)", "from uncountable_infinite[OF this]"], ["proof (chain)\npicking this:\n  infinite (sphere a r)", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite (sphere a r)\n\ngoal (1 subgoal):\n 1. infinite (sphere a r)", "."], ["proof (state)\nthis:\n  infinite (sphere a r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_halfspace_Im_gt: \"infinite {x. Im x > b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {x. b < Im x}", "apply (rule connected_uncountable[THEN uncountable_infinite,of _ \"(b+1)* \\<i>\" \"(b+2)*\\<i>\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. connected {x. b < Im x}\n 2. complex_of_real (b + 1) * \\<i> \\<in> {x. b < Im x}\n 3. complex_of_real (b + 2) * \\<i> \\<in> {x. b < Im x}\n 4. complex_of_real (b + 1) * \\<i> \\<noteq> complex_of_real (b + 2) * \\<i>", "by (auto intro!:convex_connected simp add: convex_halfspace_Im_gt)"], ["", "lemma (in ring_1) Ints_minus2: \"- a \\<in> \\<int> \\<Longrightarrow> a \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a \\<in> \\<int> \\<Longrightarrow> a \\<in> \\<int>", "using Ints_minus[of \"-a\"]"], ["proof (prove)\nusing this:\n  - a \\<in> \\<int> \\<Longrightarrow> - (- a) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. - a \\<in> \\<int> \\<Longrightarrow> a \\<in> \\<int>", "by auto"], ["", "lemma dvd_divide_Ints_iff:\n  \"b dvd a \\<or> b=0 \\<longleftrightarrow> of_int a / of_int b \\<in> (\\<int> :: 'a :: {field,ring_char_0} set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b dvd a \\<or> b = 0) = (of_int a / of_int b \\<in> \\<int>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b dvd a \\<or> b = 0 \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n 2. of_int a / of_int b \\<in> \\<int> \\<Longrightarrow> b dvd a \\<or> b = 0", "assume asm:\"b dvd a \\<or> b=0\""], ["proof (state)\nthis:\n  b dvd a \\<or> b = 0\n\ngoal (2 subgoals):\n 1. b dvd a \\<or> b = 0 \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n 2. of_int a / of_int b \\<in> \\<int> \\<Longrightarrow> b dvd a \\<or> b = 0", "let ?thesis = \"of_int a / of_int b \\<in> (\\<int> :: 'a :: {field,ring_char_0} set)\""], ["proof (state)\ngoal (2 subgoals):\n 1. b dvd a \\<or> b = 0 \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n 2. of_int a / of_int b \\<in> \\<int> \\<Longrightarrow> b dvd a \\<or> b = 0", "have ?thesis when \"b dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int>", "obtain c where \"a=b * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. a = b * c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<open>b dvd a\\<close>"], ["proof (prove)\nusing this:\n  b dvd a\n\ngoal (1 subgoal):\n 1. (\\<And>c. a = b * c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. a = b * k\n\ngoal (1 subgoal):\n 1. (\\<And>c. a = b * c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  a = b * c\n\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int>", "then"], ["proof (chain)\npicking this:\n  a = b * c", "show ?thesis"], ["proof (prove)\nusing this:\n  a = b * c\n\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int>", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  of_int a / of_int b \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b dvd a \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. b dvd a \\<or> b = 0 \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n 2. of_int a / of_int b \\<in> \\<int> \\<Longrightarrow> b dvd a \\<or> b = 0", "moreover"], ["proof (state)\nthis:\n  b dvd a \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. b dvd a \\<or> b = 0 \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n 2. of_int a / of_int b \\<in> \\<int> \\<Longrightarrow> b dvd a \\<or> b = 0", "have ?thesis when \"b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int>", "using that"], ["proof (prove)\nusing this:\n  b = 0\n\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  b = 0 \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. b dvd a \\<or> b = 0 \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n 2. of_int a / of_int b \\<in> \\<int> \\<Longrightarrow> b dvd a \\<or> b = 0", "ultimately"], ["proof (chain)\npicking this:\n  b dvd a \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n  b = 0 \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  b dvd a \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n  b = 0 \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int>", "using asm"], ["proof (prove)\nusing this:\n  b dvd a \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n  b = 0 \\<Longrightarrow> of_int a / of_int b \\<in> \\<int>\n  b dvd a \\<or> b = 0\n\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  of_int a / of_int b \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int> \\<Longrightarrow> b dvd a \\<or> b = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int> \\<Longrightarrow> b dvd a \\<or> b = 0", "assume \"of_int a / of_int b \\<in> (\\<int> :: 'a :: {field,ring_char_0} set)\""], ["proof (state)\nthis:\n  of_int a / of_int b \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int> \\<Longrightarrow> b dvd a \\<or> b = 0", "from Ints_cases[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>z.\n      of_int a / of_int b = of_int z \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain c where *:\"(of_int::_ \\<Rightarrow> 'a) c= of_int a / of_int b\""], ["proof (prove)\nusing this:\n  (\\<And>z.\n      of_int a / of_int b = of_int z \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        of_int c = of_int a / of_int b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  of_int c = of_int a / of_int b\n\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int> \\<Longrightarrow> b dvd a \\<or> b = 0", "have \"b dvd a\" when \"b\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b dvd a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b dvd a", "have \"(of_int::_ \\<Rightarrow> 'a) a = of_int b * of_int c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int a = of_int b * of_int c", "using that *"], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n  of_int c = of_int a / of_int b\n\ngoal (1 subgoal):\n 1. of_int a = of_int b * of_int c", "by auto"], ["proof (state)\nthis:\n  of_int a = of_int b * of_int c\n\ngoal (1 subgoal):\n 1. b dvd a", "then"], ["proof (chain)\npicking this:\n  of_int a = of_int b * of_int c", "have \"a = b * c\""], ["proof (prove)\nusing this:\n  of_int a = of_int b * of_int c\n\ngoal (1 subgoal):\n 1. a = b * c", "using of_int_eq_iff"], ["proof (prove)\nusing this:\n  of_int a = of_int b * of_int c\n  (of_int ?w = of_int ?z) = (?w = ?z)\n\ngoal (1 subgoal):\n 1. a = b * c", "by fastforce"], ["proof (state)\nthis:\n  a = b * c\n\ngoal (1 subgoal):\n 1. b dvd a", "then"], ["proof (chain)\npicking this:\n  a = b * c", "show ?thesis"], ["proof (prove)\nusing this:\n  a = b * c\n\ngoal (1 subgoal):\n 1. b dvd a", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  a = b * c\n\ngoal (1 subgoal):\n 1. \\<exists>k. a = b * k", "by auto"], ["proof (state)\nthis:\n  b dvd a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<noteq> 0 \\<Longrightarrow> b dvd a\n\ngoal (1 subgoal):\n 1. of_int a / of_int b \\<in> \\<int> \\<Longrightarrow> b dvd a \\<or> b = 0", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> 0 \\<Longrightarrow> b dvd a", "show \" b dvd a \\<or> b = 0\""], ["proof (prove)\nusing this:\n  b \\<noteq> 0 \\<Longrightarrow> b dvd a\n\ngoal (1 subgoal):\n 1. b dvd a \\<or> b = 0", "by auto"], ["proof (state)\nthis:\n  b dvd a \\<or> b = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_int_div_field:\n  assumes \"d dvd n\"\n  shows \"(of_int::_\\<Rightarrow>'a::field_char_0) (n div d) = of_int n / of_int d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (n div d) = of_int n / of_int d", "apply (subst (2) dvd_mult_div_cancel[OF assms,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (n div d) = of_int (d * (n div d)) / of_int d", "by (auto simp add:field_simps)"], ["", "lemma powr_eq_1_iff:\n  assumes \"a>0\"\n  shows \"(a::real) powr b =1 \\<longleftrightarrow> a=1 \\<or> b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a powr b = 1) = (a = 1 \\<or> b = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a powr b = 1 \\<Longrightarrow> a = 1 \\<or> b = 0\n 2. a = 1 \\<or> b = 0 \\<Longrightarrow> a powr b = 1", "assume \"a powr b = 1\""], ["proof (state)\nthis:\n  a powr b = 1\n\ngoal (2 subgoals):\n 1. a powr b = 1 \\<Longrightarrow> a = 1 \\<or> b = 0\n 2. a = 1 \\<or> b = 0 \\<Longrightarrow> a powr b = 1", "have \"b * ln a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * ln a = 0", "using \\<open>a powr b = 1\\<close> ln_powr[of a b] assms"], ["proof (prove)\nusing this:\n  a powr b = 1\n  a \\<noteq> 0 \\<Longrightarrow> ln (a powr b) = b * ln a\n  0 < a\n\ngoal (1 subgoal):\n 1. b * ln a = 0", "by auto"], ["proof (state)\nthis:\n  b * ln a = 0\n\ngoal (2 subgoals):\n 1. a powr b = 1 \\<Longrightarrow> a = 1 \\<or> b = 0\n 2. a = 1 \\<or> b = 0 \\<Longrightarrow> a powr b = 1", "then"], ["proof (chain)\npicking this:\n  b * ln a = 0", "have \"b=0 \\<or> ln a =0\""], ["proof (prove)\nusing this:\n  b * ln a = 0\n\ngoal (1 subgoal):\n 1. b = 0 \\<or> ln a = 0", "by auto"], ["proof (state)\nthis:\n  b = 0 \\<or> ln a = 0\n\ngoal (2 subgoals):\n 1. a powr b = 1 \\<Longrightarrow> a = 1 \\<or> b = 0\n 2. a = 1 \\<or> b = 0 \\<Longrightarrow> a powr b = 1", "then"], ["proof (chain)\npicking this:\n  b = 0 \\<or> ln a = 0", "show \"a = 1 \\<or> b = 0\""], ["proof (prove)\nusing this:\n  b = 0 \\<or> ln a = 0\n\ngoal (1 subgoal):\n 1. a = 1 \\<or> b = 0", "using assms"], ["proof (prove)\nusing this:\n  b = 0 \\<or> ln a = 0\n  0 < a\n\ngoal (1 subgoal):\n 1. a = 1 \\<or> b = 0", "by auto"], ["proof (state)\nthis:\n  a = 1 \\<or> b = 0\n\ngoal (1 subgoal):\n 1. a = 1 \\<or> b = 0 \\<Longrightarrow> a powr b = 1", "qed (insert assms, auto)"], ["", "lemma tan_inj_pi:\n  \"- (pi/2) < x \\<Longrightarrow> x < pi/2 \\<Longrightarrow> - (pi/2) < y \\<Longrightarrow> y < pi/2 \\<Longrightarrow> tan x = tan y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- (pi / 2) < x; x < pi / 2; - (pi / 2) < y; y < pi / 2;\n     tan x = tan y\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (metis arctan_tan)"], ["", "(*TODO: can we avoid fcompose in the proof?*)"], ["", "lemma finite_ReZ_segments_poly_circlepath:\n          \"finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "proof (cases \"\\<forall>t\\<in>({0..1} - {1/2}). Re ((poly p \\<circ> circlepath z0 r) t) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{0..1} - {1 / 2}.\n       Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0\n 2. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "case True"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0..1} - {1 / 2}.\n     Re ((poly p \\<circ> circlepath z0 r) t) = 0\n\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{0..1} - {1 / 2}.\n       Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0\n 2. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "have \"isCont (Re \\<circ> poly p \\<circ> circlepath z0 r) (1/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (Re \\<circ> poly p \\<circ> circlepath z0 r) (1 / 2)", "by (auto intro!:continuous_intros simp:circlepath)"], ["proof (state)\nthis:\n  isCont (Re \\<circ> poly p \\<circ> circlepath z0 r) (1 / 2)\n\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{0..1} - {1 / 2}.\n       Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0\n 2. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "moreover"], ["proof (state)\nthis:\n  isCont (Re \\<circ> poly p \\<circ> circlepath z0 r) (1 / 2)\n\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{0..1} - {1 / 2}.\n       Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0\n 2. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "have \"(Re \\<circ> poly p \\<circ> circlepath z0 r)\\<midarrow> 1/2 \\<rightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re \\<circ> poly p \\<circ> circlepath z0 r) \\<midarrow>1 / 2\n    \\<rightarrow> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Re \\<circ> poly p \\<circ> circlepath z0 r) \\<midarrow>1 / 2\n    \\<rightarrow> 0", "have \"\\<forall>\\<^sub>F x in at (1 / 2). (Re \\<circ> poly p \\<circ> circlepath z0 r) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at (1 / 2).\n       (Re \\<circ> poly p \\<circ> circlepath z0 r) x = 0", "unfolding eventually_at_le"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d>0.\n       \\<forall>x\\<in>UNIV.\n          x \\<noteq> 1 / 2 \\<and> dist x (1 / 2) \\<le> d \\<longrightarrow>\n          (Re \\<circ> poly p \\<circ> circlepath z0 r) x = 0", "apply (rule exI[where x=\"1/2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 / 2 \\<and>\n    (\\<forall>x\\<in>UNIV.\n        x \\<noteq> 1 / 2 \\<and> dist x (1 / 2) \\<le> 1 / 2 \\<longrightarrow>\n        (Re \\<circ> poly p \\<circ> circlepath z0 r) x = 0)", "unfolding dist_real_def abs_diff_le_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 / 2 \\<and>\n    (\\<forall>x\\<in>UNIV.\n        x \\<noteq> 1 / 2 \\<and>\n        1 / 2 - 1 / 2 \\<le> x \\<and> x \\<le> 1 / 2 + 1 / 2 \\<longrightarrow>\n        (Re \\<circ> poly p \\<circ> circlepath z0 r) x = 0)", "by (auto intro!:True[rule_format, unfolded comp_def])"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at (1 / 2).\n     (Re \\<circ> poly p \\<circ> circlepath z0 r) x = 0\n\ngoal (1 subgoal):\n 1. (Re \\<circ> poly p \\<circ> circlepath z0 r) \\<midarrow>1 / 2\n    \\<rightarrow> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at (1 / 2).\n     (Re \\<circ> poly p \\<circ> circlepath z0 r) x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at (1 / 2).\n     (Re \\<circ> poly p \\<circ> circlepath z0 r) x = 0\n\ngoal (1 subgoal):\n 1. (Re \\<circ> poly p \\<circ> circlepath z0 r) \\<midarrow>1 / 2\n    \\<rightarrow> 0", "by (rule tendsto_eventually)"], ["proof (state)\nthis:\n  (Re \\<circ> poly p \\<circ> circlepath z0 r) \\<midarrow>1 / 2\n  \\<rightarrow> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Re \\<circ> poly p \\<circ> circlepath z0 r) \\<midarrow>1 / 2\n  \\<rightarrow> 0\n\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{0..1} - {1 / 2}.\n       Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0\n 2. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "ultimately"], ["proof (chain)\npicking this:\n  isCont (Re \\<circ> poly p \\<circ> circlepath z0 r) (1 / 2)\n  (Re \\<circ> poly p \\<circ> circlepath z0 r) \\<midarrow>1 / 2\n  \\<rightarrow> 0", "have \"Re ((poly p \\<circ> circlepath z0 r) (1/2)) = 0\""], ["proof (prove)\nusing this:\n  isCont (Re \\<circ> poly p \\<circ> circlepath z0 r) (1 / 2)\n  (Re \\<circ> poly p \\<circ> circlepath z0 r) \\<midarrow>1 / 2\n  \\<rightarrow> 0\n\ngoal (1 subgoal):\n 1. Re ((poly p \\<circ> circlepath z0 r) (1 / 2)) = 0", "unfolding comp_def"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>x. Re (poly p (circlepath z0 r x))) (1 / 2)\n  (\\<lambda>x. Re (poly p (circlepath z0 r x))) \\<midarrow>1 / 2\n  \\<rightarrow> 0\n\ngoal (1 subgoal):\n 1. Re (poly p (circlepath z0 r (1 / 2))) = 0", "by (simp add: LIM_unique continuous_within)"], ["proof (state)\nthis:\n  Re ((poly p \\<circ> circlepath z0 r) (1 / 2)) = 0\n\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{0..1} - {1 / 2}.\n       Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0\n 2. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "then"], ["proof (chain)\npicking this:\n  Re ((poly p \\<circ> circlepath z0 r) (1 / 2)) = 0", "have \"\\<forall>t\\<in>{0..1}. Re ((poly p \\<circ> circlepath z0 r) t) = 0\""], ["proof (prove)\nusing this:\n  Re ((poly p \\<circ> circlepath z0 r) (1 / 2)) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{0..1}. Re ((poly p \\<circ> circlepath z0 r) t) = 0", "using True"], ["proof (prove)\nusing this:\n  Re ((poly p \\<circ> circlepath z0 r) (1 / 2)) = 0\n  \\<forall>t\\<in>{0..1} - {1 / 2}.\n     Re ((poly p \\<circ> circlepath z0 r) t) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>{0..1}. Re ((poly p \\<circ> circlepath z0 r) t) = 0", "by blast"], ["proof (state)\nthis:\n  \\<forall>t\\<in>{0..1}. Re ((poly p \\<circ> circlepath z0 r) t) = 0\n\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{0..1} - {1 / 2}.\n       Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0\n 2. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>{0..1}. Re ((poly p \\<circ> circlepath z0 r) t) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>{0..1}. Re ((poly p \\<circ> circlepath z0 r) t) = 0\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "apply (rule_tac finite_ReZ_segments_constI[THEN finite_ReZ_segments_congE])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>t\\<in>{0..1}.\n       Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<Longrightarrow>\n    \\<forall>t. 0 < t \\<and> t < 1 \\<longrightarrow> ?p1.1 t = ?c2\n 2. \\<And>t.\n       \\<lbrakk>\\<forall>t\\<in>{0..1}.\n                   Re ((poly p \\<circ> circlepath z0 r) t) = 0;\n        0 < t; t < 1\\<rbrakk>\n       \\<Longrightarrow> Re (?p1.1 t - ?z1.1) =\n                         Re ((poly p \\<circ> circlepath z0 r) t - 0)", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n             Re ((poly p \\<circ> circlepath z0 r) t) = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "define q1 q2 where \"q1=fcompose p [:(z0+r)*\\<i>,z0-r:] [:\\<i>,1:]\" and \n                      \"q2=([:\\<i>, 1:] ^ degree p)\""], ["proof (state)\nthis:\n  q1 =\n  fcompose p [:(z0 + complex_of_real r) * \\<i>, z0 - complex_of_real r:]\n   [:\\<i>, 1:]\n  q2 = [:\\<i>, 1:] ^ degree p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "define q1R q1I where \"q1R=map_poly Re q1\" and \"q1I=map_poly Im q1\""], ["proof (state)\nthis:\n  q1R = map_poly Re q1\n  q1I = map_poly Im q1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "define q2R q2I where \"q2R=map_poly Re q2\" and \"q2I=map_poly Im q2\""], ["proof (state)\nthis:\n  q2R = map_poly Re q2\n  q2I = map_poly Im q2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "define qq where \"qq=q1R*q2R + q1I*q2I\""], ["proof (state)\nthis:\n  qq = q1R * q2R + q1I * q2I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "have poly_eq:\"Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<longleftrightarrow> poly qq (tan (pi * t)) = 0\"\n    when \"0\\<le>t\" \"t\\<le>1\" \"t\\<noteq>1/2\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n    (poly qq (tan (pi * t)) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n    (poly qq (tan (pi * t)) = 0)", "define tt where \"tt=tan (pi * t)\""], ["proof (state)\nthis:\n  tt = tan (pi * t)\n\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n    (poly qq (tan (pi * t)) = 0)", "have \"Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<longleftrightarrow> Re (poly q1 tt / poly q2 tt) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n    (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0)", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re (poly p (circlepath z0 r t)) = 0) =\n    (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0)", "apply (subst poly_circlepath_tan_eq[of t p z0 r,folded q1_def q2_def tt_def])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<le> t\n 2. t \\<le> 1\n 3. t \\<noteq> 1 / 2\n 4. (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0) =\n    (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0)", "using that"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  t \\<le> 1\n  t \\<noteq> 1 / 2\n\ngoal (4 subgoals):\n 1. 0 \\<le> t\n 2. t \\<le> 1\n 3. t \\<noteq> 1 / 2\n 4. (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0) =\n    (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0)", "by simp_all"], ["proof (state)\nthis:\n  (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n  (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0)\n\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n    (poly qq (tan (pi * t)) = 0)", "also"], ["proof (state)\nthis:\n  (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n  (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0)\n\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n    (poly qq (tan (pi * t)) = 0)", "have \"... \\<longleftrightarrow> poly q1R tt * poly q2R tt + poly q1I tt * poly q2I tt = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0) =\n    (poly q1R tt * poly q2R tt + poly q1I tt * poly q2I tt = 0)", "unfolding q1I_def q1R_def q2R_def q2I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0) =\n    (poly (map_poly Re q1) tt * poly (map_poly Re q2) tt +\n     poly (map_poly Im q1) tt * poly (map_poly Im q2) tt =\n     0)", "by (simp add:Re_complex_div_eq_0 Re_poly_of_real Im_poly_of_real)"], ["proof (state)\nthis:\n  (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0) =\n  (poly q1R tt * poly q2R tt + poly q1I tt * poly q2I tt = 0)\n\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n    (poly qq (tan (pi * t)) = 0)", "also"], ["proof (state)\nthis:\n  (Re (poly q1 (complex_of_real tt) / poly q2 (complex_of_real tt)) = 0) =\n  (poly q1R tt * poly q2R tt + poly q1I tt * poly q2I tt = 0)\n\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n    (poly qq (tan (pi * t)) = 0)", "have \"... \\<longleftrightarrow> poly qq tt = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly q1R tt * poly q2R tt + poly q1I tt * poly q2I tt = 0) =\n    (poly qq tt = 0)", "unfolding qq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly q1R tt * poly q2R tt + poly q1I tt * poly q2I tt = 0) =\n    (poly (q1R * q2R + q1I * q2I) tt = 0)", "by simp"], ["proof (state)\nthis:\n  (poly q1R tt * poly q2R tt + poly q1I tt * poly q2I tt = 0) =\n  (poly qq tt = 0)\n\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n    (poly qq (tan (pi * t)) = 0)", "finally"], ["proof (chain)\npicking this:\n  (Re ((poly p \\<circ> circlepath z0 r) t) = 0) = (poly qq tt = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Re ((poly p \\<circ> circlepath z0 r) t) = 0) = (poly qq tt = 0)\n\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n    (poly qq (tan (pi * t)) = 0)", "unfolding tt_def"], ["proof (prove)\nusing this:\n  (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n  (poly qq (tan (pi * t)) = 0)\n\ngoal (1 subgoal):\n 1. (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n    (poly qq (tan (pi * t)) = 0)", "."], ["proof (state)\nthis:\n  (Re ((poly p \\<circ> circlepath z0 r) t) = 0) =\n  (poly qq (tan (pi * t)) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?t; ?t \\<le> 1; ?t \\<noteq> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> (Re ((poly p \\<circ> circlepath z0 r) ?t) = 0) =\n                    (poly qq (tan (pi * ?t)) = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "have \"finite {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "define P where \"P=(\\<lambda>t. Re ((poly p \\<circ> circlepath z0 r) t) = 0)\""], ["proof (state)\nthis:\n  P = (\\<lambda>t. Re ((poly p \\<circ> circlepath z0 r) t) = 0)\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "define A where \"A= ({0..1}::real set)\""], ["proof (state)\nthis:\n  A = {0..1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "define S where \"S={t\\<in>A-{1,1/2}. P t}\""], ["proof (state)\nthis:\n  S = {t \\<in> A - {1, 1 / 2}. P t}\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "have \"finite {t. poly qq (tan (pi * t)) = 0 \\<and> 0 \\<le> t \\<and> t < 1 \\<and> t\\<noteq>1/2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. poly qq (tan (pi * t)) = 0 \\<and>\n         0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {t. poly qq (tan (pi * t)) = 0 \\<and>\n         0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}", "define A where \"A={t::real. 0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}\""], ["proof (state)\nthis:\n  A = {t. 0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}\n\ngoal (1 subgoal):\n 1. finite\n     {t. poly qq (tan (pi * t)) = 0 \\<and>\n         0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}", "have \"finite ((\\<lambda>t. tan (pi * t))  -`  {x. poly qq x=0} \\<inter> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>t. tan (pi * t)) -` {x. poly qq x = 0} \\<inter> A)", "proof (rule finite_vimage_IntI)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {x. poly qq x = 0}\n 2. inj_on (\\<lambda>t. tan (pi * t)) A", "have \"x = y\" when \"tan (pi * x) = tan (pi * y)\" \"x\\<in>A\" \"y\\<in>A\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "define x' where \"x'=(if x<1/2 then x else x-1)\""], ["proof (state)\nthis:\n  x' = (if x < 1 / 2 then x else x - 1)\n\ngoal (1 subgoal):\n 1. x = y", "define y' where \"y'=(if y<1/2 then y else y-1)\""], ["proof (state)\nthis:\n  y' = (if y < 1 / 2 then y else y - 1)\n\ngoal (1 subgoal):\n 1. x = y", "have \"x'*pi = y'*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' * pi = y' * pi", "proof (rule tan_inj_pi)"], ["proof (state)\ngoal (5 subgoals):\n 1. - (pi / 2) < x' * pi\n 2. x' * pi < pi / 2\n 3. - (pi / 2) < y' * pi\n 4. y' * pi < pi / 2\n 5. tan (x' * pi) = tan (y' * pi)", "have *:\"- 1 / 2 < x'\" \"x' < 1 / 2\" \"- 1 / 2 < y'\" \"y' < 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1 / 2 < x' &&& x' < 1 / 2) &&& - 1 / 2 < y' &&& y' < 1 / 2", "using that(2,3)"], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. (- 1 / 2 < x' &&& x' < 1 / 2) &&& - 1 / 2 < y' &&& y' < 1 / 2", "unfolding x'_def y'_def A_def"], ["proof (prove)\nusing this:\n  x \\<in> {t. 0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}\n  y \\<in> {t. 0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}\n\ngoal (1 subgoal):\n 1. (- 1 / 2 < (if x < 1 / 2 then x else x - 1) &&&\n     (if x < 1 / 2 then x else x - 1) < 1 / 2) &&&\n    - 1 / 2 < (if y < 1 / 2 then y else y - 1) &&&\n    (if y < 1 / 2 then y else y - 1) < 1 / 2", "by simp_all"], ["proof (state)\nthis:\n  - 1 / 2 < x'\n  x' < 1 / 2\n  - 1 / 2 < y'\n  y' < 1 / 2\n\ngoal (5 subgoals):\n 1. - (pi / 2) < x' * pi\n 2. x' * pi < pi / 2\n 3. - (pi / 2) < y' * pi\n 4. y' * pi < pi / 2\n 5. tan (x' * pi) = tan (y' * pi)", "show \"- (pi / 2) < x'  * pi\" \"x'  * pi < pi / 2\" \"- (pi / 2) < y'  * pi\" \n                  \"y'*pi < pi / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (pi / 2) < x' * pi &&& x' * pi < pi / 2) &&&\n    - (pi / 2) < y' * pi &&& y' * pi < pi / 2", "using mult_strict_right_mono[OF *(1),of pi] \n                    mult_strict_right_mono[OF *(2),of pi] \n                    mult_strict_right_mono[OF *(3),of pi] \n                    mult_strict_right_mono[OF *(4),of pi]"], ["proof (prove)\nusing this:\n  0 < pi \\<Longrightarrow> - 1 / 2 * pi < x' * pi\n  0 < pi \\<Longrightarrow> x' * pi < 1 / 2 * pi\n  0 < pi \\<Longrightarrow> - 1 / 2 * pi < y' * pi\n  0 < pi \\<Longrightarrow> y' * pi < 1 / 2 * pi\n\ngoal (1 subgoal):\n 1. (- (pi / 2) < x' * pi &&& x' * pi < pi / 2) &&&\n    - (pi / 2) < y' * pi &&& y' * pi < pi / 2", "by auto"], ["proof (state)\nthis:\n  - (pi / 2) < x' * pi\n  x' * pi < pi / 2\n  - (pi / 2) < y' * pi\n  y' * pi < pi / 2\n\ngoal (1 subgoal):\n 1. tan (x' * pi) = tan (y' * pi)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tan (x' * pi) = tan (y' * pi)", "have \"tan (x' * pi) = tan (x * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tan (x' * pi) = tan (x * pi)", "unfolding x'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tan ((if x < 1 / 2 then x else x - 1) * pi) = tan (x * pi)", "using tan_periodic_int[of _ \"- 1\",simplified]"], ["proof (prove)\nusing this:\n  tan (?x - pi) = tan ?x\n\ngoal (1 subgoal):\n 1. tan ((if x < 1 / 2 then x else x - 1) * pi) = tan (x * pi)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  tan (x' * pi) = tan (x * pi)\n\ngoal (1 subgoal):\n 1. tan (x' * pi) = tan (y' * pi)", "also"], ["proof (state)\nthis:\n  tan (x' * pi) = tan (x * pi)\n\ngoal (1 subgoal):\n 1. tan (x' * pi) = tan (y' * pi)", "have \"... = tan (y * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tan (x * pi) = tan (y * pi)", "using \\<open>tan (pi * x) = tan (pi * y)\\<close>"], ["proof (prove)\nusing this:\n  tan (pi * x) = tan (pi * y)\n\ngoal (1 subgoal):\n 1. tan (x * pi) = tan (y * pi)", "by (auto simp:algebra_simps)"], ["proof (state)\nthis:\n  tan (x * pi) = tan (y * pi)\n\ngoal (1 subgoal):\n 1. tan (x' * pi) = tan (y' * pi)", "also"], ["proof (state)\nthis:\n  tan (x * pi) = tan (y * pi)\n\ngoal (1 subgoal):\n 1. tan (x' * pi) = tan (y' * pi)", "have \"... = tan (y' * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tan (y * pi) = tan (y' * pi)", "unfolding y'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tan (y * pi) = tan ((if y < 1 / 2 then y else y - 1) * pi)", "using tan_periodic_int[of _ \"- 1\",simplified]"], ["proof (prove)\nusing this:\n  tan (?x - pi) = tan ?x\n\ngoal (1 subgoal):\n 1. tan (y * pi) = tan ((if y < 1 / 2 then y else y - 1) * pi)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  tan (y * pi) = tan (y' * pi)\n\ngoal (1 subgoal):\n 1. tan (x' * pi) = tan (y' * pi)", "finally"], ["proof (chain)\npicking this:\n  tan (x' * pi) = tan (y' * pi)", "show \"tan (x' * pi) = tan (y' * pi)\""], ["proof (prove)\nusing this:\n  tan (x' * pi) = tan (y' * pi)\n\ngoal (1 subgoal):\n 1. tan (x' * pi) = tan (y' * pi)", "."], ["proof (state)\nthis:\n  tan (x' * pi) = tan (y' * pi)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x' * pi = y' * pi\n\ngoal (1 subgoal):\n 1. x = y", "then"], ["proof (chain)\npicking this:\n  x' * pi = y' * pi", "have \"x'=y'\""], ["proof (prove)\nusing this:\n  x' * pi = y' * pi\n\ngoal (1 subgoal):\n 1. x' = y'", "by auto"], ["proof (state)\nthis:\n  x' = y'\n\ngoal (1 subgoal):\n 1. x = y", "then"], ["proof (chain)\npicking this:\n  x' = y'", "show ?thesis"], ["proof (prove)\nusing this:\n  x' = y'\n\ngoal (1 subgoal):\n 1. x = y", "using that(2,3)"], ["proof (prove)\nusing this:\n  x' = y'\n  x \\<in> A\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. x = y", "unfolding x'_def y'_def A_def"], ["proof (prove)\nusing this:\n  (if x < 1 / 2 then x else x - 1) = (if y < 1 / 2 then y else y - 1)\n  x \\<in> {t. 0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}\n  y \\<in> {t. 0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}\n\ngoal (1 subgoal):\n 1. x = y", "by (auto split:if_splits)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>tan (pi * ?x) = tan (pi * ?y); ?x \\<in> A; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (2 subgoals):\n 1. finite {x. poly qq x = 0}\n 2. inj_on (\\<lambda>t. tan (pi * t)) A", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>tan (pi * ?x) = tan (pi * ?y); ?x \\<in> A; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y", "show \"inj_on (\\<lambda>t. tan (pi * t)) A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tan (pi * ?x) = tan (pi * ?y); ?x \\<in> A; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>t. tan (pi * t)) A", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>tan (pi * ?x) = tan (pi * ?y); ?x \\<in> A; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. tan (pi * x) = tan (pi * y) \\<longrightarrow> x = y", "by blast"], ["proof (state)\nthis:\n  inj_on (\\<lambda>t. tan (pi * t)) A\n\ngoal (1 subgoal):\n 1. finite {x. poly qq x = 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. poly qq x = 0}", "have \"qq\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qq \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> qq \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> qq \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> qq \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> qq \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> qq \\<noteq> 0", "have \"Re ((poly p \\<circ> circlepath z0 r) t) = 0\" when \"t\\<in>{0..1} - {1/2}\" for t"], ["proof (prove)\nusing this:\n  \\<not> qq \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re ((poly p \\<circ> circlepath z0 r) t) = 0", "apply (subst poly_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<not> qq \\<noteq> 0 \\<Longrightarrow> 0 \\<le> t\n 2. \\<not> qq \\<noteq> 0 \\<Longrightarrow> t \\<le> 1\n 3. \\<not> qq \\<noteq> 0 \\<Longrightarrow> t \\<noteq> 1 / 2\n 4. \\<not> qq \\<noteq> 0 \\<Longrightarrow> poly qq (tan (pi * t)) = 0", "using that"], ["proof (prove)\nusing this:\n  t \\<in> {0..1} - {1 / 2}\n\ngoal (4 subgoals):\n 1. \\<not> qq \\<noteq> 0 \\<Longrightarrow> 0 \\<le> t\n 2. \\<not> qq \\<noteq> 0 \\<Longrightarrow> t \\<le> 1\n 3. \\<not> qq \\<noteq> 0 \\<Longrightarrow> t \\<noteq> 1 / 2\n 4. \\<not> qq \\<noteq> 0 \\<Longrightarrow> poly qq (tan (pi * t)) = 0", "by auto"], ["proof (state)\nthis:\n  ?t \\<in> {0..1} - {1 / 2} \\<Longrightarrow>\n  Re ((poly p \\<circ> circlepath z0 r) ?t) = 0\n\ngoal (1 subgoal):\n 1. \\<not> qq \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?t \\<in> {0..1} - {1 / 2} \\<Longrightarrow>\n  Re ((poly p \\<circ> circlepath z0 r) ?t) = 0", "show False"], ["proof (prove)\nusing this:\n  ?t \\<in> {0..1} - {1 / 2} \\<Longrightarrow>\n  Re ((poly p \\<circ> circlepath z0 r) ?t) = 0\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  ?t \\<in> {0..1} - {1 / 2} \\<Longrightarrow>\n  Re ((poly p \\<circ> circlepath z0 r) ?t) = 0\n  \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n             Re ((poly p \\<circ> circlepath z0 r) t) = 0)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  qq \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite {x. poly qq x = 0}", "then"], ["proof (chain)\npicking this:\n  qq \\<noteq> 0", "show \"finite {x. poly qq x = 0}\""], ["proof (prove)\nusing this:\n  qq \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite {x. poly qq x = 0}", "by (simp add: poly_roots_finite)"], ["proof (state)\nthis:\n  finite {x. poly qq x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ((\\<lambda>t. tan (pi * t)) -` {x. poly qq x = 0} \\<inter> A)\n\ngoal (1 subgoal):\n 1. finite\n     {t. poly qq (tan (pi * t)) = 0 \\<and>\n         0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}", "then"], ["proof (chain)\npicking this:\n  finite ((\\<lambda>t. tan (pi * t)) -` {x. poly qq x = 0} \\<inter> A)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite ((\\<lambda>t. tan (pi * t)) -` {x. poly qq x = 0} \\<inter> A)\n\ngoal (1 subgoal):\n 1. finite\n     {t. poly qq (tan (pi * t)) = 0 \\<and>\n         0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}", "by (elim rev_finite_subset) (auto simp:A_def)"], ["proof (state)\nthis:\n  finite\n   {t. poly qq (tan (pi * t)) = 0 \\<and>\n       0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {t. poly qq (tan (pi * t)) = 0 \\<and>\n       0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "moreover"], ["proof (state)\nthis:\n  finite\n   {t. poly qq (tan (pi * t)) = 0 \\<and>\n       0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "have \"{t. poly qq (tan (pi * t)) = 0 \\<and> 0 \\<le> t \\<and> t < 1 \\<and> t\\<noteq>1/2} = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. poly qq (tan (pi * t)) = 0 \\<and>\n        0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2} =\n    S", "unfolding S_def P_def A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. poly qq (tan (pi * t)) = 0 \\<and>\n        0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2} =\n    {t \\<in> {0..1} - {1, 1 / 2}.\n     Re ((poly p \\<circ> circlepath z0 r) t) = 0}", "using poly_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?t; ?t \\<le> 1; ?t \\<noteq> 1 / 2\\<rbrakk>\n  \\<Longrightarrow> (Re ((poly p \\<circ> circlepath z0 r) ?t) = 0) =\n                    (poly qq (tan (pi * ?t)) = 0)\n\ngoal (1 subgoal):\n 1. {t. poly qq (tan (pi * t)) = 0 \\<and>\n        0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2} =\n    {t \\<in> {0..1} - {1, 1 / 2}.\n     Re ((poly p \\<circ> circlepath z0 r) t) = 0}", "by force"], ["proof (state)\nthis:\n  {t. poly qq (tan (pi * t)) = 0 \\<and>\n      0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2} =\n  S\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   {t. poly qq (tan (pi * t)) = 0 \\<and>\n       0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}\n  {t. poly qq (tan (pi * t)) = 0 \\<and>\n      0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2} =\n  S", "have \"finite S\""], ["proof (prove)\nusing this:\n  finite\n   {t. poly qq (tan (pi * t)) = 0 \\<and>\n       0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2}\n  {t. poly qq (tan (pi * t)) = 0 \\<and>\n      0 \\<le> t \\<and> t < 1 \\<and> t \\<noteq> 1 / 2} =\n  S\n\ngoal (1 subgoal):\n 1. finite S", "by blast"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "then"], ["proof (chain)\npicking this:\n  finite S", "have \"finite (S \\<union> (if P 1 then {1} else {}) \\<union> (if P (1/2) then {1/2} else {}))\""], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. finite\n     (S \\<union> (if P 1 then {1} else {}) \\<union>\n      (if P (1 / 2) then {1 / 2} else {}))", "by auto"], ["proof (state)\nthis:\n  finite\n   (S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}))\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "moreover"], ["proof (state)\nthis:\n  finite\n   (S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}))\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "have \"(S \\<union> (if P 1 then {1} else {}) \\<union> (if P (1/2) then {1/2} else {}))\n                      = {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}) =\n    {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}) =\n    {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "have \"1\\<in>A\" \"1/2 \\<in>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> A &&& 1 / 2 \\<in> A", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> {0..1} &&& 1 / 2 \\<in> {0..1}", "by auto"], ["proof (state)\nthis:\n  1 \\<in> A\n  1 / 2 \\<in> A\n\ngoal (1 subgoal):\n 1. S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}) =\n    {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "then"], ["proof (chain)\npicking this:\n  1 \\<in> A\n  1 / 2 \\<in> A", "have \"(S \\<union> (if P 1 then {1} else {}) \\<union> (if P (1/2) then {1/2} else {}))\n                      = {t\\<in>A. P t}\""], ["proof (prove)\nusing this:\n  1 \\<in> A\n  1 / 2 \\<in> A\n\ngoal (1 subgoal):\n 1. S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}) =\n    {t \\<in> A. P t}", "unfolding S_def"], ["proof (prove)\nusing this:\n  1 \\<in> A\n  1 / 2 \\<in> A\n\ngoal (1 subgoal):\n 1. {t \\<in> A - {1, 1 / 2}. P t} \\<union>\n    (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}) =\n    {t \\<in> A. P t}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>1 \\<in> A; 1 / 2 \\<in> A; P 1; \\<not> P (1 / 2); x \\<in> A;\n        P x; x * 2 = 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>1 \\<in> A; 1 / 2 \\<in> A; \\<not> P 1; \\<not> P (1 / 2);\n        x \\<in> A; P x; x * 2 = 1\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis eq_divide_eq_numeral1(1) zero_neq_numeral)+"], ["proof (state)\nthis:\n  S \\<union> (if P 1 then {1} else {}) \\<union>\n  (if P (1 / 2) then {1 / 2} else {}) =\n  {t \\<in> A. P t}\n\ngoal (1 subgoal):\n 1. S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}) =\n    {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "also"], ["proof (state)\nthis:\n  S \\<union> (if P 1 then {1} else {}) \\<union>\n  (if P (1 / 2) then {1 / 2} else {}) =\n  {t \\<in> A. P t}\n\ngoal (1 subgoal):\n 1. S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}) =\n    {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "have \"... = {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> A. P t} = {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> {0..1}. P t} = {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  {t \\<in> A. P t} = {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}) =\n    {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "finally"], ["proof (chain)\npicking this:\n  S \\<union> (if P 1 then {1} else {}) \\<union>\n  (if P (1 / 2) then {1 / 2} else {}) =\n  {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  S \\<union> (if P 1 then {1} else {}) \\<union>\n  (if P (1 / 2) then {1 / 2} else {}) =\n  {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}) =\n    {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "."], ["proof (state)\nthis:\n  S \\<union> (if P 1 then {1} else {}) \\<union>\n  (if P (1 / 2) then {1 / 2} else {}) =\n  {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> (if P 1 then {1} else {}) \\<union>\n  (if P (1 / 2) then {1 / 2} else {}) =\n  {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   (S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}))\n  S \\<union> (if P 1 then {1} else {}) \\<union>\n  (if P (1 / 2) then {1 / 2} else {}) =\n  {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "have \"finite {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}\""], ["proof (prove)\nusing this:\n  finite\n   (S \\<union> (if P 1 then {1} else {}) \\<union>\n    (if P (1 / 2) then {1 / 2} else {}))\n  S \\<union> (if P 1 then {1} else {}) \\<union>\n  (if P (1 / 2) then {1 / 2} else {}) =\n  {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  finite {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "then"], ["proof (chain)\npicking this:\n  finite {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {t. P t \\<and> 0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "unfolding P_def"], ["proof (prove)\nusing this:\n  finite\n   {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by simp"], ["proof (state)\nthis:\n  finite\n   {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t\\<in>{0..1} - {1 / 2}.\n               Re ((poly p \\<circ> circlepath z0 r) t) =\n               0) \\<Longrightarrow>\n    finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "then"], ["proof (chain)\npicking this:\n  finite\n   {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite\n   {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n       0 \\<le> t \\<and> t \\<le> 1}\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0", "apply (rule_tac finite_imp_finite_ReZ_segments)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1} \\<Longrightarrow>\n    finite\n     {t. Re ((poly p \\<circ> circlepath z0 r) t - 0) = 0 \\<and>\n         0 \\<le> t \\<and> t \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  finite_ReZ_segments (poly p \\<circ> circlepath z0 r) 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Some useful conformal/@{term bij_betw} properties\\<close>"], ["", "lemma bij_betw_plane_ball:\"bij_betw (\\<lambda>x. (\\<i>-x)/(\\<i>+x)) {x. Im x>0} (ball 0 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. 0 < Im x} (ball 0 1)", "proof (rule bij_betw_imageI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. 0 < Im x}\n 2. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x} = ball 0 1", "have neq:\"\\<i> + x \\<noteq>0\" when \"Im x>0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> + x \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  0 < Im x\n\ngoal (1 subgoal):\n 1. \\<i> + x \\<noteq> 0", "by (metis add_less_same_cancel2 add_uminus_conv_diff diff_0 diff_add_cancel \n        imaginary_unit.simps(2) not_one_less_zero uminus_complex.sel(2))"], ["proof (state)\nthis:\n  0 < Im ?x \\<Longrightarrow> \\<i> + ?x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. 0 < Im x}\n 2. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x} = ball 0 1", "then"], ["proof (chain)\npicking this:\n  0 < Im ?x \\<Longrightarrow> \\<i> + ?x \\<noteq> 0", "show \"inj_on (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. 0 < Im x}\""], ["proof (prove)\nusing this:\n  0 < Im ?x \\<Longrightarrow> \\<i> + ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. 0 < Im x}", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  0 < Im ?x \\<Longrightarrow> \\<i> + ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. 0 < Im x}.\n       \\<forall>y\\<in>{x. 0 < Im x}.\n          (\\<i> - x) / (\\<i> + x) =\n          (\\<i> - y) / (\\<i> + y) \\<longrightarrow>\n          x = y", "by (auto simp add:divide_simps algebra_simps)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x} = ball 0 1", "have \"cmod ((\\<i> - x) / (\\<i> + x)) < 1\" when \"0 < Im x \" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod ((\\<i> - x) / (\\<i> + x)) < 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod ((\\<i> - x) / (\\<i> + x)) < 1", "have \"cmod (\\<i> - x) < cmod (\\<i> + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<i> - x) < cmod (\\<i> + x)", "unfolding norm_lt inner_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (\\<i> - x) * Re (\\<i> - x) + Im (\\<i> - x) * Im (\\<i> - x)\n    < Re (\\<i> + x) * Re (\\<i> + x) + Im (\\<i> + x) * Im (\\<i> + x)", "using that"], ["proof (prove)\nusing this:\n  0 < Im x\n\ngoal (1 subgoal):\n 1. Re (\\<i> - x) * Re (\\<i> - x) + Im (\\<i> - x) * Im (\\<i> - x)\n    < Re (\\<i> + x) * Re (\\<i> + x) + Im (\\<i> + x) * Im (\\<i> + x)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cmod (\\<i> - x) < cmod (\\<i> + x)\n\ngoal (1 subgoal):\n 1. cmod ((\\<i> - x) / (\\<i> + x)) < 1", "then"], ["proof (chain)\npicking this:\n  cmod (\\<i> - x) < cmod (\\<i> + x)", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (\\<i> - x) < cmod (\\<i> + x)\n\ngoal (1 subgoal):\n 1. cmod ((\\<i> - x) / (\\<i> + x)) < 1", "unfolding norm_divide"], ["proof (prove)\nusing this:\n  cmod (\\<i> - x) < cmod (\\<i> + x)\n\ngoal (1 subgoal):\n 1. cmod (\\<i> - x) / cmod (\\<i> + x) < 1", "using neq[OF that]"], ["proof (prove)\nusing this:\n  cmod (\\<i> - x) < cmod (\\<i> + x)\n  \\<i> + x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod (\\<i> - x) / cmod (\\<i> + x) < 1", "by auto"], ["proof (state)\nthis:\n  cmod ((\\<i> - x) / (\\<i> + x)) < 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < Im ?x \\<Longrightarrow> cmod ((\\<i> - ?x) / (\\<i> + ?x)) < 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x} = ball 0 1", "moreover"], ["proof (state)\nthis:\n  0 < Im ?x \\<Longrightarrow> cmod ((\\<i> - ?x) / (\\<i> + ?x)) < 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x} = ball 0 1", "have \"x \\<in> (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x}\" when \"cmod x < 1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x}", "proof (rule rev_image_eqI[of \"\\<i>*(1-x)/(1+x)\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<i> * (1 - x) / (1 + x) \\<in> {x. 0 < Im x}\n 2. x =\n    (\\<i> - \\<i> * (1 - x) / (1 + x)) / (\\<i> + \\<i> * (1 - x) / (1 + x))", "have \"1 + x\\<noteq>0\" \"\\<i> * 2 + \\<i> * (x * 2) \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + x \\<noteq> 0 &&& \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + x \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  cmod x < 1\n\ngoal (1 subgoal):\n 1. 1 + x \\<noteq> 0", "by (metis complex_mod_triangle_sub norm_one norm_zero not_le pth_7(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  cmod x < 1\n\ngoal (1 subgoal):\n 1. \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0", "by (metis \\<open>1 + x \\<noteq> 0\\<close> complex_i_not_zero div_mult_self4 mult_2 \n            mult_zero_right nonzero_mult_div_cancel_left nonzero_mult_div_cancel_right \n            one_add_one zero_neq_numeral)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  1 + x \\<noteq> 0\n  \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<i> * (1 - x) / (1 + x) \\<in> {x. 0 < Im x}\n 2. x =\n    (\\<i> - \\<i> * (1 - x) / (1 + x)) / (\\<i> + \\<i> * (1 - x) / (1 + x))", "then"], ["proof (chain)\npicking this:\n  1 + x \\<noteq> 0\n  \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0", "show \"x = (\\<i> - \\<i> * (1 - x) / (1 + x)) / (\\<i> + \\<i> * (1 - x) / (1 + x))\""], ["proof (prove)\nusing this:\n  1 + x \\<noteq> 0\n  \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x =\n    (\\<i> - \\<i> * (1 - x) / (1 + x)) / (\\<i> + \\<i> * (1 - x) / (1 + x))", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  x = (\\<i> - \\<i> * (1 - x) / (1 + x)) / (\\<i> + \\<i> * (1 - x) / (1 + x))\n\ngoal (1 subgoal):\n 1. \\<i> * (1 - x) / (1 + x) \\<in> {x. 0 < Im x}", "show \" \\<i> * (1 - x) / (1 + x) \\<in> {x. 0 < Im x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> * (1 - x) / (1 + x) \\<in> {x. 0 < Im x}", "apply (auto simp:Im_complex_div_gt_0 algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x * Im x + Re x * Re x < 1", "using that"], ["proof (prove)\nusing this:\n  cmod x < 1\n\ngoal (1 subgoal):\n 1. Im x * Im x + Re x * Re x < 1", "unfolding cmod_def"], ["proof (prove)\nusing this:\n  sqrt ((Re x)\\<^sup>2 + (Im x)\\<^sup>2) < 1\n\ngoal (1 subgoal):\n 1. Im x * Im x + Re x * Re x < 1", "by (auto simp:power2_eq_square)"], ["proof (state)\nthis:\n  \\<i> * (1 - x) / (1 + x) \\<in> {x. 0 < Im x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmod ?x < 1 \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x} = ball 0 1", "ultimately"], ["proof (chain)\npicking this:\n  0 < Im ?x \\<Longrightarrow> cmod ((\\<i> - ?x) / (\\<i> + ?x)) < 1\n  cmod ?x < 1 \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x}", "show \"(\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x} = ball 0 1\""], ["proof (prove)\nusing this:\n  0 < Im ?x \\<Longrightarrow> cmod ((\\<i> - ?x) / (\\<i> + ?x)) < 1\n  cmod ?x < 1 \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x} = ball 0 1", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. 0 < Im x} = ball 0 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_axis_sphere:\"bij_betw (\\<lambda>x. (\\<i>-x)/(\\<i>+x)) {x. Im x=0} (sphere 0 1 - {-1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. Im x = 0}\n     (sphere 0 1 - {- 1})", "proof (rule bij_betw_imageI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. Im x = 0}\n 2. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. Im x = 0} =\n    sphere 0 1 - {- 1}", "have neq:\"\\<i> + x \\<noteq>0\" when \"Im x=0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> + x \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  Im x = 0\n\ngoal (1 subgoal):\n 1. \\<i> + x \\<noteq> 0", "by (metis add_diff_cancel_left' imaginary_unit.simps(2) minus_complex.simps(2) \n         right_minus_eq zero_complex.simps(2) zero_neq_one)"], ["proof (state)\nthis:\n  Im ?x = 0 \\<Longrightarrow> \\<i> + ?x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. Im x = 0}\n 2. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. Im x = 0} =\n    sphere 0 1 - {- 1}", "then"], ["proof (chain)\npicking this:\n  Im ?x = 0 \\<Longrightarrow> \\<i> + ?x \\<noteq> 0", "show \"inj_on (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. Im x = 0}\""], ["proof (prove)\nusing this:\n  Im ?x = 0 \\<Longrightarrow> \\<i> + ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. Im x = 0}", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  Im ?x = 0 \\<Longrightarrow> \\<i> + ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. Im x = 0}.\n       \\<forall>y\\<in>{x. Im x = 0}.\n          (\\<i> - x) / (\\<i> + x) =\n          (\\<i> - y) / (\\<i> + y) \\<longrightarrow>\n          x = y", "by (auto simp add:divide_simps algebra_simps)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. Im x = 0} =\n    sphere 0 1 - {- 1}", "have \"cmod ((\\<i> - x) / (\\<i> + x)) = 1\" \"(\\<i> - x) / (\\<i> + x) \\<noteq> - 1\" when \"Im x = 0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod ((\\<i> - x) / (\\<i> + x)) = 1 &&&\n    (\\<i> - x) / (\\<i> + x) \\<noteq> - 1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. cmod ((\\<i> - x) / (\\<i> + x)) = 1\n 2. (\\<i> - x) / (\\<i> + x) \\<noteq> - 1", "have \"cmod (\\<i> + x) = cmod (\\<i> - x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<i> + x) = cmod (\\<i> - x)", "using that"], ["proof (prove)\nusing this:\n  Im x = 0\n\ngoal (1 subgoal):\n 1. cmod (\\<i> + x) = cmod (\\<i> - x)", "unfolding cmod_def"], ["proof (prove)\nusing this:\n  Im x = 0\n\ngoal (1 subgoal):\n 1. sqrt ((Re (\\<i> + x))\\<^sup>2 + (Im (\\<i> + x))\\<^sup>2) =\n    sqrt ((Re (\\<i> - x))\\<^sup>2 + (Im (\\<i> - x))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  cmod (\\<i> + x) = cmod (\\<i> - x)\n\ngoal (2 subgoals):\n 1. cmod ((\\<i> - x) / (\\<i> + x)) = 1\n 2. (\\<i> - x) / (\\<i> + x) \\<noteq> - 1", "then"], ["proof (chain)\npicking this:\n  cmod (\\<i> + x) = cmod (\\<i> - x)", "show \"cmod ((\\<i> - x) / (\\<i> + x)) = 1\""], ["proof (prove)\nusing this:\n  cmod (\\<i> + x) = cmod (\\<i> - x)\n\ngoal (1 subgoal):\n 1. cmod ((\\<i> - x) / (\\<i> + x)) = 1", "unfolding norm_divide"], ["proof (prove)\nusing this:\n  cmod (\\<i> + x) = cmod (\\<i> - x)\n\ngoal (1 subgoal):\n 1. cmod (\\<i> - x) / cmod (\\<i> + x) = 1", "using neq[OF that]"], ["proof (prove)\nusing this:\n  cmod (\\<i> + x) = cmod (\\<i> - x)\n  \\<i> + x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod (\\<i> - x) / cmod (\\<i> + x) = 1", "by auto"], ["proof (state)\nthis:\n  cmod ((\\<i> - x) / (\\<i> + x)) = 1\n\ngoal (1 subgoal):\n 1. (\\<i> - x) / (\\<i> + x) \\<noteq> - 1", "show \"(\\<i> - x) / (\\<i> + x) \\<noteq> - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<i> - x) / (\\<i> + x) \\<noteq> - 1", "using neq[OF that]"], ["proof (prove)\nusing this:\n  \\<i> + x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<i> - x) / (\\<i> + x) \\<noteq> - 1", "by (auto simp add:divide_simps)"], ["proof (state)\nthis:\n  (\\<i> - x) / (\\<i> + x) \\<noteq> - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im ?x = 0 \\<Longrightarrow> cmod ((\\<i> - ?x) / (\\<i> + ?x)) = 1\n  Im ?x = 0 \\<Longrightarrow> (\\<i> - ?x) / (\\<i> + ?x) \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. Im x = 0} =\n    sphere 0 1 - {- 1}", "moreover"], ["proof (state)\nthis:\n  Im ?x = 0 \\<Longrightarrow> cmod ((\\<i> - ?x) / (\\<i> + ?x)) = 1\n  Im ?x = 0 \\<Longrightarrow> (\\<i> - ?x) / (\\<i> + ?x) \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. Im x = 0} =\n    sphere 0 1 - {- 1}", "have \"x \\<in> (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. Im x = 0}\" \n    when \"cmod x = 1\" \"x\\<noteq>-1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. Im x = 0}", "proof (rule rev_image_eqI[of \"\\<i>*(1-x)/(1+x)\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<i> * (1 - x) / (1 + x) \\<in> {x. Im x = 0}\n 2. x =\n    (\\<i> - \\<i> * (1 - x) / (1 + x)) / (\\<i> + \\<i> * (1 - x) / (1 + x))", "have \"1 + x\\<noteq>0\" \"\\<i> * 2 + \\<i> * (x * 2) \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + x \\<noteq> 0 &&& \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + x \\<noteq> 0", "using that(2)"], ["proof (prove)\nusing this:\n  x \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. 1 + x \\<noteq> 0", "by algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  cmod x = 1\n  x \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0", "by (metis \\<open>1 + x \\<noteq> 0\\<close> complex_i_not_zero div_mult_self4 mult_2 \n            mult_zero_right nonzero_mult_div_cancel_left nonzero_mult_div_cancel_right \n            one_add_one zero_neq_numeral)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  1 + x \\<noteq> 0\n  \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<i> * (1 - x) / (1 + x) \\<in> {x. Im x = 0}\n 2. x =\n    (\\<i> - \\<i> * (1 - x) / (1 + x)) / (\\<i> + \\<i> * (1 - x) / (1 + x))", "then"], ["proof (chain)\npicking this:\n  1 + x \\<noteq> 0\n  \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0", "show \"x = (\\<i> - \\<i> * (1 - x) / (1 + x)) / (\\<i> + \\<i> * (1 - x) / (1 + x))\""], ["proof (prove)\nusing this:\n  1 + x \\<noteq> 0\n  \\<i> * 2 + \\<i> * (x * 2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x =\n    (\\<i> - \\<i> * (1 - x) / (1 + x)) / (\\<i> + \\<i> * (1 - x) / (1 + x))", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  x = (\\<i> - \\<i> * (1 - x) / (1 + x)) / (\\<i> + \\<i> * (1 - x) / (1 + x))\n\ngoal (1 subgoal):\n 1. \\<i> * (1 - x) / (1 + x) \\<in> {x. Im x = 0}", "show \" \\<i> * (1 - x) / (1 + x) \\<in> {x. Im x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> * (1 - x) / (1 + x) \\<in> {x. Im x = 0}", "apply (auto simp:algebra_simps Im_complex_div_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x * Im x + Re x * Re x = 1", "using that(1)"], ["proof (prove)\nusing this:\n  cmod x = 1\n\ngoal (1 subgoal):\n 1. Im x * Im x + Re x * Re x = 1", "unfolding cmod_def"], ["proof (prove)\nusing this:\n  sqrt ((Re x)\\<^sup>2 + (Im x)\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. Im x * Im x + Re x * Re x = 1", "by (auto simp:power2_eq_square)"], ["proof (state)\nthis:\n  \\<i> * (1 - x) / (1 + x) \\<in> {x. Im x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>cmod ?x = 1; ?x \\<noteq> - 1\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) `\n                             {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. Im x = 0} =\n    sphere 0 1 - {- 1}", "ultimately"], ["proof (chain)\npicking this:\n  Im ?x = 0 \\<Longrightarrow> cmod ((\\<i> - ?x) / (\\<i> + ?x)) = 1\n  Im ?x = 0 \\<Longrightarrow> (\\<i> - ?x) / (\\<i> + ?x) \\<noteq> - 1\n  \\<lbrakk>cmod ?x = 1; ?x \\<noteq> - 1\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) `\n                             {x. Im x = 0}", "show \"(\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. Im x = 0} = sphere 0 1 - {- 1}\""], ["proof (prove)\nusing this:\n  Im ?x = 0 \\<Longrightarrow> cmod ((\\<i> - ?x) / (\\<i> + ?x)) = 1\n  Im ?x = 0 \\<Longrightarrow> (\\<i> - ?x) / (\\<i> + ?x) \\<noteq> - 1\n  \\<lbrakk>cmod ?x = 1; ?x \\<noteq> - 1\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) `\n                             {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. Im x = 0} =\n    sphere 0 1 - {- 1}", "by force"], ["proof (state)\nthis:\n  (\\<lambda>x. (\\<i> - x) / (\\<i> + x)) ` {x. Im x = 0} = sphere 0 1 - {- 1}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_ball_uball:\n  assumes \"r>0\"\n  shows \"bij_betw (\\<lambda>x. complex_of_real r*x + z0) (ball 0 1) (ball z0 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>x. complex_of_real r * x + z0) (ball 0 1) (ball z0 r)", "proof (rule bij_betw_imageI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>x. complex_of_real r * x + z0) (ball 0 1)\n 2. (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1 = ball z0 r", "show \"inj_on (\\<lambda>x. complex_of_real r * x + z0) (ball 0 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. complex_of_real r * x + z0) (ball 0 1)", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>ball 0 1.\n       \\<forall>y\\<in>ball 0 1.\n          complex_of_real r * x + z0 =\n          complex_of_real r * y + z0 \\<longrightarrow>\n          x = y", "using assms"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>ball 0 1.\n       \\<forall>y\\<in>ball 0 1.\n          complex_of_real r * x + z0 =\n          complex_of_real r * y + z0 \\<longrightarrow>\n          x = y", "by simp"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. complex_of_real r * x + z0) (ball 0 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1 = ball z0 r", "have \"dist z0 (complex_of_real r * x + z0) < r\" when \"cmod x<1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z0 (complex_of_real r * x + z0) < r", "using that assms"], ["proof (prove)\nusing this:\n  cmod x < 1\n  0 < r\n\ngoal (1 subgoal):\n 1. dist z0 (complex_of_real r * x + z0) < r", "by (auto simp:dist_norm norm_mult abs_of_pos)"], ["proof (state)\nthis:\n  cmod ?x < 1 \\<Longrightarrow> dist z0 (complex_of_real r * ?x + z0) < r\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1 = ball z0 r", "moreover"], ["proof (state)\nthis:\n  cmod ?x < 1 \\<Longrightarrow> dist z0 (complex_of_real r * ?x + z0) < r\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1 = ball z0 r", "have \"x \\<in> (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1\" when \"dist z0 x < r\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1", "apply (rule rev_image_eqI[of \"(x-z0)/r\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x - z0) / complex_of_real r \\<in> ball 0 1\n 2. x = complex_of_real r * ((x - z0) / complex_of_real r) + z0", "using that assms"], ["proof (prove)\nusing this:\n  dist z0 x < r\n  0 < r\n\ngoal (2 subgoals):\n 1. (x - z0) / complex_of_real r \\<in> ball 0 1\n 2. x = complex_of_real r * ((x - z0) / complex_of_real r) + z0", "by (auto simp add: dist_norm norm_divide norm_minus_commute)"], ["proof (state)\nthis:\n  dist z0 ?x < r \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1 = ball z0 r", "ultimately"], ["proof (chain)\npicking this:\n  cmod ?x < 1 \\<Longrightarrow> dist z0 (complex_of_real r * ?x + z0) < r\n  dist z0 ?x < r \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1", "show \"(\\<lambda>x. complex_of_real r  * x + z0) ` ball 0 1 = ball z0 r\""], ["proof (prove)\nusing this:\n  cmod ?x < 1 \\<Longrightarrow> dist z0 (complex_of_real r * ?x + z0) < r\n  dist z0 ?x < r \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1 = ball z0 r", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. complex_of_real r * x + z0) ` ball 0 1 = ball z0 r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_sphere_usphere:\n  assumes \"r>0\"\n  shows \"bij_betw (\\<lambda>x. complex_of_real r*x + z0) (sphere 0 1) (sphere z0 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>x. complex_of_real r * x + z0) (sphere 0 1)\n     (sphere z0 r)", "proof (rule bij_betw_imageI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>x. complex_of_real r * x + z0) (sphere 0 1)\n 2. (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1 = sphere z0 r", "show \"inj_on (\\<lambda>x. complex_of_real r * x + z0) (sphere 0 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. complex_of_real r * x + z0) (sphere 0 1)", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sphere 0 1.\n       \\<forall>y\\<in>sphere 0 1.\n          complex_of_real r * x + z0 =\n          complex_of_real r * y + z0 \\<longrightarrow>\n          x = y", "using assms"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sphere 0 1.\n       \\<forall>y\\<in>sphere 0 1.\n          complex_of_real r * x + z0 =\n          complex_of_real r * y + z0 \\<longrightarrow>\n          x = y", "by simp"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. complex_of_real r * x + z0) (sphere 0 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1 = sphere z0 r", "have \"dist z0 (complex_of_real r * x + z0) = r\" when \"cmod x=1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z0 (complex_of_real r * x + z0) = r", "using that assms"], ["proof (prove)\nusing this:\n  cmod x = 1\n  0 < r\n\ngoal (1 subgoal):\n 1. dist z0 (complex_of_real r * x + z0) = r", "by (auto simp:dist_norm norm_mult abs_of_pos)"], ["proof (state)\nthis:\n  cmod ?x = 1 \\<Longrightarrow> dist z0 (complex_of_real r * ?x + z0) = r\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1 = sphere z0 r", "moreover"], ["proof (state)\nthis:\n  cmod ?x = 1 \\<Longrightarrow> dist z0 (complex_of_real r * ?x + z0) = r\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1 = sphere z0 r", "have \"x \\<in> (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1\" when \"dist z0 x = r\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1", "apply (rule rev_image_eqI[of \"(x-z0)/r\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x - z0) / complex_of_real r \\<in> sphere 0 1\n 2. x = complex_of_real r * ((x - z0) / complex_of_real r) + z0", "using that assms"], ["proof (prove)\nusing this:\n  dist z0 x = r\n  0 < r\n\ngoal (2 subgoals):\n 1. (x - z0) / complex_of_real r \\<in> sphere 0 1\n 2. x = complex_of_real r * ((x - z0) / complex_of_real r) + z0", "by (auto simp add: dist_norm norm_divide norm_minus_commute)"], ["proof (state)\nthis:\n  dist z0 ?x = r \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1 = sphere z0 r", "ultimately"], ["proof (chain)\npicking this:\n  cmod ?x = 1 \\<Longrightarrow> dist z0 (complex_of_real r * ?x + z0) = r\n  dist z0 ?x = r \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1", "show \"(\\<lambda>x. complex_of_real r  * x + z0) ` sphere 0 1 = sphere z0 r\""], ["proof (prove)\nusing this:\n  cmod ?x = 1 \\<Longrightarrow> dist z0 (complex_of_real r * ?x + z0) = r\n  dist z0 ?x = r \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1 = sphere z0 r", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. complex_of_real r * x + z0) ` sphere 0 1 = sphere z0 r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_ball_plane_eq:\n  defines \"q1\\<equiv>[:\\<i>,-1:]\" and \"q2\\<equiv>[:\\<i>,1:]\"\n  assumes \"p\\<noteq>0\"\n  shows \"proots_count p (ball 0 1) = proots_count (fcompose p q1 q2) {x. 0 < Im x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p (ball 0 1) =\n    proots_count (fcompose p q1 q2) {x. 0 < Im x}", "unfolding q1_def q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p (ball 0 1) =\n    proots_count (fcompose p [:\\<i>, - 1:] [:\\<i>, 1:]) {x. 0 < Im x}", "proof (rule proots_fcompose_bij_eq[OF _ \\<open>p\\<noteq>0\\<close>])"], ["proof (state)\ngoal (5 subgoals):\n 1. bij_betw (\\<lambda>x. poly [:\\<i>, - 1:] x / poly [:\\<i>, 1:] x)\n     {x. 0 < Im x} (ball 0 1)\n 2. \\<forall>x\\<in>{x. 0 < Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\n 3. max (degree [:\\<i>, - 1:]) (degree [:\\<i>, 1:]) \\<le> 1\n 4. \\<forall>c. [:\\<i>, - 1:] \\<noteq> smult c [:\\<i>, 1:]\n 5. infinite UNIV", "show \"\\<forall>x\\<in>{x. 0 < Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. 0 < Im x}. poly [:\\<i>, 1:] x \\<noteq> 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. 0 < Im x \\<longrightarrow> \\<i> + x \\<noteq> 0", "by (metis add_less_same_cancel2 imaginary_unit.simps(2) not_one_less_zero \n          plus_complex.simps(2) zero_complex.simps(2))"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x. 0 < Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\n\ngoal (4 subgoals):\n 1. bij_betw (\\<lambda>x. poly [:\\<i>, - 1:] x / poly [:\\<i>, 1:] x)\n     {x. 0 < Im x} (ball 0 1)\n 2. max (degree [:\\<i>, - 1:]) (degree [:\\<i>, 1:]) \\<le> 1\n 3. \\<forall>c. [:\\<i>, - 1:] \\<noteq> smult c [:\\<i>, 1:]\n 4. infinite UNIV", "show \"infinite (UNIV::complex set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "by (simp add: infinite_UNIV_char_0)"], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal (3 subgoals):\n 1. bij_betw (\\<lambda>x. poly [:\\<i>, - 1:] x / poly [:\\<i>, 1:] x)\n     {x. 0 < Im x} (ball 0 1)\n 2. max (degree [:\\<i>, - 1:]) (degree [:\\<i>, 1:]) \\<le> 1\n 3. \\<forall>c. [:\\<i>, - 1:] \\<noteq> smult c [:\\<i>, 1:]", "qed (use bij_betw_plane_ball in auto)"], ["", "lemma proots_sphere_axis_eq:\n  defines \"q1\\<equiv>[:\\<i>,-1:]\" and \"q2\\<equiv>[:\\<i>,1:]\"\n  assumes \"p\\<noteq>0\"\n  shows \"proots_count p (sphere 0 1 - {- 1}) = proots_count (fcompose p q1 q2) {x. 0 = Im x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p (sphere 0 1 - {- 1}) =\n    proots_count (fcompose p q1 q2) {x. 0 = Im x}", "unfolding q1_def q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p (sphere 0 1 - {- 1}) =\n    proots_count (fcompose p [:\\<i>, - 1:] [:\\<i>, 1:]) {x. 0 = Im x}", "proof (rule proots_fcompose_bij_eq[OF _ \\<open>p\\<noteq>0\\<close>])"], ["proof (state)\ngoal (5 subgoals):\n 1. bij_betw (\\<lambda>x. poly [:\\<i>, - 1:] x / poly [:\\<i>, 1:] x)\n     {x. 0 = Im x} (sphere 0 1 - {- 1})\n 2. \\<forall>x\\<in>{x. 0 = Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\n 3. max (degree [:\\<i>, - 1:]) (degree [:\\<i>, 1:]) \\<le> 1\n 4. \\<forall>c. [:\\<i>, - 1:] \\<noteq> smult c [:\\<i>, 1:]\n 5. infinite UNIV", "show \"\\<forall>x\\<in>{x. 0 = Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. 0 = Im x}. poly [:\\<i>, 1:] x \\<noteq> 0", "by (simp add: Complex_eq_0 plus_complex.code)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x. 0 = Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\n\ngoal (4 subgoals):\n 1. bij_betw (\\<lambda>x. poly [:\\<i>, - 1:] x / poly [:\\<i>, 1:] x)\n     {x. 0 = Im x} (sphere 0 1 - {- 1})\n 2. max (degree [:\\<i>, - 1:]) (degree [:\\<i>, 1:]) \\<le> 1\n 3. \\<forall>c. [:\\<i>, - 1:] \\<noteq> smult c [:\\<i>, 1:]\n 4. infinite UNIV", "show \"infinite (UNIV::complex set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "by (simp add: infinite_UNIV_char_0)"], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal (3 subgoals):\n 1. bij_betw (\\<lambda>x. poly [:\\<i>, - 1:] x / poly [:\\<i>, 1:] x)\n     {x. 0 = Im x} (sphere 0 1 - {- 1})\n 2. max (degree [:\\<i>, - 1:]) (degree [:\\<i>, 1:]) \\<le> 1\n 3. \\<forall>c. [:\\<i>, - 1:] \\<noteq> smult c [:\\<i>, 1:]", "qed (use bij_betw_axis_sphere in auto)"], ["", "lemma proots_card_ball_plane_eq:\n  defines \"q1\\<equiv>[:\\<i>,-1:]\" and \"q2\\<equiv>[:\\<i>,1:]\"\n  assumes \"p\\<noteq>0\"\n  shows \"card (proots_within p (ball 0 1)) = card (proots_within (fcompose p q1 q2) {x. 0 < Im x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (ball 0 1)) =\n    card (proots_within (fcompose p q1 q2) {x. 0 < Im x})", "unfolding q1_def q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (ball 0 1)) =\n    card\n     (proots_within (fcompose p [:\\<i>, - 1:] [:\\<i>, 1:]) {x. 0 < Im x})", "proof (rule proots_card_fcompose_bij_eq[OF _ \\<open>p\\<noteq>0\\<close>])"], ["proof (state)\ngoal (5 subgoals):\n 1. bij_betw (\\<lambda>x. poly [:\\<i>, - 1:] x / poly [:\\<i>, 1:] x)\n     {x. 0 < Im x} (ball 0 1)\n 2. \\<forall>x\\<in>{x. 0 < Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\n 3. max (degree [:\\<i>, - 1:]) (degree [:\\<i>, 1:]) \\<le> 1\n 4. \\<forall>c. [:\\<i>, - 1:] \\<noteq> smult c [:\\<i>, 1:]\n 5. infinite UNIV", "show \"\\<forall>x\\<in>{x. 0 < Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. 0 < Im x}. poly [:\\<i>, 1:] x \\<noteq> 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. 0 < Im x \\<longrightarrow> \\<i> + x \\<noteq> 0", "by (metis add_less_same_cancel2 imaginary_unit.simps(2) not_one_less_zero \n          plus_complex.simps(2) zero_complex.simps(2))"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x. 0 < Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\n\ngoal (4 subgoals):\n 1. bij_betw (\\<lambda>x. poly [:\\<i>, - 1:] x / poly [:\\<i>, 1:] x)\n     {x. 0 < Im x} (ball 0 1)\n 2. max (degree [:\\<i>, - 1:]) (degree [:\\<i>, 1:]) \\<le> 1\n 3. \\<forall>c. [:\\<i>, - 1:] \\<noteq> smult c [:\\<i>, 1:]\n 4. infinite UNIV", "qed (use bij_betw_plane_ball infinite_UNIV_char_0 in auto)"], ["", "lemma proots_card_sphere_axis_eq:\n  defines \"q1\\<equiv>[:\\<i>,-1:]\" and \"q2\\<equiv>[:\\<i>,1:]\"\n  assumes \"p\\<noteq>0\"\n  shows \"card (proots_within p (sphere 0 1 - {- 1})) \n            = card (proots_within (fcompose p q1 q2) {x. 0 = Im x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (sphere 0 1 - {- 1})) =\n    card (proots_within (fcompose p q1 q2) {x. 0 = Im x})", "unfolding q1_def q2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (sphere 0 1 - {- 1})) =\n    card\n     (proots_within (fcompose p [:\\<i>, - 1:] [:\\<i>, 1:]) {x. 0 = Im x})", "proof (rule proots_card_fcompose_bij_eq[OF _ \\<open>p\\<noteq>0\\<close>])"], ["proof (state)\ngoal (5 subgoals):\n 1. bij_betw (\\<lambda>x. poly [:\\<i>, - 1:] x / poly [:\\<i>, 1:] x)\n     {x. 0 = Im x} (sphere 0 1 - {- 1})\n 2. \\<forall>x\\<in>{x. 0 = Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\n 3. max (degree [:\\<i>, - 1:]) (degree [:\\<i>, 1:]) \\<le> 1\n 4. \\<forall>c. [:\\<i>, - 1:] \\<noteq> smult c [:\\<i>, 1:]\n 5. infinite UNIV", "show \"\\<forall>x\\<in>{x. 0 = Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x. 0 = Im x}. poly [:\\<i>, 1:] x \\<noteq> 0", "by (simp add: Complex_eq_0 plus_complex.code)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x. 0 = Im x}. poly [:\\<i>, 1:] x \\<noteq> 0\n\ngoal (4 subgoals):\n 1. bij_betw (\\<lambda>x. poly [:\\<i>, - 1:] x / poly [:\\<i>, 1:] x)\n     {x. 0 = Im x} (sphere 0 1 - {- 1})\n 2. max (degree [:\\<i>, - 1:]) (degree [:\\<i>, 1:]) \\<le> 1\n 3. \\<forall>c. [:\\<i>, - 1:] \\<noteq> smult c [:\\<i>, 1:]\n 4. infinite UNIV", "qed (use bij_betw_axis_sphere infinite_UNIV_char_0 in auto)"], ["", "lemma proots_uball_eq:\n  fixes z0::complex and r::real\n  defines \"q\\<equiv>[:z0, of_real r:]\"\n  assumes \"p\\<noteq>0\" and \"r>0\"\n  shows \"proots_count p (ball z0 r) = proots_count (p \\<circ>\\<^sub>p q) (ball 0 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p (ball z0 r) =\n    proots_count (p \\<circ>\\<^sub>p q) (ball 0 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count p (ball z0 r) =\n    proots_count (p \\<circ>\\<^sub>p q) (ball 0 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p (ball z0 r) =\n    proots_count (p \\<circ>\\<^sub>p q) (ball 0 1)", "apply (rule proots_pcompose_bij_eq[OF _ \\<open>p\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. bij_betw (poly q) (ball 0 1) (ball z0 r)\n 2. degree q = 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (poly q) (ball 0 1) (ball z0 r)", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (poly [:z0, complex_of_real r:]) (ball 0 1) (ball z0 r)", "using bij_betw_ball_uball[OF \\<open>r>0\\<close>,of z0]"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>x. complex_of_real r * x + z0) (ball 0 1) (ball z0 r)\n\ngoal (1 subgoal):\n 1. bij_betw (poly [:z0, complex_of_real r:]) (ball 0 1) (ball z0 r)", "by (auto simp:algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = 1", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree [:z0, complex_of_real r:] = 1", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. degree [:z0, complex_of_real r:] = 1", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  proots_count p (ball z0 r) = proots_count (p \\<circ>\\<^sub>p q) (ball 0 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_card_uball_eq:\n  fixes z0::complex and r::real\n  defines \"q\\<equiv>[:z0, of_real r:]\"\n  assumes \"r>0\"\n  shows \"card (proots_within p (ball z0 r)) = card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "have ?thesis \n    when \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "have \"card (ball z0 r) = 0\" \"card (ball (0::complex) 1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (ball z0 r) = 0 &&& card (ball 0 1) = 0", "using infinite_ball[OF \\<open>r>0\\<close>,of z0] infinite_ball[of 1 \"0::complex\"]"], ["proof (prove)\nusing this:\n  infinite (ball z0 r)\n  0 < 1 \\<Longrightarrow> infinite (ball 0 1)\n\ngoal (1 subgoal):\n 1. card (ball z0 r) = 0 &&& card (ball 0 1) = 0", "by auto"], ["proof (state)\nthis:\n  card (ball z0 r) = 0\n  card (ball 0 1) = 0\n\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "then"], ["proof (chain)\npicking this:\n  card (ball z0 r) = 0\n  card (ball 0 1) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  card (ball z0 r) = 0\n  card (ball 0 1) = 0\n\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "using that"], ["proof (prove)\nusing this:\n  card (ball z0 r) = 0\n  card (ball 0 1) = 0\n  p = 0\n\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "by auto"], ["proof (state)\nthis:\n  card (proots_within p (ball z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow>\n  card (proots_within p (ball z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))\n\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow>\n  card (proots_within p (ball z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))\n\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "have ?thesis \n    when \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "apply (rule proots_card_pcompose_bij_eq[OF _ \\<open>p\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. bij_betw (poly q) (ball 0 1) (ball z0 r)\n 2. degree q = 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (poly q) (ball 0 1) (ball z0 r)", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (poly [:z0, complex_of_real r:]) (ball 0 1) (ball z0 r)", "using bij_betw_ball_uball[OF \\<open>r>0\\<close>,of z0]"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>x. complex_of_real r * x + z0) (ball 0 1) (ball z0 r)\n\ngoal (1 subgoal):\n 1. bij_betw (poly [:z0, complex_of_real r:]) (ball 0 1) (ball z0 r)", "by (auto simp:algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = 1", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree [:z0, complex_of_real r:] = 1", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. degree [:z0, complex_of_real r:] = 1", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p (ball z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))\n\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<Longrightarrow>\n  card (proots_within p (ball z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p (ball z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<Longrightarrow>\n  card (proots_within p (ball z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p (ball z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))\n\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))", "by blast"], ["proof (state)\nthis:\n  card (proots_within p (ball z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (ball 0 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_card_usphere_eq:\n  fixes z0::complex and r::real\n  defines \"q\\<equiv>[:z0, of_real r:]\"\n  assumes \"r>0\"\n  shows \"card (proots_within p (sphere z0 r)) = card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "have ?thesis \n    when \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "have \"card (sphere z0 r) = 0\" \"card (sphere (0::complex) 1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (sphere z0 r) = 0 &&& card (sphere 0 1) = 0", "using infinite_sphere[OF \\<open>r>0\\<close>,of z0] infinite_sphere[of 1 \"0::complex\"]"], ["proof (prove)\nusing this:\n  infinite (sphere z0 r)\n  0 < 1 \\<Longrightarrow> infinite (sphere 0 1)\n\ngoal (1 subgoal):\n 1. card (sphere z0 r) = 0 &&& card (sphere 0 1) = 0", "by auto"], ["proof (state)\nthis:\n  card (sphere z0 r) = 0\n  card (sphere 0 1) = 0\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "then"], ["proof (chain)\npicking this:\n  card (sphere z0 r) = 0\n  card (sphere 0 1) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  card (sphere z0 r) = 0\n  card (sphere 0 1) = 0\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "using that"], ["proof (prove)\nusing this:\n  card (sphere z0 r) = 0\n  card (sphere 0 1) = 0\n  p = 0\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "by auto"], ["proof (state)\nthis:\n  card (proots_within p (sphere z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow>\n  card (proots_within p (sphere z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow>\n  card (proots_within p (sphere z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "have ?thesis\n    when \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "apply (rule proots_card_pcompose_bij_eq[OF _ \\<open>p\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. bij_betw (poly q) (sphere 0 1) (sphere z0 r)\n 2. degree q = 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (poly q) (sphere 0 1) (sphere z0 r)", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (poly [:z0, complex_of_real r:]) (sphere 0 1) (sphere z0 r)", "using bij_betw_sphere_usphere[OF \\<open>r>0\\<close>,of z0]"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>x. complex_of_real r * x + z0) (sphere 0 1)\n   (sphere z0 r)\n\ngoal (1 subgoal):\n 1. bij_betw (poly [:z0, complex_of_real r:]) (sphere 0 1) (sphere z0 r)", "by (auto simp:algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = 1", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree [:z0, complex_of_real r:] = 1", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. degree [:z0, complex_of_real r:] = 1", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p (sphere z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<Longrightarrow>\n  card (proots_within p (sphere z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p (sphere z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "show \"card (proots_within p (sphere z0 r)) = card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))\""], ["proof (prove)\nusing this:\n  p = 0 \\<Longrightarrow>\n  card (proots_within p (sphere z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p (sphere z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))", "by blast"], ["proof (state)\nthis:\n  card (proots_within p (sphere z0 r)) =\n  card (proots_within (p \\<circ>\\<^sub>p q) (sphere 0 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Combining two real polynomials into a complex one\\<close>"], ["", "definition cpoly_of:: \"real poly \\<Rightarrow> real poly \\<Rightarrow> complex poly\" where\n  \"cpoly_of pR pI = map_poly of_real pR + smult \\<i> (map_poly of_real pI)\""], ["", "lemma cpoly_of_eq_0_iff[iff]:\n  \"cpoly_of pR pI = 0 \\<longleftrightarrow> pR = 0 \\<and> pI = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cpoly_of pR pI = 0) = (pR = 0 \\<and> pI = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (cpoly_of pR pI = 0) = (pR = 0 \\<and> pI = 0)", "have \"pR = 0 \\<and> pI = 0\" when \"cpoly_of pR pI = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pR = 0 \\<and> pI = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pR = 0 \\<and> pI = 0", "have \"complex_of_real (coeff pR n) + \\<i> * complex_of_real (coeff pI n) = 0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (coeff pR n) + \\<i> * complex_of_real (coeff pI n) = 0", "using that"], ["proof (prove)\nusing this:\n  cpoly_of pR pI = 0\n\ngoal (1 subgoal):\n 1. complex_of_real (coeff pR n) + \\<i> * complex_of_real (coeff pI n) = 0", "unfolding poly_eq_iff cpoly_of_def"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     coeff\n      (map_poly complex_of_real pR +\n       smult \\<i> (map_poly complex_of_real pI))\n      n =\n     coeff 0 n\n\ngoal (1 subgoal):\n 1. complex_of_real (coeff pR n) + \\<i> * complex_of_real (coeff pI n) = 0", "by (auto simp:coeff_map_poly)"], ["proof (state)\nthis:\n  complex_of_real (coeff pR ?n) + \\<i> * complex_of_real (coeff pI ?n) = 0\n\ngoal (1 subgoal):\n 1. pR = 0 \\<and> pI = 0", "then"], ["proof (chain)\npicking this:\n  complex_of_real (coeff pR ?n) + \\<i> * complex_of_real (coeff pI ?n) = 0", "have \"coeff pR n = 0 \\<and> coeff pI n = 0\" for n"], ["proof (prove)\nusing this:\n  complex_of_real (coeff pR ?n) + \\<i> * complex_of_real (coeff pI ?n) = 0\n\ngoal (1 subgoal):\n 1. coeff pR n = 0 \\<and> coeff pI n = 0", "by (metis Complex_eq Im_complex_of_real Re_complex_of_real complex.sel(1) complex.sel(2) \n          of_real_0)"], ["proof (state)\nthis:\n  coeff pR ?n = 0 \\<and> coeff pI ?n = 0\n\ngoal (1 subgoal):\n 1. pR = 0 \\<and> pI = 0", "then"], ["proof (chain)\npicking this:\n  coeff pR ?n = 0 \\<and> coeff pI ?n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff pR ?n = 0 \\<and> coeff pI ?n = 0\n\ngoal (1 subgoal):\n 1. pR = 0 \\<and> pI = 0", "unfolding poly_eq_iff"], ["proof (prove)\nusing this:\n  coeff pR ?n = 0 \\<and> coeff pI ?n = 0\n\ngoal (1 subgoal):\n 1. (\\<forall>n. coeff pR n = coeff 0 n) \\<and>\n    (\\<forall>n. coeff pI n = coeff 0 n)", "by auto"], ["proof (state)\nthis:\n  pR = 0 \\<and> pI = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cpoly_of pR pI = 0 \\<Longrightarrow> pR = 0 \\<and> pI = 0\n\ngoal (1 subgoal):\n 1. (cpoly_of pR pI = 0) = (pR = 0 \\<and> pI = 0)", "then"], ["proof (chain)\npicking this:\n  cpoly_of pR pI = 0 \\<Longrightarrow> pR = 0 \\<and> pI = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  cpoly_of pR pI = 0 \\<Longrightarrow> pR = 0 \\<and> pI = 0\n\ngoal (1 subgoal):\n 1. (cpoly_of pR pI = 0) = (pR = 0 \\<and> pI = 0)", "by (auto simp:cpoly_of_def)"], ["proof (state)\nthis:\n  (cpoly_of pR pI = 0) = (pR = 0 \\<and> pI = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cpoly_of_decompose:\n    \"p = cpoly_of (map_poly Re p) (map_poly Im p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = cpoly_of (map_poly Re p) (map_poly Im p)", "unfolding cpoly_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    map_poly complex_of_real (map_poly Re p) +\n    smult \\<i> (map_poly complex_of_real (map_poly Im p))", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 =\n    map_poly complex_of_real (map_poly Re 0) +\n    smult \\<i> (map_poly complex_of_real (map_poly Im 0))\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        p =\n        map_poly complex_of_real (map_poly Re p) +\n        smult \\<i> (map_poly complex_of_real (map_poly Im p))\\<rbrakk>\n       \\<Longrightarrow> pCons a p =\n                         map_poly complex_of_real\n                          (map_poly Re (pCons a p)) +\n                         smult \\<i>\n                          (map_poly complex_of_real\n                            (map_poly Im (pCons a p)))", "by (auto simp add:map_poly_pCons map_poly_map_poly complex_eq)"], ["", "lemma cpoly_of_dist_right:\n    \"cpoly_of (pR*g) (pI*g) = cpoly_of pR pI * (map_poly of_real g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cpoly_of (pR * g) (pI * g) = cpoly_of pR pI * map_poly complex_of_real g", "unfolding cpoly_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real (pR * g) +\n    smult \\<i> (map_poly complex_of_real (pI * g)) =\n    (map_poly complex_of_real pR +\n     smult \\<i> (map_poly complex_of_real pI)) *\n    map_poly complex_of_real g", "by (simp add: distrib_right)"], ["", "lemma poly_cpoly_of_real:\n    \"poly (cpoly_of pR pI) (of_real x) = Complex (poly pR x) (poly pI x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (cpoly_of pR pI) (complex_of_real x) =\n    Complex (poly pR x) (poly pI x)", "unfolding cpoly_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     (map_poly complex_of_real pR +\n      smult \\<i> (map_poly complex_of_real pI))\n     (complex_of_real x) =\n    Complex (poly pR x) (poly pI x)", "by (simp add: Complex_eq of_real_poly_map_poly)"], ["", "lemma poly_cpoly_of_real_iff:\n  shows \"poly (cpoly_of pR pI) (of_real t) =0 \\<longleftrightarrow> poly pR t = 0 \\<and> poly pI t=0 \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (cpoly_of pR pI) (complex_of_real t) = 0) =\n    (poly pR t = 0 \\<and> poly pI t = 0)", "unfolding  poly_cpoly_of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Complex (poly pR t) (poly pI t) = 0) =\n    (poly pR t = 0 \\<and> poly pI t = 0)", "using Complex_eq_0"], ["proof (prove)\nusing this:\n  (Complex ?a ?b = 0) = (?a = 0 \\<and> ?b = 0)\n\ngoal (1 subgoal):\n 1. (Complex (poly pR t) (poly pI t) = 0) =\n    (poly pR t = 0 \\<and> poly pI t = 0)", "by blast"], ["", "lemma order_cpoly_gcd_eq:\n  assumes \"pR\\<noteq>0 \\<or> pI\\<noteq>0\"\n  shows \"order t (cpoly_of pR pI) = order t (gcd pR pI)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "define g where \"g = gcd pR pI\""], ["proof (state)\nthis:\n  g = gcd pR pI\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "have [simp]:\"g\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd pR pI \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  pR \\<noteq> 0 \\<or> pI \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd pR pI \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "obtain pr pi where pri: \"pR = pr * g\" \"pI = pi * g\" \"coprime pr pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pr pi.\n        \\<lbrakk>pR = pr * g; pI = pi * g; coprime pr pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pr pi.\n        \\<lbrakk>pR = pr * gcd pR pI; pI = pi * gcd pR pI;\n         coprime pr pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) gcd_coprime_exists \\<open>g \\<noteq> 0\\<close> g_def"], ["proof (prove)\nusing this:\n  pR \\<noteq> 0 \\<or> pI \\<noteq> 0\n  gcd ?a ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  \\<exists>a' b'.\n     ?a = a' * gcd ?a ?b \\<and> ?b = b' * gcd ?a ?b \\<and> coprime a' b'\n  g \\<noteq> 0\n  g = gcd pR pI\n\ngoal (1 subgoal):\n 1. (\\<And>pr pi.\n        \\<lbrakk>pR = pr * gcd pR pI; pI = pi * gcd pR pI;\n         coprime pr pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pR = pr * g\n  pI = pi * g\n  coprime pr pi\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "then"], ["proof (chain)\npicking this:\n  pR = pr * g\n  pI = pi * g\n  coprime pr pi", "have \"pr \\<noteq>0 \\<or> pi \\<noteq>0\""], ["proof (prove)\nusing this:\n  pR = pr * g\n  pI = pi * g\n  coprime pr pi\n\ngoal (1 subgoal):\n 1. pr \\<noteq> 0 \\<or> pi \\<noteq> 0", "using assms mult_zero_left"], ["proof (prove)\nusing this:\n  pR = pr * g\n  pI = pi * g\n  coprime pr pi\n  pR \\<noteq> 0 \\<or> pI \\<noteq> 0\n  (0::?'a) * ?a = (0::?'a)\n\ngoal (1 subgoal):\n 1. pr \\<noteq> 0 \\<or> pi \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  pr \\<noteq> 0 \\<or> pi \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "have \"order t (cpoly_of pR pI) = order t (cpoly_of pr pi * (map_poly of_real g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) =\n    order (complex_of_real t) (cpoly_of pr pi * map_poly complex_of_real g)", "unfolding pri cpoly_of_dist_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. order (complex_of_real t)\n     (cpoly_of pr pi * map_poly complex_of_real g) =\n    order (complex_of_real t) (cpoly_of pr pi * map_poly complex_of_real g)", "by simp"], ["proof (state)\nthis:\n  order (complex_of_real t) (cpoly_of pR pI) =\n  order (complex_of_real t) (cpoly_of pr pi * map_poly complex_of_real g)\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "also"], ["proof (state)\nthis:\n  order (complex_of_real t) (cpoly_of pR pI) =\n  order (complex_of_real t) (cpoly_of pr pi * map_poly complex_of_real g)\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "have \"... = order t (cpoly_of pr pi) + order t g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (complex_of_real t)\n     (cpoly_of pr pi * map_poly complex_of_real g) =\n    order (complex_of_real t) (cpoly_of pr pi) + order t g", "apply (subst order_mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cpoly_of pr pi * map_poly complex_of_real g \\<noteq> 0\n 2. order (complex_of_real t) (cpoly_of pr pi) +\n    order (complex_of_real t) (map_poly complex_of_real g) =\n    order (complex_of_real t) (cpoly_of pr pi) + order t g", "using \\<open>pr \\<noteq>0 \\<or> pi \\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  pr \\<noteq> 0 \\<or> pi \\<noteq> 0\n\ngoal (2 subgoals):\n 1. cpoly_of pr pi * map_poly complex_of_real g \\<noteq> 0\n 2. order (complex_of_real t) (cpoly_of pr pi) +\n    order (complex_of_real t) (map_poly complex_of_real g) =\n    order (complex_of_real t) (cpoly_of pr pi) + order t g", "by (auto simp:map_poly_order_of_real)"], ["proof (state)\nthis:\n  order (complex_of_real t) (cpoly_of pr pi * map_poly complex_of_real g) =\n  order (complex_of_real t) (cpoly_of pr pi) + order t g\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "also"], ["proof (state)\nthis:\n  order (complex_of_real t) (cpoly_of pr pi * map_poly complex_of_real g) =\n  order (complex_of_real t) (cpoly_of pr pi) + order t g\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "have \"... = order t g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pr pi) + order t g = order t g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pr pi) + order t g = order t g", "have \"poly (cpoly_of pr pi) t \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (cpoly_of pr pi) (complex_of_real t) \\<noteq> 0", "unfolding poly_cpoly_of_real_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (poly pr t = 0 \\<and> poly pi t = 0)", "using \\<open>coprime pr pi\\<close> coprime_poly_0"], ["proof (prove)\nusing this:\n  coprime pr pi\n  coprime ?p ?q \\<Longrightarrow>\n  poly ?p ?x \\<noteq> (0::?'a) \\<or> poly ?q ?x \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. \\<not> (poly pr t = 0 \\<and> poly pi t = 0)", "by blast"], ["proof (state)\nthis:\n  poly (cpoly_of pr pi) (complex_of_real t) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pr pi) + order t g = order t g", "then"], ["proof (chain)\npicking this:\n  poly (cpoly_of pr pi) (complex_of_real t) \\<noteq> 0", "have \"order t (cpoly_of pr pi) = 0\""], ["proof (prove)\nusing this:\n  poly (cpoly_of pr pi) (complex_of_real t) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pr pi) = 0", "by (simp add: order_0I)"], ["proof (state)\nthis:\n  order (complex_of_real t) (cpoly_of pr pi) = 0\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pr pi) + order t g = order t g", "then"], ["proof (chain)\npicking this:\n  order (complex_of_real t) (cpoly_of pr pi) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  order (complex_of_real t) (cpoly_of pr pi) = 0\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pr pi) + order t g = order t g", "by auto"], ["proof (state)\nthis:\n  order (complex_of_real t) (cpoly_of pr pi) + order t g = order t g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order (complex_of_real t) (cpoly_of pr pi) + order t g = order t g\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "finally"], ["proof (chain)\npicking this:\n  order (complex_of_real t) (cpoly_of pR pI) = order t g", "show ?thesis"], ["proof (prove)\nusing this:\n  order (complex_of_real t) (cpoly_of pR pI) = order t g\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "unfolding g_def"], ["proof (prove)\nusing this:\n  order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)\n\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)", "."], ["proof (state)\nthis:\n  order (complex_of_real t) (cpoly_of pR pI) = order t (gcd pR pI)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Number of roots on a (bounded or unbounded) segment\\<close>\n\n\\<comment> \\<open>1 dimensional hyperplane\\<close>"], ["", "definition unbounded_line::\"'a::real_vector \\<Rightarrow> 'a \\<Rightarrow> 'a set\" where \n   \"unbounded_line a b = ({x. \\<exists>u::real. x= (1 - u) *\\<^sub>R a + u *\\<^sub>R b})\""], ["", "definition proots_line_card:: \"complex poly \\<Rightarrow> complex \\<Rightarrow> complex \\<Rightarrow> nat\" where\n  \"proots_line_card p st tt = card (proots_within p (open_segment st tt))\""], ["", "definition proots_unbounded_line_card:: \"complex poly \\<Rightarrow> complex \\<Rightarrow> complex \\<Rightarrow> nat\" where\n  \"proots_unbounded_line_card p st tt = card (proots_within p (unbounded_line st tt))\""], ["", "definition proots_unbounded_line :: \"complex poly \\<Rightarrow> complex \\<Rightarrow> complex \\<Rightarrow> nat\" where\n  \"proots_unbounded_line p st tt = proots_count p (unbounded_line st tt)\""], ["", "lemma card_proots_open_segments:\n  assumes \"poly p st \\<noteq>0\" \"poly p tt \\<noteq> 0\"\n  shows \"card (proots_within p (open_segment st tt)) = \n                (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                 in changes_itv_smods 0 1 g (pderiv g))\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "define pc pR pI g where \n      \"pc = pcompose p [:st, tt-st:]\" and\n      \"pR = map_poly Re pc\" and\n      \"pI = map_poly Im pc\" and\n      \"g  = gcd pR pI\""], ["proof (state)\nthis:\n  pc = p \\<circ>\\<^sub>p [:st, tt - st:]\n  pR = map_poly Re pc\n  pI = map_poly Im pc\n  g = gcd pR pI\n\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "have poly_iff:\"poly g t=0 \\<longleftrightarrow> poly pc t =0\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "have \"poly g t = 0 \\<longleftrightarrow> poly pR t =0 \\<and> poly pI t =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (gcd pR pI) t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)", "using poly_gcd_iff"], ["proof (prove)\nusing this:\n  (poly (gcd ?p ?q) ?x = (0::?'a)) =\n  (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. (poly (gcd pR pI) t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)", "by auto"], ["proof (state)\nthis:\n  (poly g t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "also"], ["proof (state)\nthis:\n  (poly g t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "have \"... \\<longleftrightarrow> poly pc t =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "have \"cpoly_of pR pI = pc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cpoly_of pR pI = pc", "unfolding pc_def pR_def pI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cpoly_of (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n     (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])) =\n    p \\<circ>\\<^sub>p [:st, tt - st:]", "using cpoly_of_decompose"], ["proof (prove)\nusing this:\n  ?p = cpoly_of (map_poly Re ?p) (map_poly Im ?p)\n\ngoal (1 subgoal):\n 1. cpoly_of (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n     (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])) =\n    p \\<circ>\\<^sub>p [:st, tt - st:]", "by auto"], ["proof (state)\nthis:\n  cpoly_of pR pI = pc\n\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "then"], ["proof (chain)\npicking this:\n  cpoly_of pR pI = pc", "show ?thesis"], ["proof (prove)\nusing this:\n  cpoly_of pR pI = pc\n\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "using poly_cpoly_of_real_iff"], ["proof (prove)\nusing this:\n  cpoly_of pR pI = pc\n  (poly (cpoly_of ?pR ?pI) (complex_of_real ?t) = 0) =\n  (poly ?pR ?t = 0 \\<and> poly ?pI ?t = 0)\n\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "by blast"], ["proof (state)\nthis:\n  (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "finally"], ["proof (chain)\npicking this:\n  (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly g t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "by auto"], ["proof (state)\nthis:\n  (poly g t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (poly g ?t = 0) = (poly pc (complex_of_real ?t) = 0)\n\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "have \"?R = changes_itv_smods 0 1 g (pderiv g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g)) =\n    changes_itv_smods 0 1 g (pderiv g)", "unfolding pc_def g_def pI_def pR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g)) =\n    changes_itv_smods 0 1\n     (gcd (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n       (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])))\n     (pderiv\n       (gcd (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n         (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:]))))", "by (auto simp add:Let_def)"], ["proof (state)\nthis:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in changes_itv_smods 0 1 g (pderiv g)) =\n  changes_itv_smods 0 1 g (pderiv g)\n\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "also"], ["proof (state)\nthis:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in changes_itv_smods 0 1 g (pderiv g)) =\n  changes_itv_smods 0 1 g (pderiv g)\n\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "have \"... = card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_smods 0 1 g (pderiv g) =\n    int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_itv_smods 0 1 g (pderiv g) =\n    int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1})", "have \"poly g 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly g 0 \\<noteq> 0", "using poly_iff[of 0] assms"], ["proof (prove)\nusing this:\n  (poly g 0 = 0) = (poly pc (complex_of_real 0) = 0)\n  poly p st \\<noteq> 0\n  poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g 0 \\<noteq> 0", "unfolding pc_def"], ["proof (prove)\nusing this:\n  (poly g 0 = 0) =\n  (poly (p \\<circ>\\<^sub>p [:st, tt - st:]) (complex_of_real 0) = 0)\n  poly p st \\<noteq> 0\n  poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g 0 \\<noteq> 0", "by (auto simp add:poly_pcompose)"], ["proof (state)\nthis:\n  poly g 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_itv_smods 0 1 g (pderiv g) =\n    int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1})", "moreover"], ["proof (state)\nthis:\n  poly g 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_itv_smods 0 1 g (pderiv g) =\n    int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1})", "have \"poly g 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly g 1 \\<noteq> 0", "using poly_iff[of 1] assms"], ["proof (prove)\nusing this:\n  (poly g 1 = 0) = (poly pc (complex_of_real 1) = 0)\n  poly p st \\<noteq> 0\n  poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g 1 \\<noteq> 0", "unfolding pc_def"], ["proof (prove)\nusing this:\n  (poly g 1 = 0) =\n  (poly (p \\<circ>\\<^sub>p [:st, tt - st:]) (complex_of_real 1) = 0)\n  poly p st \\<noteq> 0\n  poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g 1 \\<noteq> 0", "by (auto simp add:poly_pcompose)"], ["proof (state)\nthis:\n  poly g 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_itv_smods 0 1 g (pderiv g) =\n    int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1})", "ultimately"], ["proof (chain)\npicking this:\n  poly g 0 \\<noteq> 0\n  poly g 1 \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  poly g 0 \\<noteq> 0\n  poly g 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_itv_smods 0 1 g (pderiv g) =\n    int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1})", "using sturm_interval[of 0 1 g]"], ["proof (prove)\nusing this:\n  poly g 0 \\<noteq> 0\n  poly g 1 \\<noteq> 0\n  \\<lbrakk>0 < 1; poly g 0 \\<noteq> 0; poly g 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> int (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1}) =\n                    changes_itv_smods 0 1 g (pderiv g)\n\ngoal (1 subgoal):\n 1. changes_itv_smods 0 1 g (pderiv g) =\n    int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1})", "by auto"], ["proof (state)\nthis:\n  changes_itv_smods 0 1 g (pderiv g) =\n  int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_itv_smods 0 1 g (pderiv g) =\n  int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1})\n\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "also"], ["proof (state)\nthis:\n  changes_itv_smods 0 1 g (pderiv g) =\n  int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1})\n\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "have \"... = card {t::real. poly pc t = 0 \\<and> 0 < t \\<and> t < 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1})", "unfolding poly_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1})", "by simp"], ["proof (state)\nthis:\n  int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1}) =\n  int (card {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1})\n\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "also"], ["proof (state)\nthis:\n  int (card {t. poly g t = 0 \\<and> 0 < t \\<and> t < 1}) =\n  int (card {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1})\n\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "have \"... = ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "proof (cases \"st=tt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. st = tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))\n 2. st \\<noteq> tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "case True"], ["proof (state)\nthis:\n  st = tt\n\ngoal (2 subgoals):\n 1. st = tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))\n 2. st \\<noteq> tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "then"], ["proof (chain)\npicking this:\n  st = tt", "show ?thesis"], ["proof (prove)\nusing this:\n  st = tt\n\ngoal (1 subgoal):\n 1. int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "unfolding pc_def poly_pcompose"], ["proof (prove)\nusing this:\n  st = tt\n\ngoal (1 subgoal):\n 1. int (card\n          {t. poly p (poly [:st, tt - st:] (complex_of_real t)) = 0 \\<and>\n              0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "using \\<open>poly p tt \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  st = tt\n  poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (card\n          {t. poly p (poly [:st, tt - st:] (complex_of_real t)) = 0 \\<and>\n              0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "by auto"], ["proof (state)\nthis:\n  int (card\n        {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n  int (card (proots_within p (open_segment st tt)))\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "case False"], ["proof (state)\nthis:\n  st \\<noteq> tt\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "define ff where \"ff = (\\<lambda>t::real. st + t*(tt-st))\""], ["proof (state)\nthis:\n  ff = (\\<lambda>x. st + complex_of_real x * (tt - st))\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "define ll where \"ll = {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}\""], ["proof (state)\nthis:\n  ll = {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "have \"ff ` ll = proots_within p (open_segment st tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ff ` ll = proots_within p (open_segment st tt)", "proof (rule equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ff ` ll \\<subseteq> proots_within p (open_segment st tt)\n 2. proots_within p (open_segment st tt) \\<subseteq> ff ` ll", "show \"ff ` ll \\<subseteq> proots_within p (open_segment st tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ff ` ll \\<subseteq> proots_within p (open_segment st tt)", "unfolding ll_def ff_def pc_def poly_pcompose"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. st + complex_of_real x * (tt - st)) `\n    {t. poly p (poly [:st, tt - st:] (complex_of_real t)) = 0 \\<and>\n        0 < t \\<and> t < 1}\n    \\<subseteq> proots_within p (open_segment st tt)", "by (auto simp add:in_segment False scaleR_conv_of_real algebra_simps)"], ["proof (state)\nthis:\n  ff ` ll \\<subseteq> proots_within p (open_segment st tt)\n\ngoal (1 subgoal):\n 1. proots_within p (open_segment st tt) \\<subseteq> ff ` ll", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_within p (open_segment st tt) \\<subseteq> ff ` ll", "show \"proots_within p (open_segment st tt) \\<subseteq> ff ` ll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p (open_segment st tt) \\<subseteq> ff ` ll", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (open_segment st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (open_segment st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "assume asm:\"x \\<in> proots_within p (open_segment st tt)\""], ["proof (state)\nthis:\n  x \\<in> proots_within p (open_segment st tt)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (open_segment st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "then"], ["proof (chain)\npicking this:\n  x \\<in> proots_within p (open_segment st tt)", "obtain u where \"0<u\" and \"u < 1\" and u:\"x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\""], ["proof (prove)\nusing this:\n  x \\<in> proots_within p (open_segment st tt)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>0 < u; u < 1;\n         x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:in_segment)"], ["proof (state)\nthis:\n  0 < u\n  u < 1\n  x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (open_segment st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "then"], ["proof (chain)\npicking this:\n  0 < u\n  u < 1\n  x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt", "have \"poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0\""], ["proof (prove)\nusing this:\n  0 < u\n  u < 1\n  x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n\ngoal (1 subgoal):\n 1. poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0", "using asm"], ["proof (prove)\nusing this:\n  0 < u\n  u < 1\n  x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n  x \\<in> proots_within p (open_segment st tt)\n\ngoal (1 subgoal):\n 1. poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0", "by simp"], ["proof (state)\nthis:\n  poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (open_segment st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "then"], ["proof (chain)\npicking this:\n  poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0", "have \"u \\<in> ll\""], ["proof (prove)\nusing this:\n  poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0\n\ngoal (1 subgoal):\n 1. u \\<in> ll", "unfolding ll_def pc_def poly_pcompose"], ["proof (prove)\nusing this:\n  poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0\n\ngoal (1 subgoal):\n 1. u \\<in> {t. poly p (poly [:st, tt - st:] (complex_of_real t)) = 0 \\<and>\n                0 < t \\<and> t < 1}", "by (simp add:scaleR_conv_of_real algebra_simps \\<open>0<u\\<close> \\<open>u<1\\<close>)"], ["proof (state)\nthis:\n  u \\<in> ll\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (open_segment st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "moreover"], ["proof (state)\nthis:\n  u \\<in> ll\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (open_segment st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "have \"x = ff u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = ff u", "unfolding ff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = st + complex_of_real u * (tt - st)", "using u"], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n\ngoal (1 subgoal):\n 1. x = st + complex_of_real u * (tt - st)", "by (auto simp add:algebra_simps scaleR_conv_of_real)"], ["proof (state)\nthis:\n  x = ff u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (open_segment st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> ll\n  x = ff u", "show \"x \\<in> ff ` ll\""], ["proof (prove)\nusing this:\n  u \\<in> ll\n  x = ff u\n\ngoal (1 subgoal):\n 1. x \\<in> ff ` ll", "by (rule rev_image_eqI[of \"u\"])"], ["proof (state)\nthis:\n  x \\<in> ff ` ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_within p (open_segment st tt) \\<subseteq> ff ` ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ff ` ll = proots_within p (open_segment st tt)\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "moreover"], ["proof (state)\nthis:\n  ff ` ll = proots_within p (open_segment st tt)\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "have \"inj_on ff ll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ff ll", "unfolding ff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. st + complex_of_real x * (tt - st)) ll", "using False inj_on_def"], ["proof (prove)\nusing this:\n  st \\<noteq> tt\n  inj_on ?f ?A =\n  (\\<forall>x\\<in>?A.\n      \\<forall>y\\<in>?A. ?f x = ?f y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. st + complex_of_real x * (tt - st)) ll", "by fastforce"], ["proof (state)\nthis:\n  inj_on ff ll\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "ultimately"], ["proof (chain)\npicking this:\n  ff ` ll = proots_within p (open_segment st tt)\n  inj_on ff ll", "show ?thesis"], ["proof (prove)\nusing this:\n  ff ` ll = proots_within p (open_segment st tt)\n  inj_on ff ll\n\ngoal (1 subgoal):\n 1. int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "unfolding ll_def"], ["proof (prove)\nusing this:\n  ff ` {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1} =\n  proots_within p (open_segment st tt)\n  inj_on ff {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}\n\ngoal (1 subgoal):\n 1. int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "using card_image[of ff]"], ["proof (prove)\nusing this:\n  ff ` {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1} =\n  proots_within p (open_segment st tt)\n  inj_on ff {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}\n  inj_on ff ?A \\<Longrightarrow> card (ff ` ?A) = card ?A\n\ngoal (1 subgoal):\n 1. int (card\n          {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n    int (card (proots_within p (open_segment st tt)))", "by fastforce"], ["proof (state)\nthis:\n  int (card\n        {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n  int (card (proots_within p (open_segment st tt)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (card\n        {t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1}) =\n  int (card (proots_within p (open_segment st tt)))\n\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "finally"], ["proof (chain)\npicking this:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in changes_itv_smods 0 1 g (pderiv g)) =\n  int (card (proots_within p (open_segment st tt)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in changes_itv_smods 0 1 g (pderiv g)) =\n  int (card (proots_within p (open_segment st tt)))\n\ngoal (1 subgoal):\n 1. int (card (proots_within p (open_segment st tt))) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in changes_itv_smods 0 1 g (pderiv g))", "by simp"], ["proof (state)\nthis:\n  int (card (proots_within p (open_segment st tt))) =\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in changes_itv_smods 0 1 g (pderiv g))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unbounded_line_closed_segment: \"closed_segment a b \\<subseteq> unbounded_line a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment a b \\<subseteq> unbounded_line a b", "unfolding unbounded_line_def closed_segment_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(1 - u) *\\<^sub>R a + u *\\<^sub>R b |u. 0 \\<le> u \\<and> u \\<le> 1}\n    \\<subseteq> {x. \\<exists>u. x = (1 - u) *\\<^sub>R a + u *\\<^sub>R b}", "by auto"], ["", "lemma card_proots_unbounded_line:\n  assumes \"st\\<noteq>tt\"\n  shows \"card (proots_within p (unbounded_line st tt)) = \n                (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                 in nat (changes_R_smods g (pderiv g)))\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "define pc pR pI g where \n      \"pc = pcompose p [:st, tt-st:]\" and\n      \"pR = map_poly Re pc\" and\n      \"pI = map_poly Im pc\" and\n      \"g  = gcd pR pI\""], ["proof (state)\nthis:\n  pc = p \\<circ>\\<^sub>p [:st, tt - st:]\n  pR = map_poly Re pc\n  pI = map_poly Im pc\n  g = gcd pR pI\n\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "have poly_iff:\"poly g t=0 \\<longleftrightarrow> poly pc t =0\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "have \"poly g t = 0 \\<longleftrightarrow> poly pR t =0 \\<and> poly pI t =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (gcd pR pI) t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)", "using poly_gcd_iff"], ["proof (prove)\nusing this:\n  (poly (gcd ?p ?q) ?x = (0::?'a)) =\n  (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. (poly (gcd pR pI) t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)", "by auto"], ["proof (state)\nthis:\n  (poly g t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "also"], ["proof (state)\nthis:\n  (poly g t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "have \"... \\<longleftrightarrow> poly pc t =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "have \"cpoly_of pR pI = pc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cpoly_of pR pI = pc", "unfolding pc_def pR_def pI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cpoly_of (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n     (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])) =\n    p \\<circ>\\<^sub>p [:st, tt - st:]", "using cpoly_of_decompose"], ["proof (prove)\nusing this:\n  ?p = cpoly_of (map_poly Re ?p) (map_poly Im ?p)\n\ngoal (1 subgoal):\n 1. cpoly_of (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n     (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])) =\n    p \\<circ>\\<^sub>p [:st, tt - st:]", "by auto"], ["proof (state)\nthis:\n  cpoly_of pR pI = pc\n\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "then"], ["proof (chain)\npicking this:\n  cpoly_of pR pI = pc", "show ?thesis"], ["proof (prove)\nusing this:\n  cpoly_of pR pI = pc\n\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "using poly_cpoly_of_real_iff"], ["proof (prove)\nusing this:\n  cpoly_of pR pI = pc\n  (poly (cpoly_of ?pR ?pI) (complex_of_real ?t) = 0) =\n  (poly ?pR ?t = 0 \\<and> poly ?pI ?t = 0)\n\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "by blast"], ["proof (state)\nthis:\n  (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "finally"], ["proof (chain)\npicking this:\n  (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly g t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "by auto"], ["proof (state)\nthis:\n  (poly g t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (poly g ?t = 0) = (poly pc (complex_of_real ?t) = 0)\n\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "have \"?R = nat (changes_R_smods g (pderiv g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g))) =\n    nat (changes_R_smods g (pderiv g))", "unfolding pc_def g_def pI_def pR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g))) =\n    nat (changes_R_smods\n          (gcd (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n            (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])))\n          (pderiv\n            (gcd (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n              (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])))))", "by (auto simp add:Let_def)"], ["proof (state)\nthis:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in nat (changes_R_smods g (pderiv g))) =\n  nat (changes_R_smods g (pderiv g))\n\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "also"], ["proof (state)\nthis:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in nat (changes_R_smods g (pderiv g))) =\n  nat (changes_R_smods g (pderiv g))\n\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "have \"... = card {t. poly g t = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (changes_R_smods g (pderiv g)) = card {t. poly g t = 0}", "using sturm_R[of g]"], ["proof (prove)\nusing this:\n  int (card {x. poly g x = 0}) = changes_R_smods g (pderiv g)\n\ngoal (1 subgoal):\n 1. nat (changes_R_smods g (pderiv g)) = card {t. poly g t = 0}", "by simp"], ["proof (state)\nthis:\n  nat (changes_R_smods g (pderiv g)) = card {t. poly g t = 0}\n\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "also"], ["proof (state)\nthis:\n  nat (changes_R_smods g (pderiv g)) = card {t. poly g t = 0}\n\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "have \"... = card {t::real. poly pc t = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {t. poly g t = 0} = card {x. poly pc (complex_of_real x) = 0}", "unfolding poly_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {t. poly pc (complex_of_real t) = 0} =\n    card {x. poly pc (complex_of_real x) = 0}", "by simp"], ["proof (state)\nthis:\n  card {t. poly g t = 0} = card {x. poly pc (complex_of_real x) = 0}\n\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "also"], ["proof (state)\nthis:\n  card {t. poly g t = 0} = card {x. poly pc (complex_of_real x) = 0}\n\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "have \"... = ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "proof (cases \"st=tt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. st = tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))\n 2. st \\<noteq> tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "case True"], ["proof (state)\nthis:\n  st = tt\n\ngoal (2 subgoals):\n 1. st = tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))\n 2. st \\<noteq> tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "then"], ["proof (chain)\npicking this:\n  st = tt", "show ?thesis"], ["proof (prove)\nusing this:\n  st = tt\n\ngoal (1 subgoal):\n 1. card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "unfolding pc_def poly_pcompose unbounded_line_def"], ["proof (prove)\nusing this:\n  st = tt\n\ngoal (1 subgoal):\n 1. card {x. poly p (poly [:st, tt - st:] (complex_of_real x)) = 0} =\n    card\n     (proots_within p\n       {x. \\<exists>u. x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt})", "using assms"], ["proof (prove)\nusing this:\n  st = tt\n  st \\<noteq> tt\n\ngoal (1 subgoal):\n 1. card {x. poly p (poly [:st, tt - st:] (complex_of_real x)) = 0} =\n    card\n     (proots_within p\n       {x. \\<exists>u. x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt})", "by (auto simp add:proots_within_def)"], ["proof (state)\nthis:\n  card {x. poly pc (complex_of_real x) = 0} =\n  card (proots_within p (unbounded_line st tt))\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "case False"], ["proof (state)\nthis:\n  st \\<noteq> tt\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "define ff where \"ff = (\\<lambda>t::real. st + t*(tt-st))\""], ["proof (state)\nthis:\n  ff = (\\<lambda>x. st + complex_of_real x * (tt - st))\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "define ll where \"ll = {t. poly pc (complex_of_real t) = 0}\""], ["proof (state)\nthis:\n  ll = {t. poly pc (complex_of_real t) = 0}\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "have \"ff ` ll = proots_within p (unbounded_line st tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ff ` ll = proots_within p (unbounded_line st tt)", "proof (rule equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ff ` ll \\<subseteq> proots_within p (unbounded_line st tt)\n 2. proots_within p (unbounded_line st tt) \\<subseteq> ff ` ll", "show \"ff ` ll \\<subseteq> proots_within p (unbounded_line st tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ff ` ll \\<subseteq> proots_within p (unbounded_line st tt)", "unfolding ll_def ff_def pc_def poly_pcompose"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. st + complex_of_real x * (tt - st)) `\n    {t. poly p (poly [:st, tt - st:] (complex_of_real t)) = 0}\n    \\<subseteq> proots_within p (unbounded_line st tt)", "by (auto simp add:unbounded_line_def False scaleR_conv_of_real algebra_simps)"], ["proof (state)\nthis:\n  ff ` ll \\<subseteq> proots_within p (unbounded_line st tt)\n\ngoal (1 subgoal):\n 1. proots_within p (unbounded_line st tt) \\<subseteq> ff ` ll", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_within p (unbounded_line st tt) \\<subseteq> ff ` ll", "show \"proots_within p (unbounded_line st tt) \\<subseteq> ff ` ll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p (unbounded_line st tt) \\<subseteq> ff ` ll", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (unbounded_line st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (unbounded_line st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "assume asm:\"x \\<in> proots_within p (unbounded_line st tt)\""], ["proof (state)\nthis:\n  x \\<in> proots_within p (unbounded_line st tt)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (unbounded_line st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "then"], ["proof (chain)\npicking this:\n  x \\<in> proots_within p (unbounded_line st tt)", "obtain u where u:\"x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\""], ["proof (prove)\nusing this:\n  x \\<in> proots_within p (unbounded_line st tt)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:unbounded_line_def)"], ["proof (state)\nthis:\n  x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (unbounded_line st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "then"], ["proof (chain)\npicking this:\n  x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt", "have \"poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0\""], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n\ngoal (1 subgoal):\n 1. poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0", "using asm"], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n  x \\<in> proots_within p (unbounded_line st tt)\n\ngoal (1 subgoal):\n 1. poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0", "by simp"], ["proof (state)\nthis:\n  poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (unbounded_line st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "then"], ["proof (chain)\npicking this:\n  poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0", "have \"u \\<in> ll\""], ["proof (prove)\nusing this:\n  poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0\n\ngoal (1 subgoal):\n 1. u \\<in> ll", "unfolding ll_def pc_def poly_pcompose"], ["proof (prove)\nusing this:\n  poly p ((1 - u) *\\<^sub>R st + u *\\<^sub>R tt) = 0\n\ngoal (1 subgoal):\n 1. u \\<in> {t. poly p (poly [:st, tt - st:] (complex_of_real t)) = 0}", "by (simp add:scaleR_conv_of_real algebra_simps unbounded_line_def)"], ["proof (state)\nthis:\n  u \\<in> ll\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (unbounded_line st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "moreover"], ["proof (state)\nthis:\n  u \\<in> ll\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (unbounded_line st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "have \"x = ff u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = ff u", "unfolding ff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = st + complex_of_real u * (tt - st)", "using u"], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n\ngoal (1 subgoal):\n 1. x = st + complex_of_real u * (tt - st)", "by (auto simp add:algebra_simps scaleR_conv_of_real)"], ["proof (state)\nthis:\n  x = ff u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p (unbounded_line st tt) \\<Longrightarrow>\n       x \\<in> ff ` ll", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> ll\n  x = ff u", "show \"x \\<in> ff ` ll\""], ["proof (prove)\nusing this:\n  u \\<in> ll\n  x = ff u\n\ngoal (1 subgoal):\n 1. x \\<in> ff ` ll", "by (rule rev_image_eqI[of \"u\"])"], ["proof (state)\nthis:\n  x \\<in> ff ` ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_within p (unbounded_line st tt) \\<subseteq> ff ` ll\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ff ` ll = proots_within p (unbounded_line st tt)\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "moreover"], ["proof (state)\nthis:\n  ff ` ll = proots_within p (unbounded_line st tt)\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "have \"inj_on ff ll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ff ll", "unfolding ff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. st + complex_of_real x * (tt - st)) ll", "using False inj_on_def"], ["proof (prove)\nusing this:\n  st \\<noteq> tt\n  inj_on ?f ?A =\n  (\\<forall>x\\<in>?A.\n      \\<forall>y\\<in>?A. ?f x = ?f y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. st + complex_of_real x * (tt - st)) ll", "by fastforce"], ["proof (state)\nthis:\n  inj_on ff ll\n\ngoal (1 subgoal):\n 1. st \\<noteq> tt \\<Longrightarrow>\n    card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "ultimately"], ["proof (chain)\npicking this:\n  ff ` ll = proots_within p (unbounded_line st tt)\n  inj_on ff ll", "show ?thesis"], ["proof (prove)\nusing this:\n  ff ` ll = proots_within p (unbounded_line st tt)\n  inj_on ff ll\n\ngoal (1 subgoal):\n 1. card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "unfolding ll_def"], ["proof (prove)\nusing this:\n  ff ` {t. poly pc (complex_of_real t) = 0} =\n  proots_within p (unbounded_line st tt)\n  inj_on ff {t. poly pc (complex_of_real t) = 0}\n\ngoal (1 subgoal):\n 1. card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "using card_image[of ff]"], ["proof (prove)\nusing this:\n  ff ` {t. poly pc (complex_of_real t) = 0} =\n  proots_within p (unbounded_line st tt)\n  inj_on ff {t. poly pc (complex_of_real t) = 0}\n  inj_on ff ?A \\<Longrightarrow> card (ff ` ?A) = card ?A\n\ngoal (1 subgoal):\n 1. card {x. poly pc (complex_of_real x) = 0} =\n    card (proots_within p (unbounded_line st tt))", "by metis"], ["proof (state)\nthis:\n  card {x. poly pc (complex_of_real x) = 0} =\n  card (proots_within p (unbounded_line st tt))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {x. poly pc (complex_of_real x) = 0} =\n  card (proots_within p (unbounded_line st tt))\n\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "finally"], ["proof (chain)\npicking this:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in nat (changes_R_smods g (pderiv g))) =\n  card (proots_within p (unbounded_line st tt))", "show ?thesis"], ["proof (prove)\nusing this:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in nat (changes_R_smods g (pderiv g))) =\n  card (proots_within p (unbounded_line st tt))\n\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods g (pderiv g)))", "by simp"], ["proof (state)\nthis:\n  card (proots_within p (unbounded_line st tt)) =\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in nat (changes_R_smods g (pderiv g)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_unbounded_line:\n  assumes \"st\\<noteq>tt\" \"p\\<noteq>0\"\n  shows \"(proots_count p (unbounded_line st tt)) = \n                (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                 in nat (changes_R_smods_ext g (pderiv g)))\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "define pc pR pI g where \n      \"pc = pcompose p [:st, tt-st:]\" and\n      \"pR = map_poly Re pc\" and\n      \"pI = map_poly Im pc\" and\n      \"g  = gcd pR pI\""], ["proof (state)\nthis:\n  pc = p \\<circ>\\<^sub>p [:st, tt - st:]\n  pR = map_poly Re pc\n  pI = map_poly Im pc\n  g = gcd pR pI\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "have [simp]: \"g\\<noteq>0\" \"pc\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<noteq> 0 &&& pc \\<noteq> 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. g \\<noteq> 0\n 2. pc \\<noteq> 0", "show \"pc\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc \\<noteq> 0", "using assms(1) assms(2) pc_def pcompose_eq_0"], ["proof (prove)\nusing this:\n  st \\<noteq> tt\n  p \\<noteq> 0\n  pc = p \\<circ>\\<^sub>p [:st, tt - st:]\n  \\<lbrakk>?p \\<circ>\\<^sub>p ?q = 0; 0 < degree ?q\\<rbrakk>\n  \\<Longrightarrow> ?p = 0\n\ngoal (1 subgoal):\n 1. pc \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  pc \\<noteq> 0", "have \"pR\\<noteq>0 \\<or> pI\\<noteq>0\""], ["proof (prove)\nusing this:\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pR \\<noteq> 0 \\<or> pI \\<noteq> 0", "unfolding pR_def pI_def"], ["proof (prove)\nusing this:\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_poly Re pc \\<noteq> 0 \\<or> map_poly Im pc \\<noteq> 0", "by (metis cpoly_of_decompose map_poly_0)"], ["proof (state)\nthis:\n  pR \\<noteq> 0 \\<or> pI \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  pR \\<noteq> 0 \\<or> pI \\<noteq> 0", "show \"g\\<noteq>0\""], ["proof (prove)\nusing this:\n  pR \\<noteq> 0 \\<or> pI \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "unfolding g_def"], ["proof (prove)\nusing this:\n  pR \\<noteq> 0 \\<or> pI \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd pR pI \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g \\<noteq> 0\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "have order_eq:\"order t g = order t pc\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. order t g = order (complex_of_real t) pc", "apply (subst order_cpoly_gcd_eq[of pR pI,folded g_def,symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pR \\<noteq> 0 \\<or> pI \\<noteq> 0\n 2. order (complex_of_real t) (cpoly_of pR pI) =\n    order (complex_of_real t) pc", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pR \\<noteq> 0 \\<or> pI \\<noteq> 0", "using \\<open>g\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pR \\<noteq> 0 \\<or> pI \\<noteq> 0", "unfolding g_def"], ["proof (prove)\nusing this:\n  gcd pR pI \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pR \\<noteq> 0 \\<or> pI \\<noteq> 0", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) =\n    order (complex_of_real t) pc", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of pR pI) =\n    order (complex_of_real t) pc", "unfolding pR_def pI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order (complex_of_real t) (cpoly_of (map_poly Re pc) (map_poly Im pc)) =\n    order (complex_of_real t) pc", "by (simp add:cpoly_of_decompose[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  order ?t g = order (complex_of_real ?t) pc\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "have \"?R = nat (changes_R_smods_ext g (pderiv g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g))) =\n    nat (changes_R_smods_ext g (pderiv g))", "unfolding pc_def g_def pI_def pR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g))) =\n    nat (changes_R_smods_ext\n          (gcd (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n            (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])))\n          (pderiv\n            (gcd (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n              (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])))))", "by (auto simp add:Let_def)"], ["proof (state)\nthis:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in nat (changes_R_smods_ext g (pderiv g))) =\n  nat (changes_R_smods_ext g (pderiv g))\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "also"], ["proof (state)\nthis:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in nat (changes_R_smods_ext g (pderiv g))) =\n  nat (changes_R_smods_ext g (pderiv g))\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "have \"... = proots_count g UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (changes_R_smods_ext g (pderiv g)) = proots_count g UNIV", "using sturm_ext_R[OF \\<open>g\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  int (proots_count g UNIV) = changes_R_smods_ext g (pderiv g)\n\ngoal (1 subgoal):\n 1. nat (changes_R_smods_ext g (pderiv g)) = proots_count g UNIV", "by auto"], ["proof (state)\nthis:\n  nat (changes_R_smods_ext g (pderiv g)) = proots_count g UNIV\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "also"], ["proof (state)\nthis:\n  nat (changes_R_smods_ext g (pderiv g)) = proots_count g UNIV\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "have \"... = proots_count (map_poly complex_of_real g) (of_real ` UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count g UNIV =\n    proots_count (map_poly complex_of_real g) (range complex_of_real)", "apply (subst proots_count_of_real)"], ["proof (prove)\ngoal (2 subgoals):\n 1. g \\<noteq> 0\n 2. proots_count g UNIV = proots_count g UNIV", "by auto"], ["proof (state)\nthis:\n  proots_count g UNIV =\n  proots_count (map_poly complex_of_real g) (range complex_of_real)\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "also"], ["proof (state)\nthis:\n  proots_count g UNIV =\n  proots_count (map_poly complex_of_real g) (range complex_of_real)\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "have \"... = proots_count (map_poly complex_of_real g) {x. Im x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real g) (range complex_of_real) =\n    proots_count (map_poly complex_of_real g) {x. Im x = 0}", "apply (rule arg_cong2[where f=proots_count])"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_poly complex_of_real g = map_poly complex_of_real g\n 2. range complex_of_real = {x. Im x = 0}", "using Reals_def complex_is_Real_iff"], ["proof (prove)\nusing this:\n  \\<real> = range of_real\n  (?z \\<in> \\<real>) = (Im ?z = 0)\n\ngoal (2 subgoals):\n 1. map_poly complex_of_real g = map_poly complex_of_real g\n 2. range complex_of_real = {x. Im x = 0}", "by auto"], ["proof (state)\nthis:\n  proots_count (map_poly complex_of_real g) (range complex_of_real) =\n  proots_count (map_poly complex_of_real g) {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "also"], ["proof (state)\nthis:\n  proots_count (map_poly complex_of_real g) (range complex_of_real) =\n  proots_count (map_poly complex_of_real g) {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "have \"... = proots_count pc {x. Im x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly complex_of_real g) {x. Im x = 0} =\n    proots_count pc {x. Im x = 0}", "apply (rule proots_count_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>{x. Im x = 0}.\n       order x (map_poly complex_of_real g) = order x pc\n 2. map_poly complex_of_real g \\<noteq> 0\n 3. pc \\<noteq> 0", "apply (metis (mono_tags) Im_complex_of_real Re_complex_of_real \\<open>g \\<noteq> 0\\<close> complex_surj \n            map_poly_order_of_real mem_Collect_eq order_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_poly complex_of_real g \\<noteq> 0\n 2. pc \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  proots_count (map_poly complex_of_real g) {x. Im x = 0} =\n  proots_count pc {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "also"], ["proof (state)\nthis:\n  proots_count (map_poly complex_of_real g) {x. Im x = 0} =\n  proots_count pc {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "have \"... = proots_count p (unbounded_line st tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count pc {x. Im x = 0} = proots_count p (unbounded_line st tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count pc {x. Im x = 0} = proots_count p (unbounded_line st tt)", "have \"poly [:st, tt - st:] ` {x. Im x = 0} = unbounded_line st tt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly [:st, tt - st:] ` {x. Im x = 0} = unbounded_line st tt", "unfolding unbounded_line_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly [:st, tt - st:] ` {x. Im x = 0} =\n    {x. \\<exists>u. x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt}", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       Im xa = 0 \\<Longrightarrow>\n       \\<exists>u.\n          poly [:st, tt - st:] xa = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n 2. \\<And>x u.\n       (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n       \\<in> poly [:st, tt - st:] ` {x. Im x = 0}", "subgoal for _ x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x = 0 \\<Longrightarrow>\n    \\<exists>u.\n       poly [:st, tt - st:] x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt", "apply (rule_tac x=\"Re x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x = 0 \\<Longrightarrow>\n    poly [:st, tt - st:] x = (1 - Re x) *\\<^sub>R st + Re x *\\<^sub>R tt", "apply (simp add:algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x = 0 \\<Longrightarrow>\n    tt * x + Re x *\\<^sub>R st = st * x + Re x *\\<^sub>R tt", "by (simp add: mult.commute scaleR_complex.code times_complex.code)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x u.\n       (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n       \\<in> poly [:st, tt - st:] ` {x. Im x = 0}", "subgoal for _ u"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n    \\<in> poly [:st, tt - st:] ` {x. Im x = 0}", "apply (rule rev_image_eqI[of \"of_real u\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. complex_of_real u \\<in> {x. Im x = 0}\n 2. (1 - u) *\\<^sub>R st + u *\\<^sub>R tt =\n    poly [:st, tt - st:] (complex_of_real u)", "by (auto simp:scaleR_conv_of_real algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  poly [:st, tt - st:] ` {x. Im x = 0} = unbounded_line st tt\n\ngoal (1 subgoal):\n 1. proots_count pc {x. Im x = 0} = proots_count p (unbounded_line st tt)", "then"], ["proof (chain)\npicking this:\n  poly [:st, tt - st:] ` {x. Im x = 0} = unbounded_line st tt", "show ?thesis"], ["proof (prove)\nusing this:\n  poly [:st, tt - st:] ` {x. Im x = 0} = unbounded_line st tt\n\ngoal (1 subgoal):\n 1. proots_count pc {x. Im x = 0} = proots_count p (unbounded_line st tt)", "unfolding pc_def"], ["proof (prove)\nusing this:\n  poly [:st, tt - st:] ` {x. Im x = 0} = unbounded_line st tt\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p [:st, tt - st:]) {x. Im x = 0} =\n    proots_count p (unbounded_line st tt)", "apply (subst proots_pcompose)"], ["proof (prove)\ngoal (3 subgoals):\n 1. poly [:st, tt - st:] ` {x. Im x = 0} =\n    unbounded_line st tt \\<Longrightarrow>\n    p \\<noteq> 0\n 2. poly [:st, tt - st:] ` {x. Im x = 0} =\n    unbounded_line st tt \\<Longrightarrow>\n    degree [:st, tt - st:] = 1\n 3. poly [:st, tt - st:] ` {x. Im x = 0} =\n    unbounded_line st tt \\<Longrightarrow>\n    proots_count p (poly [:st, tt - st:] ` {x. Im x = 0}) =\n    proots_count p (unbounded_line st tt)", "using \\<open>p\\<noteq>0\\<close> \\<open>st\\<noteq>tt\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  st \\<noteq> tt\n\ngoal (3 subgoals):\n 1. poly [:st, tt - st:] ` {x. Im x = 0} =\n    unbounded_line st tt \\<Longrightarrow>\n    p \\<noteq> 0\n 2. poly [:st, tt - st:] ` {x. Im x = 0} =\n    unbounded_line st tt \\<Longrightarrow>\n    degree [:st, tt - st:] = 1\n 3. poly [:st, tt - st:] ` {x. Im x = 0} =\n    unbounded_line st tt \\<Longrightarrow>\n    proots_count p (poly [:st, tt - st:] ` {x. Im x = 0}) =\n    proots_count p (unbounded_line st tt)", "by auto"], ["proof (state)\nthis:\n  proots_count pc {x. Im x = 0} = proots_count p (unbounded_line st tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count pc {x. Im x = 0} = proots_count p (unbounded_line st tt)\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "finally"], ["proof (chain)\npicking this:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in nat (changes_R_smods_ext g (pderiv g))) =\n  proots_count p (unbounded_line st tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in nat (changes_R_smods_ext g (pderiv g))) =\n  proots_count p (unbounded_line st tt)\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n         pI = map_poly Im pc; g = gcd pR pI\n     in nat (changes_R_smods_ext g (pderiv g)))", "by simp"], ["proof (state)\nthis:\n  proots_count p (unbounded_line st tt) =\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in nat (changes_R_smods_ext g (pderiv g)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_unbounded_line_card_code[code]:\n  \"proots_unbounded_line_card p st tt = \n              (if st\\<noteq>tt then \n                (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                 in nat (changes_R_smods g (pderiv g))) \n              else \n                  Code.abort (STR ''proots_unbounded_line_card fails due to invalid hyperplanes.'') \n                      (\\<lambda>_. proots_unbounded_line_card p st tt))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_unbounded_line_card p st tt =\n    (if st \\<noteq> tt\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in nat (changes_R_smods g (pderiv g))\n     else Code.abort\n           STR ''proots_unbounded_line_card fails due to invalid hyperplanes.''\n           (\\<lambda>_. proots_unbounded_line_card p st tt))", "unfolding proots_unbounded_line_card_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (if st \\<noteq> tt\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in nat (changes_R_smods g (pderiv g))\n     else Code.abort\n           STR ''proots_unbounded_line_card fails due to invalid hyperplanes.''\n           (\\<lambda>_. card (proots_within p (unbounded_line st tt))))", "using card_proots_unbounded_line[of st tt p]"], ["proof (prove)\nusing this:\n  st \\<noteq> tt \\<Longrightarrow>\n  card (proots_within p (unbounded_line st tt)) =\n  (let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n       pI = map_poly Im pc; g = gcd pR pI\n   in nat (changes_R_smods g (pderiv g)))\n\ngoal (1 subgoal):\n 1. card (proots_within p (unbounded_line st tt)) =\n    (if st \\<noteq> tt\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in nat (changes_R_smods g (pderiv g))\n     else Code.abort\n           STR ''proots_unbounded_line_card fails due to invalid hyperplanes.''\n           (\\<lambda>_. card (proots_within p (unbounded_line st tt))))", "by auto"], ["", "lemma proots_unbounded_line_code[code]:\n  \"proots_unbounded_line p st tt = \n              ( if st\\<noteq>tt then \n                if p\\<noteq>0 then \n                  (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                  in nat (changes_R_smods_ext g (pderiv g)))\n                else \n                  Code.abort (STR ''proots_unbounded_line fails due to p=0'') \n                      (\\<lambda>_. proots_unbounded_line p st tt)\n                else \n                  Code.abort (STR ''proots_unbounded_line fails due to invalid hyperplanes.'') \n                      (\\<lambda>_. proots_unbounded_line p st tt) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_unbounded_line p st tt =\n    (if st \\<noteq> tt\n     then if p \\<noteq> 0\n          then let pc = p \\<circ>\\<^sub>p [:st, tt - st:];\n                   pR = map_poly Re pc; pI = map_poly Im pc; g = gcd pR pI\n               in nat (changes_R_smods_ext g (pderiv g))\n          else Code.abort STR ''proots_unbounded_line fails due to p=0''\n                (\\<lambda>_. proots_unbounded_line p st tt)\n     else Code.abort\n           STR ''proots_unbounded_line fails due to invalid hyperplanes.''\n           (\\<lambda>_. proots_unbounded_line p st tt))", "unfolding proots_unbounded_line_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (if st \\<noteq> tt\n     then if p \\<noteq> 0\n          then let pc = p \\<circ>\\<^sub>p [:st, tt - st:];\n                   pR = map_poly Re pc; pI = map_poly Im pc; g = gcd pR pI\n               in nat (changes_R_smods_ext g (pderiv g))\n          else Code.abort STR ''proots_unbounded_line fails due to p=0''\n                (\\<lambda>_. proots_count p (unbounded_line st tt))\n     else Code.abort\n           STR ''proots_unbounded_line fails due to invalid hyperplanes.''\n           (\\<lambda>_. proots_count p (unbounded_line st tt)))", "using proots_unbounded_line"], ["proof (prove)\nusing this:\n  \\<lbrakk>?st \\<noteq> ?tt; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proots_count ?p (unbounded_line ?st ?tt) =\n                    (let pc = ?p \\<circ>\\<^sub>p [:?st, ?tt - ?st:];\n                         pR = map_poly Re pc; pI = map_poly Im pc;\n                         g = gcd pR pI\n                     in nat (changes_R_smods_ext g (pderiv g)))\n\ngoal (1 subgoal):\n 1. proots_count p (unbounded_line st tt) =\n    (if st \\<noteq> tt\n     then if p \\<noteq> 0\n          then let pc = p \\<circ>\\<^sub>p [:st, tt - st:];\n                   pR = map_poly Re pc; pI = map_poly Im pc; g = gcd pR pI\n               in nat (changes_R_smods_ext g (pderiv g))\n          else Code.abort STR ''proots_unbounded_line fails due to p=0''\n                (\\<lambda>_. proots_count p (unbounded_line st tt))\n     else Code.abort\n           STR ''proots_unbounded_line fails due to invalid hyperplanes.''\n           (\\<lambda>_. proots_count p (unbounded_line st tt)))", "by auto"], ["", "subsection \\<open>Checking if there a polynomial root on a closed segment\\<close>"], ["", "definition no_proots_line::\"complex poly \\<Rightarrow> complex \\<Rightarrow> complex \\<Rightarrow> bool\" where\n  \"no_proots_line p st tt = (proots_within p (closed_segment st tt) = {})\""], ["", "(*TODO: the proof can probably be simplified using Lemma card_proots_open_segments*)"], ["", "lemma no_proots_line_code[code]: \"no_proots_line p st tt = (if poly p st \\<noteq>0 \\<and> poly p tt \\<noteq> 0 then \n                (let pc = pcompose p [:st, tt - st:];\n                     pR = map_poly Re pc;\n                     pI = map_poly Im pc;\n                     g  = gcd pR pI\n                 in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False) else False)\"\n            (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "proof (cases \"poly p st \\<noteq>0 \\<and> poly p tt \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)\n 2. \\<not> (poly p st \\<noteq> 0 \\<and>\n            poly p tt \\<noteq> 0) \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "case False"], ["proof (state)\nthis:\n  \\<not> (poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)\n 2. \\<not> (poly p st \\<noteq> 0 \\<and>\n            poly p tt \\<noteq> 0) \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "unfolding no_proots_line_def"], ["proof (prove)\nusing this:\n  \\<not> (poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (proots_within p (closed_segment st tt) = {}) =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "by auto"], ["proof (state)\nthis:\n  no_proots_line p st tt =\n  (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n   then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n            pI = map_poly Im pc; g = gcd pR pI\n        in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n   else False)\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "case True"], ["proof (state)\nthis:\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "then"], ["proof (chain)\npicking this:\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0", "have \"poly p st \\<noteq> 0\" \"poly p tt \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 &&& poly p tt \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p st \\<noteq> 0\n  poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "define pc pR pI g where \n      \"pc = pcompose p [:st, tt-st:]\" and\n      \"pR = map_poly Re pc\" and\n      \"pI = map_poly Im pc\" and\n      \"g  = gcd pR pI\""], ["proof (state)\nthis:\n  pc = p \\<circ>\\<^sub>p [:st, tt - st:]\n  pR = map_poly Re pc\n  pI = map_poly Im pc\n  g = gcd pR pI\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "have poly_iff:\"poly g t=0 \\<longleftrightarrow> poly pc t =0\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "have \"poly g t = 0 \\<longleftrightarrow> poly pR t =0 \\<and> poly pI t =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (gcd pR pI) t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)", "using poly_gcd_iff"], ["proof (prove)\nusing this:\n  (poly (gcd ?p ?q) ?x = (0::?'a)) =\n  (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. (poly (gcd pR pI) t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)", "by auto"], ["proof (state)\nthis:\n  (poly g t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "also"], ["proof (state)\nthis:\n  (poly g t = 0) = (poly pR t = 0 \\<and> poly pI t = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "have \"... \\<longleftrightarrow> poly pc t =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "have \"cpoly_of pR pI = pc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cpoly_of pR pI = pc", "unfolding pc_def pR_def pI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cpoly_of (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n     (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])) =\n    p \\<circ>\\<^sub>p [:st, tt - st:]", "using cpoly_of_decompose"], ["proof (prove)\nusing this:\n  ?p = cpoly_of (map_poly Re ?p) (map_poly Im ?p)\n\ngoal (1 subgoal):\n 1. cpoly_of (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n     (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])) =\n    p \\<circ>\\<^sub>p [:st, tt - st:]", "by auto"], ["proof (state)\nthis:\n  cpoly_of pR pI = pc\n\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "then"], ["proof (chain)\npicking this:\n  cpoly_of pR pI = pc", "show ?thesis"], ["proof (prove)\nusing this:\n  cpoly_of pR pI = pc\n\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "using poly_cpoly_of_real_iff"], ["proof (prove)\nusing this:\n  cpoly_of pR pI = pc\n  (poly (cpoly_of ?pR ?pI) (complex_of_real ?t) = 0) =\n  (poly ?pR ?t = 0 \\<and> poly ?pI ?t = 0)\n\ngoal (1 subgoal):\n 1. (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)", "by blast"], ["proof (state)\nthis:\n  (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (poly pR t = 0 \\<and> poly pI t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "finally"], ["proof (chain)\npicking this:\n  (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly g t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal (1 subgoal):\n 1. (poly g t = 0) = (poly pc (complex_of_real t) = 0)", "by auto"], ["proof (state)\nthis:\n  (poly g t = 0) = (poly pc (complex_of_real t) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (poly g ?t = 0) = (poly pc (complex_of_real ?t) = 0)\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "have \"?R = (changes_itv_smods 0 1 g (pderiv g) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False) =\n    (changes_itv_smods 0 1 g (pderiv g) = 0)", "using True"], ["proof (prove)\nusing this:\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False) =\n    (changes_itv_smods 0 1 g (pderiv g) = 0)", "unfolding pc_def g_def pI_def pR_def"], ["proof (prove)\nusing this:\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False) =\n    (changes_itv_smods 0 1\n      (gcd (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n        (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])))\n      (pderiv\n        (gcd (map_poly Re (p \\<circ>\\<^sub>p [:st, tt - st:]))\n          (map_poly Im (p \\<circ>\\<^sub>p [:st, tt - st:])))) =\n     0)", "by (auto simp add:Let_def)"], ["proof (state)\nthis:\n  (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n   then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n            pI = map_poly Im pc; g = gcd pR pI\n        in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n   else False) =\n  (changes_itv_smods 0 1 g (pderiv g) = 0)\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "also"], ["proof (state)\nthis:\n  (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n   then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n            pI = map_poly Im pc; g = gcd pR pI\n        in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n   else False) =\n  (changes_itv_smods 0 1 g (pderiv g) = 0)\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "have \"... = (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (changes_itv_smods 0 1 g (pderiv g) = 0) =\n    (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (changes_itv_smods 0 1 g (pderiv g) = 0) =\n    (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0)", "have \"poly g 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly g 0 \\<noteq> 0", "using poly_iff[of 0] True"], ["proof (prove)\nusing this:\n  (poly g 0 = 0) = (poly pc (complex_of_real 0) = 0)\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g 0 \\<noteq> 0", "unfolding pc_def"], ["proof (prove)\nusing this:\n  (poly g 0 = 0) =\n  (poly (p \\<circ>\\<^sub>p [:st, tt - st:]) (complex_of_real 0) = 0)\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g 0 \\<noteq> 0", "by (auto simp add:poly_pcompose)"], ["proof (state)\nthis:\n  poly g 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (changes_itv_smods 0 1 g (pderiv g) = 0) =\n    (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0)", "moreover"], ["proof (state)\nthis:\n  poly g 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (changes_itv_smods 0 1 g (pderiv g) = 0) =\n    (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0)", "have \"poly g 1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly g 1 \\<noteq> 0", "using poly_iff[of 1] True"], ["proof (prove)\nusing this:\n  (poly g 1 = 0) = (poly pc (complex_of_real 1) = 0)\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g 1 \\<noteq> 0", "unfolding pc_def"], ["proof (prove)\nusing this:\n  (poly g 1 = 0) =\n  (poly (p \\<circ>\\<^sub>p [:st, tt - st:]) (complex_of_real 1) = 0)\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly g 1 \\<noteq> 0", "by (auto simp add:poly_pcompose)"], ["proof (state)\nthis:\n  poly g 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (changes_itv_smods 0 1 g (pderiv g) = 0) =\n    (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0)", "ultimately"], ["proof (chain)\npicking this:\n  poly g 0 \\<noteq> 0\n  poly g 1 \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  poly g 0 \\<noteq> 0\n  poly g 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (changes_itv_smods 0 1 g (pderiv g) = 0) =\n    (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0)", "using sturm_interval[of 0 1 g]"], ["proof (prove)\nusing this:\n  poly g 0 \\<noteq> 0\n  poly g 1 \\<noteq> 0\n  \\<lbrakk>0 < 1; poly g 0 \\<noteq> 0; poly g 1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> int (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1}) =\n                    changes_itv_smods 0 1 g (pderiv g)\n\ngoal (1 subgoal):\n 1. (changes_itv_smods 0 1 g (pderiv g) = 0) =\n    (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0)", "by auto"], ["proof (state)\nthis:\n  (changes_itv_smods 0 1 g (pderiv g) = 0) =\n  (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (changes_itv_smods 0 1 g (pderiv g) = 0) =\n  (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0)\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "also"], ["proof (state)\nthis:\n  (changes_itv_smods 0 1 g (pderiv g) = 0) =\n  (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0)\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "have \"... = ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0) =\n    ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0) =\n    ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {})", "have \"g\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> g \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> g \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> g \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> g \\<noteq> 0", "have \"poly pc 0 =0\""], ["proof (prove)\nusing this:\n  \\<not> g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly pc 0 = 0", "using poly_iff[of 0]"], ["proof (prove)\nusing this:\n  \\<not> g \\<noteq> 0\n  (poly g 0 = 0) = (poly pc (complex_of_real 0) = 0)\n\ngoal (1 subgoal):\n 1. poly pc 0 = 0", "by auto"], ["proof (state)\nthis:\n  poly pc 0 = 0\n\ngoal (1 subgoal):\n 1. \\<not> g \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly pc 0 = 0", "show False"], ["proof (prove)\nusing this:\n  poly pc 0 = 0\n\ngoal (1 subgoal):\n 1. False", "using True"], ["proof (prove)\nusing this:\n  poly pc 0 = 0\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "unfolding pc_def"], ["proof (prove)\nusing this:\n  poly (p \\<circ>\\<^sub>p [:st, tt - st:]) 0 = 0\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add:poly_pcompose)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0) =\n    ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {})", "from poly_roots_finite[OF this]"], ["proof (chain)\npicking this:\n  finite {x. poly g x = 0}", "have \"finite {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1}\""], ["proof (prove)\nusing this:\n  finite {x. poly g x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1}", "by auto"], ["proof (state)\nthis:\n  finite {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0) =\n    ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {})", "then"], ["proof (chain)\npicking this:\n  finite {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1}\n\ngoal (1 subgoal):\n 1. (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0) =\n    ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {})", "using card_eq_0_iff"], ["proof (prove)\nusing this:\n  finite {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1}\n  (card ?A = 0) = (?A = {} \\<or> infinite ?A)\n\ngoal (1 subgoal):\n 1. (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0) =\n    ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {})", "by auto"], ["proof (state)\nthis:\n  (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0) =\n  ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0) =\n  ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {})\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "also"], ["proof (state)\nthis:\n  (card {x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = 0) =\n  ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {})\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "have \"... = ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {}) =\n    no_proots_line p st tt", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {}) =\n    no_proots_line p st tt", "have \"(\\<exists>t. poly g t = 0 \\<and> 0 < t \\<and> t < 1) \\<longleftrightarrow> (\\<exists>t::real. poly pc t = 0 \\<and> 0 < t \\<and> t < 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>t. poly g t = 0 \\<and> 0 < t \\<and> t < 1) =\n    (\\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1)", "using poly_iff"], ["proof (prove)\nusing this:\n  (poly g ?t = 0) = (poly pc (complex_of_real ?t) = 0)\n\ngoal (1 subgoal):\n 1. (\\<exists>t. poly g t = 0 \\<and> 0 < t \\<and> t < 1) =\n    (\\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>t. poly g t = 0 \\<and> 0 < t \\<and> t < 1) =\n  (\\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1)\n\ngoal (1 subgoal):\n 1. ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {}) =\n    no_proots_line p st tt", "also"], ["proof (state)\nthis:\n  (\\<exists>t. poly g t = 0 \\<and> 0 < t \\<and> t < 1) =\n  (\\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1)\n\ngoal (1 subgoal):\n 1. ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {}) =\n    no_proots_line p st tt", "have \"... \\<longleftrightarrow> (\\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>t.\n        poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1) =\n    (\\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>t.\n       poly pc (complex_of_real t) = 0 \\<and>\n       0 < t \\<and> t < 1 \\<Longrightarrow>\n    \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\n 2. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "assume \"\\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1\""], ["proof (state)\nthis:\n  \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1\n\ngoal (2 subgoals):\n 1. \\<exists>t.\n       poly pc (complex_of_real t) = 0 \\<and>\n       0 < t \\<and> t < 1 \\<Longrightarrow>\n    \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\n 2. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "obtain t where *:\"poly pc (of_real t) = 0\" and \"0 < t\" \"t < 1\""], ["proof (prove)\nusing this:\n  \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>poly pc (complex_of_real t) = 0; 0 < t; t < 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly pc (complex_of_real t) = 0\n  0 < t\n  t < 1\n\ngoal (2 subgoals):\n 1. \\<exists>t.\n       poly pc (complex_of_real t) = 0 \\<and>\n       0 < t \\<and> t < 1 \\<Longrightarrow>\n    \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\n 2. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "define x where \"x=poly [:st, tt - st:] t\""], ["proof (state)\nthis:\n  x = poly [:st, tt - st:] (complex_of_real t)\n\ngoal (2 subgoals):\n 1. \\<exists>t.\n       poly pc (complex_of_real t) = 0 \\<and>\n       0 < t \\<and> t < 1 \\<Longrightarrow>\n    \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\n 2. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "have \"x \\<in> closed_segment st tt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> closed_segment st tt", "using \\<open>0<t\\<close> \\<open>t<1\\<close>"], ["proof (prove)\nusing this:\n  0 < t\n  t < 1\n\ngoal (1 subgoal):\n 1. x \\<in> closed_segment st tt", "unfolding x_def in_segment"], ["proof (prove)\nusing this:\n  0 < t\n  t < 1\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<ge>0.\n       u \\<le> 1 \\<and>\n       poly [:st, tt - st:] (complex_of_real t) =\n       (1 - u) *\\<^sub>R st + u *\\<^sub>R tt", "by (intro exI[where x=t],auto simp add: algebra_simps scaleR_conv_of_real)"], ["proof (state)\nthis:\n  x \\<in> closed_segment st tt\n\ngoal (2 subgoals):\n 1. \\<exists>t.\n       poly pc (complex_of_real t) = 0 \\<and>\n       0 < t \\<and> t < 1 \\<Longrightarrow>\n    \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\n 2. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "moreover"], ["proof (state)\nthis:\n  x \\<in> closed_segment st tt\n\ngoal (2 subgoals):\n 1. \\<exists>t.\n       poly pc (complex_of_real t) = 0 \\<and>\n       0 < t \\<and> t < 1 \\<Longrightarrow>\n    \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\n 2. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "have \"poly p x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = 0", "using *"], ["proof (prove)\nusing this:\n  poly pc (complex_of_real t) = 0\n\ngoal (1 subgoal):\n 1. poly p x = 0", "unfolding pc_def x_def"], ["proof (prove)\nusing this:\n  poly (p \\<circ>\\<^sub>p [:st, tt - st:]) (complex_of_real t) = 0\n\ngoal (1 subgoal):\n 1. poly p (poly [:st, tt - st:] (complex_of_real t)) = 0", "by (auto simp add:poly_pcompose)"], ["proof (state)\nthis:\n  poly p x = 0\n\ngoal (2 subgoals):\n 1. \\<exists>t.\n       poly pc (complex_of_real t) = 0 \\<and>\n       0 < t \\<and> t < 1 \\<Longrightarrow>\n    \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\n 2. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> closed_segment st tt\n  poly p x = 0", "show \"\\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> closed_segment st tt\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "assume \"\\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\""], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0", "obtain x where \"x \\<in> closed_segment st tt\" \"poly p x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> closed_segment st tt; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> closed_segment st tt\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "then"], ["proof (chain)\npicking this:\n  x \\<in> closed_segment st tt\n  poly p x = 0", "obtain t::real where *:\"x = (1 - t) *\\<^sub>R st + t *\\<^sub>R tt\" and \"0\\<le>t\" \"t\\<le>1\""], ["proof (prove)\nusing this:\n  x \\<in> closed_segment st tt\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>x = (1 - t) *\\<^sub>R st + t *\\<^sub>R tt; 0 \\<le> t;\n         t \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding in_segment"], ["proof (prove)\nusing this:\n  \\<exists>u\\<ge>0.\n     u \\<le> 1 \\<and> x = (1 - u) *\\<^sub>R st + u *\\<^sub>R tt\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>x = (1 - t) *\\<^sub>R st + t *\\<^sub>R tt; 0 \\<le> t;\n         t \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = (1 - t) *\\<^sub>R st + t *\\<^sub>R tt\n  0 \\<le> t\n  t \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "then"], ["proof (chain)\npicking this:\n  x = (1 - t) *\\<^sub>R st + t *\\<^sub>R tt\n  0 \\<le> t\n  t \\<le> 1", "have \"x=poly [:st, tt - st:] t\""], ["proof (prove)\nusing this:\n  x = (1 - t) *\\<^sub>R st + t *\\<^sub>R tt\n  0 \\<le> t\n  t \\<le> 1\n\ngoal (1 subgoal):\n 1. x = poly [:st, tt - st:] (complex_of_real t)", "by (auto simp add: algebra_simps scaleR_conv_of_real)"], ["proof (state)\nthis:\n  x = poly [:st, tt - st:] (complex_of_real t)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "then"], ["proof (chain)\npicking this:\n  x = poly [:st, tt - st:] (complex_of_real t)", "have \"poly pc (complex_of_real t) = 0\""], ["proof (prove)\nusing this:\n  x = poly [:st, tt - st:] (complex_of_real t)\n\ngoal (1 subgoal):\n 1. poly pc (complex_of_real t) = 0", "using \\<open>poly p x=0\\<close>"], ["proof (prove)\nusing this:\n  x = poly [:st, tt - st:] (complex_of_real t)\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. poly pc (complex_of_real t) = 0", "unfolding pc_def"], ["proof (prove)\nusing this:\n  x = poly [:st, tt - st:] (complex_of_real t)\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. poly (p \\<circ>\\<^sub>p [:st, tt - st:]) (complex_of_real t) = 0", "by (auto simp add:poly_pcompose)"], ["proof (state)\nthis:\n  poly pc (complex_of_real t) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "moreover"], ["proof (state)\nthis:\n  poly pc (complex_of_real t) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "have \"t\\<noteq>0\" \"t\\<noteq>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> 0 &&& t \\<noteq> 1", "using True *  \\<open>poly p x=0\\<close>"], ["proof (prove)\nusing this:\n  poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n  x = (1 - t) *\\<^sub>R st + t *\\<^sub>R tt\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 &&& t \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  t \\<noteq> 0\n  t \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "then"], ["proof (chain)\npicking this:\n  t \\<noteq> 0\n  t \\<noteq> 1", "have \"0<t\" \"t<1\""], ["proof (prove)\nusing this:\n  t \\<noteq> 0\n  t \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 0 < t &&& t < 1", "using \\<open>0\\<le>t\\<close> \\<open>t\\<le>1\\<close>"], ["proof (prove)\nusing this:\n  t \\<noteq> 0\n  t \\<noteq> 1\n  0 \\<le> t\n  t \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 < t &&& t < 1", "by auto"], ["proof (state)\nthis:\n  0 < t\n  t < 1\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> closed_segment st tt \\<and> poly p x = 0 \\<Longrightarrow>\n    \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "ultimately"], ["proof (chain)\npicking this:\n  poly pc (complex_of_real t) = 0\n  0 < t\n  t < 1", "show \"\\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1\""], ["proof (prove)\nusing this:\n  poly pc (complex_of_real t) = 0\n  0 < t\n  t < 1\n\ngoal (1 subgoal):\n 1. \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1", "by auto"], ["proof (state)\nthis:\n  \\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>t. poly pc (complex_of_real t) = 0 \\<and> 0 < t \\<and> t < 1) =\n  (\\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0)\n\ngoal (1 subgoal):\n 1. ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {}) =\n    no_proots_line p st tt", "finally"], ["proof (chain)\npicking this:\n  (\\<exists>t. poly g t = 0 \\<and> 0 < t \\<and> t < 1) =\n  (\\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>t. poly g t = 0 \\<and> 0 < t \\<and> t < 1) =\n  (\\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0)\n\ngoal (1 subgoal):\n 1. ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {}) =\n    no_proots_line p st tt", "unfolding no_proots_line_def proots_within_def"], ["proof (prove)\nusing this:\n  (\\<exists>t. poly g t = 0 \\<and> 0 < t \\<and> t < 1) =\n  (\\<exists>x. x \\<in> closed_segment st tt \\<and> poly p x = 0)\n\ngoal (1 subgoal):\n 1. ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {}) =\n    ({x \\<in> closed_segment st tt. poly p x = 0} = {})", "by blast"], ["proof (state)\nthis:\n  ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {}) =\n  no_proots_line p st tt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ({x. poly g x = 0 \\<and> 0 < x \\<and> x < 1} = {}) =\n  no_proots_line p st tt\n\ngoal (1 subgoal):\n 1. poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0 \\<Longrightarrow>\n    no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "finally"], ["proof (chain)\npicking this:\n  (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n   then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n            pI = map_poly Im pc; g = gcd pR pI\n        in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n   else False) =\n  no_proots_line p st tt", "show ?thesis"], ["proof (prove)\nusing this:\n  (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n   then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n            pI = map_poly Im pc; g = gcd pR pI\n        in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n   else False) =\n  no_proots_line p st tt\n\ngoal (1 subgoal):\n 1. no_proots_line p st tt =\n    (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n     then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n              pI = map_poly Im pc; g = gcd pR pI\n          in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n     else False)", "by simp"], ["proof (state)\nthis:\n  no_proots_line p st tt =\n  (if poly p st \\<noteq> 0 \\<and> poly p tt \\<noteq> 0\n   then let pc = p \\<circ>\\<^sub>p [:st, tt - st:]; pR = map_poly Re pc;\n            pI = map_poly Im pc; g = gcd pR pI\n        in if changes_itv_smods 0 1 g (pderiv g) = 0 then True else False\n   else False)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Counting roots in a rectangle\\<close>"], ["", "definition proots_rectangle ::\"complex poly \\<Rightarrow> complex \\<Rightarrow> complex \\<Rightarrow> nat\" where\n  \"proots_rectangle p lb ub = proots_count p (box lb ub)\""], ["", "lemma closed_segment_imp_Re_Im:\n  fixes x::complex\n  assumes \"x\\<in>closed_segment lb ub\" \n  shows \"Re lb \\<le> Re ub \\<Longrightarrow> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\" \n        \"Im lb \\<le> Im ub \\<Longrightarrow> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re lb \\<le> Re ub \\<Longrightarrow>\n     Re lb \\<le> Re x \\<and> Re x \\<le> Re ub) &&&\n    (Im lb \\<le> Im ub \\<Longrightarrow>\n     Im lb \\<le> Im x \\<and> Im x \\<le> Im ub)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Re lb \\<le> Re ub \\<Longrightarrow>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n 2. Im lb \\<le> Im ub \\<Longrightarrow>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub", "obtain u where x_u:\"x=(1 - u) *\\<^sub>R lb + u *\\<^sub>R ub \" and \"0 \\<le> u\" \"u \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub; 0 \\<le> u;\n         u \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> closed_segment lb ub\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub; 0 \\<le> u;\n         u \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding closed_segment_def"], ["proof (prove)\nusing this:\n  x \\<in> {(1 - u) *\\<^sub>R lb + u *\\<^sub>R ub |u.\n           0 \\<le> u \\<and> u \\<le> 1}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub; 0 \\<le> u;\n         u \\<le> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (2 subgoals):\n 1. Re lb \\<le> Re ub \\<Longrightarrow>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n 2. Im lb \\<le> Im ub \\<Longrightarrow>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub", "have \"Re lb \\<le> Re x\" when \"Re lb \\<le> Re ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re lb \\<le> Re x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re lb \\<le> Re x", "have \"Re x = Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re x = Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)", "using x_u"], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n\ngoal (1 subgoal):\n 1. Re x = Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)", "by blast"], ["proof (state)\nthis:\n  Re x = Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\n\ngoal (1 subgoal):\n 1. Re lb \\<le> Re x", "also"], ["proof (state)\nthis:\n  Re x = Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\n\ngoal (1 subgoal):\n 1. Re lb \\<le> Re x", "have \"... = Re (lb + u *\\<^sub>R (ub - lb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) =\n    Re (lb + u *\\<^sub>R (ub - lb))", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) =\n  Re (lb + u *\\<^sub>R (ub - lb))\n\ngoal (1 subgoal):\n 1. Re lb \\<le> Re x", "also"], ["proof (state)\nthis:\n  Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) =\n  Re (lb + u *\\<^sub>R (ub - lb))\n\ngoal (1 subgoal):\n 1. Re lb \\<le> Re x", "have \"... = Re lb + u * (Re ub - Re lb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (lb + u *\\<^sub>R (ub - lb)) = Re lb + u * (Re ub - Re lb)", "by auto"], ["proof (state)\nthis:\n  Re (lb + u *\\<^sub>R (ub - lb)) = Re lb + u * (Re ub - Re lb)\n\ngoal (1 subgoal):\n 1. Re lb \\<le> Re x", "also"], ["proof (state)\nthis:\n  Re (lb + u *\\<^sub>R (ub - lb)) = Re lb + u * (Re ub - Re lb)\n\ngoal (1 subgoal):\n 1. Re lb \\<le> Re x", "have \"... \\<ge> Re lb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re lb \\<le> Re lb + u * (Re ub - Re lb)", "using \\<open>u\\<ge>0\\<close> \\<open>Re lb \\<le> Re ub\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> u\n  Re lb \\<le> Re ub\n\ngoal (1 subgoal):\n 1. Re lb \\<le> Re lb + u * (Re ub - Re lb)", "by auto"], ["proof (state)\nthis:\n  Re lb \\<le> Re lb + u * (Re ub - Re lb)\n\ngoal (1 subgoal):\n 1. Re lb \\<le> Re x", "finally"], ["proof (chain)\npicking this:\n  Re lb \\<le> Re x", "show ?thesis"], ["proof (prove)\nusing this:\n  Re lb \\<le> Re x\n\ngoal (1 subgoal):\n 1. Re lb \\<le> Re x", "."], ["proof (state)\nthis:\n  Re lb \\<le> Re x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re lb \\<le> Re ub \\<Longrightarrow> Re lb \\<le> Re x\n\ngoal (2 subgoals):\n 1. Re lb \\<le> Re ub \\<Longrightarrow>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n 2. Im lb \\<le> Im ub \\<Longrightarrow>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub", "moreover"], ["proof (state)\nthis:\n  Re lb \\<le> Re ub \\<Longrightarrow> Re lb \\<le> Re x\n\ngoal (2 subgoals):\n 1. Re lb \\<le> Re ub \\<Longrightarrow>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n 2. Im lb \\<le> Im ub \\<Longrightarrow>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub", "have \"Im lb \\<le> Im x\" when \"Im lb \\<le> Im ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im lb \\<le> Im x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im lb \\<le> Im x", "have \"Im x = Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x = Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)", "using x_u"], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n\ngoal (1 subgoal):\n 1. Im x = Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)", "by blast"], ["proof (state)\nthis:\n  Im x = Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\n\ngoal (1 subgoal):\n 1. Im lb \\<le> Im x", "also"], ["proof (state)\nthis:\n  Im x = Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\n\ngoal (1 subgoal):\n 1. Im lb \\<le> Im x", "have \"... = Im (lb + u *\\<^sub>R (ub - lb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) =\n    Im (lb + u *\\<^sub>R (ub - lb))", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) =\n  Im (lb + u *\\<^sub>R (ub - lb))\n\ngoal (1 subgoal):\n 1. Im lb \\<le> Im x", "also"], ["proof (state)\nthis:\n  Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) =\n  Im (lb + u *\\<^sub>R (ub - lb))\n\ngoal (1 subgoal):\n 1. Im lb \\<le> Im x", "have \"... = Im lb + u * (Im ub - Im lb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (lb + u *\\<^sub>R (ub - lb)) = Im lb + u * (Im ub - Im lb)", "by auto"], ["proof (state)\nthis:\n  Im (lb + u *\\<^sub>R (ub - lb)) = Im lb + u * (Im ub - Im lb)\n\ngoal (1 subgoal):\n 1. Im lb \\<le> Im x", "also"], ["proof (state)\nthis:\n  Im (lb + u *\\<^sub>R (ub - lb)) = Im lb + u * (Im ub - Im lb)\n\ngoal (1 subgoal):\n 1. Im lb \\<le> Im x", "have \"... \\<ge> Im lb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im lb \\<le> Im lb + u * (Im ub - Im lb)", "using \\<open>u\\<ge>0\\<close> \\<open>Im lb \\<le> Im ub\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> u\n  Im lb \\<le> Im ub\n\ngoal (1 subgoal):\n 1. Im lb \\<le> Im lb + u * (Im ub - Im lb)", "by auto"], ["proof (state)\nthis:\n  Im lb \\<le> Im lb + u * (Im ub - Im lb)\n\ngoal (1 subgoal):\n 1. Im lb \\<le> Im x", "finally"], ["proof (chain)\npicking this:\n  Im lb \\<le> Im x", "show ?thesis"], ["proof (prove)\nusing this:\n  Im lb \\<le> Im x\n\ngoal (1 subgoal):\n 1. Im lb \\<le> Im x", "."], ["proof (state)\nthis:\n  Im lb \\<le> Im x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im lb \\<le> Im ub \\<Longrightarrow> Im lb \\<le> Im x\n\ngoal (2 subgoals):\n 1. Re lb \\<le> Re ub \\<Longrightarrow>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n 2. Im lb \\<le> Im ub \\<Longrightarrow>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub", "moreover"], ["proof (state)\nthis:\n  Im lb \\<le> Im ub \\<Longrightarrow> Im lb \\<le> Im x\n\ngoal (2 subgoals):\n 1. Re lb \\<le> Re ub \\<Longrightarrow>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n 2. Im lb \\<le> Im ub \\<Longrightarrow>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub", "have \"Re x \\<le> Re ub\" when \"Re lb \\<le> Re ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re x \\<le> Re ub", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re x \\<le> Re ub", "have \"Re x = Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re x = Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)", "using x_u"], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n\ngoal (1 subgoal):\n 1. Re x = Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)", "by blast"], ["proof (state)\nthis:\n  Re x = Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\n\ngoal (1 subgoal):\n 1. Re x \\<le> Re ub", "also"], ["proof (state)\nthis:\n  Re x = Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\n\ngoal (1 subgoal):\n 1. Re x \\<le> Re ub", "have \"... = (1 - u) * Re lb + u * Re ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) = (1 - u) * Re lb + u * Re ub", "by auto"], ["proof (state)\nthis:\n  Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) = (1 - u) * Re lb + u * Re ub\n\ngoal (1 subgoal):\n 1. Re x \\<le> Re ub", "also"], ["proof (state)\nthis:\n  Re ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) = (1 - u) * Re lb + u * Re ub\n\ngoal (1 subgoal):\n 1. Re x \\<le> Re ub", "have \"... \\<le> (1 - u) * Re ub + u * Re ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - u) * Re lb + u * Re ub \\<le> (1 - u) * Re ub + u * Re ub", "using \\<open>u\\<le>1\\<close> \\<open>Re lb \\<le> Re ub\\<close>"], ["proof (prove)\nusing this:\n  u \\<le> 1\n  Re lb \\<le> Re ub\n\ngoal (1 subgoal):\n 1. (1 - u) * Re lb + u * Re ub \\<le> (1 - u) * Re ub + u * Re ub", "by (auto simp add: mult_left_mono)"], ["proof (state)\nthis:\n  (1 - u) * Re lb + u * Re ub \\<le> (1 - u) * Re ub + u * Re ub\n\ngoal (1 subgoal):\n 1. Re x \\<le> Re ub", "also"], ["proof (state)\nthis:\n  (1 - u) * Re lb + u * Re ub \\<le> (1 - u) * Re ub + u * Re ub\n\ngoal (1 subgoal):\n 1. Re x \\<le> Re ub", "have \"... = Re ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - u) * Re ub + u * Re ub = Re ub", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (1 - u) * Re ub + u * Re ub = Re ub\n\ngoal (1 subgoal):\n 1. Re x \\<le> Re ub", "finally"], ["proof (chain)\npicking this:\n  Re x \\<le> Re ub", "show ?thesis"], ["proof (prove)\nusing this:\n  Re x \\<le> Re ub\n\ngoal (1 subgoal):\n 1. Re x \\<le> Re ub", "."], ["proof (state)\nthis:\n  Re x \\<le> Re ub\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re lb \\<le> Re ub \\<Longrightarrow> Re x \\<le> Re ub\n\ngoal (2 subgoals):\n 1. Re lb \\<le> Re ub \\<Longrightarrow>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n 2. Im lb \\<le> Im ub \\<Longrightarrow>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub", "moreover"], ["proof (state)\nthis:\n  Re lb \\<le> Re ub \\<Longrightarrow> Re x \\<le> Re ub\n\ngoal (2 subgoals):\n 1. Re lb \\<le> Re ub \\<Longrightarrow>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n 2. Im lb \\<le> Im ub \\<Longrightarrow>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub", "have \"Im x \\<le> Im ub\" when \"Im lb \\<le> Im ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x \\<le> Im ub", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im x \\<le> Im ub", "have \"Im x = Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x = Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)", "using x_u"], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n\ngoal (1 subgoal):\n 1. Im x = Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)", "by blast"], ["proof (state)\nthis:\n  Im x = Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\n\ngoal (1 subgoal):\n 1. Im x \\<le> Im ub", "also"], ["proof (state)\nthis:\n  Im x = Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub)\n\ngoal (1 subgoal):\n 1. Im x \\<le> Im ub", "have \"... = (1 - u) * Im lb + u * Im ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) = (1 - u) * Im lb + u * Im ub", "by auto"], ["proof (state)\nthis:\n  Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) = (1 - u) * Im lb + u * Im ub\n\ngoal (1 subgoal):\n 1. Im x \\<le> Im ub", "also"], ["proof (state)\nthis:\n  Im ((1 - u) *\\<^sub>R lb + u *\\<^sub>R ub) = (1 - u) * Im lb + u * Im ub\n\ngoal (1 subgoal):\n 1. Im x \\<le> Im ub", "have \"... \\<le> (1 - u) * Im ub + u * Im ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - u) * Im lb + u * Im ub \\<le> (1 - u) * Im ub + u * Im ub", "using \\<open>u\\<le>1\\<close> \\<open>Im lb \\<le> Im ub\\<close>"], ["proof (prove)\nusing this:\n  u \\<le> 1\n  Im lb \\<le> Im ub\n\ngoal (1 subgoal):\n 1. (1 - u) * Im lb + u * Im ub \\<le> (1 - u) * Im ub + u * Im ub", "by (auto simp add: mult_left_mono)"], ["proof (state)\nthis:\n  (1 - u) * Im lb + u * Im ub \\<le> (1 - u) * Im ub + u * Im ub\n\ngoal (1 subgoal):\n 1. Im x \\<le> Im ub", "also"], ["proof (state)\nthis:\n  (1 - u) * Im lb + u * Im ub \\<le> (1 - u) * Im ub + u * Im ub\n\ngoal (1 subgoal):\n 1. Im x \\<le> Im ub", "have \"... = Im ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - u) * Im ub + u * Im ub = Im ub", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  (1 - u) * Im ub + u * Im ub = Im ub\n\ngoal (1 subgoal):\n 1. Im x \\<le> Im ub", "finally"], ["proof (chain)\npicking this:\n  Im x \\<le> Im ub", "show ?thesis"], ["proof (prove)\nusing this:\n  Im x \\<le> Im ub\n\ngoal (1 subgoal):\n 1. Im x \\<le> Im ub", "."], ["proof (state)\nthis:\n  Im x \\<le> Im ub\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im lb \\<le> Im ub \\<Longrightarrow> Im x \\<le> Im ub\n\ngoal (2 subgoals):\n 1. Re lb \\<le> Re ub \\<Longrightarrow>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n 2. Im lb \\<le> Im ub \\<Longrightarrow>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub", "ultimately"], ["proof (chain)\npicking this:\n  Re lb \\<le> Re ub \\<Longrightarrow> Re lb \\<le> Re x\n  Im lb \\<le> Im ub \\<Longrightarrow> Im lb \\<le> Im x\n  Re lb \\<le> Re ub \\<Longrightarrow> Re x \\<le> Re ub\n  Im lb \\<le> Im ub \\<Longrightarrow> Im x \\<le> Im ub", "show \n      \"Re lb \\<le> Re ub \\<Longrightarrow> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\" \n      \"Im lb \\<le> Im ub \\<Longrightarrow> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\""], ["proof (prove)\nusing this:\n  Re lb \\<le> Re ub \\<Longrightarrow> Re lb \\<le> Re x\n  Im lb \\<le> Im ub \\<Longrightarrow> Im lb \\<le> Im x\n  Re lb \\<le> Re ub \\<Longrightarrow> Re x \\<le> Re ub\n  Im lb \\<le> Im ub \\<Longrightarrow> Im x \\<le> Im ub\n\ngoal (1 subgoal):\n 1. (Re lb \\<le> Re ub \\<Longrightarrow>\n     Re lb \\<le> Re x \\<and> Re x \\<le> Re ub) &&&\n    (Im lb \\<le> Im ub \\<Longrightarrow>\n     Im lb \\<le> Im x \\<and> Im x \\<le> Im ub)", "by auto"], ["proof (state)\nthis:\n  Re lb \\<le> Re ub \\<Longrightarrow>\n  Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n  Im lb \\<le> Im ub \\<Longrightarrow>\n  Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_segment_degen_complex:\n  \"\\<lbrakk>Re lb = Re ub; Im lb \\<le> Im ub \\<rbrakk> \n    \\<Longrightarrow> x \\<in> closed_segment lb ub \\<longleftrightarrow> Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub \"\n  \"\\<lbrakk>Im lb = Im ub; Re lb \\<le> Re ub \\<rbrakk> \n    \\<Longrightarrow> x \\<in> closed_segment lb ub \\<longleftrightarrow> Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>Re lb = Re ub; Im lb \\<le> Im ub\\<rbrakk>\n     \\<Longrightarrow> (x \\<in> closed_segment lb ub) =\n                       (Re x = Re lb \\<and>\n                        Im lb \\<le> Im x \\<and> Im x \\<le> Im ub)) &&&\n    (\\<lbrakk>Im lb = Im ub; Re lb \\<le> Re ub\\<rbrakk>\n     \\<Longrightarrow> (x \\<in> closed_segment lb ub) =\n                       (Im x = Im lb \\<and>\n                        Re lb \\<le> Re x \\<and> Re x \\<le> Re ub))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Re lb = Re ub; Im lb \\<le> Im ub\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> closed_segment lb ub) =\n                      (Re x = Re lb \\<and>\n                       Im lb \\<le> Im x \\<and> Im x \\<le> Im ub)\n 2. \\<lbrakk>Im lb = Im ub; Re lb \\<le> Re ub\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> closed_segment lb ub) =\n                      (Im x = Im lb \\<and>\n                       Re lb \\<le> Re x \\<and> Re x \\<le> Re ub)", "show \"x \\<in> closed_segment lb ub \\<longleftrightarrow> Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\"\n    when \"Re lb = Re ub\" \"Im lb \\<le> Im ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> closed_segment lb ub) =\n    (Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\n 2. Re x = Re lb \\<and>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "show \"Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\" when \"x \\<in> closed_segment lb ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub", "using closed_segment_imp_Re_Im[OF that] \\<open>Re lb = Re ub\\<close> \\<open>Im lb \\<le> Im ub\\<close>"], ["proof (prove)\nusing this:\n  Re lb \\<le> Re ub \\<Longrightarrow>\n  Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n  Im lb \\<le> Im ub \\<Longrightarrow>\n  Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\n  Re lb = Re ub\n  Im lb \\<le> Im ub\n\ngoal (1 subgoal):\n 1. Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> closed_segment lb ub \\<Longrightarrow>\n  Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Re x = Re lb \\<and>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Re x = Re lb \\<and>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "assume asm:\"Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\""], ["proof (state)\nthis:\n  Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Re x = Re lb \\<and>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "define u where \"u=(Im x - Im lb)/ (Im ub - Im lb)\""], ["proof (state)\nthis:\n  u = (Im x - Im lb) / (Im ub - Im lb)\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Re x = Re lb \\<and>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "have \"x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    (1 - (Im x - Im lb) / (Im ub - Im lb)) *\\<^sub>R lb +\n    ((Im x - Im lb) / (Im ub - Im lb)) *\\<^sub>R ub", "using asm \\<open>Re lb = Re ub\\<close> \\<open>Im lb \\<le> Im ub\\<close>"], ["proof (prove)\nusing this:\n  Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\n  Re lb = Re ub\n  Im lb \\<le> Im ub\n\ngoal (1 subgoal):\n 1. x =\n    (1 - (Im x - Im lb) / (Im ub - Im lb)) *\\<^sub>R lb +\n    ((Im x - Im lb) / (Im ub - Im lb)) *\\<^sub>R ub", "apply (intro complex_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub;\n     Re lb = Re ub; Im lb \\<le> Im ub\\<rbrakk>\n    \\<Longrightarrow> Re x =\n                      Re ((1 - (Im x - Im lb) / (Im ub - Im lb)) *\\<^sub>R\n                          lb +\n                          ((Im x - Im lb) / (Im ub - Im lb)) *\\<^sub>R ub)\n 2. \\<lbrakk>Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub;\n     Re lb = Re ub; Im lb \\<le> Im ub\\<rbrakk>\n    \\<Longrightarrow> Im x =\n                      Im ((1 - (Im x - Im lb) / (Im ub - Im lb)) *\\<^sub>R\n                          lb +\n                          ((Im x - Im lb) / (Im ub - Im lb)) *\\<^sub>R ub)", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Re lb = Re ub; Re x = Re ub; Im lb \\<le> Im x;\n     Im x \\<le> Im ub\\<rbrakk>\n    \\<Longrightarrow> Im x +\n                      (Im lb * Im x - Im lb * Im lb) / (Im ub - Im lb) =\n                      Im lb +\n                      (Im ub * Im x - Im lb * Im ub) / (Im ub - Im lb)", "apply (cases \"Im ub - Im lb =0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Re lb = Re ub; Re x = Re ub; Im lb \\<le> Im x;\n     Im x \\<le> Im ub; Im ub - Im lb = 0\\<rbrakk>\n    \\<Longrightarrow> Im x +\n                      (Im lb * Im x - Im lb * Im lb) / (Im ub - Im lb) =\n                      Im lb +\n                      (Im ub * Im x - Im lb * Im ub) / (Im ub - Im lb)\n 2. \\<lbrakk>Re lb = Re ub; Re x = Re ub; Im lb \\<le> Im x;\n     Im x \\<le> Im ub; Im ub - Im lb \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Im x +\n                      (Im lb * Im x - Im lb * Im lb) / (Im ub - Im lb) =\n                      Im lb +\n                      (Im ub * Im x - Im lb * Im ub) / (Im ub - Im lb)", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Re x = Re lb \\<and>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "moreover"], ["proof (state)\nthis:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Re x = Re lb \\<and>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "have \"0\\<le>u\" \"u\\<le>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> u &&& u \\<le> 1", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (Im x - Im lb) / (Im ub - Im lb) &&&\n    (Im x - Im lb) / (Im ub - Im lb) \\<le> 1", "using \\<open>Im lb \\<le> Im ub\\<close> asm"], ["proof (prove)\nusing this:\n  Im lb \\<le> Im ub\n  Re x = Re lb \\<and> Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\n\ngoal (1 subgoal):\n 1. 0 \\<le> (Im x - Im lb) / (Im ub - Im lb) &&&\n    (Im x - Im lb) / (Im ub - Im lb) \\<le> 1", "by (cases \"Im ub - Im lb =0\",auto simp add:field_simps)+"], ["proof (state)\nthis:\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Re x = Re lb \\<and>\n    Im lb \\<le> Im x \\<and> Im x \\<le> Im ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "ultimately"], ["proof (chain)\npicking this:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n  0 \\<le> u\n  u \\<le> 1", "show \"x \\<in> closed_segment lb ub\""], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (1 subgoal):\n 1. x \\<in> closed_segment lb ub", "unfolding closed_segment_def"], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (1 subgoal):\n 1. x \\<in> {(1 - u) *\\<^sub>R lb + u *\\<^sub>R ub |u.\n             0 \\<le> u \\<and> u \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  x \\<in> closed_segment lb ub\n\ngoal (1 subgoal):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re lb = Re ub; Im lb \\<le> Im ub\\<rbrakk>\n  \\<Longrightarrow> (x \\<in> closed_segment lb ub) =\n                    (Re x = Re lb \\<and>\n                     Im lb \\<le> Im x \\<and> Im x \\<le> Im ub)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Re lb = Re ub; Im lb \\<le> Im ub\\<rbrakk>\n    \\<Longrightarrow> Re lb = Re ub\n 2. \\<lbrakk>Re lb = Re ub; Im lb \\<le> Im ub\\<rbrakk>\n    \\<Longrightarrow> Im lb \\<le> Im ub\n 3. \\<lbrakk>Im lb = Im ub; Re lb \\<le> Re ub\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> closed_segment lb ub) =\n                      (Im x = Im lb \\<and>\n                       Re lb \\<le> Re x \\<and> Re x \\<le> Re ub)", "show \"x \\<in> closed_segment lb ub \\<longleftrightarrow> Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\"\n    when \"Im lb = Im ub\" \"Re lb \\<le> Re ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> closed_segment lb ub) =\n    (Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n 2. Im x = Im lb \\<and>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "show \"Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\" when \"x \\<in> closed_segment lb ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub", "using closed_segment_imp_Re_Im[OF that] \\<open>Im lb = Im ub\\<close> \\<open>Re lb \\<le> Re ub\\<close>"], ["proof (prove)\nusing this:\n  Re lb \\<le> Re ub \\<Longrightarrow>\n  Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n  Im lb \\<le> Im ub \\<Longrightarrow>\n  Im lb \\<le> Im x \\<and> Im x \\<le> Im ub\n  Im lb = Im ub\n  Re lb \\<le> Re ub\n\ngoal (1 subgoal):\n 1. Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> closed_segment lb ub \\<Longrightarrow>\n  Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Im x = Im lb \\<and>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Im x = Im lb \\<and>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "assume asm:\"Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\""], ["proof (state)\nthis:\n  Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Im x = Im lb \\<and>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "define u where \"u=(Re x - Re lb)/ (Re ub - Re lb)\""], ["proof (state)\nthis:\n  u = (Re x - Re lb) / (Re ub - Re lb)\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Im x = Im lb \\<and>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "have \"x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    (1 - (Re x - Re lb) / (Re ub - Re lb)) *\\<^sub>R lb +\n    ((Re x - Re lb) / (Re ub - Re lb)) *\\<^sub>R ub", "using asm \\<open>Im lb = Im ub\\<close> \\<open>Re lb \\<le> Re ub\\<close>"], ["proof (prove)\nusing this:\n  Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n  Im lb = Im ub\n  Re lb \\<le> Re ub\n\ngoal (1 subgoal):\n 1. x =\n    (1 - (Re x - Re lb) / (Re ub - Re lb)) *\\<^sub>R lb +\n    ((Re x - Re lb) / (Re ub - Re lb)) *\\<^sub>R ub", "apply (intro complex_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub;\n     Im lb = Im ub; Re lb \\<le> Re ub\\<rbrakk>\n    \\<Longrightarrow> Re x =\n                      Re ((1 - (Re x - Re lb) / (Re ub - Re lb)) *\\<^sub>R\n                          lb +\n                          ((Re x - Re lb) / (Re ub - Re lb)) *\\<^sub>R ub)\n 2. \\<lbrakk>Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub;\n     Im lb = Im ub; Re lb \\<le> Re ub\\<rbrakk>\n    \\<Longrightarrow> Im x =\n                      Im ((1 - (Re x - Re lb) / (Re ub - Re lb)) *\\<^sub>R\n                          lb +\n                          ((Re x - Re lb) / (Re ub - Re lb)) *\\<^sub>R ub)", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Im lb = Im ub; Im x = Im ub; Re lb \\<le> Re x;\n     Re x \\<le> Re ub\\<rbrakk>\n    \\<Longrightarrow> Re x +\n                      (Re lb * Re x - Re lb * Re lb) / (Re ub - Re lb) =\n                      Re lb +\n                      (Re ub * Re x - Re lb * Re ub) / (Re ub - Re lb)", "apply (cases \"Re ub - Re lb =0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Im lb = Im ub; Im x = Im ub; Re lb \\<le> Re x;\n     Re x \\<le> Re ub; Re ub - Re lb = 0\\<rbrakk>\n    \\<Longrightarrow> Re x +\n                      (Re lb * Re x - Re lb * Re lb) / (Re ub - Re lb) =\n                      Re lb +\n                      (Re ub * Re x - Re lb * Re ub) / (Re ub - Re lb)\n 2. \\<lbrakk>Im lb = Im ub; Im x = Im ub; Re lb \\<le> Re x;\n     Re x \\<le> Re ub; Re ub - Re lb \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Re x +\n                      (Re lb * Re x - Re lb * Re lb) / (Re ub - Re lb) =\n                      Re lb +\n                      (Re ub * Re x - Re lb * Re ub) / (Re ub - Re lb)", "apply (auto simp add:field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Im x = Im lb \\<and>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "moreover"], ["proof (state)\nthis:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Im x = Im lb \\<and>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "have \"0\\<le>u\" \"u\\<le>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> u &&& u \\<le> 1", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (Re x - Re lb) / (Re ub - Re lb) &&&\n    (Re x - Re lb) / (Re ub - Re lb) \\<le> 1", "using \\<open>Re lb \\<le> Re ub\\<close> asm"], ["proof (prove)\nusing this:\n  Re lb \\<le> Re ub\n  Im x = Im lb \\<and> Re lb \\<le> Re x \\<and> Re x \\<le> Re ub\n\ngoal (1 subgoal):\n 1. 0 \\<le> (Re x - Re lb) / (Re ub - Re lb) &&&\n    (Re x - Re lb) / (Re ub - Re lb) \\<le> 1", "by (cases \"Re ub - Re lb =0\",auto simp add:field_simps)+"], ["proof (state)\nthis:\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (2 subgoals):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub\n 2. Im x = Im lb \\<and>\n    Re lb \\<le> Re x \\<and> Re x \\<le> Re ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "ultimately"], ["proof (chain)\npicking this:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n  0 \\<le> u\n  u \\<le> 1", "show \"x \\<in> closed_segment lb ub\""], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (1 subgoal):\n 1. x \\<in> closed_segment lb ub", "unfolding closed_segment_def"], ["proof (prove)\nusing this:\n  x = (1 - u) *\\<^sub>R lb + u *\\<^sub>R ub\n  0 \\<le> u\n  u \\<le> 1\n\ngoal (1 subgoal):\n 1. x \\<in> {(1 - u) *\\<^sub>R lb + u *\\<^sub>R ub |u.\n             0 \\<le> u \\<and> u \\<le> 1}", "by auto"], ["proof (state)\nthis:\n  x \\<in> closed_segment lb ub\n\ngoal (1 subgoal):\n 1. x \\<in> closed_segment lb ub \\<Longrightarrow>\n    x \\<in> closed_segment lb ub", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Im lb = Im ub; Re lb \\<le> Re ub\\<rbrakk>\n  \\<Longrightarrow> (x \\<in> closed_segment lb ub) =\n                    (Im x = Im lb \\<and>\n                     Re lb \\<le> Re x \\<and> Re x \\<le> Re ub)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>Re lb = Re ub; Im lb \\<le> Im ub\\<rbrakk>\n    \\<Longrightarrow> Re lb = Re ub\n 2. \\<lbrakk>Re lb = Re ub; Im lb \\<le> Im ub\\<rbrakk>\n    \\<Longrightarrow> Im lb \\<le> Im ub\n 3. \\<lbrakk>Im lb = Im ub; Re lb \\<le> Re ub\\<rbrakk>\n    \\<Longrightarrow> Im lb = Im ub\n 4. \\<lbrakk>Im lb = Im ub; Re lb \\<le> Re ub\\<rbrakk>\n    \\<Longrightarrow> Re lb \\<le> Re ub", "qed"], ["", "lemma complex_box_ne_empty: \n  fixes a b::complex\n  shows \n    \"cbox a b \\<noteq> {} \\<longleftrightarrow> (Re a \\<le> Re b \\<and> Im a \\<le> Im b)\"\n    \"box a b \\<noteq> {} \\<longleftrightarrow> (Re a < Re b \\<and> Im a < Im b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cbox a b \\<noteq> {}) = (Re a \\<le> Re b \\<and> Im a \\<le> Im b) &&&\n    (box a b \\<noteq> {}) = (Re a < Re b \\<and> Im a < Im b)", "by (auto simp add:box_ne_empty Basis_complex_def)"], ["", "lemma proots_rectangle_code1:\n  \"proots_rectangle p lb ub = (if Re lb < Re ub \\<and> Im lb < Im ub then \n            if p\\<noteq>0 then \n            if no_proots_line p lb (Complex (Re ub) (Im lb))\n            \\<and> no_proots_line p (Complex (Re ub) (Im lb)) ub\n            \\<and> no_proots_line p ub (Complex (Re lb) (Im ub))\n            \\<and> no_proots_line p (Complex (Re lb) (Im ub)) lb then  \n            (\n            let p1 = pcompose p [:lb,  Complex (Re ub - Re lb) 0:];\n                pR1 = map_poly Re p1; pI1 = map_poly Im p1; gc1 = gcd pR1 pI1;\n                p2 = pcompose p [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):];\n                pR2 = map_poly Re p2; pI2 = map_poly Im p2; gc2 = gcd pR2 pI2;\n                p3 = pcompose p [:ub, Complex (Re lb - Re ub) 0:];\n                pR3 = map_poly Re p3; pI3 = map_poly Im p3; gc3 = gcd pR3 pI3;\n                p4 = pcompose p [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):];\n                pR4 = map_poly Re p4; pI4 = map_poly Im p4; gc4 = gcd pR4 pI4\n            in \n              nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1)\n                + changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2)\n                + changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3)\n                + changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4))  div 4)\n            )\n            else Code.abort (STR ''proots_rectangle fails when there is a root on the border.'') \n            (\\<lambda>_. proots_rectangle p lb ub)\n            else Code.abort (STR ''proots_rectangle fails when p=0.'') \n            (\\<lambda>_. proots_rectangle p lb ub)\n            else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have ?thesis when \"\\<not> (Re lb < Re ub \\<and> Im lb < Im ub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have \"box lb ub = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. box lb ub = {}", "using complex_box_ne_empty[of lb ub] that"], ["proof (prove)\nusing this:\n  (cbox lb ub \\<noteq> {}) = (Re lb \\<le> Re ub \\<and> Im lb \\<le> Im ub)\n  (box lb ub \\<noteq> {}) = (Re lb < Re ub \\<and> Im lb < Im ub)\n  \\<not> (Re lb < Re ub \\<and> Im lb < Im ub)\n\ngoal (1 subgoal):\n 1. box lb ub = {}", "by auto"], ["proof (state)\nthis:\n  box lb ub = {}\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "then"], ["proof (chain)\npicking this:\n  box lb ub = {}", "have \"proots_rectangle p lb ub = 0\""], ["proof (prove)\nusing this:\n  box lb ub = {}\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub = 0", "unfolding proots_rectangle_def"], ["proof (prove)\nusing this:\n  box lb ub = {}\n\ngoal (1 subgoal):\n 1. proots_count p (box lb ub) = 0", "by auto"], ["proof (state)\nthis:\n  proots_rectangle p lb ub = 0\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "then"], ["proof (chain)\npicking this:\n  proots_rectangle p lb ub = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_rectangle p lb ub = 0\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "by (simp add:that)"], ["proof (state)\nthis:\n  proots_rectangle p lb ub =\n  (if Re lb < Re ub \\<and> Im lb < Im ub\n   then if p \\<noteq> 0\n        then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                no_proots_line p (Complex (Re lb) (Im ub)) lb\n             then let p1 = p \\<circ>\\<^sub>p\n                           [:lb, Complex (Re ub - Re lb) 0:];\n                      pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                      gc1 = gcd pR1 pI1;\n                      p2 = p \\<circ>\\<^sub>p\n                           [:Complex (Re ub) (Im lb),\n                             Complex 0 (Im ub - Im lb):];\n                      pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                      gc2 = gcd pR2 pI2;\n                      p3 = p \\<circ>\\<^sub>p\n                           [:ub, Complex (Re lb - Re ub) 0:];\n                      pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                      gc3 = gcd pR3 pI3;\n                      p4 = p \\<circ>\\<^sub>p\n                           [:Complex (Re lb) (Im ub),\n                             Complex 0 (Im lb - Im ub):];\n                      pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                      gc4 = gcd pR4 pI4\n                  in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                              (pI1 div gc1) +\n                             changes_alt_itv_smods 0 1 (pR2 div gc2)\n                              (pI2 div gc2) +\n                             changes_alt_itv_smods 0 1 (pR3 div gc3)\n                              (pI3 div gc3) +\n                             changes_alt_itv_smods 0 1 (pR4 div gc4)\n                              (pI4 div gc4)) div\n                          4)\n             else Code.abort\n                   STR ''proots_rectangle fails when there is a root on the border.''\n                   (\\<lambda>_. proots_rectangle p lb ub)\n        else Code.abort STR ''proots_rectangle fails when p=0.''\n              (\\<lambda>_. proots_rectangle p lb ub)\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (Re lb < Re ub \\<and> Im lb < Im ub) \\<Longrightarrow>\n  proots_rectangle p lb ub =\n  (if Re lb < Re ub \\<and> Im lb < Im ub\n   then if p \\<noteq> 0\n        then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                no_proots_line p (Complex (Re lb) (Im ub)) lb\n             then let p1 = p \\<circ>\\<^sub>p\n                           [:lb, Complex (Re ub - Re lb) 0:];\n                      pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                      gc1 = gcd pR1 pI1;\n                      p2 = p \\<circ>\\<^sub>p\n                           [:Complex (Re ub) (Im lb),\n                             Complex 0 (Im ub - Im lb):];\n                      pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                      gc2 = gcd pR2 pI2;\n                      p3 = p \\<circ>\\<^sub>p\n                           [:ub, Complex (Re lb - Re ub) 0:];\n                      pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                      gc3 = gcd pR3 pI3;\n                      p4 = p \\<circ>\\<^sub>p\n                           [:Complex (Re lb) (Im ub),\n                             Complex 0 (Im lb - Im ub):];\n                      pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                      gc4 = gcd pR4 pI4\n                  in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                              (pI1 div gc1) +\n                             changes_alt_itv_smods 0 1 (pR2 div gc2)\n                              (pI2 div gc2) +\n                             changes_alt_itv_smods 0 1 (pR3 div gc3)\n                              (pI3 div gc3) +\n                             changes_alt_itv_smods 0 1 (pR4 div gc4)\n                              (pI4 div gc4)) div\n                          4)\n             else Code.abort\n                   STR ''proots_rectangle fails when there is a root on the border.''\n                   (\\<lambda>_. proots_rectangle p lb ub)\n        else Code.abort STR ''proots_rectangle fails when p=0.''\n              (\\<lambda>_. proots_rectangle p lb ub)\n   else 0)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<not> (Re lb < Re ub \\<and> Im lb < Im ub) \\<Longrightarrow>\n  proots_rectangle p lb ub =\n  (if Re lb < Re ub \\<and> Im lb < Im ub\n   then if p \\<noteq> 0\n        then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                no_proots_line p (Complex (Re lb) (Im ub)) lb\n             then let p1 = p \\<circ>\\<^sub>p\n                           [:lb, Complex (Re ub - Re lb) 0:];\n                      pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                      gc1 = gcd pR1 pI1;\n                      p2 = p \\<circ>\\<^sub>p\n                           [:Complex (Re ub) (Im lb),\n                             Complex 0 (Im ub - Im lb):];\n                      pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                      gc2 = gcd pR2 pI2;\n                      p3 = p \\<circ>\\<^sub>p\n                           [:ub, Complex (Re lb - Re ub) 0:];\n                      pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                      gc3 = gcd pR3 pI3;\n                      p4 = p \\<circ>\\<^sub>p\n                           [:Complex (Re lb) (Im ub),\n                             Complex 0 (Im lb - Im ub):];\n                      pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                      gc4 = gcd pR4 pI4\n                  in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                              (pI1 div gc1) +\n                             changes_alt_itv_smods 0 1 (pR2 div gc2)\n                              (pI2 div gc2) +\n                             changes_alt_itv_smods 0 1 (pR3 div gc3)\n                              (pI3 div gc3) +\n                             changes_alt_itv_smods 0 1 (pR4 div gc4)\n                              (pI4 div gc4)) div\n                          4)\n             else Code.abort\n                   STR ''proots_rectangle fails when there is a root on the border.''\n                   (\\<lambda>_. proots_rectangle p lb ub)\n        else Code.abort STR ''proots_rectangle fails when p=0.''\n              (\\<lambda>_. proots_rectangle p lb ub)\n   else 0)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have ?thesis when \"Re lb < Re ub \\<and> Im lb < Im ub\" \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "using that"], ["proof (prove)\nusing this:\n  Re lb < Re ub \\<and> Im lb < Im ub\n  p = 0\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>Re lb < Re ub \\<and> Im lb < Im ub; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_rectangle p lb ub =\n                    (if Re lb < Re ub \\<and> Im lb < Im ub\n                     then if p \\<noteq> 0\n                          then if no_proots_line p lb\n                                   (Complex (Re ub) (Im lb)) \\<and>\n                                  no_proots_line p (Complex (Re ub) (Im lb))\n                                   ub \\<and>\n                                  no_proots_line p ub\n                                   (Complex (Re lb) (Im ub)) \\<and>\n                                  no_proots_line p (Complex (Re lb) (Im ub))\n                                   lb\n                               then let p1 =\n    p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:];\n  pR1 = map_poly Re p1; pI1 = map_poly Im p1; gc1 = gcd pR1 pI1;\n  p2 = p \\<circ>\\<^sub>p\n       [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):];\n  pR2 = map_poly Re p2; pI2 = map_poly Im p2; gc2 = gcd pR2 pI2;\n  p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:];\n  pR3 = map_poly Re p3; pI3 = map_poly Im p3; gc3 = gcd pR3 pI3;\n  p4 = p \\<circ>\\<^sub>p\n       [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):];\n  pR4 = map_poly Re p4; pI4 = map_poly Im p4; gc4 = gcd pR4 pI4\n                                    in nat\n  (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) +\n      changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) +\n      changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) +\n      changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) div\n   4)\n                               else Code.abort\n                                     STR ''proots_rectangle fails when there is a root on the border.''\n                                     (\\<lambda>_. proots_rectangle p lb ub)\n                          else Code.abort\n                                STR ''proots_rectangle fails when p=0.''\n                                (\\<lambda>_. proots_rectangle p lb ub)\n                     else 0)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>Re lb < Re ub \\<and> Im lb < Im ub; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_rectangle p lb ub =\n                    (if Re lb < Re ub \\<and> Im lb < Im ub\n                     then if p \\<noteq> 0\n                          then if no_proots_line p lb\n                                   (Complex (Re ub) (Im lb)) \\<and>\n                                  no_proots_line p (Complex (Re ub) (Im lb))\n                                   ub \\<and>\n                                  no_proots_line p ub\n                                   (Complex (Re lb) (Im ub)) \\<and>\n                                  no_proots_line p (Complex (Re lb) (Im ub))\n                                   lb\n                               then let p1 =\n    p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:];\n  pR1 = map_poly Re p1; pI1 = map_poly Im p1; gc1 = gcd pR1 pI1;\n  p2 = p \\<circ>\\<^sub>p\n       [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):];\n  pR2 = map_poly Re p2; pI2 = map_poly Im p2; gc2 = gcd pR2 pI2;\n  p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:];\n  pR3 = map_poly Re p3; pI3 = map_poly Im p3; gc3 = gcd pR3 pI3;\n  p4 = p \\<circ>\\<^sub>p\n       [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):];\n  pR4 = map_poly Re p4; pI4 = map_poly Im p4; gc4 = gcd pR4 pI4\n                                    in nat\n  (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) +\n      changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) +\n      changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) +\n      changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) div\n   4)\n                               else Code.abort\n                                     STR ''proots_rectangle fails when there is a root on the border.''\n                                     (\\<lambda>_. proots_rectangle p lb ub)\n                          else Code.abort\n                                STR ''proots_rectangle fails when p=0.''\n                                (\\<lambda>_. proots_rectangle p lb ub)\n                     else 0)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have ?thesis when     \n            \"Re lb < Re ub\" \"Im lb < Im ub\" \"p\\<noteq>0\" \n            and no_proots:\n            \"no_proots_line p lb (Complex (Re ub) (Im lb))\"\n            \"no_proots_line p (Complex (Re ub) (Im lb)) ub\"\n            \"no_proots_line p ub (Complex (Re lb) (Im ub))\"\n            \"no_proots_line p (Complex (Re lb) (Im ub)) lb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define l1 where \"l1 = linepath lb (Complex (Re ub) (Im lb))\""], ["proof (state)\nthis:\n  l1 = linepath lb (Complex (Re ub) (Im lb))\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define l2 where \"l2 = linepath (Complex (Re ub) (Im lb)) ub\""], ["proof (state)\nthis:\n  l2 = linepath (Complex (Re ub) (Im lb)) ub\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define l3 where \"l3 = linepath ub (Complex (Re lb) (Im ub))\""], ["proof (state)\nthis:\n  l3 = linepath ub (Complex (Re lb) (Im ub))\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define l4 where \"l4 = linepath (Complex (Re lb) (Im ub)) lb\""], ["proof (state)\nthis:\n  l4 = linepath (Complex (Re lb) (Im ub)) lb\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define rec where \"rec = l1 +++ l2 +++ l3 +++ l4\""], ["proof (state)\nthis:\n  rec = l1 +++ l2 +++ l3 +++ l4\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have valid[simp]:\"valid_path rec\" and loop[simp]:\"pathfinish rec = pathstart rec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path rec &&& pathfinish rec = pathstart rec", "unfolding rec_def l1_def l2_def l3_def l4_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path\n     (linepath lb (Complex (Re ub) (Im lb)) +++\n      linepath (Complex (Re ub) (Im lb)) ub +++\n      linepath ub (Complex (Re lb) (Im ub)) +++\n      linepath (Complex (Re lb) (Im ub)) lb) &&&\n    pathfinish\n     (linepath lb (Complex (Re ub) (Im lb)) +++\n      linepath (Complex (Re ub) (Im lb)) ub +++\n      linepath ub (Complex (Re lb) (Im ub)) +++\n      linepath (Complex (Re lb) (Im ub)) lb) =\n    pathstart\n     (linepath lb (Complex (Re ub) (Im lb)) +++\n      linepath (Complex (Re ub) (Im lb)) ub +++\n      linepath ub (Complex (Re lb) (Im ub)) +++\n      linepath (Complex (Re lb) (Im ub)) lb)", "by auto"], ["proof (state)\nthis:\n  valid_path rec\n  pathfinish rec = pathstart rec\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have path_no_proots:\"path_image rec \\<inter> proots p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image rec \\<inter> proots p = {}", "unfolding rec_def l1_def l2_def l3_def l4_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image\n     (linepath lb (Complex (Re ub) (Im lb)) +++\n      linepath (Complex (Re ub) (Im lb)) ub +++\n      linepath ub (Complex (Re lb) (Im ub)) +++\n      linepath (Complex (Re lb) (Im ub)) lb) \\<inter>\n    proots p =\n    {}", "apply (subst path_image_join,simp_all del:Complex_eq)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (closed_segment lb (Complex (Re ub) (Im lb)) \\<union>\n     (closed_segment (Complex (Re ub) (Im lb)) ub \\<union>\n      (closed_segment ub (Complex (Re lb) (Im ub)) \\<union>\n       closed_segment (Complex (Re lb) (Im ub)) lb))) \\<inter>\n    proots p =\n    {}", "using no_proots[unfolded no_proots_line_def]"], ["proof (prove)\nusing this:\n  proots_within p (closed_segment lb (Complex (Re ub) (Im lb))) = {}\n  proots_within p (closed_segment (Complex (Re ub) (Im lb)) ub) = {}\n  proots_within p (closed_segment ub (Complex (Re lb) (Im ub))) = {}\n  proots_within p (closed_segment (Complex (Re lb) (Im ub)) lb) = {}\n\ngoal (1 subgoal):\n 1. (closed_segment lb (Complex (Re ub) (Im lb)) \\<union>\n     (closed_segment (Complex (Re ub) (Im lb)) ub \\<union>\n      (closed_segment ub (Complex (Re lb) (Im ub)) \\<union>\n       closed_segment (Complex (Re lb) (Im ub)) lb))) \\<inter>\n    proots p =\n    {}", "by (auto simp del:Complex_eq)"], ["proof (state)\nthis:\n  path_image rec \\<inter> proots p = {}\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define g1 where \"g1 = poly p o l1\""], ["proof (state)\nthis:\n  g1 = poly p \\<circ> l1\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define g2 where \"g2 = poly p o l2\""], ["proof (state)\nthis:\n  g2 = poly p \\<circ> l2\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define g3 where \"g3 = poly p o l3\""], ["proof (state)\nthis:\n  g3 = poly p \\<circ> l3\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define g4 where \"g4 = poly p o l4\""], ["proof (state)\nthis:\n  g4 = poly p \\<circ> l4\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have [simp]: \"path g1\" \"path g2\" \"path g3\" \"path g4\"\n      \"pathfinish g1 = pathstart g2\" \"pathfinish g2 = pathstart g3\" \"pathfinish g3 = pathstart g4\"\n      \"pathfinish g4 = pathstart g1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((path g1 &&& path g2) &&& path g3 &&& path g4) &&&\n    (pathfinish g1 = pathstart g2 &&& pathfinish g2 = pathstart g3) &&&\n    pathfinish g3 = pathstart g4 &&& pathfinish g4 = pathstart g1", "unfolding g1_def g2_def g3_def g4_def l1_def l2_def l3_def l4_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((path (poly p \\<circ> linepath lb (Complex (Re ub) (Im lb))) &&&\n      path (poly p \\<circ> linepath (Complex (Re ub) (Im lb)) ub)) &&&\n     path (poly p \\<circ> linepath ub (Complex (Re lb) (Im ub))) &&&\n     path (poly p \\<circ> linepath (Complex (Re lb) (Im ub)) lb)) &&&\n    (pathfinish (poly p \\<circ> linepath lb (Complex (Re ub) (Im lb))) =\n     pathstart (poly p \\<circ> linepath (Complex (Re ub) (Im lb)) ub) &&&\n     pathfinish (poly p \\<circ> linepath (Complex (Re ub) (Im lb)) ub) =\n     pathstart (poly p \\<circ> linepath ub (Complex (Re lb) (Im ub)))) &&&\n    pathfinish (poly p \\<circ> linepath ub (Complex (Re lb) (Im ub))) =\n    pathstart (poly p \\<circ> linepath (Complex (Re lb) (Im ub)) lb) &&&\n    pathfinish (poly p \\<circ> linepath (Complex (Re lb) (Im ub)) lb) =\n    pathstart (poly p \\<circ> linepath lb (Complex (Re ub) (Im lb)))", "by (auto intro!: path_continuous_image continuous_intros \n          simp add:pathfinish_compose pathstart_compose)"], ["proof (state)\nthis:\n  path g1\n  path g2\n  path g3\n  path g4\n  pathfinish g1 = pathstart g2\n  pathfinish g2 = pathstart g3\n  pathfinish g3 = pathstart g4\n  pathfinish g4 = pathstart g1\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have [simp]: \"finite_ReZ_segments g1 0\" \"finite_ReZ_segments g2 0\" \n         \"finite_ReZ_segments g3 0\" \"finite_ReZ_segments g4 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite_ReZ_segments g1 0 &&& finite_ReZ_segments g2 0) &&&\n    finite_ReZ_segments g3 0 &&& finite_ReZ_segments g4 0", "unfolding g1_def l1_def g2_def l2_def g3_def l3_def g4_def l4_def poly_linepath_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite_ReZ_segments\n      (poly (p \\<circ>\\<^sub>p [:lb, Complex (Re ub) (Im lb) - lb:]) \\<circ>\n       complex_of_real)\n      0 &&&\n     finite_ReZ_segments\n      (poly\n        (p \\<circ>\\<^sub>p\n         [:Complex (Re ub) (Im lb), ub - Complex (Re ub) (Im lb):]) \\<circ>\n       complex_of_real)\n      0) &&&\n    finite_ReZ_segments\n     (poly (p \\<circ>\\<^sub>p [:ub, Complex (Re lb) (Im ub) - ub:]) \\<circ>\n      complex_of_real)\n     0 &&&\n    finite_ReZ_segments\n     (poly\n       (p \\<circ>\\<^sub>p\n        [:Complex (Re lb) (Im ub), lb - Complex (Re lb) (Im ub):]) \\<circ>\n      complex_of_real)\n     0", "by (rule finite_ReZ_segments_poly_of_real)+"], ["proof (state)\nthis:\n  finite_ReZ_segments g1 0\n  finite_ReZ_segments g2 0\n  finite_ReZ_segments g3 0\n  finite_ReZ_segments g4 0\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define p1 pR1 pI1 gc1\n           p2 pR2 pI2 gc2\n           p3 pR3 pI3 gc3\n           p4 pR4 pI4 gc4\n      where \"p1 = pcompose p [:lb,  Complex (Re ub - Re lb) 0:]\"\n             and \"pR1 = map_poly Re p1\" and \"pI1 = map_poly Im p1\" and \"gc1 = gcd pR1 pI1\"\n             and \"p2 = pcompose p [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):]\"\n             and \"pR2 = map_poly Re p2\" and \"pI2 = map_poly Im p2\" and \"gc2 = gcd pR2 pI2\"\n             and \"p3 = pcompose p [:ub, Complex (Re lb - Re ub) 0:]\"\n             and \"pR3 = map_poly Re p3\" and \"pI3 = map_poly Im p3\" and \"gc3 = gcd pR3 pI3\"\n             and \"p4 = pcompose p [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):]\"\n             and \"pR4 = map_poly Re p4\" and \"pI4 = map_poly Im p4\" and \"gc4 = gcd pR4 pI4\""], ["proof (state)\nthis:\n  p1 = p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:]\n  pR1 = map_poly Re p1\n  pI1 = map_poly Im p1\n  gc1 = gcd pR1 pI1\n  p2 =\n  p \\<circ>\\<^sub>p [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):]\n  pR2 = map_poly Re p2\n  pI2 = map_poly Im p2\n  gc2 = gcd pR2 pI2\n  p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:]\n  pR3 = map_poly Re p3\n  pI3 = map_poly Im p3\n  gc3 = gcd pR3 pI3\n  p4 =\n  p \\<circ>\\<^sub>p [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):]\n  pR4 = map_poly Re p4\n  pI4 = map_poly Im p4\n  gc4 = gcd pR4 pI4\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have \"gc1\\<noteq>0\" \"gc2\\<noteq>0\" \"gc3\\<noteq>0\" \"gc4\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gc1 \\<noteq> 0 &&& gc2 \\<noteq> 0) &&&\n    gc3 \\<noteq> 0 &&& gc4 \\<noteq> 0", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. gc1 \\<noteq> 0\n 2. gc2 \\<noteq> 0\n 3. gc3 \\<noteq> 0\n 4. gc4 \\<noteq> 0", "show \"gc1\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gc1 \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> gc1 \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> gc1 \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> gc1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> gc1 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> gc1 \\<noteq> 0", "have \"pI1 = 0\" \"pR1 = 0\""], ["proof (prove)\nusing this:\n  \\<not> gc1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pI1 = 0 &&& pR1 = 0", "unfolding gc1_def"], ["proof (prove)\nusing this:\n  \\<not> gcd pR1 pI1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pI1 = 0 &&& pR1 = 0", "by auto"], ["proof (state)\nthis:\n  pI1 = 0\n  pR1 = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc1 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  pI1 = 0\n  pR1 = 0", "have \"p1 = 0\""], ["proof (prove)\nusing this:\n  pI1 = 0\n  pR1 = 0\n\ngoal (1 subgoal):\n 1. p1 = 0", "unfolding pI1_def pR1_def"], ["proof (prove)\nusing this:\n  map_poly Im p1 = 0\n  map_poly Re p1 = 0\n\ngoal (1 subgoal):\n 1. p1 = 0", "by (metis cpoly_of_decompose map_poly_0)"], ["proof (state)\nthis:\n  p1 = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc1 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p1 = 0", "have \"p=0\""], ["proof (prove)\nusing this:\n  p1 = 0\n\ngoal (1 subgoal):\n 1. p = 0", "unfolding p1_def"], ["proof (prove)\nusing this:\n  p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:] = 0\n\ngoal (1 subgoal):\n 1. p = 0", "using \\<open>Re lb < Re ub\\<close>"], ["proof (prove)\nusing this:\n  p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:] = 0\n  Re lb < Re ub\n\ngoal (1 subgoal):\n 1. p = 0", "by (auto elim!:pcompose_eq_0 simp add:Complex_eq_0)"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc1 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p = 0", "show False"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gc1 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. gc2 \\<noteq> 0\n 2. gc3 \\<noteq> 0\n 3. gc4 \\<noteq> 0", "show \"gc2\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gc2 \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> gc2 \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> gc2 \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> gc2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> gc2 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> gc2 \\<noteq> 0", "have \"pI2 = 0\" \"pR2 = 0\""], ["proof (prove)\nusing this:\n  \\<not> gc2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pI2 = 0 &&& pR2 = 0", "unfolding gc2_def"], ["proof (prove)\nusing this:\n  \\<not> gcd pR2 pI2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pI2 = 0 &&& pR2 = 0", "by auto"], ["proof (state)\nthis:\n  pI2 = 0\n  pR2 = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc2 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  pI2 = 0\n  pR2 = 0", "have \"p2 = 0\""], ["proof (prove)\nusing this:\n  pI2 = 0\n  pR2 = 0\n\ngoal (1 subgoal):\n 1. p2 = 0", "unfolding pI2_def pR2_def"], ["proof (prove)\nusing this:\n  map_poly Im p2 = 0\n  map_poly Re p2 = 0\n\ngoal (1 subgoal):\n 1. p2 = 0", "by (metis cpoly_of_decompose map_poly_0)"], ["proof (state)\nthis:\n  p2 = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc2 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p2 = 0", "have \"p=0\""], ["proof (prove)\nusing this:\n  p2 = 0\n\ngoal (1 subgoal):\n 1. p = 0", "unfolding p2_def"], ["proof (prove)\nusing this:\n  p \\<circ>\\<^sub>p [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):] =\n  0\n\ngoal (1 subgoal):\n 1. p = 0", "using \\<open>Im lb < Im ub\\<close>"], ["proof (prove)\nusing this:\n  p \\<circ>\\<^sub>p [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):] =\n  0\n  Im lb < Im ub\n\ngoal (1 subgoal):\n 1. p = 0", "by (auto elim!:pcompose_eq_0 simp add:Complex_eq_0)"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc2 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p = 0", "show False"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gc2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. gc3 \\<noteq> 0\n 2. gc4 \\<noteq> 0", "show \"gc3\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gc3 \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> gc3 \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> gc3 \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> gc3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> gc3 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> gc3 \\<noteq> 0", "have \"pI3 = 0\" \"pR3 = 0\""], ["proof (prove)\nusing this:\n  \\<not> gc3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pI3 = 0 &&& pR3 = 0", "unfolding gc3_def"], ["proof (prove)\nusing this:\n  \\<not> gcd pR3 pI3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pI3 = 0 &&& pR3 = 0", "by auto"], ["proof (state)\nthis:\n  pI3 = 0\n  pR3 = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc3 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  pI3 = 0\n  pR3 = 0", "have \"p3 = 0\""], ["proof (prove)\nusing this:\n  pI3 = 0\n  pR3 = 0\n\ngoal (1 subgoal):\n 1. p3 = 0", "unfolding pI3_def pR3_def"], ["proof (prove)\nusing this:\n  map_poly Im p3 = 0\n  map_poly Re p3 = 0\n\ngoal (1 subgoal):\n 1. p3 = 0", "by (metis cpoly_of_decompose map_poly_0)"], ["proof (state)\nthis:\n  p3 = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc3 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p3 = 0", "have \"p=0\""], ["proof (prove)\nusing this:\n  p3 = 0\n\ngoal (1 subgoal):\n 1. p = 0", "unfolding p3_def"], ["proof (prove)\nusing this:\n  p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:] = 0\n\ngoal (1 subgoal):\n 1. p = 0", "using \\<open>Re lb < Re ub\\<close>"], ["proof (prove)\nusing this:\n  p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:] = 0\n  Re lb < Re ub\n\ngoal (1 subgoal):\n 1. p = 0", "by (auto elim!:pcompose_eq_0 simp add:Complex_eq_0)"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc3 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p = 0", "show False"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gc3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gc4 \\<noteq> 0", "show \"gc4\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gc4 \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> gc4 \\<noteq> 0 \\<Longrightarrow> False", "assume \"\\<not> gc4 \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<not> gc4 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> gc4 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> gc4 \\<noteq> 0", "have \"pI4 = 0\" \"pR4 = 0\""], ["proof (prove)\nusing this:\n  \\<not> gc4 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pI4 = 0 &&& pR4 = 0", "unfolding gc4_def"], ["proof (prove)\nusing this:\n  \\<not> gcd pR4 pI4 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pI4 = 0 &&& pR4 = 0", "by auto"], ["proof (state)\nthis:\n  pI4 = 0\n  pR4 = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc4 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  pI4 = 0\n  pR4 = 0", "have \"p4 = 0\""], ["proof (prove)\nusing this:\n  pI4 = 0\n  pR4 = 0\n\ngoal (1 subgoal):\n 1. p4 = 0", "unfolding pI4_def pR4_def"], ["proof (prove)\nusing this:\n  map_poly Im p4 = 0\n  map_poly Re p4 = 0\n\ngoal (1 subgoal):\n 1. p4 = 0", "by (metis cpoly_of_decompose map_poly_0)"], ["proof (state)\nthis:\n  p4 = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc4 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p4 = 0", "have \"p=0\""], ["proof (prove)\nusing this:\n  p4 = 0\n\ngoal (1 subgoal):\n 1. p = 0", "unfolding p4_def"], ["proof (prove)\nusing this:\n  p \\<circ>\\<^sub>p [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):] =\n  0\n\ngoal (1 subgoal):\n 1. p = 0", "using \\<open>Im lb < Im ub\\<close>"], ["proof (prove)\nusing this:\n  p \\<circ>\\<^sub>p [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):] =\n  0\n  Im lb < Im ub\n\ngoal (1 subgoal):\n 1. p = 0", "by (auto elim!:pcompose_eq_0 simp add:Complex_eq_0)"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<not> gc4 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p = 0", "show False"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gc4 \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gc1 \\<noteq> 0\n  gc2 \\<noteq> 0\n  gc3 \\<noteq> 0\n  gc4 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define sms where \n      \"sms = (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1)\n                + changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2)\n                + changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3)\n                + changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4))\""], ["proof (state)\nthis:\n  sms =\n  changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) +\n  changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) +\n  changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) +\n  changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have \"proots_rectangle p lb ub = (\\<Sum>r\\<in>proots p. winding_number rec r * (order r p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (proots_rectangle p lb ub) =\n    (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat (proots_rectangle p lb ub) =\n    (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p))", "have \"winding_number rec x * of_nat (order x p) = 0\" \n        when \"x\\<in>proots p - proots_within p (box lb ub)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number rec x * of_nat (order x p) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. winding_number rec x * of_nat (order x p) = 0", "have *:\"cbox lb ub = box lb ub \\<union> path_image rec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox lb ub = box lb ub \\<union> path_image rec", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cbox lb ub = box lb ub \\<union> path_image rec", "have \"x\\<in>cbox lb ub\" when \"x\\<in>box lb ub \\<union> path_image rec\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> cbox lb ub", "using that \\<open>Re lb<Re ub\\<close> \\<open>Im lb<Im ub\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> box lb ub \\<union> path_image rec\n  Re lb < Re ub\n  Im lb < Im ub\n\ngoal (1 subgoal):\n 1. x \\<in> cbox lb ub", "unfolding box_def cbox_def Basis_complex_def rec_def l1_def l2_def l3_def l4_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<forall>i\\<in>{1, \\<i>}.\n                 lb \\<bullet> i < x \\<bullet> i \\<and>\n                 x \\<bullet> i < ub \\<bullet> i} \\<union>\n          path_image\n           (linepath lb (Complex (Re ub) (Im lb)) +++\n            linepath (Complex (Re ub) (Im lb)) ub +++\n            linepath ub (Complex (Re lb) (Im ub)) +++\n            linepath (Complex (Re lb) (Im ub)) lb)\n  Re lb < Re ub\n  Im lb < Im ub\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<forall>i\\<in>{1, \\<i>}.\n                   lb \\<bullet> i \\<le> x \\<bullet> i \\<and>\n                   x \\<bullet> i \\<le> ub \\<bullet> i}", "apply (auto simp add:path_image_join closed_segment_degen_complex)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>Re lb < Re ub; Im lb < Im ub;\n     x \\<in> closed_segment ub (Complex (Re lb) (Im ub))\\<rbrakk>\n    \\<Longrightarrow> Re lb \\<le> Re x\n 2. \\<lbrakk>Re lb < Re ub; Im lb < Im ub;\n     x \\<in> closed_segment ub (Complex (Re lb) (Im ub))\\<rbrakk>\n    \\<Longrightarrow> Re x \\<le> Re ub\n 3. \\<lbrakk>Re lb < Re ub; Im lb < Im ub;\n     x \\<in> closed_segment ub (Complex (Re lb) (Im ub))\\<rbrakk>\n    \\<Longrightarrow> Im lb \\<le> Im x\n 4. \\<lbrakk>Re lb < Re ub; Im lb < Im ub;\n     x \\<in> closed_segment ub (Complex (Re lb) (Im ub))\\<rbrakk>\n    \\<Longrightarrow> Im x \\<le> Im ub\n 5. \\<lbrakk>Re lb < Re ub; Im lb < Im ub;\n     x \\<in> closed_segment (Complex (Re lb) (Im ub)) lb\\<rbrakk>\n    \\<Longrightarrow> Re lb \\<le> Re x\n 6. \\<lbrakk>Re lb < Re ub; Im lb < Im ub;\n     x \\<in> closed_segment (Complex (Re lb) (Im ub)) lb\\<rbrakk>\n    \\<Longrightarrow> Re x \\<le> Re ub\n 7. \\<lbrakk>Re lb < Re ub; Im lb < Im ub;\n     x \\<in> closed_segment (Complex (Re lb) (Im ub)) lb\\<rbrakk>\n    \\<Longrightarrow> Im lb \\<le> Im x\n 8. \\<lbrakk>Re lb < Re ub; Im lb < Im ub;\n     x \\<in> closed_segment (Complex (Re lb) (Im ub)) lb\\<rbrakk>\n    \\<Longrightarrow> Im x \\<le> Im ub", "apply (subst (asm) closed_segment_commute,simp add: closed_segment_degen_complex)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x \\<in> box lb ub \\<union> path_image rec \\<Longrightarrow>\n  ?x \\<in> cbox lb ub\n\ngoal (1 subgoal):\n 1. cbox lb ub = box lb ub \\<union> path_image rec", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> box lb ub \\<union> path_image rec \\<Longrightarrow>\n  ?x \\<in> cbox lb ub\n\ngoal (1 subgoal):\n 1. cbox lb ub = box lb ub \\<union> path_image rec", "have \"x\\<in>box lb ub \\<union> path_image rec\" when \"x\\<in>cbox lb ub\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> box lb ub \\<union> path_image rec", "using that"], ["proof (prove)\nusing this:\n  x \\<in> cbox lb ub\n\ngoal (1 subgoal):\n 1. x \\<in> box lb ub \\<union> path_image rec", "unfolding box_def cbox_def Basis_complex_def rec_def l1_def l2_def l3_def l4_def"], ["proof (prove)\nusing this:\n  x \\<in> {x. \\<forall>i\\<in>{1, \\<i>}.\n                 lb \\<bullet> i \\<le> x \\<bullet> i \\<and>\n                 x \\<bullet> i \\<le> ub \\<bullet> i}\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<forall>i\\<in>{1, \\<i>}.\n                   lb \\<bullet> i < x \\<bullet> i \\<and>\n                   x \\<bullet> i < ub \\<bullet> i} \\<union>\n            path_image\n             (linepath lb (Complex (Re ub) (Im lb)) +++\n              linepath (Complex (Re ub) (Im lb)) ub +++\n              linepath ub (Complex (Re lb) (Im ub)) +++\n              linepath (Complex (Re lb) (Im ub)) lb)", "apply (auto simp add:path_image_join closed_segment_degen_complex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Re lb \\<le> Re x; Re x \\<le> Re ub; Im lb \\<le> Im x;\n     Im x \\<le> Im ub; Im x \\<noteq> Im lb; Re x \\<noteq> Re ub;\n     x \\<notin> closed_segment (Complex (Re lb) (Im ub)) lb;\n     x \\<notin> closed_segment ub (Complex (Re lb) (Im ub))\\<rbrakk>\n    \\<Longrightarrow> Re lb < Re x\n 2. \\<lbrakk>Re lb \\<le> Re x; Re x \\<le> Re ub; Im lb \\<le> Im x;\n     Im x \\<le> Im ub; Im x \\<noteq> Im lb; Re x \\<noteq> Re ub;\n     x \\<notin> closed_segment (Complex (Re lb) (Im ub)) lb;\n     x \\<notin> closed_segment ub (Complex (Re lb) (Im ub))\\<rbrakk>\n    \\<Longrightarrow> Im x < Im ub", "apply (subst (asm) (1 2) closed_segment_commute,simp add:closed_segment_degen_complex)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x \\<in> cbox lb ub \\<Longrightarrow>\n  ?x \\<in> box lb ub \\<union> path_image rec\n\ngoal (1 subgoal):\n 1. cbox lb ub = box lb ub \\<union> path_image rec", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> box lb ub \\<union> path_image rec \\<Longrightarrow>\n  ?x \\<in> cbox lb ub\n  ?x \\<in> cbox lb ub \\<Longrightarrow>\n  ?x \\<in> box lb ub \\<union> path_image rec", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> box lb ub \\<union> path_image rec \\<Longrightarrow>\n  ?x \\<in> cbox lb ub\n  ?x \\<in> cbox lb ub \\<Longrightarrow>\n  ?x \\<in> box lb ub \\<union> path_image rec\n\ngoal (1 subgoal):\n 1. cbox lb ub = box lb ub \\<union> path_image rec", "by auto"], ["proof (state)\nthis:\n  cbox lb ub = box lb ub \\<union> path_image rec\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cbox lb ub = box lb ub \\<union> path_image rec\n\ngoal (1 subgoal):\n 1. winding_number rec x * of_nat (order x p) = 0", "moreover"], ["proof (state)\nthis:\n  cbox lb ub = box lb ub \\<union> path_image rec\n\ngoal (1 subgoal):\n 1. winding_number rec x * of_nat (order x p) = 0", "have \"x\\<notin>path_image rec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> path_image rec", "using path_no_proots that"], ["proof (prove)\nusing this:\n  path_image rec \\<inter> proots p = {}\n  x \\<in> proots p - proots_within p (box lb ub)\n\ngoal (1 subgoal):\n 1. x \\<notin> path_image rec", "by auto"], ["proof (state)\nthis:\n  x \\<notin> path_image rec\n\ngoal (1 subgoal):\n 1. winding_number rec x * of_nat (order x p) = 0", "ultimately"], ["proof (chain)\npicking this:\n  cbox lb ub = box lb ub \\<union> path_image rec\n  x \\<notin> path_image rec", "have \"x\\<notin>cbox lb ub\""], ["proof (prove)\nusing this:\n  cbox lb ub = box lb ub \\<union> path_image rec\n  x \\<notin> path_image rec\n\ngoal (1 subgoal):\n 1. x \\<notin> cbox lb ub", "using that"], ["proof (prove)\nusing this:\n  cbox lb ub = box lb ub \\<union> path_image rec\n  x \\<notin> path_image rec\n  x \\<in> proots p - proots_within p (box lb ub)\n\ngoal (1 subgoal):\n 1. x \\<notin> cbox lb ub", "by simp"], ["proof (state)\nthis:\n  x \\<notin> cbox lb ub\n\ngoal (1 subgoal):\n 1. winding_number rec x * of_nat (order x p) = 0", "from winding_number_zero_outside[OF valid_path_imp_path[OF valid] _ loop this,simplified] *"], ["proof (chain)\npicking this:\n  path_image rec \\<subseteq> cbox lb ub \\<Longrightarrow>\n  winding_number rec x = 0\n  cbox lb ub = box lb ub \\<union> path_image rec", "have \"winding_number rec x = 0\""], ["proof (prove)\nusing this:\n  path_image rec \\<subseteq> cbox lb ub \\<Longrightarrow>\n  winding_number rec x = 0\n  cbox lb ub = box lb ub \\<union> path_image rec\n\ngoal (1 subgoal):\n 1. winding_number rec x = 0", "by auto"], ["proof (state)\nthis:\n  winding_number rec x = 0\n\ngoal (1 subgoal):\n 1. winding_number rec x * of_nat (order x p) = 0", "then"], ["proof (chain)\npicking this:\n  winding_number rec x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  winding_number rec x = 0\n\ngoal (1 subgoal):\n 1. winding_number rec x * of_nat (order x p) = 0", "by auto"], ["proof (state)\nthis:\n  winding_number rec x * of_nat (order x p) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> proots p - proots_within p (box lb ub) \\<Longrightarrow>\n  winding_number rec ?x * of_nat (order ?x p) = 0\n\ngoal (1 subgoal):\n 1. of_nat (proots_rectangle p lb ub) =\n    (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p))", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> proots p - proots_within p (box lb ub) \\<Longrightarrow>\n  winding_number rec ?x * of_nat (order ?x p) = 0\n\ngoal (1 subgoal):\n 1. of_nat (proots_rectangle p lb ub) =\n    (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p))", "have \"of_nat (order x p) = winding_number rec x * of_nat (order x p)\" when \n        \"x \\<in> proots_within p (box lb ub)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (order x p) = winding_number rec x * of_nat (order x p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat (order x p) = winding_number rec x * of_nat (order x p)", "have \"x\\<in>box lb ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> box lb ub", "using that"], ["proof (prove)\nusing this:\n  x \\<in> proots_within p (box lb ub)\n\ngoal (1 subgoal):\n 1. x \\<in> box lb ub", "unfolding proots_within_def"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> box lb ub. poly p x = 0}\n\ngoal (1 subgoal):\n 1. x \\<in> box lb ub", "by auto"], ["proof (state)\nthis:\n  x \\<in> box lb ub\n\ngoal (1 subgoal):\n 1. of_nat (order x p) = winding_number rec x * of_nat (order x p)", "then"], ["proof (chain)\npicking this:\n  x \\<in> box lb ub", "have order_asms:\"Re lb < Re x\" \"Re x < Re ub\" \"Im lb < Im x\" \"Im x < Im ub\""], ["proof (prove)\nusing this:\n  x \\<in> box lb ub\n\ngoal (1 subgoal):\n 1. (Re lb < Re x &&& Re x < Re ub) &&& Im lb < Im x &&& Im x < Im ub", "by (auto simp add:box_def Basis_complex_def)"], ["proof (state)\nthis:\n  Re lb < Re x\n  Re x < Re ub\n  Im lb < Im x\n  Im x < Im ub\n\ngoal (1 subgoal):\n 1. of_nat (order x p) = winding_number rec x * of_nat (order x p)", "have \"winding_number rec x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number rec x = 1", "unfolding rec_def l1_def l2_def l3_def l4_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number\n     (linepath lb (Complex (Re ub) (Im lb)) +++\n      linepath (Complex (Re ub) (Im lb)) ub +++\n      linepath ub (Complex (Re lb) (Im ub)) +++\n      linepath (Complex (Re lb) (Im ub)) lb)\n     x =\n    1", "proof eval_winding"], ["proof (state)\ngoal (5 subgoals):\n 1. x \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb)))\n 2. x \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)\n 3. x \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub)))\n 4. x \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)\n 5. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    2 * 1", "let ?l1 = \"linepath lb (Complex (Re ub) (Im lb))\"\n          and ?l2 = \"linepath (Complex (Re ub) (Im lb)) ub\"\n          and ?l3 = \"linepath ub (Complex (Re lb) (Im ub))\"\n          and ?l4 = \"linepath (Complex (Re lb) (Im ub)) lb\""], ["proof (state)\ngoal (5 subgoals):\n 1. x \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb)))\n 2. x \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)\n 3. x \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub)))\n 4. x \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)\n 5. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    2 * 1", "show l1: \"x \\<notin> path_image ?l1\" and l2: \"x \\<notin> path_image ?l2\" and \n               l3: \"x \\<notin> path_image ?l3\" and l4:\"x \\<notin> path_image ?l4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb))) &&&\n     x \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)) &&&\n    x \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub))) &&&\n    x \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)", "using no_proots that"], ["proof (prove)\nusing this:\n  no_proots_line p lb (Complex (Re ub) (Im lb))\n  no_proots_line p (Complex (Re ub) (Im lb)) ub\n  no_proots_line p ub (Complex (Re lb) (Im ub))\n  no_proots_line p (Complex (Re lb) (Im ub)) lb\n  x \\<in> proots_within p (box lb ub)\n\ngoal (1 subgoal):\n 1. (x \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb))) &&&\n     x \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)) &&&\n    x \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub))) &&&\n    x \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)", "unfolding no_proots_line_def"], ["proof (prove)\nusing this:\n  proots_within p (closed_segment lb (Complex (Re ub) (Im lb))) = {}\n  proots_within p (closed_segment (Complex (Re ub) (Im lb)) ub) = {}\n  proots_within p (closed_segment ub (Complex (Re lb) (Im ub))) = {}\n  proots_within p (closed_segment (Complex (Re lb) (Im ub)) lb) = {}\n  x \\<in> proots_within p (box lb ub)\n\ngoal (1 subgoal):\n 1. (x \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb))) &&&\n     x \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)) &&&\n    x \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub))) &&&\n    x \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)", "by auto"], ["proof (state)\nthis:\n  x \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb)))\n  x \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)\n  x \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub)))\n  x \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    2 * 1", "show \"- of_real (cindex_pathE ?l1 x + (cindex_pathE ?l2 x +\n            (cindex_pathE ?l3 x + cindex_pathE ?l4 x))) = 2 * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "have \"(Im x - Im ub) * (Re ub - Re lb) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im x - Im ub) * (Re ub - Re lb) < 0", "using mult_less_0_iff order_asms(1) order_asms(2) order_asms(4)"], ["proof (prove)\nusing this:\n  (?a * ?b < (0::?'a)) =\n  ((0::?'a) < ?a \\<and> ?b < (0::?'a) \\<or>\n   ?a < (0::?'a) \\<and> (0::?'a) < ?b)\n  Re lb < Re x\n  Re x < Re ub\n  Im x < Im ub\n\ngoal (1 subgoal):\n 1. (Im x - Im ub) * (Re ub - Re lb) < 0", "by fastforce"], ["proof (state)\nthis:\n  (Im x - Im ub) * (Re ub - Re lb) < 0\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "then"], ["proof (chain)\npicking this:\n  (Im x - Im ub) * (Re ub - Re lb) < 0", "have \"cindex_pathE ?l3 x = -1\""], ["proof (prove)\nusing this:\n  (Im x - Im ub) * (Re ub - Re lb) < 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x = - 1", "apply (subst cindex_pathE_linepath)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Im x - Im ub) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    x \\<notin> closed_segment ub (Complex (Re lb) (Im ub))\n 2. (Im x - Im ub) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    (let c1 = Re ub - Re x; c2 = Re (Complex (Re lb) (Im ub)) - Re x;\n         c3 = Im ub * Re (Complex (Re lb) (Im ub)) +\n              Re x * Im (Complex (Re lb) (Im ub)) +\n              Im x * Re ub -\n              Im x * Re (Complex (Re lb) (Im ub)) -\n              Im (Complex (Re lb) (Im ub)) * Re ub -\n              Re x * Im ub;\n         d1 = Im ub - Im x; d2 = Im (Complex (Re lb) (Im ub)) - Im x\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    - 1", "using l3"], ["proof (prove)\nusing this:\n  x \\<notin> path_image (linepath ub (Complex (Re lb) (Im ub)))\n\ngoal (2 subgoals):\n 1. (Im x - Im ub) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    x \\<notin> closed_segment ub (Complex (Re lb) (Im ub))\n 2. (Im x - Im ub) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    (let c1 = Re ub - Re x; c2 = Re (Complex (Re lb) (Im ub)) - Re x;\n         c3 = Im ub * Re (Complex (Re lb) (Im ub)) +\n              Re x * Im (Complex (Re lb) (Im ub)) +\n              Im x * Re ub -\n              Im x * Re (Complex (Re lb) (Im ub)) -\n              Im (Complex (Re lb) (Im ub)) * Re ub -\n              Re x * Im ub;\n         d1 = Im ub - Im x; d2 = Im (Complex (Re lb) (Im ub)) - Im x\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    - 1", "by (auto simp add:algebra_simps order_asms)"], ["proof (state)\nthis:\n  cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x = - 1\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x = - 1\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "have \"(Im lb - Im x) * (Re ub - Re lb) <0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im lb - Im x) * (Re ub - Re lb) < 0", "using mult_less_0_iff order_asms(1) order_asms(2) order_asms(3)"], ["proof (prove)\nusing this:\n  (?a * ?b < (0::?'a)) =\n  ((0::?'a) < ?a \\<and> ?b < (0::?'a) \\<or>\n   ?a < (0::?'a) \\<and> (0::?'a) < ?b)\n  Re lb < Re x\n  Re x < Re ub\n  Im lb < Im x\n\ngoal (1 subgoal):\n 1. (Im lb - Im x) * (Re ub - Re lb) < 0", "by fastforce"], ["proof (state)\nthis:\n  (Im lb - Im x) * (Re ub - Re lb) < 0\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "then"], ["proof (chain)\npicking this:\n  (Im lb - Im x) * (Re ub - Re lb) < 0", "have \"cindex_pathE ?l1 x = -1\""], ["proof (prove)\nusing this:\n  (Im lb - Im x) * (Re ub - Re lb) < 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x = - 1", "apply (subst cindex_pathE_linepath)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Im lb - Im x) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    x \\<notin> closed_segment lb (Complex (Re ub) (Im lb))\n 2. (Im lb - Im x) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    (let c1 = Re lb - Re x; c2 = Re (Complex (Re ub) (Im lb)) - Re x;\n         c3 = Im lb * Re (Complex (Re ub) (Im lb)) +\n              Re x * Im (Complex (Re ub) (Im lb)) +\n              Im x * Re lb -\n              Im x * Re (Complex (Re ub) (Im lb)) -\n              Im (Complex (Re ub) (Im lb)) * Re lb -\n              Re x * Im lb;\n         d1 = Im lb - Im x; d2 = Im (Complex (Re ub) (Im lb)) - Im x\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    - 1", "using l1"], ["proof (prove)\nusing this:\n  x \\<notin> path_image (linepath lb (Complex (Re ub) (Im lb)))\n\ngoal (2 subgoals):\n 1. (Im lb - Im x) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    x \\<notin> closed_segment lb (Complex (Re ub) (Im lb))\n 2. (Im lb - Im x) * (Re ub - Re lb) < 0 \\<Longrightarrow>\n    (let c1 = Re lb - Re x; c2 = Re (Complex (Re ub) (Im lb)) - Re x;\n         c3 = Im lb * Re (Complex (Re ub) (Im lb)) +\n              Re x * Im (Complex (Re ub) (Im lb)) +\n              Im x * Re lb -\n              Im x * Re (Complex (Re ub) (Im lb)) -\n              Im (Complex (Re ub) (Im lb)) * Re lb -\n              Re x * Im lb;\n         d1 = Im lb - Im x; d2 = Im (Complex (Re ub) (Im lb)) - Im x\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    - 1", "by (auto simp add:algebra_simps order_asms)"], ["proof (state)\nthis:\n  cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x = - 1\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x = - 1\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "have \"cindex_pathE ?l2 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x = 0", "apply (subst cindex_pathE_linepath)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<notin> closed_segment (Complex (Re ub) (Im lb)) ub\n 2. (let c1 = Re (Complex (Re ub) (Im lb)) - Re x; c2 = Re ub - Re x;\n         c3 = Im (Complex (Re ub) (Im lb)) * Re ub + Re x * Im ub +\n              Im x * Re (Complex (Re ub) (Im lb)) -\n              Im x * Re ub -\n              Im ub * Re (Complex (Re ub) (Im lb)) -\n              Re x * Im (Complex (Re ub) (Im lb));\n         d1 = Im (Complex (Re ub) (Im lb)) - Im x; d2 = Im ub - Im x\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    0", "using l2 order_asms"], ["proof (prove)\nusing this:\n  x \\<notin> path_image (linepath (Complex (Re ub) (Im lb)) ub)\n  Re lb < Re x\n  Re x < Re ub\n  Im lb < Im x\n  Im x < Im ub\n\ngoal (2 subgoals):\n 1. x \\<notin> closed_segment (Complex (Re ub) (Im lb)) ub\n 2. (let c1 = Re (Complex (Re ub) (Im lb)) - Re x; c2 = Re ub - Re x;\n         c3 = Im (Complex (Re ub) (Im lb)) * Re ub + Re x * Im ub +\n              Im x * Re (Complex (Re ub) (Im lb)) -\n              Im x * Re ub -\n              Im ub * Re (Complex (Re ub) (Im lb)) -\n              Re x * Im (Complex (Re ub) (Im lb));\n         d1 = Im (Complex (Re ub) (Im lb)) - Im x; d2 = Im ub - Im x\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x = 0\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "moreover"], ["proof (state)\nthis:\n  cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x = 0\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "have \"cindex_pathE ?l4 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x = 0", "apply (subst cindex_pathE_linepath)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<notin> closed_segment (Complex (Re lb) (Im ub)) lb\n 2. (let c1 = Re (Complex (Re lb) (Im ub)) - Re x; c2 = Re lb - Re x;\n         c3 = Im (Complex (Re lb) (Im ub)) * Re lb + Re x * Im lb +\n              Im x * Re (Complex (Re lb) (Im ub)) -\n              Im x * Re lb -\n              Im lb * Re (Complex (Re lb) (Im ub)) -\n              Re x * Im (Complex (Re lb) (Im ub));\n         d1 = Im (Complex (Re lb) (Im ub)) - Im x; d2 = Im lb - Im x\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    0", "using l4 order_asms"], ["proof (prove)\nusing this:\n  x \\<notin> path_image (linepath (Complex (Re lb) (Im ub)) lb)\n  Re lb < Re x\n  Re x < Re ub\n  Im lb < Im x\n  Im x < Im ub\n\ngoal (2 subgoals):\n 1. x \\<notin> closed_segment (Complex (Re lb) (Im ub)) lb\n 2. (let c1 = Re (Complex (Re lb) (Im ub)) - Re x; c2 = Re lb - Re x;\n         c3 = Im (Complex (Re lb) (Im ub)) * Re lb + Re x * Im lb +\n              Im x * Re (Complex (Re lb) (Im ub)) -\n              Im x * Re lb -\n              Im lb * Re (Complex (Re lb) (Im ub)) -\n              Re x * Im (Complex (Re lb) (Im ub));\n         d1 = Im (Complex (Re lb) (Im ub)) - Im x; d2 = Im lb - Im x\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    0", "by auto"], ["proof (state)\nthis:\n  cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x = 0\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x = - 1\n  cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x = - 1\n  cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x = 0\n  cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x = - 1\n  cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x = - 1\n  cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x = 0\n  cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x = 0\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n        (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n         (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n          cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n    (2::'a) * (1::'a)", "by auto"], ["proof (state)\nthis:\n  - of_real\n     (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n      (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n       (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n        cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n  (2::'a) * (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - of_real\n     (cindex_pathE (linepath lb (Complex (Re ub) (Im lb))) x +\n      (cindex_pathE (linepath (Complex (Re ub) (Im lb)) ub) x +\n       (cindex_pathE (linepath ub (Complex (Re lb) (Im ub))) x +\n        cindex_pathE (linepath (Complex (Re lb) (Im ub)) lb) x))) =\n  (2::?'a1) * (1::?'a1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  winding_number rec x = 1\n\ngoal (1 subgoal):\n 1. of_nat (order x p) = winding_number rec x * of_nat (order x p)", "then"], ["proof (chain)\npicking this:\n  winding_number rec x = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  winding_number rec x = 1\n\ngoal (1 subgoal):\n 1. of_nat (order x p) = winding_number rec x * of_nat (order x p)", "by auto"], ["proof (state)\nthis:\n  of_nat (order x p) = winding_number rec x * of_nat (order x p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> proots_within p (box lb ub) \\<Longrightarrow>\n  of_nat (order ?x p) = winding_number rec ?x * of_nat (order ?x p)\n\ngoal (1 subgoal):\n 1. of_nat (proots_rectangle p lb ub) =\n    (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p))", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> proots p - proots_within p (box lb ub) \\<Longrightarrow>\n  winding_number rec ?x * of_nat (order ?x p) = 0\n  ?x \\<in> proots_within p (box lb ub) \\<Longrightarrow>\n  of_nat (order ?x p) = winding_number rec ?x * of_nat (order ?x p)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> proots p - proots_within p (box lb ub) \\<Longrightarrow>\n  winding_number rec ?x * of_nat (order ?x p) = 0\n  ?x \\<in> proots_within p (box lb ub) \\<Longrightarrow>\n  of_nat (order ?x p) = winding_number rec ?x * of_nat (order ?x p)\n\ngoal (1 subgoal):\n 1. of_nat (proots_rectangle p lb ub) =\n    (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p))", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> proots p - proots_within p (box lb ub) \\<Longrightarrow>\n  winding_number rec ?x * of_nat (order ?x p) = 0\n  ?x \\<in> proots_within p (box lb ub) \\<Longrightarrow>\n  of_nat (order ?x p) = winding_number rec ?x * of_nat (order ?x p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_nat (proots_rectangle p lb ub) =\n    (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p))", "unfolding proots_rectangle_def proots_count_def"], ["proof (prove)\nusing this:\n  ?x \\<in> proots p - proots_within p (box lb ub) \\<Longrightarrow>\n  winding_number rec ?x * of_nat (order ?x p) = 0\n  ?x \\<in> proots_within p (box lb ub) \\<Longrightarrow>\n  of_nat (order ?x p) = winding_number rec ?x * of_nat (order ?x p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_nat (\\<Sum>r\\<in>proots_within p (box lb ub). order r p) =\n    (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p))", "by (auto intro!: sum.mono_neutral_cong_left[of \"proots p\" \"proots_within p (box lb ub)\"])"], ["proof (state)\nthis:\n  of_nat (proots_rectangle p lb ub) =\n  (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_nat (proots_rectangle p lb ub) =\n  (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p))\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "also"], ["proof (state)\nthis:\n  of_nat (proots_rectangle p lb ub) =\n  (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p))\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have \"... = 1/(2 * of_real pi * \\<i>) *contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p)) =\n    1 / (2 * complex_of_real pi * \\<i>) *\n    contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p)) =\n    1 / (2 * complex_of_real pi * \\<i>) *\n    contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x)", "have \"contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) = 2 * of_real pi * \\<i> \n              * (\\<Sum>x | poly p x = 0. winding_number rec x * of_int (zorder (poly p) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x | poly p x = 0.\n       winding_number rec x * of_int (zorder (poly p) x))", "proof (rule argument_principle[of UNIV \"poly p\" \"{}\" \"\\<lambda>_. 1\" rec,simplified])"], ["proof (state)\ngoal (3 subgoals):\n 1. connected UNIV\n 2. path_image rec \\<subseteq> UNIV - {x. poly p x = 0}\n 3. finite {x. poly p x = 0}", "show \"connected (UNIV::complex set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected UNIV", "using connected_UNIV[where 'a=complex]"], ["proof (prove)\nusing this:\n  connected UNIV\n\ngoal (1 subgoal):\n 1. connected UNIV", "."], ["proof (state)\nthis:\n  connected UNIV\n\ngoal (2 subgoals):\n 1. path_image rec \\<subseteq> UNIV - {x. poly p x = 0}\n 2. finite {x. poly p x = 0}", "show \"path_image rec \\<subseteq> UNIV - {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image rec \\<subseteq> UNIV - {x. poly p x = 0}", "using path_no_proots"], ["proof (prove)\nusing this:\n  path_image rec \\<inter> proots p = {}\n\ngoal (1 subgoal):\n 1. path_image rec \\<subseteq> UNIV - {x. poly p x = 0}", "unfolding proots_within_def"], ["proof (prove)\nusing this:\n  path_image rec \\<inter> {x \\<in> UNIV. poly p x = 0} = {}\n\ngoal (1 subgoal):\n 1. path_image rec \\<subseteq> UNIV - {x. poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  path_image rec \\<subseteq> UNIV - {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0}", "show \"finite {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. poly p x = 0}", "by (simp add: poly_roots_finite that(3))"], ["proof (state)\nthis:\n  finite {x. poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x | poly p x = 0.\n     winding_number rec x * of_int (zorder (poly p) x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p)) =\n    1 / (2 * complex_of_real pi * \\<i>) *\n    contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x)", "also"], ["proof (state)\nthis:\n  contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x | poly p x = 0.\n     winding_number rec x * of_int (zorder (poly p) x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p)) =\n    1 / (2 * complex_of_real pi * \\<i>) *\n    contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x)", "have \" ... = 2 * of_real pi * \\<i> * (\\<Sum>x\\<in>proots p. winding_number rec x * (order x p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x | poly p x = 0.\n       winding_number rec x * of_int (zorder (poly p) x)) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x\\<in>proots p. winding_number rec x * of_nat (order x p))", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x | poly p x = 0.\n       winding_number rec x * of_int (zorder (poly p) x)) =\n    2 * complex_of_real pi * \\<i> *\n    (\\<Sum>x | x \\<in> UNIV \\<and> poly p x = 0.\n       winding_number rec x * of_nat (order x p))", "apply (auto intro!:sum.cong simp add:order_zorder[OF \\<open>p\\<noteq>0\\<close>] )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>poly p x = 0;\n        of_int (zorder (poly p) x) \\<noteq>\n        of_nat (nat (zorder (poly p) x))\\<rbrakk>\n       \\<Longrightarrow> winding_number rec x = 0", "by (metis nat_eq_iff2 of_nat_nat order_root order_zorder that(3))"], ["proof (state)\nthis:\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x | poly p x = 0.\n     winding_number rec x * of_int (zorder (poly p) x)) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x\\<in>proots p. winding_number rec x * of_nat (order x p))\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p)) =\n    1 / (2 * complex_of_real pi * \\<i>) *\n    contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x)", "finally"], ["proof (chain)\npicking this:\n  contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x\\<in>proots p. winding_number rec x * of_nat (order x p))", "show ?thesis"], ["proof (prove)\nusing this:\n  contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n  2 * complex_of_real pi * \\<i> *\n  (\\<Sum>x\\<in>proots p. winding_number rec x * of_nat (order x p))\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p)) =\n    1 / (2 * complex_of_real pi * \\<i>) *\n    contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p)) =\n  1 / (2 * complex_of_real pi * \\<i>) *\n  contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p)) =\n  1 / (2 * complex_of_real pi * \\<i>) *\n  contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>proots p. winding_number rec r * of_nat (order r p)) =\n  1 / (2 * complex_of_real pi * \\<i>) *\n  contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have \"... = winding_number (poly p \\<circ> rec) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (2 * complex_of_real pi * \\<i>) *\n    contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n    winding_number (poly p \\<circ> rec) 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 / (2 * complex_of_real pi * \\<i>) *\n    contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n    winding_number (poly p \\<circ> rec) 0", "have \"0 \\<notin> path_image (poly p \\<circ> rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (poly p \\<circ> rec)", "using path_no_proots"], ["proof (prove)\nusing this:\n  path_image rec \\<inter> proots p = {}\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (poly p \\<circ> rec)", "unfolding path_image_compose proots_within_def"], ["proof (prove)\nusing this:\n  path_image rec \\<inter> {x \\<in> UNIV. poly p x = 0} = {}\n\ngoal (1 subgoal):\n 1. 0 \\<notin> poly p ` path_image rec", "by fastforce"], ["proof (state)\nthis:\n  0 \\<notin> path_image (poly p \\<circ> rec)\n\ngoal (1 subgoal):\n 1. 1 / (2 * complex_of_real pi * \\<i>) *\n    contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n    winding_number (poly p \\<circ> rec) 0", "from winding_number_comp[OF _ poly_holomorphic_on _ _ this,of UNIV,simplified]"], ["proof (chain)\npicking this:\n  winding_number (poly p \\<circ> rec) 0 =\n  contour_integral rec (\\<lambda>w. deriv (poly p) w / poly p w) /\n  (2 * complex_of_real pi * \\<i>)", "show ?thesis"], ["proof (prove)\nusing this:\n  winding_number (poly p \\<circ> rec) 0 =\n  contour_integral rec (\\<lambda>w. deriv (poly p) w / poly p w) /\n  (2 * complex_of_real pi * \\<i>)\n\ngoal (1 subgoal):\n 1. 1 / (2 * complex_of_real pi * \\<i>) *\n    contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n    winding_number (poly p \\<circ> rec) 0", "by auto"], ["proof (state)\nthis:\n  1 / (2 * complex_of_real pi * \\<i>) *\n  contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n  winding_number (poly p \\<circ> rec) 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 / (2 * complex_of_real pi * \\<i>) *\n  contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n  winding_number (poly p \\<circ> rec) 0\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "also"], ["proof (state)\nthis:\n  1 / (2 * complex_of_real pi * \\<i>) *\n  contour_integral rec (\\<lambda>x. deriv (poly p) x / poly p x) =\n  winding_number (poly p \\<circ> rec) 0\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have winding_eq:\"... = - cindex_pathE (poly p \\<circ> rec) 0 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (poly p \\<circ> rec) 0 =\n    complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2)", "proof (rule winding_number_cindex_pathE)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite_ReZ_segments (poly p \\<circ> rec) 0\n 2. valid_path (poly p \\<circ> rec)\n 3. 0 \\<notin> path_image (poly p \\<circ> rec)\n 4. pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)", "show \"finite_ReZ_segments (poly p \\<circ> rec) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (poly p \\<circ> rec) 0", "unfolding rec_def path_compose_join"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments\n     ((poly p \\<circ> l1) +++\n      (poly p \\<circ> l2) +++ (poly p \\<circ> l3) +++ (poly p \\<circ> l4))\n     0", "apply (fold g1_def g2_def g3_def g4_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g1 +++ g2 +++ g3 +++ g4) 0", "by (auto intro!: finite_ReZ_segments_joinpaths path_join_imp)"], ["proof (state)\nthis:\n  finite_ReZ_segments (poly p \\<circ> rec) 0\n\ngoal (3 subgoals):\n 1. valid_path (poly p \\<circ> rec)\n 2. 0 \\<notin> path_image (poly p \\<circ> rec)\n 3. pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)", "show \"valid_path (poly p \\<circ> rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (poly p \\<circ> rec)", "by (rule valid_path_compose_holomorphic[where S=UNIV]) auto"], ["proof (state)\nthis:\n  valid_path (poly p \\<circ> rec)\n\ngoal (2 subgoals):\n 1. 0 \\<notin> path_image (poly p \\<circ> rec)\n 2. pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)", "show \"0 \\<notin> path_image (poly p \\<circ> rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (poly p \\<circ> rec)", "using path_no_proots"], ["proof (prove)\nusing this:\n  path_image rec \\<inter> proots p = {}\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (poly p \\<circ> rec)", "unfolding path_image_compose proots_def"], ["proof (prove)\nusing this:\n  path_image rec \\<inter> {x. poly p x = 0} = {}\n\ngoal (1 subgoal):\n 1. 0 \\<notin> poly p ` path_image rec", "by fastforce"], ["proof (state)\nthis:\n  0 \\<notin> path_image (poly p \\<circ> rec)\n\ngoal (1 subgoal):\n 1. pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)", "show \"pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)", "unfolding rec_def pathstart_compose pathfinish_compose"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (pathfinish (l1 +++ l2 +++ l3 +++ l4)) =\n    poly p (pathstart (l1 +++ l2 +++ l3 +++ l4))", "by (auto simp add:l1_def l4_def)"], ["proof (state)\nthis:\n  pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  winding_number (poly p \\<circ> rec) 0 =\n  complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "also"], ["proof (state)\nthis:\n  winding_number (poly p \\<circ> rec) 0 =\n  complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have cindex_pathE_eq:\"... = of_int (- sms) / of_int 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n    of_int (- sms) / of_int 4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n    of_int (- sms) / of_int 4", "have \"cindex_pathE (poly p \\<circ> rec) 0 = cindex_pathE (g1+++g2+++g3+++g4) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (poly p \\<circ> rec) 0 =\n    cindex_pathE (g1 +++ g2 +++ g3 +++ g4) 0", "unfolding rec_def path_compose_join g1_def g2_def g3_def g4_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE\n     ((poly p \\<circ> l1) +++\n      (poly p \\<circ> l2) +++ (poly p \\<circ> l3) +++ (poly p \\<circ> l4))\n     0 =\n    cindex_pathE\n     ((poly p \\<circ> l1) +++\n      (poly p \\<circ> l2) +++ (poly p \\<circ> l3) +++ (poly p \\<circ> l4))\n     0", "by simp"], ["proof (state)\nthis:\n  cindex_pathE (poly p \\<circ> rec) 0 =\n  cindex_pathE (g1 +++ g2 +++ g3 +++ g4) 0\n\ngoal (1 subgoal):\n 1. complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n    of_int (- sms) / of_int 4", "also"], ["proof (state)\nthis:\n  cindex_pathE (poly p \\<circ> rec) 0 =\n  cindex_pathE (g1 +++ g2 +++ g3 +++ g4) 0\n\ngoal (1 subgoal):\n 1. complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n    of_int (- sms) / of_int 4", "have \"... = cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 + cindex_pathE g4 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (g1 +++ g2 +++ g3 +++ g4) 0 =\n    cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n    cindex_pathE g4 0", "by (subst cindex_pathE_joinpaths,auto intro!:finite_ReZ_segments_joinpaths)+"], ["proof (state)\nthis:\n  cindex_pathE (g1 +++ g2 +++ g3 +++ g4) 0 =\n  cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n  cindex_pathE g4 0\n\ngoal (1 subgoal):\n 1. complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n    of_int (- sms) / of_int 4", "also"], ["proof (state)\nthis:\n  cindex_pathE (g1 +++ g2 +++ g3 +++ g4) 0 =\n  cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n  cindex_pathE g4 0\n\ngoal (1 subgoal):\n 1. complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n    of_int (- sms) / of_int 4", "have \"... = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)\n                     + cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)\n                     + cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)\n                     + cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n    cindex_pathE g4 0 =\n    cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n    cindex_pathE g4 0 =\n    cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "have \"cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "have *:\"g1 = poly p1 o of_real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g1 = poly p1 \\<circ> complex_of_real", "unfolding g1_def p1_def l1_def poly_linepath_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (p \\<circ>\\<^sub>p [:lb, Complex (Re ub) (Im lb) - lb:]) \\<circ>\n    complex_of_real =\n    poly (p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:]) \\<circ>\n    complex_of_real", "by (subst (5) complex_surj[symmetric],simp)"], ["proof (state)\nthis:\n  g1 = poly p1 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "then"], ["proof (chain)\npicking this:\n  g1 = poly p1 \\<circ> complex_of_real", "have \"cindex_pathE g1 0  = cindexE 0 1 (\\<lambda>t. poly pI1 t / poly pR1 t)\""], ["proof (prove)\nusing this:\n  g1 = poly p1 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 = cindexE 0 1 (\\<lambda>t. poly pI1 t / poly pR1 t)", "unfolding cindex_pathE_def pR1_def pI1_def"], ["proof (prove)\nusing this:\n  g1 = poly p1 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (g1 t - 0) / Re (g1 t - 0)) =\n    cindexE 0 1\n     (\\<lambda>t. poly (map_poly Im p1) t / poly (map_poly Re p1) t)", "by (simp add:Im_poly_of_real Re_poly_of_real)"], ["proof (state)\nthis:\n  cindex_pathE g1 0 = cindexE 0 1 (\\<lambda>t. poly pI1 t / poly pR1 t)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "also"], ["proof (state)\nthis:\n  cindex_pathE g1 0 = cindexE 0 1 (\\<lambda>t. poly pI1 t / poly pR1 t)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "have \"... = cindex_polyE 0 1 pI1 pR1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. poly pI1 t / poly pR1 t) =\n    cindex_polyE 0 1 pI1 pR1", "using cindexE_eq_cindex_polyE"], ["proof (prove)\nusing this:\n  ?a < ?b \\<Longrightarrow>\n  cindexE ?a ?b (\\<lambda>x. poly ?q x / poly ?p x) =\n  cindex_polyE ?a ?b ?q ?p\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. poly pI1 t / poly pR1 t) =\n    cindex_polyE 0 1 pI1 pR1", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (\\<lambda>t. poly pI1 t / poly pR1 t) =\n  cindex_polyE 0 1 pI1 pR1\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "also"], ["proof (state)\nthis:\n  cindexE 0 1 (\\<lambda>t. poly pI1 t / poly pR1 t) =\n  cindex_polyE 0 1 pI1 pR1\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "have \"... = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 pI1 pR1 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "using \\<open>gc1\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  gc1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 pI1 pR1 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "apply (subst (2) cindex_polyE_mult_cancel[of gc1,symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. gc1 \\<noteq> 0 \\<Longrightarrow> gc1 \\<noteq> 0\n 2. gc1 \\<noteq> 0 \\<Longrightarrow>\n    cindex_polyE 0 1 pI1 pR1 =\n    cindex_polyE 0 1 (gc1 * (pI1 div gc1)) (gc1 * (pR1 div gc1))", "by (simp_all add: gc1_def)"], ["proof (state)\nthis:\n  cindex_polyE 0 1 pI1 pR1 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)", "."], ["proof (state)\nthis:\n  cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n    cindex_pathE g4 0 =\n    cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "moreover"], ["proof (state)\nthis:\n  cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n    cindex_pathE g4 0 =\n    cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "have \"cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "have \"g2 = poly p2 o of_real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g2 = poly p2 \\<circ> complex_of_real", "unfolding g2_def p2_def l2_def poly_linepath_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     (p \\<circ>\\<^sub>p\n      [:Complex (Re ub) (Im lb), ub - Complex (Re ub) (Im lb):]) \\<circ>\n    complex_of_real =\n    poly\n     (p \\<circ>\\<^sub>p\n      [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):]) \\<circ>\n    complex_of_real", "by (subst (5) complex_surj[symmetric],simp)"], ["proof (state)\nthis:\n  g2 = poly p2 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "then"], ["proof (chain)\npicking this:\n  g2 = poly p2 \\<circ> complex_of_real", "have \"cindex_pathE g2 0  = cindexE 0 1 (\\<lambda>t. poly pI2 t / poly pR2 t)\""], ["proof (prove)\nusing this:\n  g2 = poly p2 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindex_pathE g2 0 = cindexE 0 1 (\\<lambda>t. poly pI2 t / poly pR2 t)", "unfolding cindex_pathE_def pR2_def pI2_def"], ["proof (prove)\nusing this:\n  g2 = poly p2 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (g2 t - 0) / Re (g2 t - 0)) =\n    cindexE 0 1\n     (\\<lambda>t. poly (map_poly Im p2) t / poly (map_poly Re p2) t)", "by (simp add:Im_poly_of_real Re_poly_of_real)"], ["proof (state)\nthis:\n  cindex_pathE g2 0 = cindexE 0 1 (\\<lambda>t. poly pI2 t / poly pR2 t)\n\ngoal (1 subgoal):\n 1. cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "also"], ["proof (state)\nthis:\n  cindex_pathE g2 0 = cindexE 0 1 (\\<lambda>t. poly pI2 t / poly pR2 t)\n\ngoal (1 subgoal):\n 1. cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "have \"... = cindex_polyE 0 1 pI2 pR2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. poly pI2 t / poly pR2 t) =\n    cindex_polyE 0 1 pI2 pR2", "using cindexE_eq_cindex_polyE"], ["proof (prove)\nusing this:\n  ?a < ?b \\<Longrightarrow>\n  cindexE ?a ?b (\\<lambda>x. poly ?q x / poly ?p x) =\n  cindex_polyE ?a ?b ?q ?p\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. poly pI2 t / poly pR2 t) =\n    cindex_polyE 0 1 pI2 pR2", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (\\<lambda>t. poly pI2 t / poly pR2 t) =\n  cindex_polyE 0 1 pI2 pR2\n\ngoal (1 subgoal):\n 1. cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "also"], ["proof (state)\nthis:\n  cindexE 0 1 (\\<lambda>t. poly pI2 t / poly pR2 t) =\n  cindex_polyE 0 1 pI2 pR2\n\ngoal (1 subgoal):\n 1. cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "have \"... = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 pI2 pR2 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "using \\<open>gc2\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  gc2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 pI2 pR2 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "apply (subst (2) cindex_polyE_mult_cancel[of gc2,symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. gc2 \\<noteq> 0 \\<Longrightarrow> gc2 \\<noteq> 0\n 2. gc2 \\<noteq> 0 \\<Longrightarrow>\n    cindex_polyE 0 1 pI2 pR2 =\n    cindex_polyE 0 1 (gc2 * (pI2 div gc2)) (gc2 * (pR2 div gc2))", "by (simp_all add: gc2_def)"], ["proof (state)\nthis:\n  cindex_polyE 0 1 pI2 pR2 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)\n\ngoal (1 subgoal):\n 1. cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)\n\ngoal (1 subgoal):\n 1. cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)", "."], ["proof (state)\nthis:\n  cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n    cindex_pathE g4 0 =\n    cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "moreover"], ["proof (state)\nthis:\n  cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n    cindex_pathE g4 0 =\n    cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "have \"cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "have \"g3 = poly p3 o of_real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g3 = poly p3 \\<circ> complex_of_real", "unfolding g3_def p3_def l3_def poly_linepath_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (p \\<circ>\\<^sub>p [:ub, Complex (Re lb) (Im ub) - ub:]) \\<circ>\n    complex_of_real =\n    poly (p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:]) \\<circ>\n    complex_of_real", "by (subst (5) complex_surj[symmetric],simp)"], ["proof (state)\nthis:\n  g3 = poly p3 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "then"], ["proof (chain)\npicking this:\n  g3 = poly p3 \\<circ> complex_of_real", "have \"cindex_pathE g3 0  = cindexE 0 1 (\\<lambda>t. poly pI3 t / poly pR3 t)\""], ["proof (prove)\nusing this:\n  g3 = poly p3 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindex_pathE g3 0 = cindexE 0 1 (\\<lambda>t. poly pI3 t / poly pR3 t)", "unfolding cindex_pathE_def pR3_def pI3_def"], ["proof (prove)\nusing this:\n  g3 = poly p3 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (g3 t - 0) / Re (g3 t - 0)) =\n    cindexE 0 1\n     (\\<lambda>t. poly (map_poly Im p3) t / poly (map_poly Re p3) t)", "by (simp add:Im_poly_of_real Re_poly_of_real)"], ["proof (state)\nthis:\n  cindex_pathE g3 0 = cindexE 0 1 (\\<lambda>t. poly pI3 t / poly pR3 t)\n\ngoal (1 subgoal):\n 1. cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "also"], ["proof (state)\nthis:\n  cindex_pathE g3 0 = cindexE 0 1 (\\<lambda>t. poly pI3 t / poly pR3 t)\n\ngoal (1 subgoal):\n 1. cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "have \"... = cindex_polyE 0 1 pI3 pR3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. poly pI3 t / poly pR3 t) =\n    cindex_polyE 0 1 pI3 pR3", "using cindexE_eq_cindex_polyE"], ["proof (prove)\nusing this:\n  ?a < ?b \\<Longrightarrow>\n  cindexE ?a ?b (\\<lambda>x. poly ?q x / poly ?p x) =\n  cindex_polyE ?a ?b ?q ?p\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. poly pI3 t / poly pR3 t) =\n    cindex_polyE 0 1 pI3 pR3", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (\\<lambda>t. poly pI3 t / poly pR3 t) =\n  cindex_polyE 0 1 pI3 pR3\n\ngoal (1 subgoal):\n 1. cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "also"], ["proof (state)\nthis:\n  cindexE 0 1 (\\<lambda>t. poly pI3 t / poly pR3 t) =\n  cindex_polyE 0 1 pI3 pR3\n\ngoal (1 subgoal):\n 1. cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "have \"... = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 pI3 pR3 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "using \\<open>gc3\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  gc3 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 pI3 pR3 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "apply (subst (2) cindex_polyE_mult_cancel[of gc3,symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. gc3 \\<noteq> 0 \\<Longrightarrow> gc3 \\<noteq> 0\n 2. gc3 \\<noteq> 0 \\<Longrightarrow>\n    cindex_polyE 0 1 pI3 pR3 =\n    cindex_polyE 0 1 (gc3 * (pI3 div gc3)) (gc3 * (pR3 div gc3))", "by (simp_all add: gc3_def)"], ["proof (state)\nthis:\n  cindex_polyE 0 1 pI3 pR3 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)\n\ngoal (1 subgoal):\n 1. cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)\n\ngoal (1 subgoal):\n 1. cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)", "."], ["proof (state)\nthis:\n  cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n    cindex_pathE g4 0 =\n    cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "moreover"], ["proof (state)\nthis:\n  cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n    cindex_pathE g4 0 =\n    cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "have \"cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "have \"g4 = poly p4 o of_real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g4 = poly p4 \\<circ> complex_of_real", "unfolding g4_def p4_def l4_def poly_linepath_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     (p \\<circ>\\<^sub>p\n      [:Complex (Re lb) (Im ub), lb - Complex (Re lb) (Im ub):]) \\<circ>\n    complex_of_real =\n    poly\n     (p \\<circ>\\<^sub>p\n      [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):]) \\<circ>\n    complex_of_real", "by (subst (5) complex_surj[symmetric],simp)"], ["proof (state)\nthis:\n  g4 = poly p4 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "then"], ["proof (chain)\npicking this:\n  g4 = poly p4 \\<circ> complex_of_real", "have \"cindex_pathE g4 0  = cindexE 0 1 (\\<lambda>t. poly pI4 t / poly pR4 t)\""], ["proof (prove)\nusing this:\n  g4 = poly p4 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindex_pathE g4 0 = cindexE 0 1 (\\<lambda>t. poly pI4 t / poly pR4 t)", "unfolding cindex_pathE_def pR4_def pI4_def"], ["proof (prove)\nusing this:\n  g4 = poly p4 \\<circ> complex_of_real\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (g4 t - 0) / Re (g4 t - 0)) =\n    cindexE 0 1\n     (\\<lambda>t. poly (map_poly Im p4) t / poly (map_poly Re p4) t)", "by (simp add:Im_poly_of_real Re_poly_of_real)"], ["proof (state)\nthis:\n  cindex_pathE g4 0 = cindexE 0 1 (\\<lambda>t. poly pI4 t / poly pR4 t)\n\ngoal (1 subgoal):\n 1. cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "also"], ["proof (state)\nthis:\n  cindex_pathE g4 0 = cindexE 0 1 (\\<lambda>t. poly pI4 t / poly pR4 t)\n\ngoal (1 subgoal):\n 1. cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "have \"... = cindex_polyE 0 1 pI4 pR4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. poly pI4 t / poly pR4 t) =\n    cindex_polyE 0 1 pI4 pR4", "using cindexE_eq_cindex_polyE"], ["proof (prove)\nusing this:\n  ?a < ?b \\<Longrightarrow>\n  cindexE ?a ?b (\\<lambda>x. poly ?q x / poly ?p x) =\n  cindex_polyE ?a ?b ?q ?p\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. poly pI4 t / poly pR4 t) =\n    cindex_polyE 0 1 pI4 pR4", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (\\<lambda>t. poly pI4 t / poly pR4 t) =\n  cindex_polyE 0 1 pI4 pR4\n\ngoal (1 subgoal):\n 1. cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "also"], ["proof (state)\nthis:\n  cindexE 0 1 (\\<lambda>t. poly pI4 t / poly pR4 t) =\n  cindex_polyE 0 1 pI4 pR4\n\ngoal (1 subgoal):\n 1. cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "have \"... = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 pI4 pR4 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "using \\<open>gc4\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  gc4 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 pI4 pR4 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "apply (subst (2) cindex_polyE_mult_cancel[of gc4,symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. gc4 \\<noteq> 0 \\<Longrightarrow> gc4 \\<noteq> 0\n 2. gc4 \\<noteq> 0 \\<Longrightarrow>\n    cindex_polyE 0 1 pI4 pR4 =\n    cindex_polyE 0 1 (gc4 * (pI4 div gc4)) (gc4 * (pR4 div gc4))", "by (simp_all add: gc4_def)"], ["proof (state)\nthis:\n  cindex_polyE 0 1 pI4 pR4 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)\n\ngoal (1 subgoal):\n 1. cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)\n\ngoal (1 subgoal):\n 1. cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "."], ["proof (state)\nthis:\n  cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n    cindex_pathE g4 0 =\n    cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)\n  cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)\n  cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)\n  cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE g1 0 = cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1)\n  cindex_pathE g2 0 = cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2)\n  cindex_pathE g3 0 = cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3)\n  cindex_pathE g4 0 = cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)\n\ngoal (1 subgoal):\n 1. cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n    cindex_pathE g4 0 =\n    cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)", "by auto"], ["proof (state)\nthis:\n  cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n  cindex_pathE g4 0 =\n  cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n  cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n  cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n  cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n  cindex_pathE g4 0 =\n  cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n  cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n  cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n  cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)\n\ngoal (1 subgoal):\n 1. complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n    of_int (- sms) / of_int 4", "also"], ["proof (state)\nthis:\n  cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0 +\n  cindex_pathE g4 0 =\n  cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n  cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n  cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n  cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4)\n\ngoal (1 subgoal):\n 1. complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n    of_int (- sms) / of_int 4", "have \"... = sms / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int sms / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int sms / 2", "have \"cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) \n            = changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) =\n    real_of_int (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1)) / 2", "apply (rule cindex_polyE_changes_alt_itv_mods)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR1 div gc1) (pI1 div gc1)", "using \\<open>gc1\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  gc1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR1 div gc1) (pI1 div gc1)", "unfolding gc1_def"], ["proof (prove)\nusing this:\n  gcd pR1 pI1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR1 div gcd pR1 pI1) (pI1 div gcd pR1 pI1)", "by (auto intro:div_gcd_coprime)"], ["proof (state)\nthis:\n  cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1)) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int sms / 2", "moreover"], ["proof (state)\nthis:\n  cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1)) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int sms / 2", "have \"cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) \n            = changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) =\n    real_of_int (changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2)) / 2", "apply (rule cindex_polyE_changes_alt_itv_mods)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR2 div gc2) (pI2 div gc2)", "using \\<open>gc2\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  gc2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR2 div gc2) (pI2 div gc2)", "unfolding gc2_def"], ["proof (prove)\nusing this:\n  gcd pR2 pI2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR2 div gcd pR2 pI2) (pI2 div gcd pR2 pI2)", "by (auto intro:div_gcd_coprime)"], ["proof (state)\nthis:\n  cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2)) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int sms / 2", "moreover"], ["proof (state)\nthis:\n  cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2)) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int sms / 2", "have \"cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) \n            = changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) =\n    real_of_int (changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3)) / 2", "apply (rule cindex_polyE_changes_alt_itv_mods)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR3 div gc3) (pI3 div gc3)", "using \\<open>gc3\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  gc3 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR3 div gc3) (pI3 div gc3)", "unfolding gc3_def"], ["proof (prove)\nusing this:\n  gcd pR3 pI3 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR3 div gcd pR3 pI3) (pI3 div gcd pR3 pI3)", "by (auto intro:div_gcd_coprime)"], ["proof (state)\nthis:\n  cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3)) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int sms / 2", "moreover"], ["proof (state)\nthis:\n  cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3)) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int sms / 2", "have \"cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) \n            = changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int (changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) / 2", "apply (rule cindex_polyE_changes_alt_itv_mods)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR4 div gc4) (pI4 div gc4)", "using \\<open>gc4\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  gc4 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR4 div gc4) (pI4 div gc4)", "unfolding gc4_def"], ["proof (prove)\nusing this:\n  gcd pR4 pI4 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 < 1\n 2. coprime (pR4 div gcd pR4 pI4) (pI4 div gcd pR4 pI4)", "by (auto intro:div_gcd_coprime)"], ["proof (state)\nthis:\n  cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int sms / 2", "ultimately"], ["proof (chain)\npicking this:\n  cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1)) / 2\n  cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2)) / 2\n  cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3)) / 2\n  cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1)) / 2\n  cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2)) / 2\n  cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3)) / 2\n  cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int sms / 2", "unfolding sms_def"], ["proof (prove)\nusing this:\n  cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1)) / 2\n  cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2)) / 2\n  cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3)) / 2\n  cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n  real_of_int (changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) / 2\n\ngoal (1 subgoal):\n 1. cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n    cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n    cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n    cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n    real_of_int\n     (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) +\n      changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) +\n      changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) +\n      changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) /\n    2", "by auto"], ["proof (state)\nthis:\n  cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n  cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n  cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n  cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n  real_of_int sms / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_polyE 0 1 (pI1 div gc1) (pR1 div gc1) +\n  cindex_polyE 0 1 (pI2 div gc2) (pR2 div gc2) +\n  cindex_polyE 0 1 (pI3 div gc3) (pR3 div gc3) +\n  cindex_polyE 0 1 (pI4 div gc4) (pR4 div gc4) =\n  real_of_int sms / 2\n\ngoal (1 subgoal):\n 1. complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n    of_int (- sms) / of_int 4", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE (poly p \\<circ> rec) 0 = real_of_int sms / 2", "have *:\"cindex_pathE (poly p \\<circ> rec) 0 = real_of_int sms / 2\""], ["proof (prove)\nusing this:\n  cindex_pathE (poly p \\<circ> rec) 0 = real_of_int sms / 2\n\ngoal (1 subgoal):\n 1. cindex_pathE (poly p \\<circ> rec) 0 = real_of_int sms / 2", "."], ["proof (state)\nthis:\n  cindex_pathE (poly p \\<circ> rec) 0 = real_of_int sms / 2\n\ngoal (1 subgoal):\n 1. complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n    of_int (- sms) / of_int 4", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n    of_int (- sms) / of_int 4", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (- (real_of_int sms / 2) / 2) =\n    of_int (- sms) / of_int 4", "by auto"], ["proof (state)\nthis:\n  complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n  of_int (- sms) / of_int 4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  complex_of_real (- cindex_pathE (poly p \\<circ> rec) 0 / 2) =\n  of_int (- sms) / of_int 4\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "finally"], ["proof (chain)\npicking this:\n  of_nat (proots_rectangle p lb ub) = of_int (- sms) / of_int 4", "have \"(of_nat::_\\<Rightarrow>complex) (proots_rectangle p lb ub) = of_int (- sms) / of_int 4\""], ["proof (prove)\nusing this:\n  of_nat (proots_rectangle p lb ub) = of_int (- sms) / of_int 4\n\ngoal (1 subgoal):\n 1. of_nat (proots_rectangle p lb ub) = of_int (- sms) / of_int 4", "."], ["proof (state)\nthis:\n  of_nat (proots_rectangle p lb ub) = of_int (- sms) / of_int 4\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "moreover"], ["proof (state)\nthis:\n  of_nat (proots_rectangle p lb ub) = of_int (- sms) / of_int 4\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have \"4 dvd sms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 dvd sms", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 4 dvd sms", "have \"winding_number (poly p \\<circ> rec) 0 \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (poly p \\<circ> rec) 0 \\<in> \\<int>", "proof (rule integer_winding_number)"], ["proof (state)\ngoal (3 subgoals):\n 1. path (poly p \\<circ> rec)\n 2. pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)\n 3. 0 \\<notin> path_image (poly p \\<circ> rec)", "show \"path (poly p \\<circ> rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (poly p \\<circ> rec)", "by (auto intro!:valid_path_compose_holomorphic[where S=UNIV] valid_path_imp_path)"], ["proof (state)\nthis:\n  path (poly p \\<circ> rec)\n\ngoal (2 subgoals):\n 1. pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)\n 2. 0 \\<notin> path_image (poly p \\<circ> rec)", "show \"pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)", "unfolding rec_def path_compose_join"], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish\n     ((poly p \\<circ> l1) +++\n      (poly p \\<circ> l2) +++ (poly p \\<circ> l3) +++ (poly p \\<circ> l4)) =\n    pathstart\n     ((poly p \\<circ> l1) +++\n      (poly p \\<circ> l2) +++ (poly p \\<circ> l3) +++ (poly p \\<circ> l4))", "by (auto simp add:l1_def l4_def pathfinish_compose pathstart_compose)"], ["proof (state)\nthis:\n  pathfinish (poly p \\<circ> rec) = pathstart (poly p \\<circ> rec)\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (poly p \\<circ> rec)", "show \"0 \\<notin> path_image (poly p \\<circ> rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (poly p \\<circ> rec)", "using path_no_proots"], ["proof (prove)\nusing this:\n  path_image rec \\<inter> proots p = {}\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (poly p \\<circ> rec)", "unfolding path_image_compose proots_def"], ["proof (prove)\nusing this:\n  path_image rec \\<inter> {x. poly p x = 0} = {}\n\ngoal (1 subgoal):\n 1. 0 \\<notin> poly p ` path_image rec", "by fastforce"], ["proof (state)\nthis:\n  0 \\<notin> path_image (poly p \\<circ> rec)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  winding_number (poly p \\<circ> rec) 0 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. 4 dvd sms", "then"], ["proof (chain)\npicking this:\n  winding_number (poly p \\<circ> rec) 0 \\<in> \\<int>", "have \"of_int (- sms) / of_int 4 \\<in> (\\<int>::complex set)\""], ["proof (prove)\nusing this:\n  winding_number (poly p \\<circ> rec) 0 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. of_int (- sms) / of_int 4 \\<in> \\<int>", "by (simp only: winding_eq cindex_pathE_eq)"], ["proof (state)\nthis:\n  of_int (- sms) / of_int 4 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. 4 dvd sms", "then"], ["proof (chain)\npicking this:\n  of_int (- sms) / of_int 4 \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  of_int (- sms) / of_int 4 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. 4 dvd sms", "by (subst (asm) dvd_divide_Ints_iff[symmetric],auto)"], ["proof (state)\nthis:\n  4 dvd sms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  4 dvd sms\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  of_nat (proots_rectangle p lb ub) = of_int (- sms) / of_int 4\n  4 dvd sms", "have \"proots_rectangle p lb ub = nat (- sms div 4)\""], ["proof (prove)\nusing this:\n  of_nat (proots_rectangle p lb ub) = of_int (- sms) / of_int 4\n  4 dvd sms\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub = nat (- sms div 4)", "apply (subst (asm) of_int_div_field[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 4 dvd sms \\<Longrightarrow> 4 dvd - sms\n 2. \\<lbrakk>of_nat (proots_rectangle p lb ub) = of_int (- sms div 4);\n     4 dvd sms\\<rbrakk>\n    \\<Longrightarrow> proots_rectangle p lb ub = nat (- sms div 4)", "by (simp,metis nat_int of_int_eq_iff of_int_of_nat_eq)"], ["proof (state)\nthis:\n  proots_rectangle p lb ub = nat (- sms div 4)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "then"], ["proof (chain)\npicking this:\n  proots_rectangle p lb ub = nat (- sms div 4)", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_rectangle p lb ub = nat (- sms div 4)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "unfolding Let_def"], ["proof (prove)\nusing this:\n  proots_rectangle p lb ub = nat (- sms div 4)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then nat (- (changes_alt_itv_smods 0 1\n                             (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:lb, Complex (Re ub - Re lb) 0:]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:lb, Complex (Re ub - Re lb) 0:]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:lb, Complex (Re ub - Re lb) 0:])))\n                             (map_poly Im\n                               (p \\<circ>\\<^sub>p\n                                [:lb, Complex (Re ub - Re lb) 0:]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:lb, Complex (Re ub - Re lb) 0:]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:lb, Complex (Re ub - Re lb) 0:]))) +\n                            changes_alt_itv_smods 0 1\n                             (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:Complex (Re ub) (Im lb),\n                                  Complex 0 (Im ub - Im lb):]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re ub) (Im lb),\n Complex 0 (Im ub - Im lb):]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:Complex (Re ub) (Im lb),\n                                    Complex 0 (Im ub - Im lb):])))\n                             (map_poly Im\n                               (p \\<circ>\\<^sub>p\n                                [:Complex (Re ub) (Im lb),\n                                  Complex 0 (Im ub - Im lb):]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re ub) (Im lb),\n Complex 0 (Im ub - Im lb):]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:Complex (Re ub) (Im lb),\n                                    Complex 0 (Im ub - Im lb):]))) +\n                            changes_alt_itv_smods 0 1\n                             (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:ub, Complex (Re lb - Re ub) 0:]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:ub, Complex (Re lb - Re ub) 0:]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:ub, Complex (Re lb - Re ub) 0:])))\n                             (map_poly Im\n                               (p \\<circ>\\<^sub>p\n                                [:ub, Complex (Re lb - Re ub) 0:]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:ub, Complex (Re lb - Re ub) 0:]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:ub, Complex (Re lb - Re ub) 0:]))) +\n                            changes_alt_itv_smods 0 1\n                             (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:Complex (Re lb) (Im ub),\n                                  Complex 0 (Im lb - Im ub):]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re lb) (Im ub),\n Complex 0 (Im lb - Im ub):]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:Complex (Re lb) (Im ub),\n                                    Complex 0 (Im lb - Im ub):])))\n                             (map_poly Im\n                               (p \\<circ>\\<^sub>p\n                                [:Complex (Re lb) (Im ub),\n                                  Complex 0 (Im lb - Im ub):]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re lb) (Im ub),\n Complex 0 (Im lb - Im ub):]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:Complex (Re lb) (Im ub),\n                                    Complex 0 (Im lb - Im ub):])))) div\n                         4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "apply (fold p1_def p2_def p3_def p4_def pI1_def pR1_def pI2_def pR2_def pI3_def pR3_def\n          pI4_def pR4_def gc1_def gc2_def gc3_def gc4_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub = nat (- sms div 4) \\<Longrightarrow>\n    proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                             (pI1 div gc1) +\n                            changes_alt_itv_smods 0 1 (pR2 div gc2)\n                             (pI2 div gc2) +\n                            changes_alt_itv_smods 0 1 (pR3 div gc3)\n                             (pI3 div gc3) +\n                            changes_alt_itv_smods 0 1 (pR4 div gc4)\n                             (pI4 div gc4)) div\n                         4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "apply (fold sms_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub = nat (- sms div 4) \\<Longrightarrow>\n    proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then nat (- sms div 4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "using that"], ["proof (prove)\nusing this:\n  Re lb < Re ub\n  Im lb < Im ub\n  p \\<noteq> 0\n  no_proots_line p lb (Complex (Re ub) (Im lb))\n  no_proots_line p (Complex (Re ub) (Im lb)) ub\n  no_proots_line p ub (Complex (Re lb) (Im ub))\n  no_proots_line p (Complex (Re lb) (Im ub)) lb\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub = nat (- sms div 4) \\<Longrightarrow>\n    proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then nat (- sms div 4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "by auto"], ["proof (state)\nthis:\n  proots_rectangle p lb ub =\n  (if Re lb < Re ub \\<and> Im lb < Im ub\n   then if p \\<noteq> 0\n        then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                no_proots_line p (Complex (Re lb) (Im ub)) lb\n             then let p1 = p \\<circ>\\<^sub>p\n                           [:lb, Complex (Re ub - Re lb) 0:];\n                      pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                      gc1 = gcd pR1 pI1;\n                      p2 = p \\<circ>\\<^sub>p\n                           [:Complex (Re ub) (Im lb),\n                             Complex 0 (Im ub - Im lb):];\n                      pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                      gc2 = gcd pR2 pI2;\n                      p3 = p \\<circ>\\<^sub>p\n                           [:ub, Complex (Re lb - Re ub) 0:];\n                      pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                      gc3 = gcd pR3 pI3;\n                      p4 = p \\<circ>\\<^sub>p\n                           [:Complex (Re lb) (Im ub),\n                             Complex 0 (Im lb - Im ub):];\n                      pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                      gc4 = gcd pR4 pI4\n                  in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                              (pI1 div gc1) +\n                             changes_alt_itv_smods 0 1 (pR2 div gc2)\n                              (pI2 div gc2) +\n                             changes_alt_itv_smods 0 1 (pR3 div gc3)\n                              (pI3 div gc3) +\n                             changes_alt_itv_smods 0 1 (pR4 div gc4)\n                              (pI4 div gc4)) div\n                          4)\n             else Code.abort\n                   STR ''proots_rectangle fails when there is a root on the border.''\n                   (\\<lambda>_. proots_rectangle p lb ub)\n        else Code.abort STR ''proots_rectangle fails when p=0.''\n              (\\<lambda>_. proots_rectangle p lb ub)\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Re lb < Re ub; Im lb < Im ub; p \\<noteq> 0;\n   no_proots_line p lb (Complex (Re ub) (Im lb));\n   no_proots_line p (Complex (Re ub) (Im lb)) ub;\n   no_proots_line p ub (Complex (Re lb) (Im ub));\n   no_proots_line p (Complex (Re lb) (Im ub)) lb\\<rbrakk>\n  \\<Longrightarrow> proots_rectangle p lb ub =\n                    (if Re lb < Re ub \\<and> Im lb < Im ub\n                     then if p \\<noteq> 0\n                          then if no_proots_line p lb\n                                   (Complex (Re ub) (Im lb)) \\<and>\n                                  no_proots_line p (Complex (Re ub) (Im lb))\n                                   ub \\<and>\n                                  no_proots_line p ub\n                                   (Complex (Re lb) (Im ub)) \\<and>\n                                  no_proots_line p (Complex (Re lb) (Im ub))\n                                   lb\n                               then let p1 =\n    p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:];\n  pR1 = map_poly Re p1; pI1 = map_poly Im p1; gc1 = gcd pR1 pI1;\n  p2 = p \\<circ>\\<^sub>p\n       [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):];\n  pR2 = map_poly Re p2; pI2 = map_poly Im p2; gc2 = gcd pR2 pI2;\n  p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:];\n  pR3 = map_poly Re p3; pI3 = map_poly Im p3; gc3 = gcd pR3 pI3;\n  p4 = p \\<circ>\\<^sub>p\n       [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):];\n  pR4 = map_poly Re p4; pI4 = map_poly Im p4; gc4 = gcd pR4 pI4\n                                    in nat\n  (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) +\n      changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) +\n      changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) +\n      changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) div\n   4)\n                               else Code.abort\n                                     STR ''proots_rectangle fails when there is a root on the border.''\n                                     (\\<lambda>_. proots_rectangle p lb ub)\n                          else Code.abort\n                                STR ''proots_rectangle fails when p=0.''\n                                (\\<lambda>_. proots_rectangle p lb ub)\n                     else 0)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (Re lb < Re ub \\<and> Im lb < Im ub) \\<Longrightarrow>\n  proots_rectangle p lb ub =\n  (if Re lb < Re ub \\<and> Im lb < Im ub\n   then if p \\<noteq> 0\n        then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                no_proots_line p (Complex (Re lb) (Im ub)) lb\n             then let p1 = p \\<circ>\\<^sub>p\n                           [:lb, Complex (Re ub - Re lb) 0:];\n                      pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                      gc1 = gcd pR1 pI1;\n                      p2 = p \\<circ>\\<^sub>p\n                           [:Complex (Re ub) (Im lb),\n                             Complex 0 (Im ub - Im lb):];\n                      pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                      gc2 = gcd pR2 pI2;\n                      p3 = p \\<circ>\\<^sub>p\n                           [:ub, Complex (Re lb - Re ub) 0:];\n                      pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                      gc3 = gcd pR3 pI3;\n                      p4 = p \\<circ>\\<^sub>p\n                           [:Complex (Re lb) (Im ub),\n                             Complex 0 (Im lb - Im ub):];\n                      pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                      gc4 = gcd pR4 pI4\n                  in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                              (pI1 div gc1) +\n                             changes_alt_itv_smods 0 1 (pR2 div gc2)\n                              (pI2 div gc2) +\n                             changes_alt_itv_smods 0 1 (pR3 div gc3)\n                              (pI3 div gc3) +\n                             changes_alt_itv_smods 0 1 (pR4 div gc4)\n                              (pI4 div gc4)) div\n                          4)\n             else Code.abort\n                   STR ''proots_rectangle fails when there is a root on the border.''\n                   (\\<lambda>_. proots_rectangle p lb ub)\n        else Code.abort STR ''proots_rectangle fails when p=0.''\n              (\\<lambda>_. proots_rectangle p lb ub)\n   else 0)\n  \\<lbrakk>Re lb < Re ub \\<and> Im lb < Im ub; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_rectangle p lb ub =\n                    (if Re lb < Re ub \\<and> Im lb < Im ub\n                     then if p \\<noteq> 0\n                          then if no_proots_line p lb\n                                   (Complex (Re ub) (Im lb)) \\<and>\n                                  no_proots_line p (Complex (Re ub) (Im lb))\n                                   ub \\<and>\n                                  no_proots_line p ub\n                                   (Complex (Re lb) (Im ub)) \\<and>\n                                  no_proots_line p (Complex (Re lb) (Im ub))\n                                   lb\n                               then let p1 =\n    p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:];\n  pR1 = map_poly Re p1; pI1 = map_poly Im p1; gc1 = gcd pR1 pI1;\n  p2 = p \\<circ>\\<^sub>p\n       [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):];\n  pR2 = map_poly Re p2; pI2 = map_poly Im p2; gc2 = gcd pR2 pI2;\n  p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:];\n  pR3 = map_poly Re p3; pI3 = map_poly Im p3; gc3 = gcd pR3 pI3;\n  p4 = p \\<circ>\\<^sub>p\n       [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):];\n  pR4 = map_poly Re p4; pI4 = map_poly Im p4; gc4 = gcd pR4 pI4\n                                    in nat\n  (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) +\n      changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) +\n      changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) +\n      changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) div\n   4)\n                               else Code.abort\n                                     STR ''proots_rectangle fails when there is a root on the border.''\n                                     (\\<lambda>_. proots_rectangle p lb ub)\n                          else Code.abort\n                                STR ''proots_rectangle fails when p=0.''\n                                (\\<lambda>_. proots_rectangle p lb ub)\n                     else 0)\n  \\<lbrakk>Re lb < Re ub; Im lb < Im ub; p \\<noteq> 0;\n   no_proots_line p lb (Complex (Re ub) (Im lb));\n   no_proots_line p (Complex (Re ub) (Im lb)) ub;\n   no_proots_line p ub (Complex (Re lb) (Im ub));\n   no_proots_line p (Complex (Re lb) (Im ub)) lb\\<rbrakk>\n  \\<Longrightarrow> proots_rectangle p lb ub =\n                    (if Re lb < Re ub \\<and> Im lb < Im ub\n                     then if p \\<noteq> 0\n                          then if no_proots_line p lb\n                                   (Complex (Re ub) (Im lb)) \\<and>\n                                  no_proots_line p (Complex (Re ub) (Im lb))\n                                   ub \\<and>\n                                  no_proots_line p ub\n                                   (Complex (Re lb) (Im ub)) \\<and>\n                                  no_proots_line p (Complex (Re lb) (Im ub))\n                                   lb\n                               then let p1 =\n    p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:];\n  pR1 = map_poly Re p1; pI1 = map_poly Im p1; gc1 = gcd pR1 pI1;\n  p2 = p \\<circ>\\<^sub>p\n       [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):];\n  pR2 = map_poly Re p2; pI2 = map_poly Im p2; gc2 = gcd pR2 pI2;\n  p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:];\n  pR3 = map_poly Re p3; pI3 = map_poly Im p3; gc3 = gcd pR3 pI3;\n  p4 = p \\<circ>\\<^sub>p\n       [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):];\n  pR4 = map_poly Re p4; pI4 = map_poly Im p4; gc4 = gcd pR4 pI4\n                                    in nat\n  (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) +\n      changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) +\n      changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) +\n      changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) div\n   4)\n                               else Code.abort\n                                     STR ''proots_rectangle fails when there is a root on the border.''\n                                     (\\<lambda>_. proots_rectangle p lb ub)\n                          else Code.abort\n                                STR ''proots_rectangle fails when p=0.''\n                                (\\<lambda>_. proots_rectangle p lb ub)\n                     else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (Re lb < Re ub \\<and> Im lb < Im ub) \\<Longrightarrow>\n  proots_rectangle p lb ub =\n  (if Re lb < Re ub \\<and> Im lb < Im ub\n   then if p \\<noteq> 0\n        then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                no_proots_line p (Complex (Re lb) (Im ub)) lb\n             then let p1 = p \\<circ>\\<^sub>p\n                           [:lb, Complex (Re ub - Re lb) 0:];\n                      pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                      gc1 = gcd pR1 pI1;\n                      p2 = p \\<circ>\\<^sub>p\n                           [:Complex (Re ub) (Im lb),\n                             Complex 0 (Im ub - Im lb):];\n                      pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                      gc2 = gcd pR2 pI2;\n                      p3 = p \\<circ>\\<^sub>p\n                           [:ub, Complex (Re lb - Re ub) 0:];\n                      pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                      gc3 = gcd pR3 pI3;\n                      p4 = p \\<circ>\\<^sub>p\n                           [:Complex (Re lb) (Im ub),\n                             Complex 0 (Im lb - Im ub):];\n                      pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                      gc4 = gcd pR4 pI4\n                  in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                              (pI1 div gc1) +\n                             changes_alt_itv_smods 0 1 (pR2 div gc2)\n                              (pI2 div gc2) +\n                             changes_alt_itv_smods 0 1 (pR3 div gc3)\n                              (pI3 div gc3) +\n                             changes_alt_itv_smods 0 1 (pR4 div gc4)\n                              (pI4 div gc4)) div\n                          4)\n             else Code.abort\n                   STR ''proots_rectangle fails when there is a root on the border.''\n                   (\\<lambda>_. proots_rectangle p lb ub)\n        else Code.abort STR ''proots_rectangle fails when p=0.''\n              (\\<lambda>_. proots_rectangle p lb ub)\n   else 0)\n  \\<lbrakk>Re lb < Re ub \\<and> Im lb < Im ub; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_rectangle p lb ub =\n                    (if Re lb < Re ub \\<and> Im lb < Im ub\n                     then if p \\<noteq> 0\n                          then if no_proots_line p lb\n                                   (Complex (Re ub) (Im lb)) \\<and>\n                                  no_proots_line p (Complex (Re ub) (Im lb))\n                                   ub \\<and>\n                                  no_proots_line p ub\n                                   (Complex (Re lb) (Im ub)) \\<and>\n                                  no_proots_line p (Complex (Re lb) (Im ub))\n                                   lb\n                               then let p1 =\n    p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:];\n  pR1 = map_poly Re p1; pI1 = map_poly Im p1; gc1 = gcd pR1 pI1;\n  p2 = p \\<circ>\\<^sub>p\n       [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):];\n  pR2 = map_poly Re p2; pI2 = map_poly Im p2; gc2 = gcd pR2 pI2;\n  p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:];\n  pR3 = map_poly Re p3; pI3 = map_poly Im p3; gc3 = gcd pR3 pI3;\n  p4 = p \\<circ>\\<^sub>p\n       [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):];\n  pR4 = map_poly Re p4; pI4 = map_poly Im p4; gc4 = gcd pR4 pI4\n                                    in nat\n  (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) +\n      changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) +\n      changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) +\n      changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) div\n   4)\n                               else Code.abort\n                                     STR ''proots_rectangle fails when there is a root on the border.''\n                                     (\\<lambda>_. proots_rectangle p lb ub)\n                          else Code.abort\n                                STR ''proots_rectangle fails when p=0.''\n                                (\\<lambda>_. proots_rectangle p lb ub)\n                     else 0)\n  \\<lbrakk>Re lb < Re ub; Im lb < Im ub; p \\<noteq> 0;\n   no_proots_line p lb (Complex (Re ub) (Im lb));\n   no_proots_line p (Complex (Re ub) (Im lb)) ub;\n   no_proots_line p ub (Complex (Re lb) (Im ub));\n   no_proots_line p (Complex (Re lb) (Im ub)) lb\\<rbrakk>\n  \\<Longrightarrow> proots_rectangle p lb ub =\n                    (if Re lb < Re ub \\<and> Im lb < Im ub\n                     then if p \\<noteq> 0\n                          then if no_proots_line p lb\n                                   (Complex (Re ub) (Im lb)) \\<and>\n                                  no_proots_line p (Complex (Re ub) (Im lb))\n                                   ub \\<and>\n                                  no_proots_line p ub\n                                   (Complex (Re lb) (Im ub)) \\<and>\n                                  no_proots_line p (Complex (Re lb) (Im ub))\n                                   lb\n                               then let p1 =\n    p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:];\n  pR1 = map_poly Re p1; pI1 = map_poly Im p1; gc1 = gcd pR1 pI1;\n  p2 = p \\<circ>\\<^sub>p\n       [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):];\n  pR2 = map_poly Re p2; pI2 = map_poly Im p2; gc2 = gcd pR2 pI2;\n  p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:];\n  pR3 = map_poly Re p3; pI3 = map_poly Im p3; gc3 = gcd pR3 pI3;\n  p4 = p \\<circ>\\<^sub>p\n       [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):];\n  pR4 = map_poly Re p4; pI4 = map_poly Im p4; gc4 = gcd pR4 pI4\n                                    in nat\n  (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) +\n      changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) +\n      changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) +\n      changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) div\n   4)\n                               else Code.abort\n                                     STR ''proots_rectangle fails when there is a root on the border.''\n                                     (\\<lambda>_. proots_rectangle p lb ub)\n                          else Code.abort\n                                STR ''proots_rectangle fails when p=0.''\n                                (\\<lambda>_. proots_rectangle p lb ub)\n                     else 0)\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "by fastforce"], ["proof (state)\nthis:\n  proots_rectangle p lb ub =\n  (if Re lb < Re ub \\<and> Im lb < Im ub\n   then if p \\<noteq> 0\n        then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                no_proots_line p (Complex (Re lb) (Im ub)) lb\n             then let p1 = p \\<circ>\\<^sub>p\n                           [:lb, Complex (Re ub - Re lb) 0:];\n                      pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                      gc1 = gcd pR1 pI1;\n                      p2 = p \\<circ>\\<^sub>p\n                           [:Complex (Re ub) (Im lb),\n                             Complex 0 (Im ub - Im lb):];\n                      pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                      gc2 = gcd pR2 pI2;\n                      p3 = p \\<circ>\\<^sub>p\n                           [:ub, Complex (Re lb - Re ub) 0:];\n                      pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                      gc3 = gcd pR3 pI3;\n                      p4 = p \\<circ>\\<^sub>p\n                           [:Complex (Re lb) (Im ub),\n                             Complex 0 (Im lb - Im ub):];\n                      pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                      gc4 = gcd pR4 pI4\n                  in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                              (pI1 div gc1) +\n                             changes_alt_itv_smods 0 1 (pR2 div gc2)\n                              (pI2 div gc2) +\n                             changes_alt_itv_smods 0 1 (pR3 div gc3)\n                              (pI3 div gc3) +\n                             changes_alt_itv_smods 0 1 (pR4 div gc4)\n                              (pI4 div gc4)) div\n                          4)\n             else Code.abort\n                   STR ''proots_rectangle fails when there is a root on the border.''\n                   (\\<lambda>_. proots_rectangle p lb ub)\n        else Code.abort STR ''proots_rectangle fails when p=0.''\n              (\\<lambda>_. proots_rectangle p lb ub)\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*further refinement*)"], ["", "lemma proots_rectangle_code2[code]:\n  \"proots_rectangle p lb ub = (if Re lb < Re ub \\<and> Im lb < Im ub then \n            if p\\<noteq>0 then \n            if poly p lb \\<noteq> 0 \\<and> poly p (Complex (Re ub) (Im lb)) \\<noteq>0 \n               \\<and> poly p ub \\<noteq>0 \\<and> poly p (Complex (Re lb) (Im ub)) \\<noteq>0 \n            then\n              (let p1 = pcompose p [:lb,  Complex (Re ub - Re lb) 0:];\n                pR1 = map_poly Re p1; pI1 = map_poly Im p1; gc1 = gcd pR1 pI1;\n                p2 = pcompose p [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):];\n                pR2 = map_poly Re p2; pI2 = map_poly Im p2; gc2 = gcd pR2 pI2;\n                p3 = pcompose p [:ub, Complex (Re lb - Re ub) 0:];\n                pR3 = map_poly Re p3; pI3 = map_poly Im p3; gc3 = gcd pR3 pI3;\n                p4 = pcompose p [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):];\n                pR4 = map_poly Re p4; pI4 = map_poly Im p4; gc4 = gcd pR4 pI4\n              in\n                if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0\n                   \\<and> changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \n                   \\<and> changes_itv_smods 0 1 gc3 (pderiv gc3) = 0\n                   \\<and> changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                then \n                   nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1)\n                    + changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2)\n                    + changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3)\n                    + changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) div 4)\n                else Code.abort (STR ''proots_rectangle fails when there is a root on the border.'') \n                        (\\<lambda>_. proots_rectangle p lb ub))\n            else Code.abort (STR ''proots_rectangle fails when there is a root on the border.'') \n              (\\<lambda>_. proots_rectangle p lb ub)  \n            else Code.abort (STR ''proots_rectangle fails when p=0.'') \n            (\\<lambda>_. proots_rectangle p lb ub)\n            else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if poly p lb \\<noteq> 0 \\<and>\n                  poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                  poly p ub \\<noteq> 0 \\<and>\n                  poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0 \\<and>\n                          changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \\<and>\n                          changes_itv_smods 0 1 gc3 (pderiv gc3) = 0 \\<and>\n                          changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                       then nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                     (pI1 div gc1) +\n                                    changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                     (pI2 div gc2) +\n                                    changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                     (pI3 div gc3) +\n                                    changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                     (pI4 div gc4)) div\n                                 4)\n                       else Code.abort\n                             STR ''proots_rectangle fails when there is a root on the border.''\n                             (\\<lambda>_. proots_rectangle p lb ub)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if poly p lb \\<noteq> 0 \\<and>\n                  poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                  poly p ub \\<noteq> 0 \\<and>\n                  poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0 \\<and>\n                          changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \\<and>\n                          changes_itv_smods 0 1 gc3 (pderiv gc3) = 0 \\<and>\n                          changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                       then nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                     (pI1 div gc1) +\n                                    changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                     (pI2 div gc2) +\n                                    changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                     (pI3 div gc3) +\n                                    changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                     (pI4 div gc4)) div\n                                 4)\n                       else Code.abort\n                             STR ''proots_rectangle fails when there is a root on the border.''\n                             (\\<lambda>_. proots_rectangle p lb ub)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define p1 pR1 pI1 gc1\n           p2 pR2 pI2 gc2\n           p3 pR3 pI3 gc3\n           p4 pR4 pI4 gc4\n      where \"p1 = pcompose p [:lb,  Complex (Re ub - Re lb) 0:]\"\n             and \"pR1 = map_poly Re p1\" and \"pI1 = map_poly Im p1\" and \"gc1 = gcd pR1 pI1\"\n             and \"p2 = pcompose p [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):]\"\n             and \"pR2 = map_poly Re p2\" and \"pI2 = map_poly Im p2\" and \"gc2 = gcd pR2 pI2\"\n             and \"p3 = pcompose p [:ub, Complex (Re lb - Re ub) 0:]\"\n             and \"pR3 = map_poly Re p3\" and \"pI3 = map_poly Im p3\" and \"gc3 = gcd pR3 pI3\"\n             and \"p4 = pcompose p [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):]\"\n             and \"pR4 = map_poly Re p4\" and \"pI4 = map_poly Im p4\" and \"gc4 = gcd pR4 pI4\""], ["proof (state)\nthis:\n  p1 = p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:]\n  pR1 = map_poly Re p1\n  pI1 = map_poly Im p1\n  gc1 = gcd pR1 pI1\n  p2 =\n  p \\<circ>\\<^sub>p [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):]\n  pR2 = map_poly Re p2\n  pI2 = map_poly Im p2\n  gc2 = gcd pR2 pI2\n  p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:]\n  pR3 = map_poly Re p3\n  pI3 = map_poly Im p3\n  gc3 = gcd pR3 pI3\n  p4 =\n  p \\<circ>\\<^sub>p [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):]\n  pR4 = map_poly Re p4\n  pI4 = map_poly Im p4\n  gc4 = gcd pR4 pI4\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if poly p lb \\<noteq> 0 \\<and>\n                  poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                  poly p ub \\<noteq> 0 \\<and>\n                  poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0 \\<and>\n                          changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \\<and>\n                          changes_itv_smods 0 1 gc3 (pderiv gc3) = 0 \\<and>\n                          changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                       then nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                     (pI1 div gc1) +\n                                    changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                     (pI2 div gc2) +\n                                    changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                     (pI3 div gc3) +\n                                    changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                     (pI4 div gc4)) div\n                                 4)\n                       else Code.abort\n                             STR ''proots_rectangle fails when there is a root on the border.''\n                             (\\<lambda>_. proots_rectangle p lb ub)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "define sms where \n      \"sms = (- (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) +\n                       changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) +\n                       changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) +\n                       changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) div\n                    4)\""], ["proof (state)\nthis:\n  sms =\n  - (changes_alt_itv_smods 0 1 (pR1 div gc1) (pI1 div gc1) +\n     changes_alt_itv_smods 0 1 (pR2 div gc2) (pI2 div gc2) +\n     changes_alt_itv_smods 0 1 (pR3 div gc3) (pI3 div gc3) +\n     changes_alt_itv_smods 0 1 (pR4 div gc4) (pI4 div gc4)) div\n  4\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if poly p lb \\<noteq> 0 \\<and>\n                  poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                  poly p ub \\<noteq> 0 \\<and>\n                  poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0 \\<and>\n                          changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \\<and>\n                          changes_itv_smods 0 1 gc3 (pderiv gc3) = 0 \\<and>\n                          changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                       then nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                     (pI1 div gc1) +\n                                    changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                     (pI2 div gc2) +\n                                    changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                     (pI3 div gc3) +\n                                    changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                     (pI4 div gc4)) div\n                                 4)\n                       else Code.abort\n                             STR ''proots_rectangle fails when there is a root on the border.''\n                             (\\<lambda>_. proots_rectangle p lb ub)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "have more_folds:\"p1 = p \\<circ>\\<^sub>p [:lb, Complex (Re ub) (Im lb) - lb:]\"\n    \"p2 = p \\<circ>\\<^sub>p [:Complex (Re ub) (Im lb), ub - Complex (Re ub) (Im lb):]\"\n    \"p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb) (Im ub) - ub:]\"\n    \"p4 = p \\<circ>\\<^sub>p [:Complex (Re lb) (Im ub), lb - Complex (Re lb) (Im ub):]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p1 = p \\<circ>\\<^sub>p [:lb, Complex (Re ub) (Im lb) - lb:] &&&\n     p2 =\n     p \\<circ>\\<^sub>p\n     [:Complex (Re ub) (Im lb), ub - Complex (Re ub) (Im lb):]) &&&\n    p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb) (Im ub) - ub:] &&&\n    p4 =\n    p \\<circ>\\<^sub>p\n    [:Complex (Re lb) (Im ub), lb - Complex (Re lb) (Im ub):]", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 = p \\<circ>\\<^sub>p [:lb, Complex (Re ub) (Im lb) - lb:]", "unfolding p1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:] =\n    p \\<circ>\\<^sub>p [:lb, Complex (Re ub) (Im lb) - lb:]", "by (subst (10) complex_surj[symmetric],auto simp add:minus_complex.code)"], ["proof (prove)\ngoal (3 subgoals):\n 1. p2 =\n    p \\<circ>\\<^sub>p\n    [:Complex (Re ub) (Im lb), ub - Complex (Re ub) (Im lb):]\n 2. p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb) (Im ub) - ub:]\n 3. p4 =\n    p \\<circ>\\<^sub>p\n    [:Complex (Re lb) (Im ub), lb - Complex (Re lb) (Im ub):]", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p2 =\n    p \\<circ>\\<^sub>p\n    [:Complex (Re ub) (Im lb), ub - Complex (Re ub) (Im lb):]", "unfolding p2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p\n    [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):] =\n    p \\<circ>\\<^sub>p\n    [:Complex (Re ub) (Im lb), ub - Complex (Re ub) (Im lb):]", "by (subst (10) complex_surj[symmetric],auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb) (Im ub) - ub:]\n 2. p4 =\n    p \\<circ>\\<^sub>p\n    [:Complex (Re lb) (Im ub), lb - Complex (Re lb) (Im ub):]", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb) (Im ub) - ub:]", "unfolding p3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:] =\n    p \\<circ>\\<^sub>p [:ub, Complex (Re lb) (Im ub) - ub:]", "by (subst (10) complex_surj[symmetric],auto simp add:minus_complex.code)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p4 =\n    p \\<circ>\\<^sub>p\n    [:Complex (Re lb) (Im ub), lb - Complex (Re lb) (Im ub):]", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p4 =\n    p \\<circ>\\<^sub>p\n    [:Complex (Re lb) (Im ub), lb - Complex (Re lb) (Im ub):]", "unfolding p4_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p\n    [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):] =\n    p \\<circ>\\<^sub>p\n    [:Complex (Re lb) (Im ub), lb - Complex (Re lb) (Im ub):]", "by (subst (10) complex_surj[symmetric],auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  p1 = p \\<circ>\\<^sub>p [:lb, Complex (Re ub) (Im lb) - lb:]\n  p2 =\n  p \\<circ>\\<^sub>p\n  [:Complex (Re ub) (Im lb), ub - Complex (Re ub) (Im lb):]\n  p3 = p \\<circ>\\<^sub>p [:ub, Complex (Re lb) (Im ub) - ub:]\n  p4 =\n  p \\<circ>\\<^sub>p\n  [:Complex (Re lb) (Im ub), lb - Complex (Re lb) (Im ub):]\n\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if poly p lb \\<noteq> 0 \\<and>\n                  poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                  poly p ub \\<noteq> 0 \\<and>\n                  poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0 \\<and>\n                          changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \\<and>\n                          changes_itv_smods 0 1 gc3 (pderiv gc3) = 0 \\<and>\n                          changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                       then nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                     (pI1 div gc1) +\n                                    changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                     (pI2 div gc2) +\n                                    changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                     (pI3 div gc3) +\n                                    changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                     (pI4 div gc4)) div\n                                 4)\n                       else Code.abort\n                             STR ''proots_rectangle fails when there is a root on the border.''\n                             (\\<lambda>_. proots_rectangle p lb ub)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_rectangle p lb ub =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if poly p lb \\<noteq> 0 \\<and>\n                  poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                  poly p ub \\<noteq> 0 \\<and>\n                  poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0 \\<and>\n                          changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \\<and>\n                          changes_itv_smods 0 1 gc3 (pderiv gc3) = 0 \\<and>\n                          changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                       then nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                     (pI1 div gc1) +\n                                    changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                     (pI2 div gc2) +\n                                    changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                     (pI3 div gc3) +\n                                    changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                     (pI4 div gc4)) div\n                                 4)\n                       else Code.abort\n                             STR ''proots_rectangle fails when there is a root on the border.''\n                             (\\<lambda>_. proots_rectangle p lb ub)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "apply (subst proots_rectangle_code1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if no_proots_line p lb (Complex (Re ub) (Im lb)) \\<and>\n                  no_proots_line p (Complex (Re ub) (Im lb)) ub \\<and>\n                  no_proots_line p ub (Complex (Re lb) (Im ub)) \\<and>\n                  no_proots_line p (Complex (Re lb) (Im ub)) lb\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                (pI1 div gc1) +\n                               changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                (pI2 div gc2) +\n                               changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                (pI3 div gc3) +\n                               changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                (pI4 div gc4)) div\n                            4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0) =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if poly p lb \\<noteq> 0 \\<and>\n                  poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                  poly p ub \\<noteq> 0 \\<and>\n                  poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n               then let p1 = p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:];\n                        pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                        gc1 = gcd pR1 pI1;\n                        p2 = p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):];\n                        pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                        gc2 = gcd pR2 pI2;\n                        p3 = p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:];\n                        pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                        gc3 = gcd pR3 pI3;\n                        p4 = p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):];\n                        pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                        gc4 = gcd pR4 pI4\n                    in if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0 \\<and>\n                          changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \\<and>\n                          changes_itv_smods 0 1 gc3 (pderiv gc3) = 0 \\<and>\n                          changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                       then nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                     (pI1 div gc1) +\n                                    changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                     (pI2 div gc2) +\n                                    changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                     (pI3 div gc3) +\n                                    changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                     (pI4 div gc4)) div\n                                 4)\n                       else Code.abort\n                             STR ''proots_rectangle fails when there is a root on the border.''\n                             (\\<lambda>_. proots_rectangle p lb ub)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "apply (unfold no_proots_line_code Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if (if poly p lb \\<noteq> 0 \\<and>\n                      poly p (Complex (Re ub) (Im lb)) \\<noteq> 0\n                   then if changes_itv_smods 0 1\n                            (gcd (map_poly Re\n                                   (p \\<circ>\\<^sub>p\n                                    [:lb, Complex (Re ub) (Im lb) - lb:]))\n                              (map_poly Im\n                                (p \\<circ>\\<^sub>p\n                                 [:lb, Complex (Re ub) (Im lb) - lb:])))\n                            (pderiv\n                              (gcd (map_poly Re\n                                     (p \\<circ>\\<^sub>p\n[:lb, Complex (Re ub) (Im lb) - lb:]))\n                                (map_poly Im\n                                  (p \\<circ>\\<^sub>p\n                                   [:lb,\n                                     Complex (Re ub) (Im lb) - lb:])))) =\n                           0\n                        then True else False\n                   else False) \\<and>\n                  (if poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                      poly p ub \\<noteq> 0\n                   then if changes_itv_smods 0 1\n                            (gcd (map_poly Re\n                                   (p \\<circ>\\<^sub>p\n                                    [:Complex (Re ub) (Im lb),\nub - Complex (Re ub) (Im lb):]))\n                              (map_poly Im\n                                (p \\<circ>\\<^sub>p\n                                 [:Complex (Re ub) (Im lb),\n                                   ub - Complex (Re ub) (Im lb):])))\n                            (pderiv\n                              (gcd (map_poly Re\n                                     (p \\<circ>\\<^sub>p\n[:Complex (Re ub) (Im lb), ub - Complex (Re ub) (Im lb):]))\n                                (map_poly Im\n                                  (p \\<circ>\\<^sub>p\n                                   [:Complex (Re ub) (Im lb),\n                                     ub - Complex (Re ub) (Im lb):])))) =\n                           0\n                        then True else False\n                   else False) \\<and>\n                  (if poly p ub \\<noteq> 0 \\<and>\n                      poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n                   then if changes_itv_smods 0 1\n                            (gcd (map_poly Re\n                                   (p \\<circ>\\<^sub>p\n                                    [:ub, Complex (Re lb) (Im ub) - ub:]))\n                              (map_poly Im\n                                (p \\<circ>\\<^sub>p\n                                 [:ub, Complex (Re lb) (Im ub) - ub:])))\n                            (pderiv\n                              (gcd (map_poly Re\n                                     (p \\<circ>\\<^sub>p\n[:ub, Complex (Re lb) (Im ub) - ub:]))\n                                (map_poly Im\n                                  (p \\<circ>\\<^sub>p\n                                   [:ub,\n                                     Complex (Re lb) (Im ub) - ub:])))) =\n                           0\n                        then True else False\n                   else False) \\<and>\n                  (if poly p (Complex (Re lb) (Im ub)) \\<noteq> 0 \\<and>\n                      poly p lb \\<noteq> 0\n                   then if changes_itv_smods 0 1\n                            (gcd (map_poly Re\n                                   (p \\<circ>\\<^sub>p\n                                    [:Complex (Re lb) (Im ub),\nlb - Complex (Re lb) (Im ub):]))\n                              (map_poly Im\n                                (p \\<circ>\\<^sub>p\n                                 [:Complex (Re lb) (Im ub),\n                                   lb - Complex (Re lb) (Im ub):])))\n                            (pderiv\n                              (gcd (map_poly Re\n                                     (p \\<circ>\\<^sub>p\n[:Complex (Re lb) (Im ub), lb - Complex (Re lb) (Im ub):]))\n                                (map_poly Im\n                                  (p \\<circ>\\<^sub>p\n                                   [:Complex (Re lb) (Im ub),\n                                     lb - Complex (Re lb) (Im ub):])))) =\n                           0\n                        then True else False\n                   else False)\n               then nat (- (changes_alt_itv_smods 0 1\n                             (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:lb, Complex (Re ub - Re lb) 0:]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:lb, Complex (Re ub - Re lb) 0:]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:lb, Complex (Re ub - Re lb) 0:])))\n                             (map_poly Im\n                               (p \\<circ>\\<^sub>p\n                                [:lb, Complex (Re ub - Re lb) 0:]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:lb, Complex (Re ub - Re lb) 0:]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:lb, Complex (Re ub - Re lb) 0:]))) +\n                            changes_alt_itv_smods 0 1\n                             (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:Complex (Re ub) (Im lb),\n                                  Complex 0 (Im ub - Im lb):]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re ub) (Im lb),\n Complex 0 (Im ub - Im lb):]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:Complex (Re ub) (Im lb),\n                                    Complex 0 (Im ub - Im lb):])))\n                             (map_poly Im\n                               (p \\<circ>\\<^sub>p\n                                [:Complex (Re ub) (Im lb),\n                                  Complex 0 (Im ub - Im lb):]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re ub) (Im lb),\n Complex 0 (Im ub - Im lb):]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:Complex (Re ub) (Im lb),\n                                    Complex 0 (Im ub - Im lb):]))) +\n                            changes_alt_itv_smods 0 1\n                             (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:ub, Complex (Re lb - Re ub) 0:]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:ub, Complex (Re lb - Re ub) 0:]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:ub, Complex (Re lb - Re ub) 0:])))\n                             (map_poly Im\n                               (p \\<circ>\\<^sub>p\n                                [:ub, Complex (Re lb - Re ub) 0:]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:ub, Complex (Re lb - Re ub) 0:]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:ub, Complex (Re lb - Re ub) 0:]))) +\n                            changes_alt_itv_smods 0 1\n                             (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:Complex (Re lb) (Im ub),\n                                  Complex 0 (Im lb - Im ub):]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re lb) (Im ub),\n Complex 0 (Im lb - Im ub):]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:Complex (Re lb) (Im ub),\n                                    Complex 0 (Im lb - Im ub):])))\n                             (map_poly Im\n                               (p \\<circ>\\<^sub>p\n                                [:Complex (Re lb) (Im ub),\n                                  Complex 0 (Im lb - Im ub):]) div\n                              gcd (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re lb) (Im ub),\n Complex 0 (Im lb - Im ub):]))\n                               (map_poly Im\n                                 (p \\<circ>\\<^sub>p\n                                  [:Complex (Re lb) (Im ub),\n                                    Complex 0 (Im lb - Im ub):])))) div\n                         4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0) =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if poly p lb \\<noteq> 0 \\<and>\n                  poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                  poly p ub \\<noteq> 0 \\<and>\n                  poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n               then if changes_itv_smods 0 1\n                        (gcd (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:lb, Complex (Re ub - Re lb) 0:]))\n                          (map_poly Im\n                            (p \\<circ>\\<^sub>p\n                             [:lb, Complex (Re ub - Re lb) 0:])))\n                        (pderiv\n                          (gcd (map_poly Re\n                                 (p \\<circ>\\<^sub>p\n                                  [:lb, Complex (Re ub - Re lb) 0:]))\n                            (map_poly Im\n                              (p \\<circ>\\<^sub>p\n                               [:lb, Complex (Re ub - Re lb) 0:])))) =\n                       0 \\<and>\n                       changes_itv_smods 0 1\n                        (gcd (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:Complex (Re ub) (Im lb),\n                                  Complex 0 (Im ub - Im lb):]))\n                          (map_poly Im\n                            (p \\<circ>\\<^sub>p\n                             [:Complex (Re ub) (Im lb),\n                               Complex 0 (Im ub - Im lb):])))\n                        (pderiv\n                          (gcd (map_poly Re\n                                 (p \\<circ>\\<^sub>p\n                                  [:Complex (Re ub) (Im lb),\n                                    Complex 0 (Im ub - Im lb):]))\n                            (map_poly Im\n                              (p \\<circ>\\<^sub>p\n                               [:Complex (Re ub) (Im lb),\n                                 Complex 0 (Im ub - Im lb):])))) =\n                       0 \\<and>\n                       changes_itv_smods 0 1\n                        (gcd (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:ub, Complex (Re lb - Re ub) 0:]))\n                          (map_poly Im\n                            (p \\<circ>\\<^sub>p\n                             [:ub, Complex (Re lb - Re ub) 0:])))\n                        (pderiv\n                          (gcd (map_poly Re\n                                 (p \\<circ>\\<^sub>p\n                                  [:ub, Complex (Re lb - Re ub) 0:]))\n                            (map_poly Im\n                              (p \\<circ>\\<^sub>p\n                               [:ub, Complex (Re lb - Re ub) 0:])))) =\n                       0 \\<and>\n                       changes_itv_smods 0 1\n                        (gcd (map_poly Re\n                               (p \\<circ>\\<^sub>p\n                                [:Complex (Re lb) (Im ub),\n                                  Complex 0 (Im lb - Im ub):]))\n                          (map_poly Im\n                            (p \\<circ>\\<^sub>p\n                             [:Complex (Re lb) (Im ub),\n                               Complex 0 (Im lb - Im ub):])))\n                        (pderiv\n                          (gcd (map_poly Re\n                                 (p \\<circ>\\<^sub>p\n                                  [:Complex (Re lb) (Im ub),\n                                    Complex 0 (Im lb - Im ub):]))\n                            (map_poly Im\n                              (p \\<circ>\\<^sub>p\n                               [:Complex (Re lb) (Im ub),\n                                 Complex 0 (Im lb - Im ub):])))) =\n                       0\n                    then nat (- (changes_alt_itv_smods 0 1\n                                  (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:lb, Complex (Re ub - Re lb) 0:]) div\n                                   gcd (map_poly Re\n   (p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:]))\n                                    (map_poly Im\n(p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:])))\n                                  (map_poly Im\n                                    (p \\<circ>\\<^sub>p\n                                     [:lb, Complex (Re ub - Re lb) 0:]) div\n                                   gcd (map_poly Re\n   (p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:]))\n                                    (map_poly Im\n(p \\<circ>\\<^sub>p [:lb, Complex (Re ub - Re lb) 0:]))) +\n                                 changes_alt_itv_smods 0 1\n                                  (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re ub) (Im lb),\n Complex 0 (Im ub - Im lb):]) div\n                                   gcd (map_poly Re\n   (p \\<circ>\\<^sub>p\n    [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):]))\n                                    (map_poly Im\n(p \\<circ>\\<^sub>p [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):])))\n                                  (map_poly Im\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re ub) (Im lb),\n Complex 0 (Im ub - Im lb):]) div\n                                   gcd (map_poly Re\n   (p \\<circ>\\<^sub>p\n    [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):]))\n                                    (map_poly Im\n(p \\<circ>\\<^sub>p\n [:Complex (Re ub) (Im lb), Complex 0 (Im ub - Im lb):]))) +\n                                 changes_alt_itv_smods 0 1\n                                  (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:ub, Complex (Re lb - Re ub) 0:]) div\n                                   gcd (map_poly Re\n   (p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:]))\n                                    (map_poly Im\n(p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:])))\n                                  (map_poly Im\n                                    (p \\<circ>\\<^sub>p\n                                     [:ub, Complex (Re lb - Re ub) 0:]) div\n                                   gcd (map_poly Re\n   (p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:]))\n                                    (map_poly Im\n(p \\<circ>\\<^sub>p [:ub, Complex (Re lb - Re ub) 0:]))) +\n                                 changes_alt_itv_smods 0 1\n                                  (map_poly Re\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re lb) (Im ub),\n Complex 0 (Im lb - Im ub):]) div\n                                   gcd (map_poly Re\n   (p \\<circ>\\<^sub>p\n    [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):]))\n                                    (map_poly Im\n(p \\<circ>\\<^sub>p [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):])))\n                                  (map_poly Im\n                                    (p \\<circ>\\<^sub>p\n                                     [:Complex (Re lb) (Im ub),\n Complex 0 (Im lb - Im ub):]) div\n                                   gcd (map_poly Re\n   (p \\<circ>\\<^sub>p\n    [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):]))\n                                    (map_poly Im\n(p \\<circ>\\<^sub>p\n [:Complex (Re lb) (Im ub), Complex 0 (Im lb - Im ub):])))) div\n                              4)\n                    else Code.abort\n                          STR ''proots_rectangle fails when there is a root on the border.''\n                          (\\<lambda>_. proots_rectangle p lb ub)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "apply (fold p1_def p2_def p3_def p4_def pI1_def pR1_def pI2_def pR2_def pI3_def pR3_def\n          pI4_def pR4_def gc1_def gc2_def gc3_def gc4_def more_folds)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if (if poly p lb \\<noteq> 0 \\<and>\n                      poly p (Complex (Re ub) (Im lb)) \\<noteq> 0\n                   then if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0\n                        then True else False\n                   else False) \\<and>\n                  (if poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                      poly p ub \\<noteq> 0\n                   then if changes_itv_smods 0 1 gc2 (pderiv gc2) = 0\n                        then True else False\n                   else False) \\<and>\n                  (if poly p ub \\<noteq> 0 \\<and>\n                      poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n                   then if changes_itv_smods 0 1 gc3 (pderiv gc3) = 0\n                        then True else False\n                   else False) \\<and>\n                  (if poly p (Complex (Re lb) (Im ub)) \\<noteq> 0 \\<and>\n                      poly p lb \\<noteq> 0\n                   then if changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                        then True else False\n                   else False)\n               then nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                             (pI1 div gc1) +\n                            changes_alt_itv_smods 0 1 (pR2 div gc2)\n                             (pI2 div gc2) +\n                            changes_alt_itv_smods 0 1 (pR3 div gc3)\n                             (pI3 div gc3) +\n                            changes_alt_itv_smods 0 1 (pR4 div gc4)\n                             (pI4 div gc4)) div\n                         4)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0) =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if poly p lb \\<noteq> 0 \\<and>\n                  poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                  poly p ub \\<noteq> 0 \\<and>\n                  poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n               then if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0 \\<and>\n                       changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \\<and>\n                       changes_itv_smods 0 1 gc3 (pderiv gc3) = 0 \\<and>\n                       changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                    then nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                  (pI1 div gc1) +\n                                 changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                  (pI2 div gc2) +\n                                 changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                  (pI3 div gc3) +\n                                 changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                  (pI4 div gc4)) div\n                              4)\n                    else Code.abort\n                          STR ''proots_rectangle fails when there is a root on the border.''\n                          (\\<lambda>_. proots_rectangle p lb ub)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "apply (fold sms_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if (if poly p lb \\<noteq> 0 \\<and>\n                      poly p (Complex (Re ub) (Im lb)) \\<noteq> 0\n                   then if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0\n                        then True else False\n                   else False) \\<and>\n                  (if poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                      poly p ub \\<noteq> 0\n                   then if changes_itv_smods 0 1 gc2 (pderiv gc2) = 0\n                        then True else False\n                   else False) \\<and>\n                  (if poly p ub \\<noteq> 0 \\<and>\n                      poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n                   then if changes_itv_smods 0 1 gc3 (pderiv gc3) = 0\n                        then True else False\n                   else False) \\<and>\n                  (if poly p (Complex (Re lb) (Im ub)) \\<noteq> 0 \\<and>\n                      poly p lb \\<noteq> 0\n                   then if changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                        then True else False\n                   else False)\n               then nat sms\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0) =\n    (if Re lb < Re ub \\<and> Im lb < Im ub\n     then if p \\<noteq> 0\n          then if poly p lb \\<noteq> 0 \\<and>\n                  poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                  poly p ub \\<noteq> 0 \\<and>\n                  poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n               then if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0 \\<and>\n                       changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \\<and>\n                       changes_itv_smods 0 1 gc3 (pderiv gc3) = 0 \\<and>\n                       changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                    then nat sms\n                    else Code.abort\n                          STR ''proots_rectangle fails when there is a root on the border.''\n                          (\\<lambda>_. proots_rectangle p lb ub)\n               else Code.abort\n                     STR ''proots_rectangle fails when there is a root on the border.''\n                     (\\<lambda>_. proots_rectangle p lb ub)\n          else Code.abort STR ''proots_rectangle fails when p=0.''\n                (\\<lambda>_. proots_rectangle p lb ub)\n     else 0)", "by presburger"], ["proof (state)\nthis:\n  proots_rectangle p lb ub =\n  (if Re lb < Re ub \\<and> Im lb < Im ub\n   then if p \\<noteq> 0\n        then if poly p lb \\<noteq> 0 \\<and>\n                poly p (Complex (Re ub) (Im lb)) \\<noteq> 0 \\<and>\n                poly p ub \\<noteq> 0 \\<and>\n                poly p (Complex (Re lb) (Im ub)) \\<noteq> 0\n             then let p1 = p \\<circ>\\<^sub>p\n                           [:lb, Complex (Re ub - Re lb) 0:];\n                      pR1 = map_poly Re p1; pI1 = map_poly Im p1;\n                      gc1 = gcd pR1 pI1;\n                      p2 = p \\<circ>\\<^sub>p\n                           [:Complex (Re ub) (Im lb),\n                             Complex 0 (Im ub - Im lb):];\n                      pR2 = map_poly Re p2; pI2 = map_poly Im p2;\n                      gc2 = gcd pR2 pI2;\n                      p3 = p \\<circ>\\<^sub>p\n                           [:ub, Complex (Re lb - Re ub) 0:];\n                      pR3 = map_poly Re p3; pI3 = map_poly Im p3;\n                      gc3 = gcd pR3 pI3;\n                      p4 = p \\<circ>\\<^sub>p\n                           [:Complex (Re lb) (Im ub),\n                             Complex 0 (Im lb - Im ub):];\n                      pR4 = map_poly Re p4; pI4 = map_poly Im p4;\n                      gc4 = gcd pR4 pI4\n                  in if changes_itv_smods 0 1 gc1 (pderiv gc1) = 0 \\<and>\n                        changes_itv_smods 0 1 gc2 (pderiv gc2) = 0 \\<and>\n                        changes_itv_smods 0 1 gc3 (pderiv gc3) = 0 \\<and>\n                        changes_itv_smods 0 1 gc4 (pderiv gc4) = 0\n                     then nat (- (changes_alt_itv_smods 0 1 (pR1 div gc1)\n                                   (pI1 div gc1) +\n                                  changes_alt_itv_smods 0 1 (pR2 div gc2)\n                                   (pI2 div gc2) +\n                                  changes_alt_itv_smods 0 1 (pR3 div gc3)\n                                   (pI3 div gc3) +\n                                  changes_alt_itv_smods 0 1 (pR4 div gc4)\n                                   (pI4 div gc4)) div\n                               4)\n                     else Code.abort\n                           STR ''proots_rectangle fails when there is a root on the border.''\n                           (\\<lambda>_. proots_rectangle p lb ub)\n             else Code.abort\n                   STR ''proots_rectangle fails when there is a root on the border.''\n                   (\\<lambda>_. proots_rectangle p lb ub)\n        else Code.abort STR ''proots_rectangle fails when p=0.''\n              (\\<lambda>_. proots_rectangle p lb ub)\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Polynomial roots on the upper half-plane\\<close>\n\n\\<comment> \\<open>Roots counted WITH multiplicity\\<close>"], ["", "definition proots_upper ::\"complex poly \\<Rightarrow> nat\" where\n  \"proots_upper p= proots_count p {z. Im z>0}\"\n\n\\<comment> \\<open>Roots counted WITHOUT multiplicity\\<close>"], ["", "definition proots_upper_card::\"complex poly \\<Rightarrow> nat\" where \n  \"proots_upper_card p = card (proots_within p {x. Im x >0})\""], ["", "lemma Im_Ln_tendsto_at_top: \"((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi/2 ) at_top \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "proof (cases \"a=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "case False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "define f where \"f=(\\<lambda>x. if a>0 then arctan (x/a) else arctan (x/a) + pi)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. if 0 < a then arctan (x / a) else arctan (x / a) + pi)\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "define g where \"g=(\\<lambda>x. Im (Ln (Complex a x)))\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. Im (Ln (Complex a x)))\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "have \"(f \\<longlongrightarrow> pi / 2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> pi / 2) at_top", "proof (cases \"a>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "case True"], ["proof (state)\nthis:\n  0 < a\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "then"], ["proof (chain)\npicking this:\n  0 < a", "have \"(f \\<longlongrightarrow> pi / 2) at_top \\<longleftrightarrow> ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2) at_top\""], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> pi / 2) at_top =\n    ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2)\n     at_top", "unfolding f_def field_class.field_divide_inverse"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         if 0 < a then arctan (x * inverse a)\n         else arctan (x * inverse a) + pi) \\<longlongrightarrow>\n     pi * inverse 2)\n     at_top =\n    ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow>\n     pi * inverse 2)\n     at_top", "by auto"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> pi / 2) at_top =\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2) at_top\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "also"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> pi / 2) at_top =\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2) at_top\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "have \"... \\<longleftrightarrow> (arctan \\<longlongrightarrow> pi / 2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2)\n     at_top =\n    (arctan \\<longlongrightarrow> pi / 2) at_top", "apply (subst filterlim_at_top_linear_iff[of \"inverse a\" arctan 0 \"nhds (pi/2)\",simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<noteq> 0\n 2. (if 0 < a then (arctan \\<longlongrightarrow> pi / 2) at_top\n     else (arctan \\<longlongrightarrow> pi / 2) at_bot) =\n    (arctan \\<longlongrightarrow> pi / 2) at_top", "using True"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (2 subgoals):\n 1. a \\<noteq> 0\n 2. (if 0 < a then (arctan \\<longlongrightarrow> pi / 2) at_top\n     else (arctan \\<longlongrightarrow> pi / 2) at_bot) =\n    (arctan \\<longlongrightarrow> pi / 2) at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2)\n   at_top =\n  (arctan \\<longlongrightarrow> pi / 2) at_top\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2)\n   at_top =\n  (arctan \\<longlongrightarrow> pi / 2) at_top\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arctan \\<longlongrightarrow> pi / 2) at_top", "using tendsto_arctan_at_top"], ["proof (prove)\nusing this:\n  (arctan \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. (arctan \\<longlongrightarrow> pi / 2) at_top", "."], ["proof (state)\nthis:\n  (arctan \\<longlongrightarrow> pi / 2) at_top\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "finally"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> pi / 2) at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> pi / 2) at_top", "."], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < a", "have \"(f \\<longlongrightarrow> pi / 2) at_top \\<longleftrightarrow> ((\\<lambda>x. arctan (x * inverse a) + pi) \\<longlongrightarrow> pi / 2) at_top\""], ["proof (prove)\nusing this:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> pi / 2) at_top =\n    ((\\<lambda>x. arctan (x * inverse a) + pi) \\<longlongrightarrow> pi / 2)\n     at_top", "unfolding f_def field_class.field_divide_inverse"], ["proof (prove)\nusing this:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         if 0 < a then arctan (x * inverse a)\n         else arctan (x * inverse a) + pi) \\<longlongrightarrow>\n     pi * inverse 2)\n     at_top =\n    ((\\<lambda>x. arctan (x * inverse a) + pi) \\<longlongrightarrow>\n     pi * inverse 2)\n     at_top", "by auto"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> pi / 2) at_top =\n  ((\\<lambda>x. arctan (x * inverse a) + pi) \\<longlongrightarrow> pi / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "also"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> pi / 2) at_top =\n  ((\\<lambda>x. arctan (x * inverse a) + pi) \\<longlongrightarrow> pi / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "have \"... \\<longleftrightarrow> ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. arctan (x * inverse a) + pi) \\<longlongrightarrow> pi / 2)\n     at_top =\n    ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n     at_top", "apply (subst tendsto_add_const_iff[of \"-pi\",symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         - pi + (arctan (x * inverse a) + pi)) \\<longlongrightarrow>\n     - pi + pi / 2)\n     at_top =\n    ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n     at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a) + pi) \\<longlongrightarrow> pi / 2)\n   at_top =\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a) + pi) \\<longlongrightarrow> pi / 2)\n   at_top =\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "have \"... \\<longleftrightarrow> (arctan \\<longlongrightarrow> - pi / 2) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n     at_top =\n    (arctan \\<longlongrightarrow> - pi / 2) at_bot", "apply (subst filterlim_at_top_linear_iff[of \"inverse a\" arctan 0,simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<noteq> 0\n 2. (if 0 < a then (arctan \\<longlongrightarrow> - pi / 2) at_top\n     else (arctan \\<longlongrightarrow> - pi / 2) at_bot) =\n    (arctan \\<longlongrightarrow> - pi / 2) at_bot", "using False \\<open>a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 0 < a\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a \\<noteq> 0\n 2. (if 0 < a then (arctan \\<longlongrightarrow> - pi / 2) at_top\n     else (arctan \\<longlongrightarrow> - pi / 2) at_bot) =\n    (arctan \\<longlongrightarrow> - pi / 2) at_bot", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n   at_top =\n  (arctan \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n   at_top =\n  (arctan \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arctan \\<longlongrightarrow> - pi / 2) at_bot", "using tendsto_arctan_at_bot"], ["proof (prove)\nusing this:\n  (arctan \\<longlongrightarrow> - (pi / 2)) at_bot\n\ngoal (1 subgoal):\n 1. (arctan \\<longlongrightarrow> - pi / 2) at_bot", "by simp"], ["proof (state)\nthis:\n  (arctan \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> pi / 2) at_top", "finally"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> pi / 2) at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> pi / 2) at_top", "."], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> pi / 2) at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> pi / 2) at_top\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "moreover"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> pi / 2) at_top\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "have \"\\<forall>\\<^sub>F x in at_top. f x = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. f x = g x", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       (if 0 < a then arctan (x / a) else arctan (x / a) + pi) =\n       Im (Ln (Complex a x))", "using \\<open>a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       (if 0 < a then arctan (x / a) else arctan (x / a) + pi) =\n       Im (Ln (Complex a x))", "apply (subst Im_Ln_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. a \\<noteq> 0 \\<Longrightarrow> Complex a x \\<noteq> 0\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top.\n       (if 0 < a then arctan (x / a) else arctan (x / a) + pi) =\n       (if Re (Complex a x) \\<noteq> 0\n        then if 0 < Re (Complex a x)\n             then arctan (Im (Complex a x) / Re (Complex a x))\n             else if 0 \\<le> Im (Complex a x)\n                  then arctan (Im (Complex a x) / Re (Complex a x)) + pi\n                  else arctan (Im (Complex a x) / Re (Complex a x)) - pi\n        else if 0 < Im (Complex a x) then pi / 2 else - pi / 2)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> Complex a x \\<noteq> 0", "using Complex_eq_0"], ["proof (prove)\nusing this:\n  (Complex ?a ?b = 0) = (?a = 0 \\<and> ?b = 0)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> Complex a x \\<noteq> 0", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top.\n       (if 0 < a then arctan (x / a) else arctan (x / a) + pi) =\n       (if Re (Complex a x) \\<noteq> 0\n        then if 0 < Re (Complex a x)\n             then arctan (Im (Complex a x) / Re (Complex a x))\n             else if 0 \\<le> Im (Complex a x)\n                  then arctan (Im (Complex a x) / Re (Complex a x)) + pi\n                  else arctan (Im (Complex a x) / Re (Complex a x)) - pi\n        else if 0 < Im (Complex a x) then pi / 2 else - pi / 2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_top.\n       (if 0 < a then arctan (x / a) else arctan (x / a) + pi) =\n       (if Re (Complex a x) \\<noteq> 0\n        then if 0 < Re (Complex a x)\n             then arctan (Im (Complex a x) / Re (Complex a x))\n             else if 0 \\<le> Im (Complex a x)\n                  then arctan (Im (Complex a x) / Re (Complex a x)) + pi\n                  else arctan (Im (Complex a x) / Re (Complex a x)) - pi\n        else if 0 < Im (Complex a x) then pi / 2 else - pi / 2)", "unfolding eventually_at_top_linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>N.\n       \\<forall>n\\<ge>N.\n          (if 0 < a then arctan (n / a) else arctan (n / a) + pi) =\n          (if Re (Complex a n) \\<noteq> 0\n           then if 0 < Re (Complex a n)\n                then arctan (Im (Complex a n) / Re (Complex a n))\n                else if 0 \\<le> Im (Complex a n)\n                     then arctan (Im (Complex a n) / Re (Complex a n)) + pi\n                     else arctan (Im (Complex a n) / Re (Complex a n)) - pi\n           else if 0 < Im (Complex a n) then pi / 2 else - pi / 2)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. f x = g x\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> pi / 2) at_top\n  \\<forall>\\<^sub>F x in at_top. f x = g x", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> pi / 2) at_top\n  \\<forall>\\<^sub>F x in at_top. f x = g x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "using tendsto_cong[of f g at_top]"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> pi / 2) at_top\n  \\<forall>\\<^sub>F x in at_top. f x = g x\n  \\<forall>\\<^sub>F x in at_top. f x = g x \\<Longrightarrow>\n  (f \\<longlongrightarrow> ?c) at_top = (g \\<longlongrightarrow> ?c) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "unfolding g_def"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> pi / 2) at_top\n  \\<forall>\\<^sub>F x in at_top. f x = Im (Ln (Complex a x))\n  \\<forall>\\<^sub>F x in at_top.\n     f x = Im (Ln (Complex a x)) \\<Longrightarrow>\n  (f \\<longlongrightarrow> ?c) at_top =\n  ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> ?c) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "case True"], ["proof (state)\nthis:\n  a = 0\n\ngoal (1 subgoal):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2)\n     at_top", "apply (rule tendsto_eventually)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. Im (Ln (Complex a x)) = pi / 2", "apply (rule eventually_at_top_linorderI[of 1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 1 \\<le> x \\<Longrightarrow> Im (Ln (Complex a x)) = pi / 2", "using True"], ["proof (prove)\nusing this:\n  a = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. 1 \\<le> x \\<Longrightarrow> Im (Ln (Complex a x)) = pi / 2", "by (subst Im_Ln_eq,auto simp add:Complex_eq_0)"], ["proof (state)\nthis:\n  ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> pi / 2) at_top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Im_Ln_tendsto_at_bot: \"((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi/2 ) at_bot \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "proof (cases \"a=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "case False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "define f where \"f=(\\<lambda>x. if a>0 then arctan (x/a) else arctan (x/a) - pi)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. if 0 < a then arctan (x / a) else arctan (x / a) - pi)\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "define g where \"g=(\\<lambda>x. Im (Ln (Complex a x)))\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. Im (Ln (Complex a x)))\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "have \"(f \\<longlongrightarrow> - pi / 2) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> - pi / 2) at_bot", "proof (cases \"a>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "case True"], ["proof (state)\nthis:\n  0 < a\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "then"], ["proof (chain)\npicking this:\n  0 < a", "have \"(f \\<longlongrightarrow> - pi / 2) at_bot \\<longleftrightarrow> ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2) at_bot\""], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> - pi / 2) at_bot =\n    ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n     at_bot", "unfolding f_def field_class.field_divide_inverse"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         if 0 < a then arctan (x * inverse a)\n         else arctan (x * inverse a) - pi) \\<longlongrightarrow>\n     - pi * inverse 2)\n     at_bot =\n    ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow>\n     - pi * inverse 2)\n     at_bot", "by auto"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> - pi / 2) at_bot =\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n   at_bot\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "also"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> - pi / 2) at_bot =\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n   at_bot\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "have \"... \\<longleftrightarrow> (arctan \\<longlongrightarrow> - pi / 2) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n     at_bot =\n    (arctan \\<longlongrightarrow> - pi / 2) at_bot", "apply (subst filterlim_at_bot_linear_iff[of \"inverse a\" arctan 0,simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<noteq> 0\n 2. (if 0 < a then (arctan \\<longlongrightarrow> - pi / 2) at_bot\n     else (arctan \\<longlongrightarrow> - pi / 2) at_top) =\n    (arctan \\<longlongrightarrow> - pi / 2) at_bot", "using True"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (2 subgoals):\n 1. a \\<noteq> 0\n 2. (if 0 < a then (arctan \\<longlongrightarrow> - pi / 2) at_bot\n     else (arctan \\<longlongrightarrow> - pi / 2) at_top) =\n    (arctan \\<longlongrightarrow> - pi / 2) at_bot", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n   at_bot =\n  (arctan \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> - pi / 2)\n   at_bot =\n  (arctan \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arctan \\<longlongrightarrow> - pi / 2) at_bot", "using tendsto_arctan_at_bot"], ["proof (prove)\nusing this:\n  (arctan \\<longlongrightarrow> - (pi / 2)) at_bot\n\ngoal (1 subgoal):\n 1. (arctan \\<longlongrightarrow> - pi / 2) at_bot", "by simp"], ["proof (state)\nthis:\n  (arctan \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot\n 2. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "finally"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> - pi / 2) at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> - pi / 2) at_bot", "."], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < a", "have \"(f \\<longlongrightarrow> - pi / 2) at_bot \\<longleftrightarrow> ((\\<lambda>x. arctan (x * inverse a) - pi) \\<longlongrightarrow> - pi / 2) at_bot\""], ["proof (prove)\nusing this:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> - pi / 2) at_bot =\n    ((\\<lambda>x. arctan (x * inverse a) - pi) \\<longlongrightarrow>\n     - pi / 2)\n     at_bot", "unfolding f_def field_class.field_divide_inverse"], ["proof (prove)\nusing this:\n  \\<not> 0 < a\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         if 0 < a then arctan (x * inverse a)\n         else arctan (x * inverse a) - pi) \\<longlongrightarrow>\n     - pi * inverse 2)\n     at_bot =\n    ((\\<lambda>x. arctan (x * inverse a) - pi) \\<longlongrightarrow>\n     - pi * inverse 2)\n     at_bot", "by auto"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> - pi / 2) at_bot =\n  ((\\<lambda>x. arctan (x * inverse a) - pi) \\<longlongrightarrow> - pi / 2)\n   at_bot\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "also"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> - pi / 2) at_bot =\n  ((\\<lambda>x. arctan (x * inverse a) - pi) \\<longlongrightarrow> - pi / 2)\n   at_bot\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "have \"... \\<longleftrightarrow> ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. arctan (x * inverse a) - pi) \\<longlongrightarrow>\n     - pi / 2)\n     at_bot =\n    ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2)\n     at_bot", "apply (subst tendsto_add_const_iff[of \"pi\",symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. pi + (arctan (x * inverse a) - pi)) \\<longlongrightarrow>\n     pi + - pi / 2)\n     at_bot =\n    ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2)\n     at_bot", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a) - pi) \\<longlongrightarrow> - pi / 2)\n   at_bot =\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2) at_bot\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a) - pi) \\<longlongrightarrow> - pi / 2)\n   at_bot =\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2) at_bot\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "have \"... \\<longleftrightarrow> (arctan \\<longlongrightarrow> pi / 2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2)\n     at_bot =\n    (arctan \\<longlongrightarrow> pi / 2) at_top", "apply (subst filterlim_at_bot_linear_iff[of \"inverse a\" arctan 0,simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<noteq> 0\n 2. (if 0 < a then (arctan \\<longlongrightarrow> pi / 2) at_bot\n     else (arctan \\<longlongrightarrow> pi / 2) at_top) =\n    (arctan \\<longlongrightarrow> pi / 2) at_top", "using False \\<open>a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 0 < a\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a \\<noteq> 0\n 2. (if 0 < a then (arctan \\<longlongrightarrow> pi / 2) at_bot\n     else (arctan \\<longlongrightarrow> pi / 2) at_top) =\n    (arctan \\<longlongrightarrow> pi / 2) at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2)\n   at_bot =\n  (arctan \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. arctan (x * inverse a)) \\<longlongrightarrow> pi / 2)\n   at_bot =\n  (arctan \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arctan \\<longlongrightarrow> pi / 2) at_top", "using tendsto_arctan_at_top"], ["proof (prove)\nusing this:\n  (arctan \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. (arctan \\<longlongrightarrow> pi / 2) at_top", "by simp"], ["proof (state)\nthis:\n  (arctan \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. \\<not> 0 < a \\<Longrightarrow> (f \\<longlongrightarrow> - pi / 2) at_bot", "finally"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> - pi / 2) at_bot", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> - pi / 2) at_bot", "."], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "moreover"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> - pi / 2) at_bot\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "have \"\\<forall>\\<^sub>F x in at_bot. f x = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot. f x = g x", "unfolding f_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot.\n       (if 0 < a then arctan (x / a) else arctan (x / a) - pi) =\n       Im (Ln (Complex a x))", "using \\<open>a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot.\n       (if 0 < a then arctan (x / a) else arctan (x / a) - pi) =\n       Im (Ln (Complex a x))", "apply (subst Im_Ln_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. a \\<noteq> 0 \\<Longrightarrow> Complex a x \\<noteq> 0\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_bot.\n       (if 0 < a then arctan (x / a) else arctan (x / a) - pi) =\n       (if Re (Complex a x) \\<noteq> 0\n        then if 0 < Re (Complex a x)\n             then arctan (Im (Complex a x) / Re (Complex a x))\n             else if 0 \\<le> Im (Complex a x)\n                  then arctan (Im (Complex a x) / Re (Complex a x)) + pi\n                  else arctan (Im (Complex a x) / Re (Complex a x)) - pi\n        else if 0 < Im (Complex a x) then pi / 2 else - pi / 2)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> Complex a x \\<noteq> 0", "using Complex_eq_0"], ["proof (prove)\nusing this:\n  (Complex ?a ?b = 0) = (?a = 0 \\<and> ?b = 0)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> Complex a x \\<noteq> 0", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_bot.\n       (if 0 < a then arctan (x / a) else arctan (x / a) - pi) =\n       (if Re (Complex a x) \\<noteq> 0\n        then if 0 < Re (Complex a x)\n             then arctan (Im (Complex a x) / Re (Complex a x))\n             else if 0 \\<le> Im (Complex a x)\n                  then arctan (Im (Complex a x) / Re (Complex a x)) + pi\n                  else arctan (Im (Complex a x) / Re (Complex a x)) - pi\n        else if 0 < Im (Complex a x) then pi / 2 else - pi / 2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in at_bot.\n       (if 0 < a then arctan (x / a) else arctan (x / a) - pi) =\n       (if Re (Complex a x) \\<noteq> 0\n        then if 0 < Re (Complex a x)\n             then arctan (Im (Complex a x) / Re (Complex a x))\n             else if 0 \\<le> Im (Complex a x)\n                  then arctan (Im (Complex a x) / Re (Complex a x)) + pi\n                  else arctan (Im (Complex a x) / Re (Complex a x)) - pi\n        else if 0 < Im (Complex a x) then pi / 2 else - pi / 2)", "unfolding eventually_at_bot_linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>N.\n       \\<forall>n\\<le>N.\n          (if 0 < a then arctan (n / a) else arctan (n / a) - pi) =\n          (if Re (Complex a n) \\<noteq> 0\n           then if 0 < Re (Complex a n)\n                then arctan (Im (Complex a n) / Re (Complex a n))\n                else if 0 \\<le> Im (Complex a n)\n                     then arctan (Im (Complex a n) / Re (Complex a n)) + pi\n                     else arctan (Im (Complex a n) / Re (Complex a n)) - pi\n           else if 0 < Im (Complex a n) then pi / 2 else - pi / 2)", "by (auto intro:exI[where x=\"-1\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_bot. f x = g x\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "ultimately"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> - pi / 2) at_bot\n  \\<forall>\\<^sub>F x in at_bot. f x = g x", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> - pi / 2) at_bot\n  \\<forall>\\<^sub>F x in at_bot. f x = g x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "using tendsto_cong[of f g at_bot]"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> - pi / 2) at_bot\n  \\<forall>\\<^sub>F x in at_bot. f x = g x\n  \\<forall>\\<^sub>F x in at_bot. f x = g x \\<Longrightarrow>\n  (f \\<longlongrightarrow> ?c) at_bot = (g \\<longlongrightarrow> ?c) at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "unfolding g_def"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> - pi / 2) at_bot\n  \\<forall>\\<^sub>F x in at_bot. f x = Im (Ln (Complex a x))\n  \\<forall>\\<^sub>F x in at_bot.\n     f x = Im (Ln (Complex a x)) \\<Longrightarrow>\n  (f \\<longlongrightarrow> ?c) at_bot =\n  ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> ?c) at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n   at_bot\n\ngoal (1 subgoal):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "case True"], ["proof (state)\nthis:\n  a = 0\n\ngoal (1 subgoal):\n 1. a = 0 \\<Longrightarrow>\n    ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n     at_bot", "apply (rule tendsto_eventually)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_bot. Im (Ln (Complex a x)) = - pi / 2", "apply (rule eventually_at_bot_linorderI[of \"-1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<le> - 1 \\<Longrightarrow> Im (Ln (Complex a x)) = - pi / 2", "using True"], ["proof (prove)\nusing this:\n  a = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<le> - 1 \\<Longrightarrow> Im (Ln (Complex a x)) = - pi / 2", "by (subst Im_Ln_eq,auto simp add:Complex_eq_0)"], ["proof (state)\nthis:\n  ((\\<lambda>x. Im (Ln (Complex a x))) \\<longlongrightarrow> - pi / 2)\n   at_bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Re_winding_number_tendsto_part_circlepath:\n  shows \"((\\<lambda>r. Re (winding_number (part_circlepath z0 r 0 pi ) a)) \\<longlongrightarrow> 1/2 ) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "proof (cases \"Im z0\\<le>Im a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top\n 2. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "case True"], ["proof (state)\nthis:\n  Im z0 \\<le> Im a\n\ngoal (2 subgoals):\n 1. Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top\n 2. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "define g1 where \"g1=(\\<lambda>r. part_circlepath z0 r 0 pi)\""], ["proof (state)\nthis:\n  g1 = (\\<lambda>r. part_circlepath z0 r 0 pi)\n\ngoal (2 subgoals):\n 1. Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top\n 2. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "define g2 where \"g2=(\\<lambda>r. part_circlepath z0 r pi (2*pi))\""], ["proof (state)\nthis:\n  g2 = (\\<lambda>r. part_circlepath z0 r pi (2 * pi))\n\ngoal (2 subgoals):\n 1. Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top\n 2. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "define f1 where \"f1=(\\<lambda>r. Re (winding_number (g1 r ) a))\""], ["proof (state)\nthis:\n  f1 = (\\<lambda>r. Re (winding_number (g1 r) a))\n\ngoal (2 subgoals):\n 1. Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top\n 2. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "define f2 where \"f2=(\\<lambda>r. Re (winding_number (g2 r) a))\""], ["proof (state)\nthis:\n  f2 = (\\<lambda>r. Re (winding_number (g2 r) a))\n\ngoal (2 subgoals):\n 1. Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top\n 2. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "have \"(f2 \\<longlongrightarrow> 1/2 ) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f2 \\<longlongrightarrow> 1 / 2) at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f2 \\<longlongrightarrow> 1 / 2) at_top", "define h1 where \"h1 = (\\<lambda>r. Im (Ln (Complex ( Im a-Im z0) (Re z0 - Re a + r))))\""], ["proof (state)\nthis:\n  h1 = (\\<lambda>r. Im (Ln (Complex (Im a - Im z0) (Re z0 - Re a + r))))\n\ngoal (1 subgoal):\n 1. (f2 \\<longlongrightarrow> 1 / 2) at_top", "define h2 where \"h2= (\\<lambda>r. Im (Ln (Complex (  Im a -Im z0) (Re z0 - Re a - r))))\""], ["proof (state)\nthis:\n  h2 = (\\<lambda>r. Im (Ln (Complex (Im a - Im z0) (Re z0 - Re a - r))))\n\ngoal (1 subgoal):\n 1. (f2 \\<longlongrightarrow> 1 / 2) at_top", "have \"\\<forall>\\<^sub>F x in at_top. f2 x = (h1 x - h2 x) / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. f2 x = (h1 x - h2 x) / (2 * pi)", "proof (rule eventually_at_top_linorderI[of \"cmod (a-z0) + 1\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "assume asm:\"r \\<ge> cmod (a - z0) + 1\""], ["proof (state)\nthis:\n  cmod (a - z0) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "have \"Im p \\<le> Im a\" when \"p\\<in>path_image (g2 r)\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im p \\<le> Im a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im p \\<le> Im a", "obtain t where p_def:\"p=z0 + of_real r * exp (\\<i> * of_real t)\" and \"pi\\<le>t\" \"t\\<le>2*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>p =\n                 z0 + complex_of_real r * exp (\\<i> * complex_of_real t);\n         pi \\<le> t; t \\<le> 2 * pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>p\\<in>path_image (g2 r)\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> path_image (g2 r)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>p =\n                 z0 + complex_of_real r * exp (\\<i> * complex_of_real t);\n         pi \\<le> t; t \\<le> 2 * pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding g2_def path_image_part_circlepath[of pi \"2*pi\",simplified]"], ["proof (prove)\nusing this:\n  p \\<in> {z0 + complex_of_real r * exp (\\<i> * complex_of_real x) |x.\n           pi \\<le> x \\<and> x \\<le> 2 * pi}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>p =\n                 z0 + complex_of_real r * exp (\\<i> * complex_of_real t);\n         pi \\<le> t; t \\<le> 2 * pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = z0 + complex_of_real r * exp (\\<i> * complex_of_real t)\n  pi \\<le> t\n  t \\<le> 2 * pi\n\ngoal (1 subgoal):\n 1. Im p \\<le> Im a", "then"], ["proof (chain)\npicking this:\n  p = z0 + complex_of_real r * exp (\\<i> * complex_of_real t)\n  pi \\<le> t\n  t \\<le> 2 * pi", "have \"Im p=Im z0 + sin t * r\""], ["proof (prove)\nusing this:\n  p = z0 + complex_of_real r * exp (\\<i> * complex_of_real t)\n  pi \\<le> t\n  t \\<le> 2 * pi\n\ngoal (1 subgoal):\n 1. Im p = Im z0 + sin t * r", "by (auto simp add:Im_exp)"], ["proof (state)\nthis:\n  Im p = Im z0 + sin t * r\n\ngoal (1 subgoal):\n 1. Im p \\<le> Im a", "also"], ["proof (state)\nthis:\n  Im p = Im z0 + sin t * r\n\ngoal (1 subgoal):\n 1. Im p \\<le> Im a", "have \"... \\<le> Im z0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im z0 + sin t * r \\<le> Im z0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im z0 + sin t * r \\<le> Im z0", "have \"sin t\\<le>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sin t \\<le> 0", "using \\<open>pi\\<le>t\\<close> \\<open>t\\<le>2*pi\\<close> sin_le_zero"], ["proof (prove)\nusing this:\n  pi \\<le> t\n  t \\<le> 2 * pi\n  \\<lbrakk>pi \\<le> ?x; ?x < 2 * pi\\<rbrakk>\n  \\<Longrightarrow> sin ?x \\<le> 0\n\ngoal (1 subgoal):\n 1. sin t \\<le> 0", "by fastforce"], ["proof (state)\nthis:\n  sin t \\<le> 0\n\ngoal (1 subgoal):\n 1. Im z0 + sin t * r \\<le> Im z0", "moreover"], ["proof (state)\nthis:\n  sin t \\<le> 0\n\ngoal (1 subgoal):\n 1. Im z0 + sin t * r \\<le> Im z0", "have \"r\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> r", "using asm"], ["proof (prove)\nusing this:\n  cmod (a - z0) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. 0 \\<le> r", "by (metis add.inverse_inverse add.left_neutral add_uminus_conv_diff\n                diff_ge_0_iff_ge norm_ge_zero order_trans zero_le_one)"], ["proof (state)\nthis:\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. Im z0 + sin t * r \\<le> Im z0", "ultimately"], ["proof (chain)\npicking this:\n  sin t \\<le> 0\n  0 \\<le> r", "have \"sin t * r\\<le>0\""], ["proof (prove)\nusing this:\n  sin t \\<le> 0\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. sin t * r \\<le> 0", "using mult_le_0_iff"], ["proof (prove)\nusing this:\n  sin t \\<le> 0\n  0 \\<le> r\n  (?a * ?b \\<le> (0::?'a)) =\n  ((0::?'a) \\<le> ?a \\<and> ?b \\<le> (0::?'a) \\<or>\n   ?a \\<le> (0::?'a) \\<and> (0::?'a) \\<le> ?b)\n\ngoal (1 subgoal):\n 1. sin t * r \\<le> 0", "by blast"], ["proof (state)\nthis:\n  sin t * r \\<le> 0\n\ngoal (1 subgoal):\n 1. Im z0 + sin t * r \\<le> Im z0", "then"], ["proof (chain)\npicking this:\n  sin t * r \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  sin t * r \\<le> 0\n\ngoal (1 subgoal):\n 1. Im z0 + sin t * r \\<le> Im z0", "by auto"], ["proof (state)\nthis:\n  Im z0 + sin t * r \\<le> Im z0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im z0 + sin t * r \\<le> Im z0\n\ngoal (1 subgoal):\n 1. Im p \\<le> Im a", "also"], ["proof (state)\nthis:\n  Im z0 + sin t * r \\<le> Im z0\n\ngoal (1 subgoal):\n 1. Im p \\<le> Im a", "have \"... \\<le> Im a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im z0 \\<le> Im a", "using True"], ["proof (prove)\nusing this:\n  Im z0 \\<le> Im a\n\ngoal (1 subgoal):\n 1. Im z0 \\<le> Im a", "."], ["proof (state)\nthis:\n  Im z0 \\<le> Im a\n\ngoal (1 subgoal):\n 1. Im p \\<le> Im a", "finally"], ["proof (chain)\npicking this:\n  Im p \\<le> Im a", "show ?thesis"], ["proof (prove)\nusing this:\n  Im p \\<le> Im a\n\ngoal (1 subgoal):\n 1. Im p \\<le> Im a", "."], ["proof (state)\nthis:\n  Im p \\<le> Im a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?p \\<in> path_image (g2 r) \\<Longrightarrow> Im ?p \\<le> Im a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "moreover"], ["proof (state)\nthis:\n  ?p \\<in> path_image (g2 r) \\<Longrightarrow> Im ?p \\<le> Im a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "have \"valid_path (g2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (g2 r)", "unfolding g2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (part_circlepath z0 r pi (2 * pi))", "by auto"], ["proof (state)\nthis:\n  valid_path (g2 r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "moreover"], ["proof (state)\nthis:\n  valid_path (g2 r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "have \"a \\<notin> path_image (g2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> path_image (g2 r)", "unfolding g2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> path_image (part_circlepath z0 r pi (2 * pi))", "apply (rule not_on_circlepathI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (a - z0) \\<noteq> \\<bar>r\\<bar>", "using asm"], ["proof (prove)\nusing this:\n  cmod (a - z0) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. cmod (a - z0) \\<noteq> \\<bar>r\\<bar>", "by auto"], ["proof (state)\nthis:\n  a \\<notin> path_image (g2 r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "moreover"], ["proof (state)\nthis:\n  a \\<notin> path_image (g2 r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "have [symmetric]:\"Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a)) = h1 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a)) = h1 r", "unfolding h1_def g2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * pathfinish (part_circlepath z0 r pi (2 * pi)) -\n            \\<i> * a)) =\n    Im (Ln (Complex (Im a - Im z0) (Re z0 - Re a + r)))", "apply (simp only:pathfinish_pathstart_partcirclepath_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * (z0 + complex_of_real r) - \\<i> * a)) =\n    Im (Ln (Complex (Im a - Im z0) (Re z0 - Re a + r)))", "apply (subst (4 10) complex_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> *\n            (complex_of_real (Re z0) + \\<i> * complex_of_real (Im z0) +\n             complex_of_real r) -\n            \\<i> *\n            (complex_of_real (Re a) + \\<i> * complex_of_real (Im a)))) =\n    Im (Ln (Complex (Im a - Im z0) (Re z0 - Re a + r)))", "by (auto simp add:algebra_simps Complex_eq)"], ["proof (state)\nthis:\n  h1 r = Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "moreover"], ["proof (state)\nthis:\n  h1 r = Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "have [symmetric]:\"Im (Ln (\\<i> * pathstart (g2 r) - \\<i> * a)) = h2 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * pathstart (g2 r) - \\<i> * a)) = h2 r", "unfolding h2_def g2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * pathstart (part_circlepath z0 r pi (2 * pi)) -\n            \\<i> * a)) =\n    Im (Ln (Complex (Im a - Im z0) (Re z0 - Re a - r)))", "apply (simp only:pathfinish_pathstart_partcirclepath_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * (z0 - complex_of_real r) - \\<i> * a)) =\n    Im (Ln (Complex (Im a - Im z0) (Re z0 - Re a - r)))", "apply (subst (4 10) complex_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> *\n            (complex_of_real (Re z0) + \\<i> * complex_of_real (Im z0) -\n             complex_of_real r) -\n            \\<i> *\n            (complex_of_real (Re a) + \\<i> * complex_of_real (Im a)))) =\n    Im (Ln (Complex (Im a - Im z0) (Re z0 - Re a - r)))", "by (auto simp add:algebra_simps Complex_eq)"], ["proof (state)\nthis:\n  h2 r = Im (Ln (\\<i> * pathstart (g2 r) - \\<i> * a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f2 x = (h1 x - h2 x) / (2 * pi)", "ultimately"], ["proof (chain)\npicking this:\n  ?p \\<in> path_image (g2 r) \\<Longrightarrow> Im ?p \\<le> Im a\n  valid_path (g2 r)\n  a \\<notin> path_image (g2 r)\n  h1 r = Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a))\n  h2 r = Im (Ln (\\<i> * pathstart (g2 r) - \\<i> * a))", "show \"f2 r = (h1 r - h2 r) / (2 * pi)\""], ["proof (prove)\nusing this:\n  ?p \\<in> path_image (g2 r) \\<Longrightarrow> Im ?p \\<le> Im a\n  valid_path (g2 r)\n  a \\<notin> path_image (g2 r)\n  h1 r = Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a))\n  h2 r = Im (Ln (\\<i> * pathstart (g2 r) - \\<i> * a))\n\ngoal (1 subgoal):\n 1. f2 r = (h1 r - h2 r) / (2 * pi)", "unfolding f2_def"], ["proof (prove)\nusing this:\n  ?p \\<in> path_image (g2 r) \\<Longrightarrow> Im ?p \\<le> Im a\n  valid_path (g2 r)\n  a \\<notin> path_image (g2 r)\n  h1 r = Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a))\n  h2 r = Im (Ln (\\<i> * pathstart (g2 r) - \\<i> * a))\n\ngoal (1 subgoal):\n 1. Re (winding_number (g2 r) a) = (h1 r - h2 r) / (2 * pi)", "apply (subst Re_winding_number_half_lower)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                p \\<in> path_image (g2 r) \\<Longrightarrow> Im p \\<le> Im a;\n     valid_path (g2 r); a \\<notin> path_image (g2 r);\n     h1 r = Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a));\n     h2 r = Im (Ln (\\<i> * pathstart (g2 r) - \\<i> * a))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>path_image (g2 r). Im p \\<le> Im a\n 2. \\<lbrakk>\\<And>p.\n                p \\<in> path_image (g2 r) \\<Longrightarrow> Im p \\<le> Im a;\n     valid_path (g2 r); a \\<notin> path_image (g2 r);\n     h1 r = Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a));\n     h2 r = Im (Ln (\\<i> * pathstart (g2 r) - \\<i> * a))\\<rbrakk>\n    \\<Longrightarrow> valid_path (g2 r)\n 3. \\<lbrakk>\\<And>p.\n                p \\<in> path_image (g2 r) \\<Longrightarrow> Im p \\<le> Im a;\n     valid_path (g2 r); a \\<notin> path_image (g2 r);\n     h1 r = Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a));\n     h2 r = Im (Ln (\\<i> * pathstart (g2 r) - \\<i> * a))\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> path_image (g2 r)\n 4. \\<lbrakk>\\<And>p.\n                p \\<in> path_image (g2 r) \\<Longrightarrow> Im p \\<le> Im a;\n     valid_path (g2 r); a \\<notin> path_image (g2 r);\n     h1 r = Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a));\n     h2 r = Im (Ln (\\<i> * pathstart (g2 r) - \\<i> * a))\\<rbrakk>\n    \\<Longrightarrow> (Im (Ln (\\<i> * pathfinish (g2 r) - \\<i> * a)) -\n                       Im (Ln (\\<i> * pathstart (g2 r) - \\<i> * a))) /\n                      (2 * pi) =\n                      (h1 r - h2 r) / (2 * pi)", "by (auto simp add:exp_Euler algebra_simps)"], ["proof (state)\nthis:\n  f2 r = (h1 r - h2 r) / (2 * pi)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. f2 x = (h1 x - h2 x) / (2 * pi)\n\ngoal (1 subgoal):\n 1. (f2 \\<longlongrightarrow> 1 / 2) at_top", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. f2 x = (h1 x - h2 x) / (2 * pi)\n\ngoal (1 subgoal):\n 1. (f2 \\<longlongrightarrow> 1 / 2) at_top", "have \"((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1/2 ) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "have \"(h1 \\<longlongrightarrow> pi/2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h1 \\<longlongrightarrow> pi / 2) at_top", "unfolding h1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Im (Ln (Complex (Im a - Im z0)\n                  (Re z0 - Re a + r)))) \\<longlongrightarrow>\n     pi / 2)\n     at_top", "apply (subst filterlim_at_top_linear_iff[of 1 _ \"Re a - Re z0\" ,simplified,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         Im (Ln (Complex (Im a - Im z0)\n                  (Re z0 - Re a +\n                   (x + (Re a - Re z0)))))) \\<longlongrightarrow>\n     pi / 2)\n     at_top", "using Im_Ln_tendsto_at_top"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. Im (Ln (Complex ?a x))) \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         Im (Ln (Complex (Im a - Im z0)\n                  (Re z0 - Re a +\n                   (x + (Re a - Re z0)))))) \\<longlongrightarrow>\n     pi / 2)\n     at_top", "by (simp del:Complex_eq)"], ["proof (state)\nthis:\n  (h1 \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "moreover"], ["proof (state)\nthis:\n  (h1 \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "have \"(h2 \\<longlongrightarrow> - pi/2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h2 \\<longlongrightarrow> - pi / 2) at_top", "unfolding h2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Im (Ln (Complex (Im a - Im z0)\n                  (Re z0 - Re a - r)))) \\<longlongrightarrow>\n     - pi / 2)\n     at_top", "apply (subst filterlim_at_bot_linear_iff[of \"- 1\" _ \"- Re a + Re z0\" ,simplified,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         Im (Ln (Complex (Im a - Im z0)\n                  (Re z0 - Re a -\n                   (Re z0 - Re a - x))))) \\<longlongrightarrow>\n     - pi / 2)\n     at_bot", "using Im_Ln_tendsto_at_bot"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. Im (Ln (Complex ?a x))) \\<longlongrightarrow> - pi / 2)\n   at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         Im (Ln (Complex (Im a - Im z0)\n                  (Re z0 - Re a -\n                   (Re z0 - Re a - x))))) \\<longlongrightarrow>\n     - pi / 2)\n     at_bot", "by (simp del:Complex_eq)"], ["proof (state)\nthis:\n  (h2 \\<longlongrightarrow> - pi / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  (h1 \\<longlongrightarrow> pi / 2) at_top\n  (h2 \\<longlongrightarrow> - pi / 2) at_top", "have \"((\\<lambda>x. h1 x- h2 x) \\<longlongrightarrow> pi) at_top\""], ["proof (prove)\nusing this:\n  (h1 \\<longlongrightarrow> pi / 2) at_top\n  (h2 \\<longlongrightarrow> - pi / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. h1 x - h2 x) \\<longlongrightarrow> pi) at_top", "by (auto intro: tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. h1 x - h2 x) \\<longlongrightarrow> pi) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. h1 x - h2 x) \\<longlongrightarrow> pi) at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. h1 x - h2 x) \\<longlongrightarrow> pi) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "by (auto intro: tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. (f2 \\<longlongrightarrow> 1 / 2) at_top", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top. f2 x = (h1 x - h2 x) / (2 * pi)\n  ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n   at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. f2 x = (h1 x - h2 x) / (2 * pi)\n  ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. (f2 \\<longlongrightarrow> 1 / 2) at_top", "by (auto dest:tendsto_cong)"], ["proof (state)\nthis:\n  (f2 \\<longlongrightarrow> 1 / 2) at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f2 \\<longlongrightarrow> 1 / 2) at_top\n\ngoal (2 subgoals):\n 1. Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top\n 2. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "moreover"], ["proof (state)\nthis:\n  (f2 \\<longlongrightarrow> 1 / 2) at_top\n\ngoal (2 subgoals):\n 1. Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top\n 2. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "have \"\\<forall>\\<^sub>F r in at_top. f2 r = 1 - f1 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top. f2 r = 1 - f1 r", "proof (rule eventually_at_top_linorderI[of \"cmod (a-z0) + 1\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. cmod (a - z0) + 1 \\<le> x \\<Longrightarrow> f2 x = 1 - f1 x", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. cmod (a - z0) + 1 \\<le> x \\<Longrightarrow> f2 x = 1 - f1 x", "assume asm:\"r \\<ge> cmod (a - z0) + 1\""], ["proof (state)\nthis:\n  cmod (a - z0) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x. cmod (a - z0) + 1 \\<le> x \\<Longrightarrow> f2 x = 1 - f1 x", "have \"f1 r + f2 r = Re(winding_number (g1 r +++ g2 r) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f1 r + f2 r = Re (winding_number (g1 r +++ g2 r) a)", "unfolding f1_def f2_def g1_def g2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number (part_circlepath z0 r 0 pi) a) +\n    Re (winding_number (part_circlepath z0 r pi (2 * pi)) a) =\n    Re (winding_number\n         (part_circlepath z0 r 0 pi +++ part_circlepath z0 r pi (2 * pi)) a)", "apply (subst winding_number_join)"], ["proof (prove)\ngoal (6 subgoals):\n 1. path (part_circlepath z0 r 0 pi)\n 2. a \\<notin> path_image (part_circlepath z0 r 0 pi)\n 3. path (part_circlepath z0 r pi (2 * pi))\n 4. a \\<notin> path_image (part_circlepath z0 r pi (2 * pi))\n 5. pathfinish (part_circlepath z0 r 0 pi) =\n    pathstart (part_circlepath z0 r pi (2 * pi))\n 6. Re (winding_number (part_circlepath z0 r 0 pi) a) +\n    Re (winding_number (part_circlepath z0 r pi (2 * pi)) a) =\n    Re (winding_number (part_circlepath z0 r 0 pi) a +\n        winding_number (part_circlepath z0 r pi (2 * pi)) a)", "using asm"], ["proof (prove)\nusing this:\n  cmod (a - z0) + 1 \\<le> r\n\ngoal (6 subgoals):\n 1. path (part_circlepath z0 r 0 pi)\n 2. a \\<notin> path_image (part_circlepath z0 r 0 pi)\n 3. path (part_circlepath z0 r pi (2 * pi))\n 4. a \\<notin> path_image (part_circlepath z0 r pi (2 * pi))\n 5. pathfinish (part_circlepath z0 r 0 pi) =\n    pathstart (part_circlepath z0 r pi (2 * pi))\n 6. Re (winding_number (part_circlepath z0 r 0 pi) a) +\n    Re (winding_number (part_circlepath z0 r pi (2 * pi)) a) =\n    Re (winding_number (part_circlepath z0 r 0 pi) a +\n        winding_number (part_circlepath z0 r pi (2 * pi)) a)", "by (auto intro!:not_on_circlepathI)"], ["proof (state)\nthis:\n  f1 r + f2 r = Re (winding_number (g1 r +++ g2 r) a)\n\ngoal (1 subgoal):\n 1. \\<And>x. cmod (a - z0) + 1 \\<le> x \\<Longrightarrow> f2 x = 1 - f1 x", "also"], ["proof (state)\nthis:\n  f1 r + f2 r = Re (winding_number (g1 r +++ g2 r) a)\n\ngoal (1 subgoal):\n 1. \\<And>x. cmod (a - z0) + 1 \\<le> x \\<Longrightarrow> f2 x = 1 - f1 x", "have \"... = Re(winding_number (circlepath z0 r) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number (g1 r +++ g2 r) a) =\n    Re (winding_number (circlepath z0 r) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (winding_number (g1 r +++ g2 r) a) =\n    Re (winding_number (circlepath z0 r) a)", "have \"g1 r +++ g2 r = circlepath z0 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g1 r +++ g2 r = circlepath z0 r", "unfolding circlepath_def g1_def g2_def joinpaths_def part_circlepath_def linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if x \\<le> 1 / 2\n        then z0 +\n             complex_of_real r *\n             exp (\\<i> *\n                  complex_of_real\n                   ((1 - 2 * x) *\\<^sub>R 0 + (2 * x) *\\<^sub>R pi))\n        else z0 +\n             complex_of_real r *\n             exp (\\<i> *\n                  complex_of_real\n                   ((1 - (2 * x - 1)) *\\<^sub>R pi +\n                    (2 * x - 1) *\\<^sub>R (2 * pi)))) =\n    (\\<lambda>x.\n        z0 +\n        complex_of_real r *\n        exp (\\<i> *\n             complex_of_real ((1 - x) *\\<^sub>R 0 + x *\\<^sub>R (2 * pi))))", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  g1 r +++ g2 r = circlepath z0 r\n\ngoal (1 subgoal):\n 1. Re (winding_number (g1 r +++ g2 r) a) =\n    Re (winding_number (circlepath z0 r) a)", "then"], ["proof (chain)\npicking this:\n  g1 r +++ g2 r = circlepath z0 r", "show ?thesis"], ["proof (prove)\nusing this:\n  g1 r +++ g2 r = circlepath z0 r\n\ngoal (1 subgoal):\n 1. Re (winding_number (g1 r +++ g2 r) a) =\n    Re (winding_number (circlepath z0 r) a)", "by auto"], ["proof (state)\nthis:\n  Re (winding_number (g1 r +++ g2 r) a) =\n  Re (winding_number (circlepath z0 r) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (winding_number (g1 r +++ g2 r) a) =\n  Re (winding_number (circlepath z0 r) a)\n\ngoal (1 subgoal):\n 1. \\<And>x. cmod (a - z0) + 1 \\<le> x \\<Longrightarrow> f2 x = 1 - f1 x", "also"], ["proof (state)\nthis:\n  Re (winding_number (g1 r +++ g2 r) a) =\n  Re (winding_number (circlepath z0 r) a)\n\ngoal (1 subgoal):\n 1. \\<And>x. cmod (a - z0) + 1 \\<le> x \\<Longrightarrow> f2 x = 1 - f1 x", "have \"... = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number (circlepath z0 r) a) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Re (winding_number (circlepath z0 r) a) = 1", "have \"winding_number (circlepath z0 r) a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (circlepath z0 r) a = 1", "apply (rule winding_number_circlepath)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (a - z0) < r", "using asm"], ["proof (prove)\nusing this:\n  cmod (a - z0) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. cmod (a - z0) < r", "by auto"], ["proof (state)\nthis:\n  winding_number (circlepath z0 r) a = 1\n\ngoal (1 subgoal):\n 1. Re (winding_number (circlepath z0 r) a) = 1", "then"], ["proof (chain)\npicking this:\n  winding_number (circlepath z0 r) a = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  winding_number (circlepath z0 r) a = 1\n\ngoal (1 subgoal):\n 1. Re (winding_number (circlepath z0 r) a) = 1", "by auto"], ["proof (state)\nthis:\n  Re (winding_number (circlepath z0 r) a) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (winding_number (circlepath z0 r) a) = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. cmod (a - z0) + 1 \\<le> x \\<Longrightarrow> f2 x = 1 - f1 x", "finally"], ["proof (chain)\npicking this:\n  f1 r + f2 r = 1", "have \"f1 r+f2 r=1\""], ["proof (prove)\nusing this:\n  f1 r + f2 r = 1\n\ngoal (1 subgoal):\n 1. f1 r + f2 r = 1", "."], ["proof (state)\nthis:\n  f1 r + f2 r = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. cmod (a - z0) + 1 \\<le> x \\<Longrightarrow> f2 x = 1 - f1 x", "then"], ["proof (chain)\npicking this:\n  f1 r + f2 r = 1", "show \" f2 r = 1 - f1 r\""], ["proof (prove)\nusing this:\n  f1 r + f2 r = 1\n\ngoal (1 subgoal):\n 1. f2 r = 1 - f1 r", "by auto"], ["proof (state)\nthis:\n  f2 r = 1 - f1 r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top. f2 r = 1 - f1 r\n\ngoal (2 subgoals):\n 1. Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top\n 2. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  (f2 \\<longlongrightarrow> 1 / 2) at_top\n  \\<forall>\\<^sub>F r in at_top. f2 r = 1 - f1 r", "have \"((\\<lambda>r. 1 - f1 r) \\<longlongrightarrow> 1/2 ) at_top\""], ["proof (prove)\nusing this:\n  (f2 \\<longlongrightarrow> 1 / 2) at_top\n  \\<forall>\\<^sub>F r in at_top. f2 r = 1 - f1 r\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. 1 - f1 r) \\<longlongrightarrow> 1 / 2) at_top", "using tendsto_cong[of f2 \"\\<lambda>r. 1 - f1 r\" at_top]"], ["proof (prove)\nusing this:\n  (f2 \\<longlongrightarrow> 1 / 2) at_top\n  \\<forall>\\<^sub>F r in at_top. f2 r = 1 - f1 r\n  \\<forall>\\<^sub>F x in at_top. f2 x = 1 - f1 x \\<Longrightarrow>\n  (f2 \\<longlongrightarrow> ?c) at_top =\n  ((\\<lambda>r. 1 - f1 r) \\<longlongrightarrow> ?c) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. 1 - f1 r) \\<longlongrightarrow> 1 / 2) at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>r. 1 - f1 r) \\<longlongrightarrow> 1 / 2) at_top\n\ngoal (2 subgoals):\n 1. Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top\n 2. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>r. 1 - f1 r) \\<longlongrightarrow> 1 / 2) at_top", "have \"(f1 \\<longlongrightarrow> 1/2 ) at_top\""], ["proof (prove)\nusing this:\n  ((\\<lambda>r. 1 - f1 r) \\<longlongrightarrow> 1 / 2) at_top\n\ngoal (1 subgoal):\n 1. (f1 \\<longlongrightarrow> 1 / 2) at_top", "apply (rule_tac tendsto_minus_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r. 1 - f1 r) \\<longlongrightarrow> 1 / 2)\n     at_top \\<Longrightarrow>\n    ((\\<lambda>x. - f1 x) \\<longlongrightarrow> - (1 / 2)) at_top", "apply (subst tendsto_add_const_iff[of 1,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r. 1 - f1 r) \\<longlongrightarrow> 1 / 2)\n     at_top \\<Longrightarrow>\n    ((\\<lambda>x. 1 + - f1 x) \\<longlongrightarrow> 1 + - (1 / 2)) at_top", "by auto"], ["proof (state)\nthis:\n  (f1 \\<longlongrightarrow> 1 / 2) at_top\n\ngoal (2 subgoals):\n 1. Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top\n 2. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "then"], ["proof (chain)\npicking this:\n  (f1 \\<longlongrightarrow> 1 / 2) at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  (f1 \\<longlongrightarrow> 1 / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "unfolding f1_def g1_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       Re (winding_number (part_circlepath z0 r 0 pi)\n            a)) \\<longlongrightarrow>\n   1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       Re (winding_number (part_circlepath z0 r 0 pi)\n            a)) \\<longlongrightarrow>\n   1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "case False"], ["proof (state)\nthis:\n  \\<not> Im z0 \\<le> Im a\n\ngoal (1 subgoal):\n 1. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "define g where \"g=(\\<lambda>r. part_circlepath z0 r 0 pi)\""], ["proof (state)\nthis:\n  g = (\\<lambda>r. part_circlepath z0 r 0 pi)\n\ngoal (1 subgoal):\n 1. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "define f where \"f=(\\<lambda>r. Re (winding_number (g r) a))\""], ["proof (state)\nthis:\n  f = (\\<lambda>r. Re (winding_number (g r) a))\n\ngoal (1 subgoal):\n 1. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "have \"(f \\<longlongrightarrow> 1/2 ) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> 1 / 2) at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> 1 / 2) at_top", "define h1 where \"h1 = (\\<lambda>r. Im (Ln (Complex ( Im z0-Im a) (Re a - Re z0 + r))))\""], ["proof (state)\nthis:\n  h1 = (\\<lambda>r. Im (Ln (Complex (Im z0 - Im a) (Re a - Re z0 + r))))\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> 1 / 2) at_top", "define h2 where \"h2= (\\<lambda>r. Im (Ln (Complex (  Im z0 -Im a ) (Re a - Re z0 - r))))\""], ["proof (state)\nthis:\n  h2 = (\\<lambda>r. Im (Ln (Complex (Im z0 - Im a) (Re a - Re z0 - r))))\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> 1 / 2) at_top", "have \"\\<forall>\\<^sub>F x in at_top. f x = (h1 x - h2 x) / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. f x = (h1 x - h2 x) / (2 * pi)", "proof (rule eventually_at_top_linorderI[of \"cmod (a-z0) + 1\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "assume asm:\"r \\<ge> cmod (a - z0) + 1\""], ["proof (state)\nthis:\n  cmod (a - z0) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "have \"Im p \\<ge> Im a\" when \"p\\<in>path_image (g r)\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im a \\<le> Im p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im a \\<le> Im p", "obtain t where p_def:\"p=z0 + of_real r * exp (\\<i> * of_real t)\" and \"0\\<le>t\" \"t\\<le>pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>p =\n                 z0 + complex_of_real r * exp (\\<i> * complex_of_real t);\n         0 \\<le> t; t \\<le> pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>p\\<in>path_image (g r)\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> path_image (g r)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>p =\n                 z0 + complex_of_real r * exp (\\<i> * complex_of_real t);\n         0 \\<le> t; t \\<le> pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding g_def path_image_part_circlepath[of 0 pi,simplified]"], ["proof (prove)\nusing this:\n  p \\<in> {z0 + complex_of_real r * exp (\\<i> * complex_of_real x) |x.\n           0 \\<le> x \\<and> x \\<le> pi}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>p =\n                 z0 + complex_of_real r * exp (\\<i> * complex_of_real t);\n         0 \\<le> t; t \\<le> pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = z0 + complex_of_real r * exp (\\<i> * complex_of_real t)\n  0 \\<le> t\n  t \\<le> pi\n\ngoal (1 subgoal):\n 1. Im a \\<le> Im p", "then"], ["proof (chain)\npicking this:\n  p = z0 + complex_of_real r * exp (\\<i> * complex_of_real t)\n  0 \\<le> t\n  t \\<le> pi", "have \"Im p=Im z0 + sin t * r\""], ["proof (prove)\nusing this:\n  p = z0 + complex_of_real r * exp (\\<i> * complex_of_real t)\n  0 \\<le> t\n  t \\<le> pi\n\ngoal (1 subgoal):\n 1. Im p = Im z0 + sin t * r", "by (auto simp add:Im_exp)"], ["proof (state)\nthis:\n  Im p = Im z0 + sin t * r\n\ngoal (1 subgoal):\n 1. Im a \\<le> Im p", "moreover"], ["proof (state)\nthis:\n  Im p = Im z0 + sin t * r\n\ngoal (1 subgoal):\n 1. Im a \\<le> Im p", "have \"sin t * r\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sin t * r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> sin t * r", "have \"sin t\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sin t", "using \\<open>0\\<le>t\\<close> \\<open>t\\<le>pi\\<close> sin_ge_zero"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  t \\<le> pi\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> pi\\<rbrakk> \\<Longrightarrow> 0 \\<le> sin ?x\n\ngoal (1 subgoal):\n 1. 0 \\<le> sin t", "by fastforce"], ["proof (state)\nthis:\n  0 \\<le> sin t\n\ngoal (1 subgoal):\n 1. 0 \\<le> sin t * r", "moreover"], ["proof (state)\nthis:\n  0 \\<le> sin t\n\ngoal (1 subgoal):\n 1. 0 \\<le> sin t * r", "have \"r\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> r", "using asm"], ["proof (prove)\nusing this:\n  cmod (a - z0) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. 0 \\<le> r", "by (metis add.inverse_inverse add.left_neutral add_uminus_conv_diff\n                diff_ge_0_iff_ge norm_ge_zero order_trans zero_le_one)"], ["proof (state)\nthis:\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. 0 \\<le> sin t * r", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> sin t\n  0 \\<le> r", "have \"sin t * r\\<ge>0\""], ["proof (prove)\nusing this:\n  0 \\<le> sin t\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. 0 \\<le> sin t * r", "by simp"], ["proof (state)\nthis:\n  0 \\<le> sin t * r\n\ngoal (1 subgoal):\n 1. 0 \\<le> sin t * r", "then"], ["proof (chain)\npicking this:\n  0 \\<le> sin t * r", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> sin t * r\n\ngoal (1 subgoal):\n 1. 0 \\<le> sin t * r", "by auto"], ["proof (state)\nthis:\n  0 \\<le> sin t * r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> sin t * r\n\ngoal (1 subgoal):\n 1. Im a \\<le> Im p", "ultimately"], ["proof (chain)\npicking this:\n  Im p = Im z0 + sin t * r\n  0 \\<le> sin t * r", "show ?thesis"], ["proof (prove)\nusing this:\n  Im p = Im z0 + sin t * r\n  0 \\<le> sin t * r\n\ngoal (1 subgoal):\n 1. Im a \\<le> Im p", "using False"], ["proof (prove)\nusing this:\n  Im p = Im z0 + sin t * r\n  0 \\<le> sin t * r\n  \\<not> Im z0 \\<le> Im a\n\ngoal (1 subgoal):\n 1. Im a \\<le> Im p", "by auto"], ["proof (state)\nthis:\n  Im a \\<le> Im p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?p \\<in> path_image (g r) \\<Longrightarrow> Im a \\<le> Im ?p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "moreover"], ["proof (state)\nthis:\n  ?p \\<in> path_image (g r) \\<Longrightarrow> Im a \\<le> Im ?p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "have \"valid_path (g r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (g r)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (part_circlepath z0 r 0 pi)", "by auto"], ["proof (state)\nthis:\n  valid_path (g r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "moreover"], ["proof (state)\nthis:\n  valid_path (g r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "have \"a \\<notin> path_image (g r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> path_image (g r)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> path_image (part_circlepath z0 r 0 pi)", "apply (rule not_on_circlepathI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (a - z0) \\<noteq> \\<bar>r\\<bar>", "using asm"], ["proof (prove)\nusing this:\n  cmod (a - z0) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. cmod (a - z0) \\<noteq> \\<bar>r\\<bar>", "by auto"], ["proof (state)\nthis:\n  a \\<notin> path_image (g r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "moreover"], ["proof (state)\nthis:\n  a \\<notin> path_image (g r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "have [symmetric]:\"Im (Ln (\\<i> * a - \\<i> * pathfinish (g r))) = h1 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * a - \\<i> * pathfinish (g r))) = h1 r", "unfolding h1_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * a - \\<i> * pathfinish (part_circlepath z0 r 0 pi))) =\n    Im (Ln (Complex (Im z0 - Im a) (Re a - Re z0 + r)))", "apply (simp only:pathfinish_pathstart_partcirclepath_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * a - \\<i> * (z0 - complex_of_real r))) =\n    Im (Ln (Complex (Im z0 - Im a) (Re a - Re z0 + r)))", "apply (subst (4 9) complex_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> *\n            (complex_of_real (Re a) + \\<i> * complex_of_real (Im a)) -\n            \\<i> *\n            (complex_of_real (Re (z0 - complex_of_real r)) +\n             \\<i> * complex_of_real (Im (z0 - complex_of_real r))))) =\n    Im (Ln (Complex (Im z0 - Im a) (Re a - Re z0 + r)))", "by (auto simp add:algebra_simps Complex_eq)"], ["proof (state)\nthis:\n  h1 r = Im (Ln (\\<i> * a - \\<i> * pathfinish (g r)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "moreover"], ["proof (state)\nthis:\n  h1 r = Im (Ln (\\<i> * a - \\<i> * pathfinish (g r)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "have [symmetric]:\"Im (Ln (\\<i> * a - \\<i> * pathstart (g r))) = h2 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * a - \\<i> * pathstart (g r))) = h2 r", "unfolding h2_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * a - \\<i> * pathstart (part_circlepath z0 r 0 pi))) =\n    Im (Ln (Complex (Im z0 - Im a) (Re a - Re z0 - r)))", "apply (simp only:pathfinish_pathstart_partcirclepath_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> * a - \\<i> * (z0 + complex_of_real r))) =\n    Im (Ln (Complex (Im z0 - Im a) (Re a - Re z0 - r)))", "apply (subst (4 9) complex_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (\\<i> *\n            (complex_of_real (Re a) + \\<i> * complex_of_real (Im a)) -\n            \\<i> *\n            (complex_of_real (Re (z0 + complex_of_real r)) +\n             \\<i> * complex_of_real (Im (z0 + complex_of_real r))))) =\n    Im (Ln (Complex (Im z0 - Im a) (Re a - Re z0 - r)))", "by (auto simp add:algebra_simps Complex_eq)"], ["proof (state)\nthis:\n  h2 r = Im (Ln (\\<i> * a - \\<i> * pathstart (g r)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (a - z0) + 1 \\<le> x \\<Longrightarrow>\n       f x = (h1 x - h2 x) / (2 * pi)", "ultimately"], ["proof (chain)\npicking this:\n  ?p \\<in> path_image (g r) \\<Longrightarrow> Im a \\<le> Im ?p\n  valid_path (g r)\n  a \\<notin> path_image (g r)\n  h1 r = Im (Ln (\\<i> * a - \\<i> * pathfinish (g r)))\n  h2 r = Im (Ln (\\<i> * a - \\<i> * pathstart (g r)))", "show \"f r = (h1 r - h2 r) / (2 * pi)\""], ["proof (prove)\nusing this:\n  ?p \\<in> path_image (g r) \\<Longrightarrow> Im a \\<le> Im ?p\n  valid_path (g r)\n  a \\<notin> path_image (g r)\n  h1 r = Im (Ln (\\<i> * a - \\<i> * pathfinish (g r)))\n  h2 r = Im (Ln (\\<i> * a - \\<i> * pathstart (g r)))\n\ngoal (1 subgoal):\n 1. f r = (h1 r - h2 r) / (2 * pi)", "unfolding f_def"], ["proof (prove)\nusing this:\n  ?p \\<in> path_image (g r) \\<Longrightarrow> Im a \\<le> Im ?p\n  valid_path (g r)\n  a \\<notin> path_image (g r)\n  h1 r = Im (Ln (\\<i> * a - \\<i> * pathfinish (g r)))\n  h2 r = Im (Ln (\\<i> * a - \\<i> * pathstart (g r)))\n\ngoal (1 subgoal):\n 1. Re (winding_number (g r) a) = (h1 r - h2 r) / (2 * pi)", "apply (subst Re_winding_number_half_upper)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                p \\<in> path_image (g r) \\<Longrightarrow> Im a \\<le> Im p;\n     valid_path (g r); a \\<notin> path_image (g r);\n     h1 r = Im (Ln (\\<i> * a - \\<i> * pathfinish (g r)));\n     h2 r = Im (Ln (\\<i> * a - \\<i> * pathstart (g r)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p\\<in>path_image (g r). Im a \\<le> Im p\n 2. \\<lbrakk>\\<And>p.\n                p \\<in> path_image (g r) \\<Longrightarrow> Im a \\<le> Im p;\n     valid_path (g r); a \\<notin> path_image (g r);\n     h1 r = Im (Ln (\\<i> * a - \\<i> * pathfinish (g r)));\n     h2 r = Im (Ln (\\<i> * a - \\<i> * pathstart (g r)))\\<rbrakk>\n    \\<Longrightarrow> valid_path (g r)\n 3. \\<lbrakk>\\<And>p.\n                p \\<in> path_image (g r) \\<Longrightarrow> Im a \\<le> Im p;\n     valid_path (g r); a \\<notin> path_image (g r);\n     h1 r = Im (Ln (\\<i> * a - \\<i> * pathfinish (g r)));\n     h2 r = Im (Ln (\\<i> * a - \\<i> * pathstart (g r)))\\<rbrakk>\n    \\<Longrightarrow> a \\<notin> path_image (g r)\n 4. \\<lbrakk>\\<And>p.\n                p \\<in> path_image (g r) \\<Longrightarrow> Im a \\<le> Im p;\n     valid_path (g r); a \\<notin> path_image (g r);\n     h1 r = Im (Ln (\\<i> * a - \\<i> * pathfinish (g r)));\n     h2 r = Im (Ln (\\<i> * a - \\<i> * pathstart (g r)))\\<rbrakk>\n    \\<Longrightarrow> (Im (Ln (\\<i> * a - \\<i> * pathfinish (g r))) -\n                       Im (Ln (\\<i> * a - \\<i> * pathstart (g r)))) /\n                      (2 * pi) =\n                      (h1 r - h2 r) / (2 * pi)", "by (auto simp add:exp_Euler algebra_simps)"], ["proof (state)\nthis:\n  f r = (h1 r - h2 r) / (2 * pi)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. f x = (h1 x - h2 x) / (2 * pi)\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> 1 / 2) at_top", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top. f x = (h1 x - h2 x) / (2 * pi)\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> 1 / 2) at_top", "have \"((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1/2 ) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "have \"(h1 \\<longlongrightarrow> pi/2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h1 \\<longlongrightarrow> pi / 2) at_top", "unfolding h1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Im (Ln (Complex (Im z0 - Im a)\n                  (Re a - Re z0 + r)))) \\<longlongrightarrow>\n     pi / 2)\n     at_top", "apply (subst filterlim_at_top_linear_iff[of 1 _ \"- Re a + Re z0\" ,simplified,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         Im (Ln (Complex (Im z0 - Im a)\n                  (Re a - Re z0 +\n                   (x + (Re z0 - Re a)))))) \\<longlongrightarrow>\n     pi / 2)\n     at_top", "using Im_Ln_tendsto_at_top"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. Im (Ln (Complex ?a x))) \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         Im (Ln (Complex (Im z0 - Im a)\n                  (Re a - Re z0 +\n                   (x + (Re z0 - Re a)))))) \\<longlongrightarrow>\n     pi / 2)\n     at_top", "by (simp del:Complex_eq)"], ["proof (state)\nthis:\n  (h1 \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "moreover"], ["proof (state)\nthis:\n  (h1 \\<longlongrightarrow> pi / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "have \"(h2 \\<longlongrightarrow> - pi/2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h2 \\<longlongrightarrow> - pi / 2) at_top", "unfolding h2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Im (Ln (Complex (Im z0 - Im a)\n                  (Re a - Re z0 - r)))) \\<longlongrightarrow>\n     - pi / 2)\n     at_top", "apply (subst filterlim_at_bot_linear_iff[of \"- 1\" _ \"Re a - Re z0\" ,simplified,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         Im (Ln (Complex (Im z0 - Im a)\n                  (Re a - Re z0 -\n                   (Re a - Re z0 - x))))) \\<longlongrightarrow>\n     - pi / 2)\n     at_bot", "using Im_Ln_tendsto_at_bot"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. Im (Ln (Complex ?a x))) \\<longlongrightarrow> - pi / 2)\n   at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         Im (Ln (Complex (Im z0 - Im a)\n                  (Re a - Re z0 -\n                   (Re a - Re z0 - x))))) \\<longlongrightarrow>\n     - pi / 2)\n     at_bot", "by (simp del:Complex_eq)"], ["proof (state)\nthis:\n  (h2 \\<longlongrightarrow> - pi / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  (h1 \\<longlongrightarrow> pi / 2) at_top\n  (h2 \\<longlongrightarrow> - pi / 2) at_top", "have \"((\\<lambda>x. h1 x- h2 x) \\<longlongrightarrow> pi) at_top\""], ["proof (prove)\nusing this:\n  (h1 \\<longlongrightarrow> pi / 2) at_top\n  (h2 \\<longlongrightarrow> - pi / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. h1 x - h2 x) \\<longlongrightarrow> pi) at_top", "by (auto intro: tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. h1 x - h2 x) \\<longlongrightarrow> pi) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. h1 x - h2 x) \\<longlongrightarrow> pi) at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. h1 x - h2 x) \\<longlongrightarrow> pi) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n     at_top", "by (auto intro: tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> 1 / 2) at_top", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top. f x = (h1 x - h2 x) / (2 * pi)\n  ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n   at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top. f x = (h1 x - h2 x) / (2 * pi)\n  ((\\<lambda>x. (h1 x - h2 x) / (2 * pi)) \\<longlongrightarrow> 1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> 1 / 2) at_top", "by (auto dest:tendsto_cong)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> 1 / 2) at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> 1 / 2) at_top\n\ngoal (1 subgoal):\n 1. \\<not> Im z0 \\<le> Im a \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "then"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> 1 / 2) at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> 1 / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       Re (winding_number (part_circlepath z0 r 0 pi)\n            a)) \\<longlongrightarrow>\n   1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       Re (winding_number (part_circlepath z0 r 0 pi)\n            a)) \\<longlongrightarrow>\n   1 / 2)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_image_at_top_poly_part_circlepath:\n  assumes \"degree p>0\"\n  shows \"\\<forall>\\<^sub>F r in at_top. b\\<notin>path_image (poly p o part_circlepath z0 r st tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "have \"finite (proots (p-[:b:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots (p - [:b:]))", "apply (rule finite_proots)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p - [:b:] \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. p - [:b:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  finite (proots (p - [:b:]))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "from finite_ball_include[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>e>0. proots (p - [:b:]) \\<subseteq> ball ?a e", "obtain R::real where \"R>0\" and R_ball:\"proots (p-[:b:]) \\<subseteq> ball z0 R\""], ["proof (prove)\nusing this:\n  \\<exists>e>0. proots (p - [:b:]) \\<subseteq> ball ?a e\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>0 < R; proots (p - [:b:]) \\<subseteq> ball z0 R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < R\n  proots (p - [:b:]) \\<subseteq> ball z0 R\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "proof (rule eventually_at_top_linorderI[of R])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 x st tt)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 x st tt)", "assume \"r\\<ge>R\""], ["proof (state)\nthis:\n  R \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 x st tt)", "show  \"b\\<notin>path_image (poly p o part_circlepath z0 r st tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "unfolding path_image_compose"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> poly p ` path_image (part_circlepath z0 r st tt)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "assume asm:\"b = poly p x\" \"x \\<in> path_image (part_circlepath z0 r st tt)\""], ["proof (state)\nthis:\n  b = poly p x\n  x \\<in> path_image (part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  b = poly p x\n  x \\<in> path_image (part_circlepath z0 r st tt)", "have \"x\\<in>proots (p-[:b:])\""], ["proof (prove)\nusing this:\n  b = poly p x\n  x \\<in> path_image (part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. x \\<in> proots (p - [:b:])", "unfolding proots_def"], ["proof (prove)\nusing this:\n  b = poly p x\n  x \\<in> path_image (part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. x \\<in> {x. poly (p - [:b:]) x = 0}", "by auto"], ["proof (state)\nthis:\n  x \\<in> proots (p - [:b:])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> proots (p - [:b:])", "have \"x\\<in>ball z0 r\""], ["proof (prove)\nusing this:\n  x \\<in> proots (p - [:b:])\n\ngoal (1 subgoal):\n 1. x \\<in> ball z0 r", "using R_ball \\<open>r\\<ge>R\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> proots (p - [:b:])\n  proots (p - [:b:]) \\<subseteq> ball z0 R\n  R \\<le> r\n\ngoal (1 subgoal):\n 1. x \\<in> ball z0 r", "by auto"], ["proof (state)\nthis:\n  x \\<in> ball z0 r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> ball z0 r", "have \"cmod (x- z0) < r\""], ["proof (prove)\nusing this:\n  x \\<in> ball z0 r\n\ngoal (1 subgoal):\n 1. cmod (x - z0) < r", "by (simp add: dist_commute dist_norm)"], ["proof (state)\nthis:\n  cmod (x - z0) < r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  cmod (x - z0) < r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"cmod (x - z0) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (x - z0) = r", "using asm(2) in_path_image_part_circlepath \\<open>R>0\\<close> \\<open>r\\<ge>R\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> path_image (part_circlepath z0 r st tt)\n  \\<lbrakk>?w \\<in> path_image (part_circlepath ?z ?r ?st ?tt);\n   0 \\<le> ?r\\<rbrakk>\n  \\<Longrightarrow> cmod (?w - ?z) = ?r\n  0 < R\n  R \\<le> r\n\ngoal (1 subgoal):\n 1. cmod (x - z0) = r", "by auto"], ["proof (state)\nthis:\n  cmod (x - z0) = r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  cmod (x - z0) < r\n  cmod (x - z0) = r", "show False"], ["proof (prove)\nusing this:\n  cmod (x - z0) < r\n  cmod (x - z0) = r\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_image_poly_part_circlepath:\n  assumes \"degree p>0\"\n  shows \"\\<exists>r>0.  b\\<notin>path_image (poly p o part_circlepath z0 r st tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r>0.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r>0.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "have \"finite (proots (p-[:b:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots (p - [:b:]))", "apply (rule finite_proots)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p - [:b:] \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. p - [:b:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  finite (proots (p - [:b:]))\n\ngoal (1 subgoal):\n 1. \\<exists>r>0.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "from finite_ball_include[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>e>0. proots (p - [:b:]) \\<subseteq> ball ?a e", "obtain r::real where \"r>0\" and r_ball:\"proots (p-[:b:]) \\<subseteq> ball z0 r\""], ["proof (prove)\nusing this:\n  \\<exists>e>0. proots (p - [:b:]) \\<subseteq> ball ?a e\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>0 < r; proots (p - [:b:]) \\<subseteq> ball z0 r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < r\n  proots (p - [:b:]) \\<subseteq> ball z0 r\n\ngoal (1 subgoal):\n 1. \\<exists>r>0.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "have \"b\\<notin>path_image (poly p o part_circlepath z0 r st tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "unfolding path_image_compose"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> poly p ` path_image (part_circlepath z0 r st tt)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "assume asm:\"b = poly p x\" \"x \\<in> path_image (part_circlepath z0 r st tt)\""], ["proof (state)\nthis:\n  b = poly p x\n  x \\<in> path_image (part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  b = poly p x\n  x \\<in> path_image (part_circlepath z0 r st tt)", "have \"x\\<in>proots (p-[:b:])\""], ["proof (prove)\nusing this:\n  b = poly p x\n  x \\<in> path_image (part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. x \\<in> proots (p - [:b:])", "unfolding proots_def"], ["proof (prove)\nusing this:\n  b = poly p x\n  x \\<in> path_image (part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. x \\<in> {x. poly (p - [:b:]) x = 0}", "by auto"], ["proof (state)\nthis:\n  x \\<in> proots (p - [:b:])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> proots (p - [:b:])", "have \"x\\<in>ball z0 r\""], ["proof (prove)\nusing this:\n  x \\<in> proots (p - [:b:])\n\ngoal (1 subgoal):\n 1. x \\<in> ball z0 r", "using r_ball"], ["proof (prove)\nusing this:\n  x \\<in> proots (p - [:b:])\n  proots (p - [:b:]) \\<subseteq> ball z0 r\n\ngoal (1 subgoal):\n 1. x \\<in> ball z0 r", "by auto"], ["proof (state)\nthis:\n  x \\<in> ball z0 r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> ball z0 r", "have \"cmod (x- z0) < r\""], ["proof (prove)\nusing this:\n  x \\<in> ball z0 r\n\ngoal (1 subgoal):\n 1. cmod (x - z0) < r", "by (simp add: dist_commute dist_norm)"], ["proof (state)\nthis:\n  cmod (x - z0) < r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  cmod (x - z0) < r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"cmod (x - z0) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (x - z0) = r", "using asm(2) in_path_image_part_circlepath \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> path_image (part_circlepath z0 r st tt)\n  \\<lbrakk>?w \\<in> path_image (part_circlepath ?z ?r ?st ?tt);\n   0 \\<le> ?r\\<rbrakk>\n  \\<Longrightarrow> cmod (?w - ?z) = ?r\n  0 < r\n\ngoal (1 subgoal):\n 1. cmod (x - z0) = r", "by auto"], ["proof (state)\nthis:\n  cmod (x - z0) = r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>b = poly p x;\n        x \\<in> path_image (part_circlepath z0 r st tt)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  cmod (x - z0) < r\n  cmod (x - z0) = r", "show False"], ["proof (prove)\nusing this:\n  cmod (x - z0) < r\n  cmod (x - z0) = r\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. \\<exists>r>0.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "then"], ["proof (chain)\npicking this:\n  b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)\n\ngoal (1 subgoal):\n 1. \\<exists>r>0.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<exists>r>0.\n       b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)", "by blast"], ["proof (state)\nthis:\n  \\<exists>r>0.\n     b \\<notin> path_image (poly p \\<circ> part_circlepath z0 r st tt)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Re_winding_number_poly_part_circlepath:\n  assumes \"degree p>0\"\n  shows \"((\\<lambda>r. Re (winding_number (poly p o part_circlepath z0 r 0 pi) 0)) \\<longlongrightarrow> degree p/2 ) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (poly p \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree p) / 2)\n     at_top", "using assms"], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (poly p \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree p) / 2)\n     at_top", "proof (induct rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < degree 0 \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (poly 0 \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree 0) / 2)\n     at_top\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; 0 < degree p\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly p \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree p) / 2)\n                          at_top\n 3. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "case 0"], ["proof (state)\nthis:\n  0 < degree 0\n\ngoal (3 subgoals):\n 1. 0 < degree 0 \\<Longrightarrow>\n    ((\\<lambda>r.\n         Re (winding_number (poly 0 \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree 0) / 2)\n     at_top\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; 0 < degree p\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly p \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree p) / 2)\n                          at_top\n 3. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "then"], ["proof (chain)\npicking this:\n  0 < degree 0", "show ?case"], ["proof (prove)\nusing this:\n  0 < degree 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (poly 0 \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree 0) / 2)\n     at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       Re (winding_number (poly 0 \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree 0) / 2)\n   at_top\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; 0 < degree p\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly p \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree p) / 2)\n                          at_top\n 2. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; 0 < degree p\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly p \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree p) / 2)\n                          at_top\n 2. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> 0\n  0 < degree p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; 0 < degree p\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly p \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree p) / 2)\n                          at_top\n 2. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "then"], ["proof (chain)\npicking this:\n  poly p ?a \\<noteq> 0\n  0 < degree p", "have False"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> 0\n  0 < degree p\n\ngoal (1 subgoal):\n 1. False", "using Fundamental_Theorem_Algebra.fundamental_theorem_of_algebra constant_degree neq0_conv"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> 0\n  0 < degree p\n  \\<not> constant (poly ?p) \\<Longrightarrow> \\<exists>z. poly ?p z = 0\n  constant (poly ?p) = (degree ?p = 0)\n  (?n \\<noteq> 0) = (0 < ?n)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; 0 < degree p\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly p \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree p) / 2)\n                          at_top\n 2. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "then"], ["proof (chain)\npicking this:\n  False", "show ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (poly p \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree p) / 2)\n     at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       Re (winding_number (poly p \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree p) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "case (root a p)"], ["proof (state)\nthis:\n  0 < degree p \\<Longrightarrow>\n  ((\\<lambda>r.\n       Re (winding_number (poly p \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree p) / 2)\n   at_top\n  0 < degree ([:- a, 1:] * p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "define g where \"g = (\\<lambda>r. part_circlepath z0 r 0 pi)\""], ["proof (state)\nthis:\n  g = (\\<lambda>r. part_circlepath z0 r 0 pi)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "define q where \"q=[:- a, 1:] * p\""], ["proof (state)\nthis:\n  q = [:- a, 1:] * p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "define w where \"w = (\\<lambda>r. winding_number (poly q \\<circ> g r) 0)\""], ["proof (state)\nthis:\n  w = (\\<lambda>r. winding_number (poly q \\<circ> g r) 0)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "have ?case when \"degree p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "obtain pc where pc_def:\"p=[:pc:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pc. p = [:pc:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<open>degree p = 0\\<close> degree_eq_zeroE"], ["proof (prove)\nusing this:\n  degree p = 0\n  \\<lbrakk>degree ?p = 0;\n   \\<And>a. ?p = [:a:] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>pc. p = [:pc:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  p = [:pc:]\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "then"], ["proof (chain)\npicking this:\n  p = [:pc:]", "have \"pc\\<noteq>0\""], ["proof (prove)\nusing this:\n  p = [:pc:]\n\ngoal (1 subgoal):\n 1. pc \\<noteq> 0", "using root(2)"], ["proof (prove)\nusing this:\n  p = [:pc:]\n  0 < degree ([:- a, 1:] * p)\n\ngoal (1 subgoal):\n 1. pc \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "have \"\\<forall>\\<^sub>F r in at_top. Re (w r) = Re (winding_number (g r) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top. Re (w r) = Re (winding_number (g r) a)", "proof (rule eventually_at_top_linorderI[of \"cmod (( pc * a) / pc - z0) + 1\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (pc * a / pc - z0) + 1 \\<le> x \\<Longrightarrow>\n       Re (w x) = Re (winding_number (g x) a)", "fix r::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (pc * a / pc - z0) + 1 \\<le> x \\<Longrightarrow>\n       Re (w x) = Re (winding_number (g x) a)", "assume asm:\"cmod ((pc * a) / pc - z0) + 1 \\<le> r\""], ["proof (state)\nthis:\n  cmod (pc * a / pc - z0) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (pc * a / pc - z0) + 1 \\<le> x \\<Longrightarrow>\n       Re (w x) = Re (winding_number (g x) a)", "have \"w r =  winding_number ((\\<lambda>x. pc*x - pc*a) \\<circ> (g r)) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w r = winding_number ((\\<lambda>x. pc * x - pc * a) \\<circ> g r) 0", "unfolding w_def pc_def g_def q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number\n     (poly ([:- a, 1:] * [:pc:]) \\<circ> part_circlepath z0 r 0 pi) 0 =\n    winding_number\n     ((\\<lambda>x. pc * x - pc * a) \\<circ> part_circlepath z0 r 0 pi) 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number\n     (poly [:- (pc * a), pc:] \\<circ> part_circlepath z0 r 0 pi) 0 =\n    winding_number\n     ((\\<lambda>x. pc * x - pc * a) \\<circ> part_circlepath z0 r 0 pi) 0", "by (metis (no_types, hide_lams) add.right_neutral mult.commute mult_zero_right \n            poly_0 poly_pCons uminus_add_conv_diff)"], ["proof (state)\nthis:\n  w r = winding_number ((\\<lambda>x. pc * x - pc * a) \\<circ> g r) 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (pc * a / pc - z0) + 1 \\<le> x \\<Longrightarrow>\n       Re (w x) = Re (winding_number (g x) a)", "also"], ["proof (state)\nthis:\n  w r = winding_number ((\\<lambda>x. pc * x - pc * a) \\<circ> g r) 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (pc * a / pc - z0) + 1 \\<le> x \\<Longrightarrow>\n       Re (w x) = Re (winding_number (g x) a)", "have \"... =  winding_number (g r) a \""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number ((\\<lambda>x. pc * x - pc * a) \\<circ> g r) 0 =\n    winding_number (g r) a", "apply (subst winding_number_comp_linear[where b=\"-pc*a\",simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. pc \\<noteq> 0\n 2. valid_path (g r)\n 3. (0 + pc * a) / pc \\<notin> path_image (g r)\n 4. winding_number (g r) ((0 + pc * a) / pc) = winding_number (g r) a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc \\<noteq> 0", "using \\<open>pc\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pc \\<noteq> 0", "."], ["proof (prove)\ngoal (3 subgoals):\n 1. valid_path (g r)\n 2. (0 + pc * a) / pc \\<notin> path_image (g r)\n 3. winding_number (g r) ((0 + pc * a) / pc) = winding_number (g r) a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (g r)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (part_circlepath z0 r 0 pi)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. (0 + pc * a) / pc \\<notin> path_image (g r)\n 2. winding_number (g r) ((0 + pc * a) / pc) = winding_number (g r) a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 + pc * a) / pc \\<notin> path_image (g r)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 + pc * a) / pc \\<notin> path_image (part_circlepath z0 r 0 pi)", "apply (rule not_on_circlepathI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod ((0 + pc * a) / pc - z0) \\<noteq> \\<bar>r\\<bar>", "using asm"], ["proof (prove)\nusing this:\n  cmod (pc * a / pc - z0) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. cmod ((0 + pc * a) / pc - z0) \\<noteq> \\<bar>r\\<bar>", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (g r) ((0 + pc * a) / pc) = winding_number (g r) a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (g r) ((0 + pc * a) / pc) = winding_number (g r) a", "using \\<open>pc\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. winding_number (g r) ((0 + pc * a) / pc) = winding_number (g r) a", "by (auto simp add:field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  winding_number ((\\<lambda>x. pc * x - pc * a) \\<circ> g r) 0 =\n  winding_number (g r) a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (pc * a / pc - z0) + 1 \\<le> x \\<Longrightarrow>\n       Re (w x) = Re (winding_number (g x) a)", "finally"], ["proof (chain)\npicking this:\n  w r = winding_number (g r) a", "have \"w r = winding_number (g r) a \""], ["proof (prove)\nusing this:\n  w r = winding_number (g r) a\n\ngoal (1 subgoal):\n 1. w r = winding_number (g r) a", "."], ["proof (state)\nthis:\n  w r = winding_number (g r) a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (pc * a / pc - z0) + 1 \\<le> x \\<Longrightarrow>\n       Re (w x) = Re (winding_number (g x) a)", "then"], ["proof (chain)\npicking this:\n  w r = winding_number (g r) a", "show \"Re (w r) = Re (winding_number (g r) a)\""], ["proof (prove)\nusing this:\n  w r = winding_number (g r) a\n\ngoal (1 subgoal):\n 1. Re (w r) = Re (winding_number (g r) a)", "by simp"], ["proof (state)\nthis:\n  Re (w r) = Re (winding_number (g r) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top. Re (w r) = Re (winding_number (g r) a)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top. Re (w r) = Re (winding_number (g r) a)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "have \"((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow> 1/2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow> 1 / 2)\n     at_top", "using Re_winding_number_tendsto_part_circlepath"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       Re (winding_number (part_circlepath ?z0.0 r 0 pi)\n            ?a)) \\<longlongrightarrow>\n   1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow> 1 / 2)\n     at_top", "unfolding g_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       Re (winding_number (part_circlepath ?z0.0 r 0 pi)\n            ?a)) \\<longlongrightarrow>\n   1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow> 1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F r in at_top. Re (w r) = Re (winding_number (g r) a)\n  ((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow> 1 / 2)\n   at_top", "have \"((\\<lambda>r. Re (w r)) \\<longlongrightarrow> 1/2) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top. Re (w r) = Re (winding_number (g r) a)\n  ((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow> 1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. Re (w r)) \\<longlongrightarrow> 1 / 2) at_top", "by (auto dest!:tendsto_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>r. Re (w r)) \\<longlongrightarrow> 1 / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>r. Re (w r)) \\<longlongrightarrow> 1 / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "have \"degree ([:- a, 1:] * p) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:- a, 1:] * p) = 1", "unfolding pc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:- a, 1:] * [:pc:]) = 1", "using \\<open>pc\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  pc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree ([:- a, 1:] * [:pc:]) = 1", "by auto"], ["proof (state)\nthis:\n  degree ([:- a, 1:] * p) = 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<lambda>r. Re (w r)) \\<longlongrightarrow> 1 / 2) at_top\n  degree ([:- a, 1:] * p) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>r. Re (w r)) \\<longlongrightarrow> 1 / 2) at_top\n  degree ([:- a, 1:] * p) = 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "unfolding w_def g_def comp_def q_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       Re (winding_number\n            (\\<lambda>x.\n                poly ([:- a, 1:] * p) (part_circlepath z0 r 0 pi x))\n            0)) \\<longlongrightarrow>\n   1 / 2)\n   at_top\n  degree ([:- a, 1:] * p) = 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (\\<lambda>b.\n                  poly ([:- a, 1:] * p) (part_circlepath z0 r 0 pi b))\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       Re (winding_number\n            (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree ([:- a, 1:] * p)) / 2)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow>\n  ((\\<lambda>r.\n       Re (winding_number\n            (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree ([:- a, 1:] * p)) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "moreover"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow>\n  ((\\<lambda>r.\n       Re (winding_number\n            (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree ([:- a, 1:] * p)) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "have ?case when \"degree p>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "have \"\\<forall>\\<^sub>F r in at_top. 0 \\<notin> path_image (poly q \\<circ> g r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       0 \\<notin> path_image (poly q \\<circ> g r)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       0 \\<notin> path_image (poly q \\<circ> part_circlepath z0 r 0 pi)", "apply (rule not_image_at_top_poly_part_circlepath)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree q", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree ([:- a, 1:] * p)", "using root.prems"], ["proof (prove)\nusing this:\n  0 < degree ([:- a, 1:] * p)\n\ngoal (1 subgoal):\n 1. 0 < degree ([:- a, 1:] * p)", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top. 0 \\<notin> path_image (poly q \\<circ> g r)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F r in at_top. 0 \\<notin> path_image (poly q \\<circ> g r)", "have \"\\<forall>\\<^sub>F r in at_top. Re (w r) = Re (winding_number (g r) a) \n              + Re (winding_number (poly p \\<circ> g r) 0)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top. 0 \\<notin> path_image (poly q \\<circ> g r)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       Re (w r) =\n       Re (winding_number (g r) a) +\n       Re (winding_number (poly p \\<circ> g r) 0)", "proof (rule eventually_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "assume asm:\"0 \\<notin> path_image (poly q \\<circ> g r)\""], ["proof (state)\nthis:\n  0 \\<notin> path_image (poly q \\<circ> g r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "define cc where \"cc= 1 / (of_real (2 * pi) * \\<i>)\""], ["proof (state)\nthis:\n  cc = 1 / (complex_of_real (2 * pi) * \\<i>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "define pf where \"pf=(\\<lambda>w. deriv (poly p) w / poly p w)\""], ["proof (state)\nthis:\n  pf = (\\<lambda>w. deriv (poly p) w / poly p w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "define af where \"af=(\\<lambda>w. 1/(w-a))\""], ["proof (state)\nthis:\n  af = (\\<lambda>w. 1 / (w - a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "have \"w r = cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w r =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w)", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (poly q \\<circ> g r) 0 =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w)", "apply (subst winding_number_comp[of UNIV,simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. poly q holomorphic_on UNIV\n 2. valid_path (g r)\n 3. 0 \\<notin> path_image (poly q \\<circ> g r)\n 4. contour_integral (g r) (\\<lambda>w. deriv (poly q) w / (poly q w - 0)) /\n    (2 * complex_of_real pi * \\<i>) =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w)", "using asm"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image (poly q \\<circ> g r)\n\ngoal (4 subgoals):\n 1. poly q holomorphic_on UNIV\n 2. valid_path (g r)\n 3. 0 \\<notin> path_image (poly q \\<circ> g r)\n 4. contour_integral (g r) (\\<lambda>w. deriv (poly q) w / (poly q w - 0)) /\n    (2 * complex_of_real pi * \\<i>) =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w)", "unfolding g_def cc_def"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image (poly q \\<circ> part_circlepath z0 r 0 pi)\n\ngoal (4 subgoals):\n 1. poly q holomorphic_on UNIV\n 2. valid_path (part_circlepath z0 r 0 pi)\n 3. 0 \\<notin> path_image (poly q \\<circ> part_circlepath z0 r 0 pi)\n 4. contour_integral (part_circlepath z0 r 0 pi)\n     (\\<lambda>w. deriv (poly q) w / (poly q w - 0)) /\n    (2 * complex_of_real pi * \\<i>) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral (part_circlepath z0 r 0 pi)\n     (\\<lambda>w. deriv (poly q) w / poly q w)", "by auto"], ["proof (state)\nthis:\n  w r =\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "also"], ["proof (state)\nthis:\n  w r =\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "have \"... = cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w + 1/(w-a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) =\n    cc *\n    contour_integral (g r)\n     (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) =\n    cc *\n    contour_integral (g r)\n     (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a))", "have \"contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) \n            = contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w + 1/(w-a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) =\n    contour_integral (g r)\n     (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a))", "proof (rule contour_integral_eq)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_image (g r) \\<Longrightarrow>\n       deriv (poly q) x / poly q x =\n       deriv (poly p) x / poly p x + 1 / (x - a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_image (g r) \\<Longrightarrow>\n       deriv (poly q) x / poly q x =\n       deriv (poly p) x / poly p x + 1 / (x - a)", "assume \"x \\<in> path_image (g r)\""], ["proof (state)\nthis:\n  x \\<in> path_image (g r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_image (g r) \\<Longrightarrow>\n       deriv (poly q) x / poly q x =\n       deriv (poly p) x / poly p x + 1 / (x - a)", "have \"deriv (poly q) x = deriv (poly p) x * (x-a) + poly p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deriv (poly q) x = deriv (poly p) x * (x - a) + poly p x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. deriv (poly q) x = deriv (poly p) x * (x - a) + poly p x", "have \"poly q = (\\<lambda>x. (x-a) * poly p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q = (\\<lambda>x. (x - a) * poly p x)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. poly q x = (x - a) * poly p x", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. poly ([:- a, 1:] * p) x = (x - a) * poly p x", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  poly q = (\\<lambda>x. (x - a) * poly p x)\n\ngoal (1 subgoal):\n 1. deriv (poly q) x = deriv (poly p) x * (x - a) + poly p x", "then"], ["proof (chain)\npicking this:\n  poly q = (\\<lambda>x. (x - a) * poly p x)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly q = (\\<lambda>x. (x - a) * poly p x)\n\ngoal (1 subgoal):\n 1. deriv (poly q) x = deriv (poly p) x * (x - a) + poly p x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q = (\\<lambda>x. (x - a) * poly p x) \\<Longrightarrow>\n    deriv (\\<lambda>x. (x - a) * poly p x) x =\n    deriv (poly p) x * (x - a) + poly p x", "apply (subst deriv_mult[of \"\\<lambda>x. x- a\" _ \"poly p\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. poly q = (\\<lambda>x. (x - a) * poly p x) \\<Longrightarrow>\n    (\\<lambda>x. x - a) field_differentiable at x\n 2. poly q = (\\<lambda>x. (x - a) * poly p x) \\<Longrightarrow>\n    poly p field_differentiable at x\n 3. poly q = (\\<lambda>x. (x - a) * poly p x) \\<Longrightarrow>\n    (x - a) * deriv (poly p) x + deriv (\\<lambda>x. x - a) x * poly p x =\n    deriv (poly p) x * (x - a) + poly p x", "by (auto intro:derivative_intros)"], ["proof (state)\nthis:\n  deriv (poly q) x = deriv (poly p) x * (x - a) + poly p x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deriv (poly q) x = deriv (poly p) x * (x - a) + poly p x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_image (g r) \\<Longrightarrow>\n       deriv (poly q) x / poly q x =\n       deriv (poly p) x / poly p x + 1 / (x - a)", "moreover"], ["proof (state)\nthis:\n  deriv (poly q) x = deriv (poly p) x * (x - a) + poly p x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_image (g r) \\<Longrightarrow>\n       deriv (poly q) x / poly q x =\n       deriv (poly p) x / poly p x + 1 / (x - a)", "have \"poly p x\\<noteq>0 \\<and> x-a\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0) \\<Longrightarrow>\n    False", "assume \"\\<not> (poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0)\""], ["proof (state)\nthis:\n  \\<not> (poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0)", "have \"poly q x=0\""], ["proof (prove)\nusing this:\n  \\<not> (poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. poly q x = 0", "unfolding q_def"], ["proof (prove)\nusing this:\n  \\<not> (poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. poly ([:- a, 1:] * p) x = 0", "by auto"], ["proof (state)\nthis:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  poly q x = 0", "have \"0\\<in>poly q ` path_image (g r)\""], ["proof (prove)\nusing this:\n  poly q x = 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> poly q ` path_image (g r)", "using \\<open>x \\<in> path_image (g r)\\<close>"], ["proof (prove)\nusing this:\n  poly q x = 0\n  x \\<in> path_image (g r)\n\ngoal (1 subgoal):\n 1. 0 \\<in> poly q ` path_image (g r)", "by auto"], ["proof (state)\nthis:\n  0 \\<in> poly q ` path_image (g r)\n\ngoal (1 subgoal):\n 1. \\<not> (poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  0 \\<in> poly q ` path_image (g r)", "show False"], ["proof (prove)\nusing this:\n  0 \\<in> poly q ` path_image (g r)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>0 \\<notin> path_image (poly q \\<circ> g r)\\<close>"], ["proof (prove)\nusing this:\n  0 \\<in> poly q ` path_image (g r)\n  0 \\<notin> path_image (poly q \\<circ> g r)\n\ngoal (1 subgoal):\n 1. False", "unfolding path_image_compose"], ["proof (prove)\nusing this:\n  0 \\<in> poly q ` path_image (g r)\n  0 \\<notin> poly q ` path_image (g r)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> path_image (g r) \\<Longrightarrow>\n       deriv (poly q) x / poly q x =\n       deriv (poly p) x / poly p x + 1 / (x - a)", "ultimately"], ["proof (chain)\npicking this:\n  deriv (poly q) x = deriv (poly p) x * (x - a) + poly p x\n  poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0", "show \"deriv (poly q) x / poly q x = deriv (poly p) x / poly p x + 1 / (x - a)\""], ["proof (prove)\nusing this:\n  deriv (poly q) x = deriv (poly p) x * (x - a) + poly p x\n  poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. deriv (poly q) x / poly q x = deriv (poly p) x / poly p x + 1 / (x - a)", "unfolding q_def"], ["proof (prove)\nusing this:\n  deriv (poly ([:- a, 1:] * p)) x = deriv (poly p) x * (x - a) + poly p x\n  poly p x \\<noteq> 0 \\<and> x - a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. deriv (poly ([:- a, 1:] * p)) x / poly ([:- a, 1:] * p) x =\n    deriv (poly p) x / poly p x + 1 / (x - a)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  deriv (poly q) x / poly q x = deriv (poly p) x / poly p x + 1 / (x - a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) =\n  contour_integral (g r)\n   (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a))\n\ngoal (1 subgoal):\n 1. cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) =\n    cc *\n    contour_integral (g r)\n     (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a))", "then"], ["proof (chain)\npicking this:\n  contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) =\n  contour_integral (g r)\n   (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a))", "show ?thesis"], ["proof (prove)\nusing this:\n  contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) =\n  contour_integral (g r)\n   (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a))\n\ngoal (1 subgoal):\n 1. cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) =\n    cc *\n    contour_integral (g r)\n     (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a))", "by auto"], ["proof (state)\nthis:\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) =\n  cc *\n  contour_integral (g r)\n   (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) =\n  cc *\n  contour_integral (g r)\n   (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "also"], ["proof (state)\nthis:\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly q) w / poly q w) =\n  cc *\n  contour_integral (g r)\n   (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "have \"... = cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) \n          + cc * contour_integral (g r) (\\<lambda>w. 1/(w-a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cc *\n    contour_integral (g r)\n     (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a)) =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))", "proof (subst contour_integral_add)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>w. deriv (poly p) w / poly p w) contour_integrable_on g r\n 2. (\\<lambda>w. 1 / (w - a)) contour_integrable_on g r\n 3. cc *\n    (contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n     contour_integral (g r) (\\<lambda>w. 1 / (w - a))) =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))", "have \"continuous_on (path_image (g r)) (\\<lambda>w. deriv (poly p) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (path_image (g r)) (deriv (poly p))", "unfolding deriv_pderiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (path_image (g r)) (poly (pderiv p))", "by (intro continuous_intros)"], ["proof (state)\nthis:\n  continuous_on (path_image (g r)) (deriv (poly p))\n\ngoal (3 subgoals):\n 1. (\\<lambda>w. deriv (poly p) w / poly p w) contour_integrable_on g r\n 2. (\\<lambda>w. 1 / (w - a)) contour_integrable_on g r\n 3. cc *\n    (contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n     contour_integral (g r) (\\<lambda>w. 1 / (w - a))) =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))", "moreover"], ["proof (state)\nthis:\n  continuous_on (path_image (g r)) (deriv (poly p))\n\ngoal (3 subgoals):\n 1. (\\<lambda>w. deriv (poly p) w / poly p w) contour_integrable_on g r\n 2. (\\<lambda>w. 1 / (w - a)) contour_integrable_on g r\n 3. cc *\n    (contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n     contour_integral (g r) (\\<lambda>w. 1 / (w - a))) =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))", "have \"\\<forall>w\\<in>path_image (g r). poly p w \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>path_image (g r). poly p w \\<noteq> 0", "using asm"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image (poly q \\<circ> g r)\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>path_image (g r). poly p w \\<noteq> 0", "unfolding q_def path_image_compose"], ["proof (prove)\nusing this:\n  0 \\<notin> poly ([:- a, 1:] * p) ` path_image (g r)\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>path_image (g r). poly p w \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>w\\<in>path_image (g r). poly p w \\<noteq> 0\n\ngoal (3 subgoals):\n 1. (\\<lambda>w. deriv (poly p) w / poly p w) contour_integrable_on g r\n 2. (\\<lambda>w. 1 / (w - a)) contour_integrable_on g r\n 3. cc *\n    (contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n     contour_integral (g r) (\\<lambda>w. 1 / (w - a))) =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))", "ultimately"], ["proof (chain)\npicking this:\n  continuous_on (path_image (g r)) (deriv (poly p))\n  \\<forall>w\\<in>path_image (g r). poly p w \\<noteq> 0", "show \"(\\<lambda>w. deriv (poly p) w / poly p w) contour_integrable_on g r\""], ["proof (prove)\nusing this:\n  continuous_on (path_image (g r)) (deriv (poly p))\n  \\<forall>w\\<in>path_image (g r). poly p w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. deriv (poly p) w / poly p w) contour_integrable_on g r", "unfolding g_def"], ["proof (prove)\nusing this:\n  continuous_on (path_image (part_circlepath z0 r 0 pi)) (deriv (poly p))\n  \\<forall>w\\<in>path_image (part_circlepath z0 r 0 pi). poly p w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>w. deriv (poly p) w / poly p w) contour_integrable_on\n    part_circlepath z0 r 0 pi", "by (auto intro!: contour_integrable_continuous_part_circlepath continuous_intros)"], ["proof (state)\nthis:\n  (\\<lambda>w. deriv (poly p) w / poly p w) contour_integrable_on g r\n\ngoal (2 subgoals):\n 1. (\\<lambda>w. 1 / (w - a)) contour_integrable_on g r\n 2. cc *\n    (contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n     contour_integral (g r) (\\<lambda>w. 1 / (w - a))) =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))", "show \"(\\<lambda>w. 1 / (w - a)) contour_integrable_on g r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>w. 1 / (w - a)) contour_integrable_on g r", "apply (rule contour_integrable_inversediff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path (g r)\n 2. a \\<notin> path_image (g r)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (g r)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (part_circlepath z0 r 0 pi)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> path_image (g r)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> path_image (g r)", "using asm"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image (poly q \\<circ> g r)\n\ngoal (1 subgoal):\n 1. a \\<notin> path_image (g r)", "unfolding q_def path_image_compose"], ["proof (prove)\nusing this:\n  0 \\<notin> poly ([:- a, 1:] * p) ` path_image (g r)\n\ngoal (1 subgoal):\n 1. a \\<notin> path_image (g r)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>w. 1 / (w - a)) contour_integrable_on g r\n\ngoal (1 subgoal):\n 1. cc *\n    (contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n     contour_integral (g r) (\\<lambda>w. 1 / (w - a))) =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))", "qed (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cc *\n  contour_integral (g r)\n   (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a)) =\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n  cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "also"], ["proof (state)\nthis:\n  cc *\n  contour_integral (g r)\n   (\\<lambda>w. deriv (poly p) w / poly p w + 1 / (w - a)) =\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n  cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "have \"... =  winding_number (g r) a +  winding_number (poly p o g r) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a)) =\n    winding_number (g r) a + winding_number (poly p \\<circ> g r) 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a)) =\n    winding_number (g r) a + winding_number (poly p \\<circ> g r) 0", "have \"winding_number (poly p o g r) 0\n            = cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (poly p \\<circ> g r) 0 =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w)", "apply (subst winding_number_comp[of UNIV,simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. poly p holomorphic_on UNIV\n 2. valid_path (g r)\n 3. 0 \\<notin> path_image (poly p \\<circ> g r)\n 4. contour_integral (g r) (\\<lambda>w. deriv (poly p) w / (poly p w - 0)) /\n    (2 * complex_of_real pi * \\<i>) =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w)", "using \\<open>0 \\<notin> path_image (poly q \\<circ> g r)\\<close>"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image (poly q \\<circ> g r)\n\ngoal (4 subgoals):\n 1. poly p holomorphic_on UNIV\n 2. valid_path (g r)\n 3. 0 \\<notin> path_image (poly p \\<circ> g r)\n 4. contour_integral (g r) (\\<lambda>w. deriv (poly p) w / (poly p w - 0)) /\n    (2 * complex_of_real pi * \\<i>) =\n    cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w)", "unfolding path_image_compose q_def g_def cc_def"], ["proof (prove)\nusing this:\n  0 \\<notin> poly ([:- a, 1:] * p) ` path_image (part_circlepath z0 r 0 pi)\n\ngoal (4 subgoals):\n 1. poly p holomorphic_on UNIV\n 2. valid_path (part_circlepath z0 r 0 pi)\n 3. 0 \\<notin> poly p ` path_image (part_circlepath z0 r 0 pi)\n 4. contour_integral (part_circlepath z0 r 0 pi)\n     (\\<lambda>w. deriv (poly p) w / (poly p w - 0)) /\n    (2 * complex_of_real pi * \\<i>) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral (part_circlepath z0 r 0 pi)\n     (\\<lambda>w. deriv (poly p) w / poly p w)", "by auto"], ["proof (state)\nthis:\n  winding_number (poly p \\<circ> g r) 0 =\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w)\n\ngoal (1 subgoal):\n 1. cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a)) =\n    winding_number (g r) a + winding_number (poly p \\<circ> g r) 0", "moreover"], ["proof (state)\nthis:\n  winding_number (poly p \\<circ> g r) 0 =\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w)\n\ngoal (1 subgoal):\n 1. cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a)) =\n    winding_number (g r) a + winding_number (poly p \\<circ> g r) 0", "have \"winding_number (g r) a = cc * contour_integral (g r) (\\<lambda>w. 1/(w-a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (g r) a =\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))", "apply (subst winding_number_valid_path)"], ["proof (prove)\ngoal (3 subgoals):\n 1. valid_path (g r)\n 2. a \\<notin> path_image (g r)\n 3. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral (g r) (\\<lambda>w. 1 / (w - a)) =\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))", "using \\<open>0 \\<notin> path_image (poly q \\<circ> g r)\\<close>"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image (poly q \\<circ> g r)\n\ngoal (3 subgoals):\n 1. valid_path (g r)\n 2. a \\<notin> path_image (g r)\n 3. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral (g r) (\\<lambda>w. 1 / (w - a)) =\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))", "unfolding path_image_compose q_def g_def cc_def"], ["proof (prove)\nusing this:\n  0 \\<notin> poly ([:- a, 1:] * p) ` path_image (part_circlepath z0 r 0 pi)\n\ngoal (3 subgoals):\n 1. valid_path (part_circlepath z0 r 0 pi)\n 2. a \\<notin> path_image (part_circlepath z0 r 0 pi)\n 3. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral (part_circlepath z0 r 0 pi) (\\<lambda>w. 1 / (w - a)) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral (part_circlepath z0 r 0 pi) (\\<lambda>w. 1 / (w - a))", "by auto"], ["proof (state)\nthis:\n  winding_number (g r) a =\n  cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))\n\ngoal (1 subgoal):\n 1. cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a)) =\n    winding_number (g r) a + winding_number (poly p \\<circ> g r) 0", "ultimately"], ["proof (chain)\npicking this:\n  winding_number (poly p \\<circ> g r) 0 =\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w)\n  winding_number (g r) a =\n  cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))", "show ?thesis"], ["proof (prove)\nusing this:\n  winding_number (poly p \\<circ> g r) 0 =\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w)\n  winding_number (g r) a =\n  cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a))\n\ngoal (1 subgoal):\n 1. cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n    cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a)) =\n    winding_number (g r) a + winding_number (poly p \\<circ> g r) 0", "by auto"], ["proof (state)\nthis:\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n  cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a)) =\n  winding_number (g r) a + winding_number (poly p \\<circ> g r) 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cc * contour_integral (g r) (\\<lambda>w. deriv (poly p) w / poly p w) +\n  cc * contour_integral (g r) (\\<lambda>w. 1 / (w - a)) =\n  winding_number (g r) a + winding_number (poly p \\<circ> g r) 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 \\<notin> path_image (poly q \\<circ> g x) \\<Longrightarrow>\n       Re (w x) =\n       Re (winding_number (g x) a) +\n       Re (winding_number (poly p \\<circ> g x) 0)", "finally"], ["proof (chain)\npicking this:\n  w r = winding_number (g r) a + winding_number (poly p \\<circ> g r) 0", "show \"Re (w r) = Re (winding_number (g r) a) + Re (winding_number (poly p \\<circ> g r) 0)\""], ["proof (prove)\nusing this:\n  w r = winding_number (g r) a + winding_number (poly p \\<circ> g r) 0\n\ngoal (1 subgoal):\n 1. Re (w r) =\n    Re (winding_number (g r) a) + Re (winding_number (poly p \\<circ> g r) 0)", "by auto"], ["proof (state)\nthis:\n  Re (w r) =\n  Re (winding_number (g r) a) + Re (winding_number (poly p \\<circ> g r) 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     Re (w r) =\n     Re (winding_number (g r) a) +\n     Re (winding_number (poly p \\<circ> g r) 0)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     Re (w r) =\n     Re (winding_number (g r) a) +\n     Re (winding_number (poly p \\<circ> g r) 0)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "have \"((\\<lambda>r. Re (winding_number (g r) a) \n              + Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow> degree q / 2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (g r) a) +\n         Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n     real (degree q) / 2)\n     at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (g r) a) +\n         Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n     real (degree q) / 2)\n     at_top", "have \"((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow>1 / 2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow> 1 / 2)\n     at_top", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (part_circlepath z0 r 0 pi)\n              a)) \\<longlongrightarrow>\n     1 / 2)\n     at_top", "by (rule Re_winding_number_tendsto_part_circlepath)"], ["proof (state)\nthis:\n  ((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow> 1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (g r) a) +\n         Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n     real (degree q) / 2)\n     at_top", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow> 1 / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (g r) a) +\n         Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n     real (degree q) / 2)\n     at_top", "have \"((\\<lambda>r. Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow> degree p / 2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n     real (degree p) / 2)\n     at_top", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (poly p \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree p) / 2)\n     at_top", "by (rule root(1)[OF that])"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n   real (degree p) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (g r) a) +\n         Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n     real (degree q) / 2)\n     at_top", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n   real (degree p) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (g r) a) +\n         Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n     real (degree q) / 2)\n     at_top", "have \"degree q = degree p + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = degree p + 1", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:- a, 1:] * p) = degree p + 1", "apply (subst degree_mult_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [:- a, 1:] \\<noteq> 0\n 2. p \\<noteq> 0\n 3. degree [:- a, 1:] + degree p = degree p + 1", "using that"], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (3 subgoals):\n 1. [:- a, 1:] \\<noteq> 0\n 2. p \\<noteq> 0\n 3. degree [:- a, 1:] + degree p = degree p + 1", "by auto"], ["proof (state)\nthis:\n  degree q = degree p + 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (g r) a) +\n         Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n     real (degree q) / 2)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow> 1 / 2)\n   at_top\n  ((\\<lambda>r.\n       Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n   real (degree p) / 2)\n   at_top\n  degree q = degree p + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>r. Re (winding_number (g r) a)) \\<longlongrightarrow> 1 / 2)\n   at_top\n  ((\\<lambda>r.\n       Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n   real (degree p) / 2)\n   at_top\n  degree q = degree p + 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (g r) a) +\n         Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n     real (degree q) / 2)\n     at_top", "by (simp add: tendsto_add add_divide_distrib)"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       Re (winding_number (g r) a) +\n       Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n   real (degree q) / 2)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       Re (winding_number (g r) a) +\n       Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n   real (degree q) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F r in at_top.\n     Re (w r) =\n     Re (winding_number (g r) a) +\n     Re (winding_number (poly p \\<circ> g r) 0)\n  ((\\<lambda>r.\n       Re (winding_number (g r) a) +\n       Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n   real (degree q) / 2)\n   at_top", "have \"((\\<lambda>r. Re (w r)) \\<longlongrightarrow> degree q/2) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top.\n     Re (w r) =\n     Re (winding_number (g r) a) +\n     Re (winding_number (poly p \\<circ> g r) 0)\n  ((\\<lambda>r.\n       Re (winding_number (g r) a) +\n       Re (winding_number (poly p \\<circ> g r) 0)) \\<longlongrightarrow>\n   real (degree q) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. Re (w r)) \\<longlongrightarrow> real (degree q) / 2)\n     at_top", "by (auto dest!:tendsto_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>r. Re (w r)) \\<longlongrightarrow> real (degree q) / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>r. Re (w r)) \\<longlongrightarrow> real (degree q) / 2) at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>r. Re (w r)) \\<longlongrightarrow> real (degree q) / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "unfolding w_def q_def g_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       Re (winding_number\n            (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree ([:- a, 1:] * p)) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       Re (winding_number\n            (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree ([:- a, 1:] * p)) / 2)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < degree p \\<Longrightarrow>\n  ((\\<lambda>r.\n       Re (winding_number\n            (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree ([:- a, 1:] * p)) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>0 < degree p \\<Longrightarrow>\n                ((\\<lambda>r.\n                     Re (winding_number\n                          (poly p \\<circ> part_circlepath z0 r 0 pi)\n                          0)) \\<longlongrightarrow>\n                 real (degree p) / 2)\n                 at_top;\n        0 < degree ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>r.\n                              Re (winding_number\n                                   (poly ([:- a, 1:] * p) \\<circ>\n                                    part_circlepath z0 r 0 pi)\n                                   0)) \\<longlongrightarrow>\n                          real (degree ([:- a, 1:] * p)) / 2)\n                          at_top", "ultimately"], ["proof (chain)\npicking this:\n  degree p = 0 \\<Longrightarrow>\n  ((\\<lambda>r.\n       Re (winding_number\n            (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree ([:- a, 1:] * p)) / 2)\n   at_top\n  0 < degree p \\<Longrightarrow>\n  ((\\<lambda>r.\n       Re (winding_number\n            (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree ([:- a, 1:] * p)) / 2)\n   at_top", "show ?case"], ["proof (prove)\nusing this:\n  degree p = 0 \\<Longrightarrow>\n  ((\\<lambda>r.\n       Re (winding_number\n            (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree ([:- a, 1:] * p)) / 2)\n   at_top\n  0 < degree p \\<Longrightarrow>\n  ((\\<lambda>r.\n       Re (winding_number\n            (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree ([:- a, 1:] * p)) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number\n              (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree ([:- a, 1:] * p)) / 2)\n     at_top", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       Re (winding_number\n            (poly ([:- a, 1:] * p) \\<circ> part_circlepath z0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree ([:- a, 1:] * p)) / 2)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Re_winding_number_poly_linepth:\n  fixes pp::\"complex poly\"\n  defines \"g \\<equiv> (\\<lambda>r. poly pp o linepath (-r) (of_real r))\"\n  assumes \"lead_coeff pp=1\" and no_real_zero:\"\\<forall>x\\<in>proots pp. Im x\\<noteq>0\"\n  shows \"((\\<lambda>r. 2*Re (winding_number (g r) 0) + cindex_pathE (g r) 0 ) \\<longlongrightarrow> 0 ) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "define p where \"p=map_poly Re pp\""], ["proof (state)\nthis:\n  p = map_poly Re pp\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "define q where \"q=map_poly Im pp\""], ["proof (state)\nthis:\n  q = map_poly Im pp\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "define f where \"f=(\\<lambda>t. poly q t / poly p t)\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. poly q t / poly p t)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "have sgnx_top:\"sgnx (poly p) at_top = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) at_top = 1", "unfolding sgnx_poly_at_top sgn_pos_inf_def p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (lead_coeff (map_poly Re pp)) = 1", "using \\<open>lead_coeff pp=1\\<close>"], ["proof (prove)\nusing this:\n  lead_coeff pp = 1\n\ngoal (1 subgoal):\n 1. sgn (lead_coeff (map_poly Re pp)) = 1", "by (subst lead_coeff_map_poly_nz,auto)"], ["proof (state)\nthis:\n  sgnx (poly p) at_top = 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "have not_g_image:\"0 \\<notin> path_image (g r)\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (g r)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<notin> path_image (g r) \\<Longrightarrow> False", "assume \"\\<not> 0 \\<notin> path_image (g r)\""], ["proof (state)\nthis:\n  \\<not> 0 \\<notin> path_image (g r)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<notin> path_image (g r) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<notin> path_image (g r)", "obtain x where \"poly pp x=0\" \"x\\<in>closed_segment (- of_real r) (of_real r)\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<notin> path_image (g r)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>poly pp x = 0;\n         x \\<in> closed_segment (- complex_of_real r)\n                  (complex_of_real r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding g_def path_image_compose of_real_linepath"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<notin> poly pp `\n                    path_image\n                     (linepath (complex_of_real (- r))\n                       (complex_of_real (of_real r)))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>poly pp x = 0;\n         x \\<in> closed_segment (- complex_of_real r)\n                  (complex_of_real r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly pp x = 0\n  x \\<in> closed_segment (- complex_of_real r) (complex_of_real r)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<notin> path_image (g r) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly pp x = 0\n  x \\<in> closed_segment (- complex_of_real r) (complex_of_real r)", "have \"Im x=0\" \"x\\<in>proots pp\""], ["proof (prove)\nusing this:\n  poly pp x = 0\n  x \\<in> closed_segment (- complex_of_real r) (complex_of_real r)\n\ngoal (1 subgoal):\n 1. Im x = 0 &&& x \\<in> proots pp", "using closed_segment_imp_Re_Im(2)"], ["proof (prove)\nusing this:\n  poly pp x = 0\n  x \\<in> closed_segment (- complex_of_real r) (complex_of_real r)\n  \\<lbrakk>?x \\<in> closed_segment ?lb ?ub; Im ?lb \\<le> Im ?ub\\<rbrakk>\n  \\<Longrightarrow> Im ?lb \\<le> Im ?x \\<and> Im ?x \\<le> Im ?ub\n\ngoal (1 subgoal):\n 1. Im x = 0 &&& x \\<in> proots pp", "unfolding proots_def"], ["proof (prove)\nusing this:\n  poly pp x = 0\n  x \\<in> closed_segment (- complex_of_real r) (complex_of_real r)\n  \\<lbrakk>?x \\<in> closed_segment ?lb ?ub; Im ?lb \\<le> Im ?ub\\<rbrakk>\n  \\<Longrightarrow> Im ?lb \\<le> Im ?x \\<and> Im ?x \\<le> Im ?ub\n\ngoal (1 subgoal):\n 1. Im x = 0 &&& x \\<in> {x. poly pp x = 0}", "by fastforce+"], ["proof (state)\nthis:\n  Im x = 0\n  x \\<in> proots pp\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<notin> path_image (g r) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Im x = 0\n  x \\<in> proots pp", "show False"], ["proof (prove)\nusing this:\n  Im x = 0\n  x \\<in> proots pp\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<forall>x\\<in>proots pp. Im x\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  Im x = 0\n  x \\<in> proots pp\n  \\<forall>x\\<in>proots pp. Im x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<notin> path_image (g ?r)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "have arctan_f_tendsto:\"((\\<lambda>r. (arctan (f r) -  arctan (f (-r))) / pi) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "proof (cases \"degree p>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top\n 2. \\<not> 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "case True"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (2 subgoals):\n 1. 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top\n 2. \\<not> 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "have \"degree p>degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q < degree p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree q < degree p", "have \"degree p=degree pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = degree pp", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly Re pp) = degree pp", "using \\<open>lead_coeff pp=1\\<close>"], ["proof (prove)\nusing this:\n  lead_coeff pp = 1\n\ngoal (1 subgoal):\n 1. degree (map_poly Re pp) = degree pp", "by (auto intro:map_poly_degree_eq)"], ["proof (state)\nthis:\n  degree p = degree pp\n\ngoal (1 subgoal):\n 1. degree q < degree p", "moreover"], ["proof (state)\nthis:\n  degree p = degree pp\n\ngoal (1 subgoal):\n 1. degree q < degree p", "then"], ["proof (chain)\npicking this:\n  degree p = degree pp", "have \"degree q<degree pp\""], ["proof (prove)\nusing this:\n  degree p = degree pp\n\ngoal (1 subgoal):\n 1. degree q < degree pp", "unfolding q_def"], ["proof (prove)\nusing this:\n  degree p = degree pp\n\ngoal (1 subgoal):\n 1. degree (map_poly Im pp) < degree pp", "using \\<open>lead_coeff pp=1\\<close> True"], ["proof (prove)\nusing this:\n  degree p = degree pp\n  lead_coeff pp = 1\n  0 < degree p\n\ngoal (1 subgoal):\n 1. degree (map_poly Im pp) < degree pp", "by (auto intro!:map_poly_degree_less)"], ["proof (state)\nthis:\n  degree q < degree pp\n\ngoal (1 subgoal):\n 1. degree q < degree p", "ultimately"], ["proof (chain)\npicking this:\n  degree p = degree pp\n  degree q < degree pp", "show ?thesis"], ["proof (prove)\nusing this:\n  degree p = degree pp\n  degree q < degree pp\n\ngoal (1 subgoal):\n 1. degree q < degree p", "by auto"], ["proof (state)\nthis:\n  degree q < degree p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree q < degree p\n\ngoal (2 subgoals):\n 1. 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top\n 2. \\<not> 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "then"], ["proof (chain)\npicking this:\n  degree q < degree p", "have \"(f \\<longlongrightarrow> 0) at_infinity\""], ["proof (prove)\nusing this:\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> 0) at_infinity", "unfolding f_def"], ["proof (prove)\nusing this:\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. poly q t / poly p t) \\<longlongrightarrow> 0) at_infinity", "using poly_divide_tendsto_0_at_infinity"], ["proof (prove)\nusing this:\n  degree q < degree p\n  degree ?q < degree ?p \\<Longrightarrow>\n  ((\\<lambda>x. poly ?q x / poly ?p x) \\<longlongrightarrow> (0::?'a))\n   at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. poly q t / poly p t) \\<longlongrightarrow> 0) at_infinity", "by auto"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> 0) at_infinity\n\ngoal (2 subgoals):\n 1. 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top\n 2. \\<not> 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "then"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> 0) at_infinity", "have \"(f \\<longlongrightarrow> 0) at_bot\" \"(f \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> 0) at_infinity\n\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> 0) at_bot &&&\n    (f \\<longlongrightarrow> 0) at_top", "by (auto elim!:filterlim_mono simp add:at_top_le_at_infinity at_bot_le_at_infinity)"], ["proof (state)\nthis:\n  (f \\<longlongrightarrow> 0) at_bot\n  (f \\<longlongrightarrow> 0) at_top\n\ngoal (2 subgoals):\n 1. 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top\n 2. \\<not> 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "then"], ["proof (chain)\npicking this:\n  (f \\<longlongrightarrow> 0) at_bot\n  (f \\<longlongrightarrow> 0) at_top", "have \"((\\<lambda>r. arctan (f r))\\<longlongrightarrow> 0) at_top\" \"((\\<lambda>r. arctan (f (-r)))\\<longlongrightarrow> 0) at_top\""], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> 0) at_bot\n  (f \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. arctan (f r)) \\<longlongrightarrow> 0) at_top &&&\n    ((\\<lambda>r. arctan (f (- r))) \\<longlongrightarrow> 0) at_top", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(f \\<longlongrightarrow> 0) at_bot;\n     (f \\<longlongrightarrow> 0) at_top\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>r. arctan (f r)) \\<longlongrightarrow> 0)\n                       at_top\n 2. \\<lbrakk>(f \\<longlongrightarrow> 0) at_bot;\n     (f \\<longlongrightarrow> 0) at_top\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>r. arctan (f (- r))) \\<longlongrightarrow>\n                       0)\n                       at_top", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f \\<longlongrightarrow> 0) at_bot;\n     (f \\<longlongrightarrow> 0) at_top\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>r. arctan (f r)) \\<longlongrightarrow> 0)\n                       at_top", "by (auto intro:tendsto_eq_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f \\<longlongrightarrow> 0) at_bot;\n     (f \\<longlongrightarrow> 0) at_top\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>r. arctan (f (- r))) \\<longlongrightarrow>\n                       0)\n                       at_top", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f \\<longlongrightarrow> 0) at_bot;\n     (f \\<longlongrightarrow> 0) at_top\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>r. arctan (f (- r))) \\<longlongrightarrow>\n                       0)\n                       at_top", "apply (subst tendsto_compose_filtermap[of _ uminus,unfolded comp_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f \\<longlongrightarrow> 0) at_bot;\n     (f \\<longlongrightarrow> 0) at_top\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>a. arctan (f a)) \\<longlongrightarrow> 0)\n                       (filtermap uminus at_top)", "by (auto intro:tendsto_eq_intros simp add:at_bot_mirror[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>r. arctan (f r)) \\<longlongrightarrow> 0) at_top\n  ((\\<lambda>r. arctan (f (- r))) \\<longlongrightarrow> 0) at_top\n\ngoal (2 subgoals):\n 1. 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top\n 2. \\<not> 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>r. arctan (f r)) \\<longlongrightarrow> 0) at_top\n  ((\\<lambda>r. arctan (f (- r))) \\<longlongrightarrow> 0) at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>r. arctan (f r)) \\<longlongrightarrow> 0) at_top\n  ((\\<lambda>r. arctan (f (- r))) \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "by (auto intro:tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal (1 subgoal):\n 1. \\<not> 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < degree p\n\ngoal (1 subgoal):\n 1. \\<not> 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "obtain c where \"f=(\\<lambda>r. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f = (\\<lambda>r. c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f = (\\<lambda>r. c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"degree p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = 0", "using False"], ["proof (prove)\nusing this:\n  \\<not> 0 < degree p\n\ngoal (1 subgoal):\n 1. degree p = 0", "by auto"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f = (\\<lambda>r. c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f = (\\<lambda>r. c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"degree q\\<le>degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q \\<le> degree p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree q \\<le> degree p", "have \"degree p=degree pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = degree pp", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly Re pp) = degree pp", "using \\<open>lead_coeff pp=1\\<close>"], ["proof (prove)\nusing this:\n  lead_coeff pp = 1\n\ngoal (1 subgoal):\n 1. degree (map_poly Re pp) = degree pp", "by (auto intro:map_poly_degree_eq)"], ["proof (state)\nthis:\n  degree p = degree pp\n\ngoal (1 subgoal):\n 1. degree q \\<le> degree p", "moreover"], ["proof (state)\nthis:\n  degree p = degree pp\n\ngoal (1 subgoal):\n 1. degree q \\<le> degree p", "have \"degree q\\<le>degree pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q \\<le> degree pp", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly Im pp) \\<le> degree pp", "by simp"], ["proof (state)\nthis:\n  degree q \\<le> degree pp\n\ngoal (1 subgoal):\n 1. degree q \\<le> degree p", "ultimately"], ["proof (chain)\npicking this:\n  degree p = degree pp\n  degree q \\<le> degree pp", "show ?thesis"], ["proof (prove)\nusing this:\n  degree p = degree pp\n  degree q \\<le> degree pp\n\ngoal (1 subgoal):\n 1. degree q \\<le> degree p", "by auto"], ["proof (state)\nthis:\n  degree q \\<le> degree p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree q \\<le> degree p\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f = (\\<lambda>r. c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  degree p = 0\n  degree q \\<le> degree p", "have \"degree q=0\""], ["proof (prove)\nusing this:\n  degree p = 0\n  degree q \\<le> degree p\n\ngoal (1 subgoal):\n 1. degree q = 0", "by simp"], ["proof (state)\nthis:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f = (\\<lambda>r. c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  degree q = 0", "obtain pa qa where \"p=[:pa:]\" \"q=[:qa:]\""], ["proof (prove)\nusing this:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. (\\<And>pa qa.\n        \\<lbrakk>p = [:pa:]; q = [:qa:]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>degree p=0\\<close>"], ["proof (prove)\nusing this:\n  degree q = 0\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>pa qa.\n        \\<lbrakk>p = [:pa:]; q = [:qa:]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson degree_eq_zeroE)"], ["proof (state)\nthis:\n  p = [:pa:]\n  q = [:qa:]\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f = (\\<lambda>r. c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  p = [:pa:]\n  q = [:qa:]", "show ?thesis"], ["proof (prove)\nusing this:\n  p = [:pa:]\n  q = [:qa:]\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  p = [:pa:]\n  q = [:qa:]\n  f = (\\<lambda>r. ?c) \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "unfolding f_def"], ["proof (prove)\nusing this:\n  p = [:pa:]\n  q = [:qa:]\n  (\\<lambda>t. poly q t / poly p t) = (\\<lambda>r. ?c) \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = (\\<lambda>r. c)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < degree p \\<Longrightarrow>\n    ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "then"], ["proof (chain)\npicking this:\n  f = (\\<lambda>r. c)", "show ?thesis"], ["proof (prove)\nusing this:\n  f = (\\<lambda>r. c)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n     0)\n     at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "have [simp]:\"valid_path (g r)\" \"path (g r)\" \"finite_ReZ_segments (g r) 0\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (g r) &&& path (g r) &&& finite_ReZ_segments (g r) 0", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_path (g r)\n 2. path (g r)\n 3. finite_ReZ_segments (g r) 0", "show \"valid_path (g r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (g r)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path\n     (poly pp \\<circ>\n      (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x)))", "apply (rule valid_path_compose_holomorphic[where S=UNIV])"], ["proof (prove)\ngoal (4 subgoals):\n 1. valid_path (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x))\n 2. poly pp holomorphic_on UNIV\n 3. open UNIV\n 4. path_image (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x))\n    \\<subseteq> UNIV", "by (auto simp add:of_real_linepath)"], ["proof (state)\nthis:\n  valid_path (g r)\n\ngoal (2 subgoals):\n 1. path (g r)\n 2. finite_ReZ_segments (g r) 0", "then"], ["proof (chain)\npicking this:\n  valid_path (g r)", "show \"path (g r)\""], ["proof (prove)\nusing this:\n  valid_path (g r)\n\ngoal (1 subgoal):\n 1. path (g r)", "using valid_path_imp_path"], ["proof (prove)\nusing this:\n  valid_path (g r)\n  valid_path ?g \\<Longrightarrow> path ?g\n\ngoal (1 subgoal):\n 1. path (g r)", "by auto"], ["proof (state)\nthis:\n  path (g r)\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g r) 0", "show \"finite_ReZ_segments (g r) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (g r) 0", "unfolding g_def of_real_linepath"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments\n     (poly pp \\<circ>\n      linepath (complex_of_real (- r)) (complex_of_real (of_real r)))\n     0", "using finite_ReZ_segments_poly_linepath"], ["proof (prove)\nusing this:\n  finite_ReZ_segments (poly ?p \\<circ> linepath ?a ?b) ?z\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments\n     (poly pp \\<circ>\n      linepath (complex_of_real (- r)) (complex_of_real (of_real r)))\n     0", "by simp"], ["proof (state)\nthis:\n  finite_ReZ_segments (g r) 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path (g ?r)\n  path (g ?r)\n  finite_ReZ_segments (g ?r) 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "have g_f_eq:\"Im (g r t) / Re (g r t) = (f o (\\<lambda>x. 2*r*x - r)) t\" for r t"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (g r t) / Re (g r t) = (f \\<circ> (\\<lambda>x. 2 * r * x - r)) t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im (g r t) / Re (g r t) = (f \\<circ> (\\<lambda>x. 2 * r * x - r)) t", "have \"Im (g r t) / Re (g r t) = Im ((poly pp o of_real o (\\<lambda>x. 2*r*x - r)) t) \n        / Re ((poly pp o of_real o (\\<lambda>x. 2*r*x - r)) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (g r t) / Re (g r t) =\n    Im ((poly pp \\<circ> complex_of_real \\<circ>\n         (\\<lambda>x. 2 * r * x - r))\n         t) /\n    Re ((poly pp \\<circ> complex_of_real \\<circ>\n         (\\<lambda>x. 2 * r * x - r))\n         t)", "unfolding g_def linepath_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (poly pp\n         (complex_of_real\n           ((1 - t) *\\<^sub>R - r + t *\\<^sub>R of_real r))) /\n    Re (poly pp\n         (complex_of_real\n           ((1 - t) *\\<^sub>R - r + t *\\<^sub>R of_real r))) =\n    Im (poly pp (complex_of_real (2 * r * t - r))) /\n    Re (poly pp (complex_of_real (2 * r * t - r)))", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  Im (g r t) / Re (g r t) =\n  Im ((poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r))\n       t) /\n  Re ((poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r))\n       t)\n\ngoal (1 subgoal):\n 1. Im (g r t) / Re (g r t) = (f \\<circ> (\\<lambda>x. 2 * r * x - r)) t", "also"], ["proof (state)\nthis:\n  Im (g r t) / Re (g r t) =\n  Im ((poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r))\n       t) /\n  Re ((poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r))\n       t)\n\ngoal (1 subgoal):\n 1. Im (g r t) / Re (g r t) = (f \\<circ> (\\<lambda>x. 2 * r * x - r)) t", "have \"... = (f o (\\<lambda>x. 2*r*x - r)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im ((poly pp \\<circ> complex_of_real \\<circ>\n         (\\<lambda>x. 2 * r * x - r))\n         t) /\n    Re ((poly pp \\<circ> complex_of_real \\<circ>\n         (\\<lambda>x. 2 * r * x - r))\n         t) =\n    (f \\<circ> (\\<lambda>x. 2 * r * x - r)) t", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (poly pp (complex_of_real (2 * r * t - r))) /\n    Re (poly pp (complex_of_real (2 * r * t - r))) =\n    f (2 * r * t - r)", "by (simp only:Im_poly_of_real diff_0_right Re_poly_of_real f_def q_def p_def)"], ["proof (state)\nthis:\n  Im ((poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r))\n       t) /\n  Re ((poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r))\n       t) =\n  (f \\<circ> (\\<lambda>x. 2 * r * x - r)) t\n\ngoal (1 subgoal):\n 1. Im (g r t) / Re (g r t) = (f \\<circ> (\\<lambda>x. 2 * r * x - r)) t", "finally"], ["proof (chain)\npicking this:\n  Im (g r t) / Re (g r t) = (f \\<circ> (\\<lambda>x. 2 * r * x - r)) t", "show ?thesis"], ["proof (prove)\nusing this:\n  Im (g r t) / Re (g r t) = (f \\<circ> (\\<lambda>x. 2 * r * x - r)) t\n\ngoal (1 subgoal):\n 1. Im (g r t) / Re (g r t) = (f \\<circ> (\\<lambda>x. 2 * r * x - r)) t", "."], ["proof (state)\nthis:\n  Im (g r t) / Re (g r t) = (f \\<circ> (\\<lambda>x. 2 * r * x - r)) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (g ?r ?t) / Re (g ?r ?t) = (f \\<circ> (\\<lambda>x. 2 * ?r * x - ?r)) ?t\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "have ?thesis when \"proots p={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "have \"\\<forall>\\<^sub>Fr in at_top. 2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0\n        = (arctan (f r) -  arctan (f (-r))) / pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n       (arctan (f r) - arctan (f (- r))) / pi", "proof (rule eventually_at_top_linorderI[of 1])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "fix r::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "assume \"r\\<ge>1\""], ["proof (state)\nthis:\n  1 \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "have image_pos:\"\\<forall>p\\<in>path_image (g r).  0<Re p \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (g r). 0 < Re p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>p\\<in>path_image (g r). 0 < Re p) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>p\\<in>path_image (g r). 0 < Re p)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>p\\<in>path_image (g r). 0 < Re p)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>p\\<in>path_image (g r). 0 < Re p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>p\\<in>path_image (g r). 0 < Re p)", "obtain t where \"poly p t\\<le>0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>p\\<in>path_image (g r). 0 < Re p)\n\ngoal (1 subgoal):\n 1. (\\<And>t. poly p t \\<le> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding g_def path_image_compose of_real_linepath p_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>p\\<in>poly pp `\n                         path_image\n                          (linepath (complex_of_real (- r))\n                            (complex_of_real (of_real r))).\n             0 < Re p)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        poly (map_poly Re pp) t \\<le> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Re_poly_of_real"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>p\\<in>poly pp `\n                         path_image\n                          (linepath (complex_of_real (- r))\n                            (complex_of_real (of_real r))).\n             0 < Re p)\n  Re (poly ?p (complex_of_real ?x)) = poly (map_poly Re ?p) ?x\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        poly (map_poly Re pp) t \\<le> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (simp add:closed_segment_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                poly (map_poly Re pp) t \\<le> 0 \\<Longrightarrow> thesis;\n     \\<exists>p.\n        (\\<exists>u.\n            p =\n            u *\\<^sub>R complex_of_real r -\n            (1 - u) *\\<^sub>R complex_of_real r \\<and>\n            0 \\<le> u \\<and> u \\<le> 1) \\<and>\n        \\<not> 0 < Re (poly pp p);\n     \\<And>p x.\n        Re (poly p (complex_of_real x)) = poly (map_poly Re p) x\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis not_less of_real_def real_vector.scale_scale scaleR_left_diff_distrib)"], ["proof (state)\nthis:\n  poly p t \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>p\\<in>path_image (g r). 0 < Re p) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  poly p t \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>p\\<in>path_image (g r). 0 < Re p) \\<Longrightarrow>\n    False", "have False when \"poly p t<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"sgnx (poly p) (at_right t) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right t) = - 1", "using sgnx_poly_nz that"], ["proof (prove)\nusing this:\n  poly ?p ?x \\<noteq> 0 \\<Longrightarrow>\n  sgnx (poly ?p) (at_left ?x) = sgn (poly ?p ?x)\n  poly ?p ?x \\<noteq> 0 \\<Longrightarrow>\n  sgnx (poly ?p) (at_right ?x) = sgn (poly ?p ?x)\n  poly p t < 0\n\ngoal (1 subgoal):\n 1. sgnx (poly p) (at_right t) = - 1", "by auto"], ["proof (state)\nthis:\n  sgnx (poly p) (at_right t) = - 1\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  sgnx (poly p) (at_right t) = - 1", "obtain x where \"x>t\" \"poly p x = 0\""], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right t) = - 1\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>t < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sgnx_at_top_IVT[of p t] sgnx_top"], ["proof (prove)\nusing this:\n  sgnx (poly p) (at_right t) = - 1\n  sgnx (poly p) (at_right t) \\<noteq> sgnx (poly p) at_top \\<Longrightarrow>\n  \\<exists>x>t. poly p x = 0\n  sgnx (poly p) at_top = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>t < x; poly p x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t < x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  t < x\n  poly p x = 0", "have \"x\\<in>proots p\""], ["proof (prove)\nusing this:\n  t < x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> proots p", "unfolding proots_def"], ["proof (prove)\nusing this:\n  t < x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> {x. poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  x \\<in> proots p\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  x \\<in> proots p", "show False"], ["proof (prove)\nusing this:\n  x \\<in> proots p\n\ngoal (1 subgoal):\n 1. False", "using \\<open>proots p={}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> proots p\n  proots p = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p t < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>p\\<in>path_image (g r). 0 < Re p) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  poly p t < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>p\\<in>path_image (g r). 0 < Re p) \\<Longrightarrow>\n    False", "have False when \"poly p t=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using \\<open>proots p={}\\<close> that"], ["proof (prove)\nusing this:\n  proots p = {}\n  poly p t = 0\n\ngoal (1 subgoal):\n 1. False", "unfolding proots_def"], ["proof (prove)\nusing this:\n  {x. poly p x = 0} = {}\n  poly p t = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  poly p t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>p\\<in>path_image (g r). 0 < Re p) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  poly p t \\<le> 0\n  poly p t < 0 \\<Longrightarrow> False\n  poly p t = 0 \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  poly p t \\<le> 0\n  poly p t < 0 \\<Longrightarrow> False\n  poly p t = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p\\<in>path_image (g r). 0 < Re p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "have \"Re (winding_number (g r) 0) = (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) \n          / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number (g r) 0) =\n    (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) / (2 * pi)", "apply (rule Re_winding_number_half_right[of \"g r\" 0,simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>p\\<in>path_image (g r). 0 \\<le> Re p\n 2. 0 \\<notin> path_image (g r)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (g r). 0 \\<le> Re p", "using image_pos"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>path_image (g r). 0 < Re p\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image (g r). 0 \\<le> Re p", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (g r)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (g r)", "by (auto simp add:not_g_image)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re (winding_number (g r) 0) =\n  (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "also"], ["proof (state)\nthis:\n  Re (winding_number (g r) 0) =\n  (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "have \"... = (arctan (f r) - arctan (f (-r)))/(2*pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) / (2 * pi) =\n    (arctan (f r) - arctan (f (- r))) / (2 * pi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) / (2 * pi) =\n    (arctan (f r) - arctan (f (- r))) / (2 * pi)", "have \"Im (Ln (pathfinish (g r))) = arctan (f r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish (g r))) = arctan (f r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish (g r))) = arctan (f r)", "have \"Re (pathfinish (g r)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Re (pathfinish (g r))", "by (auto intro: image_pos[rule_format])"], ["proof (state)\nthis:\n  0 < Re (pathfinish (g r))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish (g r))) = arctan (f r)", "then"], ["proof (chain)\npicking this:\n  0 < Re (pathfinish (g r))", "have \"Im (Ln (pathfinish (g r))) \n              = arctan (Im (pathfinish (g r)) / Re (pathfinish (g r)))\""], ["proof (prove)\nusing this:\n  0 < Re (pathfinish (g r))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish (g r))) =\n    arctan (Im (pathfinish (g r)) / Re (pathfinish (g r)))", "by (subst Im_Ln_eq,auto)"], ["proof (state)\nthis:\n  Im (Ln (pathfinish (g r))) =\n  arctan (Im (pathfinish (g r)) / Re (pathfinish (g r)))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish (g r))) = arctan (f r)", "also"], ["proof (state)\nthis:\n  Im (Ln (pathfinish (g r))) =\n  arctan (Im (pathfinish (g r)) / Re (pathfinish (g r)))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish (g r))) = arctan (f r)", "have \"... = arctan (f r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arctan (Im (pathfinish (g r)) / Re (pathfinish (g r))) = arctan (f r)", "unfolding path_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. arctan (Im (g r 1) / Re (g r 1)) = arctan (f r)", "by (subst g_f_eq,auto)"], ["proof (state)\nthis:\n  arctan (Im (pathfinish (g r)) / Re (pathfinish (g r))) = arctan (f r)\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish (g r))) = arctan (f r)", "finally"], ["proof (chain)\npicking this:\n  Im (Ln (pathfinish (g r))) = arctan (f r)", "show ?thesis"], ["proof (prove)\nusing this:\n  Im (Ln (pathfinish (g r))) = arctan (f r)\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish (g r))) = arctan (f r)", "."], ["proof (state)\nthis:\n  Im (Ln (pathfinish (g r))) = arctan (f r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (Ln (pathfinish (g r))) = arctan (f r)\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) / (2 * pi) =\n    (arctan (f r) - arctan (f (- r))) / (2 * pi)", "moreover"], ["proof (state)\nthis:\n  Im (Ln (pathfinish (g r))) = arctan (f r)\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) / (2 * pi) =\n    (arctan (f r) - arctan (f (- r))) / (2 * pi)", "have \"Im (Ln (pathstart (g r))) = arctan (f (-r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (pathstart (g r))) = arctan (f (- r))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im (Ln (pathstart (g r))) = arctan (f (- r))", "have \"Re (pathstart (g r)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Re (pathstart (g r))", "by (auto intro: image_pos[rule_format])"], ["proof (state)\nthis:\n  0 < Re (pathstart (g r))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart (g r))) = arctan (f (- r))", "then"], ["proof (chain)\npicking this:\n  0 < Re (pathstart (g r))", "have \"Im (Ln (pathstart (g r))) \n              = arctan (Im (pathstart (g r)) / Re (pathstart (g r)))\""], ["proof (prove)\nusing this:\n  0 < Re (pathstart (g r))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart (g r))) =\n    arctan (Im (pathstart (g r)) / Re (pathstart (g r)))", "by (subst Im_Ln_eq,auto)"], ["proof (state)\nthis:\n  Im (Ln (pathstart (g r))) =\n  arctan (Im (pathstart (g r)) / Re (pathstart (g r)))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart (g r))) = arctan (f (- r))", "also"], ["proof (state)\nthis:\n  Im (Ln (pathstart (g r))) =\n  arctan (Im (pathstart (g r)) / Re (pathstart (g r)))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart (g r))) = arctan (f (- r))", "have \"... = arctan (f (-r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arctan (Im (pathstart (g r)) / Re (pathstart (g r))) = arctan (f (- r))", "unfolding path_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. arctan (Im (g r 0) / Re (g r 0)) = arctan (f (- r))", "by (subst g_f_eq,auto)"], ["proof (state)\nthis:\n  arctan (Im (pathstart (g r)) / Re (pathstart (g r))) = arctan (f (- r))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart (g r))) = arctan (f (- r))", "finally"], ["proof (chain)\npicking this:\n  Im (Ln (pathstart (g r))) = arctan (f (- r))", "show ?thesis"], ["proof (prove)\nusing this:\n  Im (Ln (pathstart (g r))) = arctan (f (- r))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart (g r))) = arctan (f (- r))", "."], ["proof (state)\nthis:\n  Im (Ln (pathstart (g r))) = arctan (f (- r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (Ln (pathstart (g r))) = arctan (f (- r))\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) / (2 * pi) =\n    (arctan (f r) - arctan (f (- r))) / (2 * pi)", "ultimately"], ["proof (chain)\npicking this:\n  Im (Ln (pathfinish (g r))) = arctan (f r)\n  Im (Ln (pathstart (g r))) = arctan (f (- r))", "show ?thesis"], ["proof (prove)\nusing this:\n  Im (Ln (pathfinish (g r))) = arctan (f r)\n  Im (Ln (pathstart (g r))) = arctan (f (- r))\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) / (2 * pi) =\n    (arctan (f r) - arctan (f (- r))) / (2 * pi)", "by auto"], ["proof (state)\nthis:\n  (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) / (2 * pi) =\n  (arctan (f r) - arctan (f (- r))) / (2 * pi)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Im (Ln (pathfinish (g r))) - Im (Ln (pathstart (g r)))) / (2 * pi) =\n  (arctan (f r) - arctan (f (- r))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "finally"], ["proof (chain)\npicking this:\n  Re (winding_number (g r) 0) = (arctan (f r) - arctan (f (- r))) / (2 * pi)", "have \"Re (winding_number (g r) 0) = (arctan (f r) - arctan (f (-r)))/(2*pi)\""], ["proof (prove)\nusing this:\n  Re (winding_number (g r) 0) = (arctan (f r) - arctan (f (- r))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number (g r) 0) =\n    (arctan (f r) - arctan (f (- r))) / (2 * pi)", "."], ["proof (state)\nthis:\n  Re (winding_number (g r) 0) = (arctan (f r) - arctan (f (- r))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "moreover"], ["proof (state)\nthis:\n  Re (winding_number (g r) 0) = (arctan (f r) - arctan (f (- r))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "have \"cindex_pathE (g r) 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 = 0", "have \"cindex_pathE (g r) 0 = cindex_pathE (poly pp o of_real o (\\<lambda>x. 2*r*x - r)) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 =\n    cindex_pathE\n     (poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r)) 0", "unfolding g_def linepath_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE\n     (\\<lambda>x.\n         poly pp\n          (complex_of_real ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n     0 =\n    cindex_pathE (\\<lambda>x. poly pp (complex_of_real (2 * r * x - r))) 0", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cindex_pathE (g r) 0 =\n  cindex_pathE\n   (poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r)) 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 = 0", "also"], ["proof (state)\nthis:\n  cindex_pathE (g r) 0 =\n  cindex_pathE\n   (poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r)) 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 = 0", "have \"... = cindexE 0 1 (f o (\\<lambda>x. 2*r*x - r)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE\n     (poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r))\n     0 =\n    cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r))", "unfolding cindex_pathE_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t.\n         Im (poly pp (complex_of_real (2 * r * t - r)) - 0) /\n         Re (poly pp (complex_of_real (2 * r * t - r)) - 0)) =\n    cindexE 0 1 (\\<lambda>x. f (2 * r * x - r))", "by (simp only:Im_poly_of_real diff_0_right Re_poly_of_real f_def q_def p_def)"], ["proof (state)\nthis:\n  cindex_pathE\n   (poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r)) 0 =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r))\n\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 = 0", "also"], ["proof (state)\nthis:\n  cindex_pathE\n   (poly pp \\<circ> complex_of_real \\<circ> (\\<lambda>x. 2 * r * x - r)) 0 =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r))\n\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 = 0", "have \"... = cindexE (-r) r f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r)) = cindexE (- r) r f", "apply (subst cindexE_linear_comp[of \"2*r\" 0 1 _ \"-r\",simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. r \\<noteq> 0\n 2. (if 0 < r then cindexE (2 * r * 0 + - r) (2 * r * 1 + - r) f\n     else - cindexE (2 * r * 1 + - r) (2 * r * 0 + - r) f) =\n    cindexE (- r) r f", "using \\<open>r\\<ge>1\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> r\n\ngoal (2 subgoals):\n 1. r \\<noteq> 0\n 2. (if 0 < r then cindexE (2 * r * 0 + - r) (2 * r * 1 + - r) f\n     else - cindexE (2 * r * 1 + - r) (2 * r * 0 + - r) f) =\n    cindexE (- r) r f", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r)) = cindexE (- r) r f\n\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 = 0", "also"], ["proof (state)\nthis:\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r)) = cindexE (- r) r f\n\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (- r) r f = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE (- r) r f = 0", "have \"jumpF f (at_left x) =0\" \"jumpF f (at_right x) = 0\" when \"x\\<in>{-r..r}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "have \"poly p x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0", "using \\<open>proots p={}\\<close>"], ["proof (prove)\nusing this:\n  proots p = {}\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0", "unfolding proots_def"], ["proof (prove)\nusing this:\n  {x. poly p x = 0} = {}\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. jumpF f (at_left x) = 0\n 2. jumpF f (at_right x) = 0", "then"], ["proof (chain)\npicking this:\n  poly p x \\<noteq> 0", "show \"jumpF f (at_left x) =0\" \"jumpF f (at_right x) = 0\""], ["proof (prove)\nusing this:\n  poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_left x) = 0 &&& jumpF f (at_right x) = 0", "unfolding f_def"], ["proof (prove)\nusing this:\n  poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. poly q t / poly p t) (at_left x) = 0 &&&\n    jumpF (\\<lambda>t. poly q t / poly p t) (at_right x) = 0", "by (auto intro!: jumpF_not_infinity continuous_intros)"], ["proof (state)\nthis:\n  jumpF f (at_left x) = 0\n  jumpF f (at_right x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {- r..r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {- r..r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. cindexE (- r) r f = 0", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {- r..r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {- r..r} \\<Longrightarrow> jumpF f (at_right ?x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> {- r..r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {- r..r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. cindexE (- r) r f = 0", "unfolding cindexE_def"], ["proof (prove)\nusing this:\n  ?x \\<in> {- r..r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  ?x \\<in> {- r..r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               - r \\<le> x \\<and> x < r.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n               - r < x \\<and> x \\<le> r.\n       jumpF f (at_left x)) =\n    0", "by auto"], ["proof (state)\nthis:\n  cindexE (- r) r f = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE (- r) r f = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 = 0", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE (g r) 0 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE (g r) 0 = 0\n\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 = 0", "."], ["proof (state)\nthis:\n  cindex_pathE (g r) 0 = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE (g r) 0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "ultimately"], ["proof (chain)\npicking this:\n  Re (winding_number (g r) 0) = (arctan (f r) - arctan (f (- r))) / (2 * pi)\n  cindex_pathE (g r) 0 = 0", "show \"2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 \n          = (arctan (f r) -  arctan (f (-r))) / pi\""], ["proof (prove)\nusing this:\n  Re (winding_number (g r) 0) = (arctan (f r) - arctan (f (- r))) / (2 * pi)\n  cindex_pathE (g r) 0 = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n    (arctan (f r) - arctan (f (- r))) / pi", "unfolding path_defs"], ["proof (prove)\nusing this:\n  Re (winding_number (g r) 0) = (arctan (f r) - arctan (f (- r))) / (2 * pi)\n  cindex_pathE (g r) 0 = 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n    (arctan (f r) - arctan (f (- r))) / pi", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n  (arctan (f r) - arctan (f (- r))) / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n     (arctan (f r) - arctan (f (- r))) / pi\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "with arctan_f_tendsto"], ["proof (chain)\npicking this:\n  ((\\<lambda>r.\n       (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n   0)\n   at_top\n  \\<forall>\\<^sub>F r in at_top.\n     2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n     (arctan (f r) - arctan (f (- r))) / pi", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n   0)\n   at_top\n  \\<forall>\\<^sub>F r in at_top.\n     2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n     (arctan (f r) - arctan (f (- r))) / pi\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "by (auto dest:tendsto_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       2 * Re (winding_number (g r) 0) +\n       cindex_pathE (g r) 0) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots p = {} \\<Longrightarrow>\n  ((\\<lambda>r.\n       2 * Re (winding_number (g r) 0) +\n       cindex_pathE (g r) 0) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "moreover"], ["proof (state)\nthis:\n  proots p = {} \\<Longrightarrow>\n  ((\\<lambda>r.\n       2 * Re (winding_number (g r) 0) +\n       cindex_pathE (g r) 0) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "have ?thesis when \"proots p\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "define max_r where \"max_r=Max (proots p)\""], ["proof (state)\nthis:\n  max_r = Max (proots p)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "define min_r where \"min_r=Min (proots p)\""], ["proof (state)\nthis:\n  min_r = Min (proots p)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "have \"max_r \\<in>proots p\" \"min_r \\<in>proots p\" \"min_r\\<le>max_r\" and \n      min_max_bound:\"\\<forall>p\\<in>proots p. p\\<in>{min_r..max_r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (max_r \\<in> proots p &&&\n     min_r \\<in> proots p &&& min_r \\<le> max_r) &&&\n    \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. max_r \\<in> proots p\n 2. min_r \\<in> proots p\n 3. min_r \\<le> max_r\n 4. \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}", "have \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "have \"(0::real) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> 1", "by simp"], ["proof (state)\nthis:\n  0 \\<noteq> 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<noteq> 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by (metis (full_types) \\<open>p \\<equiv> map_poly Re pp\\<close> assms(2) coeff_0 coeff_map_poly one_complex.simps(1) zero_complex.sel(1))"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (4 subgoals):\n 1. max_r \\<in> proots p\n 2. min_r \\<in> proots p\n 3. min_r \\<le> max_r\n 4. \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"finite (proots p)\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (proots p)", "by auto"], ["proof (state)\nthis:\n  finite (proots p)\n\ngoal (4 subgoals):\n 1. max_r \\<in> proots p\n 2. min_r \\<in> proots p\n 3. min_r \\<le> max_r\n 4. \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}", "then"], ["proof (chain)\npicking this:\n  finite (proots p)", "show \"max_r \\<in>proots p\" \"min_r \\<in>proots p\""], ["proof (prove)\nusing this:\n  finite (proots p)\n\ngoal (1 subgoal):\n 1. max_r \\<in> proots p &&& min_r \\<in> proots p", "using Min_in Max_in that"], ["proof (prove)\nusing this:\n  finite (proots p)\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min ?A \\<in> ?A\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Max ?A \\<in> ?A\n  proots p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. max_r \\<in> proots p &&& min_r \\<in> proots p", "unfolding max_r_def min_r_def"], ["proof (prove)\nusing this:\n  finite (proots p)\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min ?A \\<in> ?A\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Max ?A \\<in> ?A\n  proots p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (proots p) \\<in> proots p &&& Min (proots p) \\<in> proots p", "by fast+"], ["proof (state)\nthis:\n  max_r \\<in> proots p\n  min_r \\<in> proots p\n\ngoal (2 subgoals):\n 1. min_r \\<le> max_r\n 2. \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}", "then"], ["proof (chain)\npicking this:\n  max_r \\<in> proots p\n  min_r \\<in> proots p", "show \"\\<forall>p\\<in>proots p. p\\<in>{min_r..max_r}\""], ["proof (prove)\nusing this:\n  max_r \\<in> proots p\n  min_r \\<in> proots p\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}", "using Min_le Max_ge \\<open>finite (proots p)\\<close>"], ["proof (prove)\nusing this:\n  max_r \\<in> proots p\n  min_r \\<in> proots p\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> Min ?A \\<le> ?x\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> ?x \\<le> Max ?A\n  finite (proots p)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}", "unfolding max_r_def min_r_def"], ["proof (prove)\nusing this:\n  Max (proots p) \\<in> proots p\n  Min (proots p) \\<in> proots p\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> Min ?A \\<le> ?x\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> ?x \\<le> Max ?A\n  finite (proots p)\n\ngoal (1 subgoal):\n 1. \\<forall>pa\\<in>proots p. pa \\<in> {Min (proots p)..Max (proots p)}", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}\n\ngoal (1 subgoal):\n 1. min_r \\<le> max_r", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}", "show \"min_r\\<le>max_r\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}\n\ngoal (1 subgoal):\n 1. min_r \\<le> max_r", "using \\<open>max_r\\<in>proots p\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}\n  max_r \\<in> proots p\n\ngoal (1 subgoal):\n 1. min_r \\<le> max_r", "by auto"], ["proof (state)\nthis:\n  min_r \\<le> max_r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max_r \\<in> proots p\n  min_r \\<in> proots p\n  min_r \\<le> max_r\n  \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "have \"\\<forall>\\<^sub>Fr in at_top. 2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0\n        = (arctan (f r) -  arctan (f (-r))) / pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n       (arctan (f r) - arctan (f (- r))) / pi", "proof (rule eventually_at_top_linorderI[of \"max (norm max_r) (norm min_r) + 1\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "assume r_asm:\"max (norm max_r) (norm min_r) + 1 \\<le> r\""], ["proof (state)\nthis:\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "then"], ["proof (chain)\npicking this:\n  max (norm max_r) (norm min_r) + 1 \\<le> r", "have \"r\\<noteq>0\" \"min_r>-r\" \"max_r<r\""], ["proof (prove)\nusing this:\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 &&& - r < min_r &&& max_r < r", "by auto"], ["proof (state)\nthis:\n  r \\<noteq> 0\n  - r < min_r\n  max_r < r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "define u where \"u=(min_r + r)/(2*r)\""], ["proof (state)\nthis:\n  u = (min_r + r) / (2 * r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "define v where \"v=(max_r + r)/(2*r)\""], ["proof (state)\nthis:\n  v = (max_r + r) / (2 * r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "have uv:\"u\\<in>{0..1}\" \"v\\<in>{0..1}\" \"u\\<le>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> {0..1} &&& v \\<in> {0..1} &&& u \\<le> v", "unfolding u_def v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (min_r + r) / (2 * r) \\<in> {0..1} &&&\n    (max_r + r) / (2 * r) \\<in> {0..1} &&&\n    (min_r + r) / (2 * r) \\<le> (max_r + r) / (2 * r)", "using r_asm  \\<open>min_r\\<le>max_r\\<close>"], ["proof (prove)\nusing this:\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n  min_r \\<le> max_r\n\ngoal (1 subgoal):\n 1. (min_r + r) / (2 * r) \\<in> {0..1} &&&\n    (max_r + r) / (2 * r) \\<in> {0..1} &&&\n    (min_r + r) / (2 * r) \\<le> (max_r + r) / (2 * r)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  u \\<in> {0..1}\n  v \\<in> {0..1}\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "define g1 where \"g1=subpath 0 u (g r)\""], ["proof (state)\nthis:\n  g1 = subpath 0 u (g r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "define g2 where \"g2=subpath u v (g r)\""], ["proof (state)\nthis:\n  g2 = subpath u v (g r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "define g3 where \"g3=subpath v 1 (g r)\""], ["proof (state)\nthis:\n  g3 = subpath v 1 (g r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "have \"path g1\" \"path g2\" \"path g3\" \"valid_path g1\" \"valid_path g2\" \"valid_path g3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (path g1 &&& path g2 &&& path g3) &&&\n    valid_path g1 &&& valid_path g2 &&& valid_path g3", "unfolding g1_def g2_def g3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (path (subpath 0 u (g r)) &&&\n     path (subpath u v (g r)) &&& path (subpath v 1 (g r))) &&&\n    valid_path (subpath 0 u (g r)) &&&\n    valid_path (subpath u v (g r)) &&& valid_path (subpath v 1 (g r))", "using uv"], ["proof (prove)\nusing this:\n  u \\<in> {0..1}\n  v \\<in> {0..1}\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. (path (subpath 0 u (g r)) &&&\n     path (subpath u v (g r)) &&& path (subpath v 1 (g r))) &&&\n    valid_path (subpath 0 u (g r)) &&&\n    valid_path (subpath u v (g r)) &&& valid_path (subpath v 1 (g r))", "by (auto intro!:path_subpath valid_path_subpath)"], ["proof (state)\nthis:\n  path g1\n  path g2\n  path g3\n  valid_path g1\n  valid_path g2\n  valid_path g3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "define wc_add where \"wc_add = (\\<lambda>g. 2*Re (winding_number g 0)  + cindex_pathE g 0)\""], ["proof (state)\nthis:\n  wc_add = (\\<lambda>g. 2 * Re (winding_number g 0) + cindex_pathE g 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "have \"wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3", "have \"winding_number (g r) 0 = winding_number g1 0 + winding_number g2 0 + winding_number g3 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (g r) 0 =\n    winding_number g1 0 + winding_number g2 0 + winding_number g3 0", "unfolding g1_def g2_def g3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (g r) 0 =\n    winding_number (subpath 0 u (g r)) 0 +\n    winding_number (subpath u v (g r)) 0 +\n    winding_number (subpath v 1 (g r)) 0", "using \\<open>u\\<in>{0..1}\\<close> \\<open>v\\<in>{0..1}\\<close> not_g_image"], ["proof (prove)\nusing this:\n  u \\<in> {0..1}\n  v \\<in> {0..1}\n  0 \\<notin> path_image (g ?r)\n\ngoal (1 subgoal):\n 1. winding_number (g r) 0 =\n    winding_number (subpath 0 u (g r)) 0 +\n    winding_number (subpath u v (g r)) 0 +\n    winding_number (subpath v 1 (g r)) 0", "by (subst winding_number_subpath_combine,simp_all)+"], ["proof (state)\nthis:\n  winding_number (g r) 0 =\n  winding_number g1 0 + winding_number g2 0 + winding_number g3 0\n\ngoal (1 subgoal):\n 1. wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3", "moreover"], ["proof (state)\nthis:\n  winding_number (g r) 0 =\n  winding_number g1 0 + winding_number g2 0 + winding_number g3 0\n\ngoal (1 subgoal):\n 1. wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3", "have \"cindex_pathE (g r) 0 = cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 =\n    cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0", "unfolding g1_def g2_def g3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 =\n    cindex_pathE (subpath 0 u (g r)) 0 +\n    cindex_pathE (subpath u v (g r)) 0 +\n    cindex_pathE (subpath v 1 (g r)) 0", "using \\<open>u\\<in>{0..1}\\<close> \\<open>v\\<in>{0..1}\\<close> \\<open>u\\<le>v\\<close> not_g_image"], ["proof (prove)\nusing this:\n  u \\<in> {0..1}\n  v \\<in> {0..1}\n  u \\<le> v\n  0 \\<notin> path_image (g ?r)\n\ngoal (1 subgoal):\n 1. cindex_pathE (g r) 0 =\n    cindex_pathE (subpath 0 u (g r)) 0 +\n    cindex_pathE (subpath u v (g r)) 0 +\n    cindex_pathE (subpath v 1 (g r)) 0", "by (subst cindex_pathE_subpath_combine,simp_all)+"], ["proof (state)\nthis:\n  cindex_pathE (g r) 0 =\n  cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0\n\ngoal (1 subgoal):\n 1. wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3", "ultimately"], ["proof (chain)\npicking this:\n  winding_number (g r) 0 =\n  winding_number g1 0 + winding_number g2 0 + winding_number g3 0\n  cindex_pathE (g r) 0 =\n  cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0", "show ?thesis"], ["proof (prove)\nusing this:\n  winding_number (g r) 0 =\n  winding_number g1 0 + winding_number g2 0 + winding_number g3 0\n  cindex_pathE (g r) 0 =\n  cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0\n\ngoal (1 subgoal):\n 1. wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3", "unfolding wc_add_def"], ["proof (prove)\nusing this:\n  winding_number (g r) 0 =\n  winding_number g1 0 + winding_number g2 0 + winding_number g3 0\n  cindex_pathE (g r) 0 =\n  cindex_pathE g1 0 + cindex_pathE g2 0 + cindex_pathE g3 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n    2 * Re (winding_number g1 0) + cindex_pathE g1 0 +\n    (2 * Re (winding_number g2 0) + cindex_pathE g2 0) +\n    (2 * Re (winding_number g3 0) + cindex_pathE g3 0)", "by auto"], ["proof (state)\nthis:\n  wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "moreover"], ["proof (state)\nthis:\n  wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "have \"wc_add g2=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add g2 = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wc_add g2 = 0", "have \"2 * Re (winding_number g2 0) = - cindex_pathE g2 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 0) = - cindex_pathE g2 0", "unfolding g2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (subpath u v (g r)) 0) =\n    - cindex_pathE (subpath u v (g r)) 0", "apply (rule winding_number_cindex_pathE_aux)"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite_ReZ_segments (subpath u v (g r)) 0\n 2. valid_path (subpath u v (g r))\n 3. 0 \\<notin> path_image (subpath u v (g r))\n 4. Re (subpath u v (g r) 1) = Re 0\n 5. Re (subpath u v (g r) 0) = Re 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath u v (g r)) 0", "using uv"], ["proof (prove)\nusing this:\n  u \\<in> {0..1}\n  v \\<in> {0..1}\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. finite_ReZ_segments (subpath u v (g r)) 0", "by (auto intro:finite_ReZ_segments_subpath)"], ["proof (prove)\ngoal (4 subgoals):\n 1. valid_path (subpath u v (g r))\n 2. 0 \\<notin> path_image (subpath u v (g r))\n 3. Re (subpath u v (g r) 1) = Re 0\n 4. Re (subpath u v (g r) 0) = Re 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (subpath u v (g r))", "using uv"], ["proof (prove)\nusing this:\n  u \\<in> {0..1}\n  v \\<in> {0..1}\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. valid_path (subpath u v (g r))", "by (auto intro:valid_path_subpath)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<notin> path_image (subpath u v (g r))\n 2. Re (subpath u v (g r) 1) = Re 0\n 3. Re (subpath u v (g r) 0) = Re 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (subpath u v (g r))", "using Path_Connected.path_image_subpath_subset \\<open>\\<And>r. path (g r)\\<close> not_g_image uv"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> {0..1}; ?v \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> path_image (subpath ?u ?v ?g) \\<subseteq> path_image ?g\n  path (g ?r)\n  0 \\<notin> path_image (g ?r)\n  u \\<in> {0..1}\n  v \\<in> {0..1}\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image (subpath u v (g r))", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. Re (subpath u v (g r) 1) = Re 0\n 2. Re (subpath u v (g r) 0) = Re 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (subpath u v (g r) 1) = Re 0", "unfolding subpath_def v_def g_def linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((poly pp \\<circ>\n         (\\<lambda>x.\n             complex_of_real\n              ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n         (((max_r + r) / (2 * r) - u) * 1 + u)) =\n    Re 0", "using r_asm \\<open>max_r \\<in>proots p\\<close>"], ["proof (prove)\nusing this:\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n  max_r \\<in> proots p\n\ngoal (1 subgoal):\n 1. Re ((poly pp \\<circ>\n         (\\<lambda>x.\n             complex_of_real\n              ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n         (((max_r + r) / (2 * r) - u) * 1 + u)) =\n    Re 0", "by (auto simp add:field_simps Re_poly_of_real p_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (subpath u v (g r) 0) = Re 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (subpath u v (g r) 0) = Re 0", "unfolding subpath_def u_def g_def linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((poly pp \\<circ>\n         (\\<lambda>x.\n             complex_of_real\n              ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n         ((v - (min_r + r) / (2 * r)) * 0 + (min_r + r) / (2 * r))) =\n    Re 0", "using r_asm \\<open>min_r \\<in>proots p\\<close>"], ["proof (prove)\nusing this:\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n  min_r \\<in> proots p\n\ngoal (1 subgoal):\n 1. Re ((poly pp \\<circ>\n         (\\<lambda>x.\n             complex_of_real\n              ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n         ((v - (min_r + r) / (2 * r)) * 0 + (min_r + r) / (2 * r))) =\n    Re 0", "by (auto simp add:field_simps Re_poly_of_real p_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 * Re (winding_number g2 0) = - cindex_pathE g2 0\n\ngoal (1 subgoal):\n 1. wc_add g2 = 0", "then"], ["proof (chain)\npicking this:\n  2 * Re (winding_number g2 0) = - cindex_pathE g2 0", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * Re (winding_number g2 0) = - cindex_pathE g2 0\n\ngoal (1 subgoal):\n 1. wc_add g2 = 0", "unfolding wc_add_def"], ["proof (prove)\nusing this:\n  2 * Re (winding_number g2 0) = - cindex_pathE g2 0\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number g2 0) + cindex_pathE g2 0 = 0", "by auto"], ["proof (state)\nthis:\n  wc_add g2 = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wc_add g2 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "moreover"], ["proof (state)\nthis:\n  wc_add g2 = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "have \"wc_add g1=- arctan (f (-r)) / pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "have g1_pq:\n          \"Re (g1 t) = poly p (min_r*t+r*t-r)\"\n          \"Im (g1 t) = poly q (min_r*t+r*t-r)\"\n          \"Im (g1 t)/Re (g1 t) = (f o (\\<lambda>x. (min_r+r)*x - r)) t\"\n          for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g1 t) = poly p (min_r * t + r * t - r) &&&\n    Im (g1 t) = poly q (min_r * t + r * t - r) &&&\n    Im (g1 t) / Re (g1 t) = (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) t", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. Re (g1 t) = poly p (min_r * t + r * t - r)\n 2. Im (g1 t) = poly q (min_r * t + r * t - r)\n 3. Im (g1 t) / Re (g1 t) = (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) t", "have \"g1 t = poly pp (of_real (min_r*t+r*t-r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g1 t = poly pp (complex_of_real (min_r * t + r * t - r))", "using \\<open>r\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g1 t = poly pp (complex_of_real (min_r * t + r * t - r))", "unfolding g1_def g_def linepath_def subpath_def u_def p_def"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (poly pp \\<circ>\n     (\\<lambda>x.\n         complex_of_real ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n     (((min_r + r) / (2 * r) - 0) * t + 0) =\n    poly pp (complex_of_real (min_r * t + r * t - r))", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  g1 t = poly pp (complex_of_real (min_r * t + r * t - r))\n\ngoal (3 subgoals):\n 1. Re (g1 t) = poly p (min_r * t + r * t - r)\n 2. Im (g1 t) = poly q (min_r * t + r * t - r)\n 3. Im (g1 t) / Re (g1 t) = (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) t", "then"], ["proof (chain)\npicking this:\n  g1 t = poly pp (complex_of_real (min_r * t + r * t - r))", "show \n              \"Re (g1 t) = poly p (min_r*t+r*t-r)\"\n              \"Im (g1 t) = poly q (min_r*t+r*t-r)\""], ["proof (prove)\nusing this:\n  g1 t = poly pp (complex_of_real (min_r * t + r * t - r))\n\ngoal (1 subgoal):\n 1. Re (g1 t) = poly p (min_r * t + r * t - r) &&&\n    Im (g1 t) = poly q (min_r * t + r * t - r)", "unfolding p_def q_def"], ["proof (prove)\nusing this:\n  g1 t = poly pp (complex_of_real (min_r * t + r * t - r))\n\ngoal (1 subgoal):\n 1. Re (g1 t) = poly (map_poly Re pp) (min_r * t + r * t - r) &&&\n    Im (g1 t) = poly (map_poly Im pp) (min_r * t + r * t - r)", "by (simp only:Re_poly_of_real Im_poly_of_real)+"], ["proof (state)\nthis:\n  Re (g1 t) = poly p (min_r * t + r * t - r)\n  Im (g1 t) = poly q (min_r * t + r * t - r)\n\ngoal (1 subgoal):\n 1. Im (g1 t) / Re (g1 t) = (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) t", "then"], ["proof (chain)\npicking this:\n  Re (g1 t) = poly p (min_r * t + r * t - r)\n  Im (g1 t) = poly q (min_r * t + r * t - r)", "show \"Im (g1 t)/Re (g1 t) = (f o (\\<lambda>x. (min_r+r)*x - r)) t\""], ["proof (prove)\nusing this:\n  Re (g1 t) = poly p (min_r * t + r * t - r)\n  Im (g1 t) = poly q (min_r * t + r * t - r)\n\ngoal (1 subgoal):\n 1. Im (g1 t) / Re (g1 t) = (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) t", "unfolding f_def"], ["proof (prove)\nusing this:\n  Re (g1 t) = poly p (min_r * t + r * t - r)\n  Im (g1 t) = poly q (min_r * t + r * t - r)\n\ngoal (1 subgoal):\n 1. Im (g1 t) / Re (g1 t) =\n    ((\\<lambda>t. poly q t / poly p t) \\<circ>\n     (\\<lambda>x. (min_r + r) * x - r))\n     t", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  Im (g1 t) / Re (g1 t) = (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (g1 ?t) = poly p (min_r * ?t + r * ?t - r)\n  Im (g1 ?t) = poly q (min_r * ?t + r * ?t - r)\n  Im (g1 ?t) / Re (g1 ?t) = (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) ?t\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "have \"Re(g1 1)=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g1 1) = 0", "using \\<open>r\\<noteq>0\\<close> Re_poly_of_real \\<open>min_r\\<in>proots p\\<close>"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  Re (poly ?p (complex_of_real ?x)) = poly (map_poly Re ?p) ?x\n  min_r \\<in> proots p\n\ngoal (1 subgoal):\n 1. Re (g1 1) = 0", "unfolding g1_def subpath_def u_def g_def linepath_def"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  Re (poly ?p (complex_of_real ?x)) = poly (map_poly Re ?p) ?x\n  min_r \\<in> proots p\n\ngoal (1 subgoal):\n 1. Re ((poly pp \\<circ>\n         (\\<lambda>x.\n             complex_of_real\n              ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n         (((min_r + r) / (2 * r) - 0) * 1 + 0)) =\n    0", "by (auto simp add:field_simps p_def)"], ["proof (state)\nthis:\n  Re (g1 1) = 0\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "have \"0 \\<notin> path_image g1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image g1", "by (metis (full_types) path_image_subpath_subset \\<open>\\<And>r. path (g r)\\<close> \n              atLeastAtMost_iff g1_def le_less not_g_image subsetCE uv(1) zero_le_one)"], ["proof (state)\nthis:\n  0 \\<notin> path_image g1\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "have wc_add_pos:\"wc_add h = - arctan (poly q (- r) / poly p (-r)) / pi\" when \n          Re_pos:\"\\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> h) x\"\n          and hp:\"\\<forall>t. Re (h t) = c*poly p (min_r*t+r*t-r)\"\n          and hq:\"\\<forall>t. Im (h t) = c*poly q (min_r*t+r*t-r)\"\n          and [simp]:\"c\\<noteq>0\"\n          (*and hpq:\"\\<forall>t. Im (h t)/Re (h t) = (f o (\\<lambda>x. (min_r+r)*x - r)) t\"*)\n          and \"Re (h 1) = 0\"\n          and \"valid_path h\"\n          and h_img:\"0 \\<notin> path_image h\"\n          for h c"], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi", "define f where \"f=(\\<lambda>t. c*poly q t / (c*poly p t))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. c * poly q t / (c * poly p t))\n\ngoal (1 subgoal):\n 1. wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi", "define farg where \"farg= (if 0 < Im (h 1) then pi / 2 else - pi / 2)\""], ["proof (state)\nthis:\n  farg = (if 0 < Im (h 1) then pi / 2 else - pi / 2)\n\ngoal (1 subgoal):\n 1. wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi", "have \"Re (winding_number h 0) = (Im (Ln (pathfinish h)) \n              - Im (Ln (pathstart h))) / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number h 0) =\n    (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi)", "apply (rule Re_winding_number_half_right[of h 0,simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>p\\<in>path_image h. 0 \\<le> Re p\n 2. valid_path h\n 3. 0 \\<notin> path_image h", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image h. 0 \\<le> Re p", "using that \\<open>Re (h 1) = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> h) x\n  \\<forall>t. Re (h t) = c * poly p (min_r * t + r * t - r)\n  \\<forall>t. Im (h t) = c * poly q (min_r * t + r * t - r)\n  c \\<noteq> 0\n  Re (h 1) = 0\n  valid_path h\n  0 \\<notin> path_image h\n  Re (h 1) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image h. 0 \\<le> Re p", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> h) x\n  \\<forall>t. Re (h t) = c * poly p (min_r * t + r * t - r)\n  \\<forall>t. Im (h t) = c * poly q (min_r * t + r * t - r)\n  c \\<noteq> 0\n  Re (h 1) = 0\n  valid_path h\n  0 \\<notin> h ` {0..1}\n  Re (h 1) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>h ` {0..1}. 0 \\<le> Re p", "by (auto simp add:le_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path h\n 2. 0 \\<notin> path_image h", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path h", "using \\<open>valid_path h\\<close>"], ["proof (prove)\nusing this:\n  valid_path h\n\ngoal (1 subgoal):\n 1. valid_path h", "."], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image h", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image h", "using h_img"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image h", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re (winding_number h 0) =\n  (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi", "also"], ["proof (state)\nthis:\n  Re (winding_number h 0) =\n  (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi", "have \"... = (farg - arctan (f (-r))) / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (farg - arctan (f (- r))) / (2 * pi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (farg - arctan (f (- r))) / (2 * pi)", "have \"Im (Ln (pathfinish h)) = farg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish h)) = farg", "using \\<open>Re(h 1)=0\\<close>"], ["proof (prove)\nusing this:\n  Re (h 1) = 0\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish h)) = farg", "unfolding farg_def path_defs"], ["proof (prove)\nusing this:\n  Re (h 1) = 0\n\ngoal (1 subgoal):\n 1. Im (Ln (h 1)) = (if 0 < Im (h 1) then pi / 2 else - pi / 2)", "apply (subst Im_Ln_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Re (h 1) = 0 \\<Longrightarrow> h 1 \\<noteq> 0\n 2. Re (h 1) = 0 \\<Longrightarrow>\n    (if Re (h 1) \\<noteq> 0\n     then if 0 < Re (h 1) then arctan (Im (h 1) / Re (h 1))\n          else if 0 \\<le> Im (h 1) then arctan (Im (h 1) / Re (h 1)) + pi\n               else arctan (Im (h 1) / Re (h 1)) - pi\n     else if 0 < Im (h 1) then pi / 2 else - pi / 2) =\n    (if 0 < Im (h 1) then pi / 2 else - pi / 2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (h 1) = 0 \\<Longrightarrow> h 1 \\<noteq> 0", "using h_img"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. Re (h 1) = 0 \\<Longrightarrow> h 1 \\<noteq> 0", "unfolding path_defs"], ["proof (prove)\nusing this:\n  0 \\<notin> h ` {0..1}\n\ngoal (1 subgoal):\n 1. Re (h 1) = 0 \\<Longrightarrow> h 1 \\<noteq> 0", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (h 1) = 0 \\<Longrightarrow>\n    (if Re (h 1) \\<noteq> 0\n     then if 0 < Re (h 1) then arctan (Im (h 1) / Re (h 1))\n          else if 0 \\<le> Im (h 1) then arctan (Im (h 1) / Re (h 1)) + pi\n               else arctan (Im (h 1) / Re (h 1)) - pi\n     else if 0 < Im (h 1) then pi / 2 else - pi / 2) =\n    (if 0 < Im (h 1) then pi / 2 else - pi / 2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (h 1) = 0 \\<Longrightarrow>\n    (if Re (h 1) \\<noteq> 0\n     then if 0 < Re (h 1) then arctan (Im (h 1) / Re (h 1))\n          else if 0 \\<le> Im (h 1) then arctan (Im (h 1) / Re (h 1)) + pi\n               else arctan (Im (h 1) / Re (h 1)) - pi\n     else if 0 < Im (h 1) then pi / 2 else - pi / 2) =\n    (if 0 < Im (h 1) then pi / 2 else - pi / 2)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Im (Ln (pathfinish h)) = farg\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (farg - arctan (f (- r))) / (2 * pi)", "moreover"], ["proof (state)\nthis:\n  Im (Ln (pathfinish h)) = farg\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (farg - arctan (f (- r))) / (2 * pi)", "have \"Im (Ln (pathstart h)) = arctan (f (-r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (pathstart h)) = arctan (f (- r))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im (Ln (pathstart h)) = arctan (f (- r))", "have \"pathstart h \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathstart h \\<noteq> 0", "using h_img"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. pathstart h \\<noteq> 0", "by (metis pathstart_in_path_image)"], ["proof (state)\nthis:\n  pathstart h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart h)) = arctan (f (- r))", "then"], ["proof (chain)\npicking this:\n  pathstart h \\<noteq> 0", "have \"Im (Ln (pathstart h)) = arctan (Im (pathstart h) / Re (pathstart h))\""], ["proof (prove)\nusing this:\n  pathstart h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart h)) = arctan (Im (pathstart h) / Re (pathstart h))", "using Re_pos[rule_format,of 0]"], ["proof (prove)\nusing this:\n  pathstart h \\<noteq> 0\n  0 \\<in> {0..<1} \\<Longrightarrow> 0 < (Re \\<circ> h) 0\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart h)) = arctan (Im (pathstart h) / Re (pathstart h))", "by (simp add: Im_Ln_eq path_defs)"], ["proof (state)\nthis:\n  Im (Ln (pathstart h)) = arctan (Im (pathstart h) / Re (pathstart h))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart h)) = arctan (f (- r))", "also"], ["proof (state)\nthis:\n  Im (Ln (pathstart h)) = arctan (Im (pathstart h) / Re (pathstart h))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart h)) = arctan (f (- r))", "have \"... = arctan (f (-r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arctan (Im (pathstart h) / Re (pathstart h)) = arctan (f (- r))", "unfolding f_def path_defs hp[rule_format] hq[rule_format]"], ["proof (prove)\ngoal (1 subgoal):\n 1. arctan\n     (c * poly q (min_r * 0 + r * 0 - r) /\n      (c * poly p (min_r * 0 + r * 0 - r))) =\n    arctan (c * poly q (- r) / (c * poly p (- r)))", "by simp"], ["proof (state)\nthis:\n  arctan (Im (pathstart h) / Re (pathstart h)) = arctan (f (- r))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart h)) = arctan (f (- r))", "finally"], ["proof (chain)\npicking this:\n  Im (Ln (pathstart h)) = arctan (f (- r))", "show ?thesis"], ["proof (prove)\nusing this:\n  Im (Ln (pathstart h)) = arctan (f (- r))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart h)) = arctan (f (- r))", "."], ["proof (state)\nthis:\n  Im (Ln (pathstart h)) = arctan (f (- r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (Ln (pathstart h)) = arctan (f (- r))\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (farg - arctan (f (- r))) / (2 * pi)", "ultimately"], ["proof (chain)\npicking this:\n  Im (Ln (pathfinish h)) = farg\n  Im (Ln (pathstart h)) = arctan (f (- r))", "show ?thesis"], ["proof (prove)\nusing this:\n  Im (Ln (pathfinish h)) = farg\n  Im (Ln (pathstart h)) = arctan (f (- r))\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (farg - arctan (f (- r))) / (2 * pi)", "by auto"], ["proof (state)\nthis:\n  (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n  (farg - arctan (f (- r))) / (2 * pi)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n  (farg - arctan (f (- r))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi", "finally"], ["proof (chain)\npicking this:\n  Re (winding_number h 0) = (farg - arctan (f (- r))) / (2 * pi)", "have \"Re (winding_number h 0) = (farg - arctan (f (-r))) / (2 * pi)\""], ["proof (prove)\nusing this:\n  Re (winding_number h 0) = (farg - arctan (f (- r))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number h 0) = (farg - arctan (f (- r))) / (2 * pi)", "."], ["proof (state)\nthis:\n  Re (winding_number h 0) = (farg - arctan (f (- r))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi", "moreover"], ["proof (state)\nthis:\n  Re (winding_number h 0) = (farg - arctan (f (- r))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi", "have \"cindex_pathE h 0 = (-farg/pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = - farg / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = - farg / pi", "have \"cindex_pathE h 0 = cindexE 0 1 (f \\<circ> (\\<lambda>x. (min_r + r) * x - r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE h 0 =\n    cindexE 0 1 (f \\<circ> (\\<lambda>x. (min_r + r) * x - r))", "unfolding cindex_pathE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (h t - 0) / Re (h t - 0)) =\n    cindexE 0 1 (f \\<circ> (\\<lambda>x. (min_r + r) * x - r))", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (h t - 0) / Re (h t - 0)) =\n    cindexE 0 1 (f \\<circ> (\\<lambda>x. (min_r + r) * x - r))", "by (auto simp add:hp hq f_def comp_def algebra_simps)"], ["proof (state)\nthis:\n  cindex_pathE h 0 =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (min_r + r) * x - r))\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = - farg / pi", "also"], ["proof (state)\nthis:\n  cindex_pathE h 0 =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (min_r + r) * x - r))\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = - farg / pi", "have \"... = cindexE (-r) min_r f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) =\n    cindexE (- r) min_r f", "apply (subst cindexE_linear_comp[where b=\"-r\",simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. min_r + r \\<noteq> 0\n 2. (if 0 < min_r + r\n     then cindexE ((min_r + r) * 0 + - r) ((min_r + r) * 1 + - r) f\n     else - cindexE ((min_r + r) * 1 + - r) ((min_r + r) * 0 + - r) f) =\n    cindexE (- r) min_r f", "using r_asm"], ["proof (prove)\nusing this:\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n\ngoal (2 subgoals):\n 1. min_r + r \\<noteq> 0\n 2. (if 0 < min_r + r\n     then cindexE ((min_r + r) * 0 + - r) ((min_r + r) * 1 + - r) f\n     else - cindexE ((min_r + r) * 1 + - r) ((min_r + r) * 0 + - r) f) =\n    cindexE (- r) min_r f", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) =\n  cindexE (- r) min_r f\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = - farg / pi", "also"], ["proof (state)\nthis:\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) =\n  cindexE (- r) min_r f\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = - farg / pi", "have \"... = - jumpF f (at_left min_r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (- r) min_r f = - jumpF f (at_left min_r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE (- r) min_r f = - jumpF f (at_left min_r)", "define right where \"right = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> - r \\<le> x \\<and> x < min_r}\""], ["proof (state)\nthis:\n  right =\n  {x. jumpF f (at_right x) \\<noteq> 0 \\<and> - r \\<le> x \\<and> x < min_r}\n\ngoal (1 subgoal):\n 1. cindexE (- r) min_r f = - jumpF f (at_left min_r)", "define left where \"left = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> - r < x \\<and> x \\<le> min_r}\""], ["proof (state)\nthis:\n  left =\n  {x. jumpF f (at_left x) \\<noteq> 0 \\<and> - r < x \\<and> x \\<le> min_r}\n\ngoal (1 subgoal):\n 1. cindexE (- r) min_r f = - jumpF f (at_left min_r)", "have *:\"jumpF f (at_right x) =0\" \"jumpF f (at_left x) =0\" when \"x\\<in>{-r..<min_r}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0 &&& jumpF f (at_left x) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_right x) = 0\n 2. jumpF f (at_left x) = 0", "have False when \"poly p x =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"x\\<ge>min_r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_r \\<le> x", "using min_max_bound[rule_format,of x] that"], ["proof (prove)\nusing this:\n  x \\<in> proots p \\<Longrightarrow> x \\<in> {min_r..max_r}\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. min_r \\<le> x", "by auto"], ["proof (state)\nthis:\n  min_r \\<le> x\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  min_r \\<le> x", "show False"], ["proof (prove)\nusing this:\n  min_r \\<le> x\n\ngoal (1 subgoal):\n 1. False", "using \\<open>x\\<in>{-r..<min_r}\\<close>"], ["proof (prove)\nusing this:\n  min_r \\<le> x\n  x \\<in> {- r..<min_r}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p x = 0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. jumpF f (at_right x) = 0\n 2. jumpF f (at_left x) = 0", "then"], ["proof (chain)\npicking this:\n  poly p x = 0 \\<Longrightarrow> False", "show \"jumpF f (at_right x) =0\" \"jumpF f (at_left x) =0\""], ["proof (prove)\nusing this:\n  poly p x = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0 &&& jumpF f (at_left x) = 0", "unfolding f_def"], ["proof (prove)\nusing this:\n  poly p x = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. c * poly q t / (c * poly p t)) (at_right x) = 0 &&&\n    jumpF (\\<lambda>t. c * poly q t / (c * poly p t)) (at_left x) = 0", "by (auto intro!:jumpF_not_infinity continuous_intros)"], ["proof (state)\nthis:\n  jumpF f (at_right x) = 0\n  jumpF f (at_left x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {- r..<min_r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  ?x \\<in> {- r..<min_r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. cindexE (- r) min_r f = - jumpF f (at_left min_r)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {- r..<min_r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  ?x \\<in> {- r..<min_r} \\<Longrightarrow> jumpF f (at_left ?x) = 0", "have \"right = {}\""], ["proof (prove)\nusing this:\n  ?x \\<in> {- r..<min_r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  ?x \\<in> {- r..<min_r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. right = {}", "unfolding right_def"], ["proof (prove)\nusing this:\n  ?x \\<in> {- r..<min_r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  ?x \\<in> {- r..<min_r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        - r \\<le> x \\<and> x < min_r} =\n    {}", "by force"], ["proof (state)\nthis:\n  right = {}\n\ngoal (1 subgoal):\n 1. cindexE (- r) min_r f = - jumpF f (at_left min_r)", "moreover"], ["proof (state)\nthis:\n  right = {}\n\ngoal (1 subgoal):\n 1. cindexE (- r) min_r f = - jumpF f (at_left min_r)", "have \"left = (if jumpF f (at_left min_r) = 0 then {} else {min_r})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left = (if jumpF f (at_left min_r) = 0 then {} else {min_r})", "unfolding left_def le_less"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        - r < x \\<and> (x < min_r \\<or> x = min_r)} =\n    (if jumpF f (at_left min_r) = 0 then {} else {min_r})", "using * r_asm"], ["proof (prove)\nusing this:\n  ?x \\<in> {- r..<min_r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  ?x \\<in> {- r..<min_r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and>\n        - r < x \\<and> (x < min_r \\<or> x = min_r)} =\n    (if jumpF f (at_left min_r) = 0 then {} else {min_r})", "by force"], ["proof (state)\nthis:\n  left = (if jumpF f (at_left min_r) = 0 then {} else {min_r})\n\ngoal (1 subgoal):\n 1. cindexE (- r) min_r f = - jumpF f (at_left min_r)", "ultimately"], ["proof (chain)\npicking this:\n  right = {}\n  left = (if jumpF f (at_left min_r) = 0 then {} else {min_r})", "show ?thesis"], ["proof (prove)\nusing this:\n  right = {}\n  left = (if jumpF f (at_left min_r) = 0 then {} else {min_r})\n\ngoal (1 subgoal):\n 1. cindexE (- r) min_r f = - jumpF f (at_left min_r)", "unfolding cindexE_def"], ["proof (prove)\nusing this:\n  right = {}\n  left = (if jumpF f (at_left min_r) = 0 then {} else {min_r})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               - r \\<le> x \\<and> x < min_r.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n               - r < x \\<and> x \\<le> min_r.\n       jumpF f (at_left x)) =\n    - jumpF f (at_left min_r)", "by (fold left_def right_def,auto)"], ["proof (state)\nthis:\n  cindexE (- r) min_r f = - jumpF f (at_left min_r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE (- r) min_r f = - jumpF f (at_left min_r)\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = - farg / pi", "also"], ["proof (state)\nthis:\n  cindexE (- r) min_r f = - jumpF f (at_left min_r)\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = - farg / pi", "have \"... = (-farg/pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "have p_pos:\"c*poly p x > 0\" when \"x \\<in> {- r<..<min_r}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "define hh where \"hh=(\\<lambda>t. min_r*t+r*t-r)\""], ["proof (state)\nthis:\n  hh = (\\<lambda>t. min_r * t + r * t - r)\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "have \"(x+r)/(min_r+r) \\<in> {0..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + r) / (min_r + r) \\<in> {0..<1}", "using that r_asm"], ["proof (prove)\nusing this:\n  x \\<in> {- r<..<min_r}\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. (x + r) / (min_r + r) \\<in> {0..<1}", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  (x + r) / (min_r + r) \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "then"], ["proof (chain)\npicking this:\n  (x + r) / (min_r + r) \\<in> {0..<1}", "have \"0 < c*poly p (hh ((x+r)/(min_r+r)))\""], ["proof (prove)\nusing this:\n  (x + r) / (min_r + r) \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. 0 < c * poly p (hh ((x + r) / (min_r + r)))", "apply (drule_tac Re_pos[rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (Re \\<circ> h) ((x + r) / (min_r + r)) \\<Longrightarrow>\n    0 < c * poly p (hh ((x + r) / (min_r + r)))", "unfolding comp_def hp[rule_format]  hq[rule_format] hh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c *\n        poly p\n         (min_r * ((x + r) / (min_r + r)) + r * ((x + r) / (min_r + r)) -\n          r) \\<Longrightarrow>\n    0 < c *\n        poly p\n         (min_r * ((x + r) / (min_r + r)) + r * ((x + r) / (min_r + r)) - r)", "."], ["proof (state)\nthis:\n  0 < c * poly p (hh ((x + r) / (min_r + r)))\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "moreover"], ["proof (state)\nthis:\n  0 < c * poly p (hh ((x + r) / (min_r + r)))\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "have \"hh ((x+r)/(min_r+r)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hh ((x + r) / (min_r + r)) = x", "unfolding hh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_r * ((x + r) / (min_r + r)) + r * ((x + r) / (min_r + r)) - r = x", "using \\<open>min_r>-r\\<close>"], ["proof (prove)\nusing this:\n  - r < min_r\n\ngoal (1 subgoal):\n 1. min_r * ((x + r) / (min_r + r)) + r * ((x + r) / (min_r + r)) - r = x", "apply (auto simp add:divide_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - r < min_r \\<Longrightarrow>\n    min_r * (x + r) + r * (x + r) - r * (min_r + r) = x * (min_r + r)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  hh ((x + r) / (min_r + r)) = x\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "ultimately"], ["proof (chain)\npicking this:\n  0 < c * poly p (hh ((x + r) / (min_r + r)))\n  hh ((x + r) / (min_r + r)) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < c * poly p (hh ((x + r) / (min_r + r)))\n  hh ((x + r) / (min_r + r)) = x\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "by simp"], ["proof (state)\nthis:\n  0 < c * poly p x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {- r<..<min_r} \\<Longrightarrow> 0 < c * poly p ?x\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "have \"c*poly q min_r \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * poly q min_r \\<noteq> 0", "using no_real_zero \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>proots pp. Im x \\<noteq> 0\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c * poly q min_r \\<noteq> 0", "by (metis Im_complex_of_real UNIV_I \\<open>min_r \\<in> proots p\\<close> cpoly_of_decompose \n                    mult_eq_0_iff p_def poly_cpoly_of_real_iff proots_within_iff q_def)"], ["proof (state)\nthis:\n  c * poly q min_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "moreover"], ["proof (state)\nthis:\n  c * poly q min_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "have ?thesis when \"c*poly q min_r > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "have \"0 < Im (h 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Im (h 1)", "unfolding hq[rule_format] hp[rule_format]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c * poly q (min_r * 1 + r * 1 - r)", "using that"], ["proof (prove)\nusing this:\n  0 < c * poly q min_r\n\ngoal (1 subgoal):\n 1. 0 < c * poly q (min_r * 1 + r * 1 - r)", "by auto"], ["proof (state)\nthis:\n  0 < Im (h 1)\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "moreover"], ["proof (state)\nthis:\n  0 < Im (h 1)\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "have \"jumpF f (at_left min_r) = 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left min_r) = 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_left min_r) = 1 / 2", "have \"((\\<lambda>t. c*poly p t) has_sgnx 1) (at_left min_r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_left min_r)", "unfolding has_sgnx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left min_r. sgn (c * poly p x) = 1", "apply (rule eventually_at_leftI[of \"-r\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {- r<..<min_r} \\<Longrightarrow> sgn (c * poly p x) = 1\n 2. - r < min_r", "using p_pos \\<open>min_r>-r\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> {- r<..<min_r} \\<Longrightarrow> 0 < c * poly p ?x\n  - r < min_r\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {- r<..<min_r} \\<Longrightarrow> sgn (c * poly p x) = 1\n 2. - r < min_r", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_left min_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_left min_r) = 1 / 2", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_left min_r)", "have \"filterlim f at_top (at_left min_r)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_left min_r)\n\ngoal (1 subgoal):\n 1. filterlim f at_top (at_left min_r)", "unfolding f_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_left min_r)\n\ngoal (1 subgoal):\n 1. LIM t at_left min_r. c * poly q t / (c * poly p t) :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"c*poly q min_r\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly q t) \\<longlongrightarrow> c * poly q min_r)\n     (at_left min_r)\n 2. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    c * poly q min_r \\<noteq> 0\n 3. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly p t) \\<longlongrightarrow> 0)\n     (at_left min_r) \\<and>\n    ((\\<lambda>x. c * poly p x) has_sgnx sgn (c * poly q min_r))\n     (at_left min_r)", "using that \\<open>min_r\\<in>proots p\\<close>"], ["proof (prove)\nusing this:\n  0 < c * poly q min_r\n  min_r \\<in> proots p\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly q t) \\<longlongrightarrow> c * poly q min_r)\n     (at_left min_r)\n 2. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    c * poly q min_r \\<noteq> 0\n 3. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly p t) \\<longlongrightarrow> 0)\n     (at_left min_r) \\<and>\n    ((\\<lambda>x. c * poly p x) has_sgnx sgn (c * poly q min_r))\n     (at_left min_r)", "by (auto intro!:tendsto_eq_intros)"], ["proof (state)\nthis:\n  filterlim f at_top (at_left min_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_left min_r) = 1 / 2", "then"], ["proof (chain)\npicking this:\n  filterlim f at_top (at_left min_r)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_top (at_left min_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_left min_r) = 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  filterlim f at_top (at_left min_r)\n\ngoal (1 subgoal):\n 1. (if filterlim f at_top (at_left min_r) then 1 / 2\n     else if filterlim f at_bot (at_left min_r) then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF f (at_left min_r) = 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF f (at_left min_r) = 1 / 2\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "ultimately"], ["proof (chain)\npicking this:\n  0 < Im (h 1)\n  jumpF f (at_left min_r) = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < Im (h 1)\n  jumpF f (at_left min_r) = 1 / 2\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "unfolding farg_def"], ["proof (prove)\nusing this:\n  0 < Im (h 1)\n  jumpF f (at_left min_r) = 1 / 2\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) =\n    - (if 0 < Im (h 1) then pi / 2 else - pi / 2) / pi", "by auto"], ["proof (state)\nthis:\n  - jumpF f (at_left min_r) = - farg / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c * poly q min_r \\<Longrightarrow>\n  - jumpF f (at_left min_r) = - farg / pi\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "moreover"], ["proof (state)\nthis:\n  0 < c * poly q min_r \\<Longrightarrow>\n  - jumpF f (at_left min_r) = - farg / pi\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "have ?thesis when \"c*poly q min_r < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "have \"0 > Im (h 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (h 1) < 0", "unfolding hq[rule_format] hp[rule_format]"], ["proof (prove)\ngoal (1 subgoal):\n 1. c * poly q (min_r * 1 + r * 1 - r) < 0", "using that"], ["proof (prove)\nusing this:\n  c * poly q min_r < 0\n\ngoal (1 subgoal):\n 1. c * poly q (min_r * 1 + r * 1 - r) < 0", "by auto"], ["proof (state)\nthis:\n  Im (h 1) < 0\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "moreover"], ["proof (state)\nthis:\n  Im (h 1) < 0\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "have \"jumpF f (at_left min_r) = - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_left min_r) = - 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_left min_r) = - 1 / 2", "have \"((\\<lambda>t. c*poly p t) has_sgnx 1) (at_left min_r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_left min_r)", "unfolding has_sgnx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left min_r. sgn (c * poly p x) = 1", "apply (rule eventually_at_leftI[of \"-r\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {- r<..<min_r} \\<Longrightarrow> sgn (c * poly p x) = 1\n 2. - r < min_r", "using p_pos \\<open>min_r>-r\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> {- r<..<min_r} \\<Longrightarrow> 0 < c * poly p ?x\n  - r < min_r\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {- r<..<min_r} \\<Longrightarrow> sgn (c * poly p x) = 1\n 2. - r < min_r", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_left min_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_left min_r) = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_left min_r)", "have \"filterlim f at_bot (at_left min_r)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_left min_r)\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_left min_r)", "unfolding f_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_left min_r)\n\ngoal (1 subgoal):\n 1. LIM t at_left min_r. c * poly q t / (c * poly p t) :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"c*poly q min_r\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly q t) \\<longlongrightarrow> c * poly q min_r)\n     (at_left min_r)\n 2. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    c * poly q min_r \\<noteq> 0\n 3. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly p t) \\<longlongrightarrow> 0)\n     (at_left min_r) \\<and>\n    ((\\<lambda>x. c * poly p x) has_sgnx - sgn (c * poly q min_r))\n     (at_left min_r)", "using that \\<open>min_r\\<in>proots p\\<close>"], ["proof (prove)\nusing this:\n  c * poly q min_r < 0\n  min_r \\<in> proots p\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly q t) \\<longlongrightarrow> c * poly q min_r)\n     (at_left min_r)\n 2. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    c * poly q min_r \\<noteq> 0\n 3. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_left min_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly p t) \\<longlongrightarrow> 0)\n     (at_left min_r) \\<and>\n    ((\\<lambda>x. c * poly p x) has_sgnx - sgn (c * poly q min_r))\n     (at_left min_r)", "by (auto intro!:tendsto_eq_intros)"], ["proof (state)\nthis:\n  filterlim f at_bot (at_left min_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_left min_r) = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  filterlim f at_bot (at_left min_r)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_left min_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_left min_r) = - 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_left min_r)\n\ngoal (1 subgoal):\n 1. (if filterlim f at_top (at_left min_r) then 1 / 2\n     else if filterlim f at_bot (at_left min_r) then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF f (at_left min_r) = - 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF f (at_left min_r) = - 1 / 2\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "ultimately"], ["proof (chain)\npicking this:\n  Im (h 1) < 0\n  jumpF f (at_left min_r) = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  Im (h 1) < 0\n  jumpF f (at_left min_r) = - 1 / 2\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "unfolding farg_def"], ["proof (prove)\nusing this:\n  Im (h 1) < 0\n  jumpF f (at_left min_r) = - 1 / 2\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) =\n    - (if 0 < Im (h 1) then pi / 2 else - pi / 2) / pi", "by auto"], ["proof (state)\nthis:\n  - jumpF f (at_left min_r) = - farg / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c * poly q min_r < 0 \\<Longrightarrow>\n  - jumpF f (at_left min_r) = - farg / pi\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "ultimately"], ["proof (chain)\npicking this:\n  c * poly q min_r \\<noteq> 0\n  0 < c * poly q min_r \\<Longrightarrow>\n  - jumpF f (at_left min_r) = - farg / pi\n  c * poly q min_r < 0 \\<Longrightarrow>\n  - jumpF f (at_left min_r) = - farg / pi", "show ?thesis"], ["proof (prove)\nusing this:\n  c * poly q min_r \\<noteq> 0\n  0 < c * poly q min_r \\<Longrightarrow>\n  - jumpF f (at_left min_r) = - farg / pi\n  c * poly q min_r < 0 \\<Longrightarrow>\n  - jumpF f (at_left min_r) = - farg / pi\n\ngoal (1 subgoal):\n 1. - jumpF f (at_left min_r) = - farg / pi", "by linarith"], ["proof (state)\nthis:\n  - jumpF f (at_left min_r) = - farg / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - jumpF f (at_left min_r) = - farg / pi\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = - farg / pi", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE h 0 = - farg / pi", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE h 0 = - farg / pi\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = - farg / pi", "."], ["proof (state)\nthis:\n  cindex_pathE h 0 = - farg / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE h 0 = - farg / pi\n\ngoal (1 subgoal):\n 1. wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi", "ultimately"], ["proof (chain)\npicking this:\n  Re (winding_number h 0) = (farg - arctan (f (- r))) / (2 * pi)\n  cindex_pathE h 0 = - farg / pi", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number h 0) = (farg - arctan (f (- r))) / (2 * pi)\n  cindex_pathE h 0 = - farg / pi\n\ngoal (1 subgoal):\n 1. wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi", "unfolding wc_add_def f_def"], ["proof (prove)\nusing this:\n  Re (winding_number h 0) =\n  (farg - arctan (c * poly q (- r) / (c * poly p (- r)))) / (2 * pi)\n  cindex_pathE h 0 = - farg / pi\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h 0) + cindex_pathE h 0 =\n    - arctan (poly q (- r) / poly p (- r)) / pi", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  wc_add h = - arctan (poly q (- r) / poly p (- r)) / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> ?h) x;\n   \\<forall>t. Re (?h t) = ?c * poly p (min_r * t + r * t - r);\n   \\<forall>t. Im (?h t) = ?c * poly q (min_r * t + r * t - r);\n   ?c \\<noteq> 0; Re (?h 1) = 0; valid_path ?h;\n   0 \\<notin> path_image ?h\\<rbrakk>\n  \\<Longrightarrow> wc_add ?h = - arctan (poly q (- r) / poly p (- r)) / pi\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "have \"\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0..<1}.\n               (Re \\<circ> g1) x \\<noteq> 0) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x \\<noteq> 0)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0..<1}.\n               (Re \\<circ> g1) x \\<noteq> 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x \\<noteq> 0)", "obtain t where t_def:\"Re (g1 t) =0\" \"t\\<in>{0..<1}\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>Re (g1 t) = 0; t \\<in> {0..<1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>Re (g1 t) = 0; t \\<in> {0..<1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  Re (g1 t) = 0\n  t \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0..<1}.\n               (Re \\<circ> g1) x \\<noteq> 0) \\<Longrightarrow>\n    False", "define m where \"m=min_r*t+r*t-r\""], ["proof (state)\nthis:\n  m = min_r * t + r * t - r\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0..<1}.\n               (Re \\<circ> g1) x \\<noteq> 0) \\<Longrightarrow>\n    False", "have \"poly p m=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p m = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p m = 0", "have \"Re (g1 t) = Re (poly pp (of_real m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g1 t) = Re (poly pp (complex_of_real m))", "unfolding m_def g1_def g_def linepath_def subpath_def u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((poly pp \\<circ>\n         (\\<lambda>x.\n             complex_of_real\n              ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n         (((min_r + r) / (2 * r) - 0) * t + 0)) =\n    Re (poly pp (complex_of_real (min_r * t + r * t - r)))", "using \\<open>r\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re ((poly pp \\<circ>\n         (\\<lambda>x.\n             complex_of_real\n              ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n         (((min_r + r) / (2 * r) - 0) * t + 0)) =\n    Re (poly pp (complex_of_real (min_r * t + r * t - r)))", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  Re (g1 t) = Re (poly pp (complex_of_real m))\n\ngoal (1 subgoal):\n 1. poly p m = 0", "then"], ["proof (chain)\npicking this:\n  Re (g1 t) = Re (poly pp (complex_of_real m))", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (g1 t) = Re (poly pp (complex_of_real m))\n\ngoal (1 subgoal):\n 1. poly p m = 0", "using t_def"], ["proof (prove)\nusing this:\n  Re (g1 t) = Re (poly pp (complex_of_real m))\n  Re (g1 t) = 0\n  t \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. poly p m = 0", "unfolding Re_poly_of_real p_def"], ["proof (prove)\nusing this:\n  Re (g1 t) = poly (map_poly Re pp) m\n  Re (g1 t) = 0\n  t \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. poly (map_poly Re pp) m = 0", "by auto"], ["proof (state)\nthis:\n  poly p m = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p m = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0..<1}.\n               (Re \\<circ> g1) x \\<noteq> 0) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  poly p m = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0..<1}.\n               (Re \\<circ> g1) x \\<noteq> 0) \\<Longrightarrow>\n    False", "have \"m<min_r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < min_r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m < min_r", "have \"min_r+r>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < min_r + r", "using r_asm"], ["proof (prove)\nusing this:\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. 0 < min_r + r", "by simp"], ["proof (state)\nthis:\n  0 < min_r + r\n\ngoal (1 subgoal):\n 1. m < min_r", "then"], ["proof (chain)\npicking this:\n  0 < min_r + r", "have \"(min_r + r)*(t-1)<0\""], ["proof (prove)\nusing this:\n  0 < min_r + r\n\ngoal (1 subgoal):\n 1. (min_r + r) * (t - 1) < 0", "using \\<open>t\\<in>{0..<1}\\<close>"], ["proof (prove)\nusing this:\n  0 < min_r + r\n  t \\<in> {0..<1}\n\ngoal (1 subgoal):\n 1. (min_r + r) * (t - 1) < 0", "by (simp add: mult_pos_neg)"], ["proof (state)\nthis:\n  (min_r + r) * (t - 1) < 0\n\ngoal (1 subgoal):\n 1. m < min_r", "then"], ["proof (chain)\npicking this:\n  (min_r + r) * (t - 1) < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (min_r + r) * (t - 1) < 0\n\ngoal (1 subgoal):\n 1. m < min_r", "unfolding m_def"], ["proof (prove)\nusing this:\n  (min_r + r) * (t - 1) < 0\n\ngoal (1 subgoal):\n 1. min_r * t + r * t - r < min_r", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  m < min_r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m < min_r\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0..<1}.\n               (Re \\<circ> g1) x \\<noteq> 0) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  poly p m = 0\n  m < min_r", "show False"], ["proof (prove)\nusing this:\n  poly p m = 0\n  m < min_r\n\ngoal (1 subgoal):\n 1. False", "using min_max_bound"], ["proof (prove)\nusing this:\n  poly p m = 0\n  m < min_r\n  \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}\n\ngoal (1 subgoal):\n 1. False", "unfolding proots_def"], ["proof (prove)\nusing this:\n  poly p m = 0\n  m < min_r\n  \\<forall>p\\<in>{x. poly p x = 0}. p \\<in> {min_r..max_r}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x \\<noteq> 0", "have \"(\\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x) \\<or> (\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x) \\<or>\n    (\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0)", "apply (elim continuous_on_neq_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {0..<1} (Re \\<circ> g1)\n 2. connected {0..<1}", "using \\<open>path g1\\<close>"], ["proof (prove)\nusing this:\n  path g1\n\ngoal (2 subgoals):\n 1. continuous_on {0..<1} (Re \\<circ> g1)\n 2. connected {0..<1}", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g1\n\ngoal (2 subgoals):\n 1. continuous_on {0..<1} (Re \\<circ> g1)\n 2. connected {0..<1}", "by (auto intro!:continuous_intros elim:continuous_on_subset)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x) \\<or>\n  (\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0)\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x) \\<or>\n  (\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0)\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "have ?thesis when \"\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "have \"wc_add (uminus o g1) = - arctan (f (- r)) / pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add (uminus \\<circ> g1) = - arctan (f (- r)) / pi", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add (uminus \\<circ> g1) = - arctan (poly q (- r) / poly p (- r)) / pi", "apply (rule wc_add_pos[of _ \"-1\"])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> (uminus \\<circ> g1)) x\n 2. \\<forall>t.\n       Re ((uminus \\<circ> g1) t) = - 1 * poly p (min_r * t + r * t - r)\n 3. \\<forall>t.\n       Im ((uminus \\<circ> g1) t) = - 1 * poly q (min_r * t + r * t - r)\n 4. - 1 \\<noteq> 0\n 5. Re ((uminus \\<circ> g1) 1) = 0\n 6. valid_path (uminus \\<circ> g1)\n 7. 0 \\<notin> path_image (uminus \\<circ> g1)", "using g1_pq that \\<open>min_r \\<in>proots p\\<close> \\<open>valid_path g1\\<close> \\<open>0 \\<notin> path_image g1\\<close>"], ["proof (prove)\nusing this:\n  Re (g1 ?t) = poly p (min_r * ?t + r * ?t - r)\n  Im (g1 ?t) = poly q (min_r * ?t + r * ?t - r)\n  Im (g1 ?t) / Re (g1 ?t) = (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) ?t\n  \\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0\n  min_r \\<in> proots p\n  valid_path g1\n  0 \\<notin> path_image g1\n\ngoal (7 subgoals):\n 1. \\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> (uminus \\<circ> g1)) x\n 2. \\<forall>t.\n       Re ((uminus \\<circ> g1) t) = - 1 * poly p (min_r * t + r * t - r)\n 3. \\<forall>t.\n       Im ((uminus \\<circ> g1) t) = - 1 * poly q (min_r * t + r * t - r)\n 4. - 1 \\<noteq> 0\n 5. Re ((uminus \\<circ> g1) 1) = 0\n 6. valid_path (uminus \\<circ> g1)\n 7. 0 \\<notin> path_image (uminus \\<circ> g1)", "by (auto simp add:path_image_compose)"], ["proof (state)\nthis:\n  wc_add (uminus \\<circ> g1) = - arctan (f (- r)) / pi\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "moreover"], ["proof (state)\nthis:\n  wc_add (uminus \\<circ> g1) = - arctan (f (- r)) / pi\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "have \"wc_add (uminus \\<circ> g1) = wc_add g1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add (uminus \\<circ> g1) = wc_add g1", "unfolding wc_add_def cindex_pathE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (uminus \\<circ> g1) 0) +\n    cindexE 0 1\n     (\\<lambda>t.\n         Im ((uminus \\<circ> g1) t - 0) / Re ((uminus \\<circ> g1) t - 0)) =\n    2 * Re (winding_number g1 0) +\n    cindexE 0 1 (\\<lambda>t. Im (g1 t - 0) / Re (g1 t - 0))", "apply (subst winding_number_uminus_comp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. valid_path g1\n 2. - 0 \\<notin> path_image g1\n 3. 2 * Re (winding_number g1 (- 0)) +\n    cindexE 0 1\n     (\\<lambda>t.\n         Im ((uminus \\<circ> g1) t - 0) / Re ((uminus \\<circ> g1) t - 0)) =\n    2 * Re (winding_number g1 0) +\n    cindexE 0 1 (\\<lambda>t. Im (g1 t - 0) / Re (g1 t - 0))", "using \\<open>valid_path g1\\<close> \\<open>0 \\<notin> path_image g1\\<close>"], ["proof (prove)\nusing this:\n  valid_path g1\n  0 \\<notin> path_image g1\n\ngoal (3 subgoals):\n 1. valid_path g1\n 2. - 0 \\<notin> path_image g1\n 3. 2 * Re (winding_number g1 (- 0)) +\n    cindexE 0 1\n     (\\<lambda>t.\n         Im ((uminus \\<circ> g1) t - 0) / Re ((uminus \\<circ> g1) t - 0)) =\n    2 * Re (winding_number g1 0) +\n    cindexE 0 1 (\\<lambda>t. Im (g1 t - 0) / Re (g1 t - 0))", "by auto"], ["proof (state)\nthis:\n  wc_add (uminus \\<circ> g1) = wc_add g1\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "ultimately"], ["proof (chain)\npicking this:\n  wc_add (uminus \\<circ> g1) = - arctan (f (- r)) / pi\n  wc_add (uminus \\<circ> g1) = wc_add g1", "show ?thesis"], ["proof (prove)\nusing this:\n  wc_add (uminus \\<circ> g1) = - arctan (f (- r)) / pi\n  wc_add (uminus \\<circ> g1) = wc_add g1\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "by auto"], ["proof (state)\nthis:\n  wc_add g1 = - arctan (f (- r)) / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0 \\<Longrightarrow>\n  wc_add g1 = - arctan (f (- r)) / pi\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0 \\<Longrightarrow>\n  wc_add g1 = - arctan (f (- r)) / pi\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "have ?thesis when \"\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (poly q (- r) / poly p (- r)) / pi", "apply (rule wc_add_pos[of _ \"1\"])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x\n 2. \\<forall>t. Re (g1 t) = 1 * poly p (min_r * t + r * t - r)\n 3. \\<forall>t. Im (g1 t) = 1 * poly q (min_r * t + r * t - r)\n 4. 1 \\<noteq> 0\n 5. Re (g1 1) = 0\n 6. valid_path g1\n 7. 0 \\<notin> path_image g1", "using g1_pq that \\<open>min_r \\<in>proots p\\<close> \\<open>valid_path g1\\<close> \\<open>0 \\<notin> path_image g1\\<close>"], ["proof (prove)\nusing this:\n  Re (g1 ?t) = poly p (min_r * ?t + r * ?t - r)\n  Im (g1 ?t) = poly q (min_r * ?t + r * ?t - r)\n  Im (g1 ?t) / Re (g1 ?t) = (f \\<circ> (\\<lambda>x. (min_r + r) * x - r)) ?t\n  \\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x\n  min_r \\<in> proots p\n  valid_path g1\n  0 \\<notin> path_image g1\n\ngoal (7 subgoals):\n 1. \\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x\n 2. \\<forall>t. Re (g1 t) = 1 * poly p (min_r * t + r * t - r)\n 3. \\<forall>t. Im (g1 t) = 1 * poly q (min_r * t + r * t - r)\n 4. 1 \\<noteq> 0\n 5. Re (g1 1) = 0\n 6. valid_path g1\n 7. 0 \\<notin> path_image g1", "by (auto simp add:path_image_compose)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x \\<Longrightarrow>\n  wc_add g1 = - arctan (f (- r)) / pi\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x) \\<or>\n  (\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0)\n  \\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0 \\<Longrightarrow>\n  wc_add g1 = - arctan (f (- r)) / pi\n  \\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x \\<Longrightarrow>\n  wc_add g1 = - arctan (f (- r)) / pi", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x) \\<or>\n  (\\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0)\n  \\<forall>x\\<in>{0..<1}. (Re \\<circ> g1) x < 0 \\<Longrightarrow>\n  wc_add g1 = - arctan (f (- r)) / pi\n  \\<forall>x\\<in>{0..<1}. 0 < (Re \\<circ> g1) x \\<Longrightarrow>\n  wc_add g1 = - arctan (f (- r)) / pi\n\ngoal (1 subgoal):\n 1. wc_add g1 = - arctan (f (- r)) / pi", "by blast"], ["proof (state)\nthis:\n  wc_add g1 = - arctan (f (- r)) / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wc_add g1 = - arctan (f (- r)) / pi\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "moreover"], ["proof (state)\nthis:\n  wc_add g1 = - arctan (f (- r)) / pi\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "have \"wc_add g3 = arctan (f r) / pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "have g3_pq:\n          \"Re (g3 t) = poly p ((r-max_r)*t + max_r)\"\n          \"Im (g3 t) = poly q ((r-max_r)*t + max_r)\"\n          \"Im (g3 t)/Re (g3 t) = (f o (\\<lambda>x. (r-max_r)*x + max_r)) t\"\n          for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g3 t) = poly p ((r - max_r) * t + max_r) &&&\n    Im (g3 t) = poly q ((r - max_r) * t + max_r) &&&\n    Im (g3 t) / Re (g3 t) =\n    (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) t", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. Re (g3 t) = poly p ((r - max_r) * t + max_r)\n 2. Im (g3 t) = poly q ((r - max_r) * t + max_r)\n 3. Im (g3 t) / Re (g3 t) =\n    (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) t", "have \"g3 t = poly pp (of_real ((r-max_r)*t + max_r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g3 t = poly pp (complex_of_real ((r - max_r) * t + max_r))", "using \\<open>r\\<noteq>0\\<close> \\<open>max_r<r\\<close>"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  max_r < r\n\ngoal (1 subgoal):\n 1. g3 t = poly pp (complex_of_real ((r - max_r) * t + max_r))", "unfolding g3_def g_def linepath_def subpath_def v_def p_def"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  max_r < r\n\ngoal (1 subgoal):\n 1. (poly pp \\<circ>\n     (\\<lambda>x.\n         complex_of_real ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n     ((1 - (max_r + r) / (2 * r)) * t + (max_r + r) / (2 * r)) =\n    poly pp (complex_of_real ((r - max_r) * t + max_r))", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  g3 t = poly pp (complex_of_real ((r - max_r) * t + max_r))\n\ngoal (3 subgoals):\n 1. Re (g3 t) = poly p ((r - max_r) * t + max_r)\n 2. Im (g3 t) = poly q ((r - max_r) * t + max_r)\n 3. Im (g3 t) / Re (g3 t) =\n    (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) t", "then"], ["proof (chain)\npicking this:\n  g3 t = poly pp (complex_of_real ((r - max_r) * t + max_r))", "show \n              \"Re (g3 t) = poly p ((r-max_r)*t + max_r)\"\n              \"Im (g3 t) = poly q ((r-max_r)*t + max_r)\""], ["proof (prove)\nusing this:\n  g3 t = poly pp (complex_of_real ((r - max_r) * t + max_r))\n\ngoal (1 subgoal):\n 1. Re (g3 t) = poly p ((r - max_r) * t + max_r) &&&\n    Im (g3 t) = poly q ((r - max_r) * t + max_r)", "unfolding p_def q_def"], ["proof (prove)\nusing this:\n  g3 t = poly pp (complex_of_real ((r - max_r) * t + max_r))\n\ngoal (1 subgoal):\n 1. Re (g3 t) = poly (map_poly Re pp) ((r - max_r) * t + max_r) &&&\n    Im (g3 t) = poly (map_poly Im pp) ((r - max_r) * t + max_r)", "by (simp only:Re_poly_of_real Im_poly_of_real)+"], ["proof (state)\nthis:\n  Re (g3 t) = poly p ((r - max_r) * t + max_r)\n  Im (g3 t) = poly q ((r - max_r) * t + max_r)\n\ngoal (1 subgoal):\n 1. Im (g3 t) / Re (g3 t) =\n    (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) t", "then"], ["proof (chain)\npicking this:\n  Re (g3 t) = poly p ((r - max_r) * t + max_r)\n  Im (g3 t) = poly q ((r - max_r) * t + max_r)", "show \"Im (g3 t)/Re (g3 t) = (f o (\\<lambda>x. (r-max_r)*x + max_r)) t\""], ["proof (prove)\nusing this:\n  Re (g3 t) = poly p ((r - max_r) * t + max_r)\n  Im (g3 t) = poly q ((r - max_r) * t + max_r)\n\ngoal (1 subgoal):\n 1. Im (g3 t) / Re (g3 t) =\n    (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) t", "unfolding f_def"], ["proof (prove)\nusing this:\n  Re (g3 t) = poly p ((r - max_r) * t + max_r)\n  Im (g3 t) = poly q ((r - max_r) * t + max_r)\n\ngoal (1 subgoal):\n 1. Im (g3 t) / Re (g3 t) =\n    ((\\<lambda>t. poly q t / poly p t) \\<circ>\n     (\\<lambda>x. (r - max_r) * x + max_r))\n     t", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  Im (g3 t) / Re (g3 t) =\n  (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re (g3 ?t) = poly p ((r - max_r) * ?t + max_r)\n  Im (g3 ?t) = poly q ((r - max_r) * ?t + max_r)\n  Im (g3 ?t) / Re (g3 ?t) =\n  (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) ?t\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "have \"Re(g3 0)=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g3 0) = 0", "using \\<open>r\\<noteq>0\\<close> Re_poly_of_real \\<open>max_r\\<in>proots p\\<close>"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  Re (poly ?p (complex_of_real ?x)) = poly (map_poly Re ?p) ?x\n  max_r \\<in> proots p\n\ngoal (1 subgoal):\n 1. Re (g3 0) = 0", "unfolding g3_def subpath_def v_def g_def linepath_def"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  Re (poly ?p (complex_of_real ?x)) = poly (map_poly Re ?p) ?x\n  max_r \\<in> proots p\n\ngoal (1 subgoal):\n 1. Re ((poly pp \\<circ>\n         (\\<lambda>x.\n             complex_of_real\n              ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n         ((1 - (max_r + r) / (2 * r)) * 0 + (max_r + r) / (2 * r))) =\n    0", "by (auto simp add:field_simps p_def)"], ["proof (state)\nthis:\n  Re (g3 0) = 0\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "have \"0 \\<notin> path_image g3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image g3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image g3", "have \"(1::real) \\<in> {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> {0..1}", "by auto"], ["proof (state)\nthis:\n  1 \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image g3", "then"], ["proof (chain)\npicking this:\n  1 \\<in> {0..1}", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image g3", "using Path_Connected.path_image_subpath_subset \\<open>\\<And>r. path (g r)\\<close> g3_def not_g_image uv(2)"], ["proof (prove)\nusing this:\n  1 \\<in> {0..1}\n  \\<lbrakk>?u \\<in> {0..1}; ?v \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> path_image (subpath ?u ?v ?g) \\<subseteq> path_image ?g\n  path (g ?r)\n  g3 = subpath v 1 (g r)\n  0 \\<notin> path_image (g ?r)\n  v \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image g3", "by blast"], ["proof (state)\nthis:\n  0 \\<notin> path_image g3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<notin> path_image g3\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "have wc_add_pos:\"wc_add h = arctan (poly q r / poly p r) / pi\" when \n          Re_pos:\"\\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> h) x\"\n          and hp:\"\\<forall>t. Re (h t) = c*poly p ((r-max_r)*t + max_r)\"\n          and hq:\"\\<forall>t. Im (h t) = c*poly q ((r-max_r)*t + max_r)\"\n          and [simp]:\"c\\<noteq>0\"\n          (*and hpq:\"\\<forall>t. Im (h t)/Re (h t) = (f o (\\<lambda>x. (min_r+r)*x - r)) t\"*)\n          and \"Re (h 0) = 0\"\n          and \"valid_path h\"\n          and h_img:\"0 \\<notin> path_image h\"\n          for h c"], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add h = arctan (poly q r / poly p r) / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wc_add h = arctan (poly q r / poly p r) / pi", "define f where \"f=(\\<lambda>t. c*poly q t / (c*poly p t))\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. c * poly q t / (c * poly p t))\n\ngoal (1 subgoal):\n 1. wc_add h = arctan (poly q r / poly p r) / pi", "define farg where \"farg= (if 0 < Im (h 0) then pi / 2 else - pi / 2)\""], ["proof (state)\nthis:\n  farg = (if 0 < Im (h 0) then pi / 2 else - pi / 2)\n\ngoal (1 subgoal):\n 1. wc_add h = arctan (poly q r / poly p r) / pi", "have \"Re (winding_number h 0) = (Im (Ln (pathfinish h)) \n              - Im (Ln (pathstart h))) / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (winding_number h 0) =\n    (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi)", "apply (rule Re_winding_number_half_right[of h 0,simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>p\\<in>path_image h. 0 \\<le> Re p\n 2. valid_path h\n 3. 0 \\<notin> path_image h", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image h. 0 \\<le> Re p", "using that \\<open>Re (h 0) = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> h) x\n  \\<forall>t. Re (h t) = c * poly p ((r - max_r) * t + max_r)\n  \\<forall>t. Im (h t) = c * poly q ((r - max_r) * t + max_r)\n  c \\<noteq> 0\n  Re (h 0) = 0\n  valid_path h\n  0 \\<notin> path_image h\n  Re (h 0) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>path_image h. 0 \\<le> Re p", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> h) x\n  \\<forall>t. Re (h t) = c * poly p ((r - max_r) * t + max_r)\n  \\<forall>t. Im (h t) = c * poly q ((r - max_r) * t + max_r)\n  c \\<noteq> 0\n  Re (h 0) = 0\n  valid_path h\n  0 \\<notin> h ` {0..1}\n  Re (h 0) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>h ` {0..1}. 0 \\<le> Re p", "by (auto simp add:le_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid_path h\n 2. 0 \\<notin> path_image h", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path h", "using \\<open>valid_path h\\<close>"], ["proof (prove)\nusing this:\n  valid_path h\n\ngoal (1 subgoal):\n 1. valid_path h", "."], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image h", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image h", "using h_img"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. 0 \\<notin> path_image h", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Re (winding_number h 0) =\n  (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. wc_add h = arctan (poly q r / poly p r) / pi", "also"], ["proof (state)\nthis:\n  Re (winding_number h 0) =\n  (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi)\n\ngoal (1 subgoal):\n 1. wc_add h = arctan (poly q r / poly p r) / pi", "have \"... = (arctan (f r) - farg) / (2 * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (arctan (f r) - farg) / (2 * pi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (arctan (f r) - farg) / (2 * pi)", "have \"Im (Ln (pathstart h)) = farg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (pathstart h)) = farg", "using \\<open>Re(h 0)=0\\<close>"], ["proof (prove)\nusing this:\n  Re (h 0) = 0\n\ngoal (1 subgoal):\n 1. Im (Ln (pathstart h)) = farg", "unfolding farg_def path_defs"], ["proof (prove)\nusing this:\n  Re (h 0) = 0\n\ngoal (1 subgoal):\n 1. Im (Ln (h 0)) = (if 0 < Im (h 0) then pi / 2 else - pi / 2)", "apply (subst Im_Ln_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Re (h 0) = 0 \\<Longrightarrow> h 0 \\<noteq> 0\n 2. Re (h 0) = 0 \\<Longrightarrow>\n    (if Re (h 0) \\<noteq> 0\n     then if 0 < Re (h 0) then arctan (Im (h 0) / Re (h 0))\n          else if 0 \\<le> Im (h 0) then arctan (Im (h 0) / Re (h 0)) + pi\n               else arctan (Im (h 0) / Re (h 0)) - pi\n     else if 0 < Im (h 0) then pi / 2 else - pi / 2) =\n    (if 0 < Im (h 0) then pi / 2 else - pi / 2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (h 0) = 0 \\<Longrightarrow> h 0 \\<noteq> 0", "using h_img"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. Re (h 0) = 0 \\<Longrightarrow> h 0 \\<noteq> 0", "unfolding path_defs"], ["proof (prove)\nusing this:\n  0 \\<notin> h ` {0..1}\n\ngoal (1 subgoal):\n 1. Re (h 0) = 0 \\<Longrightarrow> h 0 \\<noteq> 0", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (h 0) = 0 \\<Longrightarrow>\n    (if Re (h 0) \\<noteq> 0\n     then if 0 < Re (h 0) then arctan (Im (h 0) / Re (h 0))\n          else if 0 \\<le> Im (h 0) then arctan (Im (h 0) / Re (h 0)) + pi\n               else arctan (Im (h 0) / Re (h 0)) - pi\n     else if 0 < Im (h 0) then pi / 2 else - pi / 2) =\n    (if 0 < Im (h 0) then pi / 2 else - pi / 2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (h 0) = 0 \\<Longrightarrow>\n    (if Re (h 0) \\<noteq> 0\n     then if 0 < Re (h 0) then arctan (Im (h 0) / Re (h 0))\n          else if 0 \\<le> Im (h 0) then arctan (Im (h 0) / Re (h 0)) + pi\n               else arctan (Im (h 0) / Re (h 0)) - pi\n     else if 0 < Im (h 0) then pi / 2 else - pi / 2) =\n    (if 0 < Im (h 0) then pi / 2 else - pi / 2)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Im (Ln (pathstart h)) = farg\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (arctan (f r) - farg) / (2 * pi)", "moreover"], ["proof (state)\nthis:\n  Im (Ln (pathstart h)) = farg\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (arctan (f r) - farg) / (2 * pi)", "have \"Im (Ln (pathfinish h)) = arctan (f r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish h)) = arctan (f r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish h)) = arctan (f r)", "have \"pathfinish h \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish h \\<noteq> 0", "using h_img"], ["proof (prove)\nusing this:\n  0 \\<notin> path_image h\n\ngoal (1 subgoal):\n 1. pathfinish h \\<noteq> 0", "by (metis pathfinish_in_path_image)"], ["proof (state)\nthis:\n  pathfinish h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish h)) = arctan (f r)", "then"], ["proof (chain)\npicking this:\n  pathfinish h \\<noteq> 0", "have \"Im (Ln (pathfinish h)) = arctan (Im (pathfinish h) / Re (pathfinish h))\""], ["proof (prove)\nusing this:\n  pathfinish h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish h)) = arctan (Im (pathfinish h) / Re (pathfinish h))", "using Re_pos[rule_format,of 1]"], ["proof (prove)\nusing this:\n  pathfinish h \\<noteq> 0\n  1 \\<in> {0<..1} \\<Longrightarrow> 0 < (Re \\<circ> h) 1\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish h)) = arctan (Im (pathfinish h) / Re (pathfinish h))", "by (simp add: Im_Ln_eq path_defs)"], ["proof (state)\nthis:\n  Im (Ln (pathfinish h)) = arctan (Im (pathfinish h) / Re (pathfinish h))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish h)) = arctan (f r)", "also"], ["proof (state)\nthis:\n  Im (Ln (pathfinish h)) = arctan (Im (pathfinish h) / Re (pathfinish h))\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish h)) = arctan (f r)", "have \"... = arctan (f r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arctan (Im (pathfinish h) / Re (pathfinish h)) = arctan (f r)", "unfolding f_def path_defs hp[rule_format] hq[rule_format]"], ["proof (prove)\ngoal (1 subgoal):\n 1. arctan\n     (c * poly q ((r - max_r) * 1 + max_r) /\n      (c * poly p ((r - max_r) * 1 + max_r))) =\n    arctan (c * poly q r / (c * poly p r))", "by simp"], ["proof (state)\nthis:\n  arctan (Im (pathfinish h) / Re (pathfinish h)) = arctan (f r)\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish h)) = arctan (f r)", "finally"], ["proof (chain)\npicking this:\n  Im (Ln (pathfinish h)) = arctan (f r)", "show ?thesis"], ["proof (prove)\nusing this:\n  Im (Ln (pathfinish h)) = arctan (f r)\n\ngoal (1 subgoal):\n 1. Im (Ln (pathfinish h)) = arctan (f r)", "."], ["proof (state)\nthis:\n  Im (Ln (pathfinish h)) = arctan (f r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im (Ln (pathfinish h)) = arctan (f r)\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (arctan (f r) - farg) / (2 * pi)", "ultimately"], ["proof (chain)\npicking this:\n  Im (Ln (pathstart h)) = farg\n  Im (Ln (pathfinish h)) = arctan (f r)", "show ?thesis"], ["proof (prove)\nusing this:\n  Im (Ln (pathstart h)) = farg\n  Im (Ln (pathfinish h)) = arctan (f r)\n\ngoal (1 subgoal):\n 1. (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n    (arctan (f r) - farg) / (2 * pi)", "by auto"], ["proof (state)\nthis:\n  (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n  (arctan (f r) - farg) / (2 * pi)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Im (Ln (pathfinish h)) - Im (Ln (pathstart h))) / (2 * pi) =\n  (arctan (f r) - farg) / (2 * pi)\n\ngoal (1 subgoal):\n 1. wc_add h = arctan (poly q r / poly p r) / pi", "finally"], ["proof (chain)\npicking this:\n  Re (winding_number h 0) = (arctan (f r) - farg) / (2 * pi)", "have \"Re (winding_number h 0) = (arctan (f r) - farg) / (2 * pi)\""], ["proof (prove)\nusing this:\n  Re (winding_number h 0) = (arctan (f r) - farg) / (2 * pi)\n\ngoal (1 subgoal):\n 1. Re (winding_number h 0) = (arctan (f r) - farg) / (2 * pi)", "."], ["proof (state)\nthis:\n  Re (winding_number h 0) = (arctan (f r) - farg) / (2 * pi)\n\ngoal (1 subgoal):\n 1. wc_add h = arctan (poly q r / poly p r) / pi", "moreover"], ["proof (state)\nthis:\n  Re (winding_number h 0) = (arctan (f r) - farg) / (2 * pi)\n\ngoal (1 subgoal):\n 1. wc_add h = arctan (poly q r / poly p r) / pi", "have \"cindex_pathE h 0 = farg/pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = farg / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = farg / pi", "have \"cindex_pathE h 0 = cindexE 0 1 (f \\<circ> (\\<lambda>x. (r-max_r)*x + max_r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE h 0 =\n    cindexE 0 1 (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r))", "unfolding cindex_pathE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (h t - 0) / Re (h t - 0)) =\n    cindexE 0 1 (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r))", "using \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindexE 0 1 (\\<lambda>t. Im (h t - 0) / Re (h t - 0)) =\n    cindexE 0 1 (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r))", "by (auto simp add:hp hq f_def comp_def algebra_simps)"], ["proof (state)\nthis:\n  cindex_pathE h 0 =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r))\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = farg / pi", "also"], ["proof (state)\nthis:\n  cindex_pathE h 0 =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r))\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = farg / pi", "have \"... = cindexE max_r r f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) =\n    cindexE max_r r f", "apply (subst cindexE_linear_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. r - max_r \\<noteq> 0\n 2. (if 0 < r - max_r\n     then cindexE ((r - max_r) * 0 + max_r) ((r - max_r) * 1 + max_r) f\n     else - cindexE ((r - max_r) * 1 + max_r) ((r - max_r) * 0 + max_r) f) =\n    cindexE max_r r f", "using r_asm"], ["proof (prove)\nusing this:\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n\ngoal (2 subgoals):\n 1. r - max_r \\<noteq> 0\n 2. (if 0 < r - max_r\n     then cindexE ((r - max_r) * 0 + max_r) ((r - max_r) * 1 + max_r) f\n     else - cindexE ((r - max_r) * 1 + max_r) ((r - max_r) * 0 + max_r) f) =\n    cindexE max_r r f", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) =\n  cindexE max_r r f\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = farg / pi", "also"], ["proof (state)\nthis:\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) =\n  cindexE max_r r f\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = farg / pi", "have \"... = jumpF f (at_right max_r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE max_r r f = jumpF f (at_right max_r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE max_r r f = jumpF f (at_right max_r)", "define right where \"right = {x. jumpF f (at_right x) \\<noteq> 0 \\<and> max_r \\<le> x \\<and> x < r}\""], ["proof (state)\nthis:\n  right =\n  {x. jumpF f (at_right x) \\<noteq> 0 \\<and> max_r \\<le> x \\<and> x < r}\n\ngoal (1 subgoal):\n 1. cindexE max_r r f = jumpF f (at_right max_r)", "define left where \"left = {x. jumpF f (at_left x) \\<noteq> 0 \\<and> max_r < x \\<and> x \\<le> r}\""], ["proof (state)\nthis:\n  left =\n  {x. jumpF f (at_left x) \\<noteq> 0 \\<and> max_r < x \\<and> x \\<le> r}\n\ngoal (1 subgoal):\n 1. cindexE max_r r f = jumpF f (at_right max_r)", "have *:\"jumpF f (at_right x) =0\" \"jumpF f (at_left x) =0\" when \"x\\<in>{max_r<..r}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0 &&& jumpF f (at_left x) = 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. jumpF f (at_right x) = 0\n 2. jumpF f (at_left x) = 0", "have False when \"poly p x =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"x\\<le>max_r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> max_r", "using min_max_bound[rule_format,of x] that"], ["proof (prove)\nusing this:\n  x \\<in> proots p \\<Longrightarrow> x \\<in> {min_r..max_r}\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. x \\<le> max_r", "by auto"], ["proof (state)\nthis:\n  x \\<le> max_r\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  x \\<le> max_r", "show False"], ["proof (prove)\nusing this:\n  x \\<le> max_r\n\ngoal (1 subgoal):\n 1. False", "using \\<open>x\\<in>{max_r<..r}\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> max_r\n  x \\<in> {max_r<..r}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p x = 0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. jumpF f (at_right x) = 0\n 2. jumpF f (at_left x) = 0", "then"], ["proof (chain)\npicking this:\n  poly p x = 0 \\<Longrightarrow> False", "show \"jumpF f (at_right x) =0\" \"jumpF f (at_left x) =0\""], ["proof (prove)\nusing this:\n  poly p x = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jumpF f (at_right x) = 0 &&& jumpF f (at_left x) = 0", "unfolding f_def"], ["proof (prove)\nusing this:\n  poly p x = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. jumpF (\\<lambda>t. c * poly q t / (c * poly p t)) (at_right x) = 0 &&&\n    jumpF (\\<lambda>t. c * poly q t / (c * poly p t)) (at_left x) = 0", "by (auto intro!:jumpF_not_infinity continuous_intros)"], ["proof (state)\nthis:\n  jumpF f (at_right x) = 0\n  jumpF f (at_left x) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {max_r<..r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  ?x \\<in> {max_r<..r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. cindexE max_r r f = jumpF f (at_right max_r)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {max_r<..r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  ?x \\<in> {max_r<..r} \\<Longrightarrow> jumpF f (at_left ?x) = 0", "have \"left = {}\""], ["proof (prove)\nusing this:\n  ?x \\<in> {max_r<..r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  ?x \\<in> {max_r<..r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. left = {}", "unfolding left_def"], ["proof (prove)\nusing this:\n  ?x \\<in> {max_r<..r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  ?x \\<in> {max_r<..r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_left x) \\<noteq> 0 \\<and> max_r < x \\<and> x \\<le> r} =\n    {}", "by force"], ["proof (state)\nthis:\n  left = {}\n\ngoal (1 subgoal):\n 1. cindexE max_r r f = jumpF f (at_right max_r)", "moreover"], ["proof (state)\nthis:\n  left = {}\n\ngoal (1 subgoal):\n 1. cindexE max_r r f = jumpF f (at_right max_r)", "have \"right = (if jumpF f (at_right max_r) = 0 then {} else {max_r})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right = (if jumpF f (at_right max_r) = 0 then {} else {max_r})", "unfolding right_def le_less"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        (max_r < x \\<or> max_r = x) \\<and> x < r} =\n    (if jumpF f (at_right max_r) = 0 then {} else {max_r})", "using * r_asm"], ["proof (prove)\nusing this:\n  ?x \\<in> {max_r<..r} \\<Longrightarrow> jumpF f (at_right ?x) = 0\n  ?x \\<in> {max_r<..r} \\<Longrightarrow> jumpF f (at_left ?x) = 0\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. {x. jumpF f (at_right x) \\<noteq> 0 \\<and>\n        (max_r < x \\<or> max_r = x) \\<and> x < r} =\n    (if jumpF f (at_right max_r) = 0 then {} else {max_r})", "by force"], ["proof (state)\nthis:\n  right = (if jumpF f (at_right max_r) = 0 then {} else {max_r})\n\ngoal (1 subgoal):\n 1. cindexE max_r r f = jumpF f (at_right max_r)", "ultimately"], ["proof (chain)\npicking this:\n  left = {}\n  right = (if jumpF f (at_right max_r) = 0 then {} else {max_r})", "show ?thesis"], ["proof (prove)\nusing this:\n  left = {}\n  right = (if jumpF f (at_right max_r) = 0 then {} else {max_r})\n\ngoal (1 subgoal):\n 1. cindexE max_r r f = jumpF f (at_right max_r)", "unfolding cindexE_def"], ["proof (prove)\nusing this:\n  left = {}\n  right = (if jumpF f (at_right max_r) = 0 then {} else {max_r})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | jumpF f (at_right x) \\<noteq> 0 \\<and>\n               max_r \\<le> x \\<and> x < r.\n       jumpF f (at_right x)) -\n    (\\<Sum>x | jumpF f (at_left x) \\<noteq> 0 \\<and>\n               max_r < x \\<and> x \\<le> r.\n       jumpF f (at_left x)) =\n    jumpF f (at_right max_r)", "by (fold left_def right_def,auto)"], ["proof (state)\nthis:\n  cindexE max_r r f = jumpF f (at_right max_r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE max_r r f = jumpF f (at_right max_r)\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = farg / pi", "also"], ["proof (state)\nthis:\n  cindexE max_r r f = jumpF f (at_right max_r)\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = farg / pi", "have \"... = farg/pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "have p_pos:\"c*poly p x > 0\" when \"x \\<in> {max_r<..<r}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "define hh where \"hh=(\\<lambda>t. (r-max_r)*t + max_r)\""], ["proof (state)\nthis:\n  hh = (\\<lambda>t. (r - max_r) * t + max_r)\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "have \"(x-max_r)/(r-max_r) \\<in> {0<..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - max_r) / (r - max_r) \\<in> {0<..1}", "using that r_asm"], ["proof (prove)\nusing this:\n  x \\<in> {max_r<..<r}\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. (x - max_r) / (r - max_r) \\<in> {0<..1}", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  (x - max_r) / (r - max_r) \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "then"], ["proof (chain)\npicking this:\n  (x - max_r) / (r - max_r) \\<in> {0<..1}", "have \"0 < c*poly p (hh ((x-max_r)/(r-max_r)))\""], ["proof (prove)\nusing this:\n  (x - max_r) / (r - max_r) \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. 0 < c * poly p (hh ((x - max_r) / (r - max_r)))", "apply (drule_tac Re_pos[rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (Re \\<circ> h) ((x - max_r) / (r - max_r)) \\<Longrightarrow>\n    0 < c * poly p (hh ((x - max_r) / (r - max_r)))", "unfolding comp_def hp[rule_format]  hq[rule_format] hh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c *\n        poly p\n         ((r - max_r) * ((x - max_r) / (r - max_r)) +\n          max_r) \\<Longrightarrow>\n    0 < c * poly p ((r - max_r) * ((x - max_r) / (r - max_r)) + max_r)", "."], ["proof (state)\nthis:\n  0 < c * poly p (hh ((x - max_r) / (r - max_r)))\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "moreover"], ["proof (state)\nthis:\n  0 < c * poly p (hh ((x - max_r) / (r - max_r)))\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "have \"hh ((x-max_r)/(r-max_r)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hh ((x - max_r) / (r - max_r)) = x", "unfolding hh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r - max_r) * ((x - max_r) / (r - max_r)) + max_r = x", "using \\<open>max_r<r\\<close>"], ["proof (prove)\nusing this:\n  max_r < r\n\ngoal (1 subgoal):\n 1. (r - max_r) * ((x - max_r) / (r - max_r)) + max_r = x", "by (auto simp add:divide_simps)"], ["proof (state)\nthis:\n  hh ((x - max_r) / (r - max_r)) = x\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "ultimately"], ["proof (chain)\npicking this:\n  0 < c * poly p (hh ((x - max_r) / (r - max_r)))\n  hh ((x - max_r) / (r - max_r)) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < c * poly p (hh ((x - max_r) / (r - max_r)))\n  hh ((x - max_r) / (r - max_r)) = x\n\ngoal (1 subgoal):\n 1. 0 < c * poly p x", "by simp"], ["proof (state)\nthis:\n  0 < c * poly p x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {max_r<..<r} \\<Longrightarrow> 0 < c * poly p ?x\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "have \"c*poly q max_r \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * poly q max_r \\<noteq> 0", "using no_real_zero \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>proots pp. Im x \\<noteq> 0\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c * poly q max_r \\<noteq> 0", "by (metis Im_complex_of_real UNIV_I \\<open>max_r \\<in> proots p\\<close> cpoly_of_decompose \n                    mult_eq_0_iff p_def poly_cpoly_of_real_iff proots_within_iff q_def)"], ["proof (state)\nthis:\n  c * poly q max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "moreover"], ["proof (state)\nthis:\n  c * poly q max_r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "have ?thesis when \"c*poly q max_r > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "have \"0 < Im (h 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Im (h 0)", "unfolding hq[rule_format] hp[rule_format]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c * poly q ((r - max_r) * 0 + max_r)", "using that"], ["proof (prove)\nusing this:\n  0 < c * poly q max_r\n\ngoal (1 subgoal):\n 1. 0 < c * poly q ((r - max_r) * 0 + max_r)", "by auto"], ["proof (state)\nthis:\n  0 < Im (h 0)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "moreover"], ["proof (state)\nthis:\n  0 < Im (h 0)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "have \"jumpF f (at_right max_r) = 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = 1 / 2", "have \"((\\<lambda>t. c*poly p t) has_sgnx 1) (at_right max_r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_right max_r)", "unfolding has_sgnx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right max_r. sgn (c * poly p x) = 1", "apply (rule eventually_at_rightI[of _ \"r\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {max_r<..<r} \\<Longrightarrow> sgn (c * poly p x) = 1\n 2. max_r < r", "using p_pos \\<open>max_r<r\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> {max_r<..<r} \\<Longrightarrow> 0 < c * poly p ?x\n  max_r < r\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {max_r<..<r} \\<Longrightarrow> sgn (c * poly p x) = 1\n 2. max_r < r", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_right max_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = 1 / 2", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_right max_r)", "have \"filterlim f at_top (at_right max_r)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_right max_r)\n\ngoal (1 subgoal):\n 1. filterlim f at_top (at_right max_r)", "unfolding f_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_right max_r)\n\ngoal (1 subgoal):\n 1. LIM t at_right max_r. c * poly q t / (c * poly p t) :> at_top", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"c*poly q max_r\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly q t) \\<longlongrightarrow> c * poly q max_r)\n     (at_right max_r)\n 2. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    c * poly q max_r \\<noteq> 0\n 3. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly p t) \\<longlongrightarrow> 0)\n     (at_right max_r) \\<and>\n    ((\\<lambda>x. c * poly p x) has_sgnx sgn (c * poly q max_r))\n     (at_right max_r)", "using that \\<open>max_r\\<in>proots p\\<close>"], ["proof (prove)\nusing this:\n  0 < c * poly q max_r\n  max_r \\<in> proots p\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly q t) \\<longlongrightarrow> c * poly q max_r)\n     (at_right max_r)\n 2. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    c * poly q max_r \\<noteq> 0\n 3. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly p t) \\<longlongrightarrow> 0)\n     (at_right max_r) \\<and>\n    ((\\<lambda>x. c * poly p x) has_sgnx sgn (c * poly q max_r))\n     (at_right max_r)", "by (auto intro!:tendsto_eq_intros)"], ["proof (state)\nthis:\n  filterlim f at_top (at_right max_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = 1 / 2", "then"], ["proof (chain)\npicking this:\n  filterlim f at_top (at_right max_r)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_top (at_right max_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  filterlim f at_top (at_right max_r)\n\ngoal (1 subgoal):\n 1. (if filterlim f at_top (at_right max_r) then 1 / 2\n     else if filterlim f at_bot (at_right max_r) then - 1 / 2 else 0) =\n    1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF f (at_right max_r) = 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF f (at_right max_r) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "ultimately"], ["proof (chain)\npicking this:\n  0 < Im (h 0)\n  jumpF f (at_right max_r) = 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < Im (h 0)\n  jumpF f (at_right max_r) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "unfolding farg_def"], ["proof (prove)\nusing this:\n  0 < Im (h 0)\n  jumpF f (at_right max_r) = 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) =\n    (if 0 < Im (h 0) then pi / 2 else - pi / 2) / pi", "by auto"], ["proof (state)\nthis:\n  jumpF f (at_right max_r) = farg / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < c * poly q max_r \\<Longrightarrow>\n  jumpF f (at_right max_r) = farg / pi\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "moreover"], ["proof (state)\nthis:\n  0 < c * poly q max_r \\<Longrightarrow>\n  jumpF f (at_right max_r) = farg / pi\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "have ?thesis when \"c*poly q max_r < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "have \"0 > Im (h 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (h 0) < 0", "unfolding hq[rule_format] hp[rule_format]"], ["proof (prove)\ngoal (1 subgoal):\n 1. c * poly q ((r - max_r) * 0 + max_r) < 0", "using that"], ["proof (prove)\nusing this:\n  c * poly q max_r < 0\n\ngoal (1 subgoal):\n 1. c * poly q ((r - max_r) * 0 + max_r) < 0", "by auto"], ["proof (state)\nthis:\n  Im (h 0) < 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "moreover"], ["proof (state)\nthis:\n  Im (h 0) < 0\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "have \"jumpF f (at_right max_r) = - 1/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = - 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = - 1 / 2", "have \"((\\<lambda>t. c*poly p t) has_sgnx 1) (at_right max_r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_right max_r)", "unfolding has_sgnx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_right max_r. sgn (c * poly p x) = 1", "apply (rule eventually_at_rightI[of _ \"r\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {max_r<..<r} \\<Longrightarrow> sgn (c * poly p x) = 1\n 2. max_r < r", "using p_pos \\<open>max_r<r\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> {max_r<..<r} \\<Longrightarrow> 0 < c * poly p ?x\n  max_r < r\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {max_r<..<r} \\<Longrightarrow> sgn (c * poly p x) = 1\n 2. max_r < r", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_right max_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_right max_r)", "have \"filterlim f at_bot (at_right max_r)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_right max_r)\n\ngoal (1 subgoal):\n 1. filterlim f at_bot (at_right max_r)", "unfolding f_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>t. c * poly p t) has_sgnx 1) (at_right max_r)\n\ngoal (1 subgoal):\n 1. LIM t at_right max_r. c * poly q t / (c * poly p t) :> at_bot", "apply (subst filterlim_divide_at_bot_at_top_iff[of _ \"c*poly q max_r\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly q t) \\<longlongrightarrow> c * poly q max_r)\n     (at_right max_r)\n 2. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    c * poly q max_r \\<noteq> 0\n 3. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly p t) \\<longlongrightarrow> 0)\n     (at_right max_r) \\<and>\n    ((\\<lambda>x. c * poly p x) has_sgnx - sgn (c * poly q max_r))\n     (at_right max_r)", "using that \\<open>max_r\\<in>proots p\\<close>"], ["proof (prove)\nusing this:\n  c * poly q max_r < 0\n  max_r \\<in> proots p\n\ngoal (3 subgoals):\n 1. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly q t) \\<longlongrightarrow> c * poly q max_r)\n     (at_right max_r)\n 2. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    c * poly q max_r \\<noteq> 0\n 3. ((\\<lambda>t. c * poly p t) has_sgnx 1)\n     (at_right max_r) \\<Longrightarrow>\n    ((\\<lambda>t. c * poly p t) \\<longlongrightarrow> 0)\n     (at_right max_r) \\<and>\n    ((\\<lambda>x. c * poly p x) has_sgnx - sgn (c * poly q max_r))\n     (at_right max_r)", "by (auto intro!:tendsto_eq_intros)"], ["proof (state)\nthis:\n  filterlim f at_bot (at_right max_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = - 1 / 2", "then"], ["proof (chain)\npicking this:\n  filterlim f at_bot (at_right max_r)", "show ?thesis"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_right max_r)\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = - 1 / 2", "unfolding jumpF_def"], ["proof (prove)\nusing this:\n  filterlim f at_bot (at_right max_r)\n\ngoal (1 subgoal):\n 1. (if filterlim f at_top (at_right max_r) then 1 / 2\n     else if filterlim f at_bot (at_right max_r) then - 1 / 2 else 0) =\n    - 1 / 2", "by auto"], ["proof (state)\nthis:\n  jumpF f (at_right max_r) = - 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF f (at_right max_r) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "ultimately"], ["proof (chain)\npicking this:\n  Im (h 0) < 0\n  jumpF f (at_right max_r) = - 1 / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  Im (h 0) < 0\n  jumpF f (at_right max_r) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "unfolding farg_def"], ["proof (prove)\nusing this:\n  Im (h 0) < 0\n  jumpF f (at_right max_r) = - 1 / 2\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) =\n    (if 0 < Im (h 0) then pi / 2 else - pi / 2) / pi", "by auto"], ["proof (state)\nthis:\n  jumpF f (at_right max_r) = farg / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c * poly q max_r < 0 \\<Longrightarrow>\n  jumpF f (at_right max_r) = farg / pi\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "ultimately"], ["proof (chain)\npicking this:\n  c * poly q max_r \\<noteq> 0\n  0 < c * poly q max_r \\<Longrightarrow>\n  jumpF f (at_right max_r) = farg / pi\n  c * poly q max_r < 0 \\<Longrightarrow>\n  jumpF f (at_right max_r) = farg / pi", "show ?thesis"], ["proof (prove)\nusing this:\n  c * poly q max_r \\<noteq> 0\n  0 < c * poly q max_r \\<Longrightarrow>\n  jumpF f (at_right max_r) = farg / pi\n  c * poly q max_r < 0 \\<Longrightarrow>\n  jumpF f (at_right max_r) = farg / pi\n\ngoal (1 subgoal):\n 1. jumpF f (at_right max_r) = farg / pi", "by linarith"], ["proof (state)\nthis:\n  jumpF f (at_right max_r) = farg / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  jumpF f (at_right max_r) = farg / pi\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = farg / pi", "finally"], ["proof (chain)\npicking this:\n  cindex_pathE h 0 = farg / pi", "show ?thesis"], ["proof (prove)\nusing this:\n  cindex_pathE h 0 = farg / pi\n\ngoal (1 subgoal):\n 1. cindex_pathE h 0 = farg / pi", "."], ["proof (state)\nthis:\n  cindex_pathE h 0 = farg / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_pathE h 0 = farg / pi\n\ngoal (1 subgoal):\n 1. wc_add h = arctan (poly q r / poly p r) / pi", "ultimately"], ["proof (chain)\npicking this:\n  Re (winding_number h 0) = (arctan (f r) - farg) / (2 * pi)\n  cindex_pathE h 0 = farg / pi", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (winding_number h 0) = (arctan (f r) - farg) / (2 * pi)\n  cindex_pathE h 0 = farg / pi\n\ngoal (1 subgoal):\n 1. wc_add h = arctan (poly q r / poly p r) / pi", "unfolding wc_add_def f_def"], ["proof (prove)\nusing this:\n  Re (winding_number h 0) =\n  (arctan (c * poly q r / (c * poly p r)) - farg) / (2 * pi)\n  cindex_pathE h 0 = farg / pi\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number h 0) + cindex_pathE h 0 =\n    arctan (poly q r / poly p r) / pi", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  wc_add h = arctan (poly q r / poly p r) / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> ?h) x;\n   \\<forall>t. Re (?h t) = ?c * poly p ((r - max_r) * t + max_r);\n   \\<forall>t. Im (?h t) = ?c * poly q ((r - max_r) * t + max_r);\n   ?c \\<noteq> 0; Re (?h 0) = 0; valid_path ?h;\n   0 \\<notin> path_image ?h\\<rbrakk>\n  \\<Longrightarrow> wc_add ?h = arctan (poly q r / poly p r) / pi\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "have \"\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0<..1}.\n               (Re \\<circ> g3) x \\<noteq> 0) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x \\<noteq> 0)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0<..1}.\n               (Re \\<circ> g3) x \\<noteq> 0) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x \\<noteq> 0)", "obtain t where t_def:\"Re (g3 t) =0\" \"t\\<in>{0<..1}\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>Re (g3 t) = 0; t \\<in> {0<..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding path_image_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>Re (g3 t) = 0; t \\<in> {0<..1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  Re (g3 t) = 0\n  t \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0<..1}.\n               (Re \\<circ> g3) x \\<noteq> 0) \\<Longrightarrow>\n    False", "define m where \"m=(r-max_r)*t + max_r\""], ["proof (state)\nthis:\n  m = (r - max_r) * t + max_r\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0<..1}.\n               (Re \\<circ> g3) x \\<noteq> 0) \\<Longrightarrow>\n    False", "have \"poly p m=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p m = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p m = 0", "have \"Re (g3 t) = Re (poly pp (of_real m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (g3 t) = Re (poly pp (complex_of_real m))", "unfolding m_def g3_def g_def linepath_def subpath_def v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((poly pp \\<circ>\n         (\\<lambda>x.\n             complex_of_real\n              ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n         ((1 - (max_r + r) / (2 * r)) * t + (max_r + r) / (2 * r))) =\n    Re (poly pp (complex_of_real ((r - max_r) * t + max_r)))", "using \\<open>r\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re ((poly pp \\<circ>\n         (\\<lambda>x.\n             complex_of_real\n              ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n         ((1 - (max_r + r) / (2 * r)) * t + (max_r + r) / (2 * r))) =\n    Re (poly pp (complex_of_real ((r - max_r) * t + max_r)))", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  Re (g3 t) = Re (poly pp (complex_of_real m))\n\ngoal (1 subgoal):\n 1. poly p m = 0", "then"], ["proof (chain)\npicking this:\n  Re (g3 t) = Re (poly pp (complex_of_real m))", "show ?thesis"], ["proof (prove)\nusing this:\n  Re (g3 t) = Re (poly pp (complex_of_real m))\n\ngoal (1 subgoal):\n 1. poly p m = 0", "using t_def"], ["proof (prove)\nusing this:\n  Re (g3 t) = Re (poly pp (complex_of_real m))\n  Re (g3 t) = 0\n  t \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. poly p m = 0", "unfolding Re_poly_of_real p_def"], ["proof (prove)\nusing this:\n  Re (g3 t) = poly (map_poly Re pp) m\n  Re (g3 t) = 0\n  t \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. poly (map_poly Re pp) m = 0", "by auto"], ["proof (state)\nthis:\n  poly p m = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p m = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0<..1}.\n               (Re \\<circ> g3) x \\<noteq> 0) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  poly p m = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0<..1}.\n               (Re \\<circ> g3) x \\<noteq> 0) \\<Longrightarrow>\n    False", "have \"m>max_r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_r < m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. max_r < m", "have \"r-max_r>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r - max_r", "using r_asm"], ["proof (prove)\nusing this:\n  max (norm max_r) (norm min_r) + 1 \\<le> r\n\ngoal (1 subgoal):\n 1. 0 < r - max_r", "by simp"], ["proof (state)\nthis:\n  0 < r - max_r\n\ngoal (1 subgoal):\n 1. max_r < m", "then"], ["proof (chain)\npicking this:\n  0 < r - max_r", "have \"(r - max_r)*t>0\""], ["proof (prove)\nusing this:\n  0 < r - max_r\n\ngoal (1 subgoal):\n 1. 0 < (r - max_r) * t", "using \\<open>t\\<in>{0<..1}\\<close>"], ["proof (prove)\nusing this:\n  0 < r - max_r\n  t \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. 0 < (r - max_r) * t", "by (simp add: mult_pos_neg)"], ["proof (state)\nthis:\n  0 < (r - max_r) * t\n\ngoal (1 subgoal):\n 1. max_r < m", "then"], ["proof (chain)\npicking this:\n  0 < (r - max_r) * t", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < (r - max_r) * t\n\ngoal (1 subgoal):\n 1. max_r < m", "unfolding m_def"], ["proof (prove)\nusing this:\n  0 < (r - max_r) * t\n\ngoal (1 subgoal):\n 1. max_r < (r - max_r) * t + max_r", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  max_r < m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max_r < m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{0<..1}.\n               (Re \\<circ> g3) x \\<noteq> 0) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  poly p m = 0\n  max_r < m", "show False"], ["proof (prove)\nusing this:\n  poly p m = 0\n  max_r < m\n\ngoal (1 subgoal):\n 1. False", "using min_max_bound"], ["proof (prove)\nusing this:\n  poly p m = 0\n  max_r < m\n  \\<forall>p\\<in>proots p. p \\<in> {min_r..max_r}\n\ngoal (1 subgoal):\n 1. False", "unfolding proots_def"], ["proof (prove)\nusing this:\n  poly p m = 0\n  max_r < m\n  \\<forall>p\\<in>{x. poly p x = 0}. p \\<in> {min_r..max_r}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x \\<noteq> 0", "have \"(\\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x) \\<or> (\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x) \\<or>\n    (\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0)", "apply (elim continuous_on_neq_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {0<..1} (Re \\<circ> g3)\n 2. connected {0<..1}", "using \\<open>path g3\\<close>"], ["proof (prove)\nusing this:\n  path g3\n\ngoal (2 subgoals):\n 1. continuous_on {0<..1} (Re \\<circ> g3)\n 2. connected {0<..1}", "unfolding path_def"], ["proof (prove)\nusing this:\n  continuous_on {0..1} g3\n\ngoal (2 subgoals):\n 1. continuous_on {0<..1} (Re \\<circ> g3)\n 2. connected {0<..1}", "by (auto intro!:continuous_intros elim:continuous_on_subset)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x) \\<or>\n  (\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0)\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x) \\<or>\n  (\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0)\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "have ?thesis when \"\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "have \"wc_add (uminus o g3) = arctan (f r) / pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add (uminus \\<circ> g3) = arctan (f r) / pi", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add (uminus \\<circ> g3) = arctan (poly q r / poly p r) / pi", "apply (rule wc_add_pos[of _ \"-1\"])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> (uminus \\<circ> g3)) x\n 2. \\<forall>t.\n       Re ((uminus \\<circ> g3) t) = - 1 * poly p ((r - max_r) * t + max_r)\n 3. \\<forall>t.\n       Im ((uminus \\<circ> g3) t) = - 1 * poly q ((r - max_r) * t + max_r)\n 4. - 1 \\<noteq> 0\n 5. Re ((uminus \\<circ> g3) 0) = 0\n 6. valid_path (uminus \\<circ> g3)\n 7. 0 \\<notin> path_image (uminus \\<circ> g3)", "using g3_pq that \\<open>max_r \\<in>proots p\\<close> \\<open>valid_path g3\\<close> \\<open>0 \\<notin> path_image g3\\<close>"], ["proof (prove)\nusing this:\n  Re (g3 ?t) = poly p ((r - max_r) * ?t + max_r)\n  Im (g3 ?t) = poly q ((r - max_r) * ?t + max_r)\n  Im (g3 ?t) / Re (g3 ?t) =\n  (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) ?t\n  \\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0\n  max_r \\<in> proots p\n  valid_path g3\n  0 \\<notin> path_image g3\n\ngoal (7 subgoals):\n 1. \\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> (uminus \\<circ> g3)) x\n 2. \\<forall>t.\n       Re ((uminus \\<circ> g3) t) = - 1 * poly p ((r - max_r) * t + max_r)\n 3. \\<forall>t.\n       Im ((uminus \\<circ> g3) t) = - 1 * poly q ((r - max_r) * t + max_r)\n 4. - 1 \\<noteq> 0\n 5. Re ((uminus \\<circ> g3) 0) = 0\n 6. valid_path (uminus \\<circ> g3)\n 7. 0 \\<notin> path_image (uminus \\<circ> g3)", "by (auto simp add:path_image_compose)"], ["proof (state)\nthis:\n  wc_add (uminus \\<circ> g3) = arctan (f r) / pi\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "moreover"], ["proof (state)\nthis:\n  wc_add (uminus \\<circ> g3) = arctan (f r) / pi\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "have \"wc_add (uminus \\<circ> g3) = wc_add g3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add (uminus \\<circ> g3) = wc_add g3", "unfolding wc_add_def cindex_pathE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (uminus \\<circ> g3) 0) +\n    cindexE 0 1\n     (\\<lambda>t.\n         Im ((uminus \\<circ> g3) t - 0) / Re ((uminus \\<circ> g3) t - 0)) =\n    2 * Re (winding_number g3 0) +\n    cindexE 0 1 (\\<lambda>t. Im (g3 t - 0) / Re (g3 t - 0))", "apply (subst winding_number_uminus_comp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. valid_path g3\n 2. - 0 \\<notin> path_image g3\n 3. 2 * Re (winding_number g3 (- 0)) +\n    cindexE 0 1\n     (\\<lambda>t.\n         Im ((uminus \\<circ> g3) t - 0) / Re ((uminus \\<circ> g3) t - 0)) =\n    2 * Re (winding_number g3 0) +\n    cindexE 0 1 (\\<lambda>t. Im (g3 t - 0) / Re (g3 t - 0))", "using \\<open>valid_path g3\\<close> \\<open>0 \\<notin> path_image g3\\<close>"], ["proof (prove)\nusing this:\n  valid_path g3\n  0 \\<notin> path_image g3\n\ngoal (3 subgoals):\n 1. valid_path g3\n 2. - 0 \\<notin> path_image g3\n 3. 2 * Re (winding_number g3 (- 0)) +\n    cindexE 0 1\n     (\\<lambda>t.\n         Im ((uminus \\<circ> g3) t - 0) / Re ((uminus \\<circ> g3) t - 0)) =\n    2 * Re (winding_number g3 0) +\n    cindexE 0 1 (\\<lambda>t. Im (g3 t - 0) / Re (g3 t - 0))", "by auto"], ["proof (state)\nthis:\n  wc_add (uminus \\<circ> g3) = wc_add g3\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "ultimately"], ["proof (chain)\npicking this:\n  wc_add (uminus \\<circ> g3) = arctan (f r) / pi\n  wc_add (uminus \\<circ> g3) = wc_add g3", "show ?thesis"], ["proof (prove)\nusing this:\n  wc_add (uminus \\<circ> g3) = arctan (f r) / pi\n  wc_add (uminus \\<circ> g3) = wc_add g3\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "by auto"], ["proof (state)\nthis:\n  wc_add g3 = arctan (f r) / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0 \\<Longrightarrow>\n  wc_add g3 = arctan (f r) / pi\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0 \\<Longrightarrow>\n  wc_add g3 = arctan (f r) / pi\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "have ?thesis when \"\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (poly q r / poly p r) / pi", "apply (rule wc_add_pos[of _ \"1\"])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x\n 2. \\<forall>t. Re (g3 t) = 1 * poly p ((r - max_r) * t + max_r)\n 3. \\<forall>t. Im (g3 t) = 1 * poly q ((r - max_r) * t + max_r)\n 4. 1 \\<noteq> 0\n 5. Re (g3 0) = 0\n 6. valid_path g3\n 7. 0 \\<notin> path_image g3", "using g3_pq that \\<open>max_r \\<in>proots p\\<close> \\<open>valid_path g3\\<close> \\<open>0 \\<notin> path_image g3\\<close>"], ["proof (prove)\nusing this:\n  Re (g3 ?t) = poly p ((r - max_r) * ?t + max_r)\n  Im (g3 ?t) = poly q ((r - max_r) * ?t + max_r)\n  Im (g3 ?t) / Re (g3 ?t) =\n  (f \\<circ> (\\<lambda>x. (r - max_r) * x + max_r)) ?t\n  \\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x\n  max_r \\<in> proots p\n  valid_path g3\n  0 \\<notin> path_image g3\n\ngoal (7 subgoals):\n 1. \\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x\n 2. \\<forall>t. Re (g3 t) = 1 * poly p ((r - max_r) * t + max_r)\n 3. \\<forall>t. Im (g3 t) = 1 * poly q ((r - max_r) * t + max_r)\n 4. 1 \\<noteq> 0\n 5. Re (g3 0) = 0\n 6. valid_path g3\n 7. 0 \\<notin> path_image g3", "by (auto simp add:path_image_compose)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x \\<Longrightarrow>\n  wc_add g3 = arctan (f r) / pi\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x) \\<or>\n  (\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0)\n  \\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0 \\<Longrightarrow>\n  wc_add g3 = arctan (f r) / pi\n  \\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x \\<Longrightarrow>\n  wc_add g3 = arctan (f r) / pi", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x) \\<or>\n  (\\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0)\n  \\<forall>x\\<in>{0<..1}. (Re \\<circ> g3) x < 0 \\<Longrightarrow>\n  wc_add g3 = arctan (f r) / pi\n  \\<forall>x\\<in>{0<..1}. 0 < (Re \\<circ> g3) x \\<Longrightarrow>\n  wc_add g3 = arctan (f r) / pi\n\ngoal (1 subgoal):\n 1. wc_add g3 = arctan (f r) / pi", "by blast"], ["proof (state)\nthis:\n  wc_add g3 = arctan (f r) / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wc_add g3 = arctan (f r) / pi\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "ultimately"], ["proof (chain)\npicking this:\n  wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3\n  wc_add g2 = 0\n  wc_add g1 = - arctan (f (- r)) / pi\n  wc_add g3 = arctan (f r) / pi", "have \"wc_add (g r) = (arctan (f r) - arctan (f (-r))) / pi \""], ["proof (prove)\nusing this:\n  wc_add (g r) = wc_add g1 + wc_add g2 + wc_add g3\n  wc_add g2 = 0\n  wc_add g1 = - arctan (f (- r)) / pi\n  wc_add g3 = arctan (f r) / pi\n\ngoal (1 subgoal):\n 1. wc_add (g r) = (arctan (f r) - arctan (f (- r))) / pi", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  wc_add (g r) = (arctan (f r) - arctan (f (- r))) / pi\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       max (norm max_r) (norm min_r) + 1 \\<le> x \\<Longrightarrow>\n       2 * Re (winding_number (g x) 0) + cindex_pathE (g x) 0 =\n       (arctan (f x) - arctan (f (- x))) / pi", "then"], ["proof (chain)\npicking this:\n  wc_add (g r) = (arctan (f r) - arctan (f (- r))) / pi", "show \"2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 \n          = (arctan (f r) - arctan (f (- r))) / pi\""], ["proof (prove)\nusing this:\n  wc_add (g r) = (arctan (f r) - arctan (f (- r))) / pi\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n    (arctan (f r) - arctan (f (- r))) / pi", "unfolding wc_add_def"], ["proof (prove)\nusing this:\n  2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n  (arctan (f r) - arctan (f (- r))) / pi\n\ngoal (1 subgoal):\n 1. 2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n    (arctan (f r) - arctan (f (- r))) / pi", "."], ["proof (state)\nthis:\n  2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n  (arctan (f r) - arctan (f (- r))) / pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n     (arctan (f r) - arctan (f (- r))) / pi\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "with arctan_f_tendsto"], ["proof (chain)\npicking this:\n  ((\\<lambda>r.\n       (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n   0)\n   at_top\n  \\<forall>\\<^sub>F r in at_top.\n     2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n     (arctan (f r) - arctan (f (- r))) / pi", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       (arctan (f r) - arctan (f (- r))) / pi) \\<longlongrightarrow>\n   0)\n   at_top\n  \\<forall>\\<^sub>F r in at_top.\n     2 * Re (winding_number (g r) 0) + cindex_pathE (g r) 0 =\n     (arctan (f r) - arctan (f (- r))) / pi\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "by (auto dest:tendsto_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       2 * Re (winding_number (g r) 0) +\n       cindex_pathE (g r) 0) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots p \\<noteq> {} \\<Longrightarrow>\n  ((\\<lambda>r.\n       2 * Re (winding_number (g r) 0) +\n       cindex_pathE (g r) 0) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "ultimately"], ["proof (chain)\npicking this:\n  proots p = {} \\<Longrightarrow>\n  ((\\<lambda>r.\n       2 * Re (winding_number (g r) 0) +\n       cindex_pathE (g r) 0) \\<longlongrightarrow>\n   0)\n   at_top\n  proots p \\<noteq> {} \\<Longrightarrow>\n  ((\\<lambda>r.\n       2 * Re (winding_number (g r) 0) +\n       cindex_pathE (g r) 0) \\<longlongrightarrow>\n   0)\n   at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  proots p = {} \\<Longrightarrow>\n  ((\\<lambda>r.\n       2 * Re (winding_number (g r) 0) +\n       cindex_pathE (g r) 0) \\<longlongrightarrow>\n   0)\n   at_top\n  proots p \\<noteq> {} \\<Longrightarrow>\n  ((\\<lambda>r.\n       2 * Re (winding_number (g r) 0) +\n       cindex_pathE (g r) 0) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 * Re (winding_number (g r) 0) +\n         cindex_pathE (g r) 0) \\<longlongrightarrow>\n     0)\n     at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>r.\n       2 * Re (winding_number (g r) 0) +\n       cindex_pathE (g r) 0) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_upper_cindex_eq:\n  assumes \"lead_coeff p=1\" and no_real_roots:\"\\<forall>x\\<in>proots p. Im x\\<noteq>0\" \n  shows \"proots_upper p =\n             (degree p - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "proof (cases \"degree p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "case True"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "then"], ["proof (chain)\npicking this:\n  degree p = 0", "obtain c where \"p=[:c:]\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c. p = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using degree_eq_zeroE"], ["proof (prove)\nusing this:\n  degree p = 0\n  \\<lbrakk>degree ?p = 0;\n   \\<And>a. ?p = [:a:] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c. p = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  p = [:c:]\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "then"], ["proof (chain)\npicking this:\n  p = [:c:]", "have p_def:\"p=[:1:]\""], ["proof (prove)\nusing this:\n  p = [:c:]\n\ngoal (1 subgoal):\n 1. p = [:1:]", "using \\<open>lead_coeff p=1\\<close>"], ["proof (prove)\nusing this:\n  p = [:c:]\n  lead_coeff p = 1\n\ngoal (1 subgoal):\n 1. p = [:1:]", "by simp"], ["proof (state)\nthis:\n  p = [:1:]\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "have \"proots_count p {x. Im x>0} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {x. 0 < Im x} = 0", "unfolding p_def proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within [:1:] {x. 0 < Im x}. order r [:1:]) = 0", "by auto"], ["proof (state)\nthis:\n  proots_count p {x. 0 < Im x} = 0\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "moreover"], ["proof (state)\nthis:\n  proots_count p {x. 0 < Im x} = 0\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "have \"cindex_poly_ubd (map_poly Im p) (map_poly Re p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly_ubd (map_poly Im p) (map_poly Re p) = 0", "apply (subst cindex_poly_ubd_code)"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_R_smods (map_poly Re p) (map_poly Im p) = 0", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_R_smods (map_poly Re [:1:]) (map_poly Im [:1:]) = 0", "by (auto simp add:map_poly_pCons changes_R_smods_def changes_poly_neg_inf_def \n        changes_poly_pos_inf_def)"], ["proof (state)\nthis:\n  cindex_poly_ubd (map_poly Im p) (map_poly Re p) = 0\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "ultimately"], ["proof (chain)\npicking this:\n  proots_count p {x. 0 < Im x} = 0\n  cindex_poly_ubd (map_poly Im p) (map_poly Re p) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count p {x. 0 < Im x} = 0\n  cindex_poly_ubd (map_poly Im p) (map_poly Re p) = 0\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "using True"], ["proof (prove)\nusing this:\n  proots_count p {x. 0 < Im x} = 0\n  cindex_poly_ubd (map_poly Im p) (map_poly Re p) = 0\n  degree p = 0\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "unfolding proots_upper_def"], ["proof (prove)\nusing this:\n  proots_count p {x. 0 < Im x} = 0\n  cindex_poly_ubd (map_poly Im p) (map_poly Re p) = 0\n  degree p = 0\n\ngoal (1 subgoal):\n 1. real (proots_count p {z. 0 < Im z}) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "by auto"], ["proof (state)\nthis:\n  real (proots_upper p) =\n  real_of_int\n   (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n  2\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "then"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 0", "have \"degree p>0\" \"p\\<noteq>0\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree p &&& p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  0 < degree p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "define w1 where \"w1=(\\<lambda>r. Re (winding_number (poly p \\<circ> \n              (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x))) 0))\""], ["proof (state)\nthis:\n  w1 =\n  (\\<lambda>r.\n      Re (winding_number\n           (poly p \\<circ>\n            (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x)))\n           0))\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "define w2 where \"w2=(\\<lambda>r. Re (winding_number (poly p \\<circ> part_circlepath 0 r 0 pi) 0))\""], ["proof (state)\nthis:\n  w2 =\n  (\\<lambda>r.\n      Re (winding_number (poly p \\<circ> part_circlepath 0 r 0 pi) 0))\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "define cp where \"cp=(\\<lambda>r. cindex_pathE (poly p \\<circ> (\\<lambda>x. \n      of_real (linepath (- r) (of_real r) x))) 0)\""], ["proof (state)\nthis:\n  cp =\n  (\\<lambda>r.\n      cindex_pathE\n       (poly p \\<circ>\n        (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x)))\n       0)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "define ci where \"ci=(\\<lambda>r. cindexE (-r) r (\\<lambda>x. poly (map_poly Im p) x/poly (map_poly Re p) x))\""], ["proof (state)\nthis:\n  ci =\n  (\\<lambda>r.\n      cindexE (- r) r\n       (\\<lambda>x. poly (map_poly Im p) x / poly (map_poly Re p) x))\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "define cubd where \"cubd =cindex_poly_ubd (map_poly Im p) (map_poly Re p)\""], ["proof (state)\nthis:\n  cubd = cindex_poly_ubd (map_poly Im p) (map_poly Re p)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "obtain R where \"proots p \\<subseteq> ball 0 R\" and \"R>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>proots p \\<subseteq> ball 0 R; 0 < R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>p\\<noteq>0\\<close> finite_ball_include[of \"proots p\" 0]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  finite (proots p) \\<Longrightarrow>\n  \\<exists>e>0. proots p \\<subseteq> ball 0 e\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>proots p \\<subseteq> ball 0 R; 0 < R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  proots p \\<subseteq> ball 0 R\n  0 < R\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "have \"((\\<lambda>r. w1 r  +w2 r+ cp r / 2 -ci r/2)\n       \\<longlongrightarrow> real (degree p) / 2 - of_int cubd / 2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r. w1 r + w2 r + cp r / 2 - ci r / 2) \\<longlongrightarrow>\n     real (degree p) / 2 - real_of_int cubd / 2)\n     at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>r. w1 r + w2 r + cp r / 2 - ci r / 2) \\<longlongrightarrow>\n     real (degree p) / 2 - real_of_int cubd / 2)\n     at_top", "have t1:\"((\\<lambda>r. 2 * w1 r + cp r) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>r. 2 * w1 r + cp r) \\<longlongrightarrow> 0) at_top", "using Re_winding_number_poly_linepth[OF assms]"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       2 *\n       Re (winding_number\n            (poly p \\<circ>\n             (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x)))\n            0) +\n       cindex_pathE\n        (poly p \\<circ>\n         (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x)))\n        0) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. 2 * w1 r + cp r) \\<longlongrightarrow> 0) at_top", "unfolding w1_def cp_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       2 *\n       Re (winding_number\n            (poly p \\<circ>\n             (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x)))\n            0) +\n       cindex_pathE\n        (poly p \\<circ>\n         (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x)))\n        0) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         2 *\n         Re (winding_number\n              (poly p \\<circ>\n               (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x)))\n              0) +\n         cindex_pathE\n          (poly p \\<circ>\n           (\\<lambda>x. complex_of_real (linepath (- r) (of_real r) x)))\n          0) \\<longlongrightarrow>\n     0)\n     at_top", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>r. 2 * w1 r + cp r) \\<longlongrightarrow> 0) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. w1 r + w2 r + cp r / 2 - ci r / 2) \\<longlongrightarrow>\n     real (degree p) / 2 - real_of_int cubd / 2)\n     at_top", "have t2:\"(w2 \\<longlongrightarrow> real (degree p) / 2) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w2 \\<longlongrightarrow> real (degree p) / 2) at_top", "using Re_winding_number_poly_part_circlepath[OF \\<open>degree p>0\\<close>,of 0]"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       Re (winding_number (poly p \\<circ> part_circlepath 0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree p) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. (w2 \\<longlongrightarrow> real (degree p) / 2) at_top", "unfolding w2_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>r.\n       Re (winding_number (poly p \\<circ> part_circlepath 0 r 0 pi)\n            0)) \\<longlongrightarrow>\n   real (degree p) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r.\n         Re (winding_number (poly p \\<circ> part_circlepath 0 r 0 pi)\n              0)) \\<longlongrightarrow>\n     real (degree p) / 2)\n     at_top", "by auto"], ["proof (state)\nthis:\n  (w2 \\<longlongrightarrow> real (degree p) / 2) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. w1 r + w2 r + cp r / 2 - ci r / 2) \\<longlongrightarrow>\n     real (degree p) / 2 - real_of_int cubd / 2)\n     at_top", "have t3:\"(ci \\<longlongrightarrow> of_int cubd) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ci \\<longlongrightarrow> real_of_int cubd) at_top", "apply (rule tendsto_eventually)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ci x = real_of_int cubd", "using cindex_poly_ubd_eventually[of \"map_poly Im p\" \"map_poly Re p\"]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r\n      (\\<lambda>x. poly (map_poly Im p) x / poly (map_poly Re p) x) =\n     real_of_int (cindex_poly_ubd (map_poly Im p) (map_poly Re p))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top. ci x = real_of_int cubd", "unfolding ci_def cubd_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top.\n     cindexE (- r) r\n      (\\<lambda>x. poly (map_poly Im p) x / poly (map_poly Re p) x) =\n     real_of_int (cindex_poly_ubd (map_poly Im p) (map_poly Re p))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       cindexE (- x) x\n        (\\<lambda>x. poly (map_poly Im p) x / poly (map_poly Re p) x) =\n       real_of_int (cindex_poly_ubd (map_poly Im p) (map_poly Re p))", "by auto"], ["proof (state)\nthis:\n  (ci \\<longlongrightarrow> real_of_int cubd) at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. w1 r + w2 r + cp r / 2 - ci r / 2) \\<longlongrightarrow>\n     real (degree p) / 2 - real_of_int cubd / 2)\n     at_top", "from tendsto_add[OF tendsto_add[OF tendsto_mult_left[OF t3,of \"-1/2\",simplified] \n         tendsto_mult_left[OF t1,of \"1/2\",simplified]]\n         t2]"], ["proof (chain)\npicking this:\n  ((\\<lambda>x.\n       - (ci x / 2) + (w1 x + cp x / 2) + w2 x) \\<longlongrightarrow>\n   - (real_of_int cubd / 2) + 0 + real (degree p) / 2)\n   at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       - (ci x / 2) + (w1 x + cp x / 2) + w2 x) \\<longlongrightarrow>\n   - (real_of_int cubd / 2) + 0 + real (degree p) / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. w1 r + w2 r + cp r / 2 - ci r / 2) \\<longlongrightarrow>\n     real (degree p) / 2 - real_of_int cubd / 2)\n     at_top", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>r. w1 r + w2 r + cp r / 2 - ci r / 2) \\<longlongrightarrow>\n   real (degree p) / 2 - real_of_int cubd / 2)\n   at_top\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>r. w1 r + w2 r + cp r / 2 - ci r / 2) \\<longlongrightarrow>\n   real (degree p) / 2 - real_of_int cubd / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>r. w1 r + w2 r + cp r / 2 - ci r / 2) \\<longlongrightarrow>\n   real (degree p) / 2 - real_of_int cubd / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "have \"\\<forall>\\<^sub>F r in at_top. w1 r  +w2 r+ cp r / 2 -ci r/2 = proots_count p {x. Im x>0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       w1 r + w2 r + cp r / 2 - ci r / 2 =\n       real (proots_count p {x. 0 < Im x})", "proof (rule eventually_at_top_linorderI[of R])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "assume \"r\\<ge>R\""], ["proof (state)\nthis:\n  R \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "then"], ["proof (chain)\npicking this:\n  R \\<le> r", "have r_ball:\"proots p \\<subseteq> ball 0 r\" and \"r>0\""], ["proof (prove)\nusing this:\n  R \\<le> r\n\ngoal (1 subgoal):\n 1. proots p \\<subseteq> ball 0 r &&& 0 < r", "using \\<open>R>0\\<close> \\<open>proots p \\<subseteq> ball 0 R\\<close>"], ["proof (prove)\nusing this:\n  R \\<le> r\n  0 < R\n  proots p \\<subseteq> ball 0 R\n\ngoal (1 subgoal):\n 1. proots p \\<subseteq> ball 0 r &&& 0 < r", "by auto"], ["proof (state)\nthis:\n  proots p \\<subseteq> ball 0 r\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "define ll where \"ll=linepath (- complex_of_real r) r\""], ["proof (state)\nthis:\n  ll = linepath (- complex_of_real r) (complex_of_real r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "define rr where \"rr=part_circlepath 0 r 0 pi\""], ["proof (state)\nthis:\n  rr = part_circlepath 0 r 0 pi\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "define lr where \"lr = ll +++ rr\""], ["proof (state)\nthis:\n  lr = ll +++ rr\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "have img_ll:\"path_image ll \\<subseteq> - proots p\" and img_rr: \"path_image rr \\<subseteq> - proots p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image ll \\<subseteq> - proots p &&&\n    path_image rr \\<subseteq> - proots p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image ll \\<subseteq> - proots p", "unfolding ll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (linepath (- complex_of_real r) (complex_of_real r))\n    \\<subseteq> - proots p", "using \\<open>0 < r\\<close> closed_segment_degen_complex(2) no_real_roots"], ["proof (prove)\nusing this:\n  0 < r\n  \\<lbrakk>Im ?lb = Im ?ub; Re ?lb \\<le> Re ?ub\\<rbrakk>\n  \\<Longrightarrow> (?x \\<in> closed_segment ?lb ?ub) =\n                    (Im ?x = Im ?lb \\<and>\n                     Re ?lb \\<le> Re ?x \\<and> Re ?x \\<le> Re ?ub)\n  \\<forall>x\\<in>proots p. Im x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. path_image (linepath (- complex_of_real r) (complex_of_real r))\n    \\<subseteq> - proots p", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image rr \\<subseteq> - proots p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image rr \\<subseteq> - proots p", "unfolding rr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_image (part_circlepath 0 r 0 pi) \\<subseteq> - proots p", "using in_path_image_part_circlepath \\<open>0 < r\\<close> r_ball"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<in> path_image (part_circlepath ?z ?r ?st ?tt);\n   0 \\<le> ?r\\<rbrakk>\n  \\<Longrightarrow> cmod (?w - ?z) = ?r\n  0 < r\n  proots p \\<subseteq> ball 0 r\n\ngoal (1 subgoal):\n 1. path_image (part_circlepath 0 r 0 pi) \\<subseteq> - proots p", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  path_image ll \\<subseteq> - proots p\n  path_image rr \\<subseteq> - proots p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "have [simp]:\"valid_path (poly p o ll)\" \"valid_path (poly p o rr)\"\n        \"valid_path ll\" \"valid_path rr\" \n        \"pathfinish rr=pathstart ll\" \"pathfinish ll = pathstart rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid_path (poly p \\<circ> ll) &&&\n     valid_path (poly p \\<circ> rr) &&& valid_path ll) &&&\n    valid_path rr &&&\n    pathfinish rr = pathstart ll &&& pathfinish ll = pathstart rr", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. valid_path (poly p \\<circ> ll)\n 2. valid_path (poly p \\<circ> rr)\n 3. valid_path ll\n 4. valid_path rr\n 5. pathfinish rr = pathstart ll\n 6. pathfinish ll = pathstart rr", "show \"valid_path (poly p o ll)\" \"valid_path (poly p o rr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path (poly p \\<circ> ll) &&& valid_path (poly p \\<circ> rr)", "unfolding ll_def rr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_path\n     (poly p \\<circ> linepath (- complex_of_real r) (complex_of_real r)) &&&\n    valid_path (poly p \\<circ> part_circlepath 0 r 0 pi)", "by (auto intro:valid_path_compose_holomorphic)"], ["proof (state)\nthis:\n  valid_path (poly p \\<circ> ll)\n  valid_path (poly p \\<circ> rr)\n\ngoal (4 subgoals):\n 1. valid_path ll\n 2. valid_path rr\n 3. pathfinish rr = pathstart ll\n 4. pathfinish ll = pathstart rr", "then"], ["proof (chain)\npicking this:\n  valid_path (poly p \\<circ> ll)\n  valid_path (poly p \\<circ> rr)", "show \"valid_path ll\" \"valid_path rr\""], ["proof (prove)\nusing this:\n  valid_path (poly p \\<circ> ll)\n  valid_path (poly p \\<circ> rr)\n\ngoal (1 subgoal):\n 1. valid_path ll &&& valid_path rr", "unfolding ll_def rr_def"], ["proof (prove)\nusing this:\n  valid_path\n   (poly p \\<circ> linepath (- complex_of_real r) (complex_of_real r))\n  valid_path (poly p \\<circ> part_circlepath 0 r 0 pi)\n\ngoal (1 subgoal):\n 1. valid_path (linepath (- complex_of_real r) (complex_of_real r)) &&&\n    valid_path (part_circlepath 0 r 0 pi)", "by auto"], ["proof (state)\nthis:\n  valid_path ll\n  valid_path rr\n\ngoal (2 subgoals):\n 1. pathfinish rr = pathstart ll\n 2. pathfinish ll = pathstart rr", "show \"pathfinish rr=pathstart ll\" \"pathfinish ll = pathstart rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish rr = pathstart ll &&& pathfinish ll = pathstart rr", "unfolding ll_def rr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pathfinish (part_circlepath 0 r 0 pi) =\n    pathstart (linepath (- complex_of_real r) (complex_of_real r)) &&&\n    pathfinish (linepath (- complex_of_real r) (complex_of_real r)) =\n    pathstart (part_circlepath 0 r 0 pi)", "by auto"], ["proof (state)\nthis:\n  pathfinish rr = pathstart ll\n  pathfinish ll = pathstart rr\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_path (poly p \\<circ> ll)\n  valid_path (poly p \\<circ> rr)\n  valid_path ll\n  valid_path rr\n  pathfinish rr = pathstart ll\n  pathfinish ll = pathstart rr\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "have \"proots_count p {x. Im x>0} = (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (proots_count p {x. 0 < Im x}) =\n    (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p))", "unfolding proots_count_def of_nat_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>proots_within p {x. 0 < Im x}. of_nat (order x p)) =\n    (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p))", "proof (rule sum.mono_neutral_cong_left)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (proots p)\n 2. proots_within p {x. 0 < Im x} \\<subseteq> proots p\n 3. \\<forall>i\\<in>proots p - proots_within p {x. 0 < Im x}.\n       winding_number lr i * of_nat (order i p) = 0\n 4. \\<And>x.\n       x \\<in> proots_within p {x. 0 < Im x} \\<Longrightarrow>\n       of_nat (order x p) = winding_number lr x * of_nat (order x p)", "show \"finite (proots p)\" \"proots_within p {x. 0 < Im x} \\<subseteq> proots p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots p) &&& proots_within p {x. 0 < Im x} \\<subseteq> proots p", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (proots p) &&& proots_within p {x. 0 < Im x} \\<subseteq> proots p", "by auto"], ["proof (state)\nthis:\n  finite (proots p)\n  proots_within p {x. 0 < Im x} \\<subseteq> proots p\n\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>proots p - proots_within p {x. 0 < Im x}.\n       winding_number lr i * of_nat (order i p) = 0\n 2. \\<And>x.\n       x \\<in> proots_within p {x. 0 < Im x} \\<Longrightarrow>\n       of_nat (order x p) = winding_number lr x * of_nat (order x p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>proots p - proots_within p {x. 0 < Im x}.\n       winding_number lr i * of_nat (order i p) = 0\n 2. \\<And>x.\n       x \\<in> proots_within p {x. 0 < Im x} \\<Longrightarrow>\n       of_nat (order x p) = winding_number lr x * of_nat (order x p)", "have \"winding_number lr x=0\" when \"x\\<in>proots p - proots_within p {x. 0 < Im x}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number lr x = 0", "unfolding lr_def ll_def rr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number\n     (linepath (- complex_of_real r) (complex_of_real r) +++\n      part_circlepath 0 r 0 pi)\n     x =\n    0", "proof (eval_winding,simp_all)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)\n 2. x \\<notin> path_image (part_circlepath 0 r 0 pi)\n 3. - cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x =\n    cindex_pathE (part_circlepath 0 r 0 pi) x", "show *:\"x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)", "using img_ll that"], ["proof (prove)\nusing this:\n  path_image ll \\<subseteq> - proots p\n  x \\<in> proots p - proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)", "unfolding ll_def"], ["proof (prove)\nusing this:\n  path_image (linepath (- complex_of_real r) (complex_of_real r))\n  \\<subseteq> - proots p\n  x \\<in> proots p - proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)", "by auto"], ["proof (state)\nthis:\n  x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)\n\ngoal (2 subgoals):\n 1. x \\<notin> path_image (part_circlepath 0 r 0 pi)\n 2. - cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x =\n    cindex_pathE (part_circlepath 0 r 0 pi) x", "show \"x \\<notin> path_image (part_circlepath 0 r 0 pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> path_image (part_circlepath 0 r 0 pi)", "using img_rr that"], ["proof (prove)\nusing this:\n  path_image rr \\<subseteq> - proots p\n  x \\<in> proots p - proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. x \\<notin> path_image (part_circlepath 0 r 0 pi)", "unfolding rr_def"], ["proof (prove)\nusing this:\n  path_image (part_circlepath 0 r 0 pi) \\<subseteq> - proots p\n  x \\<in> proots p - proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. x \\<notin> path_image (part_circlepath 0 r 0 pi)", "by auto"], ["proof (state)\nthis:\n  x \\<notin> path_image (part_circlepath 0 r 0 pi)\n\ngoal (1 subgoal):\n 1. - cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x =\n    cindex_pathE (part_circlepath 0 r 0 pi) x", "have xr_facts:\"0 > Im x\" \"-r<Re x\" \"Re x<r\" \"cmod x<r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im x < 0 &&& - r < Re x) &&& Re x < r &&& cmod x < r", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. Im x < 0\n 2. - r < Re x\n 3. Re x < r\n 4. cmod x < r", "have \"Im x\\<le>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x \\<le> 0", "using that"], ["proof (prove)\nusing this:\n  x \\<in> proots p - proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. Im x \\<le> 0", "by auto"], ["proof (state)\nthis:\n  Im x \\<le> 0\n\ngoal (4 subgoals):\n 1. Im x < 0\n 2. - r < Re x\n 3. Re x < r\n 4. cmod x < r", "moreover"], ["proof (state)\nthis:\n  Im x \\<le> 0\n\ngoal (4 subgoals):\n 1. Im x < 0\n 2. - r < Re x\n 3. Re x < r\n 4. cmod x < r", "have \"Im x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0", "using no_real_roots that"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>proots p. Im x \\<noteq> 0\n  x \\<in> proots p - proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  Im x \\<noteq> 0\n\ngoal (4 subgoals):\n 1. Im x < 0\n 2. - r < Re x\n 3. Re x < r\n 4. cmod x < r", "ultimately"], ["proof (chain)\npicking this:\n  Im x \\<le> 0\n  Im x \\<noteq> 0", "show \"0 > Im x\""], ["proof (prove)\nusing this:\n  Im x \\<le> 0\n  Im x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im x < 0", "by auto"], ["proof (state)\nthis:\n  Im x < 0\n\ngoal (3 subgoals):\n 1. - r < Re x\n 2. Re x < r\n 3. cmod x < r", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. - r < Re x\n 2. Re x < r\n 3. cmod x < r", "show \"cmod x<r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod x < r", "using that r_ball"], ["proof (prove)\nusing this:\n  x \\<in> proots p - proots_within p {x. 0 < Im x}\n  proots p \\<subseteq> ball 0 r\n\ngoal (1 subgoal):\n 1. cmod x < r", "by auto"], ["proof (state)\nthis:\n  cmod x < r\n\ngoal (2 subgoals):\n 1. - r < Re x\n 2. Re x < r", "then"], ["proof (chain)\npicking this:\n  cmod x < r", "have \"\\<bar>Re x\\<bar> < r\""], ["proof (prove)\nusing this:\n  cmod x < r\n\ngoal (1 subgoal):\n 1. \\<bar>Re x\\<bar> < r", "using abs_Re_le_cmod[of x]"], ["proof (prove)\nusing this:\n  cmod x < r\n  \\<bar>Re x\\<bar> \\<le> cmod x\n\ngoal (1 subgoal):\n 1. \\<bar>Re x\\<bar> < r", "by argo"], ["proof (state)\nthis:\n  \\<bar>Re x\\<bar> < r\n\ngoal (2 subgoals):\n 1. - r < Re x\n 2. Re x < r", "then"], ["proof (chain)\npicking this:\n  \\<bar>Re x\\<bar> < r", "show \"-r<Re x\" \"Re x<r\""], ["proof (prove)\nusing this:\n  \\<bar>Re x\\<bar> < r\n\ngoal (1 subgoal):\n 1. - r < Re x &&& Re x < r", "by linarith+"], ["proof (state)\nthis:\n  - r < Re x\n  Re x < r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Im x < 0\n  - r < Re x\n  Re x < r\n  cmod x < r\n\ngoal (1 subgoal):\n 1. - cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x =\n    cindex_pathE (part_circlepath 0 r 0 pi) x", "then"], ["proof (chain)\npicking this:\n  Im x < 0\n  - r < Re x\n  Re x < r\n  cmod x < r", "have \"cindex_pathE ll x = 1\""], ["proof (prove)\nusing this:\n  Im x < 0\n  - r < Re x\n  Re x < r\n  cmod x < r\n\ngoal (1 subgoal):\n 1. cindex_pathE ll x = 1", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  Im x < 0\n  - r < Re x\n  Re x < r\n  cmod x < r\n  0 < r\n\ngoal (1 subgoal):\n 1. cindex_pathE ll x = 1", "unfolding cindex_pathE_linepath[OF *] ll_def"], ["proof (prove)\nusing this:\n  Im x < 0\n  - r < Re x\n  Re x < r\n  cmod x < r\n  0 < r\n\ngoal (1 subgoal):\n 1. (let c1 = Re (- complex_of_real r) - Re x;\n         c2 = Re (complex_of_real r) - Re x;\n         c3 = Im (- complex_of_real r) * Re (complex_of_real r) +\n              Re x * Im (complex_of_real r) +\n              Im x * Re (- complex_of_real r) -\n              Im x * Re (complex_of_real r) -\n              Im (complex_of_real r) * Re (- complex_of_real r) -\n              Re x * Im (- complex_of_real r);\n         d1 = Im (- complex_of_real r) - Im x;\n         d2 = Im (complex_of_real r) - Im x\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    1", "by (auto simp add: mult_pos_neg)"], ["proof (state)\nthis:\n  cindex_pathE ll x = 1\n\ngoal (1 subgoal):\n 1. - cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x =\n    cindex_pathE (part_circlepath 0 r 0 pi) x", "moreover"], ["proof (state)\nthis:\n  cindex_pathE ll x = 1\n\ngoal (1 subgoal):\n 1. - cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x =\n    cindex_pathE (part_circlepath 0 r 0 pi) x", "have \"cindex_pathE rr x=-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE rr x = - 1", "unfolding rr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath 0 r 0 pi) x = - 1", "using r_ball that"], ["proof (prove)\nusing this:\n  proots p \\<subseteq> ball 0 r\n  x \\<in> proots p - proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath 0 r 0 pi) x = - 1", "by (auto intro!: cindex_pathE_circlepath_upper)"], ["proof (state)\nthis:\n  cindex_pathE rr x = - 1\n\ngoal (1 subgoal):\n 1. - cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x =\n    cindex_pathE (part_circlepath 0 r 0 pi) x", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE ll x = 1\n  cindex_pathE rr x = - 1", "show \"-cindex_pathE (linepath (- of_real r) (of_real r)) x =\n            cindex_pathE (part_circlepath 0 r 0 pi) x\""], ["proof (prove)\nusing this:\n  cindex_pathE ll x = 1\n  cindex_pathE rr x = - 1\n\ngoal (1 subgoal):\n 1. - cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x =\n    cindex_pathE (part_circlepath 0 r 0 pi) x", "unfolding ll_def rr_def"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x = 1\n  cindex_pathE (part_circlepath 0 r 0 pi) x = - 1\n\ngoal (1 subgoal):\n 1. - cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x =\n    cindex_pathE (part_circlepath 0 r 0 pi) x", "by auto"], ["proof (state)\nthis:\n  - cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x =\n  cindex_pathE (part_circlepath 0 r 0 pi) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> proots p - proots_within p {x. 0 < Im x} \\<Longrightarrow>\n  winding_number lr ?x = 0\n\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>proots p - proots_within p {x. 0 < Im x}.\n       winding_number lr i * of_nat (order i p) = 0\n 2. \\<And>x.\n       x \\<in> proots_within p {x. 0 < Im x} \\<Longrightarrow>\n       of_nat (order x p) = winding_number lr x * of_nat (order x p)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> proots p - proots_within p {x. 0 < Im x} \\<Longrightarrow>\n  winding_number lr ?x = 0", "show \"\\<forall>i\\<in>proots p - proots_within p {x. 0 < Im x}. \n          winding_number lr i * of_nat (order i p) = 0\""], ["proof (prove)\nusing this:\n  ?x \\<in> proots p - proots_within p {x. 0 < Im x} \\<Longrightarrow>\n  winding_number lr ?x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>proots p - proots_within p {x. 0 < Im x}.\n       winding_number lr i * of_nat (order i p) = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>proots p - proots_within p {x. 0 < Im x}.\n     winding_number lr i * of_nat (order i p) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p {x. 0 < Im x} \\<Longrightarrow>\n       of_nat (order x p) = winding_number lr x * of_nat (order x p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p {x. 0 < Im x} \\<Longrightarrow>\n       of_nat (order x p) = winding_number lr x * of_nat (order x p)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p {x. 0 < Im x} \\<Longrightarrow>\n       of_nat (order x p) = winding_number lr x * of_nat (order x p)", "assume x_asm:\"x \\<in> proots_within p {x. 0 < Im x}\""], ["proof (state)\nthis:\n  x \\<in> proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p {x. 0 < Im x} \\<Longrightarrow>\n       of_nat (order x p) = winding_number lr x * of_nat (order x p)", "have \"winding_number lr x=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number lr x = 1", "unfolding lr_def ll_def rr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number\n     (linepath (- complex_of_real r) (complex_of_real r) +++\n      part_circlepath 0 r 0 pi)\n     x =\n    1", "proof (eval_winding,simp_all)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)\n 2. x \\<notin> path_image (part_circlepath 0 r 0 pi)\n 3. - complex_of_real\n       (cindex_pathE (linepath (- complex_of_real r) (complex_of_real r))\n         x) -\n    complex_of_real (cindex_pathE (part_circlepath 0 r 0 pi) x) =\n    2", "show *:\"x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)", "using img_ll x_asm"], ["proof (prove)\nusing this:\n  path_image ll \\<subseteq> - proots p\n  x \\<in> proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)", "unfolding ll_def"], ["proof (prove)\nusing this:\n  path_image (linepath (- complex_of_real r) (complex_of_real r))\n  \\<subseteq> - proots p\n  x \\<in> proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)", "by auto"], ["proof (state)\nthis:\n  x \\<notin> closed_segment (- complex_of_real r) (complex_of_real r)\n\ngoal (2 subgoals):\n 1. x \\<notin> path_image (part_circlepath 0 r 0 pi)\n 2. - complex_of_real\n       (cindex_pathE (linepath (- complex_of_real r) (complex_of_real r))\n         x) -\n    complex_of_real (cindex_pathE (part_circlepath 0 r 0 pi) x) =\n    2", "show \"x \\<notin> path_image (part_circlepath 0 r 0 pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> path_image (part_circlepath 0 r 0 pi)", "using img_rr x_asm"], ["proof (prove)\nusing this:\n  path_image rr \\<subseteq> - proots p\n  x \\<in> proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. x \\<notin> path_image (part_circlepath 0 r 0 pi)", "unfolding rr_def"], ["proof (prove)\nusing this:\n  path_image (part_circlepath 0 r 0 pi) \\<subseteq> - proots p\n  x \\<in> proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. x \\<notin> path_image (part_circlepath 0 r 0 pi)", "by auto"], ["proof (state)\nthis:\n  x \\<notin> path_image (part_circlepath 0 r 0 pi)\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath (- complex_of_real r) (complex_of_real r))\n         x) -\n    complex_of_real (cindex_pathE (part_circlepath 0 r 0 pi) x) =\n    2", "have xr_facts:\"0 < Im x\" \"-r<Re x\" \"Re x<r\" \"cmod x<r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < Im x &&& - r < Re x) &&& Re x < r &&& cmod x < r", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 < Im x\n 2. - r < Re x\n 3. Re x < r\n 4. cmod x < r", "show \"0 < Im x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Im x", "using x_asm"], ["proof (prove)\nusing this:\n  x \\<in> proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. 0 < Im x", "by auto"], ["proof (state)\nthis:\n  0 < Im x\n\ngoal (3 subgoals):\n 1. - r < Re x\n 2. Re x < r\n 3. cmod x < r", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. - r < Re x\n 2. Re x < r\n 3. cmod x < r", "show \"cmod x<r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod x < r", "using x_asm r_ball"], ["proof (prove)\nusing this:\n  x \\<in> proots_within p {x. 0 < Im x}\n  proots p \\<subseteq> ball 0 r\n\ngoal (1 subgoal):\n 1. cmod x < r", "by auto"], ["proof (state)\nthis:\n  cmod x < r\n\ngoal (2 subgoals):\n 1. - r < Re x\n 2. Re x < r", "then"], ["proof (chain)\npicking this:\n  cmod x < r", "have \"\\<bar>Re x\\<bar> < r\""], ["proof (prove)\nusing this:\n  cmod x < r\n\ngoal (1 subgoal):\n 1. \\<bar>Re x\\<bar> < r", "using abs_Re_le_cmod[of x]"], ["proof (prove)\nusing this:\n  cmod x < r\n  \\<bar>Re x\\<bar> \\<le> cmod x\n\ngoal (1 subgoal):\n 1. \\<bar>Re x\\<bar> < r", "by argo"], ["proof (state)\nthis:\n  \\<bar>Re x\\<bar> < r\n\ngoal (2 subgoals):\n 1. - r < Re x\n 2. Re x < r", "then"], ["proof (chain)\npicking this:\n  \\<bar>Re x\\<bar> < r", "show \"-r<Re x\" \"Re x<r\""], ["proof (prove)\nusing this:\n  \\<bar>Re x\\<bar> < r\n\ngoal (1 subgoal):\n 1. - r < Re x &&& Re x < r", "by linarith+"], ["proof (state)\nthis:\n  - r < Re x\n  Re x < r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < Im x\n  - r < Re x\n  Re x < r\n  cmod x < r\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath (- complex_of_real r) (complex_of_real r))\n         x) -\n    complex_of_real (cindex_pathE (part_circlepath 0 r 0 pi) x) =\n    2", "then"], ["proof (chain)\npicking this:\n  0 < Im x\n  - r < Re x\n  Re x < r\n  cmod x < r", "have \"cindex_pathE ll x = -1\""], ["proof (prove)\nusing this:\n  0 < Im x\n  - r < Re x\n  Re x < r\n  cmod x < r\n\ngoal (1 subgoal):\n 1. cindex_pathE ll x = - 1", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  0 < Im x\n  - r < Re x\n  Re x < r\n  cmod x < r\n  0 < r\n\ngoal (1 subgoal):\n 1. cindex_pathE ll x = - 1", "unfolding cindex_pathE_linepath[OF *] ll_def"], ["proof (prove)\nusing this:\n  0 < Im x\n  - r < Re x\n  Re x < r\n  cmod x < r\n  0 < r\n\ngoal (1 subgoal):\n 1. (let c1 = Re (- complex_of_real r) - Re x;\n         c2 = Re (complex_of_real r) - Re x;\n         c3 = Im (- complex_of_real r) * Re (complex_of_real r) +\n              Re x * Im (complex_of_real r) +\n              Im x * Re (- complex_of_real r) -\n              Im x * Re (complex_of_real r) -\n              Im (complex_of_real r) * Re (- complex_of_real r) -\n              Re x * Im (- complex_of_real r);\n         d1 = Im (- complex_of_real r) - Im x;\n         d2 = Im (complex_of_real r) - Im x\n     in if 0 < c1 \\<and> c2 < 0 \\<or> c1 < 0 \\<and> 0 < c2\n        then if 0 < c3 then 1 else - 1\n        else if (c1 = 0) = (c2 \\<noteq> 0) \\<and>\n                (c1 = 0 \\<longrightarrow> d1 \\<noteq> 0) \\<and>\n                (c2 = 0 \\<longrightarrow> d2 \\<noteq> 0)\n             then if c1 = 0 \\<and> (0 < c2) = (0 < d1) \\<or>\n                     c2 = 0 \\<and> (0 < c1) = (d2 < 0)\n                  then 1 / 2 else - 1 / 2\n             else 0) =\n    - 1", "by (auto simp add: mult_less_0_iff)"], ["proof (state)\nthis:\n  cindex_pathE ll x = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath (- complex_of_real r) (complex_of_real r))\n         x) -\n    complex_of_real (cindex_pathE (part_circlepath 0 r 0 pi) x) =\n    2", "moreover"], ["proof (state)\nthis:\n  cindex_pathE ll x = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath (- complex_of_real r) (complex_of_real r))\n         x) -\n    complex_of_real (cindex_pathE (part_circlepath 0 r 0 pi) x) =\n    2", "have \"cindex_pathE rr x=-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE rr x = - 1", "unfolding rr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath 0 r 0 pi) x = - 1", "using r_ball x_asm"], ["proof (prove)\nusing this:\n  proots p \\<subseteq> ball 0 r\n  x \\<in> proots_within p {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. cindex_pathE (part_circlepath 0 r 0 pi) x = - 1", "by (auto intro!: cindex_pathE_circlepath_upper)"], ["proof (state)\nthis:\n  cindex_pathE rr x = - 1\n\ngoal (1 subgoal):\n 1. - complex_of_real\n       (cindex_pathE (linepath (- complex_of_real r) (complex_of_real r))\n         x) -\n    complex_of_real (cindex_pathE (part_circlepath 0 r 0 pi) x) =\n    2", "ultimately"], ["proof (chain)\npicking this:\n  cindex_pathE ll x = - 1\n  cindex_pathE rr x = - 1", "show \"- of_real (cindex_pathE (linepath (- of_real r) (of_real r)) x) -\n            of_real (cindex_pathE (part_circlepath 0 r 0 pi) x) = 2\""], ["proof (prove)\nusing this:\n  cindex_pathE ll x = - 1\n  cindex_pathE rr x = - 1\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath (- complex_of_real r) (complex_of_real r))\n         x) -\n    of_real (cindex_pathE (part_circlepath 0 r 0 pi) x) =\n    (2::'a)", "unfolding ll_def rr_def"], ["proof (prove)\nusing this:\n  cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x = - 1\n  cindex_pathE (part_circlepath 0 r 0 pi) x = - 1\n\ngoal (1 subgoal):\n 1. - of_real\n       (cindex_pathE (linepath (- complex_of_real r) (complex_of_real r))\n         x) -\n    of_real (cindex_pathE (part_circlepath 0 r 0 pi) x) =\n    (2::'a)", "by auto"], ["proof (state)\nthis:\n  - of_real\n     (cindex_pathE (linepath (- complex_of_real r) (complex_of_real r)) x) -\n  of_real (cindex_pathE (part_circlepath 0 r 0 pi) x) =\n  (2::?'a1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  winding_number lr x = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within p {x. 0 < Im x} \\<Longrightarrow>\n       of_nat (order x p) = winding_number lr x * of_nat (order x p)", "then"], ["proof (chain)\npicking this:\n  winding_number lr x = 1", "show \"of_nat (order x p) = winding_number lr x * of_nat (order x p)\""], ["proof (prove)\nusing this:\n  winding_number lr x = 1\n\ngoal (1 subgoal):\n 1. of_nat (order x p) = winding_number lr x * of_nat (order x p)", "by auto"], ["proof (state)\nthis:\n  of_nat (order x p) = winding_number lr x * of_nat (order x p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_nat (proots_count p {x. 0 < Im x}) =\n  (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "also"], ["proof (state)\nthis:\n  of_nat (proots_count p {x. 0 < Im x}) =\n  (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "have \"... = 1/(2*pi*\\<i>) * contour_integral lr (\\<lambda>x. deriv (poly p) x / poly p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p)) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral lr (\\<lambda>x. deriv (poly p) x / poly p x)", "apply (subst argument_principle_poly[of p lr])"], ["proof (prove)\ngoal (5 subgoals):\n 1. p \\<noteq> 0\n 2. valid_path lr\n 3. pathfinish lr = pathstart lr\n 4. path_image lr \\<subseteq> - proots p\n 5. (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p)) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    (2 * complex_of_real pi * \\<i> *\n     (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p)))", "using \\<open>p\\<noteq>0\\<close> img_ll img_rr"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  path_image ll \\<subseteq> - proots p\n  path_image rr \\<subseteq> - proots p\n\ngoal (5 subgoals):\n 1. p \\<noteq> 0\n 2. valid_path lr\n 3. pathfinish lr = pathstart lr\n 4. path_image lr \\<subseteq> - proots p\n 5. (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p)) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    (2 * complex_of_real pi * \\<i> *\n     (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p)))", "unfolding lr_def ll_def rr_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  path_image (linepath (- complex_of_real r) (complex_of_real r))\n  \\<subseteq> - proots p\n  path_image (part_circlepath 0 r 0 pi) \\<subseteq> - proots p\n\ngoal (5 subgoals):\n 1. p \\<noteq> 0\n 2. valid_path\n     (linepath (- complex_of_real r) (complex_of_real r) +++\n      part_circlepath 0 r 0 pi)\n 3. pathfinish\n     (linepath (- complex_of_real r) (complex_of_real r) +++\n      part_circlepath 0 r 0 pi) =\n    pathstart\n     (linepath (- complex_of_real r) (complex_of_real r) +++\n      part_circlepath 0 r 0 pi)\n 4. path_image\n     (linepath (- complex_of_real r) (complex_of_real r) +++\n      part_circlepath 0 r 0 pi)\n    \\<subseteq> - proots p\n 5. (\\<Sum>x\\<in>proots p.\n       winding_number\n        (linepath (- complex_of_real r) (complex_of_real r) +++\n         part_circlepath 0 r 0 pi)\n        x *\n       of_nat (order x p)) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    (2 * complex_of_real pi * \\<i> *\n     (\\<Sum>x\\<in>proots p.\n        winding_number\n         (linepath (- complex_of_real r) (complex_of_real r) +++\n          part_circlepath 0 r 0 pi)\n         x *\n        of_nat (order x p)))", "by (auto simp add:path_image_join)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p)) =\n  1 / (complex_of_real (2 * pi) * \\<i>) *\n  contour_integral lr (\\<lambda>x. deriv (poly p) x / poly p x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>proots p. winding_number lr x * of_nat (order x p)) =\n  1 / (complex_of_real (2 * pi) * \\<i>) *\n  contour_integral lr (\\<lambda>x. deriv (poly p) x / poly p x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "have \"... = winding_number (poly p \\<circ> lr) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral lr (\\<lambda>x. deriv (poly p) x / poly p x) =\n    winding_number (poly p \\<circ> lr) 0", "apply (subst winding_number_comp[of UNIV \"poly p\" lr 0])"], ["proof (prove)\ngoal (6 subgoals):\n 1. open UNIV\n 2. poly p holomorphic_on UNIV\n 3. path_image lr \\<subseteq> UNIV\n 4. valid_path lr\n 5. 0 \\<notin> path_image (poly p \\<circ> lr)\n 6. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral lr (\\<lambda>x. deriv (poly p) x / poly p x) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral lr (\\<lambda>w. deriv (poly p) w / (poly p w - 0))", "using \\<open>p\\<noteq>0\\<close> img_ll img_rr"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  path_image ll \\<subseteq> - proots p\n  path_image rr \\<subseteq> - proots p\n\ngoal (6 subgoals):\n 1. open UNIV\n 2. poly p holomorphic_on UNIV\n 3. path_image lr \\<subseteq> UNIV\n 4. valid_path lr\n 5. 0 \\<notin> path_image (poly p \\<circ> lr)\n 6. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral lr (\\<lambda>x. deriv (poly p) x / poly p x) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral lr (\\<lambda>w. deriv (poly p) w / (poly p w - 0))", "unfolding lr_def ll_def rr_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  path_image (linepath (- complex_of_real r) (complex_of_real r))\n  \\<subseteq> - proots p\n  path_image (part_circlepath 0 r 0 pi) \\<subseteq> - proots p\n\ngoal (6 subgoals):\n 1. open UNIV\n 2. poly p holomorphic_on UNIV\n 3. path_image\n     (linepath (- complex_of_real r) (complex_of_real r) +++\n      part_circlepath 0 r 0 pi)\n    \\<subseteq> UNIV\n 4. valid_path\n     (linepath (- complex_of_real r) (complex_of_real r) +++\n      part_circlepath 0 r 0 pi)\n 5. 0 \\<notin> path_image\n                (poly p \\<circ>\n                 linepath (- complex_of_real r) (complex_of_real r) +++\n                 part_circlepath 0 r 0 pi)\n 6. 1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral\n     (linepath (- complex_of_real r) (complex_of_real r) +++\n      part_circlepath 0 r 0 pi)\n     (\\<lambda>x. deriv (poly p) x / poly p x) =\n    1 / (complex_of_real (2 * pi) * \\<i>) *\n    contour_integral\n     (linepath (- complex_of_real r) (complex_of_real r) +++\n      part_circlepath 0 r 0 pi)\n     (\\<lambda>w. deriv (poly p) w / (poly p w - 0))", "by (auto simp add:path_image_join path_image_compose)"], ["proof (state)\nthis:\n  1 / (complex_of_real (2 * pi) * \\<i>) *\n  contour_integral lr (\\<lambda>x. deriv (poly p) x / poly p x) =\n  winding_number (poly p \\<circ> lr) 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "also"], ["proof (state)\nthis:\n  1 / (complex_of_real (2 * pi) * \\<i>) *\n  contour_integral lr (\\<lambda>x. deriv (poly p) x / poly p x) =\n  winding_number (poly p \\<circ> lr) 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "have \"... = Re (winding_number (poly p \\<circ> lr) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (poly p \\<circ> lr) 0 =\n    complex_of_real (Re (winding_number (poly p \\<circ> lr) 0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. winding_number (poly p \\<circ> lr) 0 =\n    complex_of_real (Re (winding_number (poly p \\<circ> lr) 0))", "have \"winding_number (poly p \\<circ> lr) 0 \\<in> Ints\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winding_number (poly p \\<circ> lr) 0 \\<in> \\<int>", "apply (rule integer_winding_number)"], ["proof (prove)\ngoal (3 subgoals):\n 1. path (poly p \\<circ> lr)\n 2. pathfinish (poly p \\<circ> lr) = pathstart (poly p \\<circ> lr)\n 3. 0 \\<notin> path_image (poly p \\<circ> lr)", "using \\<open>p\\<noteq>0\\<close> img_ll img_rr"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  path_image ll \\<subseteq> - proots p\n  path_image rr \\<subseteq> - proots p\n\ngoal (3 subgoals):\n 1. path (poly p \\<circ> lr)\n 2. pathfinish (poly p \\<circ> lr) = pathstart (poly p \\<circ> lr)\n 3. 0 \\<notin> path_image (poly p \\<circ> lr)", "unfolding lr_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  path_image ll \\<subseteq> - proots p\n  path_image rr \\<subseteq> - proots p\n\ngoal (3 subgoals):\n 1. path (poly p \\<circ> ll +++ rr)\n 2. pathfinish (poly p \\<circ> ll +++ rr) =\n    pathstart (poly p \\<circ> ll +++ rr)\n 3. 0 \\<notin> path_image (poly p \\<circ> ll +++ rr)", "by (auto simp add:path_image_join path_image_compose path_compose_join \n            pathstart_compose pathfinish_compose valid_path_imp_path)"], ["proof (state)\nthis:\n  winding_number (poly p \\<circ> lr) 0 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. winding_number (poly p \\<circ> lr) 0 =\n    complex_of_real (Re (winding_number (poly p \\<circ> lr) 0))", "then"], ["proof (chain)\npicking this:\n  winding_number (poly p \\<circ> lr) 0 \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  winding_number (poly p \\<circ> lr) 0 \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. winding_number (poly p \\<circ> lr) 0 =\n    complex_of_real (Re (winding_number (poly p \\<circ> lr) 0))", "by (simp add: complex_eqI complex_is_Int_iff)"], ["proof (state)\nthis:\n  winding_number (poly p \\<circ> lr) 0 =\n  complex_of_real (Re (winding_number (poly p \\<circ> lr) 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  winding_number (poly p \\<circ> lr) 0 =\n  complex_of_real (Re (winding_number (poly p \\<circ> lr) 0))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "also"], ["proof (state)\nthis:\n  winding_number (poly p \\<circ> lr) 0 =\n  complex_of_real (Re (winding_number (poly p \\<circ> lr) 0))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "have \"... =  Re (winding_number (poly p \\<circ> ll) 0) + Re (winding_number (poly p \\<circ> rr) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (Re (winding_number (poly p \\<circ> lr) 0)) =\n    complex_of_real\n     (Re (winding_number (poly p \\<circ> ll) 0) +\n      Re (winding_number (poly p \\<circ> rr) 0))", "unfolding lr_def path_compose_join"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real\n     (Re (winding_number ((poly p \\<circ> ll) +++ (poly p \\<circ> rr)) 0)) =\n    complex_of_real\n     (Re (winding_number (poly p \\<circ> ll) 0) +\n      Re (winding_number (poly p \\<circ> rr) 0))", "using img_ll img_rr"], ["proof (prove)\nusing this:\n  path_image ll \\<subseteq> - proots p\n  path_image rr \\<subseteq> - proots p\n\ngoal (1 subgoal):\n 1. complex_of_real\n     (Re (winding_number ((poly p \\<circ> ll) +++ (poly p \\<circ> rr)) 0)) =\n    complex_of_real\n     (Re (winding_number (poly p \\<circ> ll) 0) +\n      Re (winding_number (poly p \\<circ> rr) 0))", "apply (subst winding_number_join)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>path_image ll \\<subseteq> - proots p;\n     path_image rr \\<subseteq> - proots p\\<rbrakk>\n    \\<Longrightarrow> path (poly p \\<circ> ll)\n 2. \\<lbrakk>path_image ll \\<subseteq> - proots p;\n     path_image rr \\<subseteq> - proots p\\<rbrakk>\n    \\<Longrightarrow> 0 \\<notin> path_image (poly p \\<circ> ll)\n 3. \\<lbrakk>path_image ll \\<subseteq> - proots p;\n     path_image rr \\<subseteq> - proots p\\<rbrakk>\n    \\<Longrightarrow> path (poly p \\<circ> rr)\n 4. \\<lbrakk>path_image ll \\<subseteq> - proots p;\n     path_image rr \\<subseteq> - proots p\\<rbrakk>\n    \\<Longrightarrow> 0 \\<notin> path_image (poly p \\<circ> rr)\n 5. \\<lbrakk>path_image ll \\<subseteq> - proots p;\n     path_image rr \\<subseteq> - proots p\\<rbrakk>\n    \\<Longrightarrow> pathfinish (poly p \\<circ> ll) =\n                      pathstart (poly p \\<circ> rr)\n 6. \\<lbrakk>path_image ll \\<subseteq> - proots p;\n     path_image rr \\<subseteq> - proots p\\<rbrakk>\n    \\<Longrightarrow> complex_of_real\n                       (Re (winding_number (poly p \\<circ> ll) 0 +\n                            winding_number (poly p \\<circ> rr) 0)) =\n                      complex_of_real\n                       (Re (winding_number (poly p \\<circ> ll) 0) +\n                        Re (winding_number (poly p \\<circ> rr) 0))", "by (auto simp add:valid_path_imp_path path_image_compose pathstart_compose pathfinish_compose)"], ["proof (state)\nthis:\n  complex_of_real (Re (winding_number (poly p \\<circ> lr) 0)) =\n  complex_of_real\n   (Re (winding_number (poly p \\<circ> ll) 0) +\n    Re (winding_number (poly p \\<circ> rr) 0))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "also"], ["proof (state)\nthis:\n  complex_of_real (Re (winding_number (poly p \\<circ> lr) 0)) =\n  complex_of_real\n   (Re (winding_number (poly p \\<circ> ll) 0) +\n    Re (winding_number (poly p \\<circ> rr) 0))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "have \"... = w1 r  +w2 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real\n     (Re (winding_number (poly p \\<circ> ll) 0) +\n      Re (winding_number (poly p \\<circ> rr) 0)) =\n    complex_of_real (w1 r + w2 r)", "unfolding w1_def w2_def ll_def rr_def of_real_linepath"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real\n     (Re (winding_number\n           (poly p \\<circ>\n            linepath (- complex_of_real r) (complex_of_real r))\n           0) +\n      Re (winding_number (poly p \\<circ> part_circlepath 0 r 0 pi) 0)) =\n    complex_of_real\n     (Re (winding_number\n           (poly p \\<circ>\n            linepath (complex_of_real (- r)) (complex_of_real (of_real r)))\n           0) +\n      Re (winding_number (poly p \\<circ> part_circlepath 0 r 0 pi) 0))", "by auto"], ["proof (state)\nthis:\n  complex_of_real\n   (Re (winding_number (poly p \\<circ> ll) 0) +\n    Re (winding_number (poly p \\<circ> rr) 0)) =\n  complex_of_real (w1 r + w2 r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "finally"], ["proof (chain)\npicking this:\n  of_nat (proots_count p {x. 0 < Im x}) = complex_of_real (w1 r + w2 r)", "have \"of_nat (proots_count p {x. 0 < Im x}) = complex_of_real (w1 r + w2 r)\""], ["proof (prove)\nusing this:\n  of_nat (proots_count p {x. 0 < Im x}) = complex_of_real (w1 r + w2 r)\n\ngoal (1 subgoal):\n 1. of_nat (proots_count p {x. 0 < Im x}) = complex_of_real (w1 r + w2 r)", "."], ["proof (state)\nthis:\n  of_nat (proots_count p {x. 0 < Im x}) = complex_of_real (w1 r + w2 r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "then"], ["proof (chain)\npicking this:\n  of_nat (proots_count p {x. 0 < Im x}) = complex_of_real (w1 r + w2 r)", "have \"proots_count p {x. 0 < Im x} = w1 r + w2 r\""], ["proof (prove)\nusing this:\n  of_nat (proots_count p {x. 0 < Im x}) = complex_of_real (w1 r + w2 r)\n\ngoal (1 subgoal):\n 1. real (proots_count p {x. 0 < Im x}) = w1 r + w2 r", "using of_real_eq_iff"], ["proof (prove)\nusing this:\n  of_nat (proots_count p {x. 0 < Im x}) = complex_of_real (w1 r + w2 r)\n  (of_real ?x = of_real ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. real (proots_count p {x. 0 < Im x}) = w1 r + w2 r", "by fastforce"], ["proof (state)\nthis:\n  real (proots_count p {x. 0 < Im x}) = w1 r + w2 r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "moreover"], ["proof (state)\nthis:\n  real (proots_count p {x. 0 < Im x}) = w1 r + w2 r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "have \"cp r = ci r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cp r = ci r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cp r = ci r", "define f where \"f=(\\<lambda>x. Im (poly p (of_real x)) / Re (poly p x))\""], ["proof (state)\nthis:\n  f =\n  (\\<lambda>x.\n      Im (poly p (complex_of_real x)) / Re (poly p (complex_of_real x)))\n\ngoal (1 subgoal):\n 1. cp r = ci r", "have \"cp r = cindex_pathE (poly p \\<circ> (\\<lambda>x. 2*r*x - r)) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cp r =\n    cindex_pathE\n     (poly p \\<circ> (\\<lambda>x. complex_of_real (2 * r * x - r))) 0", "unfolding cp_def linepath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE\n     (poly p \\<circ>\n      (\\<lambda>x.\n          complex_of_real ((1 - x) *\\<^sub>R - r + x *\\<^sub>R of_real r)))\n     0 =\n    cindex_pathE\n     (poly p \\<circ> (\\<lambda>x. complex_of_real (2 * r * x - r))) 0", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  cp r =\n  cindex_pathE\n   (poly p \\<circ> (\\<lambda>x. complex_of_real (2 * r * x - r))) 0\n\ngoal (1 subgoal):\n 1. cp r = ci r", "also"], ["proof (state)\nthis:\n  cp r =\n  cindex_pathE\n   (poly p \\<circ> (\\<lambda>x. complex_of_real (2 * r * x - r))) 0\n\ngoal (1 subgoal):\n 1. cp r = ci r", "have \"... = cindexE 0 1 (f o (\\<lambda>x. 2*r*x - r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_pathE\n     (poly p \\<circ> (\\<lambda>x. complex_of_real (2 * r * x - r))) 0 =\n    cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r))", "unfolding cp_def ci_def cindex_pathE_def f_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1\n     (\\<lambda>t.\n         Im (poly p (complex_of_real (2 * r * t - r)) - 0) /\n         Re (poly p (complex_of_real (2 * r * t - r)) - 0)) =\n    cindexE 0 1\n     (\\<lambda>x.\n         Im (poly p (complex_of_real (2 * r * x - r))) /\n         Re (poly p (complex_of_real (2 * r * x - r))))", "by auto"], ["proof (state)\nthis:\n  cindex_pathE\n   (poly p \\<circ> (\\<lambda>x. complex_of_real (2 * r * x - r))) 0 =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r))\n\ngoal (1 subgoal):\n 1. cp r = ci r", "also"], ["proof (state)\nthis:\n  cindex_pathE\n   (poly p \\<circ> (\\<lambda>x. complex_of_real (2 * r * x - r))) 0 =\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r))\n\ngoal (1 subgoal):\n 1. cp r = ci r", "have \"... = cindexE (-r) r f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r)) = cindexE (- r) r f", "apply (subst cindexE_linear_comp[of \"2*r\" 0 1 f \"-r\",simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. r \\<noteq> 0\n 2. (if 0 < r then cindexE (2 * r * 0 + - r) (2 * r * 1 + - r) f\n     else - cindexE (2 * r * 1 + - r) (2 * r * 0 + - r) f) =\n    cindexE (- r) r f", "using \\<open>r>0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (2 subgoals):\n 1. r \\<noteq> 0\n 2. (if 0 < r then cindexE (2 * r * 0 + - r) (2 * r * 1 + - r) f\n     else - cindexE (2 * r * 1 + - r) (2 * r * 0 + - r) f) =\n    cindexE (- r) r f", "by auto"], ["proof (state)\nthis:\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r)) = cindexE (- r) r f\n\ngoal (1 subgoal):\n 1. cp r = ci r", "also"], ["proof (state)\nthis:\n  cindexE 0 1 (f \\<circ> (\\<lambda>x. 2 * r * x - r)) = cindexE (- r) r f\n\ngoal (1 subgoal):\n 1. cp r = ci r", "have \"... = ci r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (- r) r f = ci r", "unfolding ci_def f_def Im_poly_of_real Re_poly_of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (- r) r\n     (\\<lambda>x. poly (map_poly Im p) x / poly (map_poly Re p) x) =\n    cindexE (- r) r\n     (\\<lambda>x. poly (map_poly Im p) x / poly (map_poly Re p) x)", "by simp"], ["proof (state)\nthis:\n  cindexE (- r) r f = ci r\n\ngoal (1 subgoal):\n 1. cp r = ci r", "finally"], ["proof (chain)\npicking this:\n  cp r = ci r", "show ?thesis"], ["proof (prove)\nusing this:\n  cp r = ci r\n\ngoal (1 subgoal):\n 1. cp r = ci r", "."], ["proof (state)\nthis:\n  cp r = ci r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cp r = ci r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       R \\<le> x \\<Longrightarrow>\n       w1 x + w2 x + cp x / 2 - ci x / 2 =\n       real (proots_count p {x. 0 < Im x})", "ultimately"], ["proof (chain)\npicking this:\n  real (proots_count p {x. 0 < Im x}) = w1 r + w2 r\n  cp r = ci r", "show \"w1 r + w2 r + cp r / 2 - ci r / 2 = real (proots_count p {x. 0 < Im x})\""], ["proof (prove)\nusing this:\n  real (proots_count p {x. 0 < Im x}) = w1 r + w2 r\n  cp r = ci r\n\ngoal (1 subgoal):\n 1. w1 r + w2 r + cp r / 2 - ci r / 2 = real (proots_count p {x. 0 < Im x})", "by auto"], ["proof (state)\nthis:\n  w1 r + w2 r + cp r / 2 - ci r / 2 = real (proots_count p {x. 0 < Im x})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     w1 r + w2 r + cp r / 2 - ci r / 2 = real (proots_count p {x. 0 < Im x})\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<lambda>r. w1 r + w2 r + cp r / 2 - ci r / 2) \\<longlongrightarrow>\n   real (degree p) / 2 - real_of_int cubd / 2)\n   at_top\n  \\<forall>\\<^sub>F r in at_top.\n     w1 r + w2 r + cp r / 2 - ci r / 2 = real (proots_count p {x. 0 < Im x})", "have \"((\\<lambda>r::real. real (proots_count p {x. 0 < Im x})) \n      \\<longlongrightarrow> real (degree p) / 2 - of_int cubd / 2) at_top\""], ["proof (prove)\nusing this:\n  ((\\<lambda>r. w1 r + w2 r + cp r / 2 - ci r / 2) \\<longlongrightarrow>\n   real (degree p) / 2 - real_of_int cubd / 2)\n   at_top\n  \\<forall>\\<^sub>F r in at_top.\n     w1 r + w2 r + cp r / 2 - ci r / 2 = real (proots_count p {x. 0 < Im x})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>r. real (proots_count p {x. 0 < Im x})) \\<longlongrightarrow>\n     real (degree p) / 2 - real_of_int cubd / 2)\n     at_top", "by (auto dest: tendsto_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>r. real (proots_count p {x. 0 < Im x})) \\<longlongrightarrow>\n   real (degree p) / 2 - real_of_int cubd / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>r. real (proots_count p {x. 0 < Im x})) \\<longlongrightarrow>\n   real (degree p) / 2 - real_of_int cubd / 2)\n   at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>r. real (proots_count p {x. 0 < Im x})) \\<longlongrightarrow>\n   real (degree p) / 2 - real_of_int cubd / 2)\n   at_top\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "apply (subst (asm) tendsto_const_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. at_top \\<noteq> bot\n 2. real (proots_count p {x. 0 < Im x}) =\n    real (degree p) / 2 - real_of_int cubd / 2 \\<Longrightarrow>\n    real (proots_upper p) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "unfolding cubd_def proots_upper_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. at_top \\<noteq> bot\n 2. real (proots_count p {x. 0 < Im x}) =\n    real (degree p) / 2 -\n    real_of_int (cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2 \\<Longrightarrow>\n    real (proots_count p {z. 0 < Im z}) =\n    real_of_int\n     (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "by auto"], ["proof (state)\nthis:\n  real (proots_upper p) =\n  real_of_int\n   (int (degree p) - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n  2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindexE_roots_on_horizontal_border:\n  fixes a::complex and s::real\n  defines \"g\\<equiv>linepath a (a + of_real s)\"\n  assumes pqr:\"p = q * r\" and r_monic:\"lead_coeff r=1\" and r_proots:\"\\<forall>x\\<in>proots r. Im x=Im a\"\n  shows \"cindexE lb ub (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n          cindexE lb ub (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "using assms"], ["proof (prove)\nusing this:\n  g \\<equiv> linepath a (a + complex_of_real s)\n  p = q * r\n  lead_coeff r = 1\n  \\<forall>x\\<in>proots r. Im x = Im a\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "proof (induct r arbitrary:p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>g = linepath a (a + complex_of_real s); p = q * 0;\n        lead_coeff 0 = 1; \\<forall>x\\<in>proots 0. Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly p \\<circ> g) t) /\n                              Re ((poly p \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))\n 2. \\<And>p pa.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0;\n        g = linepath a (a + complex_of_real s); pa = q * p;\n        lead_coeff p = 1; \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))\n 3. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "case 0"], ["proof (state)\nthis:\n  g = linepath a (a + complex_of_real s)\n  p = q * 0\n  lead_coeff 0 = 1\n  \\<forall>x\\<in>proots 0. Im x = Im a\n\ngoal (3 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>g = linepath a (a + complex_of_real s); p = q * 0;\n        lead_coeff 0 = 1; \\<forall>x\\<in>proots 0. Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly p \\<circ> g) t) /\n                              Re ((poly p \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))\n 2. \\<And>p pa.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0;\n        g = linepath a (a + complex_of_real s); pa = q * p;\n        lead_coeff p = 1; \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))\n 3. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "then"], ["proof (chain)\npicking this:\n  g = linepath a (a + complex_of_real s)\n  p = q * 0\n  lead_coeff 0 = 1\n  \\<forall>x\\<in>proots 0. Im x = Im a", "have False"], ["proof (prove)\nusing this:\n  g = linepath a (a + complex_of_real s)\n  p = q * 0\n  lead_coeff 0 = 1\n  \\<forall>x\\<in>proots 0. Im x = Im a\n\ngoal (1 subgoal):\n 1. False", "by (metis Im_complex_of_real UNIV_I imaginary_unit.simps(2) proots_within_0 zero_neq_one)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>g = linepath a (a + complex_of_real s); p = q * 0;\n        lead_coeff 0 = 1; \\<forall>x\\<in>proots 0. Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly p \\<circ> g) t) /\n                              Re ((poly p \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))\n 2. \\<And>p pa.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0;\n        g = linepath a (a + complex_of_real s); pa = q * p;\n        lead_coeff p = 1; \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))\n 3. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "then"], ["proof (chain)\npicking this:\n  False", "show ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "by simp"], ["proof (state)\nthis:\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n\ngoal (2 subgoals):\n 1. \\<And>p pa.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0;\n        g = linepath a (a + complex_of_real s); pa = q * p;\n        lead_coeff p = 1; \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))\n 2. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p pa.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0;\n        g = linepath a (a + complex_of_real s); pa = q * p;\n        lead_coeff p = 1; \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))\n 2. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "case (no_proots r)"], ["proof (state)\nthis:\n  poly r ?a \\<noteq> 0\n  g = linepath a (a + complex_of_real s)\n  p = q * r\n  lead_coeff r = 1\n  \\<forall>x\\<in>proots r. Im x = Im a\n\ngoal (2 subgoals):\n 1. \\<And>p pa.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0;\n        g = linepath a (a + complex_of_real s); pa = q * p;\n        lead_coeff p = 1; \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))\n 2. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "then"], ["proof (chain)\npicking this:\n  poly r ?a \\<noteq> 0\n  g = linepath a (a + complex_of_real s)\n  p = q * r\n  lead_coeff r = 1\n  \\<forall>x\\<in>proots r. Im x = Im a", "obtain b where \"b\\<noteq>0\" \"r=[:b:]\""], ["proof (prove)\nusing this:\n  poly r ?a \\<noteq> 0\n  g = linepath a (a + complex_of_real s)\n  p = q * r\n  lead_coeff r = 1\n  \\<forall>x\\<in>proots r. Im x = Im a\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<noteq> 0; r = [:b:]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using fundamental_theorem_of_algebra_alt"], ["proof (prove)\nusing this:\n  poly r ?a \\<noteq> 0\n  g = linepath a (a + complex_of_real s)\n  p = q * r\n  lead_coeff r = 1\n  \\<forall>x\\<in>proots r. Im x = Im a\n  \\<nexists>a l.\n     a \\<noteq> 0 \\<and> l = 0 \\<and> ?p = pCons a l \\<Longrightarrow>\n  \\<exists>z. poly ?p z = 0\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<noteq> 0; r = [:b:]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b \\<noteq> 0\n  r = [:b:]\n\ngoal (2 subgoals):\n 1. \\<And>p pa.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0;\n        g = linepath a (a + complex_of_real s); pa = q * p;\n        lead_coeff p = 1; \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))\n 2. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> 0\n  r = [:b:]", "have \"r=1\""], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n  r = [:b:]\n\ngoal (1 subgoal):\n 1. r = 1", "using \\<open>lead_coeff r = 1\\<close>"], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n  r = [:b:]\n  lead_coeff r = 1\n\ngoal (1 subgoal):\n 1. r = 1", "by simp"], ["proof (state)\nthis:\n  r = 1\n\ngoal (2 subgoals):\n 1. \\<And>p pa.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0;\n        g = linepath a (a + complex_of_real s); pa = q * p;\n        lead_coeff p = 1; \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))\n 2. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "with \\<open>p = q * r\\<close>"], ["proof (chain)\npicking this:\n  p = q * r\n  r = 1", "show ?case"], ["proof (prove)\nusing this:\n  p = q * r\n  r = 1\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "by simp"], ["proof (state)\nthis:\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n\ngoal (1 subgoal):\n 1. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "case (root b r)"], ["proof (state)\nthis:\n  \\<lbrakk>g = linepath a (a + complex_of_real s); ?p = q * r;\n   lead_coeff r = 1; \\<forall>x\\<in>proots r. Im x = Im a\\<rbrakk>\n  \\<Longrightarrow> cindexE lb ub\n                     (\\<lambda>t.\n                         Im ((poly ?p \\<circ> g) t) /\n                         Re ((poly ?p \\<circ> g) t)) =\n                    cindexE lb ub\n                     (\\<lambda>t.\n                         Im ((poly q \\<circ> g) t) /\n                         Re ((poly q \\<circ> g) t))\n  g = linepath a (a + complex_of_real s)\n  p = q * ([:- b, 1:] * r)\n  lead_coeff ([:- b, 1:] * r) = 1\n  \\<forall>x\\<in>proots ([:- b, 1:] * r). Im x = Im a\n\ngoal (1 subgoal):\n 1. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>g = linepath a (a + complex_of_real s); ?p = q * r;\n   lead_coeff r = 1; \\<forall>x\\<in>proots r. Im x = Im a\\<rbrakk>\n  \\<Longrightarrow> cindexE lb ub\n                     (\\<lambda>t.\n                         Im ((poly ?p \\<circ> g) t) /\n                         Re ((poly ?p \\<circ> g) t)) =\n                    cindexE lb ub\n                     (\\<lambda>t.\n                         Im ((poly q \\<circ> g) t) /\n                         Re ((poly q \\<circ> g) t))\n  g = linepath a (a + complex_of_real s)\n  p = q * ([:- b, 1:] * r)\n  lead_coeff ([:- b, 1:] * r) = 1\n  \\<forall>x\\<in>proots ([:- b, 1:] * r). Im x = Im a", "have ?case when \"s=0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>g = linepath a (a + complex_of_real s); ?p = q * r;\n   lead_coeff r = 1; \\<forall>x\\<in>proots r. Im x = Im a\\<rbrakk>\n  \\<Longrightarrow> cindexE lb ub\n                     (\\<lambda>t.\n                         Im ((poly ?p \\<circ> g) t) /\n                         Re ((poly ?p \\<circ> g) t)) =\n                    cindexE lb ub\n                     (\\<lambda>t.\n                         Im ((poly q \\<circ> g) t) /\n                         Re ((poly q \\<circ> g) t))\n  g = linepath a (a + complex_of_real s)\n  p = q * ([:- b, 1:] * r)\n  lead_coeff ([:- b, 1:] * r) = 1\n  \\<forall>x\\<in>proots ([:- b, 1:] * r). Im x = Im a\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "using that(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>g = linepath a (a + complex_of_real s); ?p = q * r;\n   lead_coeff r = 1; \\<forall>x\\<in>proots r. Im x = Im a\\<rbrakk>\n  \\<Longrightarrow> cindexE lb ub\n                     (\\<lambda>t.\n                         Im ((poly ?p \\<circ> g) t) /\n                         Re ((poly ?p \\<circ> g) t)) =\n                    cindexE lb ub\n                     (\\<lambda>t.\n                         Im ((poly q \\<circ> g) t) /\n                         Re ((poly q \\<circ> g) t))\n  g = linepath a (a + complex_of_real s)\n  p = q * ([:- b, 1:] * r)\n  lead_coeff ([:- b, 1:] * r) = 1\n  \\<forall>x\\<in>proots ([:- b, 1:] * r). Im x = Im a\n  s = 0\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "unfolding cindex_pathE_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>g = linepath a (a + complex_of_real s); ?p = q * r;\n   lead_coeff r = 1; \\<forall>x\\<in>proots r. Im x = Im a\\<rbrakk>\n  \\<Longrightarrow> cindexE lb ub\n                     (\\<lambda>t.\n                         Im ((poly ?p \\<circ> g) t) /\n                         Re ((poly ?p \\<circ> g) t)) =\n                    cindexE lb ub\n                     (\\<lambda>t.\n                         Im ((poly q \\<circ> g) t) /\n                         Re ((poly q \\<circ> g) t))\n  g = linepath a (a + complex_of_real s)\n  p = q * ([:- b, 1:] * r)\n  lead_coeff ([:- b, 1:] * r) = 1\n  \\<forall>x\\<in>proots ([:- b, 1:] * r). Im x = Im a\n  s = 0\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "by (simp add:cindexE_constI)"], ["proof (state)\nthis:\n  s = 0 \\<Longrightarrow>\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n\ngoal (1 subgoal):\n 1. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "moreover"], ["proof (state)\nthis:\n  s = 0 \\<Longrightarrow>\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n\ngoal (1 subgoal):\n 1. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "have ?case when \"s\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "define qrg where \"qrg = poly (q*r) \\<circ> g\""], ["proof (state)\nthis:\n  qrg = poly (q * r) \\<circ> g\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "have \"cindexE lb ub (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t))\n          = cindexE lb ub (\\<lambda>t. Im (qrg t * (g t - b)) / Re (qrg t * (g t - b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im (qrg t * (g t - b)) / Re (qrg t * (g t - b)))", "unfolding qrg_def \\<open>p = q * ([:- b, 1:] * r)\\<close> comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t.\n         Im (poly (q * ([:- b, 1:] * r)) (g t)) /\n         Re (poly (q * ([:- b, 1:] * r)) (g t))) =\n    cindexE lb ub\n     (\\<lambda>t.\n         Im (poly (q * r) (g t) * (g t - b)) /\n         Re (poly (q * r) (g t) * (g t - b)))", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im (qrg t * (g t - b)) / Re (qrg t * (g t - b)))\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "also"], ["proof (state)\nthis:\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im (qrg t * (g t - b)) / Re (qrg t * (g t - b)))\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "have \"... = cindexE lb ub\n        (\\<lambda>t. ((Re a + t * s - Re b )* Im (qrg t)) /\n           ((Re a + t * s - Re b )* Re (qrg t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im (qrg t * (g t - b)) / Re (qrg t * (g t - b))) =\n    cindexE lb ub\n     (\\<lambda>t.\n         (Re a + t * s - Re b) * Im (qrg t) /\n         ((Re a + t * s - Re b) * Re (qrg t)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im (qrg t * (g t - b)) / Re (qrg t * (g t - b))) =\n    cindexE lb ub\n     (\\<lambda>t.\n         (Re a + t * s - Re b) * Im (qrg t) /\n         ((Re a + t * s - Re b) * Re (qrg t)))", "have \"Im b = Im a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im b = Im a", "using \\<open>\\<forall>x\\<in>proots ([:- b, 1:] * r). Im x = Im a\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>proots ([:- b, 1:] * r). Im x = Im a\n\ngoal (1 subgoal):\n 1. Im b = Im a", "by auto"], ["proof (state)\nthis:\n  Im b = Im a\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im (qrg t * (g t - b)) / Re (qrg t * (g t - b))) =\n    cindexE lb ub\n     (\\<lambda>t.\n         (Re a + t * s - Re b) * Im (qrg t) /\n         ((Re a + t * s - Re b) * Re (qrg t)))", "then"], ["proof (chain)\npicking this:\n  Im b = Im a", "show ?thesis"], ["proof (prove)\nusing this:\n  Im b = Im a\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im (qrg t * (g t - b)) / Re (qrg t * (g t - b))) =\n    cindexE lb ub\n     (\\<lambda>t.\n         (Re a + t * s - Re b) * Im (qrg t) /\n         ((Re a + t * s - Re b) * Re (qrg t)))", "unfolding cindex_pathE_def g_def linepath_def"], ["proof (prove)\nusing this:\n  Im b = Im a\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t.\n         Im (qrg t *\n             ((1 - t) *\\<^sub>R a + t *\\<^sub>R (a + complex_of_real s) -\n              b)) /\n         Re (qrg t *\n             ((1 - t) *\\<^sub>R a + t *\\<^sub>R (a + complex_of_real s) -\n              b))) =\n    cindexE lb ub\n     (\\<lambda>t.\n         (Re a + t * s - Re b) * Im (qrg t) /\n         ((Re a + t * s - Re b) * Re (qrg t)))", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  cindexE lb ub\n   (\\<lambda>t. Im (qrg t * (g t - b)) / Re (qrg t * (g t - b))) =\n  cindexE lb ub\n   (\\<lambda>t.\n       (Re a + t * s - Re b) * Im (qrg t) /\n       ((Re a + t * s - Re b) * Re (qrg t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE lb ub\n   (\\<lambda>t. Im (qrg t * (g t - b)) / Re (qrg t * (g t - b))) =\n  cindexE lb ub\n   (\\<lambda>t.\n       (Re a + t * s - Re b) * Im (qrg t) /\n       ((Re a + t * s - Re b) * Re (qrg t)))\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "also"], ["proof (state)\nthis:\n  cindexE lb ub\n   (\\<lambda>t. Im (qrg t * (g t - b)) / Re (qrg t * (g t - b))) =\n  cindexE lb ub\n   (\\<lambda>t.\n       (Re a + t * s - Re b) * Im (qrg t) /\n       ((Re a + t * s - Re b) * Re (qrg t)))\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "have \"... = cindexE lb ub (\\<lambda>t. Im (qrg t) / Re (qrg t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t.\n         (Re a + t * s - Re b) * Im (qrg t) /\n         ((Re a + t * s - Re b) * Re (qrg t))) =\n    cindexE lb ub (\\<lambda>t. Im (qrg t) / Re (qrg t))", "proof (rule cindexE_cong[of \"{t. Re a + t * s - Re b = 0}\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {t. Re a + t * s - Re b = 0}\n 2. \\<And>x.\n       \\<lbrakk>lb < x; x < ub;\n        x \\<notin> {t. Re a + t * s - Re b = 0}\\<rbrakk>\n       \\<Longrightarrow> (Re a + x * s - Re b) * Im (qrg x) /\n                         ((Re a + x * s - Re b) * Re (qrg x)) =\n                         Im (qrg x) / Re (qrg x)", "show \"finite {t. Re a + t * s - Re b = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {t. Re a + t * s - Re b = 0}", "proof (cases \"Re a= Re b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Re a = Re b \\<Longrightarrow> finite {t. Re a + t * s - Re b = 0}\n 2. Re a \\<noteq> Re b \\<Longrightarrow> finite {t. Re a + t * s - Re b = 0}", "case True"], ["proof (state)\nthis:\n  Re a = Re b\n\ngoal (2 subgoals):\n 1. Re a = Re b \\<Longrightarrow> finite {t. Re a + t * s - Re b = 0}\n 2. Re a \\<noteq> Re b \\<Longrightarrow> finite {t. Re a + t * s - Re b = 0}", "then"], ["proof (chain)\npicking this:\n  Re a = Re b", "have \"{t. Re a + t * s - Re b = 0} = {0}\""], ["proof (prove)\nusing this:\n  Re a = Re b\n\ngoal (1 subgoal):\n 1. {t. Re a + t * s - Re b = 0} = {0}", "using \\<open>s\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  Re a = Re b\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {t. Re a + t * s - Re b = 0} = {0}", "by auto"], ["proof (state)\nthis:\n  {t. Re a + t * s - Re b = 0} = {0}\n\ngoal (2 subgoals):\n 1. Re a = Re b \\<Longrightarrow> finite {t. Re a + t * s - Re b = 0}\n 2. Re a \\<noteq> Re b \\<Longrightarrow> finite {t. Re a + t * s - Re b = 0}", "then"], ["proof (chain)\npicking this:\n  {t. Re a + t * s - Re b = 0} = {0}", "show ?thesis"], ["proof (prove)\nusing this:\n  {t. Re a + t * s - Re b = 0} = {0}\n\ngoal (1 subgoal):\n 1. finite {t. Re a + t * s - Re b = 0}", "by auto"], ["proof (state)\nthis:\n  finite {t. Re a + t * s - Re b = 0}\n\ngoal (1 subgoal):\n 1. Re a \\<noteq> Re b \\<Longrightarrow> finite {t. Re a + t * s - Re b = 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Re a \\<noteq> Re b \\<Longrightarrow> finite {t. Re a + t * s - Re b = 0}", "case False"], ["proof (state)\nthis:\n  Re a \\<noteq> Re b\n\ngoal (1 subgoal):\n 1. Re a \\<noteq> Re b \\<Longrightarrow> finite {t. Re a + t * s - Re b = 0}", "then"], ["proof (chain)\npicking this:\n  Re a \\<noteq> Re b", "have \"{t. Re a + t * s - Re b = 0} = {(Re b - Re a) / s}\""], ["proof (prove)\nusing this:\n  Re a \\<noteq> Re b\n\ngoal (1 subgoal):\n 1. {t. Re a + t * s - Re b = 0} = {(Re b - Re a) / s}", "using \\<open>s\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  Re a \\<noteq> Re b\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {t. Re a + t * s - Re b = 0} = {(Re b - Re a) / s}", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  {t. Re a + t * s - Re b = 0} = {(Re b - Re a) / s}\n\ngoal (1 subgoal):\n 1. Re a \\<noteq> Re b \\<Longrightarrow> finite {t. Re a + t * s - Re b = 0}", "then"], ["proof (chain)\npicking this:\n  {t. Re a + t * s - Re b = 0} = {(Re b - Re a) / s}", "show ?thesis"], ["proof (prove)\nusing this:\n  {t. Re a + t * s - Re b = 0} = {(Re b - Re a) / s}\n\ngoal (1 subgoal):\n 1. finite {t. Re a + t * s - Re b = 0}", "by auto"], ["proof (state)\nthis:\n  finite {t. Re a + t * s - Re b = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {t. Re a + t * s - Re b = 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>lb < x; x < ub;\n        x \\<notin> {t. Re a + t * s - Re b = 0}\\<rbrakk>\n       \\<Longrightarrow> (Re a + x * s - Re b) * Im (qrg x) /\n                         ((Re a + x * s - Re b) * Re (qrg x)) =\n                         Im (qrg x) / Re (qrg x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>lb < x; x < ub;\n        x \\<notin> {t. Re a + t * s - Re b = 0}\\<rbrakk>\n       \\<Longrightarrow> (Re a + x * s - Re b) * Im (qrg x) /\n                         ((Re a + x * s - Re b) * Re (qrg x)) =\n                         Im (qrg x) / Re (qrg x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>lb < x; x < ub;\n        x \\<notin> {t. Re a + t * s - Re b = 0}\\<rbrakk>\n       \\<Longrightarrow> (Re a + x * s - Re b) * Im (qrg x) /\n                         ((Re a + x * s - Re b) * Re (qrg x)) =\n                         Im (qrg x) / Re (qrg x)", "assume asm:\"x \\<notin> {t. Re a + t * s - Re b = 0}\""], ["proof (state)\nthis:\n  x \\<notin> {t. Re a + t * s - Re b = 0}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>lb < x; x < ub;\n        x \\<notin> {t. Re a + t * s - Re b = 0}\\<rbrakk>\n       \\<Longrightarrow> (Re a + x * s - Re b) * Im (qrg x) /\n                         ((Re a + x * s - Re b) * Re (qrg x)) =\n                         Im (qrg x) / Re (qrg x)", "define tt where \"tt=Re a + x * s - Re b\""], ["proof (state)\nthis:\n  tt = Re a + x * s - Re b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>lb < x; x < ub;\n        x \\<notin> {t. Re a + t * s - Re b = 0}\\<rbrakk>\n       \\<Longrightarrow> (Re a + x * s - Re b) * Im (qrg x) /\n                         ((Re a + x * s - Re b) * Re (qrg x)) =\n                         Im (qrg x) / Re (qrg x)", "have \"tt\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tt \\<noteq> 0", "using asm"], ["proof (prove)\nusing this:\n  x \\<notin> {t. Re a + t * s - Re b = 0}\n\ngoal (1 subgoal):\n 1. tt \\<noteq> 0", "unfolding tt_def"], ["proof (prove)\nusing this:\n  x \\<notin> {t. Re a + t * s - Re b = 0}\n\ngoal (1 subgoal):\n 1. Re a + x * s - Re b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>lb < x; x < ub;\n        x \\<notin> {t. Re a + t * s - Re b = 0}\\<rbrakk>\n       \\<Longrightarrow> (Re a + x * s - Re b) * Im (qrg x) /\n                         ((Re a + x * s - Re b) * Re (qrg x)) =\n                         Im (qrg x) / Re (qrg x)", "then"], ["proof (chain)\npicking this:\n  tt \\<noteq> 0", "show \"tt * Im (qrg x) / (tt * Re (qrg x)) = Im (qrg x) / Re (qrg x)\""], ["proof (prove)\nusing this:\n  tt \\<noteq> 0\n\ngoal (1 subgoal):\n 1. tt * Im (qrg x) / (tt * Re (qrg x)) = Im (qrg x) / Re (qrg x)", "by auto"], ["proof (state)\nthis:\n  tt * Im (qrg x) / (tt * Re (qrg x)) = Im (qrg x) / Re (qrg x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE lb ub\n   (\\<lambda>t.\n       (Re a + t * s - Re b) * Im (qrg t) /\n       ((Re a + t * s - Re b) * Re (qrg t))) =\n  cindexE lb ub (\\<lambda>t. Im (qrg t) / Re (qrg t))\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "also"], ["proof (state)\nthis:\n  cindexE lb ub\n   (\\<lambda>t.\n       (Re a + t * s - Re b) * Im (qrg t) /\n       ((Re a + t * s - Re b) * Re (qrg t))) =\n  cindexE lb ub (\\<lambda>t. Im (qrg t) / Re (qrg t))\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "have \"... = cindexE lb ub (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub (\\<lambda>t. Im (qrg t) / Re (qrg t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "unfolding qrg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t.\n         Im ((poly (q * r) \\<circ> g) t) /\n         Re ((poly (q * r) \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "proof (rule root(1))"], ["proof (state)\ngoal (4 subgoals):\n 1. g = linepath a (a + complex_of_real s)\n 2. q * r = q * r\n 3. lead_coeff r = 1\n 4. \\<forall>x\\<in>proots r. Im x = Im a", "show \"lead_coeff r = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff r = 1", "by (metis lead_coeff_mult lead_coeff_pCons(1) mult_cancel_left2 one_poly_eq_simps(2) \n          root.prems(2) zero_neq_one)"], ["proof (state)\nthis:\n  lead_coeff r = 1\n\ngoal (3 subgoals):\n 1. g = linepath a (a + complex_of_real s)\n 2. q * r = q * r\n 3. \\<forall>x\\<in>proots r. Im x = Im a", "qed (use root in simp_all)"], ["proof (state)\nthis:\n  cindexE lb ub (\\<lambda>t. Im (qrg t) / Re (qrg t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "finally"], ["proof (chain)\npicking this:\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "."], ["proof (state)\nthis:\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<noteq> 0 \\<Longrightarrow>\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n\ngoal (1 subgoal):\n 1. \\<And>aa p pa.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>g = linepath a (a + complex_of_real s);\n                    pa = q * p; lead_coeff p = 1;\n                    \\<forall>x\\<in>proots p. Im x = Im a\\<rbrakk>\n                   \\<Longrightarrow> cindexE lb ub\n(\\<lambda>t. Im ((poly pa \\<circ> g) t) / Re ((poly pa \\<circ> g) t)) =\n                                     cindexE lb ub\n(\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t));\n        g = linepath a (a + complex_of_real s); pa = q * ([:- aa, 1:] * p);\n        lead_coeff ([:- aa, 1:] * p) = 1;\n        \\<forall>x\\<in>proots ([:- aa, 1:] * p). Im x = Im a\\<rbrakk>\n       \\<Longrightarrow> cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly pa \\<circ> g) t) /\n                              Re ((poly pa \\<circ> g) t)) =\n                         cindexE lb ub\n                          (\\<lambda>t.\n                              Im ((poly q \\<circ> g) t) /\n                              Re ((poly q \\<circ> g) t))", "ultimately"], ["proof (chain)\npicking this:\n  s = 0 \\<Longrightarrow>\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n  s \\<noteq> 0 \\<Longrightarrow>\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "show ?case"], ["proof (prove)\nusing this:\n  s = 0 \\<Longrightarrow>\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n  s \\<noteq> 0 \\<Longrightarrow>\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n\ngoal (1 subgoal):\n 1. cindexE lb ub\n     (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n    cindexE lb ub\n     (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))", "by auto"], ["proof (state)\nthis:\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly p \\<circ> g) t) / Re ((poly p \\<circ> g) t)) =\n  cindexE lb ub\n   (\\<lambda>t. Im ((poly q \\<circ> g) t) / Re ((poly q \\<circ> g) t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_decompose_by_proots:\n  fixes p ::\"'a::idom poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"\\<exists>q r. p = q * r \\<and> lead_coeff q=1 \\<and> (\\<forall>x\\<in>proots q. P x) \\<and> (\\<forall>x\\<in>proots r. \\<not>P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       p = q * r \\<and>\n       lead_coeff q = (1::'a) \\<and>\n       (\\<forall>x\\<in>proots q. P x) \\<and>\n       (\\<forall>x\\<in>proots r. \\<not> P x)", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       p = q * r \\<and>\n       lead_coeff q = (1::'a) \\<and>\n       (\\<forall>x\\<in>proots q. P x) \\<and>\n       (\\<forall>x\\<in>proots r. \\<not> P x)", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>q r.\n       0 = q * r \\<and>\n       lead_coeff q = (1::'a) \\<and>\n       Ball (proots q) P \\<and> (\\<forall>x\\<in>proots r. \\<not> P x)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "case 0"], ["proof (state)\nthis:\n  0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>q r.\n       0 = q * r \\<and>\n       lead_coeff q = (1::'a) \\<and>\n       Ball (proots q) P \\<and> (\\<forall>x\\<in>proots r. \\<not> P x)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       0 = q * r \\<and>\n       lead_coeff q = (1::'a) \\<and>\n       (\\<forall>a\\<in>proots q. P a) \\<and>\n       (\\<forall>x\\<in>proots r. \\<not> P x)", "by simp"], ["proof (state)\nthis:\n  \\<exists>q r.\n     0 = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "then"], ["proof (chain)\npicking this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       p = q * r \\<and>\n       lead_coeff q = (1::'a) \\<and>\n       (\\<forall>a\\<in>proots q. P a) \\<and>\n       (\\<forall>x\\<in>proots r. \\<not> P x)", "apply (rule_tac x=1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         p = 1 * r \\<and>\n                         lead_coeff 1 = (1::'a) \\<and>\n                         (\\<forall>a\\<in>proots 1. P a) \\<and>\n                         (\\<forall>x\\<in>proots r. \\<not> P x)", "apply (rule_tac x=p in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> p = 1 * p \\<and>\n                      lead_coeff 1 = (1::'a) \\<and>\n                      (\\<forall>a\\<in>proots 1. P a) \\<and>\n                      (\\<forall>x\\<in>proots p. \\<not> P x)", "by (simp add:proots_def)"], ["proof (state)\nthis:\n  \\<exists>q r.\n     p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "case (root a p)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>q r.\n     p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n  [:- a, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>q r.\n     p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n  [:- a, 1::'a:] * p \\<noteq> 0", "obtain q r where pqr:\"p = q * r\" and leadq:\"lead_coeff q=1\" \n                    and qball:\"\\<forall>a\\<in>proots q. P a\" and rball:\"\\<forall>x\\<in>proots r. \\<not> P x\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>q r.\n     p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n  [:- a, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q * r; lead_coeff q = (1::'a);\n         \\<forall>a\\<in>proots q. P a;\n         \\<forall>x\\<in>proots r. \\<not> P x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mult_zero_right"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>q r.\n     p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n  [:- a, 1::'a:] * p \\<noteq> 0\n  ?a * (0::?'a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q * r; lead_coeff q = (1::'a);\n         \\<forall>a\\<in>proots q. P a;\n         \\<forall>x\\<in>proots r. \\<not> P x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p = q * r\n  lead_coeff q = (1::'a)\n  \\<forall>a\\<in>proots q. P a\n  \\<forall>x\\<in>proots r. \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "have ?case when \"P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       [:- a, 1::'a:] * p = q * r \\<and>\n       lead_coeff q = (1::'a) \\<and>\n       (\\<forall>a\\<in>proots q. P a) \\<and>\n       (\\<forall>x\\<in>proots r. \\<not> P x)", "apply (rule_tac x=\"[:- a, 1:] * q\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       [:- a, 1::'a:] * p = [:- a, 1::'a:] * q * r \\<and>\n       lead_coeff ([:- a, 1::'a:] * q) = (1::'a) \\<and>\n       (\\<forall>a\\<in>proots ([:- a, 1::'a:] * q). P a) \\<and>\n       (\\<forall>x\\<in>proots r. \\<not> P x)", "apply (rule_tac x=r in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * p = [:- a, 1::'a:] * q * r \\<and>\n    lead_coeff ([:- a, 1::'a:] * q) = (1::'a) \\<and>\n    (\\<forall>a\\<in>proots ([:- a, 1::'a:] * q). P a) \\<and>\n    (\\<forall>x\\<in>proots r. \\<not> P x)", "using pqr qball rball that leadq"], ["proof (prove)\nusing this:\n  p = q * r\n  \\<forall>a\\<in>proots q. P a\n  \\<forall>x\\<in>proots r. \\<not> P x\n  P a\n  lead_coeff q = (1::'a)\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * p = [:- a, 1::'a:] * q * r \\<and>\n    lead_coeff ([:- a, 1::'a:] * q) = (1::'a) \\<and>\n    (\\<forall>a\\<in>proots ([:- a, 1::'a:] * q). P a) \\<and>\n    (\\<forall>x\\<in>proots r. \\<not> P x)", "unfolding lead_coeff_mult"], ["proof (prove)\nusing this:\n  p = q * r\n  \\<forall>a\\<in>proots q. P a\n  \\<forall>x\\<in>proots r. \\<not> P x\n  P a\n  lead_coeff q = (1::'a)\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * p = [:- a, 1::'a:] * q * r \\<and>\n    lead_coeff [:- a, 1::'a:] * lead_coeff q = (1::'a) \\<and>\n    (\\<forall>a\\<in>proots ([:- a, 1::'a:] * q). P a) \\<and>\n    (\\<forall>x\\<in>proots r. \\<not> P x)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  P a \\<Longrightarrow>\n  \\<exists>q r.\n     [:- a, 1::'a:] * p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "moreover"], ["proof (state)\nthis:\n  P a \\<Longrightarrow>\n  \\<exists>q r.\n     [:- a, 1::'a:] * p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "have ?case when \"\\<not> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       [:- a, 1::'a:] * p = q * r \\<and>\n       lead_coeff q = (1::'a) \\<and>\n       (\\<forall>a\\<in>proots q. P a) \\<and>\n       (\\<forall>x\\<in>proots r. \\<not> P x)", "apply (rule_tac x=\"q\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       [:- a, 1::'a:] * p = q * r \\<and>\n       lead_coeff q = (1::'a) \\<and>\n       (\\<forall>a\\<in>proots q. P a) \\<and>\n       (\\<forall>x\\<in>proots r. \\<not> P x)", "apply (rule_tac x=\"[:- a, 1:] *r\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * p = q * ([:- a, 1::'a:] * r) \\<and>\n    lead_coeff q = (1::'a) \\<and>\n    (\\<forall>a\\<in>proots q. P a) \\<and>\n    (\\<forall>x\\<in>proots ([:- a, 1::'a:] * r). \\<not> P x)", "using pqr qball rball that leadq"], ["proof (prove)\nusing this:\n  p = q * r\n  \\<forall>a\\<in>proots q. P a\n  \\<forall>x\\<in>proots r. \\<not> P x\n  \\<not> P a\n  lead_coeff q = (1::'a)\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * p = q * ([:- a, 1::'a:] * r) \\<and>\n    lead_coeff q = (1::'a) \\<and>\n    (\\<forall>a\\<in>proots q. P a) \\<and>\n    (\\<forall>x\\<in>proots ([:- a, 1::'a:] * r). \\<not> P x)", "unfolding lead_coeff_mult"], ["proof (prove)\nusing this:\n  p = q * r\n  \\<forall>a\\<in>proots q. P a\n  \\<forall>x\\<in>proots r. \\<not> P x\n  \\<not> P a\n  lead_coeff q = (1::'a)\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * p = q * ([:- a, 1::'a:] * r) \\<and>\n    lead_coeff q = (1::'a) \\<and>\n    (\\<forall>a\\<in>proots q. P a) \\<and>\n    (\\<forall>x\\<in>proots ([:- a, 1::'a:] * r). \\<not> P x)", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  \\<not> P a \\<Longrightarrow>\n  \\<exists>q r.\n     [:- a, 1::'a:] * p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                \\<exists>q r.\n                   p = q * r \\<and>\n                   lead_coeff q = (1::'a) \\<and>\n                   Ball (proots q) P \\<and>\n                   (\\<forall>x\\<in>proots r. \\<not> P x);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q r.\n                            [:- a, 1::'a:] * p = q * r \\<and>\n                            lead_coeff q = (1::'a) \\<and>\n                            Ball (proots q) P \\<and>\n                            (\\<forall>x\\<in>proots r. \\<not> P x)", "ultimately"], ["proof (chain)\npicking this:\n  P a \\<Longrightarrow>\n  \\<exists>q r.\n     [:- a, 1::'a:] * p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n  \\<not> P a \\<Longrightarrow>\n  \\<exists>q r.\n     [:- a, 1::'a:] * p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)", "show ?case"], ["proof (prove)\nusing this:\n  P a \\<Longrightarrow>\n  \\<exists>q r.\n     [:- a, 1::'a:] * p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n  \\<not> P a \\<Longrightarrow>\n  \\<exists>q r.\n     [:- a, 1::'a:] * p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n\ngoal (1 subgoal):\n 1. \\<exists>q r.\n       [:- a, 1::'a:] * p = q * r \\<and>\n       lead_coeff q = (1::'a) \\<and>\n       (\\<forall>a\\<in>proots q. P a) \\<and>\n       (\\<forall>x\\<in>proots r. \\<not> P x)", "by blast"], ["proof (state)\nthis:\n  \\<exists>q r.\n     [:- a, 1::'a:] * p = q * r \\<and>\n     lead_coeff q = (1::'a) \\<and>\n     (\\<forall>a\\<in>proots q. P a) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> P x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_upper_cindex_eq':\n  assumes \"lead_coeff p=1\"\n  shows \"proots_upper p = (degree p - proots_count p {x. Im x=0} \n              - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "have \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  lead_coeff p = 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "from poly_decompose_by_proots[OF this,of \"\\<lambda>x. Im x\\<noteq>0\"]"], ["proof (chain)\npicking this:\n  \\<exists>q r.\n     p = q * r \\<and>\n     lead_coeff q = 1 \\<and>\n     (\\<forall>x\\<in>proots q. Im x \\<noteq> 0) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> Im x \\<noteq> 0)", "obtain q r where pqr:\"p = q * r\" and leadq:\"lead_coeff q=1\"\n              and qball: \"\\<forall>x\\<in>proots q. Im x \\<noteq>0\" and rball:\"\\<forall>x\\<in>proots r. Im x =0\""], ["proof (prove)\nusing this:\n  \\<exists>q r.\n     p = q * r \\<and>\n     lead_coeff q = 1 \\<and>\n     (\\<forall>x\\<in>proots q. Im x \\<noteq> 0) \\<and>\n     (\\<forall>x\\<in>proots r. \\<not> Im x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q * r; lead_coeff q = 1;\n         \\<forall>x\\<in>proots q. Im x \\<noteq> 0;\n         \\<forall>x\\<in>proots r. Im x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = q * r\n  lead_coeff q = 1\n  \\<forall>x\\<in>proots q. Im x \\<noteq> 0\n  \\<forall>x\\<in>proots r. Im x = 0\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "have \"real_of_int (proots_upper p) = proots_upper q + proots_upper r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (int (proots_upper p)) =\n    real (proots_upper q + proots_upper r)", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int (int (proots_upper p)) =\n    real (proots_upper q + proots_upper r)", "unfolding proots_upper_def pqr"], ["proof (prove)\nusing this:\n  q * r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int (int (proots_count (q * r) {z. 0 < Im z})) =\n    real (proots_count q {z. 0 < Im z} + proots_count r {z. 0 < Im z})", "by (auto simp add:proots_count_times)"], ["proof (state)\nthis:\n  real_of_int (int (proots_upper p)) =\n  real (proots_upper q + proots_upper r)\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "also"], ["proof (state)\nthis:\n  real_of_int (int (proots_upper p)) =\n  real (proots_upper q + proots_upper r)\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "have \"... = proots_upper q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (proots_upper q + proots_upper r) = real (proots_upper q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (proots_upper q + proots_upper r) = real (proots_upper q)", "have \"proots_within r {z. 0 < Im z} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within r {z. 0 < Im z} = {}", "using rball"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>proots r. Im x = 0\n\ngoal (1 subgoal):\n 1. proots_within r {z. 0 < Im z} = {}", "by auto"], ["proof (state)\nthis:\n  proots_within r {z. 0 < Im z} = {}\n\ngoal (1 subgoal):\n 1. real (proots_upper q + proots_upper r) = real (proots_upper q)", "then"], ["proof (chain)\npicking this:\n  proots_within r {z. 0 < Im z} = {}", "have \"proots_upper r =0 \""], ["proof (prove)\nusing this:\n  proots_within r {z. 0 < Im z} = {}\n\ngoal (1 subgoal):\n 1. proots_upper r = 0", "unfolding proots_upper_def proots_count_def"], ["proof (prove)\nusing this:\n  proots_within r {z. 0 < Im z} = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>ra\\<in>proots_within r {z. 0 < Im z}. order ra r) = 0", "by simp"], ["proof (state)\nthis:\n  proots_upper r = 0\n\ngoal (1 subgoal):\n 1. real (proots_upper q + proots_upper r) = real (proots_upper q)", "then"], ["proof (chain)\npicking this:\n  proots_upper r = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_upper r = 0\n\ngoal (1 subgoal):\n 1. real (proots_upper q + proots_upper r) = real (proots_upper q)", "by auto"], ["proof (state)\nthis:\n  real (proots_upper q + proots_upper r) = real (proots_upper q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (proots_upper q + proots_upper r) = real (proots_upper q)\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "also"], ["proof (state)\nthis:\n  real (proots_upper q + proots_upper r) = real (proots_upper q)\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "have \"... =  (degree q - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (proots_upper q) =\n    real_of_int\n     (int (degree q) - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) /\n    2", "by (rule proots_upper_cindex_eq[OF leadq qball])"], ["proof (state)\nthis:\n  real (proots_upper q) =\n  real_of_int\n   (int (degree q) - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) /\n  2\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "also"], ["proof (state)\nthis:\n  real (proots_upper q) =\n  real_of_int\n   (int (degree q) - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) /\n  2\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "have \"... = (degree p - proots_count p {x. Im x=0} \n                      - cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     (int (degree q) - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) /\n    2 =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int\n     (int (degree q) - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) /\n    2 =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "have \"degree q = degree p - proots_count p {x. Im x=0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = degree p - proots_count p {x. Im x = 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree q = degree p - proots_count p {x. Im x = 0}", "have \"degree p= degree q + degree r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = degree q + degree r", "unfolding pqr"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (q * r) = degree q + degree r", "apply (rule degree_mult_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. q \\<noteq> 0\n 2. r \\<noteq> 0", "using \\<open>p \\<noteq> 0\\<close> pqr"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = q * r\n\ngoal (2 subgoals):\n 1. q \\<noteq> 0\n 2. r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree p = degree q + degree r\n\ngoal (1 subgoal):\n 1. degree q = degree p - proots_count p {x. Im x = 0}", "moreover"], ["proof (state)\nthis:\n  degree p = degree q + degree r\n\ngoal (1 subgoal):\n 1. degree q = degree p - proots_count p {x. Im x = 0}", "have \"degree r = proots_count p {x. Im x=0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree r = proots_count p {x. Im x = 0}", "unfolding degree_proots_count proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ra\\<in>proots r. order ra r) =\n    (\\<Sum>r\\<in>proots_within p {x. Im x = 0}. order r p)", "proof (rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. proots r = proots_within p {x. Im x = 0}\n 2. \\<And>x.\n       x \\<in> proots_within p {x. Im x = 0} \\<Longrightarrow>\n       order x r = order x p", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. proots r = proots_within p {x. Im x = 0}\n 2. \\<And>x.\n       x \\<in> proots_within p {x. Im x = 0} \\<Longrightarrow>\n       order x r = order x p", "assume \"x \\<in> proots_within p {x. Im x = 0}\""], ["proof (state)\nthis:\n  x \\<in> proots_within p {x. Im x = 0}\n\ngoal (2 subgoals):\n 1. proots r = proots_within p {x. Im x = 0}\n 2. \\<And>x.\n       x \\<in> proots_within p {x. Im x = 0} \\<Longrightarrow>\n       order x r = order x p", "then"], ["proof (chain)\npicking this:\n  x \\<in> proots_within p {x. Im x = 0}", "have \"Im x=0\""], ["proof (prove)\nusing this:\n  x \\<in> proots_within p {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. Im x = 0", "by auto"], ["proof (state)\nthis:\n  Im x = 0\n\ngoal (2 subgoals):\n 1. proots r = proots_within p {x. Im x = 0}\n 2. \\<And>x.\n       x \\<in> proots_within p {x. Im x = 0} \\<Longrightarrow>\n       order x r = order x p", "then"], ["proof (chain)\npicking this:\n  Im x = 0", "have \"order x q = 0\""], ["proof (prove)\nusing this:\n  Im x = 0\n\ngoal (1 subgoal):\n 1. order x q = 0", "using qball order_0I"], ["proof (prove)\nusing this:\n  Im x = 0\n  \\<forall>x\\<in>proots q. Im x \\<noteq> 0\n  poly ?p ?a \\<noteq> (0::?'a) \\<Longrightarrow> order ?a ?p = 0\n\ngoal (1 subgoal):\n 1. order x q = 0", "by blast"], ["proof (state)\nthis:\n  order x q = 0\n\ngoal (2 subgoals):\n 1. proots r = proots_within p {x. Im x = 0}\n 2. \\<And>x.\n       x \\<in> proots_within p {x. Im x = 0} \\<Longrightarrow>\n       order x r = order x p", "then"], ["proof (chain)\npicking this:\n  order x q = 0", "show \"order x r = order x p\""], ["proof (prove)\nusing this:\n  order x q = 0\n\ngoal (1 subgoal):\n 1. order x r = order x p", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  order x q = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x r = order x p", "unfolding pqr"], ["proof (prove)\nusing this:\n  order x q = 0\n  q * r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x r = order x (q * r)", "by (simp add: order_mult)"], ["proof (state)\nthis:\n  order x r = order x p\n\ngoal (1 subgoal):\n 1. proots r = proots_within p {x. Im x = 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. proots r = proots_within p {x. Im x = 0}", "show \"proots r = proots_within p {x. Im x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots r = proots_within p {x. Im x = 0}", "unfolding pqr proots_within_times"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots r =\n    proots_within q {x. Im x = 0} \\<union> proots_within r {x. Im x = 0}", "using qball rball"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>proots q. Im x \\<noteq> 0\n  \\<forall>x\\<in>proots r. Im x = 0\n\ngoal (1 subgoal):\n 1. proots r =\n    proots_within q {x. Im x = 0} \\<union> proots_within r {x. Im x = 0}", "by auto"], ["proof (state)\nthis:\n  proots r = proots_within p {x. Im x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree r = proots_count p {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. degree q = degree p - proots_count p {x. Im x = 0}", "ultimately"], ["proof (chain)\npicking this:\n  degree p = degree q + degree r\n  degree r = proots_count p {x. Im x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  degree p = degree q + degree r\n  degree r = proots_count p {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. degree q = degree p - proots_count p {x. Im x = 0}", "by auto"], ["proof (state)\nthis:\n  degree q = degree p - proots_count p {x. Im x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree q = degree p - proots_count p {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (degree q) - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) /\n    2 =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "moreover"], ["proof (state)\nthis:\n  degree q = degree p - proots_count p {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (degree q) - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) /\n    2 =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "have \"cindex_poly_ubd (map_poly Im q) (map_poly Re q) \n            = cindex_poly_ubd (map_poly Im p) (map_poly Re p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly_ubd (map_poly Im q) (map_poly Re q) =\n    cindex_poly_ubd (map_poly Im p) (map_poly Re p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindex_poly_ubd (map_poly Im q) (map_poly Re q) =\n    cindex_poly_ubd (map_poly Im p) (map_poly Re p)", "define iq rq ip rp where \"iq = map_poly Im q\" and \"rq=map_poly Re q\" \n                           and \"ip=map_poly Im p\" and \"rp = map_poly Re p\""], ["proof (state)\nthis:\n  iq = map_poly Im q\n  rq = map_poly Re q\n  ip = map_poly Im p\n  rp = map_poly Re p\n\ngoal (1 subgoal):\n 1. cindex_poly_ubd (map_poly Im q) (map_poly Re q) =\n    cindex_poly_ubd (map_poly Im p) (map_poly Re p)", "have \"cindexE (- x) x (\\<lambda>x. poly iq x / poly rq x) \n              = cindexE (- x) x (\\<lambda>x. poly ip x / poly rp x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindexE (- x) x (\\<lambda>x. poly iq x / poly rq x) =\n    cindexE (- x) x (\\<lambda>x. poly ip x / poly rp x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindexE (- x) x (\\<lambda>x. poly iq x / poly rq x) =\n    cindexE (- x) x (\\<lambda>x. poly ip x / poly rp x)", "have \"lead_coeff r = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff r = 1", "using pqr leadq \\<open>lead_coeff p=1\\<close>"], ["proof (prove)\nusing this:\n  p = q * r\n  lead_coeff q = 1\n  lead_coeff p = 1\n\ngoal (1 subgoal):\n 1. lead_coeff r = 1", "by (simp add: coeff_degree_mult)"], ["proof (state)\nthis:\n  lead_coeff r = 1\n\ngoal (1 subgoal):\n 1. cindexE (- x) x (\\<lambda>x. poly iq x / poly rq x) =\n    cindexE (- x) x (\\<lambda>x. poly ip x / poly rp x)", "then"], ["proof (chain)\npicking this:\n  lead_coeff r = 1", "have \"cindexE (- x) x (\\<lambda>t. Im (poly p (t *\\<^sub>R 1)) / Re (poly p (t *\\<^sub>R 1))) =\n                      cindexE (- x) x (\\<lambda>t. Im (poly q (t *\\<^sub>R 1)) / Re (poly q (t *\\<^sub>R 1)))\""], ["proof (prove)\nusing this:\n  lead_coeff r = 1\n\ngoal (1 subgoal):\n 1. cindexE (- x) x\n     (\\<lambda>t.\n         Im (poly p (t *\\<^sub>R 1)) / Re (poly p (t *\\<^sub>R 1))) =\n    cindexE (- x) x\n     (\\<lambda>t. Im (poly q (t *\\<^sub>R 1)) / Re (poly q (t *\\<^sub>R 1)))", "using cindexE_roots_on_horizontal_border[OF pqr,of 0 \"-x\" x 1\n              ,unfolded linepath_def comp_def,simplified] rball"], ["proof (prove)\nusing this:\n  lead_coeff r = 1\n  \\<lbrakk>lead_coeff r = 1; \\<forall>x\\<in>proots r. Im x = 0\\<rbrakk>\n  \\<Longrightarrow> cindexE (- x) x\n                     (\\<lambda>t.\n                         Im (poly p (t *\\<^sub>R 1)) /\n                         Re (poly p (t *\\<^sub>R 1))) =\n                    cindexE (- x) x\n                     (\\<lambda>t.\n                         Im (poly q (t *\\<^sub>R 1)) /\n                         Re (poly q (t *\\<^sub>R 1)))\n  \\<forall>x\\<in>proots r. Im x = 0\n\ngoal (1 subgoal):\n 1. cindexE (- x) x\n     (\\<lambda>t.\n         Im (poly p (t *\\<^sub>R 1)) / Re (poly p (t *\\<^sub>R 1))) =\n    cindexE (- x) x\n     (\\<lambda>t. Im (poly q (t *\\<^sub>R 1)) / Re (poly q (t *\\<^sub>R 1)))", "by simp"], ["proof (state)\nthis:\n  cindexE (- x) x\n   (\\<lambda>t. Im (poly p (t *\\<^sub>R 1)) / Re (poly p (t *\\<^sub>R 1))) =\n  cindexE (- x) x\n   (\\<lambda>t. Im (poly q (t *\\<^sub>R 1)) / Re (poly q (t *\\<^sub>R 1)))\n\ngoal (1 subgoal):\n 1. cindexE (- x) x (\\<lambda>x. poly iq x / poly rq x) =\n    cindexE (- x) x (\\<lambda>x. poly ip x / poly rp x)", "then"], ["proof (chain)\npicking this:\n  cindexE (- x) x\n   (\\<lambda>t. Im (poly p (t *\\<^sub>R 1)) / Re (poly p (t *\\<^sub>R 1))) =\n  cindexE (- x) x\n   (\\<lambda>t. Im (poly q (t *\\<^sub>R 1)) / Re (poly q (t *\\<^sub>R 1)))", "show ?thesis"], ["proof (prove)\nusing this:\n  cindexE (- x) x\n   (\\<lambda>t. Im (poly p (t *\\<^sub>R 1)) / Re (poly p (t *\\<^sub>R 1))) =\n  cindexE (- x) x\n   (\\<lambda>t. Im (poly q (t *\\<^sub>R 1)) / Re (poly q (t *\\<^sub>R 1)))\n\ngoal (1 subgoal):\n 1. cindexE (- x) x (\\<lambda>x. poly iq x / poly rq x) =\n    cindexE (- x) x (\\<lambda>x. poly ip x / poly rp x)", "unfolding scaleR_conv_of_real iq_def ip_def rq_def rp_def"], ["proof (prove)\nusing this:\n  cindexE (- x) x\n   (\\<lambda>t.\n       Im (poly p (complex_of_real t * 1)) /\n       Re (poly p (complex_of_real t * 1))) =\n  cindexE (- x) x\n   (\\<lambda>t.\n       Im (poly q (complex_of_real t * 1)) /\n       Re (poly q (complex_of_real t * 1)))\n\ngoal (1 subgoal):\n 1. cindexE (- x) x\n     (\\<lambda>x. poly (map_poly Im q) x / poly (map_poly Re q) x) =\n    cindexE (- x) x\n     (\\<lambda>x. poly (map_poly Im p) x / poly (map_poly Re p) x)", "by (simp add:Im_poly_of_real Re_poly_of_real)"], ["proof (state)\nthis:\n  cindexE (- x) x (\\<lambda>x. poly iq x / poly rq x) =\n  cindexE (- x) x (\\<lambda>x. poly ip x / poly rp x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindexE (- ?x) ?x (\\<lambda>x. poly iq x / poly rq x) =\n  cindexE (- ?x) ?x (\\<lambda>x. poly ip x / poly rp x)\n\ngoal (1 subgoal):\n 1. cindex_poly_ubd (map_poly Im q) (map_poly Re q) =\n    cindex_poly_ubd (map_poly Im p) (map_poly Re p)", "then"], ["proof (chain)\npicking this:\n  cindexE (- ?x) ?x (\\<lambda>x. poly iq x / poly rq x) =\n  cindexE (- ?x) ?x (\\<lambda>x. poly ip x / poly rp x)", "have \"\\<forall>\\<^sub>F r::real in at_top.\n        real_of_int (cindex_poly_ubd iq rq) = cindex_poly_ubd ip rp\""], ["proof (prove)\nusing this:\n  cindexE (- ?x) ?x (\\<lambda>x. poly iq x / poly rq x) =\n  cindexE (- ?x) ?x (\\<lambda>x. poly ip x / poly rp x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       real_of_int (cindex_poly_ubd iq rq) =\n       real_of_int (cindex_poly_ubd ip rp)", "using eventually_conj[OF cindex_poly_ubd_eventually[of iq rq] \n                cindex_poly_ubd_eventually[of ip rp]]"], ["proof (prove)\nusing this:\n  cindexE (- ?x) ?x (\\<lambda>x. poly iq x / poly rq x) =\n  cindexE (- ?x) ?x (\\<lambda>x. poly ip x / poly rp x)\n  \\<forall>\\<^sub>F x in at_top.\n     cindexE (- x) x (\\<lambda>x. poly iq x / poly rq x) =\n     real_of_int (cindex_poly_ubd iq rq) \\<and>\n     cindexE (- x) x (\\<lambda>x. poly ip x / poly rp x) =\n     real_of_int (cindex_poly_ubd ip rp)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       real_of_int (cindex_poly_ubd iq rq) =\n       real_of_int (cindex_poly_ubd ip rp)", "by (elim eventually_mono,auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F r in at_top.\n     real_of_int (cindex_poly_ubd iq rq) =\n     real_of_int (cindex_poly_ubd ip rp)\n\ngoal (1 subgoal):\n 1. cindex_poly_ubd (map_poly Im q) (map_poly Re q) =\n    cindex_poly_ubd (map_poly Im p) (map_poly Re p)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F r in at_top.\n     real_of_int (cindex_poly_ubd iq rq) =\n     real_of_int (cindex_poly_ubd ip rp)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F r in at_top.\n     real_of_int (cindex_poly_ubd iq rq) =\n     real_of_int (cindex_poly_ubd ip rp)\n\ngoal (1 subgoal):\n 1. cindex_poly_ubd (map_poly Im q) (map_poly Re q) =\n    cindex_poly_ubd (map_poly Im p) (map_poly Re p)", "apply (fold iq_def rq_def ip_def rp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F r in at_top.\n       real_of_int (cindex_poly_ubd iq rq) =\n       real_of_int (cindex_poly_ubd ip rp) \\<Longrightarrow>\n    cindex_poly_ubd iq rq = cindex_poly_ubd ip rp", "by simp"], ["proof (state)\nthis:\n  cindex_poly_ubd (map_poly Im q) (map_poly Re q) =\n  cindex_poly_ubd (map_poly Im p) (map_poly Re p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cindex_poly_ubd (map_poly Im q) (map_poly Re q) =\n  cindex_poly_ubd (map_poly Im p) (map_poly Re p)\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (degree q) - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) /\n    2 =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "ultimately"], ["proof (chain)\npicking this:\n  degree q = degree p - proots_count p {x. Im x = 0}\n  cindex_poly_ubd (map_poly Im q) (map_poly Re q) =\n  cindex_poly_ubd (map_poly Im p) (map_poly Re p)", "show ?thesis"], ["proof (prove)\nusing this:\n  degree q = degree p - proots_count p {x. Im x = 0}\n  cindex_poly_ubd (map_poly Im q) (map_poly Re q) =\n  cindex_poly_ubd (map_poly Im p) (map_poly Re p)\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (degree q) - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) /\n    2 =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "by auto"], ["proof (state)\nthis:\n  real_of_int\n   (int (degree q) - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) /\n  2 =\n  real_of_int\n   (int (degree p - proots_count p {x. Im x = 0}) -\n    cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n  2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int\n   (int (degree q) - cindex_poly_ubd (map_poly Im q) (map_poly Re q)) /\n  2 =\n  real_of_int\n   (int (degree p - proots_count p {x. Im x = 0}) -\n    cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n  2\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "finally"], ["proof (chain)\npicking this:\n  real_of_int (int (proots_upper p)) =\n  real_of_int\n   (int (degree p - proots_count p {x. Im x = 0}) -\n    cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n  2", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int (int (proots_upper p)) =\n  real_of_int\n   (int (degree p - proots_count p {x. Im x = 0}) -\n    cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n  2\n\ngoal (1 subgoal):\n 1. real (proots_upper p) =\n    real_of_int\n     (int (degree p - proots_count p {x. Im x = 0}) -\n      cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n    2", "by simp"], ["proof (state)\nthis:\n  real (proots_upper p) =\n  real_of_int\n   (int (degree p - proots_count p {x. Im x = 0}) -\n    cindex_poly_ubd (map_poly Im p) (map_poly Re p)) /\n  2\n\ngoal:\nNo subgoals!", "qed"], ["", "(*If we know that the polynomial p is squarefree, we can cope with the case when there're \n  roots on the border.*)"], ["", "lemma proots_within_upper_squarefree:\n  assumes \"rsquarefree p\"\n  shows  \"card (proots_within p {x. Im x >0}) = (let \n            pp = smult (inverse (lead_coeff p)) p;\n            pI = map_poly Im pp;\n            pR = map_poly Re pp;\n            g = gcd pR pI\n        in\n            nat ((degree p - changes_R_smods g (pderiv g) - changes_R_smods pR pI) div 2)  \n      )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "define pp where \"pp = smult (inverse (lead_coeff p)) p\""], ["proof (state)\nthis:\n  pp = smult (inverse (lead_coeff p)) p\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "define pI where \"pI = map_poly Im pp\""], ["proof (state)\nthis:\n  pI = map_poly Im pp\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "define pR where \"pR = map_poly Re pp\""], ["proof (state)\nthis:\n  pR = map_poly Re pp\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "define g where  \"g = gcd pR pI\""], ["proof (state)\nthis:\n  g = gcd pR pI\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "have \"card (proots_within p {x. Im x >0}) = proots_upper p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) = proots_upper p", "unfolding proots_upper_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) = proots_count p {z. 0 < Im z}", "using card_proots_within_rsquarefree[OF assms]"], ["proof (prove)\nusing this:\n  proots_count p ?s = card (proots_within p ?s)\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) = proots_count p {z. 0 < Im z}", "by auto"], ["proof (state)\nthis:\n  card (proots_within p {x. 0 < Im x}) = proots_upper p\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "also"], ["proof (state)\nthis:\n  card (proots_within p {x. 0 < Im x}) = proots_upper p\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "have \"... = proots_upper pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_upper p = proots_upper pp", "unfolding proots_upper_def pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {z. 0 < Im z} =\n    proots_count (smult (inverse (lead_coeff p)) p) {z. 0 < Im z}", "apply (subst proots_count_smult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inverse (lead_coeff p) \\<noteq> 0\n 2. proots_count p {z. 0 < Im z} = proots_count p {z. 0 < Im z}", "using assms"], ["proof (prove)\nusing this:\n  rsquarefree p\n\ngoal (2 subgoals):\n 1. inverse (lead_coeff p) \\<noteq> 0\n 2. proots_count p {z. 0 < Im z} = proots_count p {z. 0 < Im z}", "by auto"], ["proof (state)\nthis:\n  proots_upper p = proots_upper pp\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "also"], ["proof (state)\nthis:\n  proots_upper p = proots_upper pp\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "have \"... = (degree pp - proots_count pp {x. Im x = 0} - cindex_poly_ubd pI pR) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_upper pp) =\n    (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (proots_upper pp) =\n    (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2", "define rr where \"rr = proots_count pp {x. Im x = 0}\""], ["proof (state)\nthis:\n  rr = proots_count pp {x. Im x = 0}\n\ngoal (1 subgoal):\n 1. int (proots_upper pp) =\n    (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2", "define cpp where \"cpp = cindex_poly_ubd pI pR\""], ["proof (state)\nthis:\n  cpp = cindex_poly_ubd pI pR\n\ngoal (1 subgoal):\n 1. int (proots_upper pp) =\n    (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2", "have *:\"proots_upper pp = (degree pp - rr - cpp) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (proots_upper pp) = real_of_int (int (degree pp - rr) - cpp) / 2", "apply (rule proots_upper_cindex_eq'[of pp,folded rr_def cpp_def pR_def pI_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff pp = 1", "unfolding pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (smult (inverse (lead_coeff p)) p) = 1", "using assms"], ["proof (prove)\nusing this:\n  rsquarefree p\n\ngoal (1 subgoal):\n 1. lead_coeff (smult (inverse (lead_coeff p)) p) = 1", "by auto"], ["proof (state)\nthis:\n  real (proots_upper pp) = real_of_int (int (degree pp - rr) - cpp) / 2\n\ngoal (1 subgoal):\n 1. int (proots_upper pp) =\n    (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2", "also"], ["proof (state)\nthis:\n  real (proots_upper pp) = real_of_int (int (degree pp - rr) - cpp) / 2\n\ngoal (1 subgoal):\n 1. int (proots_upper pp) =\n    (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2", "have \"... = (degree pp - rr - cpp) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (int (degree pp - rr) - cpp) / 2 =\n    real_of_int ((int (degree pp - rr) - cpp) div 2)", "proof (subst real_of_int_div)"], ["proof (state)\ngoal (2 subgoals):\n 1. even (int (degree pp - rr) - cpp)\n 2. real_of_int (int (degree pp - rr) - cpp) / 2 =\n    real_of_int (int (degree pp - rr) - cpp) / real_of_int 2", "define tt where \"tt=int (degree pp - rr) - cpp\""], ["proof (state)\nthis:\n  tt = int (degree pp - rr) - cpp\n\ngoal (2 subgoals):\n 1. even (int (degree pp - rr) - cpp)\n 2. real_of_int (int (degree pp - rr) - cpp) / 2 =\n    real_of_int (int (degree pp - rr) - cpp) / real_of_int 2", "have \"real_of_int tt=2*proots_upper pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int tt = real (2 * proots_upper pp)", "by (simp add:*[folded tt_def])"], ["proof (state)\nthis:\n  real_of_int tt = real (2 * proots_upper pp)\n\ngoal (2 subgoals):\n 1. even (int (degree pp - rr) - cpp)\n 2. real_of_int (int (degree pp - rr) - cpp) / 2 =\n    real_of_int (int (degree pp - rr) - cpp) / real_of_int 2", "then"], ["proof (chain)\npicking this:\n  real_of_int tt = real (2 * proots_upper pp)", "show \"even tt\""], ["proof (prove)\nusing this:\n  real_of_int tt = real (2 * proots_upper pp)\n\ngoal (1 subgoal):\n 1. even tt", "by (metis dvd_triv_left even_of_nat of_int_eq_iff of_int_of_nat_eq)"], ["proof (state)\nthis:\n  even tt\n\ngoal (1 subgoal):\n 1. real_of_int (int (degree pp - rr) - cpp) / 2 =\n    real_of_int (int (degree pp - rr) - cpp) / real_of_int 2", "qed simp"], ["proof (state)\nthis:\n  real_of_int (int (degree pp - rr) - cpp) / 2 =\n  real_of_int ((int (degree pp - rr) - cpp) div 2)\n\ngoal (1 subgoal):\n 1. int (proots_upper pp) =\n    (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2", "finally"], ["proof (chain)\npicking this:\n  real (proots_upper pp) = real_of_int ((int (degree pp - rr) - cpp) div 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  real (proots_upper pp) = real_of_int ((int (degree pp - rr) - cpp) div 2)\n\ngoal (1 subgoal):\n 1. int (proots_upper pp) =\n    (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2", "unfolding rr_def cpp_def"], ["proof (prove)\nusing this:\n  real (proots_upper pp) =\n  real_of_int\n   ((int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2)\n\ngoal (1 subgoal):\n 1. int (proots_upper pp) =\n    (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2", "by simp"], ["proof (state)\nthis:\n  int (proots_upper pp) =\n  (int (degree pp - proots_count pp {x. Im x = 0}) -\n   cindex_poly_ubd pI pR) div\n  2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (proots_upper pp) =\n  (int (degree pp - proots_count pp {x. Im x = 0}) -\n   cindex_poly_ubd pI pR) div\n  2\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "also"], ["proof (state)\nthis:\n  int (proots_upper pp) =\n  (int (degree pp - proots_count pp {x. Im x = 0}) -\n   cindex_poly_ubd pI pR) div\n  2\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "have \"... = (degree pp - changes_R_smods g (pderiv g) \n                        - cindex_poly_ubd pI pR) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "have \"rsquarefree pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree pp", "using assms rsquarefree_smult_iff"], ["proof (prove)\nusing this:\n  rsquarefree p\n  ?s \\<noteq> (0::?'a) \\<Longrightarrow>\n  rsquarefree (smult ?s ?p) = rsquarefree ?p\n\ngoal (1 subgoal):\n 1. rsquarefree pp", "unfolding pp_def"], ["proof (prove)\nusing this:\n  rsquarefree p\n  ?s \\<noteq> (0::?'a) \\<Longrightarrow>\n  rsquarefree (smult ?s ?p) = rsquarefree ?p\n\ngoal (1 subgoal):\n 1. rsquarefree (smult (inverse (lead_coeff p)) p)", "by (metis inverse_eq_imp_eq inverse_zero leading_coeff_neq_0 rsquarefree_0)"], ["proof (state)\nthis:\n  rsquarefree pp\n\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "from card_proots_within_rsquarefree[OF this]"], ["proof (chain)\npicking this:\n  proots_count pp ?s = card (proots_within pp ?s)", "have \"proots_count pp {x. Im x = 0} = card (proots_within pp {x. Im x = 0})\""], ["proof (prove)\nusing this:\n  proots_count pp ?s = card (proots_within pp ?s)\n\ngoal (1 subgoal):\n 1. proots_count pp {x. Im x = 0} = card (proots_within pp {x. Im x = 0})", "by simp"], ["proof (state)\nthis:\n  proots_count pp {x. Im x = 0} = card (proots_within pp {x. Im x = 0})\n\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "also"], ["proof (state)\nthis:\n  proots_count pp {x. Im x = 0} = card (proots_within pp {x. Im x = 0})\n\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "have \"... = card (proots_within pp (unbounded_line 0 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within pp {x. Im x = 0}) =\n    card (proots_within pp (unbounded_line 0 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within pp {x. Im x = 0}) =\n    card (proots_within pp (unbounded_line 0 1))", "have \"{x. Im x = 0} = unbounded_line 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. Im x = 0} = unbounded_line 0 1", "unfolding unbounded_line_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. Im x = 0} = {x. \\<exists>u. x = (1 - u) *\\<^sub>R 0 + u *\\<^sub>R 1}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. Im x = 0 \\<Longrightarrow> \\<exists>u. x = u *\\<^sub>R 1", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x = 0 \\<Longrightarrow> \\<exists>u. x = u *\\<^sub>R 1", "apply (rule_tac x=\"Re x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x = 0 \\<Longrightarrow> x = Re x *\\<^sub>R 1", "by (metis complex_is_Real_iff of_real_Re of_real_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {x. Im x = 0} = unbounded_line 0 1\n\ngoal (1 subgoal):\n 1. card (proots_within pp {x. Im x = 0}) =\n    card (proots_within pp (unbounded_line 0 1))", "then"], ["proof (chain)\npicking this:\n  {x. Im x = 0} = unbounded_line 0 1", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. Im x = 0} = unbounded_line 0 1\n\ngoal (1 subgoal):\n 1. card (proots_within pp {x. Im x = 0}) =\n    card (proots_within pp (unbounded_line 0 1))", "by simp"], ["proof (state)\nthis:\n  card (proots_within pp {x. Im x = 0}) =\n  card (proots_within pp (unbounded_line 0 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (proots_within pp {x. Im x = 0}) =\n  card (proots_within pp (unbounded_line 0 1))\n\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "also"], ["proof (state)\nthis:\n  card (proots_within pp {x. Im x = 0}) =\n  card (proots_within pp (unbounded_line 0 1))\n\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "have \"... = changes_R_smods g (pderiv g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (proots_within pp (unbounded_line 0 1))) =\n    changes_R_smods g (pderiv g)", "unfolding card_proots_unbounded_line[of 0 1 pp,simplified,folded pI_def pR_def] g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (let g = gcd pR pI in nat (changes_R_smods g (pderiv g))) =\n    changes_R_smods (gcd pR pI) (pderiv (gcd pR pI))", "by (auto simp add:Let_def sturm_R[symmetric])"], ["proof (state)\nthis:\n  int (card (proots_within pp (unbounded_line 0 1))) =\n  changes_R_smods g (pderiv g)\n\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "finally"], ["proof (chain)\npicking this:\n  int (proots_count pp {x. Im x = 0}) = changes_R_smods g (pderiv g)", "have \"proots_count pp {x. Im x = 0} = changes_R_smods g (pderiv g)\""], ["proof (prove)\nusing this:\n  int (proots_count pp {x. Im x = 0}) = changes_R_smods g (pderiv g)\n\ngoal (1 subgoal):\n 1. int (proots_count pp {x. Im x = 0}) = changes_R_smods g (pderiv g)", "."], ["proof (state)\nthis:\n  int (proots_count pp {x. Im x = 0}) = changes_R_smods g (pderiv g)\n\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "moreover"], ["proof (state)\nthis:\n  int (proots_count pp {x. Im x = 0}) = changes_R_smods g (pderiv g)\n\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "have \"degree pp \\<ge> proots_count pp {x. Im x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count pp {x. Im x = 0} \\<le> degree pp", "by (metis \\<open>rsquarefree pp\\<close> proots_count_leq_degree rsquarefree_0)"], ["proof (state)\nthis:\n  proots_count pp {x. Im x = 0} \\<le> degree pp\n\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "ultimately"], ["proof (chain)\npicking this:\n  int (proots_count pp {x. Im x = 0}) = changes_R_smods g (pderiv g)\n  proots_count pp {x. Im x = 0} \\<le> degree pp", "show ?thesis"], ["proof (prove)\nusing this:\n  int (proots_count pp {x. Im x = 0}) = changes_R_smods g (pderiv g)\n  proots_count pp {x. Im x = 0} \\<le> degree pp\n\ngoal (1 subgoal):\n 1. (int (degree pp - proots_count pp {x. Im x = 0}) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2", "by auto"], ["proof (state)\nthis:\n  (int (degree pp - proots_count pp {x. Im x = 0}) -\n   cindex_poly_ubd pI pR) div\n  2 =\n  (int (degree pp) - changes_R_smods g (pderiv g) -\n   cindex_poly_ubd pI pR) div\n  2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (int (degree pp - proots_count pp {x. Im x = 0}) -\n   cindex_poly_ubd pI pR) div\n  2 =\n  (int (degree pp) - changes_R_smods g (pderiv g) -\n   cindex_poly_ubd pI pR) div\n  2\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "also"], ["proof (state)\nthis:\n  (int (degree pp - proots_count pp {x. Im x = 0}) -\n   cindex_poly_ubd pI pR) div\n  2 =\n  (int (degree pp) - changes_R_smods g (pderiv g) -\n   cindex_poly_ubd pI pR) div\n  2\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "have \"... = (degree p - changes_R_smods g (pderiv g) \n                        - changes_R_smods pR pI) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree p) - changes_R_smods g (pderiv g) -\n     changes_R_smods pR pI) div\n    2", "using cindex_poly_ubd_code"], ["proof (prove)\nusing this:\n  cindex_poly_ubd ?q ?p = changes_R_smods ?p ?q\n\ngoal (1 subgoal):\n 1. (int (degree pp) - changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree p) - changes_R_smods g (pderiv g) -\n     changes_R_smods pR pI) div\n    2", "unfolding pp_def"], ["proof (prove)\nusing this:\n  cindex_poly_ubd ?q ?p = changes_R_smods ?p ?q\n\ngoal (1 subgoal):\n 1. (int (degree (smult (inverse (lead_coeff p)) p)) -\n     changes_R_smods g (pderiv g) -\n     cindex_poly_ubd pI pR) div\n    2 =\n    (int (degree p) - changes_R_smods g (pderiv g) -\n     changes_R_smods pR pI) div\n    2", "by simp"], ["proof (state)\nthis:\n  (int (degree pp) - changes_R_smods g (pderiv g) -\n   cindex_poly_ubd pI pR) div\n  2 =\n  (int (degree p) - changes_R_smods g (pderiv g) -\n   changes_R_smods pR pI) div\n  2\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "finally"], ["proof (chain)\npicking this:\n  int (card (proots_within p {x. 0 < Im x})) =\n  (int (degree p) - changes_R_smods g (pderiv g) -\n   changes_R_smods pR pI) div\n  2", "have \"card (proots_within p {x. 0 < Im x}) = (degree p - changes_R_smods g (pderiv g) -\n                  changes_R_smods pR pI) div 2\""], ["proof (prove)\nusing this:\n  int (card (proots_within p {x. 0 < Im x})) =\n  (int (degree p) - changes_R_smods g (pderiv g) -\n   changes_R_smods pR pI) div\n  2\n\ngoal (1 subgoal):\n 1. int (card (proots_within p {x. 0 < Im x})) =\n    (int (degree p) - changes_R_smods g (pderiv g) -\n     changes_R_smods pR pI) div\n    2", "."], ["proof (state)\nthis:\n  int (card (proots_within p {x. 0 < Im x})) =\n  (int (degree p) - changes_R_smods g (pderiv g) -\n   changes_R_smods pR pI) div\n  2\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "then"], ["proof (chain)\npicking this:\n  int (card (proots_within p {x. 0 < Im x})) =\n  (int (degree p) - changes_R_smods g (pderiv g) -\n   changes_R_smods pR pI) div\n  2", "show ?thesis"], ["proof (prove)\nusing this:\n  int (card (proots_within p {x. 0 < Im x})) =\n  (int (degree p) - changes_R_smods g (pderiv g) -\n   changes_R_smods pR pI) div\n  2\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n         pR = map_poly Re pp; g = gcd pR pI\n     in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n              changes_R_smods pR pI) div\n             2))", "unfolding Let_def"], ["proof (prove)\nusing this:\n  int (card (proots_within p {x. 0 < Im x})) =\n  (int (degree p) - changes_R_smods g (pderiv g) -\n   changes_R_smods pR pI) div\n  2\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    nat ((int (degree p) -\n          changes_R_smods\n           (gcd (map_poly Re (smult (inverse (lead_coeff p)) p))\n             (map_poly Im (smult (inverse (lead_coeff p)) p)))\n           (pderiv\n             (gcd (map_poly Re (smult (inverse (lead_coeff p)) p))\n               (map_poly Im (smult (inverse (lead_coeff p)) p)))) -\n          changes_R_smods (map_poly Re (smult (inverse (lead_coeff p)) p))\n           (map_poly Im (smult (inverse (lead_coeff p)) p))) div\n         2)", "apply (fold pp_def pR_def pI_def g_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (proots_within p {x. 0 < Im x})) =\n    (int (degree p) - changes_R_smods g (pderiv g) -\n     changes_R_smods pR pI) div\n    2 \\<Longrightarrow>\n    card (proots_within p {x. 0 < Im x}) =\n    nat ((int (degree p) - changes_R_smods g (pderiv g) -\n          changes_R_smods pR pI) div\n         2)", "by (simp add: pp_def)"], ["proof (state)\nthis:\n  card (proots_within p {x. 0 < Im x}) =\n  (let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n       pR = map_poly Re pp; g = gcd pR pI\n   in nat ((int (degree p) - changes_R_smods g (pderiv g) -\n            changes_R_smods pR pI) div\n           2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_upper_code1[code]:\n  \"proots_upper p = \n    (if p \\<noteq> 0 then\n       (let pp=smult (inverse (lead_coeff p)) p;\n            pI=map_poly Im pp;\n            pR=map_poly Re pp;\n            g = gcd pI pR\n        in\n            nat ((degree p - nat (changes_R_smods_ext g (pderiv g)) - changes_R_smods pR pI) div 2) \n        )\n    else \n      Code.abort (STR ''proots_upper fails when p=0.'') (\\<lambda>_. proots_upper p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "define pp where \"pp = smult (inverse (lead_coeff p)) p\""], ["proof (state)\nthis:\n  pp = smult (inverse (lead_coeff p)) p\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "define pI where \"pI = map_poly Im pp\""], ["proof (state)\nthis:\n  pI = map_poly Im pp\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "define pR where \"pR=map_poly Re pp\""], ["proof (state)\nthis:\n  pR = map_poly Re pp\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "define g where  \"g = gcd pI pR\""], ["proof (state)\nthis:\n  g = gcd pI pR\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "have ?thesis when \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "using that"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "by auto"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow>\n  proots_upper p =\n  (if p \\<noteq> 0\n   then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n            pR = map_poly Re pp; g = gcd pI pR\n        in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                 changes_R_smods pR pI) div\n                2)\n   else Code.abort STR ''proots_upper fails when p=0.''\n         (\\<lambda>_. proots_upper p))\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow>\n  proots_upper p =\n  (if p \\<noteq> 0\n   then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n            pR = map_poly Re pp; g = gcd pI pR\n        in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                 changes_R_smods pR pI) div\n                2)\n   else Code.abort STR ''proots_upper fails when p=0.''\n         (\\<lambda>_. proots_upper p))\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "have ?thesis when \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "have \"pp\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp \\<noteq> 0", "unfolding pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (inverse (lead_coeff p)) p \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smult (inverse (lead_coeff p)) p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  pp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "define rr where \"rr=int (degree pp - proots_count pp {x. Im x = 0}) - cindex_poly_ubd pI pR\""], ["proof (state)\nthis:\n  rr =\n  int (degree pp - proots_count pp {x. Im x = 0}) - cindex_poly_ubd pI pR\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "have \"lead_coeff p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff p \\<noteq> 0", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff p \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  lead_coeff p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "then"], ["proof (chain)\npicking this:\n  lead_coeff p \\<noteq> 0", "have \"proots_upper pp = rr / 2\""], ["proof (prove)\nusing this:\n  lead_coeff p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real (proots_upper pp) = real_of_int rr / 2", "unfolding rr_def"], ["proof (prove)\nusing this:\n  lead_coeff p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real (proots_upper pp) =\n    real_of_int\n     (int (degree pp - proots_count pp {x. Im x = 0}) -\n      cindex_poly_ubd pI pR) /\n    2", "apply (rule_tac proots_upper_cindex_eq'[of pp, folded pI_def pR_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff p \\<noteq> 0 \\<Longrightarrow> lead_coeff pp = 1", "unfolding pp_def lead_coeff_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff p \\<noteq> 0 \\<Longrightarrow>\n    inverse (lead_coeff p) * lead_coeff p = 1", "by auto"], ["proof (state)\nthis:\n  real (proots_upper pp) = real_of_int rr / 2\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "then"], ["proof (chain)\npicking this:\n  real (proots_upper pp) = real_of_int rr / 2", "have \"proots_upper pp = nat (rr div 2)\""], ["proof (prove)\nusing this:\n  real (proots_upper pp) = real_of_int rr / 2\n\ngoal (1 subgoal):\n 1. proots_upper pp = nat (rr div 2)", "by linarith"], ["proof (state)\nthis:\n  proots_upper pp = nat (rr div 2)\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "moreover"], ["proof (state)\nthis:\n  proots_upper pp = nat (rr div 2)\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "have\n      \"rr = degree p - nat (changes_R_smods_ext g (pderiv g)) - changes_R_smods pR pI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rr =\n    int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n    changes_R_smods pR pI", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rr =\n    int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n    changes_R_smods pR pI", "have \"degree pp = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree pp = degree p", "unfolding pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (smult (inverse (lead_coeff p)) p) = degree p", "by auto"], ["proof (state)\nthis:\n  degree pp = degree p\n\ngoal (1 subgoal):\n 1. rr =\n    int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n    changes_R_smods pR pI", "moreover"], ["proof (state)\nthis:\n  degree pp = degree p\n\ngoal (1 subgoal):\n 1. rr =\n    int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n    changes_R_smods pR pI", "have \"proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))", "have \"{x. Im x = 0} = unbounded_line 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. Im x = 0} = unbounded_line 0 1", "unfolding unbounded_line_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. Im x = 0} = {x. \\<exists>u. x = (1 - u) *\\<^sub>R 0 + u *\\<^sub>R 1}", "by (simp add: complex_eq_iff)"], ["proof (state)\nthis:\n  {x. Im x = 0} = unbounded_line 0 1\n\ngoal (1 subgoal):\n 1. proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))", "then"], ["proof (chain)\npicking this:\n  {x. Im x = 0} = unbounded_line 0 1", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. Im x = 0} = unbounded_line 0 1\n\ngoal (1 subgoal):\n 1. proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))", "using proots_unbounded_line[of 0 1 pp,simplified, folded pI_def pR_def] \\<open>pp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  {x. Im x = 0} = unbounded_line 0 1\n  pp \\<noteq> 0 \\<Longrightarrow>\n  proots_count pp (unbounded_line 0 1) =\n  (let g = gcd pR pI in nat (changes_R_smods_ext g (pderiv g)))\n  pp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))", "by (auto simp:Let_def g_def gcd.commute)"], ["proof (state)\nthis:\n  proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))\n\ngoal (1 subgoal):\n 1. rr =\n    int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n    changes_R_smods pR pI", "moreover"], ["proof (state)\nthis:\n  proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))\n\ngoal (1 subgoal):\n 1. rr =\n    int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n    changes_R_smods pR pI", "have \"cindex_poly_ubd pI pR = changes_R_smods pR pI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindex_poly_ubd pI pR = changes_R_smods pR pI", "using cindex_poly_ubd_code"], ["proof (prove)\nusing this:\n  cindex_poly_ubd ?q ?p = changes_R_smods ?p ?q\n\ngoal (1 subgoal):\n 1. cindex_poly_ubd pI pR = changes_R_smods pR pI", "by auto"], ["proof (state)\nthis:\n  cindex_poly_ubd pI pR = changes_R_smods pR pI\n\ngoal (1 subgoal):\n 1. rr =\n    int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n    changes_R_smods pR pI", "ultimately"], ["proof (chain)\npicking this:\n  degree pp = degree p\n  proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))\n  cindex_poly_ubd pI pR = changes_R_smods pR pI", "show ?thesis"], ["proof (prove)\nusing this:\n  degree pp = degree p\n  proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))\n  cindex_poly_ubd pI pR = changes_R_smods pR pI\n\ngoal (1 subgoal):\n 1. rr =\n    int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n    changes_R_smods pR pI", "unfolding rr_def"], ["proof (prove)\nusing this:\n  degree pp = degree p\n  proots_count pp {x. Im x = 0} = nat (changes_R_smods_ext g (pderiv g))\n  cindex_poly_ubd pI pR = changes_R_smods pR pI\n\ngoal (1 subgoal):\n 1. int (degree pp - proots_count pp {x. Im x = 0}) -\n    cindex_poly_ubd pI pR =\n    int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n    changes_R_smods pR pI", "by auto"], ["proof (state)\nthis:\n  rr =\n  int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n  changes_R_smods pR pI\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rr =\n  int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n  changes_R_smods pR pI\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "moreover"], ["proof (state)\nthis:\n  rr =\n  int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n  changes_R_smods pR pI\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "have \"proots_upper pp = proots_upper p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_upper pp = proots_upper p", "unfolding pp_def proots_upper_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (smult (inverse (lead_coeff p)) p) {z. 0 < Im z} =\n    proots_count p {z. 0 < Im z}", "apply (subst proots_count_smult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inverse (lead_coeff p) \\<noteq> 0\n 2. proots_count p {z. 0 < Im z} = proots_count p {z. 0 < Im z}", "using that"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. inverse (lead_coeff p) \\<noteq> 0\n 2. proots_count p {z. 0 < Im z} = proots_count p {z. 0 < Im z}", "by auto"], ["proof (state)\nthis:\n  proots_upper pp = proots_upper p\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "ultimately"], ["proof (chain)\npicking this:\n  proots_upper pp = nat (rr div 2)\n  rr =\n  int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n  changes_R_smods pR pI\n  proots_upper pp = proots_upper p", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_upper pp = nat (rr div 2)\n  rr =\n  int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n  changes_R_smods pR pI\n  proots_upper pp = proots_upper p\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "unfolding Let_def"], ["proof (prove)\nusing this:\n  proots_upper pp = nat (rr div 2)\n  rr =\n  int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n  changes_R_smods pR pI\n  proots_upper pp = proots_upper p\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then nat ((int (degree p -\n                     nat (changes_R_smods_ext\n                           (gcd (map_poly Im\n                                  (smult (inverse (lead_coeff p)) p))\n                             (map_poly Re\n                               (smult (inverse (lead_coeff p)) p)))\n                           (pderiv\n                             (gcd (map_poly Im\n                                    (smult (inverse (lead_coeff p)) p))\n                               (map_poly Re\n                                 (smult (inverse (lead_coeff p)) p)))))) -\n                changes_R_smods\n                 (map_poly Re (smult (inverse (lead_coeff p)) p))\n                 (map_poly Im (smult (inverse (lead_coeff p)) p))) div\n               2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "using that"], ["proof (prove)\nusing this:\n  proots_upper pp = nat (rr div 2)\n  rr =\n  int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n  changes_R_smods pR pI\n  proots_upper pp = proots_upper p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then nat ((int (degree p -\n                     nat (changes_R_smods_ext\n                           (gcd (map_poly Im\n                                  (smult (inverse (lead_coeff p)) p))\n                             (map_poly Re\n                               (smult (inverse (lead_coeff p)) p)))\n                           (pderiv\n                             (gcd (map_poly Im\n                                    (smult (inverse (lead_coeff p)) p))\n                               (map_poly Re\n                                 (smult (inverse (lead_coeff p)) p)))))) -\n                changes_R_smods\n                 (map_poly Re (smult (inverse (lead_coeff p)) p))\n                 (map_poly Im (smult (inverse (lead_coeff p)) p))) div\n               2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "apply (fold pp_def pI_def pR_def g_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proots_upper pp = nat (rr div 2);\n     rr =\n     int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n     changes_R_smods pR pI;\n     proots_upper pp = proots_upper p; p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> proots_upper p =\n                      (if p \\<noteq> 0\n                       then nat ((int (degree p -\n nat (changes_R_smods_ext g (pderiv g))) -\n                                  changes_R_smods pR pI) div\n                                 2)\n                       else Code.abort STR ''proots_upper fails when p=0.''\n                             (\\<lambda>_. proots_upper p))", "by argo"], ["proof (state)\nthis:\n  proots_upper p =\n  (if p \\<noteq> 0\n   then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n            pR = map_poly Re pp; g = gcd pI pR\n        in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                 changes_R_smods pR pI) div\n                2)\n   else Code.abort STR ''proots_upper fails when p=0.''\n         (\\<lambda>_. proots_upper p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  proots_upper p =\n  (if p \\<noteq> 0\n   then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n            pR = map_poly Re pp; g = gcd pI pR\n        in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                 changes_R_smods pR pI) div\n                2)\n   else Code.abort STR ''proots_upper fails when p=0.''\n         (\\<lambda>_. proots_upper p))\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<Longrightarrow>\n  proots_upper p =\n  (if p \\<noteq> 0\n   then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n            pR = map_poly Re pp; g = gcd pI pR\n        in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                 changes_R_smods pR pI) div\n                2)\n   else Code.abort STR ''proots_upper fails when p=0.''\n         (\\<lambda>_. proots_upper p))\n  p \\<noteq> 0 \\<Longrightarrow>\n  proots_upper p =\n  (if p \\<noteq> 0\n   then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n            pR = map_poly Re pp; g = gcd pI pR\n        in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                 changes_R_smods pR pI) div\n                2)\n   else Code.abort STR ''proots_upper fails when p=0.''\n         (\\<lambda>_. proots_upper p))", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<Longrightarrow>\n  proots_upper p =\n  (if p \\<noteq> 0\n   then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n            pR = map_poly Re pp; g = gcd pI pR\n        in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                 changes_R_smods pR pI) div\n                2)\n   else Code.abort STR ''proots_upper fails when p=0.''\n         (\\<lambda>_. proots_upper p))\n  p \\<noteq> 0 \\<Longrightarrow>\n  proots_upper p =\n  (if p \\<noteq> 0\n   then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n            pR = map_poly Re pp; g = gcd pI pR\n        in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                 changes_R_smods pR pI) div\n                2)\n   else Code.abort STR ''proots_upper fails when p=0.''\n         (\\<lambda>_. proots_upper p))\n\ngoal (1 subgoal):\n 1. proots_upper p =\n    (if p \\<noteq> 0\n     then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pI pR\n          in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                   changes_R_smods pR pI) div\n                  2)\n     else Code.abort STR ''proots_upper fails when p=0.''\n           (\\<lambda>_. proots_upper p))", "by blast"], ["proof (state)\nthis:\n  proots_upper p =\n  (if p \\<noteq> 0\n   then let pp = smult (inverse (lead_coeff p)) p; pI = map_poly Im pp;\n            pR = map_poly Re pp; g = gcd pI pR\n        in nat ((int (degree p - nat (changes_R_smods_ext g (pderiv g))) -\n                 changes_R_smods pR pI) div\n                2)\n   else Code.abort STR ''proots_upper fails when p=0.''\n         (\\<lambda>_. proots_upper p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_upper_card_code[code]:\n  \"proots_upper_card p = (if p=0 then 0 else\n      (let\n            pf = p div (gcd p (pderiv p));\n            pp = smult (inverse (lead_coeff pf)) pf;\n            pI = map_poly Im pp;\n            pR = map_poly Re pp;\n            g = gcd pR pI\n        in\n            nat ((degree pf - changes_R_smods g (pderiv g) - changes_R_smods pR pI) div 2)  \n      ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "unfolding proots_upper_card_def"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "using infinite_halfspace_Im_gt"], ["proof (prove)\nusing this:\n  p = 0\n  infinite {x. ?b < Im x}\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "by auto"], ["proof (state)\nthis:\n  proots_upper_card p =\n  (if p = 0 then 0\n   else let pf = p div gcd p (pderiv p);\n            pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n            pR = map_poly Re pp; g = gcd pR pI\n        in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                 changes_R_smods pR pI) div\n                2))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "define pf pp pI pR g where \n        \"pf = p div (gcd p (pderiv p))\"\n    and \"pp = smult (inverse (lead_coeff pf)) pf\"\n    and \"pI = map_poly Im pp\"\n    and \"pR = map_poly Re pp\"\n    and \"g = gcd pR pI\""], ["proof (state)\nthis:\n  pf = p div gcd p (pderiv p)\n  pp = smult (inverse (lead_coeff pf)) pf\n  pI = map_poly Im pp\n  pR = map_poly Re pp\n  g = gcd pR pI\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "have \"proots_upper_card p = proots_upper_card pf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_upper_card p = proots_upper_card pf", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_upper_card p = proots_upper_card pf", "have \"proots_within p {x. 0 < Im x} = proots_within pf {x. 0 < Im x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p {x. 0 < Im x} = proots_within pf {x. 0 < Im x}", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> {x. 0 < Im x}. poly p x = 0} =\n    {x \\<in> {x. 0 < Im x}. poly pf x = 0}", "using poly_gcd_pderiv_iff[of p,folded pf_def]"], ["proof (prove)\nusing this:\n  (poly pf ?x = 0) = (poly p ?x = 0)\n\ngoal (1 subgoal):\n 1. {x \\<in> {x. 0 < Im x}. poly p x = 0} =\n    {x \\<in> {x. 0 < Im x}. poly pf x = 0}", "by auto"], ["proof (state)\nthis:\n  proots_within p {x. 0 < Im x} = proots_within pf {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. proots_upper_card p = proots_upper_card pf", "then"], ["proof (chain)\npicking this:\n  proots_within p {x. 0 < Im x} = proots_within pf {x. 0 < Im x}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within p {x. 0 < Im x} = proots_within pf {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. proots_upper_card p = proots_upper_card pf", "unfolding proots_upper_card_def"], ["proof (prove)\nusing this:\n  proots_within p {x. 0 < Im x} = proots_within pf {x. 0 < Im x}\n\ngoal (1 subgoal):\n 1. card (proots_within p {x. 0 < Im x}) =\n    card (proots_within pf {x. 0 < Im x})", "by auto"], ["proof (state)\nthis:\n  proots_upper_card p = proots_upper_card pf\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_upper_card p = proots_upper_card pf\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "also"], ["proof (state)\nthis:\n  proots_upper_card p = proots_upper_card pf\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "have \"... = nat ((degree pf - changes_R_smods g (pderiv g) - changes_R_smods pR pI) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_upper_card pf =\n    nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n          changes_R_smods pR pI) div\n         2)", "using proots_within_upper_squarefree[OF rsquarefree_gcd_pderiv[OF \\<open>p\\<noteq>0\\<close>]\n        ,unfolded Let_def,folded pf_def,folded pp_def pI_def pR_def g_def]"], ["proof (prove)\nusing this:\n  card (proots_within pf {x. 0 < Im x}) =\n  nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n        changes_R_smods pR pI) div\n       2)\n\ngoal (1 subgoal):\n 1. proots_upper_card pf =\n    nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n          changes_R_smods pR pI) div\n         2)", "unfolding proots_upper_card_def"], ["proof (prove)\nusing this:\n  card (proots_within pf {x. 0 < Im x}) =\n  nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n        changes_R_smods pR pI) div\n       2)\n\ngoal (1 subgoal):\n 1. card (proots_within pf {x. 0 < Im x}) =\n    nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n          changes_R_smods pR pI) div\n         2)", "by blast"], ["proof (state)\nthis:\n  proots_upper_card pf =\n  nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n        changes_R_smods pR pI) div\n       2)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "finally"], ["proof (chain)\npicking this:\n  proots_upper_card p =\n  nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n        changes_R_smods pR pI) div\n       2)", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_upper_card p =\n  nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n        changes_R_smods pR pI) div\n       2)\n\ngoal (1 subgoal):\n 1. proots_upper_card p =\n    (if p = 0 then 0\n     else let pf = p div gcd p (pderiv p);\n              pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n              pR = map_poly Re pp; g = gcd pR pI\n          in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2))", "unfolding Let_def"], ["proof (prove)\nusing this:\n  proots_upper_card p =\n  nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n        changes_R_smods pR pI) div\n       2)\n\ngoal (1 subgoal):\n 1. proots_upper_card p =\n    (if p = 0 then 0\n     else nat ((int (degree (p div gcd p (pderiv p))) -\n                changes_R_smods\n                 (gcd (map_poly Re\n                        (smult\n                          (inverse (lead_coeff (p div gcd p (pderiv p))))\n                          (p div gcd p (pderiv p))))\n                   (map_poly Im\n                     (smult (inverse (lead_coeff (p div gcd p (pderiv p))))\n                       (p div gcd p (pderiv p)))))\n                 (pderiv\n                   (gcd (map_poly Re\n                          (smult\n                            (inverse (lead_coeff (p div gcd p (pderiv p))))\n                            (p div gcd p (pderiv p))))\n                     (map_poly Im\n                       (smult\n                         (inverse (lead_coeff (p div gcd p (pderiv p))))\n                         (p div gcd p (pderiv p)))))) -\n                changes_R_smods\n                 (map_poly Re\n                   (smult (inverse (lead_coeff (p div gcd p (pderiv p))))\n                     (p div gcd p (pderiv p))))\n                 (map_poly Im\n                   (smult (inverse (lead_coeff (p div gcd p (pderiv p))))\n                     (p div gcd p (pderiv p))))) div\n               2))", "apply (fold pf_def,fold pp_def pI_def pR_def g_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proots_upper_card p =\n             nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2);\n     proots_upper_card p =\n     nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n           changes_R_smods pR pI) div\n          2)\\<rbrakk>\n    \\<Longrightarrow> proots_upper_card p =\n                      (if p = 0 then 0\n                       else nat ((int (degree pf) -\n                                  changes_R_smods g (pderiv g) -\n                                  changes_R_smods pR pI) div\n                                 2))", "using False"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>proots_upper_card p =\n             nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                   changes_R_smods pR pI) div\n                  2);\n     proots_upper_card p =\n     nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n           changes_R_smods pR pI) div\n          2)\\<rbrakk>\n    \\<Longrightarrow> proots_upper_card p =\n                      (if p = 0 then 0\n                       else nat ((int (degree pf) -\n                                  changes_R_smods g (pderiv g) -\n                                  changes_R_smods pR pI) div\n                                 2))", "by auto"], ["proof (state)\nthis:\n  proots_upper_card p =\n  (if p = 0 then 0\n   else let pf = p div gcd p (pderiv p);\n            pp = smult (inverse (lead_coeff pf)) pf; pI = map_poly Im pp;\n            pR = map_poly Re pp; g = gcd pR pI\n        in nat ((int (degree pf) - changes_R_smods g (pderiv g) -\n                 changes_R_smods pR pI) div\n                2))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Polynomial roots on a general half-plane\\<close>"], ["", "text \\<open>the number of roots of polynomial @{term p}, counted with multiplicity,\n   on the left half plane of the vector @{term \"b-a\"}.\\<close>"], ["", "definition proots_half ::\"complex poly \\<Rightarrow> complex \\<Rightarrow> complex \\<Rightarrow> nat\" where\n  \"proots_half p a b = proots_count p {w. Im ((w-a) / (b-a)) > 0}\""], ["", "lemma proots_half_empty:\n  assumes \"a=b\"\n  shows \"proots_half p a b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_half p a b = 0", "unfolding proots_half_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {w. 0 < Im ((w - a) / (b - a))} = 0", "using assms"], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. proots_count p {w. 0 < Im ((w - a) / (b - a))} = 0", "by auto"], ["", "(*TODO: the proof can potentially simplified with some conformal properties.*)"], ["", "lemma proots_half_proots_upper:\n  assumes \"a\\<noteq>b\" \"p\\<noteq>0\"\n  shows \"proots_half p a b= proots_upper (pcompose p [:a, (b-a):])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_half p a b = proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_half p a b = proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])", "define q where \"q=[:a, (b - a):]\""], ["proof (state)\nthis:\n  q = [:a, b - a:]\n\ngoal (1 subgoal):\n 1. proots_half p a b = proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])", "define f where \"f=(\\<lambda>x. (b-a)*x+ a)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. (b - a) * x + a)\n\ngoal (1 subgoal):\n 1. proots_half p a b = proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])", "have \"(\\<Sum>r\\<in>proots_within p {w. Im ((w-a) / (b-a)) > 0}. order r p) \n      = (\\<Sum>r\\<in>proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}. order r (p \\<circ>\\<^sub>pq))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p {w. 0 < Im ((w - a) / (b - a))}.\n       order r p) =\n    (\\<Sum>r\\<in>proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}.\n       order r (p \\<circ>\\<^sub>p q))", "proof (rule sum.reindex_cong[of f])"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on f (proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z})\n 2. proots_within p {w. 0 < Im ((w - a) / (b - a))} =\n    f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 3. \\<And>x.\n       x \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                {z. 0 < Im z} \\<Longrightarrow>\n       order (f x) p = order x (p \\<circ>\\<^sub>p q)", "have \"inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inj f", "unfolding f_def inj_on_def"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          (b - a) * x + a = (b - a) * y + a \\<longrightarrow> x = y", "by fastforce"], ["proof (state)\nthis:\n  inj f\n\ngoal (3 subgoals):\n 1. inj_on f (proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z})\n 2. proots_within p {w. 0 < Im ((w - a) / (b - a))} =\n    f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 3. \\<And>x.\n       x \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                {z. 0 < Im z} \\<Longrightarrow>\n       order (f x) p = order x (p \\<circ>\\<^sub>p q)", "then"], ["proof (chain)\npicking this:\n  inj f", "show \"inj_on f (proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z})\""], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. inj_on f (proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z})", "by (elim inj_on_subset,auto)"], ["proof (state)\nthis:\n  inj_on f (proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z})\n\ngoal (2 subgoals):\n 1. proots_within p {w. 0 < Im ((w - a) / (b - a))} =\n    f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. \\<And>x.\n       x \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                {z. 0 < Im z} \\<Longrightarrow>\n       order (f x) p = order x (p \\<circ>\\<^sub>p q)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. proots_within p {w. 0 < Im ((w - a) / (b - a))} =\n    f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. \\<And>x.\n       x \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                {z. 0 < Im z} \\<Longrightarrow>\n       order (f x) p = order x (p \\<circ>\\<^sub>p q)", "show \"proots_within p {w. Im ((w-a) / (b-a)) > 0} = f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p {w. 0 < Im ((w - a) / (b - a))} =\n    f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> proots_within p\n                {w. 0 < Im ((w - a) / (b - a))} \\<Longrightarrow>\n       x \\<in> f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> proots_within p\n                {w. 0 < Im ((w - a) / (b - a))} \\<Longrightarrow>\n       x \\<in> f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "assume x_asm:\"x \\<in> proots_within p {w. Im ((w-a) / (b-a)) > 0}\""], ["proof (state)\nthis:\n  x \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> proots_within p\n                {w. 0 < Im ((w - a) / (b - a))} \\<Longrightarrow>\n       x \\<in> f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "define xx where \"xx=(x -a) / (b - a)\""], ["proof (state)\nthis:\n  xx = (x - a) / (b - a)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> proots_within p\n                {w. 0 < Im ((w - a) / (b - a))} \\<Longrightarrow>\n       x \\<in> f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "have \"poly (p \\<circ>\\<^sub>p q) xx = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (p \\<circ>\\<^sub>p q) xx = 0", "unfolding q_def xx_def poly_pcompose"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (poly [:a, b - a:] ((x - a) / (b - a))) = 0", "using assms x_asm"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  p \\<noteq> 0\n  x \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}\n\ngoal (1 subgoal):\n 1. poly p (poly [:a, b - a:] ((x - a) / (b - a))) = 0", "by auto"], ["proof (state)\nthis:\n  poly (p \\<circ>\\<^sub>p q) xx = 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> proots_within p\n                {w. 0 < Im ((w - a) / (b - a))} \\<Longrightarrow>\n       x \\<in> f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "moreover"], ["proof (state)\nthis:\n  poly (p \\<circ>\\<^sub>p q) xx = 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> proots_within p\n                {w. 0 < Im ((w - a) / (b - a))} \\<Longrightarrow>\n       x \\<in> f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "have \"Im xx > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Im xx", "unfolding xx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Im ((x - a) / (b - a))", "using x_asm"], ["proof (prove)\nusing this:\n  x \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}\n\ngoal (1 subgoal):\n 1. 0 < Im ((x - a) / (b - a))", "by auto"], ["proof (state)\nthis:\n  0 < Im xx\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> proots_within p\n                {w. 0 < Im ((w - a) / (b - a))} \\<Longrightarrow>\n       x \\<in> f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "ultimately"], ["proof (chain)\npicking this:\n  poly (p \\<circ>\\<^sub>p q) xx = 0\n  0 < Im xx", "have \"xx \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\""], ["proof (prove)\nusing this:\n  poly (p \\<circ>\\<^sub>p q) xx = 0\n  0 < Im xx\n\ngoal (1 subgoal):\n 1. xx \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}", "by auto"], ["proof (state)\nthis:\n  xx \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> proots_within p\n                {w. 0 < Im ((w - a) / (b - a))} \\<Longrightarrow>\n       x \\<in> f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "then"], ["proof (chain)\npicking this:\n  xx \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}", "show \"x \\<in> f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\""], ["proof (prove)\nusing this:\n  xx \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n\ngoal (1 subgoal):\n 1. x \\<in> f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}", "apply (intro rev_image_eqI[of xx])"], ["proof (prove)\ngoal (2 subgoals):\n 1. xx \\<in> proots_within (p \\<circ>\\<^sub>p q)\n              {z. 0 < Im z} \\<Longrightarrow>\n    xx \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. xx \\<in> proots_within (p \\<circ>\\<^sub>p q)\n              {z. 0 < Im z} \\<Longrightarrow>\n    x = f xx", "unfolding f_def xx_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x - a) / (b - a)\n    \\<in> proots_within (p \\<circ>\\<^sub>p q)\n           {z. 0 < Im z} \\<Longrightarrow>\n    (x - a) / (b - a)\n    \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. (x - a) / (b - a)\n    \\<in> proots_within (p \\<circ>\\<^sub>p q)\n           {z. 0 < Im z} \\<Longrightarrow>\n    x = (b - a) * ((x - a) / (b - a)) + a", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. (x - a) / (b - a)\n    \\<in> proots_within (p \\<circ>\\<^sub>p q)\n           {z. 0 < Im z} \\<Longrightarrow>\n    (x - a) / (b - a)\n    \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n 2. (x - a) / (b - a)\n    \\<in> proots_within (p \\<circ>\\<^sub>p q)\n           {z. 0 < Im z} \\<Longrightarrow>\n    x = (b - a) * ((x - a) / (b - a)) + a", "by auto"], ["proof (state)\nthis:\n  x \\<in> f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "assume \"x \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\""], ["proof (state)\nthis:\n  x \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                 {z. 0 < Im z} \\<Longrightarrow>\n       f xa \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "then"], ["proof (chain)\npicking this:\n  x \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}", "show \"f x \\<in> proots_within p {w. 0 < Im ((w-a) / (b - a))}\""], ["proof (prove)\nusing this:\n  x \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n\ngoal (1 subgoal):\n 1. f x \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "unfolding f_def q_def"], ["proof (prove)\nusing this:\n  x \\<in> proots_within (p \\<circ>\\<^sub>p [:a, b - a:]) {z. 0 < Im z}\n\ngoal (1 subgoal):\n 1. (b - a) * x + a \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> proots_within (p \\<circ>\\<^sub>p [:a, b - a:]) {z. 0 < Im z}\n  a \\<noteq> b\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (b - a) * x + a \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}", "apply (auto simp add:poly_pcompose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; p \\<noteq> 0; poly p (a + x * (b - a)) = 0;\n     0 < Im x\\<rbrakk>\n    \\<Longrightarrow> poly p ((b - a) * x + a) = 0", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  f x \\<in> proots_within p {w. 0 < Im ((w - a) / (b - a))}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_within p {w. 0 < Im ((w - a) / (b - a))} =\n  f ` proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                {z. 0 < Im z} \\<Longrightarrow>\n       order (f x) p = order x (p \\<circ>\\<^sub>p q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                {z. 0 < Im z} \\<Longrightarrow>\n       order (f x) p = order x (p \\<circ>\\<^sub>p q)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                {z. 0 < Im z} \\<Longrightarrow>\n       order (f x) p = order x (p \\<circ>\\<^sub>p q)", "assume \"x \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\""], ["proof (state)\nthis:\n  x \\<in> proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within (p \\<circ>\\<^sub>p q)\n                {z. 0 < Im z} \\<Longrightarrow>\n       order (f x) p = order x (p \\<circ>\\<^sub>p q)", "show \"order (f x) p = order x (p \\<circ>\\<^sub>p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (f x) p = order x (p \\<circ>\\<^sub>p q)", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order (f x) p = order x (p \\<circ>\\<^sub>p q)", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    order (f x) 0 = order x (0 \\<circ>\\<^sub>p q)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) p = order x (p \\<circ>\\<^sub>p q)\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "case 0"], ["proof (state)\nthis:\n  0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    order (f x) 0 = order x (0 \\<circ>\\<^sub>p q)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) p = order x (p \\<circ>\\<^sub>p q)\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order (f x) 0 = order x (0 \\<circ>\\<^sub>p q)", "by simp"], ["proof (state)\nthis:\n  order (f x) 0 = order x (0 \\<circ>\\<^sub>p q)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) p = order x (p \\<circ>\\<^sub>p q)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) p = order x (p \\<circ>\\<^sub>p q)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) p = order x (p \\<circ>\\<^sub>p q)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "have \"order (f x) p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (f x) p = 0", "apply (rule order_0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (f x) \\<noteq> 0", "using no_proots"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p (f x) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  order (f x) p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) p = order x (p \\<circ>\\<^sub>p q)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "moreover"], ["proof (state)\nthis:\n  order (f x) p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) p = order x (p \\<circ>\\<^sub>p q)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "have \"order x (p \\<circ>\\<^sub>p q) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (p \\<circ>\\<^sub>p q) = 0", "apply (rule order_0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (p \\<circ>\\<^sub>p q) x \\<noteq> 0", "unfolding poly_pcompose q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (poly [:a, b - a:] x) \\<noteq> 0", "using no_proots"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p (poly [:a, b - a:] x) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  order x (p \\<circ>\\<^sub>p q) = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) p = order x (p \\<circ>\\<^sub>p q)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "ultimately"], ["proof (chain)\npicking this:\n  order (f x) p = 0\n  order x (p \\<circ>\\<^sub>p q) = 0", "show ?case"], ["proof (prove)\nusing this:\n  order (f x) p = 0\n  order x (p \\<circ>\\<^sub>p q) = 0\n\ngoal (1 subgoal):\n 1. order (f x) p = order x (p \\<circ>\\<^sub>p q)", "by auto"], ["proof (state)\nthis:\n  order (f x) p = order x (p \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "case (root c p)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  order (f x) p = order x (p \\<circ>\\<^sub>p q)\n  [:- c, 1:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "have \"order (f x) ([:- c, 1:] * p) = order (f x) [:-c,1:] + order (f x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (f x) ([:- c, 1:] * p) = order (f x) [:- c, 1:] + order (f x) p", "apply (subst order_mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [:- c, 1:] * p \\<noteq> 0\n 2. order (f x) [:- c, 1:] + order (f x) p =\n    order (f x) [:- c, 1:] + order (f x) p", "using root"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  order (f x) p = order x (p \\<circ>\\<^sub>p q)\n  [:- c, 1:] * p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. [:- c, 1:] * p \\<noteq> 0\n 2. order (f x) [:- c, 1:] + order (f x) p =\n    order (f x) [:- c, 1:] + order (f x) p", "by auto"], ["proof (state)\nthis:\n  order (f x) ([:- c, 1:] * p) = order (f x) [:- c, 1:] + order (f x) p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "also"], ["proof (state)\nthis:\n  order (f x) ([:- c, 1:] * p) = order (f x) [:- c, 1:] + order (f x) p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "have \"... =  order x ([:- c, 1:] \\<circ>\\<^sub>p q) +  order x (p \\<circ>\\<^sub>p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] + order (f x) p =\n    order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] + order (f x) p =\n    order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)", "have \"order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "proof (cases \"f x=c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f x = c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n 2. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "case True"], ["proof (state)\nthis:\n  f x = c\n\ngoal (2 subgoals):\n 1. f x = c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n 2. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "have \"[:- c, 1:] \\<circ>\\<^sub>p q = smult (b-a) [:-x,1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- c, 1:] \\<circ>\\<^sub>p q = smult (b - a) [:- x, 1:]", "using True"], ["proof (prove)\nusing this:\n  f x = c\n\ngoal (1 subgoal):\n 1. [:- c, 1:] \\<circ>\\<^sub>p q = smult (b - a) [:- x, 1:]", "unfolding q_def f_def pcompose_pCons"], ["proof (prove)\nusing this:\n  (b - a) * x + a = c\n\ngoal (1 subgoal):\n 1. [:- c:] +\n    [:a, b - a:] * ([:1:] + [:a, b - a:] * 0 \\<circ>\\<^sub>p [:a, b - a:]) =\n    smult (b - a) [:- x, 1:]", "by auto"], ["proof (state)\nthis:\n  [:- c, 1:] \\<circ>\\<^sub>p q = smult (b - a) [:- x, 1:]\n\ngoal (2 subgoals):\n 1. f x = c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n 2. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "then"], ["proof (chain)\npicking this:\n  [:- c, 1:] \\<circ>\\<^sub>p q = smult (b - a) [:- x, 1:]", "have \"order x ([:- c, 1:] \\<circ>\\<^sub>p q) = order x (smult (b-a) [:-x,1:])\""], ["proof (prove)\nusing this:\n  [:- c, 1:] \\<circ>\\<^sub>p q = smult (b - a) [:- x, 1:]\n\ngoal (1 subgoal):\n 1. order x ([:- c, 1:] \\<circ>\\<^sub>p q) =\n    order x (smult (b - a) [:- x, 1:])", "by auto"], ["proof (state)\nthis:\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) =\n  order x (smult (b - a) [:- x, 1:])\n\ngoal (2 subgoals):\n 1. f x = c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n 2. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "then"], ["proof (chain)\npicking this:\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) =\n  order x (smult (b - a) [:- x, 1:])", "have \"order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 1\""], ["proof (prove)\nusing this:\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) =\n  order x (smult (b - a) [:- x, 1:])\n\ngoal (1 subgoal):\n 1. order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 1", "apply (subst (asm) order_smult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b - a \\<noteq> 0\n 2. order x ([:- c, 1:] \\<circ>\\<^sub>p q) =\n    order x [:- x, 1:] \\<Longrightarrow>\n    order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 1", "using assms order_power_n_n[of _ 1,simplified]"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  p \\<noteq> 0\n  True\n\ngoal (2 subgoals):\n 1. b - a \\<noteq> 0\n 2. order x ([:- c, 1:] \\<circ>\\<^sub>p q) =\n    order x [:- x, 1:] \\<Longrightarrow>\n    order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 1", "by auto"], ["proof (state)\nthis:\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 1\n\ngoal (2 subgoals):\n 1. f x = c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n 2. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "moreover"], ["proof (state)\nthis:\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 1\n\ngoal (2 subgoals):\n 1. f x = c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n 2. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "have \"order (f x) [:- c, 1:] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] = 1", "using True order_power_n_n[of _ 1,simplified]"], ["proof (prove)\nusing this:\n  f x = c\n  True\n\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] = 1", "by auto"], ["proof (state)\nthis:\n  order (f x) [:- c, 1:] = 1\n\ngoal (2 subgoals):\n 1. f x = c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n 2. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "ultimately"], ["proof (chain)\npicking this:\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 1\n  order (f x) [:- c, 1:] = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 1\n  order (f x) [:- c, 1:] = 1\n\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "by auto"], ["proof (state)\nthis:\n  order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "case False"], ["proof (state)\nthis:\n  f x \\<noteq> c\n\ngoal (1 subgoal):\n 1. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "have \"order (f x) [:- c, 1:] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] = 0", "apply (rule order_0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly [:- c, 1:] (f x) \\<noteq> 0", "using False"], ["proof (prove)\nusing this:\n  f x \\<noteq> c\n\ngoal (1 subgoal):\n 1. poly [:- c, 1:] (f x) \\<noteq> 0", "unfolding f_def"], ["proof (prove)\nusing this:\n  (b - a) * x + a \\<noteq> c\n\ngoal (1 subgoal):\n 1. poly [:- c, 1:] ((b - a) * x + a) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  order (f x) [:- c, 1:] = 0\n\ngoal (1 subgoal):\n 1. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "moreover"], ["proof (state)\nthis:\n  order (f x) [:- c, 1:] = 0\n\ngoal (1 subgoal):\n 1. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "have \"order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 0", "apply (rule order_0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ([:- c, 1:] \\<circ>\\<^sub>p q) x \\<noteq> 0", "using False"], ["proof (prove)\nusing this:\n  f x \\<noteq> c\n\ngoal (1 subgoal):\n 1. poly ([:- c, 1:] \\<circ>\\<^sub>p q) x \\<noteq> 0", "unfolding f_def q_def poly_pcompose"], ["proof (prove)\nusing this:\n  (b - a) * x + a \\<noteq> c\n\ngoal (1 subgoal):\n 1. poly [:- c, 1:] (poly [:a, b - a:] x) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 0\n\ngoal (1 subgoal):\n 1. f x \\<noteq> c \\<Longrightarrow>\n    order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "ultimately"], ["proof (chain)\npicking this:\n  order (f x) [:- c, 1:] = 0\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  order (f x) [:- c, 1:] = 0\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) = 0\n\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)", "by auto"], ["proof (state)\nthis:\n  order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] + order (f x) p =\n    order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)", "moreover"], ["proof (state)\nthis:\n  order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] + order (f x) p =\n    order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)", "have \"order (f x) p = order x (p \\<circ>\\<^sub>p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (f x) p = order x (p \\<circ>\\<^sub>p q)", "apply (rule root)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using root"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  order (f x) p = order x (p \\<circ>\\<^sub>p q)\n  [:- c, 1:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  order (f x) p = order x (p \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] + order (f x) p =\n    order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)", "ultimately"], ["proof (chain)\npicking this:\n  order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n  order (f x) p = order x (p \\<circ>\\<^sub>p q)", "show ?thesis"], ["proof (prove)\nusing this:\n  order (f x) [:- c, 1:] = order x ([:- c, 1:] \\<circ>\\<^sub>p q)\n  order (f x) p = order x (p \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. order (f x) [:- c, 1:] + order (f x) p =\n    order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)", "by auto"], ["proof (state)\nthis:\n  order (f x) [:- c, 1:] + order (f x) p =\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order (f x) [:- c, 1:] + order (f x) p =\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "also"], ["proof (state)\nthis:\n  order (f x) [:- c, 1:] + order (f x) p =\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "have \"... = order x (([:- c, 1:] * p) \\<circ>\\<^sub>p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n    order x (([:- c, 1:] * p) \\<circ>\\<^sub>p q)", "unfolding pcompose_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n    order x ([:- c, 1:] \\<circ>\\<^sub>p q * p \\<circ>\\<^sub>p q)", "apply (subst order_mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [:- c, 1:] \\<circ>\\<^sub>p q * p \\<circ>\\<^sub>p q \\<noteq> 0\n 2. order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n    order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- c, 1:] \\<circ>\\<^sub>p q * p \\<circ>\\<^sub>p q \\<noteq> 0", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- c, 1:] \\<circ>\\<^sub>p [:a, b - a:] *\n    p \\<circ>\\<^sub>p [:a, b - a:] \\<noteq>\n    0", "using assms(1) pcompose_eq_0 root.prems"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  \\<lbrakk>?p \\<circ>\\<^sub>p ?q = 0; 0 < degree ?q\\<rbrakk>\n  \\<Longrightarrow> ?p = 0\n  [:- c, 1:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:- c, 1:] \\<circ>\\<^sub>p [:a, b - a:] *\n    p \\<circ>\\<^sub>p [:a, b - a:] \\<noteq>\n    0", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n    order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)", "by simp"], ["proof (state)\nthis:\n  order x ([:- c, 1:] \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n  order x (([:- c, 1:] * p) \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (f x) p = order x (p \\<circ>\\<^sub>p q);\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (f x) ([:- a, 1:] * p) =\n                         order x (([:- a, 1:] * p) \\<circ>\\<^sub>p q)", "finally"], ["proof (chain)\npicking this:\n  order (f x) ([:- c, 1:] * p) =\n  order x (([:- c, 1:] * p) \\<circ>\\<^sub>p q)", "show ?case"], ["proof (prove)\nusing this:\n  order (f x) ([:- c, 1:] * p) =\n  order x (([:- c, 1:] * p) \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. order (f x) ([:- c, 1:] * p) =\n    order x (([:- c, 1:] * p) \\<circ>\\<^sub>p q)", "."], ["proof (state)\nthis:\n  order (f x) ([:- c, 1:] * p) =\n  order x (([:- c, 1:] * p) \\<circ>\\<^sub>p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order (f x) p = order x (p \\<circ>\\<^sub>p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>proots_within p {w. 0 < Im ((w - a) / (b - a))}. order r p) =\n  (\\<Sum>r\\<in>proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}.\n     order r (p \\<circ>\\<^sub>p q))\n\ngoal (1 subgoal):\n 1. proots_half p a b = proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>r\\<in>proots_within p {w. 0 < Im ((w - a) / (b - a))}. order r p) =\n  (\\<Sum>r\\<in>proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}.\n     order r (p \\<circ>\\<^sub>p q))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>r\\<in>proots_within p {w. 0 < Im ((w - a) / (b - a))}. order r p) =\n  (\\<Sum>r\\<in>proots_within (p \\<circ>\\<^sub>p q) {z. 0 < Im z}.\n     order r (p \\<circ>\\<^sub>p q))\n\ngoal (1 subgoal):\n 1. proots_half p a b = proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])", "unfolding proots_half_def proots_upper_def proots_count_def q_def"], ["proof (prove)\nusing this:\n  (\\<Sum>r\\<in>proots_within p {w. 0 < Im ((w - a) / (b - a))}. order r p) =\n  (\\<Sum>r\\<in>proots_within (p \\<circ>\\<^sub>p [:a, b - a:]) {z. 0 < Im z}.\n     order r (p \\<circ>\\<^sub>p [:a, b - a:]))\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p {w. 0 < Im ((w - a) / (b - a))}.\n       order r p) =\n    (\\<Sum>r\\<in>proots_within (p \\<circ>\\<^sub>p [:a, b - a:])\n                  {z. 0 < Im z}.\n       order r (p \\<circ>\\<^sub>p [:a, b - a:]))", "by auto"], ["proof (state)\nthis:\n  proots_half p a b = proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_half_code1[code]:\n  \"proots_half p a b = (if a\\<noteq>b then \n                        if p\\<noteq>0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:]) \n                        else Code.abort (STR ''proots_half fails when p=0.'') \n                          (\\<lambda>_. proots_half p a b) \n                        else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "have ?thesis when \"a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "using proots_half_empty that"], ["proof (prove)\nusing this:\n  ?a = ?b \\<Longrightarrow> proots_half ?p ?a ?b = 0\n  a = b\n\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "by auto"], ["proof (state)\nthis:\n  a = b \\<Longrightarrow>\n  proots_half p a b =\n  (if a \\<noteq> b\n   then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n        else Code.abort STR ''proots_half fails when p=0.''\n              (\\<lambda>_. proots_half p a b)\n   else 0)\n\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "moreover"], ["proof (state)\nthis:\n  a = b \\<Longrightarrow>\n  proots_half p a b =\n  (if a \\<noteq> b\n   then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n        else Code.abort STR ''proots_half fails when p=0.''\n              (\\<lambda>_. proots_half p a b)\n   else 0)\n\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "have ?thesis when \"a\\<noteq>b\" \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "using that"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  p = 0\n\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> b; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_half p a b =\n                    (if a \\<noteq> b\n                     then if p \\<noteq> 0\n                          then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n                          else Code.abort\n                                STR ''proots_half fails when p=0.''\n                                (\\<lambda>_. proots_half p a b)\n                     else 0)\n\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> b; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_half p a b =\n                    (if a \\<noteq> b\n                     then if p \\<noteq> 0\n                          then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n                          else Code.abort\n                                STR ''proots_half fails when p=0.''\n                                (\\<lambda>_. proots_half p a b)\n                     else 0)\n\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "have ?thesis when \"a\\<noteq>b\" \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "using proots_half_proots_upper[OF that] that"], ["proof (prove)\nusing this:\n  proots_half p a b = proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n  a \\<noteq> b\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> b; p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proots_half p a b =\n                    (if a \\<noteq> b\n                     then if p \\<noteq> 0\n                          then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n                          else Code.abort\n                                STR ''proots_half fails when p=0.''\n                                (\\<lambda>_. proots_half p a b)\n                     else 0)\n\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "ultimately"], ["proof (chain)\npicking this:\n  a = b \\<Longrightarrow>\n  proots_half p a b =\n  (if a \\<noteq> b\n   then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n        else Code.abort STR ''proots_half fails when p=0.''\n              (\\<lambda>_. proots_half p a b)\n   else 0)\n  \\<lbrakk>a \\<noteq> b; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_half p a b =\n                    (if a \\<noteq> b\n                     then if p \\<noteq> 0\n                          then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n                          else Code.abort\n                                STR ''proots_half fails when p=0.''\n                                (\\<lambda>_. proots_half p a b)\n                     else 0)\n  \\<lbrakk>a \\<noteq> b; p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proots_half p a b =\n                    (if a \\<noteq> b\n                     then if p \\<noteq> 0\n                          then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n                          else Code.abort\n                                STR ''proots_half fails when p=0.''\n                                (\\<lambda>_. proots_half p a b)\n                     else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = b \\<Longrightarrow>\n  proots_half p a b =\n  (if a \\<noteq> b\n   then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n        else Code.abort STR ''proots_half fails when p=0.''\n              (\\<lambda>_. proots_half p a b)\n   else 0)\n  \\<lbrakk>a \\<noteq> b; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_half p a b =\n                    (if a \\<noteq> b\n                     then if p \\<noteq> 0\n                          then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n                          else Code.abort\n                                STR ''proots_half fails when p=0.''\n                                (\\<lambda>_. proots_half p a b)\n                     else 0)\n  \\<lbrakk>a \\<noteq> b; p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proots_half p a b =\n                    (if a \\<noteq> b\n                     then if p \\<noteq> 0\n                          then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n                          else Code.abort\n                                STR ''proots_half fails when p=0.''\n                                (\\<lambda>_. proots_half p a b)\n                     else 0)\n\ngoal (1 subgoal):\n 1. proots_half p a b =\n    (if a \\<noteq> b\n     then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n          else Code.abort STR ''proots_half fails when p=0.''\n                (\\<lambda>_. proots_half p a b)\n     else 0)", "by auto"], ["proof (state)\nthis:\n  proots_half p a b =\n  (if a \\<noteq> b\n   then if p \\<noteq> 0 then proots_upper (p \\<circ>\\<^sub>p [:a, b - a:])\n        else Code.abort STR ''proots_half fails when p=0.''\n              (\\<lambda>_. proots_half p a b)\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Polynomial roots within a circle (open ball)\\<close>\n\n\\<comment> \\<open>Roots counted WITH multiplicity\\<close>"], ["", "definition proots_ball::\"complex poly \\<Rightarrow> complex \\<Rightarrow> real \\<Rightarrow> nat\" where\n  \"proots_ball p z0 r = proots_count p (ball z0 r)\" \n\n\\<comment> \\<open>Roots counted WITHOUT multiplicity\\<close>"], ["", "definition proots_ball_card ::\"complex poly \\<Rightarrow> complex \\<Rightarrow> real \\<Rightarrow> nat\" where\n  \"proots_ball_card p z0 r = card (proots_within p (ball z0 r))\""], ["", "lemma proots_ball_code1[code]:\n  \"proots_ball p z0 r = ( if r \\<le> 0 then \n                              0\n                          else if p\\<noteq>0 then\n                              proots_upper (fcompose (p \\<circ>\\<^sub>p [:z0, of_real r:]) [:\\<i>,-1:] [:\\<i>,1:]) \n                          else \n                              Code.abort (STR ''proots_ball fails when p=0.'') \n                                (\\<lambda>_. proots_ball p z0 r)\n                        )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))", "proof (cases \"p=0 \\<or> r\\<le>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))\n 2. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> r \\<le> 0)\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))\n 2. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))", "have \"proots_ball p z0 r = proots_count (p \\<circ>\\<^sub>p [:z0, of_real r:]) (ball 0 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_ball p z0 r =\n    proots_count (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) (ball 0 1)", "unfolding proots_ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p (ball z0 r) =\n    proots_count (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) (ball 0 1)", "apply (rule proots_uball_eq[THEN arg_cong])"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. 0 < r", "using False"], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> r \\<le> 0)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. 0 < r", "by auto"], ["proof (state)\nthis:\n  proots_ball p z0 r =\n  proots_count (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) (ball 0 1)\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))\n 2. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))", "also"], ["proof (state)\nthis:\n  proots_ball p z0 r =\n  proots_count (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) (ball 0 1)\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))\n 2. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))", "have \"... = proots_upper (fcompose (p \\<circ>\\<^sub>p [:z0, of_real r:]) [:\\<i>,-1:] [:\\<i>,1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) (ball 0 1) =\n    proots_upper\n     (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n       [:\\<i>, 1:])", "unfolding proots_upper_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) (ball 0 1) =\n    proots_count\n     (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n       [:\\<i>, 1:])\n     {z. 0 < Im z}", "apply (rule proots_ball_plane_eq[THEN arg_cong])"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p [:z0, complex_of_real r:] \\<noteq> 0", "using False pcompose_eq_0[of p \"[:z0, of_real r:]\"]"], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> r \\<le> 0)\n  \\<lbrakk>p \\<circ>\\<^sub>p [:z0, complex_of_real r:] = 0;\n   0 < degree [:z0, complex_of_real r:]\\<rbrakk>\n  \\<Longrightarrow> p = 0\n\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p [:z0, complex_of_real r:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  proots_count (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) (ball 0 1) =\n  proots_upper\n   (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n     [:\\<i>, 1:])\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))\n 2. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))", "finally"], ["proof (chain)\npicking this:\n  proots_ball p z0 r =\n  proots_upper\n   (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n     [:\\<i>, 1:])", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_ball p z0 r =\n  proots_upper\n   (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n     [:\\<i>, 1:])\n\ngoal (1 subgoal):\n 1. proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))", "using False"], ["proof (prove)\nusing this:\n  proots_ball p z0 r =\n  proots_upper\n   (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n     [:\\<i>, 1:])\n  \\<not> (p = 0 \\<or> r \\<le> 0)\n\ngoal (1 subgoal):\n 1. proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))", "by auto"], ["proof (state)\nthis:\n  proots_ball p z0 r =\n  (if r \\<le> 0 then 0\n   else if p \\<noteq> 0\n        then proots_upper\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n        else Code.abort STR ''proots_ball fails when p=0.''\n              (\\<lambda>_. proots_ball p z0 r))\n\ngoal (1 subgoal):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball p z0 r =\n    (if r \\<le> 0 then 0\n     else if p \\<noteq> 0\n          then proots_upper\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n          else Code.abort STR ''proots_ball fails when p=0.''\n                (\\<lambda>_. proots_ball p z0 r))", "qed (auto simp:proots_ball_def ball_empty)"], ["", "lemma proots_ball_card_code1[code]:\n  \"proots_ball_card p z0 r = \n                ( if r \\<le> 0 \\<or> p=0 then \n                      0\n                 else \n                    proots_upper_card (fcompose (p \\<circ>\\<^sub>p [:z0, of_real r:]) [:\\<i>,-1:] [:\\<i>,1:]) \n                        )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "proof (cases \"p=0 \\<or> r\\<le>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))\n 2. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "case True"], ["proof (state)\nthis:\n  p = 0 \\<or> r \\<le> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))\n 2. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<or> r \\<le> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))\n 2. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "have ?thesis when \"r\\<le>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "have \"proots_within p (ball z0 r) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p (ball z0 r) = {}", "by (simp add: ball_empty that)"], ["proof (state)\nthis:\n  proots_within p (ball z0 r) = {}\n\ngoal (1 subgoal):\n 1. proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "then"], ["proof (chain)\npicking this:\n  proots_within p (ball z0 r) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within p (ball z0 r) = {}\n\ngoal (1 subgoal):\n 1. proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "unfolding proots_ball_card_def"], ["proof (prove)\nusing this:\n  proots_within p (ball z0 r) = {}\n\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "using that"], ["proof (prove)\nusing this:\n  proots_within p (ball z0 r) = {}\n  r \\<le> 0\n\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "by auto"], ["proof (state)\nthis:\n  proots_ball_card p z0 r =\n  (if r \\<le> 0 \\<or> p = 0 then 0\n   else proots_upper_card\n         (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n           [:\\<i>, - 1:] [:\\<i>, 1:]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r \\<le> 0 \\<Longrightarrow>\n  proots_ball_card p z0 r =\n  (if r \\<le> 0 \\<or> p = 0 then 0\n   else proots_upper_card\n         (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n           [:\\<i>, - 1:] [:\\<i>, 1:]))\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))\n 2. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "moreover"], ["proof (state)\nthis:\n  r \\<le> 0 \\<Longrightarrow>\n  proots_ball_card p z0 r =\n  (if r \\<le> 0 \\<or> p = 0 then 0\n   else proots_upper_card\n         (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n           [:\\<i>, - 1:] [:\\<i>, 1:]))\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))\n 2. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "have ?thesis when \"r>0\" \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "unfolding proots_ball_card_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "using that infinite_ball[of r z0]"], ["proof (prove)\nusing this:\n  0 < r\n  p = 0\n  0 < r \\<Longrightarrow> infinite (ball z0 r)\n\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < r; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_ball_card p z0 r =\n                    (if r \\<le> 0 \\<or> p = 0 then 0\n                     else proots_upper_card\n                           (fcompose\n                             (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                             [:\\<i>, - 1:] [:\\<i>, 1:]))\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> r \\<le> 0 \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))\n 2. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<or> r \\<le> 0\n  r \\<le> 0 \\<Longrightarrow>\n  proots_ball_card p z0 r =\n  (if r \\<le> 0 \\<or> p = 0 then 0\n   else proots_upper_card\n         (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n           [:\\<i>, - 1:] [:\\<i>, 1:]))\n  \\<lbrakk>0 < r; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_ball_card p z0 r =\n                    (if r \\<le> 0 \\<or> p = 0 then 0\n                     else proots_upper_card\n                           (fcompose\n                             (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                             [:\\<i>, - 1:] [:\\<i>, 1:]))", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0 \\<or> r \\<le> 0\n  r \\<le> 0 \\<Longrightarrow>\n  proots_ball_card p z0 r =\n  (if r \\<le> 0 \\<or> p = 0 then 0\n   else proots_upper_card\n         (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n           [:\\<i>, - 1:] [:\\<i>, 1:]))\n  \\<lbrakk>0 < r; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_ball_card p z0 r =\n                    (if r \\<le> 0 \\<or> p = 0 then 0\n                     else proots_upper_card\n                           (fcompose\n                             (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                             [:\\<i>, - 1:] [:\\<i>, 1:]))\n\ngoal (1 subgoal):\n 1. proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "by argo"], ["proof (state)\nthis:\n  proots_ball_card p z0 r =\n  (if r \\<le> 0 \\<or> p = 0 then 0\n   else proots_upper_card\n         (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n           [:\\<i>, - 1:] [:\\<i>, 1:]))\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> r \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "then"], ["proof (chain)\npicking this:\n  \\<not> (p = 0 \\<or> r \\<le> 0)", "have \"p\\<noteq>0\" \"r>0\""], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> r \\<le> 0)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& 0 < r", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "have \"proots_ball_card p z0 r = card (proots_within (p \\<circ>\\<^sub>p [:z0, of_real r:]) (ball 0 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_ball_card p z0 r =\n    card\n     (proots_within (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n       (ball 0 1))", "unfolding proots_ball_card_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (ball z0 r)) =\n    card\n     (proots_within (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n       (ball 0 1))", "by (rule proots_card_uball_eq[OF \\<open>r>0\\<close>, THEN arg_cong])"], ["proof (state)\nthis:\n  proots_ball_card p z0 r =\n  card\n   (proots_within (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) (ball 0 1))\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "also"], ["proof (state)\nthis:\n  proots_ball_card p z0 r =\n  card\n   (proots_within (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) (ball 0 1))\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "have \"... = proots_upper_card (fcompose (p \\<circ>\\<^sub>p [:z0, of_real r:]) [:\\<i>,-1:] [:\\<i>,1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (proots_within (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n       (ball 0 1)) =\n    proots_upper_card\n     (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n       [:\\<i>, 1:])", "unfolding proots_upper_card_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (proots_within (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n       (ball 0 1)) =\n    card\n     (proots_within\n       (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n         [:\\<i>, 1:])\n       {x. 0 < Im x})", "apply (rule proots_card_ball_plane_eq[THEN arg_cong])"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p [:z0, complex_of_real r:] \\<noteq> 0", "using False pcompose_eq_0[of p \"[:z0, of_real r:]\"]"], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> r \\<le> 0)\n  \\<lbrakk>p \\<circ>\\<^sub>p [:z0, complex_of_real r:] = 0;\n   0 < degree [:z0, complex_of_real r:]\\<rbrakk>\n  \\<Longrightarrow> p = 0\n\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p [:z0, complex_of_real r:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card\n   (proots_within (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n     (ball 0 1)) =\n  proots_upper_card\n   (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n     [:\\<i>, 1:])\n\ngoal (1 subgoal):\n 1. \\<not> (p = 0 \\<or> r \\<le> 0) \\<Longrightarrow>\n    proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "finally"], ["proof (chain)\npicking this:\n  proots_ball_card p z0 r =\n  proots_upper_card\n   (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n     [:\\<i>, 1:])", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_ball_card p z0 r =\n  proots_upper_card\n   (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n     [:\\<i>, 1:])\n\ngoal (1 subgoal):\n 1. proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "using False"], ["proof (prove)\nusing this:\n  proots_ball_card p z0 r =\n  proots_upper_card\n   (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n     [:\\<i>, 1:])\n  \\<not> (p = 0 \\<or> r \\<le> 0)\n\ngoal (1 subgoal):\n 1. proots_ball_card p z0 r =\n    (if r \\<le> 0 \\<or> p = 0 then 0\n     else proots_upper_card\n           (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n             [:\\<i>, - 1:] [:\\<i>, 1:]))", "by auto"], ["proof (state)\nthis:\n  proots_ball_card p z0 r =\n  (if r \\<le> 0 \\<or> p = 0 then 0\n   else proots_upper_card\n         (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n           [:\\<i>, - 1:] [:\\<i>, 1:]))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Polynomial roots on a circle (sphere)\\<close>\n\n\\<comment> \\<open>Roots counted WITH multiplicity\\<close>"], ["", "definition proots_sphere::\"complex poly \\<Rightarrow> complex \\<Rightarrow> real \\<Rightarrow> nat\" where\n  \"proots_sphere p z0 r = proots_count p (sphere z0 r)\" \n\n\\<comment> \\<open>Roots counted WITHOUT multiplicity\\<close>"], ["", "definition proots_sphere_card ::\"complex poly \\<Rightarrow> complex \\<Rightarrow> real \\<Rightarrow> nat\" where\n  \"proots_sphere_card p z0 r = card (proots_within p (sphere z0 r))\""], ["", "lemma proots_sphere_card_code1[code]:\n  \"proots_sphere_card p z0 r = \n                ( if r=0 then \n                      (if poly p z0=0 then 1 else 0) \n                  else if r < 0 \\<or> p=0 then \n                      0\n                  else \n                    (if poly p (z0-r) =0 then 1 else 0) +\n                    proots_unbounded_line_card (fcompose (p \\<circ>\\<^sub>p [:z0, of_real r:]) [:\\<i>,-1:] [:\\<i>,1:])\n                      0 1 \n                )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have ?thesis when \"r=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have \"proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})", "by auto"], ["proof (state)\nthis:\n  proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "then"], ["proof (chain)\npicking this:\n  proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "unfolding proots_sphere_card_def"], ["proof (prove)\nusing this:\n  proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "using that"], ["proof (prove)\nusing this:\n  proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})\n  r = 0\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "by simp"], ["proof (state)\nthis:\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r = 0 \\<Longrightarrow>\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "moreover"], ["proof (state)\nthis:\n  r = 0 \\<Longrightarrow>\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have ?thesis when \"r\\<noteq>0\" \"r < 0 \\<or> p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have ?thesis when \"r<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have \"proots_within p (sphere z0 r) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p (sphere z0 r) = {}", "by (auto simp add: ball_empty that)"], ["proof (state)\nthis:\n  proots_within p (sphere z0 r) = {}\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "then"], ["proof (chain)\npicking this:\n  proots_within p (sphere z0 r) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within p (sphere z0 r) = {}\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "unfolding proots_sphere_card_def"], ["proof (prove)\nusing this:\n  proots_within p (sphere z0 r) = {}\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "using that"], ["proof (prove)\nusing this:\n  proots_within p (sphere z0 r) = {}\n  r < 0\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "by auto"], ["proof (state)\nthis:\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r < 0 \\<Longrightarrow>\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "moreover"], ["proof (state)\nthis:\n  r < 0 \\<Longrightarrow>\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have ?thesis when \"r>0\" \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "unfolding proots_sphere_card_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "using that infinite_sphere[of r z0]"], ["proof (prove)\nusing this:\n  0 < r\n  p = 0\n  0 < r \\<Longrightarrow> infinite (sphere z0 r)\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < r; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_sphere_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else (if poly p (z0 - complex_of_real r) = 0\n                                then 1 else 0) +\n                               proots_unbounded_line_card\n                                (fcompose\n                                  (p \\<circ>\\<^sub>p\n                                   [:z0, complex_of_real r:])\n                                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                                0 1)\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "ultimately"], ["proof (chain)\npicking this:\n  r < 0 \\<Longrightarrow>\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n  \\<lbrakk>0 < r; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_sphere_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else (if poly p (z0 - complex_of_real r) = 0\n                                then 1 else 0) +\n                               proots_unbounded_line_card\n                                (fcompose\n                                  (p \\<circ>\\<^sub>p\n                                   [:z0, complex_of_real r:])\n                                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                                0 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  r < 0 \\<Longrightarrow>\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n  \\<lbrakk>0 < r; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_sphere_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else (if poly p (z0 - complex_of_real r) = 0\n                                then 1 else 0) +\n                               proots_unbounded_line_card\n                                (fcompose\n                                  (p \\<circ>\\<^sub>p\n                                   [:z0, complex_of_real r:])\n                                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                                0 1)\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "using that"], ["proof (prove)\nusing this:\n  r < 0 \\<Longrightarrow>\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n  \\<lbrakk>0 < r; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_sphere_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else (if poly p (z0 - complex_of_real r) = 0\n                                then 1 else 0) +\n                               proots_unbounded_line_card\n                                (fcompose\n                                  (p \\<circ>\\<^sub>p\n                                   [:z0, complex_of_real r:])\n                                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                                0 1)\n  r \\<noteq> 0\n  r < 0 \\<or> p = 0\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "by argo"], ["proof (state)\nthis:\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>r \\<noteq> 0; r < 0 \\<or> p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_sphere_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else (if poly p (z0 - complex_of_real r) = 0\n                                then 1 else 0) +\n                               proots_unbounded_line_card\n                                (fcompose\n                                  (p \\<circ>\\<^sub>p\n                                   [:z0, complex_of_real r:])\n                                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                                0 1)\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>r \\<noteq> 0; r < 0 \\<or> p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_sphere_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else (if poly p (z0 - complex_of_real r) = 0\n                                then 1 else 0) +\n                               proots_unbounded_line_card\n                                (fcompose\n                                  (p \\<circ>\\<^sub>p\n                                   [:z0, complex_of_real r:])\n                                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                                0 1)\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have ?thesis when \"r>0\" \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "define pp where \"pp = p \\<circ>\\<^sub>p [:z0, of_real r:]\""], ["proof (state)\nthis:\n  pp = p \\<circ>\\<^sub>p [:z0, complex_of_real r:]\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "define ppp where \"ppp=fcompose pp [:\\<i>, - 1:] [:\\<i>, 1:]\""], ["proof (state)\nthis:\n  ppp = fcompose pp [:\\<i>, - 1:] [:\\<i>, 1:]\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have \"pp\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp \\<noteq> 0", "unfolding pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p [:z0, complex_of_real r:] \\<noteq> 0", "using that pcompose_eq_0"], ["proof (prove)\nusing this:\n  0 < r\n  p \\<noteq> 0\n  \\<lbrakk>?p \\<circ>\\<^sub>p ?q = 0; 0 < degree ?q\\<rbrakk>\n  \\<Longrightarrow> ?p = 0\n\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p [:z0, complex_of_real r:] \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  pp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have \"proots_sphere_card p z0 r = card (proots_within pp (sphere 0 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r = card (proots_within pp (sphere 0 1))", "unfolding proots_sphere_card_def pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) =\n    card\n     (proots_within (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n       (sphere 0 1))", "by (rule proots_card_usphere_eq[OF \\<open>r>0\\<close>, THEN arg_cong])"], ["proof (state)\nthis:\n  proots_sphere_card p z0 r = card (proots_within pp (sphere 0 1))\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "also"], ["proof (state)\nthis:\n  proots_sphere_card p z0 r = card (proots_within pp (sphere 0 1))\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have \"... = card (proots_within pp {-1} \\<union> proots_within pp (sphere 0 1 - {-1}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within pp (sphere 0 1)) =\n    card\n     (proots_within pp {- 1} \\<union> proots_within pp (sphere 0 1 - {- 1}))", "by (simp add: insert_absorb proots_within_union)"], ["proof (state)\nthis:\n  card (proots_within pp (sphere 0 1)) =\n  card\n   (proots_within pp {- 1} \\<union> proots_within pp (sphere 0 1 - {- 1}))\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "also"], ["proof (state)\nthis:\n  card (proots_within pp (sphere 0 1)) =\n  card\n   (proots_within pp {- 1} \\<union> proots_within pp (sphere 0 1 - {- 1}))\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have \"... = card (proots_within pp {-1}) + card (proots_within pp (sphere 0 1 - {-1}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (proots_within pp {- 1} \\<union>\n      proots_within pp (sphere 0 1 - {- 1})) =\n    card (proots_within pp {- 1}) +\n    card (proots_within pp (sphere 0 1 - {- 1}))", "apply (rule card_Un_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (proots_within pp {- 1})\n 2. finite (proots_within pp (sphere 0 1 - {- 1}))\n 3. proots_within pp {- 1} \\<inter> proots_within pp (sphere 0 1 - {- 1}) =\n    {}", "using \\<open>pp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  pp \\<noteq> 0\n\ngoal (3 subgoals):\n 1. finite (proots_within pp {- 1})\n 2. finite (proots_within pp (sphere 0 1 - {- 1}))\n 3. proots_within pp {- 1} \\<inter> proots_within pp (sphere 0 1 - {- 1}) =\n    {}", "by auto"], ["proof (state)\nthis:\n  card\n   (proots_within pp {- 1} \\<union> proots_within pp (sphere 0 1 - {- 1})) =\n  card (proots_within pp {- 1}) +\n  card (proots_within pp (sphere 0 1 - {- 1}))\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "also"], ["proof (state)\nthis:\n  card\n   (proots_within pp {- 1} \\<union> proots_within pp (sphere 0 1 - {- 1})) =\n  card (proots_within pp {- 1}) +\n  card (proots_within pp (sphere 0 1 - {- 1}))\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have \"... = card (proots_within pp {-1}) + card (proots_within ppp {x. 0 = Im x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within pp {- 1}) +\n    card (proots_within pp (sphere 0 1 - {- 1})) =\n    card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x})", "using proots_card_sphere_axis_eq[OF \\<open>pp\\<noteq>0\\<close>,folded ppp_def]"], ["proof (prove)\nusing this:\n  card (proots_within pp (sphere 0 1 - {- 1})) =\n  card (proots_within ppp {x. 0 = Im x})\n\ngoal (1 subgoal):\n 1. card (proots_within pp {- 1}) +\n    card (proots_within pp (sphere 0 1 - {- 1})) =\n    card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x})", "by simp"], ["proof (state)\nthis:\n  card (proots_within pp {- 1}) +\n  card (proots_within pp (sphere 0 1 - {- 1})) =\n  card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x})\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "also"], ["proof (state)\nthis:\n  card (proots_within pp {- 1}) +\n  card (proots_within pp (sphere 0 1 - {- 1})) =\n  card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x})\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "have \"... = (if poly p (z0-r) =0 then 1 else 0) + proots_unbounded_line_card ppp 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x}) =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card ppp 0 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x}) =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card ppp 0 1", "have \"proots_within pp {-1} = (if poly p (z0-r) =0 then {-1} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within pp {- 1} =\n    (if poly p (z0 - complex_of_real r) = 0 then {- 1} else {})", "unfolding pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) {- 1} =\n    (if poly p (z0 - complex_of_real r) = 0 then {- 1} else {})", "by (auto simp:poly_pcompose)"], ["proof (state)\nthis:\n  proots_within pp {- 1} =\n  (if poly p (z0 - complex_of_real r) = 0 then {- 1} else {})\n\ngoal (1 subgoal):\n 1. card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x}) =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card ppp 0 1", "then"], ["proof (chain)\npicking this:\n  proots_within pp {- 1} =\n  (if poly p (z0 - complex_of_real r) = 0 then {- 1} else {})", "have \"card (proots_within pp {-1}) = (if poly p (z0-r) =0 then 1 else 0)\""], ["proof (prove)\nusing this:\n  proots_within pp {- 1} =\n  (if poly p (z0 - complex_of_real r) = 0 then {- 1} else {})\n\ngoal (1 subgoal):\n 1. card (proots_within pp {- 1}) =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  card (proots_within pp {- 1}) =\n  (if poly p (z0 - complex_of_real r) = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x}) =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card ppp 0 1", "moreover"], ["proof (state)\nthis:\n  card (proots_within pp {- 1}) =\n  (if poly p (z0 - complex_of_real r) = 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x}) =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card ppp 0 1", "have \"{x. Im x = 0} = unbounded_line 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. Im x = 0} = unbounded_line 0 1", "unfolding unbounded_line_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. Im x = 0} = {x. \\<exists>u. x = (1 - u) *\\<^sub>R 0 + u *\\<^sub>R 1}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. Im x = 0 \\<Longrightarrow> \\<exists>u. x = u *\\<^sub>R 1", "by (metis complex_is_Real_iff of_real_Re of_real_def)"], ["proof (state)\nthis:\n  {x. Im x = 0} = unbounded_line 0 1\n\ngoal (1 subgoal):\n 1. card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x}) =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card ppp 0 1", "then"], ["proof (chain)\npicking this:\n  {x. Im x = 0} = unbounded_line 0 1", "have \"card (proots_within ppp {x. 0 = Im x})\n                        = proots_unbounded_line_card ppp 0 1\""], ["proof (prove)\nusing this:\n  {x. Im x = 0} = unbounded_line 0 1\n\ngoal (1 subgoal):\n 1. card (proots_within ppp {x. 0 = Im x}) =\n    proots_unbounded_line_card ppp 0 1", "unfolding proots_unbounded_line_card_def"], ["proof (prove)\nusing this:\n  {x. Im x = 0} = unbounded_line 0 1\n\ngoal (1 subgoal):\n 1. card (proots_within ppp {x. 0 = Im x}) =\n    card (proots_within ppp (unbounded_line 0 1))", "by simp"], ["proof (state)\nthis:\n  card (proots_within ppp {x. 0 = Im x}) =\n  proots_unbounded_line_card ppp 0 1\n\ngoal (1 subgoal):\n 1. card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x}) =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card ppp 0 1", "ultimately"], ["proof (chain)\npicking this:\n  card (proots_within pp {- 1}) =\n  (if poly p (z0 - complex_of_real r) = 0 then 1 else 0)\n  card (proots_within ppp {x. 0 = Im x}) =\n  proots_unbounded_line_card ppp 0 1", "show ?thesis"], ["proof (prove)\nusing this:\n  card (proots_within pp {- 1}) =\n  (if poly p (z0 - complex_of_real r) = 0 then 1 else 0)\n  card (proots_within ppp {x. 0 = Im x}) =\n  proots_unbounded_line_card ppp 0 1\n\ngoal (1 subgoal):\n 1. card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x}) =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card ppp 0 1", "by auto"], ["proof (state)\nthis:\n  card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x}) =\n  (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n  proots_unbounded_line_card ppp 0 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (proots_within pp {- 1}) + card (proots_within ppp {x. 0 = Im x}) =\n  (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n  proots_unbounded_line_card ppp 0 1\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "finally"], ["proof (chain)\npicking this:\n  proots_sphere_card p z0 r =\n  (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n  proots_unbounded_line_card ppp 0 1", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_sphere_card p z0 r =\n  (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n  proots_unbounded_line_card ppp 0 1\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "apply (fold pp_def,fold ppp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proots_sphere_card p z0 r =\n             (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card ppp 0 1;\n     proots_sphere_card p z0 r =\n     (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n     proots_unbounded_line_card ppp 0 1\\<rbrakk>\n    \\<Longrightarrow> proots_sphere_card p z0 r =\n                      (if r = 0 then if poly p z0 = 0 then 1 else 0\n                       else if r < 0 \\<or> p = 0 then 0\n                            else (if poly p (z0 - complex_of_real r) = 0\n                                  then 1 else 0) +\n                                 proots_unbounded_line_card ppp 0 1)", "using that"], ["proof (prove)\nusing this:\n  0 < r\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>proots_sphere_card p z0 r =\n             (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card ppp 0 1;\n     proots_sphere_card p z0 r =\n     (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n     proots_unbounded_line_card ppp 0 1\\<rbrakk>\n    \\<Longrightarrow> proots_sphere_card p z0 r =\n                      (if r = 0 then if poly p z0 = 0 then 1 else 0\n                       else if r < 0 \\<or> p = 0 then 0\n                            else (if poly p (z0 - complex_of_real r) = 0\n                                  then 1 else 0) +\n                                 proots_unbounded_line_card ppp 0 1)", "by auto"], ["proof (state)\nthis:\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < r; p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proots_sphere_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else (if poly p (z0 - complex_of_real r) = 0\n                                then 1 else 0) +\n                               proots_unbounded_line_card\n                                (fcompose\n                                  (p \\<circ>\\<^sub>p\n                                   [:z0, complex_of_real r:])\n                                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                                0 1)\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "ultimately"], ["proof (chain)\npicking this:\n  r = 0 \\<Longrightarrow>\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n  \\<lbrakk>r \\<noteq> 0; r < 0 \\<or> p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_sphere_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else (if poly p (z0 - complex_of_real r) = 0\n                                then 1 else 0) +\n                               proots_unbounded_line_card\n                                (fcompose\n                                  (p \\<circ>\\<^sub>p\n                                   [:z0, complex_of_real r:])\n                                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                                0 1)\n  \\<lbrakk>0 < r; p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proots_sphere_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else (if poly p (z0 - complex_of_real r) = 0\n                                then 1 else 0) +\n                               proots_unbounded_line_card\n                                (fcompose\n                                  (p \\<circ>\\<^sub>p\n                                   [:z0, complex_of_real r:])\n                                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                                0 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  r = 0 \\<Longrightarrow>\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n  \\<lbrakk>r \\<noteq> 0; r < 0 \\<or> p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_sphere_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else (if poly p (z0 - complex_of_real r) = 0\n                                then 1 else 0) +\n                               proots_unbounded_line_card\n                                (fcompose\n                                  (p \\<circ>\\<^sub>p\n                                   [:z0, complex_of_real r:])\n                                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                                0 1)\n  \\<lbrakk>0 < r; p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> proots_sphere_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else (if poly p (z0 - complex_of_real r) = 0\n                                then 1 else 0) +\n                               proots_unbounded_line_card\n                                (fcompose\n                                  (p \\<circ>\\<^sub>p\n                                   [:z0, complex_of_real r:])\n                                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                                0 1)\n\ngoal (1 subgoal):\n 1. proots_sphere_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n               proots_unbounded_line_card\n                (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                  [:\\<i>, - 1:] [:\\<i>, 1:])\n                0 1)", "by auto"], ["proof (state)\nthis:\n  proots_sphere_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card\n              (fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                [:\\<i>, - 1:] [:\\<i>, 1:])\n              0 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Polynomial roots on a closed ball\\<close>\n\n\\<comment> \\<open>Roots counted WITH multiplicity\\<close>"], ["", "definition proots_cball::\"complex poly \\<Rightarrow> complex \\<Rightarrow> real \\<Rightarrow> nat\" where\n  \"proots_cball p z0 r = proots_count p (cball z0 r)\" \n\n\\<comment> \\<open>Roots counted WITHOUT multiplicity\\<close>"], ["", "definition proots_cball_card ::\"complex poly \\<Rightarrow> complex \\<Rightarrow> real \\<Rightarrow> nat\" where\n  \"proots_cball_card p z0 r = card (proots_within p (cball z0 r))\""], ["", "(*FIXME: this surely can be optimised/refined.*)"], ["", "lemma proots_cball_card_code1[code]:\n  \"proots_cball_card p z0 r = \n                ( if r=0 then \n                      (if poly p z0=0 then 1 else 0) \n                  else if r < 0 \\<or> p=0 then \n                      0\n                  else \n                    ( let pp=fcompose (p \\<circ>\\<^sub>p [:z0, of_real r:]) [:\\<i>,-1:] [:\\<i>,1:] \n                      in \n                        (if poly p (z0-r) =0 then 1 else 0) \n                        + proots_unbounded_line_card pp 0 1 \n                        + proots_upper_card pp\n                    )\n                )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "have ?thesis when \"r=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "have \"proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})", "by auto"], ["proof (state)\nthis:\n  proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "then"], ["proof (chain)\npicking this:\n  proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "unfolding proots_cball_card_def"], ["proof (prove)\nusing this:\n  proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})\n\ngoal (1 subgoal):\n 1. card (proots_within p (cball z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "using that"], ["proof (prove)\nusing this:\n  proots_within p {z0} = (if poly p z0 = 0 then {z0} else {})\n  r = 0\n\ngoal (1 subgoal):\n 1. card (proots_within p (cball z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "by simp"], ["proof (state)\nthis:\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r = 0 \\<Longrightarrow>\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "moreover"], ["proof (state)\nthis:\n  r = 0 \\<Longrightarrow>\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "have ?thesis when \"r\\<noteq>0\" \"r < 0 \\<or> p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "have ?thesis when \"r<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "have \"proots_within p (cball z0 r) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p (cball z0 r) = {}", "by (auto simp add: ball_empty that)"], ["proof (state)\nthis:\n  proots_within p (cball z0 r) = {}\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "then"], ["proof (chain)\npicking this:\n  proots_within p (cball z0 r) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within p (cball z0 r) = {}\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "unfolding proots_cball_card_def"], ["proof (prove)\nusing this:\n  proots_within p (cball z0 r) = {}\n\ngoal (1 subgoal):\n 1. card (proots_within p (cball z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "using that"], ["proof (prove)\nusing this:\n  proots_within p (cball z0 r) = {}\n  r < 0\n\ngoal (1 subgoal):\n 1. card (proots_within p (cball z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "by auto"], ["proof (state)\nthis:\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r < 0 \\<Longrightarrow>\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "moreover"], ["proof (state)\nthis:\n  r < 0 \\<Longrightarrow>\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "have ?thesis when \"r>0\" \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "unfolding proots_cball_card_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (cball z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "using that infinite_cball[of r z0]"], ["proof (prove)\nusing this:\n  0 < r\n  p = 0\n  0 < r \\<Longrightarrow> infinite (cball z0 r)\n\ngoal (1 subgoal):\n 1. card (proots_within p (cball z0 r)) =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < r; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_cball_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else let pp = fcompose\n   (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:] [:\\<i>, 1:]\n                               in (if poly p (z0 - complex_of_real r) = 0\n                                   then 1 else 0) +\n                                  proots_unbounded_line_card pp 0 1 +\n                                  proots_upper_card pp)\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "ultimately"], ["proof (chain)\npicking this:\n  r < 0 \\<Longrightarrow>\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n  \\<lbrakk>0 < r; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_cball_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else let pp = fcompose\n   (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:] [:\\<i>, 1:]\n                               in (if poly p (z0 - complex_of_real r) = 0\n                                   then 1 else 0) +\n                                  proots_unbounded_line_card pp 0 1 +\n                                  proots_upper_card pp)", "show ?thesis"], ["proof (prove)\nusing this:\n  r < 0 \\<Longrightarrow>\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n  \\<lbrakk>0 < r; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_cball_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else let pp = fcompose\n   (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:] [:\\<i>, 1:]\n                               in (if poly p (z0 - complex_of_real r) = 0\n                                   then 1 else 0) +\n                                  proots_unbounded_line_card pp 0 1 +\n                                  proots_upper_card pp)\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "using that"], ["proof (prove)\nusing this:\n  r < 0 \\<Longrightarrow>\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n  \\<lbrakk>0 < r; p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_cball_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else let pp = fcompose\n   (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:] [:\\<i>, 1:]\n                               in (if poly p (z0 - complex_of_real r) = 0\n                                   then 1 else 0) +\n                                  proots_unbounded_line_card pp 0 1 +\n                                  proots_upper_card pp)\n  r \\<noteq> 0\n  r < 0 \\<or> p = 0\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "by argo"], ["proof (state)\nthis:\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>r \\<noteq> 0; r < 0 \\<or> p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_cball_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else let pp = fcompose\n   (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:] [:\\<i>, 1:]\n                               in (if poly p (z0 - complex_of_real r) = 0\n                                   then 1 else 0) +\n                                  proots_unbounded_line_card pp 0 1 +\n                                  proots_upper_card pp)\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>r \\<noteq> 0; r < 0 \\<or> p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_cball_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else let pp = fcompose\n   (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:] [:\\<i>, 1:]\n                               in (if poly p (z0 - complex_of_real r) = 0\n                                   then 1 else 0) +\n                                  proots_unbounded_line_card pp 0 1 +\n                                  proots_upper_card pp)\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "have ?thesis when \"p\\<noteq>0\" \"r>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "define pp where \"pp=fcompose (p \\<circ>\\<^sub>p [:z0, of_real r:]) [:\\<i>,-1:] [:\\<i>,1:]\""], ["proof (state)\nthis:\n  pp =\n  fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:]\n   [:\\<i>, 1:]\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "have \"proots_cball_card p z0 r = card (proots_within p (sphere z0 r) \n                                        \\<union> proots_within p (ball z0 r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    card\n     (proots_within p (sphere z0 r) \\<union> proots_within p (ball z0 r))", "unfolding proots_cball_card_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (cball z0 r)) =\n    card\n     (proots_within p (sphere z0 r) \\<union> proots_within p (ball z0 r))", "apply (simp add:proots_within_union)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (cball z0 r)) =\n    card (proots_within p (sphere z0 r \\<union> ball z0 r))", "by (metis Diff_partition cball_diff_sphere sphere_cball)"], ["proof (state)\nthis:\n  proots_cball_card p z0 r =\n  card (proots_within p (sphere z0 r) \\<union> proots_within p (ball z0 r))\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "also"], ["proof (state)\nthis:\n  proots_cball_card p z0 r =\n  card (proots_within p (sphere z0 r) \\<union> proots_within p (ball z0 r))\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "have \"... = card (proots_within p (sphere z0 r)) + card (proots_within p (ball z0 r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (proots_within p (sphere z0 r) \\<union> proots_within p (ball z0 r)) =\n    card (proots_within p (sphere z0 r)) +\n    card (proots_within p (ball z0 r))", "apply (rule card_Un_disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (proots_within p (sphere z0 r))\n 2. finite (proots_within p (ball z0 r))\n 3. proots_within p (sphere z0 r) \\<inter> proots_within p (ball z0 r) = {}", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (3 subgoals):\n 1. finite (proots_within p (sphere z0 r))\n 2. finite (proots_within p (ball z0 r))\n 3. proots_within p (sphere z0 r) \\<inter> proots_within p (ball z0 r) = {}", "by auto"], ["proof (state)\nthis:\n  card\n   (proots_within p (sphere z0 r) \\<union> proots_within p (ball z0 r)) =\n  card (proots_within p (sphere z0 r)) + card (proots_within p (ball z0 r))\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "also"], ["proof (state)\nthis:\n  card\n   (proots_within p (sphere z0 r) \\<union> proots_within p (ball z0 r)) =\n  card (proots_within p (sphere z0 r)) + card (proots_within p (ball z0 r))\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "have \"... = (if poly p (z0-r) =0 then 1 else 0) + proots_unbounded_line_card pp 0 1 \n                        + proots_upper_card pp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) +\n    card (proots_within p (ball z0 r)) =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card pp 0 1 +\n    proots_upper_card pp", "using proots_sphere_card_code1[of p z0 r,folded pp_def,unfolded proots_sphere_card_def] \n        proots_ball_card_code1[of p z0 r,folded pp_def,unfolded proots_ball_card_def]\n        that"], ["proof (prove)\nusing this:\n  card (proots_within p (sphere z0 r)) =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n             proots_unbounded_line_card pp 0 1)\n  card (proots_within p (ball z0 r)) =\n  (if r \\<le> 0 \\<or> p = 0 then 0 else proots_upper_card pp)\n  p \\<noteq> 0\n  0 < r\n\ngoal (1 subgoal):\n 1. card (proots_within p (sphere z0 r)) +\n    card (proots_within p (ball z0 r)) =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card pp 0 1 +\n    proots_upper_card pp", "by simp"], ["proof (state)\nthis:\n  card (proots_within p (sphere z0 r)) +\n  card (proots_within p (ball z0 r)) =\n  (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n  proots_unbounded_line_card pp 0 1 +\n  proots_upper_card pp\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "finally"], ["proof (chain)\npicking this:\n  proots_cball_card p z0 r =\n  (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n  proots_unbounded_line_card pp 0 1 +\n  proots_upper_card pp", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_cball_card p z0 r =\n  (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n  proots_unbounded_line_card pp 0 1 +\n  proots_upper_card pp\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "apply (fold pp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card pp 0 1 +\n    proots_upper_card pp \\<Longrightarrow>\n    proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = pp\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "using that"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  0 < r\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n    proots_unbounded_line_card pp 0 1 +\n    proots_upper_card pp \\<Longrightarrow>\n    proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = pp\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "by auto"], ["proof (state)\nthis:\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0; 0 < r\\<rbrakk>\n  \\<Longrightarrow> proots_cball_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else let pp = fcompose\n   (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:] [:\\<i>, 1:]\n                               in (if poly p (z0 - complex_of_real r) = 0\n                                   then 1 else 0) +\n                                  proots_unbounded_line_card pp 0 1 +\n                                  proots_upper_card pp)\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "ultimately"], ["proof (chain)\npicking this:\n  r = 0 \\<Longrightarrow>\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n  \\<lbrakk>r \\<noteq> 0; r < 0 \\<or> p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_cball_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else let pp = fcompose\n   (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:] [:\\<i>, 1:]\n                               in (if poly p (z0 - complex_of_real r) = 0\n                                   then 1 else 0) +\n                                  proots_unbounded_line_card pp 0 1 +\n                                  proots_upper_card pp)\n  \\<lbrakk>p \\<noteq> 0; 0 < r\\<rbrakk>\n  \\<Longrightarrow> proots_cball_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else let pp = fcompose\n   (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:] [:\\<i>, 1:]\n                               in (if poly p (z0 - complex_of_real r) = 0\n                                   then 1 else 0) +\n                                  proots_unbounded_line_card pp 0 1 +\n                                  proots_upper_card pp)", "show ?thesis"], ["proof (prove)\nusing this:\n  r = 0 \\<Longrightarrow>\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n  \\<lbrakk>r \\<noteq> 0; r < 0 \\<or> p = 0\\<rbrakk>\n  \\<Longrightarrow> proots_cball_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else let pp = fcompose\n   (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:] [:\\<i>, 1:]\n                               in (if poly p (z0 - complex_of_real r) = 0\n                                   then 1 else 0) +\n                                  proots_unbounded_line_card pp 0 1 +\n                                  proots_upper_card pp)\n  \\<lbrakk>p \\<noteq> 0; 0 < r\\<rbrakk>\n  \\<Longrightarrow> proots_cball_card p z0 r =\n                    (if r = 0 then if poly p z0 = 0 then 1 else 0\n                     else if r < 0 \\<or> p = 0 then 0\n                          else let pp = fcompose\n   (p \\<circ>\\<^sub>p [:z0, complex_of_real r:]) [:\\<i>, - 1:] [:\\<i>, 1:]\n                               in (if poly p (z0 - complex_of_real r) = 0\n                                   then 1 else 0) +\n                                  proots_unbounded_line_card pp 0 1 +\n                                  proots_upper_card pp)\n\ngoal (1 subgoal):\n 1. proots_cball_card p z0 r =\n    (if r = 0 then if poly p z0 = 0 then 1 else 0\n     else if r < 0 \\<or> p = 0 then 0\n          else let pp = fcompose\n                         (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                         [:\\<i>, - 1:] [:\\<i>, 1:]\n               in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                  proots_unbounded_line_card pp 0 1 +\n                  proots_upper_card pp)", "by auto"], ["proof (state)\nthis:\n  proots_cball_card p z0 r =\n  (if r = 0 then if poly p z0 = 0 then 1 else 0\n   else if r < 0 \\<or> p = 0 then 0\n        else let pp = fcompose (p \\<circ>\\<^sub>p [:z0, complex_of_real r:])\n                       [:\\<i>, - 1:] [:\\<i>, 1:]\n             in (if poly p (z0 - complex_of_real r) = 0 then 1 else 0) +\n                proots_unbounded_line_card pp 0 1 +\n                proots_upper_card pp)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}