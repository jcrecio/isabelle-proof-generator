{"file_name": "/home/qj213/afp-2021-10-22/thys/UpDown_Scheme/Imperative.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UpDown_Scheme", "problem_names": ["theorem zipWithA [sep_heap_rules]:\n  fixes xs ys :: \"'a::heap list\"\n  assumes \"length xs = length ys\"\n  shows \"< a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys > zipWithA f a b < \\<lambda>r. (a \\<mapsto>\\<^sub>a map (case_prod f) (zip xs ys)) * b \\<mapsto>\\<^sub>a ys * \\<up>(a = r) >\"", "theorem copy_array [sep_heap_rules]:\n  \"< a \\<mapsto>\\<^sub>a xs > copy_array a < \\<lambda>r. a \\<mapsto>\\<^sub>a xs * r \\<mapsto>\\<^sub>a xs >\"", "theorem sum_array [sep_heap_rules]:\n  fixes xs ys :: \"rat list\"\n  shows \"length xs = length ys \\<Longrightarrow> < a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys > sum_array a b < \\<lambda>r. (a \\<mapsto>\\<^sub>a map (\\<lambda>(a, b). a + b) (zip xs ys)) * b \\<mapsto>\\<^sub>a ys >\"", "lemma linearizationD:\n  \"p \\<in> sparsegrid dm lm \\<Longrightarrow> pm p < card (sparsegrid dm lm)\"", "lemma gridI_nth_rule [sep_heap_rules]:\n  \"g \\<in> sparsegrid dm lm \\<Longrightarrow> < gridI a v > Array.nth a (pm g) <\\<lambda>r. gridI a v * \\<up> (of_rat r = v g)>\"", "lemma gridI_upd_rule [sep_heap_rules]:\n  \"g \\<in> sparsegrid dm lm \\<Longrightarrow>\n    < gridI a v > Array.upd (pm g) x a <\\<lambda>a'. gridI a (fun_upd v g (of_rat x)) * \\<up>(a' = a)>\"", "lemma upI' [sep_heap_rules]:\n  assumes lin[simp]: \"d < dm\"\n    and l: \"level p + l = lm\" \"l = 0 \\<or> p \\<in> sparsegrid dm lm\"\n  shows \"< gridI a v > upI' d l p a <\\<lambda>r. let (r', v') = up' d l p v in gridI a v' * \\<up>(rat_pair r = r') >\"", "lemma downI' [sep_heap_rules]:\n  assumes lin[simp]: \"d < dm\"\n    and l: \"level p + l = lm\" \"l = 0 \\<or> p \\<in> sparsegrid dm lm\"\n  shows \"< gridI a v > downI' d l p a fl fr <\\<lambda>r. gridI a (down' d l p (of_rat fl) (of_rat fr) v) >\"", "theorem liftI [sep_heap_rules]:\n  assumes \"d < dm\"\n  and f[sep_heap_rules]: \"\\<And>v p. p \\<in> lgrid (start dm) ({0..<dm} - {d}) lm \\<Longrightarrow>\n    < gridI a v > f d (lm - level p) p a <\\<lambda>r. gridI a (f' d (lm - level p) p v) >\"\n  shows \"< gridI a v > liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v) >\"", "theorem upI [sep_heap_rules]:\n  assumes [simp]: \"d < dm\"\n  shows \"< gridI a v > upI d a <\\<lambda>r. gridI a (up dm lm d v) > \"", "theorem downI [sep_heap_rules]:\n  assumes [simp]: \"d < dm\"\n  shows \"< gridI a v > downI d a <\\<lambda>r. gridI a (down dm lm d v) > \"", "theorem copy_array_gridI [sep_heap_rules]:\n  \"< gridI a v > copy_array a < \\<lambda>r. gridI a v * gridI r v >\"", "theorem sum_array_gridI [sep_heap_rules]:\n  \"< gridI a v * gridI b w > sum_array a b < \\<lambda>r. gridI a (sum_vector v w) * gridI b w >\"", "theorem updownI' [sep_heap_rules]:\n  \"d \\<le> dm \\<Longrightarrow> < gridI a v > updownI' d a <\\<lambda>r. gridI a (updown' dm lm d v) >\\<^sub>t\"", "theorem updownI [sep_heap_rules]:\n  \"< gridI a v > updownI a <\\<lambda>r. gridI a (updown dm lm v) >\\<^sub>t\""], "translations": [["", "theorem zipWithA [sep_heap_rules]:\n  fixes xs ys :: \"'a::heap list\"\n  assumes \"length xs = length ys\"\n  shows \"< a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys > zipWithA f a b < \\<lambda>r. (a \\<mapsto>\\<^sub>a map (case_prod f) (zip xs ys)) * b \\<mapsto>\\<^sub>a ys * \\<up>(a = r) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> zipWithA f a b\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n        \\<up> (a = r)>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> zipWithA f a b\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n        \\<up> (a = r)>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> zipWithA f a b\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n        \\<up> (a = r)>", "fix n and xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> zipWithA f a b\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n        \\<up> (a = r)>", "let ?part_res = \"\\<lambda>n xs. (map (case_prod f) (zip (take n xs) (take n ys)) @ drop n xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> zipWithA f a b\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n        \\<up> (a = r)>", "assume \"n \\<le> length xs\" \"length xs = length ys\""], ["proof (state)\nthis:\n  n \\<le> length xs\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> zipWithA f a b\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n        \\<up> (a = r)>", "then"], ["proof (chain)\npicking this:\n  n \\<le> length xs\n  length xs = length ys", "have \"< a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys > Heap_Monad.fold_map (\\<lambda>n. do {\n         x \\<leftarrow> Array.nth a n ;\n         y \\<leftarrow> Array.nth b n ;\n         Array.upd n (f x y) a\n       }) [0..<n] < \\<lambda>r. a \\<mapsto>\\<^sub>a ?part_res n xs * b \\<mapsto>\\<^sub>a ys >\""], ["proof (prove)\nusing this:\n  n \\<le> length xs\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n    Heap_Monad.fold_map\n     (\\<lambda>n.\n         Array.nth a n \\<bind>\n         (\\<lambda>x.\n             Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n     [0..<n]\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a (map2 f (take n xs) (take n ys) @ drop n xs) *\n        b \\<mapsto>\\<^sub>a ys>", "proof (induct n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 \\<le> length xs; length xs = length ys\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n                         Heap_Monad.fold_map\n                          (\\<lambda>n.\n                              Array.nth a n \\<bind>\n                              (\\<lambda>x.\n                                  Array.nth b n \\<bind>\n                                  (\\<lambda>y. Array.upd n (f x y) a)))\n                          [0..<0]\n                         <\\<lambda>r.\n                             a \\<mapsto>\\<^sub>a\n                             (map2 f (take 0 xs) (take 0 ys) @ drop 0 xs) *\n                             b \\<mapsto>\\<^sub>a ys>\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> length xs;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs *\nb \\<mapsto>\\<^sub>a ys>\n                                     Heap_Monad.fold_map\n(\\<lambda>n.\n    Array.nth a n \\<bind>\n    (\\<lambda>x. Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n[0..<n]\n                                     <\\<lambda>r.\n   a \\<mapsto>\\<^sub>a (map2 f (take n xs) (take n ys) @ drop n xs) *\n   b \\<mapsto>\\<^sub>a ys>;\n        Suc n \\<le> length xs; length xs = length ys\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n                         Heap_Monad.fold_map\n                          (\\<lambda>n.\n                              Array.nth a n \\<bind>\n                              (\\<lambda>x.\n                                  Array.nth b n \\<bind>\n                                  (\\<lambda>y. Array.upd n (f x y) a)))\n                          [0..<Suc n]\n                         <\\<lambda>r.\n                             a \\<mapsto>\\<^sub>a\n                             (map2 f (take (Suc n) xs) (take (Suc n) ys) @\n                              drop (Suc n) xs) *\n                             b \\<mapsto>\\<^sub>a ys>", "case 0"], ["proof (state)\nthis:\n  0 \\<le> length xs\n  length xs = length ys\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 \\<le> length xs; length xs = length ys\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n                         Heap_Monad.fold_map\n                          (\\<lambda>n.\n                              Array.nth a n \\<bind>\n                              (\\<lambda>x.\n                                  Array.nth b n \\<bind>\n                                  (\\<lambda>y. Array.upd n (f x y) a)))\n                          [0..<0]\n                         <\\<lambda>r.\n                             a \\<mapsto>\\<^sub>a\n                             (map2 f (take 0 xs) (take 0 ys) @ drop 0 xs) *\n                             b \\<mapsto>\\<^sub>a ys>\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> length xs;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs *\nb \\<mapsto>\\<^sub>a ys>\n                                     Heap_Monad.fold_map\n(\\<lambda>n.\n    Array.nth a n \\<bind>\n    (\\<lambda>x. Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n[0..<n]\n                                     <\\<lambda>r.\n   a \\<mapsto>\\<^sub>a (map2 f (take n xs) (take n ys) @ drop n xs) *\n   b \\<mapsto>\\<^sub>a ys>;\n        Suc n \\<le> length xs; length xs = length ys\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n                         Heap_Monad.fold_map\n                          (\\<lambda>n.\n                              Array.nth a n \\<bind>\n                              (\\<lambda>x.\n                                  Array.nth b n \\<bind>\n                                  (\\<lambda>y. Array.upd n (f x y) a)))\n                          [0..<Suc n]\n                         <\\<lambda>r.\n                             a \\<mapsto>\\<^sub>a\n                             (map2 f (take (Suc n) xs) (take (Suc n) ys) @\n                              drop (Suc n) xs) *\n                             b \\<mapsto>\\<^sub>a ys>", "then"], ["proof (chain)\npicking this:\n  0 \\<le> length xs\n  length xs = length ys", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> length xs\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n    Heap_Monad.fold_map\n     (\\<lambda>n.\n         Array.nth a n \\<bind>\n         (\\<lambda>x.\n             Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n     [0..<0]\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a (map2 f (take 0 xs) (take 0 ys) @ drop 0 xs) *\n        b \\<mapsto>\\<^sub>a ys>", "by sep_auto"], ["proof (state)\nthis:\n  <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n  Heap_Monad.fold_map\n   (\\<lambda>n.\n       Array.nth a n \\<bind>\n       (\\<lambda>x.\n           Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n   [0..<0]\n  <\\<lambda>r.\n      a \\<mapsto>\\<^sub>a (map2 f (take 0 xs) (take 0 ys) @ drop 0 xs) *\n      b \\<mapsto>\\<^sub>a ys>\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> length xs;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs *\nb \\<mapsto>\\<^sub>a ys>\n                                     Heap_Monad.fold_map\n(\\<lambda>n.\n    Array.nth a n \\<bind>\n    (\\<lambda>x. Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n[0..<n]\n                                     <\\<lambda>r.\n   a \\<mapsto>\\<^sub>a (map2 f (take n xs) (take n ys) @ drop n xs) *\n   b \\<mapsto>\\<^sub>a ys>;\n        Suc n \\<le> length xs; length xs = length ys\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n                         Heap_Monad.fold_map\n                          (\\<lambda>n.\n                              Array.nth a n \\<bind>\n                              (\\<lambda>x.\n                                  Array.nth b n \\<bind>\n                                  (\\<lambda>y. Array.upd n (f x y) a)))\n                          [0..<Suc n]\n                         <\\<lambda>r.\n                             a \\<mapsto>\\<^sub>a\n                             (map2 f (take (Suc n) xs) (take (Suc n) ys) @\n                              drop (Suc n) xs) *\n                             b \\<mapsto>\\<^sub>a ys>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> length xs;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs *\nb \\<mapsto>\\<^sub>a ys>\n                                     Heap_Monad.fold_map\n(\\<lambda>n.\n    Array.nth a n \\<bind>\n    (\\<lambda>x. Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n[0..<n]\n                                     <\\<lambda>r.\n   a \\<mapsto>\\<^sub>a (map2 f (take n xs) (take n ys) @ drop n xs) *\n   b \\<mapsto>\\<^sub>a ys>;\n        Suc n \\<le> length xs; length xs = length ys\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n                         Heap_Monad.fold_map\n                          (\\<lambda>n.\n                              Array.nth a n \\<bind>\n                              (\\<lambda>x.\n                                  Array.nth b n \\<bind>\n                                  (\\<lambda>y. Array.upd n (f x y) a)))\n                          [0..<Suc n]\n                         <\\<lambda>r.\n                             a \\<mapsto>\\<^sub>a\n                             (map2 f (take (Suc n) xs) (take (Suc n) ys) @\n                              drop (Suc n) xs) *\n                             b \\<mapsto>\\<^sub>a ys>", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> length ?xs; length ?xs = length ys\\<rbrakk>\n  \\<Longrightarrow> <a \\<mapsto>\\<^sub>a ?xs * b \\<mapsto>\\<^sub>a ys>\n                    Heap_Monad.fold_map\n                     (\\<lambda>n.\n                         Array.nth a n \\<bind>\n                         (\\<lambda>x.\n                             Array.nth b n \\<bind>\n                             (\\<lambda>y. Array.upd n (f x y) a)))\n                     [0..<n]\n                    <\\<lambda>r.\n                        a \\<mapsto>\\<^sub>a\n                        (map2 f (take n ?xs) (take n ys) @ drop n ?xs) *\n                        b \\<mapsto>\\<^sub>a ys>\n  Suc n \\<le> length xs\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> length xs;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs *\nb \\<mapsto>\\<^sub>a ys>\n                                     Heap_Monad.fold_map\n(\\<lambda>n.\n    Array.nth a n \\<bind>\n    (\\<lambda>x. Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n[0..<n]\n                                     <\\<lambda>r.\n   a \\<mapsto>\\<^sub>a (map2 f (take n xs) (take n ys) @ drop n xs) *\n   b \\<mapsto>\\<^sub>a ys>;\n        Suc n \\<le> length xs; length xs = length ys\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n                         Heap_Monad.fold_map\n                          (\\<lambda>n.\n                              Array.nth a n \\<bind>\n                              (\\<lambda>x.\n                                  Array.nth b n \\<bind>\n                                  (\\<lambda>y. Array.upd n (f x y) a)))\n                          [0..<Suc n]\n                         <\\<lambda>r.\n                             a \\<mapsto>\\<^sub>a\n                             (map2 f (take (Suc n) xs) (take (Suc n) ys) @\n                              drop (Suc n) xs) *\n                             b \\<mapsto>\\<^sub>a ys>", "note Suc.hyps [sep_heap_rules]"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> length ?xs; length ?xs = length ys\\<rbrakk>\n  \\<Longrightarrow> <a \\<mapsto>\\<^sub>a ?xs * b \\<mapsto>\\<^sub>a ys>\n                    Heap_Monad.fold_map\n                     (\\<lambda>n.\n                         Array.nth a n \\<bind>\n                         (\\<lambda>x.\n                             Array.nth b n \\<bind>\n                             (\\<lambda>y. Array.upd n (f x y) a)))\n                     [0..<n]\n                    <\\<lambda>r.\n                        a \\<mapsto>\\<^sub>a\n                        (map2 f (take n ?xs) (take n ys) @ drop n ?xs) *\n                        b \\<mapsto>\\<^sub>a ys>\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> length xs;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs *\nb \\<mapsto>\\<^sub>a ys>\n                                     Heap_Monad.fold_map\n(\\<lambda>n.\n    Array.nth a n \\<bind>\n    (\\<lambda>x. Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n[0..<n]\n                                     <\\<lambda>r.\n   a \\<mapsto>\\<^sub>a (map2 f (take n xs) (take n ys) @ drop n xs) *\n   b \\<mapsto>\\<^sub>a ys>;\n        Suc n \\<le> length xs; length xs = length ys\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n                         Heap_Monad.fold_map\n                          (\\<lambda>n.\n                              Array.nth a n \\<bind>\n                              (\\<lambda>x.\n                                  Array.nth b n \\<bind>\n                                  (\\<lambda>y. Array.upd n (f x y) a)))\n                          [0..<Suc n]\n                         <\\<lambda>r.\n                             a \\<mapsto>\\<^sub>a\n                             (map2 f (take (Suc n) xs) (take (Suc n) ys) @\n                              drop (Suc n) xs) *\n                             b \\<mapsto>\\<^sub>a ys>", "have *: \"(?part_res n xs)[n := f (?part_res n xs ! n) (ys ! n)] =  ?part_res (Suc n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map2 f (take n xs) (take n ys) @ drop n xs)\n    [n := f ((map2 f (take n xs) (take n ys) @ drop n xs) ! n) (ys ! n)] =\n    map2 f (take (Suc n) xs) (take (Suc n) ys) @ drop (Suc n) xs", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc n \\<le> length xs\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. (map2 f (take n xs) (take n ys) @ drop n xs)\n    [n := f ((map2 f (take n xs) (take n ys) @ drop n xs) ! n) (ys ! n)] =\n    map2 f (take (Suc n) xs) (take (Suc n) ys) @ drop (Suc n) xs", "by (simp add: nth_append take_Suc_conv_app_nth upd_conv_take_nth_drop)"], ["proof (state)\nthis:\n  (map2 f (take n xs) (take n ys) @ drop n xs)\n  [n := f ((map2 f (take n xs) (take n ys) @ drop n xs) ! n) (ys ! n)] =\n  map2 f (take (Suc n) xs) (take (Suc n) ys) @ drop (Suc n) xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> length xs;\n                    length xs = length ys\\<rbrakk>\n                   \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs *\nb \\<mapsto>\\<^sub>a ys>\n                                     Heap_Monad.fold_map\n(\\<lambda>n.\n    Array.nth a n \\<bind>\n    (\\<lambda>x. Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n[0..<n]\n                                     <\\<lambda>r.\n   a \\<mapsto>\\<^sub>a (map2 f (take n xs) (take n ys) @ drop n xs) *\n   b \\<mapsto>\\<^sub>a ys>;\n        Suc n \\<le> length xs; length xs = length ys\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n                         Heap_Monad.fold_map\n                          (\\<lambda>n.\n                              Array.nth a n \\<bind>\n                              (\\<lambda>x.\n                                  Array.nth b n \\<bind>\n                                  (\\<lambda>y. Array.upd n (f x y) a)))\n                          [0..<Suc n]\n                         <\\<lambda>r.\n                             a \\<mapsto>\\<^sub>a\n                             (map2 f (take (Suc n) xs) (take (Suc n) ys) @\n                              drop (Suc n) xs) *\n                             b \\<mapsto>\\<^sub>a ys>", "from Suc.prems"], ["proof (chain)\npicking this:\n  Suc n \\<le> length xs\n  length xs = length ys", "show ?case"], ["proof (prove)\nusing this:\n  Suc n \\<le> length xs\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n    Heap_Monad.fold_map\n     (\\<lambda>n.\n         Array.nth a n \\<bind>\n         (\\<lambda>x.\n             Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n     [0..<Suc n]\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a\n        (map2 f (take (Suc n) xs) (take (Suc n) ys) @ drop (Suc n) xs) *\n        b \\<mapsto>\\<^sub>a ys>", "by (sep_auto simp add: fold_map_append *)"], ["proof (state)\nthis:\n  <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n  Heap_Monad.fold_map\n   (\\<lambda>n.\n       Array.nth a n \\<bind>\n       (\\<lambda>x.\n           Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n   [0..<Suc n]\n  <\\<lambda>r.\n      a \\<mapsto>\\<^sub>a\n      (map2 f (take (Suc n) xs) (take (Suc n) ys) @ drop (Suc n) xs) *\n      b \\<mapsto>\\<^sub>a ys>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n  Heap_Monad.fold_map\n   (\\<lambda>n.\n       Array.nth a n \\<bind>\n       (\\<lambda>x.\n           Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n   [0..<n]\n  <\\<lambda>r.\n      a \\<mapsto>\\<^sub>a (map2 f (take n xs) (take n ys) @ drop n xs) *\n      b \\<mapsto>\\<^sub>a ys>\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> zipWithA f a b\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n        \\<up> (a = r)>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?n2 \\<le> length ?xsa2; length ?xsa2 = length ys\\<rbrakk>\n  \\<Longrightarrow> <a \\<mapsto>\\<^sub>a ?xsa2 * b \\<mapsto>\\<^sub>a ys>\n                    Heap_Monad.fold_map\n                     (\\<lambda>n.\n                         Array.nth a n \\<bind>\n                         (\\<lambda>x.\n                             Array.nth b n \\<bind>\n                             (\\<lambda>y. Array.upd n (f x y) a)))\n                     [0..<?n2]\n                    <\\<lambda>r.\n                        a \\<mapsto>\\<^sub>a\n                        (map2 f (take ?n2 ?xsa2) (take ?n2 ys) @\n                         drop ?n2 ?xsa2) *\n                        b \\<mapsto>\\<^sub>a ys>\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> zipWithA f a b\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n        \\<up> (a = r)>", "note this[sep_heap_rules]"], ["proof (state)\nthis:\n  \\<lbrakk>?n2 \\<le> length ?xsa2; length ?xsa2 = length ys\\<rbrakk>\n  \\<Longrightarrow> <a \\<mapsto>\\<^sub>a ?xsa2 * b \\<mapsto>\\<^sub>a ys>\n                    Heap_Monad.fold_map\n                     (\\<lambda>n.\n                         Array.nth a n \\<bind>\n                         (\\<lambda>x.\n                             Array.nth b n \\<bind>\n                             (\\<lambda>y. Array.upd n (f x y) a)))\n                     [0..<?n2]\n                    <\\<lambda>r.\n                        a \\<mapsto>\\<^sub>a\n                        (map2 f (take ?n2 ?xsa2) (take ?n2 ys) @\n                         drop ?n2 ?xsa2) *\n                        b \\<mapsto>\\<^sub>a ys>\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> zipWithA f a b\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n        \\<up> (a = r)>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> zipWithA f a b\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n        \\<up> (a = r)>", "unfolding zipWithA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n    Array.len a \\<bind>\n    (\\<lambda>n.\n        Heap_Monad.fold_map\n         (\\<lambda>n.\n             Array.nth a n \\<bind>\n             (\\<lambda>x.\n                 Array.nth b n \\<bind> (\\<lambda>y. Array.upd n (f x y) a)))\n         [0..<n] \\<bind>\n        (\\<lambda>_. return a))\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n        \\<up> (a = r)>", "by (sep_auto simp add: assms)"], ["proof (state)\nthis:\n  <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> zipWithA f a b\n  <\\<lambda>r.\n      a \\<mapsto>\\<^sub>a map2 f xs ys * b \\<mapsto>\\<^sub>a ys *\n      \\<up> (a = r)>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition copy_array :: \"'a::heap array \\<Rightarrow> ('a::heap array) Heap\" where\n  \"copy_array a = Array.freeze a \\<bind> Array.of_list\""], ["", "theorem copy_array [sep_heap_rules]:\n  \"< a \\<mapsto>\\<^sub>a xs > copy_array a < \\<lambda>r. a \\<mapsto>\\<^sub>a xs * r \\<mapsto>\\<^sub>a xs >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs> copy_array a\n    <\\<lambda>r. a \\<mapsto>\\<^sub>a xs * r \\<mapsto>\\<^sub>a xs>", "unfolding copy_array_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a xs> Array.freeze a \\<bind> Array.of_list\n    <\\<lambda>r. a \\<mapsto>\\<^sub>a xs * r \\<mapsto>\\<^sub>a xs>", "by sep_auto"], ["", "definition sum_array :: \"rat array \\<Rightarrow> rat array \\<Rightarrow> unit Heap\" where\n  \"sum_array a b = zipWithA (+) a b \\<then> return ()\""], ["", "theorem sum_array [sep_heap_rules]:\n  fixes xs ys :: \"rat list\"\n  shows \"length xs = length ys \\<Longrightarrow> < a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys > sum_array a b < \\<lambda>r. (a \\<mapsto>\\<^sub>a map (\\<lambda>(a, b). a + b) (zip xs ys)) * b \\<mapsto>\\<^sub>a ys >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys> sum_array a b\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 (+) xs ys * b \\<mapsto>\\<^sub>a ys>", "unfolding sum_array_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    <a \\<mapsto>\\<^sub>a xs * b \\<mapsto>\\<^sub>a ys>\n    zipWithA (+) a b \\<bind> (\\<lambda>_. return ())\n    <\\<lambda>r.\n        a \\<mapsto>\\<^sub>a map2 (+) xs ys * b \\<mapsto>\\<^sub>a ys>", "by sep_auto"], ["", "locale linearization =\n  fixes dm lm :: nat\n  fixes pm :: pointmap\n  assumes pm: \"bij_betw pm (sparsegrid dm lm) {..< card (sparsegrid dm lm)}\"\nbegin"], ["", "lemma linearizationD:\n  \"p \\<in> sparsegrid dm lm \\<Longrightarrow> pm p < card (sparsegrid dm lm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid dm lm \\<Longrightarrow>\n    pm p < card (sparsegrid dm lm)", "using pm"], ["proof (prove)\nusing this:\n  bij_betw pm (sparsegrid dm lm) {..<card (sparsegrid dm lm)}\n\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid dm lm \\<Longrightarrow>\n    pm p < card (sparsegrid dm lm)", "by (auto simp: bij_betw_def)"], ["", "definition gridI :: \"impgrid \\<Rightarrow> (grid_point \\<Rightarrow> real) \\<Rightarrow> assn\" where\n  \"gridI a v =\n    (\\<exists>\\<^sub>A xs. a \\<mapsto>\\<^sub>a xs * \\<up>((\\<forall>p\\<in>sparsegrid dm lm. v p = of_rat (xs ! pm p)) \\<and> length xs = card (sparsegrid dm lm)))\""], ["", "lemma gridI_nth_rule [sep_heap_rules]:\n  \"g \\<in> sparsegrid dm lm \\<Longrightarrow> < gridI a v > Array.nth a (pm g) <\\<lambda>r. gridI a v * \\<up> (of_rat r = v g)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> sparsegrid dm lm \\<Longrightarrow>\n    <gridI a v> Array.nth a (pm g)\n    <\\<lambda>r. gridI a v * \\<up> (real_of_rat r = v g)>", "using pm"], ["proof (prove)\nusing this:\n  bij_betw pm (sparsegrid dm lm) {..<card (sparsegrid dm lm)}\n\ngoal (1 subgoal):\n 1. g \\<in> sparsegrid dm lm \\<Longrightarrow>\n    <gridI a v> Array.nth a (pm g)\n    <\\<lambda>r. gridI a v * \\<up> (real_of_rat r = v g)>", "by (sep_auto simp: bij_betw_def gridI_def)"], ["", "lemma gridI_upd_rule [sep_heap_rules]:\n  \"g \\<in> sparsegrid dm lm \\<Longrightarrow>\n    < gridI a v > Array.upd (pm g) x a <\\<lambda>a'. gridI a (fun_upd v g (of_rat x)) * \\<up>(a' = a)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> sparsegrid dm lm \\<Longrightarrow>\n    <gridI a v> Array.upd (pm g) x a\n    <\\<lambda>a'. gridI a (v(g := real_of_rat x)) * \\<up> (a' = a)>", "unfolding gridI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> sparsegrid dm lm \\<Longrightarrow>\n    <\\<exists>\\<^sub>Axs.\n        a \\<mapsto>\\<^sub>a xs *\n        \\<up>\n         ((\\<forall>p\\<in>sparsegrid dm lm.\n              v p = real_of_rat (xs ! pm p)) \\<and>\n          length xs = card (sparsegrid dm lm))>\n    Array.upd (pm g) x a\n    <\\<lambda>a'.\n        (\\<exists>\\<^sub>Axs.\n            a \\<mapsto>\\<^sub>a xs *\n            \\<up>\n             ((\\<forall>p\\<in>sparsegrid dm lm.\n                  (v(g := real_of_rat x)) p =\n                  real_of_rat (xs ! pm p)) \\<and>\n              length xs = card (sparsegrid dm lm))) *\n        \\<up> (a' = a)>", "using pm"], ["proof (prove)\nusing this:\n  bij_betw pm (sparsegrid dm lm) {..<card (sparsegrid dm lm)}\n\ngoal (1 subgoal):\n 1. g \\<in> sparsegrid dm lm \\<Longrightarrow>\n    <\\<exists>\\<^sub>Axs.\n        a \\<mapsto>\\<^sub>a xs *\n        \\<up>\n         ((\\<forall>p\\<in>sparsegrid dm lm.\n              v p = real_of_rat (xs ! pm p)) \\<and>\n          length xs = card (sparsegrid dm lm))>\n    Array.upd (pm g) x a\n    <\\<lambda>a'.\n        (\\<exists>\\<^sub>Axs.\n            a \\<mapsto>\\<^sub>a xs *\n            \\<up>\n             ((\\<forall>p\\<in>sparsegrid dm lm.\n                  (v(g := real_of_rat x)) p =\n                  real_of_rat (xs ! pm p)) \\<and>\n              length xs = card (sparsegrid dm lm))) *\n        \\<up> (a' = a)>", "by (sep_auto simp: bij_betw_def inj_onD intro!: nth_list_update_eq[symmetric] nth_list_update_neq[symmetric])"], ["", "primrec upI' :: \"nat \\<Rightarrow> nat \\<Rightarrow> grid_point \\<Rightarrow> impgrid \\<Rightarrow> (rat * rat) Heap\" where\n  \"upI' d       0 p a = return (0, 0)\" |\n  \"upI' d (Suc l) p a = do {\n       (fl, fml) \\<leftarrow> upI' d l (child p left d) a ;\n       (fmr, fr) \\<leftarrow> upI' d l (child p right d) a ;\n       val \\<leftarrow> Array.nth a (pm p) ;\n       Array.upd (pm p) (fml + fmr) a ;\n       let result = ((fml + fmr + val / 2 ^ (lv p d) / 2) / 2) ;\n       return (fl + result, fr + result)\n     }\""], ["", "lemma upI' [sep_heap_rules]:\n  assumes lin[simp]: \"d < dm\"\n    and l: \"level p + l = lm\" \"l = 0 \\<or> p \\<in> sparsegrid dm lm\"\n  shows \"< gridI a v > upI' d l p a <\\<lambda>r. let (r', v') = up' d l p v in gridI a v' * \\<up>(rat_pair r = r') >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v> upI' d l p a\n    <\\<lambda>r.\n        let (r', v') = up' d l p v in gridI a v' * \\<up> (rat_pair r = r')>", "using l"], ["proof (prove)\nusing this:\n  level p + l = lm\n  l = 0 \\<or> p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. <gridI a v> upI' d l p a\n    <\\<lambda>r.\n        let (r', v') = up' d l p v in gridI a v' * \\<up> (rat_pair r = r')>", "proof (induct l arbitrary: p v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p v.\n       \\<lbrakk>level p + 0 = lm;\n        0 = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d 0 p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d 0 p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>\n 2. \\<And>l p v.\n       \\<lbrakk>\\<And>p v.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> upI' d l p a\n                                     <\\<lambda>r.\n   let (r', v') = up' d l p v in gridI a v' * \\<up> (rat_pair r = r')>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d (Suc l) p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d (Suc l) p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>", "note rat_pair.simps [simp]"], ["proof (state)\nthis:\n  rat_pair (?a, ?b) = (of_rat ?a, of_rat ?b)\n\ngoal (2 subgoals):\n 1. \\<And>p v.\n       \\<lbrakk>level p + 0 = lm;\n        0 = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d 0 p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d 0 p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>\n 2. \\<And>l p v.\n       \\<lbrakk>\\<And>p v.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> upI' d l p a\n                                     <\\<lambda>r.\n   let (r', v') = up' d l p v in gridI a v' * \\<up> (rat_pair r = r')>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d (Suc l) p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d (Suc l) p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>", "case 0"], ["proof (state)\nthis:\n  level p + 0 = lm\n  0 = 0 \\<or> p \\<in> sparsegrid dm lm\n\ngoal (2 subgoals):\n 1. \\<And>p v.\n       \\<lbrakk>level p + 0 = lm;\n        0 = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d 0 p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d 0 p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>\n 2. \\<And>l p v.\n       \\<lbrakk>\\<And>p v.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> upI' d l p a\n                                     <\\<lambda>r.\n   let (r', v') = up' d l p v in gridI a v' * \\<up> (rat_pair r = r')>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d (Suc l) p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d (Suc l) p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>", "then"], ["proof (chain)\npicking this:\n  level p + 0 = lm\n  0 = 0 \\<or> p \\<in> sparsegrid dm lm", "show ?case"], ["proof (prove)\nusing this:\n  level p + 0 = lm\n  0 = 0 \\<or> p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. <gridI a v> upI' d 0 p a\n    <\\<lambda>r.\n        let b = up' d 0 p v\n        in case b of\n           (r', v') \\<Rightarrow> gridI a v' * \\<up> (rat_pair r = r')>", "by sep_auto"], ["proof (state)\nthis:\n  <gridI a v> upI' d 0 p a\n  <\\<lambda>r.\n      let b = up' d 0 p v\n      in case b of\n         (r', v') \\<Rightarrow> gridI a v' * \\<up> (rat_pair r = r')>\n\ngoal (1 subgoal):\n 1. \\<And>l p v.\n       \\<lbrakk>\\<And>p v.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> upI' d l p a\n                                     <\\<lambda>r.\n   let (r', v') = up' d l p v in gridI a v' * \\<up> (rat_pair r = r')>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d (Suc l) p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d (Suc l) p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l p v.\n       \\<lbrakk>\\<And>p v.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> upI' d l p a\n                                     <\\<lambda>r.\n   let (r', v') = up' d l p v in gridI a v' * \\<up> (rat_pair r = r')>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d (Suc l) p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d (Suc l) p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>", "case (Suc l)"], ["proof (state)\nthis:\n  \\<lbrakk>level ?p + l = lm; l = 0 \\<or> ?p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> <gridI a ?v> upI' d l ?p a\n                    <\\<lambda>r.\n                        let b = up' d l ?p ?v\n                        in case b of\n                           (r', v') \\<Rightarrow>\n                             gridI a v' * \\<up> (rat_pair r = r')>\n  level p + Suc l = lm\n  Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. \\<And>l p v.\n       \\<lbrakk>\\<And>p v.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> upI' d l p a\n                                     <\\<lambda>r.\n   let (r', v') = up' d l p v in gridI a v' * \\<up> (rat_pair r = r')>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d (Suc l) p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d (Suc l) p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>", "from Suc.prems \\<open>d < dm\\<close>"], ["proof (chain)\npicking this:\n  level p + Suc l = lm\n  Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\n  d < dm", "have [simp]: \"level (child p left d) + l = lm\" \"level (child p right d) + l = lm\" \"p \\<in> sparsegrid dm lm\""], ["proof (prove)\nusing this:\n  level p + Suc l = lm\n  Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\n  d < dm\n\ngoal (1 subgoal):\n 1. level (child p left d) + l = lm &&&\n    level (child p right d) + l = lm &&& p \\<in> sparsegrid dm lm", "by (auto simp: sparsegrid_length)"], ["proof (state)\nthis:\n  level (child p left d) + l = lm\n  level (child p right d) + l = lm\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. \\<And>l p v.\n       \\<lbrakk>\\<And>p v.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> upI' d l p a\n                                     <\\<lambda>r.\n   let (r', v') = up' d l p v in gridI a v' * \\<up> (rat_pair r = r')>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d (Suc l) p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d (Suc l) p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>", "have [simp]: \"child p left d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0\" \"child p right d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (child p left d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0) &&&\n    (child p right d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0)", "using Suc.prems"], ["proof (prove)\nusing this:\n  level p + Suc l = lm\n  Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. (child p left d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0) &&&\n    (child p right d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0)", "by (auto simp: sparsegrid_def lgrid_def)"], ["proof (state)\nthis:\n  child p left d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0\n  child p right d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0\n\ngoal (1 subgoal):\n 1. \\<And>l p v.\n       \\<lbrakk>\\<And>p v.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> upI' d l p a\n                                     <\\<lambda>r.\n   let (r', v') = up' d l p v in gridI a v' * \\<up> (rat_pair r = r')>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d (Suc l) p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d (Suc l) p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>", "note Suc(1)[sep_heap_rules]"], ["proof (state)\nthis:\n  \\<lbrakk>level ?p + l = lm; l = 0 \\<or> ?p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> <gridI a ?v> upI' d l ?p a\n                    <\\<lambda>r.\n                        let b = up' d l ?p ?v\n                        in case b of\n                           (r', v') \\<Rightarrow>\n                             gridI a v' * \\<up> (rat_pair r = r')>\n\ngoal (1 subgoal):\n 1. \\<And>l p v.\n       \\<lbrakk>\\<And>p v.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> upI' d l p a\n                                     <\\<lambda>r.\n   let (r', v') = up' d l p v in gridI a v' * \\<up> (rat_pair r = r')>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> upI' d (Suc l) p a\n                         <\\<lambda>r.\n                             let (r', v') = up' d (Suc l) p v\n                             in gridI a v' * \\<up> (rat_pair r = r')>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v> upI' d (Suc l) p a\n    <\\<lambda>r.\n        let b = up' d (Suc l) p v\n        in case b of\n           (r', v') \\<Rightarrow> gridI a v' * \\<up> (rat_pair r = r')>", "by (sep_auto split: prod.split simp: of_rat_add of_rat_divide of_rat_power of_rat_mult rat_pair_def Let_def)"], ["proof (state)\nthis:\n  <gridI a v> upI' d (Suc l) p a\n  <\\<lambda>r.\n      let b = up' d (Suc l) p v\n      in case b of\n         (r', v') \\<Rightarrow> gridI a v' * \\<up> (rat_pair r = r')>\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec downI' :: \"nat \\<Rightarrow> nat \\<Rightarrow> grid_point \\<Rightarrow> impgrid \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow> unit Heap\" where\n  \"downI' d       0 p a fl fr = return ()\" |\n  \"downI' d (Suc l) p a fl fr = do {\n      val \\<leftarrow> Array.nth a (pm p) ;\n      let fm = ((fl + fr) / 2 + val) ;\n      Array.upd (pm p) (((fl + fr) / 4 + (1 / 3) * val) / 2 ^ (lv p d)) a ;\n      downI' d l (child p left d) a fl fm ;\n      downI' d l (child p right d) a fm fr\n    }\""], ["", "lemma downI' [sep_heap_rules]:\n  assumes lin[simp]: \"d < dm\"\n    and l: \"level p + l = lm\" \"l = 0 \\<or> p \\<in> sparsegrid dm lm\"\n  shows \"< gridI a v > downI' d l p a fl fr <\\<lambda>r. gridI a (down' d l p (of_rat fl) (of_rat fr) v) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v> downI' d l p a fl fr\n    <\\<lambda>r. gridI a (down' d l p (real_of_rat fl) (real_of_rat fr) v)>", "using l"], ["proof (prove)\nusing this:\n  level p + l = lm\n  l = 0 \\<or> p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. <gridI a v> downI' d l p a fl fr\n    <\\<lambda>r. gridI a (down' d l p (real_of_rat fl) (real_of_rat fr) v)>", "proof (induct l arbitrary: p v fl fr)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p v fl fr.\n       \\<lbrakk>level p + 0 = lm;\n        0 = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d 0 p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d 0 p (real_of_rat fl) (real_of_rat fr)\n                                v)>\n 2. \\<And>l p v fl fr.\n       \\<lbrakk>\\<And>p v fl fr.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> downI' d l p a fl fr\n                                     <\\<lambda>r.\n   gridI a (down' d l p (real_of_rat fl) (real_of_rat fr) v)>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d (Suc l) p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d (Suc l) p (real_of_rat fl)\n                                (real_of_rat fr) v)>", "note rat_pair.simps [simp]"], ["proof (state)\nthis:\n  rat_pair (?a, ?b) = (of_rat ?a, of_rat ?b)\n\ngoal (2 subgoals):\n 1. \\<And>p v fl fr.\n       \\<lbrakk>level p + 0 = lm;\n        0 = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d 0 p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d 0 p (real_of_rat fl) (real_of_rat fr)\n                                v)>\n 2. \\<And>l p v fl fr.\n       \\<lbrakk>\\<And>p v fl fr.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> downI' d l p a fl fr\n                                     <\\<lambda>r.\n   gridI a (down' d l p (real_of_rat fl) (real_of_rat fr) v)>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d (Suc l) p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d (Suc l) p (real_of_rat fl)\n                                (real_of_rat fr) v)>", "case 0"], ["proof (state)\nthis:\n  level p + 0 = lm\n  0 = 0 \\<or> p \\<in> sparsegrid dm lm\n\ngoal (2 subgoals):\n 1. \\<And>p v fl fr.\n       \\<lbrakk>level p + 0 = lm;\n        0 = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d 0 p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d 0 p (real_of_rat fl) (real_of_rat fr)\n                                v)>\n 2. \\<And>l p v fl fr.\n       \\<lbrakk>\\<And>p v fl fr.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> downI' d l p a fl fr\n                                     <\\<lambda>r.\n   gridI a (down' d l p (real_of_rat fl) (real_of_rat fr) v)>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d (Suc l) p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d (Suc l) p (real_of_rat fl)\n                                (real_of_rat fr) v)>", "then"], ["proof (chain)\npicking this:\n  level p + 0 = lm\n  0 = 0 \\<or> p \\<in> sparsegrid dm lm", "show ?case"], ["proof (prove)\nusing this:\n  level p + 0 = lm\n  0 = 0 \\<or> p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. <gridI a v> downI' d 0 p a fl fr\n    <\\<lambda>r. gridI a (down' d 0 p (real_of_rat fl) (real_of_rat fr) v)>", "by sep_auto"], ["proof (state)\nthis:\n  <gridI a v> downI' d 0 p a fl fr\n  <\\<lambda>r. gridI a (down' d 0 p (real_of_rat fl) (real_of_rat fr) v)>\n\ngoal (1 subgoal):\n 1. \\<And>l p v fl fr.\n       \\<lbrakk>\\<And>p v fl fr.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> downI' d l p a fl fr\n                                     <\\<lambda>r.\n   gridI a (down' d l p (real_of_rat fl) (real_of_rat fr) v)>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d (Suc l) p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d (Suc l) p (real_of_rat fl)\n                                (real_of_rat fr) v)>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l p v fl fr.\n       \\<lbrakk>\\<And>p v fl fr.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> downI' d l p a fl fr\n                                     <\\<lambda>r.\n   gridI a (down' d l p (real_of_rat fl) (real_of_rat fr) v)>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d (Suc l) p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d (Suc l) p (real_of_rat fl)\n                                (real_of_rat fr) v)>", "case (Suc l)"], ["proof (state)\nthis:\n  \\<lbrakk>level ?p + l = lm; l = 0 \\<or> ?p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> <gridI a ?v> downI' d l ?p a ?fl ?fr\n                    <\\<lambda>r.\n                        gridI a\n                         (down' d l ?p (real_of_rat ?fl) (real_of_rat ?fr)\n                           ?v)>\n  level p + Suc l = lm\n  Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. \\<And>l p v fl fr.\n       \\<lbrakk>\\<And>p v fl fr.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> downI' d l p a fl fr\n                                     <\\<lambda>r.\n   gridI a (down' d l p (real_of_rat fl) (real_of_rat fr) v)>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d (Suc l) p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d (Suc l) p (real_of_rat fl)\n                                (real_of_rat fr) v)>", "from Suc.prems \\<open>d < dm\\<close>"], ["proof (chain)\npicking this:\n  level p + Suc l = lm\n  Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\n  d < dm", "have [simp]: \"level (child p left d) + l = lm\" \"level (child p right d) + l = lm\" \"p \\<in> sparsegrid dm lm\""], ["proof (prove)\nusing this:\n  level p + Suc l = lm\n  Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\n  d < dm\n\ngoal (1 subgoal):\n 1. level (child p left d) + l = lm &&&\n    level (child p right d) + l = lm &&& p \\<in> sparsegrid dm lm", "by (auto simp: sparsegrid_length)"], ["proof (state)\nthis:\n  level (child p left d) + l = lm\n  level (child p right d) + l = lm\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. \\<And>l p v fl fr.\n       \\<lbrakk>\\<And>p v fl fr.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> downI' d l p a fl fr\n                                     <\\<lambda>r.\n   gridI a (down' d l p (real_of_rat fl) (real_of_rat fr) v)>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d (Suc l) p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d (Suc l) p (real_of_rat fl)\n                                (real_of_rat fr) v)>", "have [simp]: \"child p left d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0\" \"child p right d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (child p left d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0) &&&\n    (child p right d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0)", "using Suc.prems"], ["proof (prove)\nusing this:\n  level p + Suc l = lm\n  Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. (child p left d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0) &&&\n    (child p right d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0)", "by (auto simp: sparsegrid_def lgrid_def)"], ["proof (state)\nthis:\n  child p left d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0\n  child p right d \\<notin> sparsegrid dm lm \\<Longrightarrow> l = 0\n\ngoal (1 subgoal):\n 1. \\<And>l p v fl fr.\n       \\<lbrakk>\\<And>p v fl fr.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> downI' d l p a fl fr\n                                     <\\<lambda>r.\n   gridI a (down' d l p (real_of_rat fl) (real_of_rat fr) v)>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d (Suc l) p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d (Suc l) p (real_of_rat fl)\n                                (real_of_rat fr) v)>", "note Suc(1)[sep_heap_rules]"], ["proof (state)\nthis:\n  \\<lbrakk>level ?p + l = lm; l = 0 \\<or> ?p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> <gridI a ?v> downI' d l ?p a ?fl ?fr\n                    <\\<lambda>r.\n                        gridI a\n                         (down' d l ?p (real_of_rat ?fl) (real_of_rat ?fr)\n                           ?v)>\n\ngoal (1 subgoal):\n 1. \\<And>l p v fl fr.\n       \\<lbrakk>\\<And>p v fl fr.\n                   \\<lbrakk>level p + l = lm;\n                    l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> <gridI a v> downI' d l p a fl fr\n                                     <\\<lambda>r.\n   gridI a (down' d l p (real_of_rat fl) (real_of_rat fr) v)>;\n        level p + Suc l = lm;\n        Suc l = 0 \\<or> p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> <gridI a v> downI' d (Suc l) p a fl fr\n                         <\\<lambda>r.\n                             gridI a\n                              (down' d (Suc l) p (real_of_rat fl)\n                                (real_of_rat fr) v)>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v> downI' d (Suc l) p a fl fr\n    <\\<lambda>r.\n        gridI a (down' d (Suc l) p (real_of_rat fl) (real_of_rat fr) v)>", "by (sep_auto split: prod.split simp: of_rat_add of_rat_divide of_rat_power of_rat_mult rat_pair_def Let_def fun_upd_def)"], ["proof (state)\nthis:\n  <gridI a v> downI' d (Suc l) p a fl fr\n  <\\<lambda>r.\n      gridI a (down' d (Suc l) p (real_of_rat fl) (real_of_rat fr) v)>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition liftI :: \"(nat \\<Rightarrow> nat \\<Rightarrow> grid_point \\<Rightarrow> impgrid \\<Rightarrow> unit Heap) \\<Rightarrow> nat \\<Rightarrow> impgrid \\<Rightarrow> unit Heap\" where\n  \"liftI f d a = \n    foldr (\\<lambda> p n. n \\<then> f d (lm - level p) p a) (gridgen (start dm) ({ 0 ..< dm } - { d }) lm) (return ())\""], ["", "theorem liftI [sep_heap_rules]:\n  assumes \"d < dm\"\n  and f[sep_heap_rules]: \"\\<And>v p. p \\<in> lgrid (start dm) ({0..<dm} - {d}) lm \\<Longrightarrow>\n    < gridI a v > f d (lm - level p) p a <\\<lambda>r. gridI a (f' d (lm - level p) p v) >\"\n  shows \"< gridI a v > liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v> liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v)>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <gridI a v> liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v)>", "let ?ds = \"{0..<dm} - {d}\" and ?g = \"gridI a\""], ["proof (state)\ngoal (1 subgoal):\n 1. <gridI a v> liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v)>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. <gridI a v> liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v)>", "fix ps"], ["proof (state)\ngoal (1 subgoal):\n 1. <gridI a v> liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v)>", "assume \"set ps \\<subseteq> set (gridgen (start dm) ?ds lm)\" and \"distinct ps\""], ["proof (state)\nthis:\n  set ps \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct ps\n\ngoal (1 subgoal):\n 1. <gridI a v> liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v)>", "then"], ["proof (chain)\npicking this:\n  set ps \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct ps", "have \"< ?g v >\n        foldr (\\<lambda>p n. (n :: unit Heap) \\<then> f d (lm - level p) p a) ps (return ())\n      <\\<lambda>r. ?g (foldr (\\<lambda>p \\<alpha>. f' d (lm - level p) p \\<alpha>) ps v) >\""], ["proof (prove)\nusing this:\n  set ps \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct ps\n\ngoal (1 subgoal):\n 1. <gridI a v>\n    foldr (\\<lambda>p n. n \\<bind> (\\<lambda>_. f d (lm - level p) p a)) ps\n     (return ())\n    <\\<lambda>r. gridI a (foldr (\\<lambda>p. f' d (lm - level p) p) ps v)>", "by (induct ps arbitrary: v) (sep_auto simp: gridgen_lgrid_eq)+"], ["proof (state)\nthis:\n  <gridI a v>\n  foldr (\\<lambda>p n. n \\<bind> (\\<lambda>_. f d (lm - level p) p a)) ps\n   (return ())\n  <\\<lambda>r. gridI a (foldr (\\<lambda>p. f' d (lm - level p) p) ps v)>\n\ngoal (1 subgoal):\n 1. <gridI a v> liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v)>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>set ?ps2\n           \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct ?ps2\\<rbrakk>\n  \\<Longrightarrow> <gridI a v>\n                    foldr\n                     (\\<lambda>p n.\n                         n \\<bind> (\\<lambda>_. f d (lm - level p) p a))\n                     ?ps2 (return ())\n                    <\\<lambda>r.\n                        gridI a\n                         (foldr (\\<lambda>p. f' d (lm - level p) p) ?ps2 v)>\n\ngoal (1 subgoal):\n 1. <gridI a v> liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v)>", "from this[OF subset_refl gridgen_distinct]"], ["proof (chain)\npicking this:\n  <gridI a v>\n  foldr (\\<lambda>p n. n \\<bind> (\\<lambda>_. f d (lm - level p) p a))\n   (gridgen (start dm) ({0..<dm} - {d}) lm) (return ())\n  <\\<lambda>r.\n      gridI a\n       (foldr (\\<lambda>p. f' d (lm - level p) p)\n         (gridgen (start dm) ({0..<dm} - {d}) lm) v)>", "show ?thesis"], ["proof (prove)\nusing this:\n  <gridI a v>\n  foldr (\\<lambda>p n. n \\<bind> (\\<lambda>_. f d (lm - level p) p a))\n   (gridgen (start dm) ({0..<dm} - {d}) lm) (return ())\n  <\\<lambda>r.\n      gridI a\n       (foldr (\\<lambda>p. f' d (lm - level p) p)\n         (gridgen (start dm) ({0..<dm} - {d}) lm) v)>\n\ngoal (1 subgoal):\n 1. <gridI a v> liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v)>", "by (simp add: liftI_def Grid.lift_def)"], ["proof (state)\nthis:\n  <gridI a v> liftI f d a <\\<lambda>r. gridI a (Grid.lift f' dm lm d v)>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition upI where \"upI = liftI (\\<lambda>d l p a. upI' d l p a \\<then> return ())\""], ["", "theorem upI [sep_heap_rules]:\n  assumes [simp]: \"d < dm\"\n  shows \"< gridI a v > upI d a <\\<lambda>r. gridI a (up dm lm d v) > \""], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v> upI d a <\\<lambda>r. gridI a (up dm lm d v)>", "unfolding up_def upI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v>\n    liftI (\\<lambda>d l p a. upI' d l p a \\<bind> (\\<lambda>_. return ())) d\n     a\n    <\\<lambda>r.\n        gridI a\n         (Grid.lift (\\<lambda>d lm p \\<alpha>. snd (up' d lm p \\<alpha>)) dm\n           lm d v)>", "by (sep_auto simp: lgrid_def sparsegrid_def lgrid_def split: prod.split\n               intro: grid_union_dims[of \"{0..<dm} - {d}\" \"{0..<dm}\"])"], ["", "definition downI where \"downI = liftI (\\<lambda>d l p a. downI' d l p a 0 0)\""], ["", "theorem downI [sep_heap_rules]:\n  assumes [simp]: \"d < dm\"\n  shows \"< gridI a v > downI d a <\\<lambda>r. gridI a (down dm lm d v) > \""], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v> downI d a <\\<lambda>r. gridI a (down dm lm d v)>", "unfolding down_def downI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v> liftI (\\<lambda>d l p a. downI' d l p a 0 0) d a\n    <\\<lambda>r.\n        gridI a (Grid.lift (\\<lambda>d l p. down' d l p 0 0) dm lm d v)>", "by (sep_auto simp: lgrid_def sparsegrid_def lgrid_def split: prod.split\n               intro: grid_union_dims[of \"{0..<dm} - {d}\" \"{0..<dm}\"])"], ["", "theorem copy_array_gridI [sep_heap_rules]:\n  \"< gridI a v > copy_array a < \\<lambda>r. gridI a v * gridI r v >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v> copy_array a <\\<lambda>r. gridI a v * gridI r v>", "unfolding gridI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Axs.\n        a \\<mapsto>\\<^sub>a xs *\n        \\<up>\n         ((\\<forall>p\\<in>sparsegrid dm lm.\n              v p = real_of_rat (xs ! pm p)) \\<and>\n          length xs = card (sparsegrid dm lm))>\n    copy_array a\n    <\\<lambda>r.\n        (\\<exists>\\<^sub>Axs.\n            a \\<mapsto>\\<^sub>a xs *\n            \\<up>\n             ((\\<forall>p\\<in>sparsegrid dm lm.\n                  v p = real_of_rat (xs ! pm p)) \\<and>\n              length xs = card (sparsegrid dm lm))) *\n        (\\<exists>\\<^sub>Axs.\n            r \\<mapsto>\\<^sub>a xs *\n            \\<up>\n             ((\\<forall>p\\<in>sparsegrid dm lm.\n                  v p = real_of_rat (xs ! pm p)) \\<and>\n              length xs = card (sparsegrid dm lm)))>", "by sep_auto"], ["", "theorem sum_array_gridI [sep_heap_rules]:\n  \"< gridI a v * gridI b w > sum_array a b < \\<lambda>r. gridI a (sum_vector v w) * gridI b w >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v * gridI b w> sum_array a b\n    <\\<lambda>r. gridI a (sum_vector v w) * gridI b w>", "unfolding gridI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <(\\<exists>\\<^sub>Axs.\n         a \\<mapsto>\\<^sub>a xs *\n         \\<up>\n          ((\\<forall>p\\<in>sparsegrid dm lm.\n               v p = real_of_rat (xs ! pm p)) \\<and>\n           length xs = card (sparsegrid dm lm))) *\n     (\\<exists>\\<^sub>Axs.\n         b \\<mapsto>\\<^sub>a xs *\n         \\<up>\n          ((\\<forall>p\\<in>sparsegrid dm lm.\n               w p = real_of_rat (xs ! pm p)) \\<and>\n           length xs = card (sparsegrid dm lm)))>\n    sum_array a b\n    <\\<lambda>r.\n        (\\<exists>\\<^sub>Axs.\n            a \\<mapsto>\\<^sub>a xs *\n            \\<up>\n             ((\\<forall>p\\<in>sparsegrid dm lm.\n                  sum_vector v w p = real_of_rat (xs ! pm p)) \\<and>\n              length xs = card (sparsegrid dm lm))) *\n        (\\<exists>\\<^sub>Axs.\n            b \\<mapsto>\\<^sub>a xs *\n            \\<up>\n             ((\\<forall>p\\<in>sparsegrid dm lm.\n                  w p = real_of_rat (xs ! pm p)) \\<and>\n              length xs = card (sparsegrid dm lm)))>", "by (sep_auto simp: sum_vector_def nth_map linearizationD of_rat_add)"], ["", "primrec updownI' :: \"nat \\<Rightarrow> impgrid \\<Rightarrow> unit Heap\" where\n  \"updownI' 0 a = return ()\" |\n  \"updownI' (Suc d) a = do {\n      b \\<leftarrow> copy_array a ;\n      upI d a ;\n      updownI' d a ;\n      updownI' d b ;\n      downI d b ;\n      sum_array a b\n    }\""], ["", "theorem updownI' [sep_heap_rules]:\n  \"d \\<le> dm \\<Longrightarrow> < gridI a v > updownI' d a <\\<lambda>r. gridI a (updown' dm lm d v) >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> dm \\<Longrightarrow>\n    <gridI a\n      v> updownI' d a <\\<lambda>r. gridI a (updown' dm lm d v)>\\<^sub>t", "proof (induct d arbitrary: a v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a v.\n       0 \\<le> dm \\<Longrightarrow>\n       <gridI a\n         v> updownI' 0 a <\\<lambda>r. gridI a (updown' dm lm 0 v)>\\<^sub>t\n 2. \\<And>d a v.\n       \\<lbrakk>\\<And>a v.\n                   d \\<le> dm \\<Longrightarrow>\n                   <gridI a\n                     v> updownI' d\n                         a <\\<lambda>r.\n                               gridI a (updown' dm lm d v)>\\<^sub>t;\n        Suc d \\<le> dm\\<rbrakk>\n       \\<Longrightarrow> <gridI a\n                           v> updownI' (Suc d)\n                               a <\\<lambda>r.\n                                     gridI a\n(updown' dm lm (Suc d) v)>\\<^sub>t", "case (Suc d)"], ["proof (state)\nthis:\n  d \\<le> dm \\<Longrightarrow>\n  <gridI ?a\n    ?v> updownI' d ?a <\\<lambda>r. gridI ?a (updown' dm lm d ?v)>\\<^sub>t\n  Suc d \\<le> dm\n\ngoal (2 subgoals):\n 1. \\<And>a v.\n       0 \\<le> dm \\<Longrightarrow>\n       <gridI a\n         v> updownI' 0 a <\\<lambda>r. gridI a (updown' dm lm 0 v)>\\<^sub>t\n 2. \\<And>d a v.\n       \\<lbrakk>\\<And>a v.\n                   d \\<le> dm \\<Longrightarrow>\n                   <gridI a\n                     v> updownI' d\n                         a <\\<lambda>r.\n                               gridI a (updown' dm lm d v)>\\<^sub>t;\n        Suc d \\<le> dm\\<rbrakk>\n       \\<Longrightarrow> <gridI a\n                           v> updownI' (Suc d)\n                               a <\\<lambda>r.\n                                     gridI a\n(updown' dm lm (Suc d) v)>\\<^sub>t", "note Suc.hyps [sep_heap_rules]"], ["proof (state)\nthis:\n  d \\<le> dm \\<Longrightarrow>\n  <gridI ?a\n    ?v> updownI' d ?a <\\<lambda>r. gridI ?a (updown' dm lm d ?v)>\\<^sub>t\n\ngoal (2 subgoals):\n 1. \\<And>a v.\n       0 \\<le> dm \\<Longrightarrow>\n       <gridI a\n         v> updownI' 0 a <\\<lambda>r. gridI a (updown' dm lm 0 v)>\\<^sub>t\n 2. \\<And>d a v.\n       \\<lbrakk>\\<And>a v.\n                   d \\<le> dm \\<Longrightarrow>\n                   <gridI a\n                     v> updownI' d\n                         a <\\<lambda>r.\n                               gridI a (updown' dm lm d v)>\\<^sub>t;\n        Suc d \\<le> dm\\<rbrakk>\n       \\<Longrightarrow> <gridI a\n                           v> updownI' (Suc d)\n                               a <\\<lambda>r.\n                                     gridI a\n(updown' dm lm (Suc d) v)>\\<^sub>t", "from Suc.prems"], ["proof (chain)\npicking this:\n  Suc d \\<le> dm", "show ?case"], ["proof (prove)\nusing this:\n  Suc d \\<le> dm\n\ngoal (1 subgoal):\n 1. <gridI a\n      v> updownI' (Suc d)\n          a <\\<lambda>r. gridI a (updown' dm lm (Suc d) v)>\\<^sub>t", "by sep_auto"], ["proof (state)\nthis:\n  <gridI a\n    v> updownI' (Suc d)\n        a <\\<lambda>r. gridI a (updown' dm lm (Suc d) v)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>a v.\n       0 \\<le> dm \\<Longrightarrow>\n       <gridI a\n         v> updownI' 0 a <\\<lambda>r. gridI a (updown' dm lm 0 v)>\\<^sub>t", "qed sep_auto"], ["", "definition updownI where \"updownI a = updownI' dm a\""], ["", "theorem updownI [sep_heap_rules]:\n  \"< gridI a v > updownI a <\\<lambda>r. gridI a (updown dm lm v) >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a v> updownI a <\\<lambda>r. gridI a (updown dm lm v)>\\<^sub>t", "unfolding updown_def updownI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <gridI a\n      v> updownI' dm a <\\<lambda>r. gridI a (updown' dm lm dm v)>\\<^sub>t", "by sep_auto"], ["", "end"], ["", "end"]]}