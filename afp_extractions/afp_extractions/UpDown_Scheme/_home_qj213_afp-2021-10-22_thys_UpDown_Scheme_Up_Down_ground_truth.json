{"file_name": "/home/qj213/afp-2021-10-22/thys/UpDown_Scheme/Up_Down.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UpDown_Scheme", "problem_names": ["lemma updown': \"\\<lbrakk> d \\<le> dm; p \\<in> sparsegrid dm lm \\<rbrakk>\n  \\<Longrightarrow> (updown' dm lm d \\<alpha>) p = (\\<Sum> p' \\<in> lgrid (base {0 ..< d} p) {0 ..< d} lm. \\<alpha> p' * (\\<Prod> d' \\<in> {0 ..< d}. l2_\\<phi> (p' ! d') (p ! d')))\"\n  (is \"\\<lbrakk> _ ; _ \\<rbrakk> \\<Longrightarrow> _ = (\\<Sum> p' \\<in> ?subgrid d p. \\<alpha> p' * ?prod d p' p)\")", "theorem updown:\n  assumes p_spg: \"p \\<in> sparsegrid dm lm\"\n  shows \"updown dm lm \\<alpha> p = (\\<Sum> p' \\<in> sparsegrid dm lm. \\<alpha> p' * l2 p' p)\""], "translations": [["", "lemma updown': \"\\<lbrakk> d \\<le> dm; p \\<in> sparsegrid dm lm \\<rbrakk>\n  \\<Longrightarrow> (updown' dm lm d \\<alpha>) p = (\\<Sum> p' \\<in> lgrid (base {0 ..< d} p) {0 ..< d} lm. \\<alpha> p' * (\\<Prod> d' \\<in> {0 ..< d}. l2_\\<phi> (p' ! d') (p ! d')))\"\n  (is \"\\<lbrakk> _ ; _ \\<rbrakk> \\<Longrightarrow> _ = (\\<Sum> p' \\<in> ?subgrid d p. \\<alpha> p' * ?prod d p' p)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n    \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                      (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                         \\<alpha> p' *\n                         (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')))", "proof (induct d arbitrary: \\<alpha> p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> p.\n       \\<lbrakk>0 \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm 0 \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<0} p) {0..<0} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<0.\n                                l2_\\<phi> (p' ! d') (p ! d')))\n 2. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> dm\n  p \\<in> sparsegrid dm lm\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> p.\n       \\<lbrakk>0 \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm 0 \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<0} p) {0..<0} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<0.\n                                l2_\\<phi> (p' ! d') (p ! d')))\n 2. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "hence \"?subgrid 0 p = {p}\""], ["proof (prove)\nusing this:\n  0 \\<le> dm\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. lgrid (base {0..<0} p) {0..<0} lm = {p}", "using base_empty"], ["proof (prove)\nusing this:\n  0 \\<le> dm\n  p \\<in> sparsegrid dm lm\n  ?p \\<in> sparsegrid' ?dm \\<Longrightarrow> base {} ?p = ?p\n\ngoal (1 subgoal):\n 1. lgrid (base {0..<0} p) {0..<0} lm = {p}", "unfolding lgrid_def and sparsegrid_def sparsegrid'_def"], ["proof (prove)\nusing this:\n  0 \\<le> dm\n  p \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}\n  ?p \\<in> grid (start ?dm) {0..<?dm} \\<Longrightarrow> base {} ?p = ?p\n\ngoal (1 subgoal):\n 1. {p \\<in> grid (base {0..<0} p) {0..<0}. level p < lm} = {p}", "by auto"], ["proof (state)\nthis:\n  lgrid (base {0..<0} p) {0..<0} lm = {p}\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> p.\n       \\<lbrakk>0 \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm 0 \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<0} p) {0..<0} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<0.\n                                l2_\\<phi> (p' ! d') (p ! d')))\n 2. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "thus ?case"], ["proof (prove)\nusing this:\n  lgrid (base {0..<0} p) {0..<0} lm = {p}\n\ngoal (1 subgoal):\n 1. updown' dm lm 0 \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {0..<0} p) {0..<0} lm.\n       \\<alpha> p' * (\\<Prod>d' = 0..<0. l2_\\<phi> (p' ! d') (p ! d')))", "unfolding updown'.simps"], ["proof (prove)\nusing this:\n  lgrid (base {0..<0} p) {0..<0} lm = {p}\n\ngoal (1 subgoal):\n 1. \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {0..<0} p) {0..<0} lm.\n       \\<alpha> p' * (\\<Prod>d' = 0..<0. l2_\\<phi> (p' ! d') (p ! d')))", "by auto"], ["proof (state)\nthis:\n  updown' dm lm 0 \\<alpha> p =\n  (\\<Sum>p'\\<in>lgrid (base {0..<0} p) {0..<0} lm.\n     \\<alpha> p' * (\\<Prod>d' = 0..<0. l2_\\<phi> (p' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "case (Suc d)"], ["proof (state)\nthis:\n  \\<lbrakk>d \\<le> dm; ?p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> updown' dm lm d ?\\<alpha> ?p =\n                    (\\<Sum>p'\\<in>lgrid (base {0..<d} ?p) {0..<d} lm.\n                       ?\\<alpha> p' *\n                       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (?p ! d')))\n  Suc d \\<le> dm\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "let \"?leafs p\" = \"(lgrid p {d} lm) - {p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "let \"?parents\" = \"parents d (base {d} p) p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "let ?b = \"base {0..<d} p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"d < dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < dm", "using \\<open>Suc d \\<le> dm\\<close>"], ["proof (prove)\nusing this:\n  Suc d \\<le> dm\n\ngoal (1 subgoal):\n 1. d < dm", "by auto"], ["proof (state)\nthis:\n  d < dm\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have p_spg: \"p \\<in> grid (start dm) {0..<dm}\" and p_spg': \"p \\<in> sparsegrid' dm\" and \"level p < lm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) {0..<dm} &&&\n    p \\<in> sparsegrid' dm &&& level p < lm", "using \\<open>p \\<in> sparsegrid dm lm\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) {0..<dm} &&&\n    p \\<in> sparsegrid' dm &&& level p < lm", "unfolding sparsegrid_def and sparsegrid'_def and lgrid_def"], ["proof (prove)\nusing this:\n  p \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}\n\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) {0..<dm} &&&\n    p \\<in> grid (start dm) {0..<dm} &&& level p < lm", "by auto"], ["proof (state)\nthis:\n  p \\<in> grid (start dm) {0..<dm}\n  p \\<in> sparsegrid' dm\n  level p < lm\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have p'_in_spg: \"!! p'. p' \\<in> ?subgrid d p \\<Longrightarrow> p' \\<in> sparsegrid dm lm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p'.\n       p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n       p' \\<in> sparsegrid dm lm", "using base_grid[OF p_spg']"], ["proof (prove)\nusing this:\n  grid (base ?ds p) ?ds \\<subseteq> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. \\<And>p'.\n       p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n       p' \\<in> sparsegrid dm lm", "unfolding sparsegrid'_def sparsegrid_def lgrid_def"], ["proof (prove)\nusing this:\n  grid (base ?ds p) ?ds \\<subseteq> grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. \\<And>p'.\n       p' \\<in> {p \\<in> grid (base {0..<d} p) {0..<d}.\n                 level p < lm} \\<Longrightarrow>\n       p' \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}", "by auto"], ["proof (state)\nthis:\n  ?p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n  ?p' \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "from baseE[OF p_spg', where ds=\"{0..<d}\"]"], ["proof (chain)\npicking this:\n  base {0..<d} p \\<in> grid (start dm) ({0..<dm} - {0..<d})\n  p \\<in> grid (base {0..<d} p) {0..<d}", "have \"?b \\<in> grid (start dm) {d..<dm}\" and p_bgrid: \"p \\<in> grid ?b {0..<d}\""], ["proof (prove)\nusing this:\n  base {0..<d} p \\<in> grid (start dm) ({0..<dm} - {0..<d})\n  p \\<in> grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. base {0..<d} p \\<in> grid (start dm) {d..<dm} &&&\n    p \\<in> grid (base {0..<d} p) {0..<d}", "by auto"], ["proof (state)\nthis:\n  base {0..<d} p \\<in> grid (start dm) {d..<dm}\n  p \\<in> grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "hence \"d < length ?b\""], ["proof (prove)\nusing this:\n  base {0..<d} p \\<in> grid (start dm) {d..<dm}\n  p \\<in> grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. d < length (base {0..<d} p)", "using \\<open>Suc d \\<le> dm\\<close>"], ["proof (prove)\nusing this:\n  base {0..<d} p \\<in> grid (start dm) {d..<dm}\n  p \\<in> grid (base {0..<d} p) {0..<d}\n  Suc d \\<le> dm\n\ngoal (1 subgoal):\n 1. d < length (base {0..<d} p)", "by auto"], ["proof (state)\nthis:\n  d < length (base {0..<d} p)\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"p ! d = ?b ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! d = base {0..<d} p ! d", "using base_out[OF _ _ p_spg'] \\<open>Suc d \\<le> dm\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?d < dm; ?d \\<notin> ?ds\\<rbrakk>\n  \\<Longrightarrow> base ?ds p ! ?d = p ! ?d\n  Suc d \\<le> dm\n\ngoal (1 subgoal):\n 1. p ! d = base {0..<d} p ! d", "by auto"], ["proof (state)\nthis:\n  p ! d = base {0..<d} p ! d\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"length p = dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p = dm", "using \\<open>p \\<in> sparsegrid dm lm\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. length p = dm", "unfolding sparsegrid_def lgrid_def"], ["proof (prove)\nusing this:\n  p \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}\n\ngoal (1 subgoal):\n 1. length p = dm", "by auto"], ["proof (state)\nthis:\n  length p = dm\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "hence \"d < length p\""], ["proof (prove)\nusing this:\n  length p = dm\n\ngoal (1 subgoal):\n 1. d < length p", "using \\<open>d < dm\\<close>"], ["proof (prove)\nusing this:\n  length p = dm\n  d < dm\n\ngoal (1 subgoal):\n 1. d < length p", "by auto"], ["proof (state)\nthis:\n  d < length p\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"updown' dm lm d (up dm lm d \\<alpha>) p =\n    (\\<Sum> p' \\<in> ?subgrid d p. (up dm lm d \\<alpha>) p' * (?prod d p' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. updown' dm lm d (up dm lm d \\<alpha>) p =\n    (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n       up dm lm d \\<alpha> p' *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')))", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>d \\<le> dm; ?p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> updown' dm lm d ?\\<alpha> ?p =\n                    (\\<Sum>p'\\<in>lgrid (base {0..<d} ?p) {0..<d} lm.\n                       ?\\<alpha> p' *\n                       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (?p ! d')))\n  Suc d \\<le> dm\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. updown' dm lm d (up dm lm d \\<alpha>) p =\n    (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n       up dm lm d \\<alpha> p' *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')))", "by auto"], ["proof (state)\nthis:\n  updown' dm lm d (up dm lm d \\<alpha>) p =\n  (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n     up dm lm d \\<alpha> p' *\n     (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  updown' dm lm d (up dm lm d \\<alpha>) p =\n  (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n     up dm lm d \\<alpha> p' *\n     (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p' \\<in> ?subgrid d p. (\\<Sum> p'' \\<in> ?leafs p'. \\<alpha> p'' * ?prod (Suc d) p'' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n       up dm lm d \\<alpha> p' *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d'))) =\n    (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n       \\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n         \\<alpha> p'' *\n         (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "proof (intro sum.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n       up dm lm d \\<alpha> x *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p ! d')) =\n       (\\<Sum>p''\\<in>lgrid x {d} lm - {x}.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "fix p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n       up dm lm d \\<alpha> x *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p ! d')) =\n       (\\<Sum>p''\\<in>lgrid x {d} lm - {x}.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "assume \"p' \\<in> ?subgrid d p\""], ["proof (state)\nthis:\n  p' \\<in> lgrid (base {0..<d} p) {0..<d} lm\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n       up dm lm d \\<alpha> x *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p ! d')) =\n       (\\<Sum>p''\\<in>lgrid x {d} lm - {x}.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "hence \"d < length p'\""], ["proof (prove)\nusing this:\n  p' \\<in> lgrid (base {0..<d} p) {0..<d} lm\n\ngoal (1 subgoal):\n 1. d < length p'", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  p' \\<in> {p \\<in> grid (base {0..<d} p) {0..<d}. level p < lm}\n\ngoal (1 subgoal):\n 1. d < length p'", "using base_length[OF p_spg'] \\<open>Suc d \\<le> dm\\<close>"], ["proof (prove)\nusing this:\n  p' \\<in> {p \\<in> grid (base {0..<d} p) {0..<d}. level p < lm}\n  length (base ?ds p) = dm\n  Suc d \\<le> dm\n\ngoal (1 subgoal):\n 1. d < length p'", "by auto"], ["proof (state)\nthis:\n  d < length p'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n       up dm lm d \\<alpha> x *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p ! d')) =\n       (\\<Sum>p''\\<in>lgrid x {d} lm - {x}.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "have \"up dm lm d \\<alpha> p' * ?prod d p' p =\n      (\\<Sum> p'' \\<in> ?leafs p'. \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d)) * ?prod d p' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up dm lm d \\<alpha> p' *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n    (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d)) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d'))", "using \\<open>p' \\<in> ?subgrid d p\\<close> up \\<open>Suc d \\<le> dm\\<close> p'_in_spg"], ["proof (prove)\nusing this:\n  p' \\<in> lgrid (base {0..<d} p) {0..<d} lm\n  \\<lbrakk>?d < ?dm; ?p \\<in> sparsegrid ?dm ?lm\\<rbrakk>\n  \\<Longrightarrow> up ?dm ?lm ?d ?\\<alpha> ?p =\n                    (\\<Sum>p'\\<in>lgrid ?p {?d} ?lm - {?p}.\n                       ?\\<alpha> p' * l2_\\<phi> (p' ! ?d) (?p ! ?d))\n  Suc d \\<le> dm\n  ?p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n  ?p' \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. up dm lm d \\<alpha> p' *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n    (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d)) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d'))", "by auto"], ["proof (state)\nthis:\n  up dm lm d \\<alpha> p' *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n     \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d)) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n       up dm lm d \\<alpha> x *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p ! d')) =\n       (\\<Sum>p''\\<in>lgrid x {d} lm - {x}.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  up dm lm d \\<alpha> p' *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n     \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d)) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n       up dm lm d \\<alpha> x *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p ! d')) =\n       (\\<Sum>p''\\<in>lgrid x {d} lm - {x}.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p'' \\<in> ?leafs p'. \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d) * ?prod d p' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d)) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n    (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')))", "using sum_distrib_right"], ["proof (prove)\nusing this:\n  sum ?f ?A * ?r = (\\<Sum>n\\<in>?A. ?f n * ?r)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d)) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n    (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n     \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d)) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n     \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d) *\n     (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n       up dm lm d \\<alpha> x *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p ! d')) =\n       (\\<Sum>p''\\<in>lgrid x {d} lm - {x}.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n     \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d)) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n     \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d) *\n     (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n       up dm lm d \\<alpha> x *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p ! d')) =\n       (\\<Sum>p''\\<in>lgrid x {d} lm - {x}.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p'' \\<in> ?leafs p'. \\<alpha> p'' * ?prod (Suc d) p'' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d'))) =\n    (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "proof (intro sum.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid p' {d} lm - {p'} \\<Longrightarrow>\n       \\<alpha> x * l2_\\<phi> (x ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "fix p''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid p' {d} lm - {p'} \\<Longrightarrow>\n       \\<alpha> x * l2_\\<phi> (x ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "assume \"p'' \\<in> ?leafs p'\""], ["proof (state)\nthis:\n  p'' \\<in> lgrid p' {d} lm - {p'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid p' {d} lm - {p'} \\<Longrightarrow>\n       \\<alpha> x * l2_\\<phi> (x ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "have \"?prod d p' p = ?prod d p'' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))", "proof (intro prod.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<d} \\<Longrightarrow>\n       l2_\\<phi> (p' ! x) (p ! x) = l2_\\<phi> (p'' ! x) (p ! x)", "fix d'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<d} \\<Longrightarrow>\n       l2_\\<phi> (p' ! x) (p ! x) = l2_\\<phi> (p'' ! x) (p ! x)", "assume \"d' \\<in> {0..<d}\""], ["proof (state)\nthis:\n  d' \\<in> {0..<d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<d} \\<Longrightarrow>\n       l2_\\<phi> (p' ! x) (p ! x) = l2_\\<phi> (p'' ! x) (p ! x)", "hence d_lt_p: \"d' < length p'\" and d'_not_d: \"d' \\<notin> {d}\""], ["proof (prove)\nusing this:\n  d' \\<in> {0..<d}\n\ngoal (1 subgoal):\n 1. d' < length p' &&& d' \\<notin> {d}", "using \\<open>d < length p'\\<close>"], ["proof (prove)\nusing this:\n  d' \\<in> {0..<d}\n  d < length p'\n\ngoal (1 subgoal):\n 1. d' < length p' &&& d' \\<notin> {d}", "by auto"], ["proof (state)\nthis:\n  d' < length p'\n  d' \\<notin> {d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<d} \\<Longrightarrow>\n       l2_\\<phi> (p' ! x) (p ! x) = l2_\\<phi> (p'' ! x) (p ! x)", "hence \"p' ! d' = p'' ! d'\""], ["proof (prove)\nusing this:\n  d' < length p'\n  d' \\<notin> {d}\n\ngoal (1 subgoal):\n 1. p' ! d' = p'' ! d'", "using \\<open>p'' \\<in> ?leafs p'\\<close> grid_invariant[OF d_lt_p d'_not_d]"], ["proof (prove)\nusing this:\n  d' < length p'\n  d' \\<notin> {d}\n  p'' \\<in> lgrid p' {d} lm - {p'}\n  ?p \\<in> grid p' {d} \\<Longrightarrow> ?p ! d' = p' ! d'\n\ngoal (1 subgoal):\n 1. p' ! d' = p'' ! d'", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  d' < length p'\n  d' \\<notin> {d}\n  p'' \\<in> {p \\<in> grid p' {d}. level p < lm} - {p'}\n  ?p \\<in> grid p' {d} \\<Longrightarrow> ?p ! d' = p' ! d'\n\ngoal (1 subgoal):\n 1. p' ! d' = p'' ! d'", "by auto"], ["proof (state)\nthis:\n  p' ! d' = p'' ! d'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<d} \\<Longrightarrow>\n       l2_\\<phi> (p' ! x) (p ! x) = l2_\\<phi> (p'' ! x) (p ! x)", "thus \"l2_\\<phi> (p'!d') (p!d') = l2_\\<phi> (p''!d') (p!d')\""], ["proof (prove)\nusing this:\n  p' ! d' = p'' ! d'\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p' ! d') (p ! d') = l2_\\<phi> (p'' ! d') (p ! d')", "by auto"], ["proof (state)\nthis:\n  l2_\\<phi> (p' ! d') (p ! d') = l2_\\<phi> (p'' ! d') (p ! d')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid p' {d} lm - {p'} \\<Longrightarrow>\n       \\<alpha> x * l2_\\<phi> (x ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "moreover"], ["proof (state)\nthis:\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid p' {d} lm - {p'} \\<Longrightarrow>\n       \\<alpha> x * l2_\\<phi> (x ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "have \"p' ! d = p ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' ! d = p ! d", "using \\<open>p' \\<in> ?subgrid d p\\<close> and grid_invariant[OF \\<open>d < length ?b\\<close>, where p=p' and ds=\"{0..<d}\"]"], ["proof (prove)\nusing this:\n  p' \\<in> lgrid (base {0..<d} p) {0..<d} lm\n  \\<lbrakk>d \\<notin> {0..<d};\n   p' \\<in> grid (base {0..<d} p) {0..<d}\\<rbrakk>\n  \\<Longrightarrow> p' ! d = base {0..<d} p ! d\n\ngoal (1 subgoal):\n 1. p' ! d = p ! d", "unfolding lgrid_def \\<open>p ! d = ?b ! d\\<close>"], ["proof (prove)\nusing this:\n  p' \\<in> {p \\<in> grid (base {0..<d} p) {0..<d}. level p < lm}\n  \\<lbrakk>d \\<notin> {0..<d};\n   p' \\<in> grid (base {0..<d} p) {0..<d}\\<rbrakk>\n  \\<Longrightarrow> p' ! d = base {0..<d} p ! d\n\ngoal (1 subgoal):\n 1. p' ! d = base {0..<d} p ! d", "by auto"], ["proof (state)\nthis:\n  p' ! d = p ! d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid p' {d} lm - {p'} \\<Longrightarrow>\n       \\<alpha> x * l2_\\<phi> (x ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n  p' ! d = p ! d", "have \"l2_\\<phi> (p'' ! d) (p' ! d) * ?prod d p' p =\n        l2_\\<phi> (p'' ! d) (p ! d) * ?prod d p'' p\""], ["proof (prove)\nusing this:\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n  p' ! d = p ! d\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p'' ! d) (p' ! d) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n    l2_\\<phi> (p'' ! d) (p ! d) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))", "by auto"], ["proof (state)\nthis:\n  l2_\\<phi> (p'' ! d) (p' ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  l2_\\<phi> (p'' ! d) (p ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid p' {d} lm - {p'} \\<Longrightarrow>\n       \\<alpha> x * l2_\\<phi> (x ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "also"], ["proof (state)\nthis:\n  l2_\\<phi> (p'' ! d) (p' ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  l2_\\<phi> (p'' ! d) (p ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid p' {d} lm - {p'} \\<Longrightarrow>\n       \\<alpha> x * l2_\\<phi> (x ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "have \"\\<dots> = ?prod (Suc d) p'' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2_\\<phi> (p'' ! d) (p ! d) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l2_\\<phi> (p'' ! d) (p ! d) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "have \"insert d {0..<d} = {0..<Suc d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert d {0..<d} = {0..<Suc d}", "by auto"], ["proof (state)\nthis:\n  insert d {0..<d} = {0..<Suc d}\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p'' ! d) (p ! d) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "moreover"], ["proof (state)\nthis:\n  insert d {0..<d} = {0..<Suc d}\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p'' ! d) (p ! d) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "from prod.insert"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> prod ?g (insert ?x ?A) = ?g ?x * prod ?g ?A", "have \"prod (\\<lambda> d'. l2_\\<phi> (p'' ! d') (p ! d')) (insert d {0..<d}) =\n          (\\<lambda> d'. l2_\\<phi> (p'' ! d') (p ! d')) d * prod (\\<lambda> d'. l2_\\<phi> (p'' ! d') (p ! d')) {0..<d}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> prod ?g (insert ?x ?A) = ?g ?x * prod ?g ?A\n\ngoal (1 subgoal):\n 1. (\\<Prod>d'\\<in>insert d {0..<d}. l2_\\<phi> (p'' ! d') (p ! d')) =\n    l2_\\<phi> (p'' ! d) (p ! d) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>d'\\<in>insert d {0..<d}. l2_\\<phi> (p'' ! d') (p ! d')) =\n  l2_\\<phi> (p'' ! d) (p ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p'' ! d) (p ! d) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "ultimately"], ["proof (chain)\npicking this:\n  insert d {0..<d} = {0..<Suc d}\n  (\\<Prod>d'\\<in>insert d {0..<d}. l2_\\<phi> (p'' ! d') (p ! d')) =\n  l2_\\<phi> (p'' ! d) (p ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))", "show ?thesis"], ["proof (prove)\nusing this:\n  insert d {0..<d} = {0..<Suc d}\n  (\\<Prod>d'\\<in>insert d {0..<d}. l2_\\<phi> (p'' ! d') (p ! d')) =\n  l2_\\<phi> (p'' ! d) (p ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p'' ! d) (p ! d) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "by auto"], ["proof (state)\nthis:\n  l2_\\<phi> (p'' ! d) (p ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) =\n  (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l2_\\<phi> (p'' ! d) (p ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) =\n  (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid p' {d} lm - {p'} \\<Longrightarrow>\n       \\<alpha> x * l2_\\<phi> (x ! d) (p' ! d) *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "finally"], ["proof (chain)\npicking this:\n  l2_\\<phi> (p'' ! d) (p' ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "show \"\\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d) * ?prod d p' p = \\<alpha> p'' * ?prod (Suc d) p'' p\""], ["proof (prove)\nusing this:\n  l2_\\<phi> (p'' ! d) (p' ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n    \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "by auto"], ["proof (state)\nthis:\n  \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n     \\<alpha> p'' * l2_\\<phi> (p'' ! d) (p' ! d) *\n     (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d'))) =\n  (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n       up dm lm d \\<alpha> x *\n       (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p ! d')) =\n       (\\<Sum>p''\\<in>lgrid x {d} lm - {x}.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "finally"], ["proof (chain)\npicking this:\n  up dm lm d \\<alpha> p' *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "show \"(up dm lm d \\<alpha>) p' * (?prod d p' p) = (\\<Sum> p'' \\<in> ?leafs p'. \\<alpha> p'' * ?prod (Suc d) p'' p)\""], ["proof (prove)\nusing this:\n  up dm lm d \\<alpha> p' *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. up dm lm d \\<alpha> p' *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n    (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "by auto"], ["proof (state)\nthis:\n  up dm lm d \\<alpha> p' *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')) =\n  (\\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n     up dm lm d \\<alpha> p' *\n     (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d'))) =\n  (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n     \\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n     up dm lm d \\<alpha> p' *\n     (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d'))) =\n  (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n     \\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> (p', p'') \\<in> Sigma (?subgrid d p) (\\<lambda>p'. (?leafs p')). (\\<alpha> p'') * (?prod (Suc d) p'' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n       \\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n         \\<alpha> p'' *\n         (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    (\\<Sum>(p', p'')\n           \\<in>(SIGMA p':lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "by (rule sum.Sigma, auto simp add: lgrid_finite)"], ["proof (state)\nthis:\n  (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n     \\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>(p', p'')\n         \\<in>(SIGMA p':lgrid (base {0..<d} p) {0..<d} lm.\n                  lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n     \\<Sum>p''\\<in>lgrid p' {d} lm - {p'}.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>(p', p'')\n         \\<in>(SIGMA p':lgrid (base {0..<d} p) {0..<d} lm.\n                  lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p''' \\<in> (\\<Union> p' \\<in> ?subgrid d p. (\\<Union> p'' \\<in> ?leafs p'. { (p', p'') })).\n    (((\\<lambda> p''. \\<alpha> p'' * ?prod (Suc d) p'' p) o snd) p''') )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(p', p'')\n           \\<in>(SIGMA p':lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    sum ((\\<lambda>p''.\n             \\<alpha> p'' *\n             (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n         snd)\n     (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n         \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')})", "unfolding Sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(p', p'')\n           \\<in>(\\<Union>x\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    \\<Union>y\\<in>lgrid x {d} lm - {x}. {(x, y)}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    sum ((\\<lambda>p''.\n             \\<alpha> p'' *\n             (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n         snd)\n     (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n         \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')})", "by (rule sum.cong[OF refl], auto)"], ["proof (state)\nthis:\n  (\\<Sum>(p', p'')\n         \\<in>(SIGMA p':lgrid (base {0..<d} p) {0..<d} lm.\n                  lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  sum ((\\<lambda>p''.\n           \\<alpha> p'' *\n           (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n       snd)\n   (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n       \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')})\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(p', p'')\n         \\<in>(SIGMA p':lgrid (base {0..<d} p) {0..<d} lm.\n                  lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  sum ((\\<lambda>p''.\n           \\<alpha> p'' *\n           (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n       snd)\n   (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n       \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')})\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p'' \\<in> snd ` (\\<Union> p' \\<in> ?subgrid d p. (\\<Union> p'' \\<in> ?leafs p'. { (p', p'') })).\n    \\<alpha> p'' * (?prod (Suc d) p'' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>p''.\n             \\<alpha> p'' *\n             (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n         snd)\n     (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n         \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')}) =\n    (\\<Sum>p''\\<in>snd `\n                   (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "unfolding lgrid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>p''.\n             \\<alpha> p'' *\n             (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n         snd)\n     (\\<Union>p'\\<in>{p \\<in> grid (base {0..<d} p) {0..<d}. level p < lm}.\n         \\<Union>p''\\<in>{p \\<in> grid p' {d}. level p < lm} - {p'}.\n            {(p', p'')}) =\n    (\\<Sum>p''\\<in>snd `\n                   (\\<Union>p'\\<in>{p \\<in> grid (base {0..<d} p) {0..<d}.\n                                    level p < lm}.\n                       \\<Union>p''\\<in>{p \\<in> grid p' {d}. level p < lm} -\n {p'}.\n                          {(p', p'')}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "by (rule sum.reindex[symmetric],\n        rule subset_inj_on[OF grid_grid_inj_on[OF ivl_disj_int(15)[where l=0 and m=\"d\" and u=\"d\"], where b=\"?b\"]])\n       auto"], ["proof (state)\nthis:\n  sum ((\\<lambda>p''.\n           \\<alpha> p'' *\n           (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n       snd)\n   (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n       \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')}) =\n  (\\<Sum>p''\\<in>snd `\n                 (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>p''.\n           \\<alpha> p'' *\n           (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n       snd)\n   (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n       \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')}) =\n  (\\<Sum>p''\\<in>snd `\n                 (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p'' \\<in> (\\<Union> p' \\<in> ?subgrid d p. (\\<Union> p'' \\<in> ?leafs p'. snd ` { (p', p'') })).\n    \\<alpha> p'' * (?prod (Suc d) p'' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>snd `\n                   (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       \\<Union>p''\\<in>lgrid p' {d} lm - {p'}.\n                          snd ` {(p', p'')}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "by (auto simp only: image_UN)"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>snd `\n                 (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     \\<Union>p''\\<in>lgrid p' {d} lm - {p'}.\n                        snd ` {(p', p'')}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>snd `\n                 (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     \\<Union>p''\\<in>lgrid p' {d} lm - {p'}. {(p', p'')}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     \\<Union>p''\\<in>lgrid p' {d} lm - {p'}.\n                        snd ` {(p', p'')}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p'' \\<in> (\\<Union> p' \\<in> ?subgrid d p. ?leafs p'). \\<alpha> p'' * (?prod (Suc d) p'' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       \\<Union>p''\\<in>lgrid p' {d} lm - {p'}.\n                          snd ` {(p', p'')}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       lgrid p' {d} lm - {p'}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     \\<Union>p''\\<in>lgrid p' {d} lm - {p'}.\n                        snd ` {(p', p'')}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "finally"], ["proof (chain)\npicking this:\n  updown' dm lm d (up dm lm d \\<alpha>) p =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "have up_part: \"updown' dm lm d (up dm lm d \\<alpha>) p = (\\<Sum> p'' \\<in> (\\<Union> p' \\<in> ?subgrid d p. ?leafs p'). \\<alpha> p'' * (?prod (Suc d) p'' p))\""], ["proof (prove)\nusing this:\n  updown' dm lm d (up dm lm d \\<alpha>) p =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. updown' dm lm d (up dm lm d \\<alpha>) p =\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       lgrid p' {d} lm - {p'}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "."], ["proof (state)\nthis:\n  updown' dm lm d (up dm lm d \\<alpha>) p =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"down dm lm d (updown' dm lm d \\<alpha>) p = (\\<Sum> p' \\<in> ?parents. (updown' dm lm d \\<alpha> p') * l2_\\<phi> (p ! d) (p' ! d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. down dm lm d (updown' dm lm d \\<alpha>) p =\n    (\\<Sum>p'\\<in>parents d (base {d} p) p.\n       updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d))", "using \\<open>Suc d \\<le> dm\\<close> and down and \\<open>p \\<in> sparsegrid dm lm\\<close>"], ["proof (prove)\nusing this:\n  Suc d \\<le> dm\n  \\<lbrakk>?d < ?dm; ?p \\<in> sparsegrid ?dm ?lm\\<rbrakk>\n  \\<Longrightarrow> down ?dm ?lm ?d ?\\<alpha> ?p =\n                    (\\<Sum>p'\\<in>parents ?d (base {?d} ?p) ?p.\n                       ?\\<alpha> p' * l2_\\<phi> (?p ! ?d) (p' ! ?d))\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. down dm lm d (updown' dm lm d \\<alpha>) p =\n    (\\<Sum>p'\\<in>parents d (base {d} p) p.\n       updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d))", "by auto"], ["proof (state)\nthis:\n  down dm lm d (updown' dm lm d \\<alpha>) p =\n  (\\<Sum>p'\\<in>parents d (base {d} p) p.\n     updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  down dm lm d (updown' dm lm d \\<alpha>) p =\n  (\\<Sum>p'\\<in>parents d (base {d} p) p.\n     updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p' \\<in> ?parents. \\<Sum> p'' \\<in> ?subgrid d p'. \\<alpha> p'' * ?prod (Suc d) p'' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p'\\<in>parents d (base {d} p) p.\n       updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d)) =\n    (\\<Sum>p'\\<in>parents d (base {d} p) p.\n       \\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n         \\<alpha> p'' *\n         (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "fix p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "let ?b' = \"base {d} p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "assume \"p' \\<in> ?parents\""], ["proof (state)\nthis:\n  p' \\<in> parents d (base {d} p) p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "hence p_lgrid: \"p' \\<in> lgrid ?b' {d} (level p + 1)\""], ["proof (prove)\nusing this:\n  p' \\<in> parents d (base {d} p) p\n\ngoal (1 subgoal):\n 1. p' \\<in> lgrid (base {d} p) {d} (level p + 1)", "using parents_subset_lgrid"], ["proof (prove)\nusing this:\n  p' \\<in> parents d (base {d} p) p\n  parents ?d ?b ?p \\<subseteq> lgrid ?b {?d} (level ?p + 1)\n\ngoal (1 subgoal):\n 1. p' \\<in> lgrid (base {d} p) {d} (level p + 1)", "by auto"], ["proof (state)\nthis:\n  p' \\<in> lgrid (base {d} p) {d} (level p + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "hence \"p' \\<in> sparsegrid dm lm\" and p'_spg': \"p' \\<in> sparsegrid' dm\""], ["proof (prove)\nusing this:\n  p' \\<in> lgrid (base {d} p) {d} (level p + 1)\n\ngoal (1 subgoal):\n 1. p' \\<in> sparsegrid dm lm &&& p' \\<in> sparsegrid' dm", "using \\<open>level p < lm\\<close> base_grid[OF p_spg']"], ["proof (prove)\nusing this:\n  p' \\<in> lgrid (base {d} p) {d} (level p + 1)\n  level p < lm\n  grid (base ?ds p) ?ds \\<subseteq> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. p' \\<in> sparsegrid dm lm &&& p' \\<in> sparsegrid' dm", "unfolding sparsegrid_def lgrid_def sparsegrid'_def"], ["proof (prove)\nusing this:\n  p' \\<in> {p \\<in> grid (base {d} p) {d}. level p < level p + 1}\n  level p < lm\n  grid (base ?ds p) ?ds \\<subseteq> grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. p' \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm} &&&\n    p' \\<in> grid (start dm) {0..<dm}", "by auto"], ["proof (state)\nthis:\n  p' \\<in> sparsegrid dm lm\n  p' \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "hence \"length p' = dm\""], ["proof (prove)\nusing this:\n  p' \\<in> sparsegrid dm lm\n  p' \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. length p' = dm", "unfolding sparsegrid_def lgrid_def"], ["proof (prove)\nusing this:\n  p' \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}\n  p' \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. length p' = dm", "by auto"], ["proof (state)\nthis:\n  length p' = dm\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "hence \"d < length p'\""], ["proof (prove)\nusing this:\n  length p' = dm\n\ngoal (1 subgoal):\n 1. d < length p'", "using \\<open>Suc d \\<le> dm\\<close>"], ["proof (prove)\nusing this:\n  length p' = dm\n  Suc d \\<le> dm\n\ngoal (1 subgoal):\n 1. d < length p'", "by auto"], ["proof (state)\nthis:\n  d < length p'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "from p_lgrid"], ["proof (chain)\npicking this:\n  p' \\<in> lgrid (base {d} p) {d} (level p + 1)", "have p'_grid: \"p' \\<in> grid ?b' {d}\""], ["proof (prove)\nusing this:\n  p' \\<in> lgrid (base {d} p) {d} (level p + 1)\n\ngoal (1 subgoal):\n 1. p' \\<in> grid (base {d} p) {d}", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  p' \\<in> {p \\<in> grid (base {d} p) {d}. level p < level p + 1}\n\ngoal (1 subgoal):\n 1. p' \\<in> grid (base {d} p) {d}", "by auto"], ["proof (state)\nthis:\n  p' \\<in> grid (base {d} p) {d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "have \"(updown' dm lm d \\<alpha> p') * l2_\\<phi> (p ! d) (p' !  d) = (\\<Sum> p'' \\<in> ?subgrid d p'. \\<alpha> p'' * ?prod d p'' p') * l2_\\<phi> (p ! d) (p' ! d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d) =\n    (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d'))) *\n    l2_\\<phi> (p ! d) (p' ! d)", "using \\<open>p' \\<in> sparsegrid dm lm\\<close> Suc"], ["proof (prove)\nusing this:\n  p' \\<in> sparsegrid dm lm\n  \\<lbrakk>d \\<le> dm; ?p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> updown' dm lm d ?\\<alpha> ?p =\n                    (\\<Sum>p'\\<in>lgrid (base {0..<d} ?p) {0..<d} lm.\n                       ?\\<alpha> p' *\n                       (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (?p ! d')))\n  Suc d \\<le> dm\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d) =\n    (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d'))) *\n    l2_\\<phi> (p ! d) (p' ! d)", "by auto"], ["proof (state)\nthis:\n  updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d) =\n  (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d'))) *\n  l2_\\<phi> (p ! d) (p' ! d)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d) =\n  (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d'))) *\n  l2_\\<phi> (p ! d) (p' ! d)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p'' \\<in> ?subgrid d p'. \\<alpha> p'' * ?prod d p'' p' * l2_\\<phi> (p ! d) (p' ! d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d'))) *\n    l2_\\<phi> (p ! d) (p' ! d) =\n    (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) *\n       l2_\\<phi> (p ! d) (p' ! d))", "using sum_distrib_right"], ["proof (prove)\nusing this:\n  sum ?f ?A * ?r = (\\<Sum>n\\<in>?A. ?f n * ?r)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d'))) *\n    l2_\\<phi> (p ! d) (p' ! d) =\n    (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) *\n       l2_\\<phi> (p ! d) (p' ! d))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d'))) *\n  l2_\\<phi> (p ! d) (p' ! d) =\n  (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) *\n     l2_\\<phi> (p ! d) (p' ! d))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d'))) *\n  l2_\\<phi> (p ! d) (p' ! d) =\n  (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) *\n     l2_\\<phi> (p ! d) (p' ! d))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p'' \\<in> ?subgrid d p'. \\<alpha> p'' * ?prod (Suc d) p'' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) *\n       l2_\\<phi> (p ! d) (p' ! d)) =\n    (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p') {0..<d} lm \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p' ! d')) *\n       l2_\\<phi> (p ! d) (p' ! d) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "fix p''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p') {0..<d} lm \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p' ! d')) *\n       l2_\\<phi> (p ! d) (p' ! d) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "assume \"p'' \\<in> ?subgrid d p'\""], ["proof (state)\nthis:\n  p'' \\<in> lgrid (base {0..<d} p') {0..<d} lm\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p') {0..<d} lm \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p' ! d')) *\n       l2_\\<phi> (p ! d) (p' ! d) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "have \"?prod d p'' p' = ?prod d p'' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) =\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))", "proof (rule prod.cong, rule refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<d} \\<Longrightarrow>\n       l2_\\<phi> (p'' ! x) (p' ! x) = l2_\\<phi> (p'' ! x) (p ! x)", "fix d'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<d} \\<Longrightarrow>\n       l2_\\<phi> (p'' ! x) (p' ! x) = l2_\\<phi> (p'' ! x) (p ! x)", "assume \"d' \\<in> {0..<d}\""], ["proof (state)\nthis:\n  d' \\<in> {0..<d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<d} \\<Longrightarrow>\n       l2_\\<phi> (p'' ! x) (p' ! x) = l2_\\<phi> (p'' ! x) (p ! x)", "hence \"d' < dm\" and \"d' \\<notin> {d}\""], ["proof (prove)\nusing this:\n  d' \\<in> {0..<d}\n\ngoal (1 subgoal):\n 1. d' < dm &&& d' \\<notin> {d}", "using \\<open>Suc d \\<le> dm\\<close>"], ["proof (prove)\nusing this:\n  d' \\<in> {0..<d}\n  Suc d \\<le> dm\n\ngoal (1 subgoal):\n 1. d' < dm &&& d' \\<notin> {d}", "by auto"], ["proof (state)\nthis:\n  d' < dm\n  d' \\<notin> {d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<d} \\<Longrightarrow>\n       l2_\\<phi> (p'' ! x) (p' ! x) = l2_\\<phi> (p'' ! x) (p ! x)", "from grid_base_out[OF this p_spg' p'_grid]"], ["proof (chain)\npicking this:\n  p' ! d' = p ! d'", "show \"l2_\\<phi> (p''!d') (p'!d') = l2_\\<phi> (p''!d') (p!d')\""], ["proof (prove)\nusing this:\n  p' ! d' = p ! d'\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p'' ! d') (p' ! d') = l2_\\<phi> (p'' ! d') (p ! d')", "by auto"], ["proof (state)\nthis:\n  l2_\\<phi> (p'' ! d') (p' ! d') = l2_\\<phi> (p'' ! d') (p ! d')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) =\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p') {0..<d} lm \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p' ! d')) *\n       l2_\\<phi> (p ! d) (p' ! d) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "moreover"], ["proof (state)\nthis:\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) =\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p') {0..<d} lm \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p' ! d')) *\n       l2_\\<phi> (p ! d) (p' ! d) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "have \"l2_\\<phi> (p ! d) (p' ! d) = l2_\\<phi> (p'' ! d) (p ! d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2_\\<phi> (p ! d) (p' ! d) = l2_\\<phi> (p'' ! d) (p ! d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l2_\\<phi> (p ! d) (p' ! d) = l2_\\<phi> (p'' ! d) (p ! d)", "have \"d < dm\" and \"d \\<notin> {0..<d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < dm &&& d \\<notin> {0..<d}", "using \\<open>Suc d \\<le> dm\\<close> base_length p'_spg'"], ["proof (prove)\nusing this:\n  Suc d \\<le> dm\n  ?p \\<in> sparsegrid' ?dm \\<Longrightarrow> length (base ?ds ?p) = ?dm\n  p' \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. d < dm &&& d \\<notin> {0..<d}", "by auto"], ["proof (state)\nthis:\n  d < dm\n  d \\<notin> {0..<d}\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p ! d) (p' ! d) = l2_\\<phi> (p'' ! d) (p ! d)", "from grid_base_out[OF this p'_spg'] \\<open>p'' \\<in> ?subgrid d p'\\<close>[unfolded lgrid_def]"], ["proof (chain)\npicking this:\n  ?p \\<in> grid (base {0..<d} p') {0..<d} \\<Longrightarrow> ?p ! d = p' ! d\n  p'' \\<in> {p \\<in> grid (base {0..<d} p') {0..<d}. level p < lm}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?p \\<in> grid (base {0..<d} p') {0..<d} \\<Longrightarrow> ?p ! d = p' ! d\n  p'' \\<in> {p \\<in> grid (base {0..<d} p') {0..<d}. level p < lm}\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p ! d) (p' ! d) = l2_\\<phi> (p'' ! d) (p ! d)", "using l2_commutative"], ["proof (prove)\nusing this:\n  ?p \\<in> grid (base {0..<d} p') {0..<d} \\<Longrightarrow> ?p ! d = p' ! d\n  p'' \\<in> {p \\<in> grid (base {0..<d} p') {0..<d}. level p < lm}\n  l2_\\<phi> ?p ?q = l2_\\<phi> ?q ?p\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p ! d) (p' ! d) = l2_\\<phi> (p'' ! d) (p ! d)", "by auto"], ["proof (state)\nthis:\n  l2_\\<phi> (p ! d) (p' ! d) = l2_\\<phi> (p'' ! d) (p ! d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l2_\\<phi> (p ! d) (p' ! d) = l2_\\<phi> (p'' ! d) (p ! d)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p') {0..<d} lm \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p' ! d')) *\n       l2_\\<phi> (p ! d) (p' ! d) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "moreover"], ["proof (state)\nthis:\n  l2_\\<phi> (p ! d) (p' ! d) = l2_\\<phi> (p'' ! d) (p ! d)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p') {0..<d} lm \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p' ! d')) *\n       l2_\\<phi> (p ! d) (p' ! d) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "have \"?prod d p'' p * l2_\\<phi> (p'' ! d) (p ! d) = ?prod (Suc d) p'' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n    l2_\\<phi> (p'' ! d) (p ! d) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n    l2_\\<phi> (p'' ! d) (p ! d) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "have \"insert d {0..<d} = {0..<Suc d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert d {0..<d} = {0..<Suc d}", "by auto"], ["proof (state)\nthis:\n  insert d {0..<d} = {0..<Suc d}\n\ngoal (1 subgoal):\n 1. (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n    l2_\\<phi> (p'' ! d) (p ! d) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "moreover"], ["proof (state)\nthis:\n  insert d {0..<d} = {0..<Suc d}\n\ngoal (1 subgoal):\n 1. (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n    l2_\\<phi> (p'' ! d) (p ! d) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "from prod.insert"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> prod ?g (insert ?x ?A) = ?g ?x * prod ?g ?A", "have \"(\\<lambda> d'. l2_\\<phi> (p'' ! d') (p ! d')) d * prod (\\<lambda> d'. l2_\\<phi> (p'' ! d') (p ! d')) {0..<d} =\n          prod (\\<lambda> d'. l2_\\<phi> (p'' ! d') (p ! d')) (insert d {0..<d})\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> prod ?g (insert ?x ?A) = ?g ?x * prod ?g ?A\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p'' ! d) (p ! d) *\n    (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) =\n    (\\<Prod>d'\\<in>insert d {0..<d}. l2_\\<phi> (p'' ! d') (p ! d'))", "by auto"], ["proof (state)\nthis:\n  l2_\\<phi> (p'' ! d) (p ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) =\n  (\\<Prod>d'\\<in>insert d {0..<d}. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n    l2_\\<phi> (p'' ! d) (p ! d) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "hence \"(prod (\\<lambda> d'. l2_\\<phi> (p'' ! d') (p ! d')) {0..<d}) * (\\<lambda> d'. l2_\\<phi> (p'' ! d') (p ! d')) d =\n          prod (\\<lambda> d'. l2_\\<phi> (p'' ! d') (p ! d')) (insert d {0..<d})\""], ["proof (prove)\nusing this:\n  l2_\\<phi> (p'' ! d) (p ! d) *\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) =\n  (\\<Prod>d'\\<in>insert d {0..<d}. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n    l2_\\<phi> (p'' ! d) (p ! d) =\n    (\\<Prod>d'\\<in>insert d {0..<d}. l2_\\<phi> (p'' ! d') (p ! d'))", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n  l2_\\<phi> (p'' ! d) (p ! d) =\n  (\\<Prod>d'\\<in>insert d {0..<d}. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n    l2_\\<phi> (p'' ! d) (p ! d) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "ultimately"], ["proof (chain)\npicking this:\n  insert d {0..<d} = {0..<Suc d}\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n  l2_\\<phi> (p'' ! d) (p ! d) =\n  (\\<Prod>d'\\<in>insert d {0..<d}. l2_\\<phi> (p'' ! d') (p ! d'))", "show ?thesis"], ["proof (prove)\nusing this:\n  insert d {0..<d} = {0..<Suc d}\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n  l2_\\<phi> (p'' ! d) (p ! d) =\n  (\\<Prod>d'\\<in>insert d {0..<d}. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n    l2_\\<phi> (p'' ! d) (p ! d) =\n    (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n  l2_\\<phi> (p'' ! d) (p ! d) =\n  (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n  l2_\\<phi> (p'' ! d) (p ! d) =\n  (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<d} p') {0..<d} lm \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<d. l2_\\<phi> (x ! d') (p' ! d')) *\n       l2_\\<phi> (p ! d) (p' ! d) =\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d'))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) =\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n  l2_\\<phi> (p ! d) (p' ! d) = l2_\\<phi> (p'' ! d) (p ! d)\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n  l2_\\<phi> (p'' ! d) (p ! d) =\n  (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "show \"\\<alpha> p'' * ?prod d p'' p' * l2_\\<phi> (p ! d) (p' ! d) = \\<alpha> p'' * ?prod (Suc d) p'' p\""], ["proof (prove)\nusing this:\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) =\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d'))\n  l2_\\<phi> (p ! d) (p' ! d) = l2_\\<phi> (p'' ! d) (p ! d)\n  (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p ! d')) *\n  l2_\\<phi> (p'' ! d) (p ! d) =\n  (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal (1 subgoal):\n 1. \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) *\n    l2_\\<phi> (p ! d) (p' ! d) =\n    \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))", "by auto"], ["proof (state)\nthis:\n  \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) *\n  l2_\\<phi> (p ! d) (p' ! d) =\n  \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p'' ! d') (p' ! d')) *\n     l2_\\<phi> (p ! d) (p' ! d)) =\n  (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d (base {d} p) p \\<Longrightarrow>\n       updown' dm lm d \\<alpha> x * l2_\\<phi> (p ! d) (x ! d) =\n       (\\<Sum>p''\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n          \\<alpha> p'' *\n          (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "finally"], ["proof (chain)\npicking this:\n  updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d) =\n  (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "show \"(updown' dm lm d \\<alpha> p') * l2_\\<phi> (p ! d) (p' ! d) = (\\<Sum> p'' \\<in> ?subgrid d p'. \\<alpha> p'' * ?prod (Suc d) p'' p)\""], ["proof (prove)\nusing this:\n  updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d) =\n  (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d) =\n    (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "by auto"], ["proof (state)\nthis:\n  updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d) =\n  (\\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p'\\<in>parents d (base {d} p) p.\n     updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d)) =\n  (\\<Sum>p'\\<in>parents d (base {d} p) p.\n     \\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p'\\<in>parents d (base {d} p) p.\n     updown' dm lm d \\<alpha> p' * l2_\\<phi> (p ! d) (p' ! d)) =\n  (\\<Sum>p'\\<in>parents d (base {d} p) p.\n     \\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> (p', p'') \\<in> (Sigma ?parents (?subgrid d)). \\<alpha> p'' * ?prod (Suc d) p'' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p'\\<in>parents d (base {d} p) p.\n       \\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n         \\<alpha> p'' *\n         (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    (\\<Sum>(p', p'')\n           \\<in>(SIGMA a:parents d (base {d} p) p.\n                    lgrid (base {0..<d} a) {0..<d} lm).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "by (rule sum.Sigma, auto simp add: parents_finite lgrid_finite)"], ["proof (state)\nthis:\n  (\\<Sum>p'\\<in>parents d (base {d} p) p.\n     \\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>(p', p'')\n         \\<in>(SIGMA a:parents d (base {d} p) p.\n                  lgrid (base {0..<d} a) {0..<d} lm).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p'\\<in>parents d (base {d} p) p.\n     \\<Sum>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>(p', p'')\n         \\<in>(SIGMA a:parents d (base {d} p) p.\n                  lgrid (base {0..<d} a) {0..<d} lm).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p''' \\<in> (\\<Union> p' \\<in> ?parents. (\\<Union> p'' \\<in> ?subgrid d p'. { (p', p'') })).\n    ( ((\\<lambda> p''. \\<alpha> p'' * ?prod (Suc d) p'' p) o snd) p''') )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(p', p'')\n           \\<in>(SIGMA a:parents d (base {d} p) p.\n                    lgrid (base {0..<d} a) {0..<d} lm).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    sum ((\\<lambda>p''.\n             \\<alpha> p'' *\n             (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n         snd)\n     (\\<Union>p'\\<in>parents d (base {d} p) p.\n         \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm. {(p', p'')})", "unfolding Sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(p', p'')\n           \\<in>(\\<Union>x\\<in>parents d (base {d} p) p.\n                    \\<Union>y\\<in>lgrid (base {0..<d} x) {0..<d} lm.\n                       {(x, y)}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    sum ((\\<lambda>p''.\n             \\<alpha> p'' *\n             (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n         snd)\n     (\\<Union>p'\\<in>parents d (base {d} p) p.\n         \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm. {(p', p'')})", "by (rule sum.cong[OF refl], auto)"], ["proof (state)\nthis:\n  (\\<Sum>(p', p'')\n         \\<in>(SIGMA a:parents d (base {d} p) p.\n                  lgrid (base {0..<d} a) {0..<d} lm).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  sum ((\\<lambda>p''.\n           \\<alpha> p'' *\n           (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n       snd)\n   (\\<Union>p'\\<in>parents d (base {d} p) p.\n       \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm. {(p', p'')})\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(p', p'')\n         \\<in>(SIGMA a:parents d (base {d} p) p.\n                  lgrid (base {0..<d} a) {0..<d} lm).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  sum ((\\<lambda>p''.\n           \\<alpha> p'' *\n           (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n       snd)\n   (\\<Union>p'\\<in>parents d (base {d} p) p.\n       \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm. {(p', p'')})\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p'' \\<in> snd ` (\\<Union> p' \\<in> ?parents. (\\<Union> p'' \\<in> ?subgrid d p'. { (p', p'') })). \\<alpha> p'' * (?prod (Suc d) p'' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>p''.\n             \\<alpha> p'' *\n             (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n         snd)\n     (\\<Union>p'\\<in>parents d (base {d} p) p.\n         \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm. {(p', p'')}) =\n    (\\<Sum>p''\\<in>snd `\n                   (\\<Union>p'\\<in>parents d (base {d} p) p.\n                       \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                          {(p', p'')}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "proof (rule sum.reindex[symmetric], rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                            \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d}\n       lm.\n                               {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                       {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                            \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d}\n       lm.\n                               {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                       {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p. \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm. {(p', p'')})\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n              \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                 {(p', p'')})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                            \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d}\n       lm.\n                               {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                       {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence x_snd: \"snd x \\<in> grid (base {0..<d} (fst x)) {0..<d}\" and \"fst x \\<in> grid (base {d} p) {d}\" and \"p \\<in> grid (fst x) {d}\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n              \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                 {(p', p'')})\n\ngoal (1 subgoal):\n 1. snd x \\<in> grid (base {0..<d} (fst x)) {0..<d} &&&\n    fst x \\<in> grid (base {d} p) {d} &&& p \\<in> grid (fst x) {d}", "unfolding parents_def lgrid_def"], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>p'\\<in>{x \\<in> grid (base {d} p) {d}.\n                           p \\<in> grid x {d}}.\n              \\<Union>p''\\<in>{p \\<in> grid (base {0..<d} p') {0..<d}.\n                               level p < lm}.\n                 {(p', p'')})\n\ngoal (1 subgoal):\n 1. snd x \\<in> grid (base {0..<d} (fst x)) {0..<d} &&&\n    fst x \\<in> grid (base {d} p) {d} &&& p \\<in> grid (fst x) {d}", "by auto"], ["proof (state)\nthis:\n  snd x \\<in> grid (base {0..<d} (fst x)) {0..<d}\n  fst x \\<in> grid (base {d} p) {d}\n  p \\<in> grid (fst x) {d}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                            \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d}\n       lm.\n                               {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                       {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence x_spg: \"fst x \\<in> sparsegrid' dm\""], ["proof (prove)\nusing this:\n  snd x \\<in> grid (base {0..<d} (fst x)) {0..<d}\n  fst x \\<in> grid (base {d} p) {d}\n  p \\<in> grid (fst x) {d}\n\ngoal (1 subgoal):\n 1. fst x \\<in> sparsegrid' dm", "using base_grid[OF p_spg']"], ["proof (prove)\nusing this:\n  snd x \\<in> grid (base {0..<d} (fst x)) {0..<d}\n  fst x \\<in> grid (base {d} p) {d}\n  p \\<in> grid (fst x) {d}\n  grid (base ?ds p) ?ds \\<subseteq> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. fst x \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  fst x \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                            \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d}\n       lm.\n                               {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                       {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p. \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm. {(p', p'')})\""], ["proof (state)\nthis:\n  y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n              \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                 {(p', p'')})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                            \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d}\n       lm.\n                               {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                       {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence y_snd: \"snd y \\<in> grid (base {0..<d} (fst y)) {0..<d}\" and \"fst y \\<in> grid (base {d} p) {d}\" and \"p \\<in> grid (fst y) {d}\""], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n              \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                 {(p', p'')})\n\ngoal (1 subgoal):\n 1. snd y \\<in> grid (base {0..<d} (fst y)) {0..<d} &&&\n    fst y \\<in> grid (base {d} p) {d} &&& p \\<in> grid (fst y) {d}", "unfolding parents_def lgrid_def"], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>p'\\<in>{x \\<in> grid (base {d} p) {d}.\n                           p \\<in> grid x {d}}.\n              \\<Union>p''\\<in>{p \\<in> grid (base {0..<d} p') {0..<d}.\n                               level p < lm}.\n                 {(p', p'')})\n\ngoal (1 subgoal):\n 1. snd y \\<in> grid (base {0..<d} (fst y)) {0..<d} &&&\n    fst y \\<in> grid (base {d} p) {d} &&& p \\<in> grid (fst y) {d}", "by auto"], ["proof (state)\nthis:\n  snd y \\<in> grid (base {0..<d} (fst y)) {0..<d}\n  fst y \\<in> grid (base {d} p) {d}\n  p \\<in> grid (fst y) {d}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                            \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d}\n       lm.\n                               {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                       {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence y_spg: \"fst y \\<in> sparsegrid' dm\""], ["proof (prove)\nusing this:\n  snd y \\<in> grid (base {0..<d} (fst y)) {0..<d}\n  fst y \\<in> grid (base {d} p) {d}\n  p \\<in> grid (fst y) {d}\n\ngoal (1 subgoal):\n 1. fst y \\<in> sparsegrid' dm", "using base_grid[OF p_spg']"], ["proof (prove)\nusing this:\n  snd y \\<in> grid (base {0..<d} (fst y)) {0..<d}\n  fst y \\<in> grid (base {d} p) {d}\n  p \\<in> grid (fst y) {d}\n  grid (base ?ds p) ?ds \\<subseteq> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. fst y \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  fst y \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                            \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d}\n       lm.\n                               {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                       {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"length (fst y) = dm\""], ["proof (prove)\nusing this:\n  fst y \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. length (fst y) = dm", "unfolding sparsegrid'_def"], ["proof (prove)\nusing this:\n  fst y \\<in> grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. length (fst y) = dm", "by auto"], ["proof (state)\nthis:\n  length (fst y) = dm\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                            \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d}\n       lm.\n                               {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                       {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"snd x = snd y\""], ["proof (state)\nthis:\n  snd x = snd y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                            \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d}\n       lm.\n                               {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                       {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"fst x = fst y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x = fst y", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (fst x) = length (fst y)\n 2. \\<And>i. i < length (fst x) \\<Longrightarrow> fst x ! i = fst y ! i", "show l_eq: \"length (fst x) = length (fst y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst x) = length (fst y)", "using grid_length[OF \\<open>p \\<in> grid (fst y) {d}\\<close>] grid_length[OF \\<open>p \\<in> grid (fst x) {d}\\<close>]"], ["proof (prove)\nusing this:\n  length p = length (fst y)\n  length p = length (fst x)\n\ngoal (1 subgoal):\n 1. length (fst x) = length (fst y)", "by auto"], ["proof (state)\nthis:\n  length (fst x) = length (fst y)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length (fst x) \\<Longrightarrow> fst x ! i = fst y ! i", "show \"fst x ! i = fst y ! i\" if \"i < length (fst x)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x ! i = fst y ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst x ! i = fst y ! i", "have \"i < length (fst y)\" and \"i < dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (fst y) &&& i < dm", "using that l_eq and \\<open>length (fst y) = dm\\<close>"], ["proof (prove)\nusing this:\n  i < length (fst x)\n  length (fst x) = length (fst y)\n  length (fst y) = dm\n\ngoal (1 subgoal):\n 1. i < length (fst y) &&& i < dm", "by auto"], ["proof (state)\nthis:\n  i < length (fst y)\n  i < dm\n\ngoal (1 subgoal):\n 1. fst x ! i = fst y ! i", "show \"fst x ! i = fst y ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x ! i = fst y ! i", "proof (cases \"i = d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = d \\<Longrightarrow> fst x ! i = fst y ! i\n 2. i \\<noteq> d \\<Longrightarrow> fst x ! i = fst y ! i", "case False"], ["proof (state)\nthis:\n  i \\<noteq> d\n\ngoal (2 subgoals):\n 1. i = d \\<Longrightarrow> fst x ! i = fst y ! i\n 2. i \\<noteq> d \\<Longrightarrow> fst x ! i = fst y ! i", "hence \"i \\<notin> {d}\""], ["proof (prove)\nusing this:\n  i \\<noteq> d\n\ngoal (1 subgoal):\n 1. i \\<notin> {d}", "by auto"], ["proof (state)\nthis:\n  i \\<notin> {d}\n\ngoal (2 subgoals):\n 1. i = d \\<Longrightarrow> fst x ! i = fst y ! i\n 2. i \\<noteq> d \\<Longrightarrow> fst x ! i = fst y ! i", "with grid_invariant[OF \\<open>i < length (fst x)\\<close> this \\<open>p \\<in> grid (fst x) {d}\\<close>]\n            grid_invariant[OF \\<open>i < length (fst y)\\<close> this \\<open>p \\<in> grid (fst y) {d}\\<close>]"], ["proof (chain)\npicking this:\n  p ! i = fst x ! i\n  p ! i = fst y ! i\n  i \\<notin> {d}", "show ?thesis"], ["proof (prove)\nusing this:\n  p ! i = fst x ! i\n  p ! i = fst y ! i\n  i \\<notin> {d}\n\ngoal (1 subgoal):\n 1. fst x ! i = fst y ! i", "by auto"], ["proof (state)\nthis:\n  fst x ! i = fst y ! i\n\ngoal (1 subgoal):\n 1. i = d \\<Longrightarrow> fst x ! i = fst y ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = d \\<Longrightarrow> fst x ! i = fst y ! i", "case True"], ["proof (state)\nthis:\n  i = d\n\ngoal (1 subgoal):\n 1. i = d \\<Longrightarrow> fst x ! i = fst y ! i", "with grid_base_out[OF \\<open>i < dm\\<close> _ y_spg y_snd] grid_base_out[OF \\<open>i < dm\\<close> _ x_spg x_snd]"], ["proof (chain)\npicking this:\n  i \\<notin> {0..<d} \\<Longrightarrow> snd y ! i = fst y ! i\n  i \\<notin> {0..<d} \\<Longrightarrow> snd x ! i = fst x ! i\n  i = d", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> {0..<d} \\<Longrightarrow> snd y ! i = fst y ! i\n  i \\<notin> {0..<d} \\<Longrightarrow> snd x ! i = fst x ! i\n  i = d\n\ngoal (1 subgoal):\n 1. fst x ! i = fst y ! i", "using \\<open>snd x = snd y\\<close>"], ["proof (prove)\nusing this:\n  i \\<notin> {0..<d} \\<Longrightarrow> snd y ! i = fst y ! i\n  i \\<notin> {0..<d} \\<Longrightarrow> snd x ! i = fst x ! i\n  i = d\n  snd x = snd y\n\ngoal (1 subgoal):\n 1. fst x ! i = fst y ! i", "by auto"], ["proof (state)\nthis:\n  fst x ! i = fst y ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst x ! i = fst y ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length (fst x) \\<Longrightarrow> fst x ! ?i = fst y ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst x = fst y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                            \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d}\n       lm.\n                               {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                       {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using prod_eqI[OF \\<open>fst x = fst y\\<close> \\<open>snd x = snd y\\<close>]"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y", "."], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum ((\\<lambda>p''.\n           \\<alpha> p'' *\n           (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n       snd)\n   (\\<Union>p'\\<in>parents d (base {d} p) p.\n       \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm. {(p', p'')}) =\n  (\\<Sum>p''\\<in>snd `\n                 (\\<Union>p'\\<in>parents d (base {d} p) p.\n                     \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                        {(p', p'')}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>p''.\n           \\<alpha> p'' *\n           (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) \\<circ>\n       snd)\n   (\\<Union>p'\\<in>parents d (base {d} p) p.\n       \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm. {(p', p'')}) =\n  (\\<Sum>p''\\<in>snd `\n                 (\\<Union>p'\\<in>parents d (base {d} p) p.\n                     \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                        {(p', p'')}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p'' \\<in> (\\<Union> p' \\<in> ?parents. (\\<Union> p'' \\<in> ?subgrid d p'. snd ` { (p', p'') })).\n    \\<alpha> p'' * (?prod (Suc d) p'' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>snd `\n                   (\\<Union>p'\\<in>parents d (base {d} p) p.\n                       \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                          {(p', p'')}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                       \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                          snd ` {(p', p'')}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "by (auto simp only: image_UN)"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>snd `\n                 (\\<Union>p'\\<in>parents d (base {d} p) p.\n                     \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                        {(p', p'')}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                     \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                        snd ` {(p', p'')}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>snd `\n                 (\\<Union>p'\\<in>parents d (base {d} p) p.\n                     \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                        {(p', p'')}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                     \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                        snd ` {(p', p'')}).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p'' \\<in> (\\<Union> p' \\<in> ?parents. ?subgrid d p'). \\<alpha> p'' * ?prod (Suc d) p'' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                       \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                          snd ` {(p', p'')}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                       lgrid (base {0..<d} p') {0..<d} lm).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                     \\<Union>p''\\<in>lgrid (base {0..<d} p') {0..<d} lm.\n                        snd ` {(p', p'')}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                     lgrid (base {0..<d} p') {0..<d} lm).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "finally"], ["proof (chain)\npicking this:\n  down dm lm d (updown' dm lm d \\<alpha>) p =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                     lgrid (base {0..<d} p') {0..<d} lm).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "have down_part: \"down dm lm d (updown' dm lm d \\<alpha>) p =\n    (\\<Sum> p'' \\<in> (\\<Union> p' \\<in> ?parents. ?subgrid d p'). \\<alpha> p'' * ?prod (Suc d) p'' p)\""], ["proof (prove)\nusing this:\n  down dm lm d (updown' dm lm d \\<alpha>) p =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                     lgrid (base {0..<d} p') {0..<d} lm).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. down dm lm d (updown' dm lm d \\<alpha>) p =\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                       lgrid (base {0..<d} p') {0..<d} lm).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "."], ["proof (state)\nthis:\n  down dm lm d (updown' dm lm d \\<alpha>) p =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                     lgrid (base {0..<d} p') {0..<d} lm).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"updown' dm lm (Suc d) \\<alpha> p =\n    (\\<Sum> p'' \\<in> (\\<Union> p' \\<in> ?subgrid d p. ?leafs p'). \\<alpha> p'' * ?prod (Suc d) p'' p) +\n    (\\<Sum> p'' \\<in> (\\<Union> p' \\<in> ?parents. ?subgrid d p'). \\<alpha> p'' * ?prod (Suc d) p'' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. updown' dm lm (Suc d) \\<alpha> p =\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       lgrid p' {d} lm - {p'}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) +\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                       lgrid (base {0..<d} p') {0..<d} lm).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "unfolding sum_vector_def updown'.simps down_part and up_part"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       lgrid p' {d} lm - {p'}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) +\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                       lgrid (base {0..<d} p') {0..<d} lm).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       lgrid p' {d} lm - {p'}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) +\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                       lgrid (base {0..<d} p') {0..<d} lm).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", ".."], ["proof (state)\nthis:\n  updown' dm lm (Suc d) \\<alpha> p =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) +\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                     lgrid (base {0..<d} p') {0..<d} lm).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  updown' dm lm (Suc d) \\<alpha> p =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) +\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                     lgrid (base {0..<d} p') {0..<d} lm).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p'' \\<in> (\\<Union> p' \\<in> ?subgrid d p. ?leafs p') \\<union> (\\<Union> p' \\<in> ?parents. ?subgrid d p'). \\<alpha> p'' * ?prod (Suc d) p'' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       lgrid p' {d} lm - {p'}).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) +\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                       lgrid (base {0..<d} p') {0..<d} lm).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       lgrid p' {d} lm - {p'}) \\<union>\n                   (\\<Union>p'\\<in>parents d (base {d} p) p.\n                       lgrid (base {0..<d} p') {0..<d} lm).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))", "proof (rule sum.union_disjoint[symmetric], simp add: lgrid_finite, simp add: lgrid_finite parents_finite,\n         rule iffD2[OF disjoint_iff_not_equal], rule ballI, rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "assume \"x \\<in> (\\<Union> p' \\<in> ?subgrid d p. ?leafs p')\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n              lgrid p' {d} lm - {p'})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n              lgrid p' {d} lm - {p'})", "obtain px where \"px \\<in> grid (base {0..<d} p) {0..<d}\" and \"x \\<in> grid px {d}\" and \"x \\<noteq> px\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n              lgrid p' {d} lm - {p'})\n\ngoal (1 subgoal):\n 1. (\\<And>px.\n        \\<lbrakk>px \\<in> grid (base {0..<d} p) {0..<d};\n         x \\<in> grid px {d}; x \\<noteq> px\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>p'\\<in>{p \\<in> grid (base {0..<d} p) {0..<d}.\n                           level p < lm}.\n              {p \\<in> grid p' {d}. level p < lm} - {p'})\n\ngoal (1 subgoal):\n 1. (\\<And>px.\n        \\<lbrakk>px \\<in> grid (base {0..<d} p) {0..<d};\n         x \\<in> grid px {d}; x \\<noteq> px\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  px \\<in> grid (base {0..<d} p) {0..<d}\n  x \\<in> grid px {d}\n  x \\<noteq> px\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "with grid_base_out[OF _ _ p_spg' this(1)] \\<open>Suc d \\<le> dm\\<close> base_length[OF p_spg'] grid_level_d"], ["proof (chain)\npicking this:\n  \\<lbrakk>?d < dm; ?d \\<notin> {0..<d}\\<rbrakk>\n  \\<Longrightarrow> px ! ?d = p ! ?d\n  Suc d \\<le> dm\n  length (base ?ds p) = dm\n  \\<lbrakk>?d < length ?b; ?p \\<in> grid ?b {?d}; ?p \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> lv ?b ?d < lv ?p ?d\n  px \\<in> grid (base {0..<d} p) {0..<d}\n  x \\<in> grid px {d}\n  x \\<noteq> px", "have \"lv px d < lv x d\" and \"px ! d = p ! d\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?d < dm; ?d \\<notin> {0..<d}\\<rbrakk>\n  \\<Longrightarrow> px ! ?d = p ! ?d\n  Suc d \\<le> dm\n  length (base ?ds p) = dm\n  \\<lbrakk>?d < length ?b; ?p \\<in> grid ?b {?d}; ?p \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> lv ?b ?d < lv ?p ?d\n  px \\<in> grid (base {0..<d} p) {0..<d}\n  x \\<in> grid px {d}\n  x \\<noteq> px\n\ngoal (1 subgoal):\n 1. lv px d < lv x d &&& px ! d = p ! d", "by auto"], ["proof (state)\nthis:\n  lv px d < lv x d\n  px ! d = p ! d\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "hence \"lv p d < lv x d\""], ["proof (prove)\nusing this:\n  lv px d < lv x d\n  px ! d = p ! d\n\ngoal (1 subgoal):\n 1. lv p d < lv x d", "unfolding lv_def"], ["proof (prove)\nusing this:\n  fst (px ! d) < fst (x ! d)\n  px ! d = p ! d\n\ngoal (1 subgoal):\n 1. fst (p ! d) < fst (x ! d)", "by auto"], ["proof (state)\nthis:\n  lv p d < lv x d\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "moreover"], ["proof (state)\nthis:\n  lv p d < lv x d\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "assume \"y \\<in> (\\<Union> p' \\<in> ?parents. ?subgrid d p')\""], ["proof (state)\nthis:\n  y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n              lgrid (base {0..<d} p') {0..<d} lm)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "then"], ["proof (chain)\npicking this:\n  y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n              lgrid (base {0..<d} p') {0..<d} lm)", "obtain py where y_grid: \"y \\<in> grid (base {0..<d} py) {0..<d}\" and \"py \\<in> ?parents\""], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n              lgrid (base {0..<d} p') {0..<d} lm)\n\ngoal (1 subgoal):\n 1. (\\<And>py.\n        \\<lbrakk>y \\<in> grid (base {0..<d} py) {0..<d};\n         py \\<in> parents d (base {d} p) p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n              {p \\<in> grid (base {0..<d} p') {0..<d}. level p < lm})\n\ngoal (1 subgoal):\n 1. (\\<And>py.\n        \\<lbrakk>y \\<in> grid (base {0..<d} py) {0..<d};\n         py \\<in> parents d (base {d} p) p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> grid (base {0..<d} py) {0..<d}\n  py \\<in> parents d (base {d} p) p\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "hence \"py \\<in> grid (base {d} p) {d}\" and \"p \\<in> grid py {d}\""], ["proof (prove)\nusing this:\n  y \\<in> grid (base {0..<d} py) {0..<d}\n  py \\<in> parents d (base {d} p) p\n\ngoal (1 subgoal):\n 1. py \\<in> grid (base {d} p) {d} &&& p \\<in> grid py {d}", "unfolding parents_def"], ["proof (prove)\nusing this:\n  y \\<in> grid (base {0..<d} py) {0..<d}\n  py \\<in> {x \\<in> grid (base {d} p) {d}. p \\<in> grid x {d}}\n\ngoal (1 subgoal):\n 1. py \\<in> grid (base {d} p) {d} &&& p \\<in> grid py {d}", "by auto"], ["proof (state)\nthis:\n  py \\<in> grid (base {d} p) {d}\n  p \\<in> grid py {d}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "hence py_spg: \"py \\<in> sparsegrid' dm\""], ["proof (prove)\nusing this:\n  py \\<in> grid (base {d} p) {d}\n  p \\<in> grid py {d}\n\ngoal (1 subgoal):\n 1. py \\<in> sparsegrid' dm", "using base_grid[OF p_spg']"], ["proof (prove)\nusing this:\n  py \\<in> grid (base {d} p) {d}\n  p \\<in> grid py {d}\n  grid (base ?ds p) ?ds \\<subseteq> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. py \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  py \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "have \"y ! d = py ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y ! d = py ! d", "using grid_base_out[OF _ _ py_spg y_grid] \\<open>Suc d \\<le> dm\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?d < dm; ?d \\<notin> {0..<d}\\<rbrakk>\n  \\<Longrightarrow> y ! ?d = py ! ?d\n  Suc d \\<le> dm\n\ngoal (1 subgoal):\n 1. y ! d = py ! d", "by auto"], ["proof (state)\nthis:\n  y ! d = py ! d\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "hence \"lv y d \\<le> lv p d\""], ["proof (prove)\nusing this:\n  y ! d = py ! d\n\ngoal (1 subgoal):\n 1. lv y d \\<le> lv p d", "using grid_single_level[OF \\<open>p \\<in> grid py {d}\\<close>] \\<open>Suc d \\<le> dm\\<close> and sparsegrid'_length[OF py_spg]"], ["proof (prove)\nusing this:\n  y ! d = py ! d\n  ?d < length py \\<Longrightarrow> lv py ?d \\<le> lv p ?d\n  Suc d \\<le> dm\n  length py = dm\n\ngoal (1 subgoal):\n 1. lv y d \\<le> lv p d", "unfolding lv_def"], ["proof (prove)\nusing this:\n  y ! d = py ! d\n  ?d < length py \\<Longrightarrow> fst (py ! ?d) \\<le> fst (p ! ?d)\n  Suc d \\<le> dm\n  length py = dm\n\ngoal (1 subgoal):\n 1. fst (y ! d) \\<le> fst (p ! d)", "by auto"], ["proof (state)\nthis:\n  lv y d \\<le> lv p d\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                            lgrid p' {d} lm - {p'});\n        y \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> y", "ultimately"], ["proof (chain)\npicking this:\n  lv p d < lv x d\n  lv y d \\<le> lv p d", "show \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  lv p d < lv x d\n  lv y d \\<le> lv p d\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) +\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                     lgrid (base {0..<d} p') {0..<d} lm).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     lgrid p' {d} lm - {p'}) \\<union>\n                 (\\<Union>p'\\<in>parents d (base {d} p) p.\n                     lgrid (base {0..<d} p') {0..<d} lm).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     lgrid p' {d} lm - {p'}).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) +\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>parents d (base {d} p) p.\n                     lgrid (base {0..<d} p') {0..<d} lm).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     lgrid p' {d} lm - {p'}) \\<union>\n                 (\\<Union>p'\\<in>parents d (base {d} p) p.\n                     lgrid (base {0..<d} p') {0..<d} lm).\n     \\<alpha> p'' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "have \"\\<dots> = (\\<Sum> p' \\<in> ?subgrid (Suc d) p. \\<alpha> p' * ?prod (Suc d) p' p)\" (is \"(\\<Sum> x \\<in> ?in. ?F x) = (\\<Sum> x \\<in> ?out. ?F x)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                       lgrid p' {d} lm - {p'}) \\<union>\n                   (\\<Union>p'\\<in>parents d (base {d} p) p.\n                       lgrid (base {0..<d} p') {0..<d} lm).\n       \\<alpha> p'' *\n       (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n    (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p) {0..<Suc d} lm.\n       \\<alpha> p' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p' ! d') (p ! d')))", "proof (rule sum.mono_neutral_left, simp add: lgrid_finite)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n        lgrid p' {d} lm - {p'}) \\<union>\n    (\\<Union>p'\\<in>parents d (base {d} p) p.\n        lgrid (base {0..<d} p') {0..<d} lm)\n    \\<subseteq> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n 2. \\<forall>i\\<in>lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n                   ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                        lgrid p' {d} lm - {p'}) \\<union>\n                    (\\<Union>p'\\<in>parents d (base {d} p) p.\n                        lgrid (base {0..<d} p') {0..<d} lm)).\n       \\<alpha> i * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (i ! d') (p ! d')) = 0", "show \"?in \\<subseteq> ?out\" (is \"?children \\<union> ?siblings \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n        lgrid p' {d} lm - {p'}) \\<union>\n    (\\<Union>p'\\<in>parents d (base {d} p) p.\n        lgrid (base {0..<d} p') {0..<d} lm)\n    \\<subseteq> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                   lgrid p' {d} lm - {p'}) \\<union>\n               (\\<Union>p'\\<in>parents d (base {d} p) p.\n                   lgrid (base {0..<d} p') {0..<d} lm) \\<Longrightarrow>\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                   lgrid p' {d} lm - {p'}) \\<union>\n               (\\<Union>p'\\<in>parents d (base {d} p) p.\n                   lgrid (base {0..<d} p') {0..<d} lm) \\<Longrightarrow>\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "assume \"x \\<in> ?in\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n              lgrid p' {d} lm - {p'}) \\<union>\n          (\\<Union>p'\\<in>parents d (base {d} p) p.\n              lgrid (base {0..<d} p') {0..<d} lm)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                   lgrid p' {d} lm - {p'}) \\<union>\n               (\\<Union>p'\\<in>parents d (base {d} p) p.\n                   lgrid (base {0..<d} p') {0..<d} lm) \\<Longrightarrow>\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "show \"x \\<in> ?out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "proof (cases \"x \\<in> ?children\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n 2. x \\<notin> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                   lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "case False"], ["proof (state)\nthis:\n  x \\<notin> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                 lgrid p' {d} lm - {p'})\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n 2. x \\<notin> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                   lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "hence \"x \\<in> ?siblings\""], ["proof (prove)\nusing this:\n  x \\<notin> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                 lgrid p' {d} lm - {p'})\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                lgrid (base {0..<d} p') {0..<d} lm)", "using \\<open>x \\<in> ?in\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                 lgrid p' {d} lm - {p'})\n  x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n              lgrid p' {d} lm - {p'}) \\<union>\n          (\\<Union>p'\\<in>parents d (base {d} p) p.\n              lgrid (base {0..<d} p') {0..<d} lm)\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n                lgrid (base {0..<d} p') {0..<d} lm)", "by auto"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n              lgrid (base {0..<d} p') {0..<d} lm)\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n 2. x \\<notin> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                   lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n              lgrid (base {0..<d} p') {0..<d} lm)", "obtain px where \"px \\<in> parents d (base {d} p) p\" and \"x \\<in> lgrid (base {0..<d} px) {0..<d} lm\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>p'\\<in>parents d (base {d} p) p.\n              lgrid (base {0..<d} p') {0..<d} lm)\n\ngoal (1 subgoal):\n 1. (\\<And>px.\n        \\<lbrakk>px \\<in> parents d (base {d} p) p;\n         x \\<in> lgrid (base {0..<d} px) {0..<d} lm\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  px \\<in> parents d (base {d} p) p\n  x \\<in> lgrid (base {0..<d} px) {0..<d} lm\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n 2. x \\<notin> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                   lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "hence \"level x < lm\" and \"px \\<in> grid (base {d} p) {d}\" and \"x \\<in> grid (base {0..<d} px) {0..<d}\" and \"{d} \\<union> {0..<d} = {0..<Suc d}\""], ["proof (prove)\nusing this:\n  px \\<in> parents d (base {d} p) p\n  x \\<in> lgrid (base {0..<d} px) {0..<d} lm\n\ngoal (1 subgoal):\n 1. (level x < lm &&& px \\<in> grid (base {d} p) {d}) &&&\n    x \\<in> grid (base {0..<d} px) {0..<d} &&&\n    {d} \\<union> {0..<d} = {0..<Suc d}", "unfolding lgrid_def parents_def"], ["proof (prove)\nusing this:\n  px \\<in> {x \\<in> grid (base {d} p) {d}. p \\<in> grid x {d}}\n  x \\<in> {p \\<in> grid (base {0..<d} px) {0..<d}. level p < lm}\n\ngoal (1 subgoal):\n 1. (level x < lm &&& px \\<in> grid (base {d} p) {d}) &&&\n    x \\<in> grid (base {0..<d} px) {0..<d} &&&\n    {d} \\<union> {0..<d} = {0..<Suc d}", "by auto"], ["proof (state)\nthis:\n  level x < lm\n  px \\<in> grid (base {d} p) {d}\n  x \\<in> grid (base {0..<d} px) {0..<d}\n  {d} \\<union> {0..<d} = {0..<Suc d}\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n 2. x \\<notin> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                   lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "with grid_base_union[OF p_spg' this(2) this(3)]"], ["proof (chain)\npicking this:\n  x \\<in> grid (base ({d} \\<union> {0..<d}) p) ({d} \\<union> {0..<d})\n  level x < lm\n  px \\<in> grid (base {d} p) {d}\n  x \\<in> grid (base {0..<d} px) {0..<d}\n  {d} \\<union> {0..<d} = {0..<Suc d}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> grid (base ({d} \\<union> {0..<d}) p) ({d} \\<union> {0..<d})\n  level x < lm\n  px \\<in> grid (base {d} p) {d}\n  x \\<in> grid (base {0..<d} px) {0..<d}\n  {d} \\<union> {0..<d} = {0..<Suc d}\n\ngoal (1 subgoal):\n 1. x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  x \\<in> grid (base ({d} \\<union> {0..<d}) p) ({d} \\<union> {0..<d})\n  level x < lm\n  px \\<in> grid (base {d} p) {d}\n  x \\<in> grid (base {0..<d} px) {0..<d}\n  {d} \\<union> {0..<d} = {0..<Suc d}\n\ngoal (1 subgoal):\n 1. x \\<in> {p \\<in> grid (base {0..<Suc d} p) {0..<Suc d}. level p < lm}", "by auto"], ["proof (state)\nthis:\n  x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "have d_eq: \"{0..<Suc d} \\<union> {d} = {0..<Suc d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc d} \\<union> {d} = {0..<Suc d}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc d} \\<union> {d} = {0..<Suc d}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "case True"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n              lgrid p' {d} lm - {p'})\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n              lgrid p' {d} lm - {p'})", "obtain px where \"px \\<in> ?subgrid d p\" and \"x \\<in> lgrid px {d} lm\" and \"x \\<noteq> px\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n              lgrid p' {d} lm - {p'})\n\ngoal (1 subgoal):\n 1. (\\<And>px.\n        \\<lbrakk>px \\<in> lgrid (base {0..<d} p) {0..<d} lm;\n         x \\<in> lgrid px {d} lm; x \\<noteq> px\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  px \\<in> lgrid (base {0..<d} p) {0..<d} lm\n  x \\<in> lgrid px {d} lm\n  x \\<noteq> px\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "hence \"px \\<in> grid (base {0..<d} p) {0..<d}\" and \"x \\<in> grid px {d}\" and \"level x < lm\" and \"{d} \\<union> {0..<d} = {0..<Suc d}\""], ["proof (prove)\nusing this:\n  px \\<in> lgrid (base {0..<d} p) {0..<d} lm\n  x \\<in> lgrid px {d} lm\n  x \\<noteq> px\n\ngoal (1 subgoal):\n 1. (px \\<in> grid (base {0..<d} p) {0..<d} &&& x \\<in> grid px {d}) &&&\n    level x < lm &&& {d} \\<union> {0..<d} = {0..<Suc d}", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  px \\<in> {p \\<in> grid (base {0..<d} p) {0..<d}. level p < lm}\n  x \\<in> {p \\<in> grid px {d}. level p < lm}\n  x \\<noteq> px\n\ngoal (1 subgoal):\n 1. (px \\<in> grid (base {0..<d} p) {0..<d} &&& x \\<in> grid px {d}) &&&\n    level x < lm &&& {d} \\<union> {0..<d} = {0..<Suc d}", "by auto"], ["proof (state)\nthis:\n  px \\<in> grid (base {0..<d} p) {0..<d}\n  x \\<in> grid px {d}\n  level x < lm\n  {d} \\<union> {0..<d} = {0..<Suc d}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "from grid_base_dim_add[OF _ p_spg' this(1)]"], ["proof (chain)\npicking this:\n  {0..<d} \\<subseteq> ?ds \\<Longrightarrow> px \\<in> grid (base ?ds p) ?ds", "have \"px \\<in> grid (base {0..<Suc d} p) {0..<Suc d}\""], ["proof (prove)\nusing this:\n  {0..<d} \\<subseteq> ?ds \\<Longrightarrow> px \\<in> grid (base ?ds p) ?ds\n\ngoal (1 subgoal):\n 1. px \\<in> grid (base {0..<Suc d} p) {0..<Suc d}", "by auto"], ["proof (state)\nthis:\n  px \\<in> grid (base {0..<Suc d} p) {0..<Suc d}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                lgrid p' {d} lm - {p'}) \\<Longrightarrow>\n    x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "from grid_transitive[OF \\<open>x \\<in> grid px {d}\\<close> this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>{0..<Suc d} \\<subseteq> ?ds''; {d} \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (base {0..<Suc d} p) ?ds''", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<Suc d} \\<subseteq> ?ds''; {d} \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (base {0..<Suc d} p) ?ds''\n\ngoal (1 subgoal):\n 1. x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<Suc d} \\<subseteq> ?ds''; {d} \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (base {0..<Suc d} p) ?ds''\n\ngoal (1 subgoal):\n 1. x \\<in> {p \\<in> grid (base {0..<Suc d} p) {0..<Suc d}. level p < lm}", "using \\<open>level x < lm\\<close> d_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<Suc d} \\<subseteq> ?ds''; {d} \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (base {0..<Suc d} p) ?ds''\n  level x < lm\n  {0..<Suc d} \\<union> {d} = {0..<Suc d}\n\ngoal (1 subgoal):\n 1. x \\<in> {p \\<in> grid (base {0..<Suc d} p) {0..<Suc d}. level p < lm}", "by auto"], ["proof (state)\nthis:\n  x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n      lgrid p' {d} lm - {p'}) \\<union>\n  (\\<Union>p'\\<in>parents d (base {d} p) p.\n      lgrid (base {0..<d} p') {0..<d} lm)\n  \\<subseteq> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n                   ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                        lgrid p' {d} lm - {p'}) \\<union>\n                    (\\<Union>p'\\<in>parents d (base {d} p) p.\n                        lgrid (base {0..<d} p') {0..<d} lm)).\n       \\<alpha> i * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (i ! d') (p ! d')) = 0", "show \"\\<forall> x \\<in> ?out - ?in. ?F x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n                   ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                        lgrid p' {d} lm - {p'}) \\<union>\n                    (\\<Union>p'\\<in>parents d (base {d} p) p.\n                        lgrid (base {0..<d} p') {0..<d} lm)).\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "assume \"x \\<in> ?out - ?in\""], ["proof (state)\nthis:\n  x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n          ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n               lgrid p' {d} lm - {p'}) \\<union>\n           (\\<Union>p'\\<in>parents d (base {d} p) p.\n               lgrid (base {0..<d} p') {0..<d} lm))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "hence \"x \\<in> ?out\" and up_ps': \"!! p'. p' \\<in> ?subgrid d p \\<Longrightarrow> x \\<notin> lgrid p' {d} lm - {p'}\"\n        and down_ps': \"!! p'. p' \\<in> ?parents \\<Longrightarrow> x \\<notin> ?subgrid d p'\""], ["proof (prove)\nusing this:\n  x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n          ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n               lgrid p' {d} lm - {p'}) \\<union>\n           (\\<Union>p'\\<in>parents d (base {d} p) p.\n               lgrid (base {0..<d} p') {0..<d} lm))\n\ngoal (1 subgoal):\n 1. x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm &&&\n    (\\<And>p'.\n        p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n        x \\<notin> lgrid p' {d} lm - {p'}) &&&\n    (\\<And>p'.\n        p' \\<in> parents d (base {d} p) p \\<Longrightarrow>\n        x \\<notin> lgrid (base {0..<d} p') {0..<d} lm)", "by auto"], ["proof (state)\nthis:\n  x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n  ?p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n  x \\<notin> lgrid ?p' {d} lm - {?p'}\n  ?p' \\<in> parents d (base {d} p) p \\<Longrightarrow>\n  x \\<notin> lgrid (base {0..<d} ?p') {0..<d} lm\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "hence x_eq: \"x \\<in> grid (base {0..<Suc d} p) {0..<Suc d}\" and \"level x < lm\""], ["proof (prove)\nusing this:\n  x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm\n  ?p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n  x \\<notin> lgrid ?p' {d} lm - {?p'}\n  ?p' \\<in> parents d (base {d} p) p \\<Longrightarrow>\n  x \\<notin> lgrid (base {0..<d} ?p') {0..<d} lm\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<Suc d} p) {0..<Suc d} &&& level x < lm", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  x \\<in> {p \\<in> grid (base {0..<Suc d} p) {0..<Suc d}. level p < lm}\n  ?p'\n  \\<in> {p \\<in> grid (base {0..<d} p) {0..<d}.\n         level p < lm} \\<Longrightarrow>\n  x \\<notin> {p \\<in> grid ?p' {d}. level p < lm} - {?p'}\n  ?p' \\<in> parents d (base {d} p) p \\<Longrightarrow>\n  x \\<notin> {p \\<in> grid (base {0..<d} ?p') {0..<d}. level p < lm}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<Suc d} p) {0..<Suc d} &&& level x < lm", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (base {0..<Suc d} p) {0..<Suc d}\n  level x < lm\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "hence up_ps: \"!! p'. p' \\<in> ?subgrid d p \\<Longrightarrow> x \\<notin> grid p' {d} - {p'}\" and\n        down_ps: \"!! p'. p' \\<in> ?parents \\<Longrightarrow> x \\<notin> grid (base {0..<d} p') {0..<d}\""], ["proof (prove)\nusing this:\n  x \\<in> grid (base {0..<Suc d} p) {0..<Suc d}\n  level x < lm\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n        x \\<notin> grid p' {d} - {p'}) &&&\n    (\\<And>p'.\n        p' \\<in> parents d (base {d} p) p \\<Longrightarrow>\n        x \\<notin> grid (base {0..<d} p') {0..<d})", "using up_ps' down_ps'"], ["proof (prove)\nusing this:\n  x \\<in> grid (base {0..<Suc d} p) {0..<Suc d}\n  level x < lm\n  ?p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n  x \\<notin> lgrid ?p' {d} lm - {?p'}\n  ?p' \\<in> parents d (base {d} p) p \\<Longrightarrow>\n  x \\<notin> lgrid (base {0..<d} ?p') {0..<d} lm\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n        x \\<notin> grid p' {d} - {p'}) &&&\n    (\\<And>p'.\n        p' \\<in> parents d (base {d} p) p \\<Longrightarrow>\n        x \\<notin> grid (base {0..<d} p') {0..<d})", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  x \\<in> grid (base {0..<Suc d} p) {0..<Suc d}\n  level x < lm\n  ?p'\n  \\<in> {p \\<in> grid (base {0..<d} p) {0..<d}.\n         level p < lm} \\<Longrightarrow>\n  x \\<notin> {p \\<in> grid ?p' {d}. level p < lm} - {?p'}\n  ?p' \\<in> parents d (base {d} p) p \\<Longrightarrow>\n  x \\<notin> {p \\<in> grid (base {0..<d} ?p') {0..<d}. level p < lm}\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p' \\<in> {p \\<in> grid (base {0..<d} p) {0..<d}.\n                  level p < lm} \\<Longrightarrow>\n        x \\<notin> grid p' {d} - {p'}) &&&\n    (\\<And>p'.\n        p' \\<in> parents d (base {d} p) p \\<Longrightarrow>\n        x \\<notin> grid (base {0..<d} p') {0..<d})", "by auto"], ["proof (state)\nthis:\n  ?p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n  x \\<notin> grid ?p' {d} - {?p'}\n  ?p' \\<in> parents d (base {d} p) p \\<Longrightarrow>\n  x \\<notin> grid (base {0..<d} ?p') {0..<d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "have ds_eq: \"{0..<Suc d} = {0..<d} \\<union> {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<Suc d} = {0..<d} \\<union> {d}", "by auto"], ["proof (state)\nthis:\n  {0..<Suc d} = {0..<d} \\<union> {d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "have \"x \\<notin> grid (base {0..<d} p) {0..<Suc d} - grid (base {0..<d} p) {0..<d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> grid (base {0..<d} p) {0..<Suc d} -\n               grid (base {0..<d} p) {0..<d}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) {0..<Suc d} -\n            grid (base {0..<d} p) {0..<d} \\<Longrightarrow>\n    False", "assume \"x \\<in> grid (base {0..<d} p) {0..<Suc d} - grid (base {0..<d} p) {0..<d}\""], ["proof (state)\nthis:\n  x \\<in> grid (base {0..<d} p) {0..<Suc d} - grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) {0..<Suc d} -\n            grid (base {0..<d} p) {0..<d} \\<Longrightarrow>\n    False", "hence \"x \\<in> grid (base {0..<d} p) ({d} \\<union> {0..<d})\" and x_ngrid: \"x \\<notin> grid (base {0..<d} p) {0..<d}\""], ["proof (prove)\nusing this:\n  x \\<in> grid (base {0..<d} p) {0..<Suc d} - grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) ({d} \\<union> {0..<d}) &&&\n    x \\<notin> grid (base {0..<d} p) {0..<d}", "using ds_eq"], ["proof (prove)\nusing this:\n  x \\<in> grid (base {0..<d} p) {0..<Suc d} - grid (base {0..<d} p) {0..<d}\n  {0..<Suc d} = {0..<d} \\<union> {d}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) ({d} \\<union> {0..<d}) &&&\n    x \\<notin> grid (base {0..<d} p) {0..<d}", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (base {0..<d} p) ({d} \\<union> {0..<d})\n  x \\<notin> grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) {0..<Suc d} -\n            grid (base {0..<d} p) {0..<d} \\<Longrightarrow>\n    False", "from grid_split[OF this(1)]"], ["proof (chain)\npicking this:\n  \\<exists>xa\\<in>grid (base {0..<d} p) {0..<d}. x \\<in> grid xa {d}", "obtain px where px_grid: \"px \\<in> grid (base {0..<d} p) {0..<d}\" and \"x \\<in> grid px {d}\""], ["proof (prove)\nusing this:\n  \\<exists>xa\\<in>grid (base {0..<d} p) {0..<d}. x \\<in> grid xa {d}\n\ngoal (1 subgoal):\n 1. (\\<And>px.\n        \\<lbrakk>px \\<in> grid (base {0..<d} p) {0..<d};\n         x \\<in> grid px {d}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  px \\<in> grid (base {0..<d} p) {0..<d}\n  x \\<in> grid px {d}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) {0..<Suc d} -\n            grid (base {0..<d} p) {0..<d} \\<Longrightarrow>\n    False", "from grid_level[OF this(2)] \\<open>level x < lm\\<close>"], ["proof (chain)\npicking this:\n  level px \\<le> level x\n  level x < lm", "have \"level px < lm\""], ["proof (prove)\nusing this:\n  level px \\<le> level x\n  level x < lm\n\ngoal (1 subgoal):\n 1. level px < lm", "by auto"], ["proof (state)\nthis:\n  level px < lm\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) {0..<Suc d} -\n            grid (base {0..<d} p) {0..<d} \\<Longrightarrow>\n    False", "hence \"px \\<in> ?subgrid d p\""], ["proof (prove)\nusing this:\n  level px < lm\n\ngoal (1 subgoal):\n 1. px \\<in> lgrid (base {0..<d} p) {0..<d} lm", "using px_grid"], ["proof (prove)\nusing this:\n  level px < lm\n  px \\<in> grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. px \\<in> lgrid (base {0..<d} p) {0..<d} lm", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  level px < lm\n  px \\<in> grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. px \\<in> {p \\<in> grid (base {0..<d} p) {0..<d}. level p < lm}", "by auto"], ["proof (state)\nthis:\n  px \\<in> lgrid (base {0..<d} p) {0..<d} lm\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) {0..<Suc d} -\n            grid (base {0..<d} p) {0..<d} \\<Longrightarrow>\n    False", "hence \"x \\<notin> grid px {d} - {px}\""], ["proof (prove)\nusing this:\n  px \\<in> lgrid (base {0..<d} p) {0..<d} lm\n\ngoal (1 subgoal):\n 1. x \\<notin> grid px {d} - {px}", "using up_ps"], ["proof (prove)\nusing this:\n  px \\<in> lgrid (base {0..<d} p) {0..<d} lm\n  ?p' \\<in> lgrid (base {0..<d} p) {0..<d} lm \\<Longrightarrow>\n  x \\<notin> grid ?p' {d} - {?p'}\n\ngoal (1 subgoal):\n 1. x \\<notin> grid px {d} - {px}", "by auto"], ["proof (state)\nthis:\n  x \\<notin> grid px {d} - {px}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) {0..<Suc d} -\n            grid (base {0..<d} p) {0..<d} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  x \\<notin> grid px {d} - {px}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) {0..<Suc d} -\n            grid (base {0..<d} p) {0..<d} \\<Longrightarrow>\n    False", "have \"x \\<noteq> px\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> px", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<noteq> px \\<Longrightarrow> False", "assume \"\\<not> x \\<noteq> px\""], ["proof (state)\nthis:\n  \\<not> x \\<noteq> px\n\ngoal (1 subgoal):\n 1. \\<not> x \\<noteq> px \\<Longrightarrow> False", "with px_grid and x_ngrid"], ["proof (chain)\npicking this:\n  px \\<in> grid (base {0..<d} p) {0..<d}\n  x \\<notin> grid (base {0..<d} p) {0..<d}\n  \\<not> x \\<noteq> px", "show False"], ["proof (prove)\nusing this:\n  px \\<in> grid (base {0..<d} p) {0..<d}\n  x \\<notin> grid (base {0..<d} p) {0..<d}\n  \\<not> x \\<noteq> px\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> px\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) {0..<Suc d} -\n            grid (base {0..<d} p) {0..<d} \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> grid px {d} - {px}\n  x \\<noteq> px", "show False"], ["proof (prove)\nusing this:\n  x \\<notin> grid px {d} - {px}\n  x \\<noteq> px\n\ngoal (1 subgoal):\n 1. False", "using \\<open>x \\<in> grid px {d}\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> grid px {d} - {px}\n  x \\<noteq> px\n  x \\<in> grid px {d}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> grid (base {0..<d} p) {0..<Suc d} -\n             grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "moreover"], ["proof (state)\nthis:\n  x \\<notin> grid (base {0..<d} p) {0..<Suc d} -\n             grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "have \"p \\<in> ?parents\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> parents d (base {d} p) p", "unfolding parents_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> {x \\<in> grid (base {d} p) {d}. p \\<in> grid x {d}}", "using baseE(2)[OF p_spg']"], ["proof (prove)\nusing this:\n  p \\<in> grid (base ?ds p) ?ds\n\ngoal (1 subgoal):\n 1. p \\<in> {x \\<in> grid (base {d} p) {d}. p \\<in> grid x {d}}", "by auto"], ["proof (state)\nthis:\n  p \\<in> parents d (base {d} p) p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "hence \"x \\<notin> grid (base {0..<d} p) {0..<d}\""], ["proof (prove)\nusing this:\n  p \\<in> parents d (base {d} p) p\n\ngoal (1 subgoal):\n 1. x \\<notin> grid (base {0..<d} p) {0..<d}", "by (rule down_ps)"], ["proof (state)\nthis:\n  x \\<notin> grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> grid (base {0..<d} p) {0..<Suc d} -\n             grid (base {0..<d} p) {0..<d}\n  x \\<notin> grid (base {0..<d} p) {0..<d}", "have x_ngrid: \"x \\<notin> grid (base {0..<d} p) {0..<Suc d}\""], ["proof (prove)\nusing this:\n  x \\<notin> grid (base {0..<d} p) {0..<Suc d} -\n             grid (base {0..<d} p) {0..<d}\n  x \\<notin> grid (base {0..<d} p) {0..<d}\n\ngoal (1 subgoal):\n 1. x \\<notin> grid (base {0..<d} p) {0..<Suc d}", "by auto"], ["proof (state)\nthis:\n  x \\<notin> grid (base {0..<d} p) {0..<Suc d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "have x_spg: \"x \\<in> sparsegrid' dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> sparsegrid' dm", "using base_grid[OF p_spg'] x_eq"], ["proof (prove)\nusing this:\n  grid (base ?ds p) ?ds \\<subseteq> sparsegrid' dm\n  x \\<in> grid (base {0..<Suc d} p) {0..<Suc d}\n\ngoal (1 subgoal):\n 1. x \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  x \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "hence \"length x = dm\""], ["proof (prove)\nusing this:\n  x \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. length x = dm", "using grid_length"], ["proof (prove)\nusing this:\n  x \\<in> sparsegrid' dm\n  ?p' \\<in> grid ?p ?ds \\<Longrightarrow> length ?p' = length ?p\n\ngoal (1 subgoal):\n 1. length x = dm", "by auto"], ["proof (state)\nthis:\n  length x = dm\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "let ?bx = \"base {0..<d} x\" and ?bp = \"base {0..<d} p\" and ?bx1 = \"base {d} x\" and ?bp1 = \"base {d} p\" and ?px = \"p[d := x ! d]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "have x_nochild_p: \"?bx \\<notin> grid ?bp {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base {0..<d} x \\<notin> grid (base {0..<d} p) {d}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} x\n           \\<notin> grid (base {0..<d} p) {d} \\<Longrightarrow>\n    False", "assume \"\\<not> base {0..<d} x \\<notin> grid (base {0..<d} p) {d}\""], ["proof (state)\nthis:\n  \\<not> base {0..<d} x \\<notin> grid (base {0..<d} p) {d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} x\n           \\<notin> grid (base {0..<d} p) {d} \\<Longrightarrow>\n    False", "hence \"base {0..<d} x \\<in> grid (base {0..<d} p) {d}\""], ["proof (prove)\nusing this:\n  \\<not> base {0..<d} x \\<notin> grid (base {0..<d} p) {d}\n\ngoal (1 subgoal):\n 1. base {0..<d} x \\<in> grid (base {0..<d} p) {d}", "by auto"], ["proof (state)\nthis:\n  base {0..<d} x \\<in> grid (base {0..<d} p) {d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} x\n           \\<notin> grid (base {0..<d} p) {d} \\<Longrightarrow>\n    False", "from grid_transitive[OF baseE(2)[OF x_spg] this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>{d} \\<subseteq> ?ds''; {0..<d} \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (base {0..<d} p) ?ds''", "have \"x \\<in> grid (base {0..<d} p) {0..<Suc d}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{d} \\<subseteq> ?ds''; {0..<d} \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (base {0..<d} p) ?ds''\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) {0..<Suc d}", "using ds_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>{d} \\<subseteq> ?ds''; {0..<d} \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (base {0..<d} p) ?ds''\n  {0..<Suc d} = {0..<d} \\<union> {d}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base {0..<d} p) {0..<Suc d}", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (base {0..<d} p) {0..<Suc d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} x\n           \\<notin> grid (base {0..<d} p) {d} \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  x \\<in> grid (base {0..<d} p) {0..<Suc d}\n\ngoal (1 subgoal):\n 1. False", "using x_ngrid"], ["proof (prove)\nusing this:\n  x \\<in> grid (base {0..<d} p) {0..<Suc d}\n  x \\<notin> grid (base {0..<d} p) {0..<Suc d}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  base {0..<d} x \\<notin> grid (base {0..<d} p) {d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "have \"d < length ?bx\" and \"d < length ?bp\" and \"d < length ?bx1\" and \"d < length ?bp1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d < length (base {0..<d} x) &&& d < length (base {0..<d} p)) &&&\n    d < length (base {d} x) &&& d < length (base {d} p)", "using base_length[OF x_spg] base_length[OF p_spg'] and \\<open>d < dm\\<close>"], ["proof (prove)\nusing this:\n  length (base ?ds x) = dm\n  length (base ?ds p) = dm\n  d < dm\n\ngoal (1 subgoal):\n 1. (d < length (base {0..<d} x) &&& d < length (base {0..<d} p)) &&&\n    d < length (base {d} x) &&& d < length (base {d} p)", "by auto"], ["proof (state)\nthis:\n  d < length (base {0..<d} x)\n  d < length (base {0..<d} p)\n  d < length (base {d} x)\n  d < length (base {d} p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "have p_nochild_x: \"?bp \\<notin> grid ?bx {d}\" (is \"?assm\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. base {0..<d} p \\<notin> grid (base {0..<d} x) {d}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "have ds: \"{0..<d} \\<union> {0..<Suc d} = {d} \\<union> {0..<d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<d} \\<union> {0..<Suc d} = {d} \\<union> {0..<d}", "by auto"], ["proof (state)\nthis:\n  {0..<d} \\<union> {0..<Suc d} = {d} \\<union> {0..<d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "have d_sub: \"{d} \\<subseteq> {0..<Suc d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {d} \\<subseteq> {0..<Suc d}", "by auto"], ["proof (state)\nthis:\n  {d} \\<subseteq> {0..<Suc d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "assume \"\\<not> ?assm\""], ["proof (state)\nthis:\n  \\<not> base {0..<d} p \\<notin> grid (base {0..<d} x) {d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "hence b_in_bx: \"base {0..<d} p \\<in> grid ?bx {d}\""], ["proof (prove)\nusing this:\n  \\<not> base {0..<d} p \\<notin> grid (base {0..<d} x) {d}\n\ngoal (1 subgoal):\n 1. base {0..<d} p \\<in> grid (base {0..<d} x) {d}", "by auto"], ["proof (state)\nthis:\n  base {0..<d} p \\<in> grid (base {0..<d} x) {d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "have \"d \\<notin> {0..<d}\" and \"d \\<in> {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<notin> {0..<d} &&& d \\<in> {d}", "by auto"], ["proof (state)\nthis:\n  d \\<notin> {0..<d}\n  d \\<in> {d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "from grid_replace_dim[OF \\<open>d < length ?bx\\<close> \\<open>d < length p\\<close> grid.Start[where b=p and ds=\"{d}\"] b_in_bx]"], ["proof (chain)\npicking this:\n  p[d := base {0..<d} p ! d] \\<in> grid (p[d := base {0..<d} x ! d]) {d}", "have \"p \\<in> grid ?px {d}\""], ["proof (prove)\nusing this:\n  p[d := base {0..<d} p ! d] \\<in> grid (p[d := base {0..<d} x ! d]) {d}\n\ngoal (1 subgoal):\n 1. p \\<in> grid (p[d := x ! d]) {d}", "unfolding base_out[OF \\<open>d < dm\\<close> \\<open>d \\<notin> {0..<d}\\<close> x_spg] base_out[OF \\<open>d < dm\\<close> \\<open>d \\<notin> {0..<d}\\<close> p_spg'] list_update_id"], ["proof (prove)\nusing this:\n  p \\<in> grid (p[d := x ! d]) {d}\n\ngoal (1 subgoal):\n 1. p \\<in> grid (p[d := x ! d]) {d}", "."], ["proof (state)\nthis:\n  p \\<in> grid (p[d := x ! d]) {d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  p \\<in> grid (p[d := x ! d]) {d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "from grid_replace_dim[OF \\<open>d < length ?bx1\\<close> \\<open>d < length ?bp1\\<close> baseE(2)[OF p_spg', where ds=\"{d}\"] baseE(2)[OF x_spg, where ds=\"{d}\"]]"], ["proof (chain)\npicking this:\n  p[d := x ! d] \\<in> grid ((base {d} p)[d := base {d} x ! d]) {d}", "have \"?px \\<in> grid ?bp1 {d}\""], ["proof (prove)\nusing this:\n  p[d := x ! d] \\<in> grid ((base {d} p)[d := base {d} x ! d]) {d}\n\ngoal (1 subgoal):\n 1. p[d := x ! d] \\<in> grid (base {d} p) {d}", "unfolding base_in[OF \\<open>d < dm\\<close> \\<open>d \\<in> {d}\\<close> x_spg]"], ["proof (prove)\nusing this:\n  p[d := x ! d] \\<in> grid ((base {d} p)[d := start dm ! d]) {d}\n\ngoal (1 subgoal):\n 1. p[d := x ! d] \\<in> grid (base {d} p) {d}", "unfolding base_in[OF \\<open>d < dm\\<close> \\<open>d \\<in> {d}\\<close> p_spg', symmetric] list_update_id"], ["proof (prove)\nusing this:\n  p[d := x ! d] \\<in> grid (base {d} p) {d}\n\ngoal (1 subgoal):\n 1. p[d := x ! d] \\<in> grid (base {d} p) {d}", "."], ["proof (state)\nthis:\n  p[d := x ! d] \\<in> grid (base {d} p) {d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  p \\<in> grid (p[d := x ! d]) {d}\n  p[d := x ! d] \\<in> grid (base {d} p) {d}", "have \"x \\<notin> grid (base {0..<d} ?px) {0..<d}\""], ["proof (prove)\nusing this:\n  p \\<in> grid (p[d := x ! d]) {d}\n  p[d := x ! d] \\<in> grid (base {d} p) {d}\n\ngoal (1 subgoal):\n 1. x \\<notin> grid (base {0..<d} (p[d := x ! d])) {0..<d}", "using down_ps[unfolded parents_def, where p'=\"?px\"]"], ["proof (prove)\nusing this:\n  p \\<in> grid (p[d := x ! d]) {d}\n  p[d := x ! d] \\<in> grid (base {d} p) {d}\n  p[d := x ! d]\n  \\<in> {x \\<in> grid (base {d} p) {d}.\n         p \\<in> grid x {d}} \\<Longrightarrow>\n  x \\<notin> grid (base {0..<d} (p[d := x ! d])) {0..<d}\n\ngoal (1 subgoal):\n 1. x \\<notin> grid (base {0..<d} (p[d := x ! d])) {0..<d}", "by (auto simp only:)"], ["proof (state)\nthis:\n  x \\<notin> grid (base {0..<d} (p[d := x ! d])) {0..<d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  x \\<notin> grid (base {0..<d} (p[d := x ! d])) {0..<d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "have \"base {0..<d} ?px = ?bx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base {0..<d} (p[d := x ! d]) = base {0..<d} x", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (base {0..<d} (p[d := x ! d])) = length (base {0..<d} x)\n 2. \\<And>i.\n       i < length (base {0..<d} (p[d := x ! d])) \\<Longrightarrow>\n       base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "from \\<open>?px \\<in> grid ?bp1 {d}\\<close>"], ["proof (chain)\npicking this:\n  p[d := x ! d] \\<in> grid (base {d} p) {d}", "have px_spg: \"?px \\<in> sparsegrid' dm\""], ["proof (prove)\nusing this:\n  p[d := x ! d] \\<in> grid (base {d} p) {d}\n\ngoal (1 subgoal):\n 1. p[d := x ! d] \\<in> sparsegrid' dm", "using base_grid[OF p_spg']"], ["proof (prove)\nusing this:\n  p[d := x ! d] \\<in> grid (base {d} p) {d}\n  grid (base ?ds p) ?ds \\<subseteq> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. p[d := x ! d] \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  p[d := x ! d] \\<in> sparsegrid' dm\n\ngoal (2 subgoals):\n 1. length (base {0..<d} (p[d := x ! d])) = length (base {0..<d} x)\n 2. \\<And>i.\n       i < length (base {0..<d} (p[d := x ! d])) \\<Longrightarrow>\n       base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "from base_length[OF this] base_length[OF x_spg]"], ["proof (chain)\npicking this:\n  length (base ?ds (p[d := x ! d])) = dm\n  length (base ?ds x) = dm", "show l_eq: \"length (base {0..<d} ?px) = length ?bx\""], ["proof (prove)\nusing this:\n  length (base ?ds (p[d := x ! d])) = dm\n  length (base ?ds x) = dm\n\ngoal (1 subgoal):\n 1. length (base {0..<d} (p[d := x ! d])) = length (base {0..<d} x)", "by auto"], ["proof (state)\nthis:\n  length (base {0..<d} (p[d := x ! d])) = length (base {0..<d} x)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (base {0..<d} (p[d := x ! d])) \\<Longrightarrow>\n       base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "show \"base {0..<d} ?px ! i = ?bx ! i\" if \"i < length (base {0..<d} ?px)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "have \"i < length ?bx\" and \"i < dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (base {0..<d} x) &&& i < dm", "using that l_eq and base_length[OF px_spg]"], ["proof (prove)\nusing this:\n  i < length (base {0..<d} (p[d := x ! d]))\n  length (base {0..<d} (p[d := x ! d])) = length (base {0..<d} x)\n  length (base ?ds (p[d := x ! d])) = dm\n\ngoal (1 subgoal):\n 1. i < length (base {0..<d} x) &&& i < dm", "by auto"], ["proof (state)\nthis:\n  i < length (base {0..<d} x)\n  i < dm\n\ngoal (1 subgoal):\n 1. base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "show \"base {0..<d} ?px ! i = ?bx ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "proof (cases \"i < d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < d \\<Longrightarrow>\n    base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i\n 2. \\<not> i < d \\<Longrightarrow>\n    base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "case True"], ["proof (state)\nthis:\n  i < d\n\ngoal (2 subgoals):\n 1. i < d \\<Longrightarrow>\n    base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i\n 2. \\<not> i < d \\<Longrightarrow>\n    base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "hence \"i \\<in> {0..<d}\""], ["proof (prove)\nusing this:\n  i < d\n\ngoal (1 subgoal):\n 1. i \\<in> {0..<d}", "by auto"], ["proof (state)\nthis:\n  i \\<in> {0..<d}\n\ngoal (2 subgoals):\n 1. i < d \\<Longrightarrow>\n    base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i\n 2. \\<not> i < d \\<Longrightarrow>\n    base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "from base_in[OF \\<open>i < dm\\<close> this]"], ["proof (chain)\npicking this:\n  ?p \\<in> sparsegrid' dm \\<Longrightarrow>\n  base {0..<d} ?p ! i = start dm ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  ?p \\<in> sparsegrid' dm \\<Longrightarrow>\n  base {0..<d} ?p ! i = start dm ! i\n\ngoal (1 subgoal):\n 1. base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "using px_spg x_spg"], ["proof (prove)\nusing this:\n  ?p \\<in> sparsegrid' dm \\<Longrightarrow>\n  base {0..<d} ?p ! i = start dm ! i\n  p[d := x ! d] \\<in> sparsegrid' dm\n  x \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "by auto"], ["proof (state)\nthis:\n  base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i\n\ngoal (1 subgoal):\n 1. \\<not> i < d \\<Longrightarrow>\n    base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < d \\<Longrightarrow>\n    base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "case False"], ["proof (state)\nthis:\n  \\<not> i < d\n\ngoal (1 subgoal):\n 1. \\<not> i < d \\<Longrightarrow>\n    base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "hence \"i \\<notin> {0..<d}\""], ["proof (prove)\nusing this:\n  \\<not> i < d\n\ngoal (1 subgoal):\n 1. i \\<notin> {0..<d}", "by auto"], ["proof (state)\nthis:\n  i \\<notin> {0..<d}\n\ngoal (1 subgoal):\n 1. \\<not> i < d \\<Longrightarrow>\n    base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "have \"?px ! i = x ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p[d := x ! d] ! i = x ! i", "proof (cases \"i > d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i\n 2. \\<not> d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i", "have i_le: \"i < length (base {0..<Suc d} p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (base {0..<Suc d} p)", "using base_length[OF p_spg'] and \\<open>i < dm\\<close>"], ["proof (prove)\nusing this:\n  length (base ?ds p) = dm\n  i < dm\n\ngoal (1 subgoal):\n 1. i < length (base {0..<Suc d} p)", "by auto"], ["proof (state)\nthis:\n  i < length (base {0..<Suc d} p)\n\ngoal (2 subgoals):\n 1. d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i\n 2. \\<not> d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i", "case True"], ["proof (state)\nthis:\n  d < i\n\ngoal (2 subgoals):\n 1. d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i\n 2. \\<not> d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i", "hence \"i \\<notin> {0..<Suc d}\""], ["proof (prove)\nusing this:\n  d < i\n\ngoal (1 subgoal):\n 1. i \\<notin> {0..<Suc d}", "by auto"], ["proof (state)\nthis:\n  i \\<notin> {0..<Suc d}\n\ngoal (2 subgoals):\n 1. d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i\n 2. \\<not> d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i", "from grid_invariant[OF i_le this x_eq] base_out[OF \\<open>i < dm\\<close> this p_spg']"], ["proof (chain)\npicking this:\n  x ! i = base {0..<Suc d} p ! i\n  base {0..<Suc d} p ! i = p ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  x ! i = base {0..<Suc d} p ! i\n  base {0..<Suc d} p ! i = p ! i\n\ngoal (1 subgoal):\n 1. p[d := x ! d] ! i = x ! i", "using list_update_id and True"], ["proof (prove)\nusing this:\n  x ! i = base {0..<Suc d} p ! i\n  base {0..<Suc d} p ! i = p ! i\n  ?xs[?i := ?xs ! ?i] = ?xs\n  d < i\n\ngoal (1 subgoal):\n 1. p[d := x ! d] ! i = x ! i", "by auto"], ["proof (state)\nthis:\n  p[d := x ! d] ! i = x ! i\n\ngoal (1 subgoal):\n 1. \\<not> d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i", "case False"], ["proof (state)\nthis:\n  \\<not> d < i\n\ngoal (1 subgoal):\n 1. \\<not> d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i", "hence \"d = i\""], ["proof (prove)\nusing this:\n  \\<not> d < i\n\ngoal (1 subgoal):\n 1. d = i", "using \\<open>\\<not> i < d\\<close>"], ["proof (prove)\nusing this:\n  \\<not> d < i\n  \\<not> i < d\n\ngoal (1 subgoal):\n 1. d = i", "by auto"], ["proof (state)\nthis:\n  d = i\n\ngoal (1 subgoal):\n 1. \\<not> d < i \\<Longrightarrow> p[d := x ! d] ! i = x ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  d = i\n\ngoal (1 subgoal):\n 1. p[d := x ! d] ! i = x ! i", "unfolding \\<open>d = i\\<close>"], ["proof (prove)\nusing this:\n  i = i\n\ngoal (1 subgoal):\n 1. p[i := x ! i] ! i = x ! i", "using \\<open>i < dm\\<close> \\<open>length p = dm\\<close> nth_list_update_eq"], ["proof (prove)\nusing this:\n  i = i\n  i < dm\n  length p = dm\n  ?i < length ?xs \\<Longrightarrow> ?xs[?i := ?x] ! ?i = ?x\n\ngoal (1 subgoal):\n 1. p[i := x ! i] ! i = x ! i", "by auto"], ["proof (state)\nthis:\n  p[d := x ! d] ! i = x ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p[d := x ! d] ! i = x ! i\n\ngoal (1 subgoal):\n 1. \\<not> i < d \\<Longrightarrow>\n    base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  p[d := x ! d] ! i = x ! i\n\ngoal (1 subgoal):\n 1. base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "using base_out[OF \\<open>i < dm\\<close> \\<open>i \\<notin> {0..<d}\\<close> px_spg] base_out[OF \\<open>i < dm\\<close> \\<open>i \\<notin> {0..<d}\\<close> x_spg]"], ["proof (prove)\nusing this:\n  p[d := x ! d] ! i = x ! i\n  base {0..<d} (p[d := x ! d]) ! i = p[d := x ! d] ! i\n  base {0..<d} x ! i = x ! i\n\ngoal (1 subgoal):\n 1. base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i", "by auto"], ["proof (state)\nthis:\n  base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  base {0..<d} (p[d := x ! d]) ! i = base {0..<d} x ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length (base {0..<d} (p[d := x ! d])) \\<Longrightarrow>\n  base {0..<d} (p[d := x ! d]) ! ?i = base {0..<d} x ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  base {0..<d} (p[d := x ! d]) = base {0..<d} x\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> grid (base {0..<d} (p[d := x ! d])) {0..<d}\n  base {0..<d} (p[d := x ! d]) = base {0..<d} x", "have \"x \\<notin> grid ?bx {0..<d}\""], ["proof (prove)\nusing this:\n  x \\<notin> grid (base {0..<d} (p[d := x ! d])) {0..<d}\n  base {0..<d} (p[d := x ! d]) = base {0..<d} x\n\ngoal (1 subgoal):\n 1. x \\<notin> grid (base {0..<d} x) {0..<d}", "by auto"], ["proof (state)\nthis:\n  x \\<notin> grid (base {0..<d} x) {0..<d}\n\ngoal (1 subgoal):\n 1. \\<not> base {0..<d} p\n           \\<notin> grid (base {0..<d} x) {d} \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  x \\<notin> grid (base {0..<d} x) {0..<d}\n\ngoal (1 subgoal):\n 1. False", "using baseE(2)[OF x_spg]"], ["proof (prove)\nusing this:\n  x \\<notin> grid (base {0..<d} x) {0..<d}\n  x \\<in> grid (base ?ds x) ?ds\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  base {0..<d} p \\<notin> grid (base {0..<d} x) {d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "have x_grid: \"?bx \\<in> grid (base {0..<Suc d} p) {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base {0..<d} x \\<in> grid (base {0..<Suc d} p) {d}", "using grid_shift_base[OF _ p_spg' x_eq[unfolded ds_eq]]"], ["proof (prove)\nusing this:\n  {d} \\<inter> {0..<d} = {} \\<Longrightarrow>\n  base {0..<d} x \\<in> grid (base ({d} \\<union> {0..<d}) p) {d}\n\ngoal (1 subgoal):\n 1. base {0..<d} x \\<in> grid (base {0..<Suc d} p) {d}", "unfolding ds_eq"], ["proof (prove)\nusing this:\n  {d} \\<inter> {0..<d} = {} \\<Longrightarrow>\n  base {0..<d} x \\<in> grid (base ({d} \\<union> {0..<d}) p) {d}\n\ngoal (1 subgoal):\n 1. base {0..<d} x \\<in> grid (base ({0..<d} \\<union> {d}) p) {d}", "by auto"], ["proof (state)\nthis:\n  base {0..<d} x \\<in> grid (base {0..<Suc d} p) {d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "have p_grid: \"?bp \\<in> grid (base {0..<Suc d} p) {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base {0..<d} p \\<in> grid (base {0..<Suc d} p) {d}", "using grid_shift_base[OF _ p_spg' baseE(2)[OF p_spg', where ds=\"{0..<d} \\<union> {d}\"]]"], ["proof (prove)\nusing this:\n  {d} \\<inter> {0..<d} = {} \\<Longrightarrow>\n  base {0..<d} p \\<in> grid (base ({d} \\<union> {0..<d}) p) {d}\n\ngoal (1 subgoal):\n 1. base {0..<d} p \\<in> grid (base {0..<Suc d} p) {d}", "unfolding ds_eq"], ["proof (prove)\nusing this:\n  {d} \\<inter> {0..<d} = {} \\<Longrightarrow>\n  base {0..<d} p \\<in> grid (base ({d} \\<union> {0..<d}) p) {d}\n\ngoal (1 subgoal):\n 1. base {0..<d} p \\<in> grid (base ({0..<d} \\<union> {d}) p) {d}", "by auto"], ["proof (state)\nthis:\n  base {0..<d} p \\<in> grid (base {0..<Suc d} p) {d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "have \"l2_\\<phi> (?bp ! d) (?bx ! d) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0", "proof (cases \"lv ?bx d \\<le> lv ?bp d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lv (base {0..<d} x) d \\<le> lv (base {0..<d} p) d \\<Longrightarrow>\n    l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0\n 2. \\<not> lv (base {0..<d} x) d\n           \\<le> lv (base {0..<d} p) d \\<Longrightarrow>\n    l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0", "case True"], ["proof (state)\nthis:\n  lv (base {0..<d} x) d \\<le> lv (base {0..<d} p) d\n\ngoal (2 subgoals):\n 1. lv (base {0..<d} x) d \\<le> lv (base {0..<d} p) d \\<Longrightarrow>\n    l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0\n 2. \\<not> lv (base {0..<d} x) d\n           \\<le> lv (base {0..<d} p) d \\<Longrightarrow>\n    l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0", "from l2_disjoint[OF _ x_grid p_grid p_nochild_x this] \\<open>d < dm\\<close> and base_length[OF p_spg']"], ["proof (chain)\npicking this:\n  d < length (base {0..<Suc d} p) \\<Longrightarrow>\n  l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0\n  d < dm\n  length (base ?ds p) = dm", "show ?thesis"], ["proof (prove)\nusing this:\n  d < length (base {0..<Suc d} p) \\<Longrightarrow>\n  l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0\n  d < dm\n  length (base ?ds p) = dm\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0", "by auto"], ["proof (state)\nthis:\n  l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0\n\ngoal (1 subgoal):\n 1. \\<not> lv (base {0..<d} x) d\n           \\<le> lv (base {0..<d} p) d \\<Longrightarrow>\n    l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lv (base {0..<d} x) d\n           \\<le> lv (base {0..<d} p) d \\<Longrightarrow>\n    l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0", "case False"], ["proof (state)\nthis:\n  \\<not> lv (base {0..<d} x) d \\<le> lv (base {0..<d} p) d\n\ngoal (1 subgoal):\n 1. \\<not> lv (base {0..<d} x) d\n           \\<le> lv (base {0..<d} p) d \\<Longrightarrow>\n    l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0", "hence \"lv ?bx d \\<ge> lv ?bp d\""], ["proof (prove)\nusing this:\n  \\<not> lv (base {0..<d} x) d \\<le> lv (base {0..<d} p) d\n\ngoal (1 subgoal):\n 1. lv (base {0..<d} p) d \\<le> lv (base {0..<d} x) d", "by auto"], ["proof (state)\nthis:\n  lv (base {0..<d} p) d \\<le> lv (base {0..<d} x) d\n\ngoal (1 subgoal):\n 1. \\<not> lv (base {0..<d} x) d\n           \\<le> lv (base {0..<d} p) d \\<Longrightarrow>\n    l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0", "from l2_disjoint[OF _ p_grid x_grid x_nochild_p this] \\<open>d < dm\\<close> and base_length[OF p_spg']"], ["proof (chain)\npicking this:\n  d < length (base {0..<Suc d} p) \\<Longrightarrow>\n  l2_\\<phi> (base {0..<d} x ! d) (base {0..<d} p ! d) = 0\n  d < dm\n  length (base ?ds p) = dm", "show ?thesis"], ["proof (prove)\nusing this:\n  d < length (base {0..<Suc d} p) \\<Longrightarrow>\n  l2_\\<phi> (base {0..<d} x ! d) (base {0..<d} p ! d) = 0\n  d < dm\n  length (base ?ds p) = dm\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0", "by (auto simp: l2_commutative)"], ["proof (state)\nthis:\n  l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "hence \"l2_\\<phi> (p ! d) (x ! d) = 0\""], ["proof (prove)\nusing this:\n  l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p ! d) (x ! d) = 0", "using base_out[OF \\<open>d < dm\\<close>] p_spg' x_spg"], ["proof (prove)\nusing this:\n  l2_\\<phi> (base {0..<d} p ! d) (base {0..<d} x ! d) = 0\n  \\<lbrakk>d \\<notin> ?ds; ?p \\<in> sparsegrid' dm\\<rbrakk>\n  \\<Longrightarrow> base ?ds ?p ! d = ?p ! d\n  p \\<in> sparsegrid' dm\n  x \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. l2_\\<phi> (p ! d) (x ! d) = 0", "by auto"], ["proof (state)\nthis:\n  l2_\\<phi> (p ! d) (x ! d) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "hence \"\\<exists> d \\<in> {0..<Suc d}. l2_\\<phi> (p ! d) (x ! d) = 0\""], ["proof (prove)\nusing this:\n  l2_\\<phi> (p ! d) (x ! d) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<in>{0..<Suc d}. l2_\\<phi> (p ! d) (x ! d) = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>d\\<in>{0..<Suc d}. l2_\\<phi> (p ! d) (x ! d) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n               ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                    lgrid p' {d} lm - {p'}) \\<union>\n                (\\<Union>p'\\<in>parents d (base {d} p) p.\n                    lgrid (base {0..<d} p') {0..<d} lm)) \\<Longrightarrow>\n       \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "from prod_zero[OF _ this]"], ["proof (chain)\npicking this:\n  finite {0..<Suc d} \\<Longrightarrow>\n  (\\<Prod>d = 0..<Suc d. l2_\\<phi> (p ! d) (x ! d)) = 0", "show \"?F x = 0\""], ["proof (prove)\nusing this:\n  finite {0..<Suc d} \\<Longrightarrow>\n  (\\<Prod>d = 0..<Suc d. l2_\\<phi> (p ! d) (x ! d)) = 0\n\ngoal (1 subgoal):\n 1. \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0", "by (auto simp: l2_commutative)"], ["proof (state)\nthis:\n  \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>lgrid (base {0..<Suc d} p) {0..<Suc d} lm -\n                 ((\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                      lgrid p' {d} lm - {p'}) \\<union>\n                  (\\<Union>p'\\<in>parents d (base {d} p) p.\n                      lgrid (base {0..<d} p') {0..<d} lm)).\n     \\<alpha> x * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (x ! d') (p ! d')) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p''\\<in>(\\<Union>p'\\<in>lgrid (base {0..<d} p) {0..<d} lm.\n                     lgrid p' {d} lm - {p'}) \\<union>\n                 (\\<Union>p'\\<in>parents d (base {d} p) p.\n                     lgrid (base {0..<d} p') {0..<d} lm).\n     \\<alpha> p'' *\n     (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p'' ! d') (p ! d'))) =\n  (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p) {0..<Suc d} lm.\n     \\<alpha> p' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. \\<And>d \\<alpha> p.\n       \\<lbrakk>\\<And>\\<alpha> p.\n                   \\<lbrakk>d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> updown' dm lm d \\<alpha> p =\n                                     (\\<Sum>p'\n      \\<in>lgrid (base {0..<d} p) {0..<d} lm.\n  \\<alpha> p' * (\\<Prod>d' = 0..<d. l2_\\<phi> (p' ! d') (p ! d')));\n        Suc d \\<le> dm; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> updown' dm lm (Suc d) \\<alpha> p =\n                         (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p)\n  {0..<Suc d} lm.\n                            \\<alpha> p' *\n                            (\\<Prod>d' = 0..<Suc d.\n                                l2_\\<phi> (p' ! d') (p ! d')))", "finally"], ["proof (chain)\npicking this:\n  updown' dm lm (Suc d) \\<alpha> p =\n  (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p) {0..<Suc d} lm.\n     \\<alpha> p' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p' ! d') (p ! d')))", "show ?case"], ["proof (prove)\nusing this:\n  updown' dm lm (Suc d) \\<alpha> p =\n  (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p) {0..<Suc d} lm.\n     \\<alpha> p' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p' ! d') (p ! d')))\n\ngoal (1 subgoal):\n 1. updown' dm lm (Suc d) \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p) {0..<Suc d} lm.\n       \\<alpha> p' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p' ! d') (p ! d')))", "."], ["proof (state)\nthis:\n  updown' dm lm (Suc d) \\<alpha> p =\n  (\\<Sum>p'\\<in>lgrid (base {0..<Suc d} p) {0..<Suc d} lm.\n     \\<alpha> p' * (\\<Prod>d' = 0..<Suc d. l2_\\<phi> (p' ! d') (p ! d')))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem updown:\n  assumes p_spg: \"p \\<in> sparsegrid dm lm\"\n  shows \"updown dm lm \\<alpha> p = (\\<Sum> p' \\<in> sparsegrid dm lm. \\<alpha> p' * l2 p' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. updown dm lm \\<alpha> p =\n    (\\<Sum>p'\\<in>sparsegrid dm lm. \\<alpha> p' * l2 p' p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. updown dm lm \\<alpha> p =\n    (\\<Sum>p'\\<in>sparsegrid dm lm. \\<alpha> p' * l2 p' p)", "have \"p \\<in> sparsegrid' dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid' dm", "using p_spg"], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid' dm", "unfolding sparsegrid_def sparsegrid'_def lgrid_def"], ["proof (prove)\nusing this:\n  p \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}\n\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) {0..<dm}", "by auto"], ["proof (state)\nthis:\n  p \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. updown dm lm \\<alpha> p =\n    (\\<Sum>p'\\<in>sparsegrid dm lm. \\<alpha> p' * l2 p' p)", "have \"!!p'. p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm \\<Longrightarrow> length p' = dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p'.\n       p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm \\<Longrightarrow>\n       length p' = dm", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p'.\n       p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm \\<Longrightarrow>\n       length p' = dm", "fix p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p'.\n       p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm \\<Longrightarrow>\n       length p' = dm", "assume \"p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm\""], ["proof (state)\nthis:\n  p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm\n\ngoal (1 subgoal):\n 1. \\<And>p'.\n       p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm \\<Longrightarrow>\n       length p' = dm", "with base_grid[OF \\<open>p \\<in> sparsegrid' dm\\<close>]"], ["proof (chain)\npicking this:\n  grid (base ?ds p) ?ds \\<subseteq> sparsegrid' dm\n  p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm", "have \"p' \\<in> sparsegrid' dm\""], ["proof (prove)\nusing this:\n  grid (base ?ds p) ?ds \\<subseteq> sparsegrid' dm\n  p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm\n\ngoal (1 subgoal):\n 1. p' \\<in> sparsegrid' dm", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  grid (base ?ds p) ?ds \\<subseteq> sparsegrid' dm\n  p' \\<in> {pa \\<in> grid (base {0..<dm} p) {0..<dm}. level pa < lm}\n\ngoal (1 subgoal):\n 1. p' \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  p' \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. \\<And>p'.\n       p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm \\<Longrightarrow>\n       length p' = dm", "thus \"length p' = dm\""], ["proof (prove)\nusing this:\n  p' \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. length p' = dm", "by auto"], ["proof (state)\nthis:\n  length p' = dm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm \\<Longrightarrow>\n  length ?p' = dm\n\ngoal (1 subgoal):\n 1. updown dm lm \\<alpha> p =\n    (\\<Sum>p'\\<in>sparsegrid dm lm. \\<alpha> p' * l2 p' p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm \\<Longrightarrow>\n  length ?p' = dm\n\ngoal (1 subgoal):\n 1. updown dm lm \\<alpha> p =\n    (\\<Sum>p'\\<in>sparsegrid dm lm. \\<alpha> p' * l2 p' p)", "unfolding updown_def sparsegrid_def base_start_eq[OF p_spg]"], ["proof (prove)\nusing this:\n  ?p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm \\<Longrightarrow>\n  length ?p' = dm\n\ngoal (1 subgoal):\n 1. updown' dm lm dm \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {0..<dm} p) {0..<dm} lm.\n       \\<alpha> p' * l2 p' p)", "using updown'[OF _ p_spg, where d=dm] p_spg[unfolded sparsegrid_def lgrid_def]"], ["proof (prove)\nusing this:\n  ?p' \\<in> lgrid (base {0..<dm} p) {0..<dm} lm \\<Longrightarrow>\n  length ?p' = dm\n  dm \\<le> dm \\<Longrightarrow>\n  updown' dm lm dm ?\\<alpha> p =\n  (\\<Sum>p'\\<in>lgrid (base {0..<dm} p) {0..<dm} lm.\n     ?\\<alpha> p' * (\\<Prod>d' = 0..<dm. l2_\\<phi> (p' ! d') (p ! d')))\n  p \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}\n\ngoal (1 subgoal):\n 1. updown' dm lm dm \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {0..<dm} p) {0..<dm} lm.\n       \\<alpha> p' * l2 p' p)", "by (auto simp: atLeast0LessThan p_spg[THEN sparsegrid_length] l2_eq)"], ["proof (state)\nthis:\n  updown dm lm \\<alpha> p =\n  (\\<Sum>p'\\<in>sparsegrid dm lm. \\<alpha> p' * l2 p' p)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary\n  fixes \\<alpha>\n  assumes p: \"p \\<in> sparsegrid dm lm\"\n  defines \"f\\<^sub>\\<alpha> \\<equiv> \\<lambda>x. (\\<Sum>p\\<in>sparsegrid dm lm. \\<alpha> p * \\<Phi> p x)\"\n  shows \"updown dm lm \\<alpha> p = (\\<integral>x. f\\<^sub>\\<alpha> x * \\<Phi> p x \\<partial>(\\<Pi>\\<^sub>M d\\<in>{..<dm}. lborel))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. updown dm lm \\<alpha> p =\n    LINT x|Pi\\<^sub>M {..<dm} (\\<lambda>d. lborel).\n       f\\<^sub>\\<alpha> x * \\<Phi> p x", "unfolding updown[OF p] l2_def f\\<^sub>\\<alpha>_def sum_distrib_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p'\\<in>sparsegrid dm lm.\n       \\<alpha> p' *\n       (LINT x|Pi\\<^sub>M {..<length p'} (\\<lambda>d. lborel).\n           \\<Phi> p' x * \\<Phi> p x)) =\n    LINT x|Pi\\<^sub>M {..<dm} (\\<lambda>d. lborel).\n       (\\<Sum>n\\<in>sparsegrid dm lm. \\<alpha> n * \\<Phi> n x * \\<Phi> p x)", "apply (intro has_bochner_integral_integral_eq[symmetric] has_bochner_integral_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> sparsegrid dm lm \\<Longrightarrow>\n       has_bochner_integral (Pi\\<^sub>M {..<dm} (\\<lambda>d. lborel))\n        (\\<lambda>x. \\<alpha> n * \\<Phi> n x * \\<Phi> p x)\n        (\\<alpha> n *\n         (LINT x|Pi\\<^sub>M {..<length n} (\\<lambda>d. lborel).\n             \\<Phi> n x * \\<Phi> p x))", "apply (subst mult.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> sparsegrid dm lm \\<Longrightarrow>\n       has_bochner_integral (Pi\\<^sub>M {..<dm} (\\<lambda>d. lborel))\n        (\\<lambda>x. \\<alpha> n * (\\<Phi> n x * \\<Phi> p x))\n        (\\<alpha> n *\n         (LINT x|Pi\\<^sub>M {..<length n} (\\<lambda>d. lborel).\n             \\<Phi> n x * \\<Phi> p x))", "apply (intro has_bochner_integral_mult_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> sparsegrid dm lm; \\<alpha> n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> has_bochner_integral\n                          (Pi\\<^sub>M {..<dm} (\\<lambda>d. lborel))\n                          (\\<lambda>x. \\<Phi> n x * \\<Phi> p x)\n                          (LINT x|Pi\\<^sub>M {..<length n}\n                                   (\\<lambda>d. lborel).\n                              \\<Phi> n x * \\<Phi> p x)", "apply (simp add: sparsegrid_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> sparsegrid dm lm; \\<alpha> n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> has_bochner_integral\n                          (Pi\\<^sub>M {..<dm} (\\<lambda>d. lborel))\n                          (\\<lambda>x. \\<Phi> n x * \\<Phi> p x)\n                          (LINT x|Pi\\<^sub>M {..<dm} (\\<lambda>d. lborel).\n                              \\<Phi> n x * \\<Phi> p x)", "apply (rule has_bochner_integral_integrable)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> sparsegrid dm lm; \\<alpha> n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> integrable\n                          (Pi\\<^sub>M {..<dm} (\\<lambda>d. lborel))\n                          (\\<lambda>x. \\<Phi> n x * \\<Phi> p x)", "using p"], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> sparsegrid dm lm; \\<alpha> n \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> integrable\n                          (Pi\\<^sub>M {..<dm} (\\<lambda>d. lborel))\n                          (\\<lambda>x. \\<Phi> n x * \\<Phi> p x)", "apply (simp add: sparsegrid_length \\<Phi>_def prod.distrib[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> sparsegrid dm lm; \\<alpha> n \\<noteq> 0;\n        p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> integrable\n                          (Pi\\<^sub>M {..<dm} (\\<lambda>d. lborel))\n                          (\\<lambda>x.\n                              \\<Prod>xa<dm.\n                                 \\<phi> (n ! xa) (x xa) *\n                                 \\<phi> (p ! xa) (x xa))", "proof (rule product_sigma_finite.product_integrable_prod)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> sparsegrid dm lm; \\<alpha> n \\<noteq> 0;\n        p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> product_sigma_finite (\\<lambda>d. lborel)\n 2. \\<And>n.\n       \\<lbrakk>n \\<in> sparsegrid dm lm; \\<alpha> n \\<noteq> 0;\n        p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> finite {..<dm}\n 3. \\<And>n x.\n       \\<lbrakk>n \\<in> sparsegrid dm lm; \\<alpha> n \\<noteq> 0;\n        p \\<in> sparsegrid dm lm; x \\<in> {..<dm}\\<rbrakk>\n       \\<Longrightarrow> integrable lborel\n                          (\\<lambda>a. \\<phi> (n ! x) a * \\<phi> (p ! x) a)", "show \"product_sigma_finite (\\<lambda>d. lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. product_sigma_finite (\\<lambda>d. lborel)", ".."], ["proof (state)\nthis:\n  product_sigma_finite (\\<lambda>d. lborel)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> sparsegrid dm lm; \\<alpha> n \\<noteq> 0;\n        p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> finite {..<dm}\n 2. \\<And>n x.\n       \\<lbrakk>n \\<in> sparsegrid dm lm; \\<alpha> n \\<noteq> 0;\n        p \\<in> sparsegrid dm lm; x \\<in> {..<dm}\\<rbrakk>\n       \\<Longrightarrow> integrable lborel\n                          (\\<lambda>a. \\<phi> (n ! x) a * \\<phi> (p ! x) a)", "qed (auto intro: integrable_\\<phi>2)"], ["", "end"]]}