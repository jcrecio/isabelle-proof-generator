{"file_name": "/home/qj213/afp-2021-10-22/thys/UpDown_Scheme/Grid_Point.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UpDown_Scheme", "problem_names": ["lemma level_all_eq:\n  assumes \"\\<And>d. d < length p \\<Longrightarrow> lv p d = lv p' d\"\n  and \"length p = length p'\"\n  shows \"level p' = level p\"", "lemma inv_inv[simp]: \"inv (inv dir) = dir\"", "lemma sgn_inv[simp]: \"sgn (inv dir) = - sgn dir\"", "lemma child_length[simp]: \"length (child p dir d) = length p\"", "lemma child_odd[simp]: \"d < length p \\<Longrightarrow> odd (ix (child p dir d) d)\"", "lemma child_eq: \"p ! d = (l, i) \\<Longrightarrow> \\<exists> j. child p dir d = p[d := (l + 1, j)]\"", "lemma child_other: \"d \\<noteq> d' \\<Longrightarrow> child p dir d ! d' = p ! d'\"", "lemma child_invariant: assumes \"d' < length p\" shows \"(child p dir d ! d' = p ! d') = (d \\<noteq> d')\"", "lemma child_single_level: \"d < length p \\<Longrightarrow> lv (child p dir d) d > lv p d\"", "lemma child_lv: \"d < length p \\<Longrightarrow> lv (child p dir d) d = lv p d + 1\"", "lemma child_lv_other: assumes \"d' \\<noteq> d\" shows \"lv (child p dir d') d = lv p d\"", "lemma child_ix_left: \"d < length p \\<Longrightarrow> ix (child p left d) d = 2 * ix p d - 1\"", "lemma child_ix_right: \"d < length p \\<Longrightarrow> ix (child p right d) d = 2 * ix p d + 1\"", "lemma child_ix: \"d < length p \\<Longrightarrow> ix (child p dir d) d = 2 * ix p d + sgn dir\"", "lemma child_level[simp]: assumes \"d < length p\"\n  shows \"level (child p dir d) = level p + 1\"", "lemma child_ex_neighbour: \"\\<exists> b'. child b dir d = child b' (inv dir) d\"", "lemma child_level_gt[simp]: \"level (child p dir d) >= level p\"", "lemma child_estimate_child:\n  assumes \"d < length p\"\n    and \"l \\<le> lv p d\"\n    and i'_range: \"ix p d < (i + 1) * 2^(lv p d - l) \\<and>\n                   ix p d > (i - 1) * 2^(lv p d - l)\"\n                  (is \"?top p \\<and> ?bottom p\")\n    and is_child: \"p' = child p dir d\"\n  shows \"?top p' \\<and> ?bottom p'\"", "lemma child_neighbour: assumes \"child p (inv dir) d = child ps dir d\" (is \"?c_p = ?c_ps\")\n  shows \"ps = p[d := (lv p d, ix p d - sgn dir)]\" (is \"_ = ?ps\")", "lemma start_lv[simp]: \"d < dm \\<Longrightarrow> lv (start dm) d = 0\"", "lemma start_ix[simp]: \"d < dm \\<Longrightarrow> ix (start dm) d = 1\"", "lemma start_length[simp]: \"length (start dm) = dm\"", "lemma level_start_0[simp]: \"level (start dm) = 0\""], "translations": [["", "lemma level_all_eq:\n  assumes \"\\<And>d. d < length p \\<Longrightarrow> lv p d = lv p' d\"\n  and \"length p = length p'\"\n  shows \"level p' = level p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level p' = level p", "unfolding level_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lv p') {..<length p'} = sum (lv p) {..<length p}", "using assms"], ["proof (prove)\nusing this:\n  ?d < length p \\<Longrightarrow> lv p ?d = lv p' ?d\n  length p = length p'\n\ngoal (1 subgoal):\n 1. sum (lv p') {..<length p'} = sum (lv p) {..<length p}", "by auto"], ["", "datatype dir = left | right"], ["", "fun sgn :: \"dir \\<Rightarrow> int\"\nwhere\n    \"sgn left  = -1\"\n  | \"sgn right =  1\""], ["", "fun inv :: \"dir \\<Rightarrow> dir\"\nwhere\n    \"inv left = right\"\n  | \"inv right = left\""], ["", "lemma inv_inv[simp]: \"inv (inv dir) = dir\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Grid_Point.inv (Grid_Point.inv dir) = dir", "by (cases dir) simp_all"], ["", "lemma sgn_inv[simp]: \"sgn (inv dir) = - sgn dir\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Grid_Point.sgn (Grid_Point.inv dir) = - Grid_Point.sgn dir", "by (cases dir, auto)"], ["", "definition child :: \"grid_point \\<Rightarrow> dir \\<Rightarrow> nat \\<Rightarrow> grid_point\"\n  where \"child p dir d = p[d := (lv p d + 1, 2 * (ix p d) + sgn dir)]\""], ["", "lemma child_length[simp]: \"length (child p dir d) = length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (child p dir d) = length p", "unfolding child_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (p[d := (lv p d + 1, 2 * ix p d + Grid_Point.sgn dir)]) =\n    length p", "by simp"], ["", "lemma child_odd[simp]: \"d < length p \\<Longrightarrow> odd (ix (child p dir d) d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow> odd (ix (child p dir d) d)", "unfolding child_def ix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow>\n    odd (snd (p[d := (lv p d + 1, 2 * snd (p ! d) + Grid_Point.sgn dir)] !\n              d))", "by (cases dir, auto)"], ["", "lemma child_eq: \"p ! d = (l, i) \\<Longrightarrow> \\<exists> j. child p dir d = p[d := (l + 1, j)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! d = (l, i) \\<Longrightarrow>\n    \\<exists>j. child p dir d = p[d := (l + 1, j)]", "by (auto simp add: child_def ix_def lv_def)"], ["", "lemma child_other: \"d \\<noteq> d' \\<Longrightarrow> child p dir d ! d' = p ! d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<noteq> d' \\<Longrightarrow> child p dir d ! d' = p ! d'", "unfolding child_def lv_def ix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<noteq> d' \\<Longrightarrow>\n    p[d := (fst (p ! d) + 1, 2 * snd (p ! d) + Grid_Point.sgn dir)] ! d' =\n    p ! d'", "by (cases \"d' < length p\", auto)"], ["", "lemma child_invariant: assumes \"d' < length p\" shows \"(child p dir d ! d' = p ! d') = (d \\<noteq> d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (child p dir d ! d' = p ! d') = (d \\<noteq> d')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (child p dir d ! d' = p ! d') = (d \\<noteq> d')", "obtain l i where \"p ! d' = (l, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l i. p ! d' = (l, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>l i. p ! d' = (l, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  p ! d' = (l, i)\n\ngoal (1 subgoal):\n 1. (child p dir d ! d' = p ! d') = (d \\<noteq> d')", "with assms"], ["proof (chain)\npicking this:\n  d' < length p\n  p ! d' = (l, i)", "show ?thesis"], ["proof (prove)\nusing this:\n  d' < length p\n  p ! d' = (l, i)\n\ngoal (1 subgoal):\n 1. (child p dir d ! d' = p ! d') = (d \\<noteq> d')", "unfolding child_def ix_def lv_def"], ["proof (prove)\nusing this:\n  d' < length p\n  p ! d' = (l, i)\n\ngoal (1 subgoal):\n 1. (p[d := (fst (p ! d) + 1, 2 * snd (p ! d) + Grid_Point.sgn dir)] ! d' =\n     p ! d') =\n    (d \\<noteq> d')", "by auto"], ["proof (state)\nthis:\n  (child p dir d ! d' = p ! d') = (d \\<noteq> d')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma child_single_level: \"d < length p \\<Longrightarrow> lv (child p dir d) d > lv p d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow> lv p d < lv (child p dir d) d", "unfolding lv_def child_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow>\n    fst (p ! d)\n    < fst (p[d := (fst (p ! d) + 1, 2 * ix p d + Grid_Point.sgn dir)] ! d)", "by simp"], ["", "lemma child_lv: \"d < length p \\<Longrightarrow> lv (child p dir d) d = lv p d + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow> lv (child p dir d) d = lv p d + 1", "unfolding child_def lv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow>\n    fst (p[d := (fst (p ! d) + 1, 2 * ix p d + Grid_Point.sgn dir)] ! d) =\n    fst (p ! d) + 1", "by simp"], ["", "lemma child_lv_other: assumes \"d' \\<noteq> d\" shows \"lv (child p dir d') d = lv p d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv (child p dir d') d = lv p d", "using child_other[OF assms]"], ["proof (prove)\nusing this:\n  child ?p ?dir d' ! d = ?p ! d\n\ngoal (1 subgoal):\n 1. lv (child p dir d') d = lv p d", "unfolding lv_def"], ["proof (prove)\nusing this:\n  child ?p ?dir d' ! d = ?p ! d\n\ngoal (1 subgoal):\n 1. fst (child p dir d' ! d) = fst (p ! d)", "by simp"], ["", "lemma child_ix_left: \"d < length p \\<Longrightarrow> ix (child p left d) d = 2 * ix p d - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow> ix (child p left d) d = 2 * ix p d - 1", "unfolding child_def ix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow>\n    snd (p[d := (lv p d + 1, 2 * snd (p ! d) + Grid_Point.sgn left)] ! d) =\n    2 * snd (p ! d) - 1", "by simp"], ["", "lemma child_ix_right: \"d < length p \\<Longrightarrow> ix (child p right d) d = 2 * ix p d + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow> ix (child p right d) d = 2 * ix p d + 1", "unfolding child_def ix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow>\n    snd (p[d := (lv p d + 1, 2 * snd (p ! d) + Grid_Point.sgn right)] ! d) =\n    2 * snd (p ! d) + 1", "by simp"], ["", "lemma child_ix: \"d < length p \\<Longrightarrow> ix (child p dir d) d = 2 * ix p d + sgn dir\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow>\n    ix (child p dir d) d = 2 * ix p d + Grid_Point.sgn dir", "unfolding child_def ix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p \\<Longrightarrow>\n    snd (p[d := (lv p d + 1, 2 * snd (p ! d) + Grid_Point.sgn dir)] ! d) =\n    2 * snd (p ! d) + Grid_Point.sgn dir", "by simp"], ["", "lemma child_level[simp]: assumes \"d < length p\"\n  shows \"level (child p dir d) = level p + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level (child p dir d) = level p + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. level (child p dir d) = level p + 1", "have inter: \"{0..<length p} \\<inter> {d} = {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<length p} \\<inter> {d} = {d}", "using assms"], ["proof (prove)\nusing this:\n  d < length p\n\ngoal (1 subgoal):\n 1. {0..<length p} \\<inter> {d} = {d}", "by auto"], ["proof (state)\nthis:\n  {0..<length p} \\<inter> {d} = {d}\n\ngoal (1 subgoal):\n 1. level (child p dir d) = level p + 1", "have \"level (child p dir d) =\n    (\\<Sum> d' = 0..<length p. if d' \\<in> {d} then lv p d + 1 else lv p d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level (child p dir d) =\n    (\\<Sum>d' = 0..<length p. if d' \\<in> {d} then lv p d + 1 else lv p d')", "by (auto intro!: sum.cong simp add: child_lv_other child_lv level_def)"], ["proof (state)\nthis:\n  level (child p dir d) =\n  (\\<Sum>d' = 0..<length p. if d' \\<in> {d} then lv p d + 1 else lv p d')\n\ngoal (1 subgoal):\n 1. level (child p dir d) = level p + 1", "moreover"], ["proof (state)\nthis:\n  level (child p dir d) =\n  (\\<Sum>d' = 0..<length p. if d' \\<in> {d} then lv p d + 1 else lv p d')\n\ngoal (1 subgoal):\n 1. level (child p dir d) = level p + 1", "have \"level p + 1 =\n    (\\<Sum> d' = 0..<length p. if d' \\<in> {d} then lv p d else lv p d') + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level p + 1 =\n    (\\<Sum>d' = 0..<length p. if d' \\<in> {d} then lv p d else lv p d') + 1", "by (auto intro!: sum.cong simp add: child_lv_other child_lv level_def)"], ["proof (state)\nthis:\n  level p + 1 =\n  (\\<Sum>d' = 0..<length p. if d' \\<in> {d} then lv p d else lv p d') + 1\n\ngoal (1 subgoal):\n 1. level (child p dir d) = level p + 1", "ultimately"], ["proof (chain)\npicking this:\n  level (child p dir d) =\n  (\\<Sum>d' = 0..<length p. if d' \\<in> {d} then lv p d + 1 else lv p d')\n  level p + 1 =\n  (\\<Sum>d' = 0..<length p. if d' \\<in> {d} then lv p d else lv p d') + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  level (child p dir d) =\n  (\\<Sum>d' = 0..<length p. if d' \\<in> {d} then lv p d + 1 else lv p d')\n  level p + 1 =\n  (\\<Sum>d' = 0..<length p. if d' \\<in> {d} then lv p d else lv p d') + 1\n\ngoal (1 subgoal):\n 1. level (child p dir d) = level p + 1", "unfolding sum.If_cases[OF finite_atLeastLessThan] inter"], ["proof (prove)\nusing this:\n  level (child p dir d) =\n  (\\<Sum>d'\\<in>{0..<length p} \\<inter> {d'. d' \\<in> {d}}. lv p d + 1) +\n  sum (lv p) ({0..<length p} \\<inter> - {d'. d' \\<in> {d}})\n  level p + 1 =\n  (\\<Sum>d'\\<in>{0..<length p} \\<inter> {d'. d' \\<in> {d}}. lv p d) +\n  sum (lv p) ({0..<length p} \\<inter> - {d'. d' \\<in> {d}}) +\n  1\n\ngoal (1 subgoal):\n 1. level (child p dir d) = level p + 1", "using assms"], ["proof (prove)\nusing this:\n  level (child p dir d) =\n  (\\<Sum>d'\\<in>{0..<length p} \\<inter> {d'. d' \\<in> {d}}. lv p d + 1) +\n  sum (lv p) ({0..<length p} \\<inter> - {d'. d' \\<in> {d}})\n  level p + 1 =\n  (\\<Sum>d'\\<in>{0..<length p} \\<inter> {d'. d' \\<in> {d}}. lv p d) +\n  sum (lv p) ({0..<length p} \\<inter> - {d'. d' \\<in> {d}}) +\n  1\n  d < length p\n\ngoal (1 subgoal):\n 1. level (child p dir d) = level p + 1", "by auto"], ["proof (state)\nthis:\n  level (child p dir d) = level p + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma child_ex_neighbour: \"\\<exists> b'. child b dir d = child b' (inv dir) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b'. child b dir d = child b' (Grid_Point.inv dir) d", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. child b dir d = child ?b' (Grid_Point.inv dir) d", "show \"child b dir d = child (b[d := (lv b d, ix b d + sgn dir)]) (inv dir) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. child b dir d =\n    child (b[d := (lv b d, ix b d + Grid_Point.sgn dir)])\n     (Grid_Point.inv dir) d", "unfolding child_def ix_def lv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b[d := (fst (b ! d) + 1, 2 * snd (b ! d) + Grid_Point.sgn dir)] = b\n    [d := (fst (b ! d), snd (b ! d) + Grid_Point.sgn dir),\n     d := (fst (b[d := (fst (b ! d), snd (b ! d) + Grid_Point.sgn dir)] !\n                d) +\n           1,\n           2 *\n           snd (b[d := (fst (b ! d), snd (b ! d) + Grid_Point.sgn dir)] !\n                d) +\n           Grid_Point.sgn (Grid_Point.inv dir))]", "by (cases \"d < length b\", auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  child b dir d =\n  child (b[d := (lv b d, ix b d + Grid_Point.sgn dir)]) (Grid_Point.inv dir)\n   d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma child_level_gt[simp]: \"level (child p dir d) >= level p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level p \\<le> level (child p dir d)", "by (cases \"d < length p\", simp, simp add: child_def)"], ["", "lemma child_estimate_child:\n  assumes \"d < length p\"\n    and \"l \\<le> lv p d\"\n    and i'_range: \"ix p d < (i + 1) * 2^(lv p d - l) \\<and>\n                   ix p d > (i - 1) * 2^(lv p d - l)\"\n                  (is \"?top p \\<and> ?bottom p\")\n    and is_child: \"p' = child p dir d\"\n  shows \"?top p' \\<and> ?bottom p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l) \\<and>\n    (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l)\n 2. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "from is_child and \\<open>d < length p\\<close>"], ["proof (chain)\npicking this:\n  p' = child p dir d\n  d < length p", "have \"lv p' d = lv p d + 1\""], ["proof (prove)\nusing this:\n  p' = child p dir d\n  d < length p\n\ngoal (1 subgoal):\n 1. lv p' d = lv p d + 1", "by (auto simp add: child_def ix_def lv_def)"], ["proof (state)\nthis:\n  lv p' d = lv p d + 1\n\ngoal (2 subgoals):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l)\n 2. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "hence \"lv p' d - l = lv p d - l + 1\""], ["proof (prove)\nusing this:\n  lv p' d = lv p d + 1\n\ngoal (1 subgoal):\n 1. lv p' d - l = lv p d - l + 1", "using \\<open>lv p d >= l\\<close>"], ["proof (prove)\nusing this:\n  lv p' d = lv p d + 1\n  l \\<le> lv p d\n\ngoal (1 subgoal):\n 1. lv p' d - l = lv p d - l + 1", "by auto"], ["proof (state)\nthis:\n  lv p' d - l = lv p d - l + 1\n\ngoal (2 subgoals):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l)\n 2. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "hence pow_l'': \"(2^(lv p' d - l) :: int) = 2 * 2^(lv p d - l)\""], ["proof (prove)\nusing this:\n  lv p' d - l = lv p d - l + 1\n\ngoal (1 subgoal):\n 1. 2 ^ (lv p' d - l) = 2 * 2 ^ (lv p d - l)", "by auto"], ["proof (state)\nthis:\n  2 ^ (lv p' d - l) = 2 * 2 ^ (lv p d - l)\n\ngoal (2 subgoals):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l)\n 2. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "show \"?top p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l)", "from is_child and \\<open>d < length p\\<close>"], ["proof (chain)\npicking this:\n  p' = child p dir d\n  d < length p", "have \"ix p' d \\<le> 2 * (ix p d) + 1\""], ["proof (prove)\nusing this:\n  p' = child p dir d\n  d < length p\n\ngoal (1 subgoal):\n 1. ix p' d \\<le> 2 * ix p d + 1", "by (cases dir, auto simp add: child_def lv_def ix_def)"], ["proof (state)\nthis:\n  ix p' d \\<le> 2 * ix p d + 1\n\ngoal (1 subgoal):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l)", "also"], ["proof (state)\nthis:\n  ix p' d \\<le> 2 * ix p d + 1\n\ngoal (1 subgoal):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l)", "have \"\\<dots> < (i + 1) * (2 * 2^(lv p d - l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ix p d + 1 < (i + 1) * (2 * 2 ^ (lv p d - l))", "using i'_range"], ["proof (prove)\nusing this:\n  ix p d < (i + 1) * 2 ^ (lv p d - l) \\<and>\n  (i - 1) * 2 ^ (lv p d - l) < ix p d\n\ngoal (1 subgoal):\n 1. 2 * ix p d + 1 < (i + 1) * (2 * 2 ^ (lv p d - l))", "by auto"], ["proof (state)\nthis:\n  2 * ix p d + 1 < (i + 1) * (2 * 2 ^ (lv p d - l))\n\ngoal (1 subgoal):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l)", "finally"], ["proof (chain)\npicking this:\n  ix p' d < (i + 1) * (2 * 2 ^ (lv p d - l))", "show ?thesis"], ["proof (prove)\nusing this:\n  ix p' d < (i + 1) * (2 * 2 ^ (lv p d - l))\n\ngoal (1 subgoal):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l)", "using pow_l''"], ["proof (prove)\nusing this:\n  ix p' d < (i + 1) * (2 * 2 ^ (lv p d - l))\n  2 ^ (lv p' d - l) = 2 * 2 ^ (lv p d - l)\n\ngoal (1 subgoal):\n 1. ix p' d < (i + 1) * 2 ^ (lv p' d - l)", "by auto"], ["proof (state)\nthis:\n  ix p' d < (i + 1) * 2 ^ (lv p' d - l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ix p' d < (i + 1) * 2 ^ (lv p' d - l)\n\ngoal (1 subgoal):\n 1. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "show \"?bottom p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "have \"(i - 1) * 2^(lv p' d - l) = 2 * ((i - 1) * 2^(lv p d - l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i - 1) * 2 ^ (lv p' d - l) = 2 * ((i - 1) * 2 ^ (lv p d - l))", "using pow_l''"], ["proof (prove)\nusing this:\n  2 ^ (lv p' d - l) = 2 * 2 ^ (lv p d - l)\n\ngoal (1 subgoal):\n 1. (i - 1) * 2 ^ (lv p' d - l) = 2 * ((i - 1) * 2 ^ (lv p d - l))", "by simp"], ["proof (state)\nthis:\n  (i - 1) * 2 ^ (lv p' d - l) = 2 * ((i - 1) * 2 ^ (lv p d - l))\n\ngoal (1 subgoal):\n 1. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "also"], ["proof (state)\nthis:\n  (i - 1) * 2 ^ (lv p' d - l) = 2 * ((i - 1) * 2 ^ (lv p d - l))\n\ngoal (1 subgoal):\n 1. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "have \"\\<dots> < 2 * ix p d - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ((i - 1) * 2 ^ (lv p d - l)) < 2 * ix p d - 1", "using i'_range"], ["proof (prove)\nusing this:\n  ix p d < (i + 1) * 2 ^ (lv p d - l) \\<and>\n  (i - 1) * 2 ^ (lv p d - l) < ix p d\n\ngoal (1 subgoal):\n 1. 2 * ((i - 1) * 2 ^ (lv p d - l)) < 2 * ix p d - 1", "by auto"], ["proof (state)\nthis:\n  2 * ((i - 1) * 2 ^ (lv p d - l)) < 2 * ix p d - 1\n\ngoal (1 subgoal):\n 1. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "finally"], ["proof (chain)\npicking this:\n  (i - 1) * 2 ^ (lv p' d - l) < 2 * ix p d - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  (i - 1) * 2 ^ (lv p' d - l) < 2 * ix p d - 1\n\ngoal (1 subgoal):\n 1. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "using is_child and \\<open>d < length p\\<close>"], ["proof (prove)\nusing this:\n  (i - 1) * 2 ^ (lv p' d - l) < 2 * ix p d - 1\n  p' = child p dir d\n  d < length p\n\ngoal (1 subgoal):\n 1. (i - 1) * 2 ^ (lv p' d - l) < ix p' d", "by (cases dir, auto simp add: child_def lv_def ix_def)"], ["proof (state)\nthis:\n  (i - 1) * 2 ^ (lv p' d - l) < ix p' d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (i - 1) * 2 ^ (lv p' d - l) < ix p' d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma child_neighbour: assumes \"child p (inv dir) d = child ps dir d\" (is \"?c_p = ?c_ps\")\n  shows \"ps = p[d := (lv p d, ix p d - sgn dir)]\" (is \"_ = ?ps\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps = p[d := (lv p d, ix p d - Grid_Point.sgn dir)]", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length ps = length (p[d := (lv p d, ix p d - Grid_Point.sgn dir)])\n 2. \\<And>i.\n       i < length ps \\<Longrightarrow>\n       ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "have \"length ?c_ps = length ?c_p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (child ps dir d) = length (child p (Grid_Point.inv dir) d)", "using \\<open>?c_p = ?c_ps\\<close>"], ["proof (prove)\nusing this:\n  child p (Grid_Point.inv dir) d = child ps dir d\n\ngoal (1 subgoal):\n 1. length (child ps dir d) = length (child p (Grid_Point.inv dir) d)", "by simp"], ["proof (state)\nthis:\n  length (child ps dir d) = length (child p (Grid_Point.inv dir) d)\n\ngoal (2 subgoals):\n 1. length ps = length (p[d := (lv p d, ix p d - Grid_Point.sgn dir)])\n 2. \\<And>i.\n       i < length ps \\<Longrightarrow>\n       ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "hence len_eq: \"length ps = length p\""], ["proof (prove)\nusing this:\n  length (child ps dir d) = length (child p (Grid_Point.inv dir) d)\n\ngoal (1 subgoal):\n 1. length ps = length p", "by simp"], ["proof (state)\nthis:\n  length ps = length p\n\ngoal (2 subgoals):\n 1. length ps = length (p[d := (lv p d, ix p d - Grid_Point.sgn dir)])\n 2. \\<And>i.\n       i < length ps \\<Longrightarrow>\n       ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "thus \"length ps = length ?ps\""], ["proof (prove)\nusing this:\n  length ps = length p\n\ngoal (1 subgoal):\n 1. length ps = length (p[d := (lv p d, ix p d - Grid_Point.sgn dir)])", "by simp"], ["proof (state)\nthis:\n  length ps = length (p[d := (lv p d, ix p d - Grid_Point.sgn dir)])\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length ps \\<Longrightarrow>\n       ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "show \"ps ! i = ?ps ! i\" if \"i < length ps\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "have \"i < length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length p", "using that len_eq"], ["proof (prove)\nusing this:\n  i < length ps\n  length ps = length p\n\ngoal (1 subgoal):\n 1. i < length p", "by auto"], ["proof (state)\nthis:\n  i < length p\n\ngoal (1 subgoal):\n 1. ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "show \"ps ! i = ?ps ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "proof (cases \"d = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d = i \\<Longrightarrow>\n    ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i\n 2. d \\<noteq> i \\<Longrightarrow>\n    ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "case [simp]: True"], ["proof (state)\nthis:\n  d = i\n\ngoal (2 subgoals):\n 1. d = i \\<Longrightarrow>\n    ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i\n 2. d \\<noteq> i \\<Longrightarrow>\n    ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "have \"?c_p ! i = ?c_ps ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. child p (Grid_Point.inv dir) d ! i = child ps dir d ! i", "using \\<open>?c_p = ?c_ps\\<close>"], ["proof (prove)\nusing this:\n  child p (Grid_Point.inv dir) d = child ps dir d\n\ngoal (1 subgoal):\n 1. child p (Grid_Point.inv dir) d ! i = child ps dir d ! i", "by auto"], ["proof (state)\nthis:\n  child p (Grid_Point.inv dir) d ! i = child ps dir d ! i\n\ngoal (2 subgoals):\n 1. d = i \\<Longrightarrow>\n    ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i\n 2. d \\<noteq> i \\<Longrightarrow>\n    ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "hence \"ix p i = ix ps d + sgn dir\" and \"lv p i = lv ps i\""], ["proof (prove)\nusing this:\n  child p (Grid_Point.inv dir) d ! i = child ps dir d ! i\n\ngoal (1 subgoal):\n 1. ix p i = ix ps d + Grid_Point.sgn dir &&& lv p i = lv ps i", "by (auto simp add: child_def\n          nth_list_update_eq[OF \\<open>i < length p\\<close>]\n          nth_list_update_eq[OF \\<open>i < length ps\\<close>])"], ["proof (state)\nthis:\n  ix p i = ix ps d + Grid_Point.sgn dir\n  lv p i = lv ps i\n\ngoal (2 subgoals):\n 1. d = i \\<Longrightarrow>\n    ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i\n 2. d \\<noteq> i \\<Longrightarrow>\n    ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  ix p i = ix ps d + Grid_Point.sgn dir\n  lv p i = lv ps i\n\ngoal (1 subgoal):\n 1. ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "by (simp add: lv_def ix_def \\<open>i < length p\\<close>)"], ["proof (state)\nthis:\n  ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i\n\ngoal (1 subgoal):\n 1. d \\<noteq> i \\<Longrightarrow>\n    ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<noteq> i \\<Longrightarrow>\n    ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "assume \"d \\<noteq> i\""], ["proof (state)\nthis:\n  d \\<noteq> i\n\ngoal (1 subgoal):\n 1. d \\<noteq> i \\<Longrightarrow>\n    ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "with child_other[OF this, of ps dir] child_other[OF this, of p \"inv dir\"]"], ["proof (chain)\npicking this:\n  child ps dir d ! i = ps ! i\n  child p (Grid_Point.inv dir) d ! i = p ! i\n  d \\<noteq> i", "show ?thesis"], ["proof (prove)\nusing this:\n  child ps dir d ! i = ps ! i\n  child p (Grid_Point.inv dir) d ! i = p ! i\n  d \\<noteq> i\n\ngoal (1 subgoal):\n 1. ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "using assms"], ["proof (prove)\nusing this:\n  child ps dir d ! i = ps ! i\n  child p (Grid_Point.inv dir) d ! i = p ! i\n  d \\<noteq> i\n  child p (Grid_Point.inv dir) d = child ps dir d\n\ngoal (1 subgoal):\n 1. ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i", "by auto"], ["proof (state)\nthis:\n  ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ps ! i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length ps \\<Longrightarrow>\n  ps ! ?i = p[d := (lv p d, ix p d - Grid_Point.sgn dir)] ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["", "definition start :: \"nat \\<Rightarrow> grid_point\"\nwhere\n  \"start dm = replicate dm (0, 1)\""], ["", "lemma start_lv[simp]: \"d < dm \\<Longrightarrow> lv (start dm) d = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < dm \\<Longrightarrow> lv (start dm) d = 0", "unfolding start_def lv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d < dm \\<Longrightarrow> fst (replicate dm (0, 1) ! d) = 0", "by simp"], ["", "lemma start_ix[simp]: \"d < dm \\<Longrightarrow> ix (start dm) d = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < dm \\<Longrightarrow> ix (start dm) d = 1", "unfolding start_def ix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d < dm \\<Longrightarrow> snd (replicate dm (0, 1) ! d) = 1", "by simp"], ["", "lemma start_length[simp]: \"length (start dm) = dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (start dm) = dm", "unfolding start_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (replicate dm (0, 1)) = dm", "by auto"], ["", "lemma level_start_0[simp]: \"level (start dm) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level (start dm) = 0", "using level_def"], ["proof (prove)\nusing this:\n  level ?p = sum (lv ?p) {..<length ?p}\n\ngoal (1 subgoal):\n 1. level (start dm) = 0", "by auto"], ["", "end"]]}