{"file_name": "/home/qj213/afp-2021-10-22/thys/UpDown_Scheme/Grid.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/UpDown_Scheme", "problem_names": ["lemma grid_length[simp]: \"p' \\<in> grid p ds \\<Longrightarrow> length p' = length p\"", "lemma grid_union_dims: \"\\<lbrakk> ds \\<subseteq> ds' ; p \\<in> grid b ds \\<rbrakk> \\<Longrightarrow> p \\<in> grid b ds'\"", "lemma grid_transitive: \"\\<lbrakk> a \\<in> grid b ds ; b \\<in> grid c ds' ; ds' \\<subseteq> ds'' ; ds \\<subseteq> ds'' \\<rbrakk> \\<Longrightarrow> a \\<in> grid c ds''\"", "lemma grid_child[intro?]: assumes \"d \\<in> ds\" and p_grid: \"p \\<in> grid (child b dir d) ds\"\n  shows \"p \\<in> grid b ds\"", "lemma grid_single_level[simp]: assumes \"p \\<in> grid b ds\" and \"d < length b\"\n  shows \"lv b d \\<le> lv p d\"", "lemma grid_child_level:\n  assumes \"d < length b\"\n  and p_grid: \"p \\<in> grid (child b dir d) ds\"\n  shows \"lv b d < lv p d\"", "lemma child_out: \"length p \\<le> d \\<Longrightarrow> child p dir d = p\"", "lemma grid_dim_remove:\n  assumes inset: \"p \\<in> grid b ({d} \\<union> ds)\"\n  and eq: \"d < length b \\<Longrightarrow> p ! d = b ! d\"\n  shows \"p \\<in> grid b ds\"", "lemma gridgen_dim_restrict:\n  assumes inset: \"p \\<in> grid b (ds' \\<union> ds)\"\n  and eq: \"\\<forall> d \\<in> ds'. d \\<ge> length b\"\n  shows \"p \\<in> grid b ds\"", "lemma grid_dim_remove_outer: \"grid b ds = grid b {d \\<in> ds. d < length b}\"", "lemma grid_level[intro]: assumes \"p \\<in> grid b ds\" shows \"level b \\<le> level p\"", "lemma grid_empty_ds[simp]: \"grid b {} = { b }\"", "lemma grid_Start: assumes inset: \"p \\<in> grid b ds\" and eq: \"level p = level b\" shows \"p = b\"", "lemma grid_estimate:\n  assumes \"d < length b\" and p_grid: \"p \\<in> grid b ds\"\n  shows \"ix p d < (ix b d + 1) * 2^(lv p d - lv b d) \\<and> ix p d > (ix b d - 1) * 2^(lv p d - lv b d)\"", "lemma grid_odd: assumes \"d < length b\" and p_diff: \"p ! d \\<noteq> b ! d\" and p_grid: \"p \\<in> grid b ds\"\n  shows \"odd (ix p d)\"", "lemma grid_invariant: assumes \"d < length b\" and \"d \\<notin> ds\" and p_grid: \"p \\<in> grid b ds\"\n  shows \"p ! d = b ! d\"", "lemma grid_part: assumes \"d < length b\" and p_valid: \"p \\<in> grid b {d}\" and p'_valid: \"p' \\<in> grid b {d}\"\n  and level: \"lv p' d \\<ge> lv p d\"\n  and right: \"ix p' d \\<le> (ix p d + 1) * 2^(lv p' d - lv p d)\" (is \"?right p p' d\")\n  and left: \"ix p' d \\<ge> (ix p d - 1) * 2^(lv p' d - lv p d)\" (is \"?left p p' d\")\n  shows \"p' \\<in> grid p {d}\"", "lemma grid_disjunct: assumes \"d < length p\"\n  shows \"grid (child p left d) ds \\<inter> grid (child p right d) ds = {}\"\n  (is \"grid ?l ds \\<inter> grid ?r ds = {}\")", "lemma grid_level_eq: assumes eq: \"\\<forall> d \\<in> ds. lv p d = lv b d\" and grid: \"p \\<in> grid b ds\"\n  shows \"level p = level b\"", "lemma grid_partition:\n  \"grid p {d} = {p} \\<union> grid (child p left d) {d} \\<union> grid (child p right d) {d}\"\n  (is \"_ = _ \\<union> grid ?l {d} \\<union> grid ?r {d}\")", "lemma grid_change_dim: assumes grid: \"p \\<in> grid b ds\"\n  shows \"p[d := X] \\<in> grid (b[d := X]) ds\"", "lemma grid_change_dim_child: assumes grid: \"p \\<in> grid b ds\" and \"d \\<notin> ds\"\n  shows \"child p dir d \\<in> grid (child b dir d) ds\"", "lemma grid_split: assumes grid: \"p \\<in> grid b (ds' \\<union> ds)\" shows \"\\<exists> x \\<in> grid b ds. p \\<in> grid x ds'\"", "lemma grid_union_eq: \"(\\<Union> p \\<in> grid b ds. grid p ds') = grid b (ds' \\<union> ds)\"", "lemma grid_onedim_split:\n  \"grid b (ds \\<union> {d}) = grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union> grid (child b right d) (ds \\<union> {d})\"\n  (is \"_ = ?g \\<union> ?l (ds \\<union> {d}) \\<union> ?r (ds \\<union> {d})\")", "lemma grid_child_without_parent: assumes grid: \"p \\<in> grid (child b dir d) ds\" (is \"p \\<in> grid ?c ds\") and \"d < length b\"\n  shows \"p \\<noteq> b\"", "lemma grid_disjunct':\n  assumes \"p \\<in> grid b ds\" and \"p' \\<in> grid b ds\" and \"x \\<in> grid p ds'\" and \"p \\<noteq> p'\" and \"ds \\<inter> ds' = {}\"\n  shows \"x \\<notin> grid p' ds'\"", "lemma grid_split1: assumes grid: \"p \\<in> grid b (ds' \\<union> ds)\" and \"ds \\<inter> ds' = {}\"\n  shows \"\\<exists>! x \\<in> grid b ds. p \\<in> grid x ds'\"", "lemma lgridI[intro]:\n  \"\\<lbrakk> p \\<in> grid b ds ; level p < lm \\<rbrakk> \\<Longrightarrow> p \\<in> lgrid b ds lm\"", "lemma lgridE[elim]:\n  assumes \"p \\<in> lgrid b ds lm\"\n  assumes \"\\<lbrakk> p \\<in> grid b ds ; level p < lm \\<rbrakk> \\<Longrightarrow> P\"\n  shows P", "lemma lgridI_child[intro]:\n  \"d \\<in> ds \\<Longrightarrow> p \\<in> lgrid (child b dir d) ds lm \\<Longrightarrow> p \\<in> lgrid b ds lm\"", "lemma lgrid_empty[simp]: \"lgrid p ds (level p) = {}\"", "lemma lgrid_empty': assumes \"lm \\<le> level p\" shows \"lgrid p ds lm = {}\"", "lemma grid_not_child:\n  assumes [simp]: \"d < length p\"\n  shows \"p \\<notin> grid (child p dir d) ds\"", "lemma grid_subset_alldim:\n  assumes p: \"p \\<in> grid b ds\"\n  defines \"dm \\<equiv> length b\"\n  shows \"p \\<in> grid b {0..<dm}\"", "lemma sparsegrid'_length[simp]:\n  \"b \\<in> sparsegrid' dm \\<Longrightarrow> length b = dm\"", "lemma sparsegrid'I[intro]:\n  assumes b: \"b \\<in> sparsegrid' dm\" and p: \"p \\<in> grid b ds\"\n  shows \"p \\<in> sparsegrid' dm\"", "lemma sparsegrid'_start:\n  assumes \"b \\<in> grid (start dm) ds\"\n  shows \"b \\<in> sparsegrid' dm\"", "lemma sparsegrid_length: \"p \\<in> sparsegrid dm lm \\<Longrightarrow> length p = dm\"", "lemma sparsegrid_subset[intro]: \"p \\<in> sparsegrid dm lm \\<Longrightarrow> p \\<in> sparsegrid' dm\"", "lemma sparsegridI[intro]:\n  assumes \"p \\<in> sparsegrid' dm\" and \"level p < lm\"\n  shows \"p \\<in> sparsegrid dm lm\"", "lemma sparsegrid_start:\n  assumes \"b \\<in> lgrid (start dm) ds lm\"\n  shows \"b \\<in> sparsegrid dm lm\"", "lemma sparsegridE[elim]:\n  assumes \"p \\<in> sparsegrid dm lm\"\n  shows \"p \\<in> sparsegrid' dm\" and \"level p < lm\"", "lemma gridgen_lgrid_eq: \"set (gridgen p ds l) = lgrid p ds (level p + l)\"", "lemma gridgen_distinct: \"distinct (gridgen p ds l)\"", "lemma lgrid_finite: \"finite (lgrid b ds lm)\"", "lemma lgrid_sum:\n  fixes F :: \"grid_point \\<Rightarrow> real\"\n  assumes \"d < length b\" and \"level b < lm\"\n  shows \"(\\<Sum> p \\<in> lgrid b {d} lm. F p) =\n          (\\<Sum> p \\<in> lgrid (child b left d) {d} lm. F p) + (\\<Sum> p \\<in> lgrid (child b right d) {d} lm. F p) + F b\"\n  (is \"(\\<Sum> p \\<in> ?grid b. F p) = (\\<Sum> p \\<in> ?grid ?l . F p) + (?sum (?grid ?r)) + F b\")", "lemma baseE: assumes p_grid: \"p \\<in> sparsegrid' dm\"\n  shows \"base ds p \\<in> grid (start dm) ({0..<dm} - ds)\"\n  and \"p \\<in> grid (base ds p) ds\"", "lemma baseI: assumes x_grid: \"x \\<in> grid (start dm) ({0..<dm} - ds)\" and p_xgrid: \"p \\<in> grid x ds\"\n  shows \"base ds p = x\"", "lemma base_empty: assumes p_grid: \"p \\<in> sparsegrid' dm\" shows \"base {} p = p\"", "lemma base_start_eq: assumes p_spg: \"p \\<in> sparsegrid dm lm\"\n  shows \"start dm = base {0..<dm} p\"", "lemma base_in_grid: assumes p_grid: \"p \\<in> sparsegrid' dm\" shows \"base ds p \\<in> grid (start dm) {0..<dm}\"", "lemma base_grid: assumes p_grid: \"p \\<in> sparsegrid' dm\" shows \"grid (base ds p) ds \\<subseteq> sparsegrid' dm\"", "lemma base_length[simp]: assumes p_grid: \"p \\<in> sparsegrid' dm\" shows \"length (base ds p) = dm\"", "lemma base_in[simp]: assumes \"d < dm\" and \"d \\<in> ds\" and p_grid: \"p \\<in> sparsegrid' dm\" shows \"base ds p ! d = start dm ! d\"", "lemma base_out[simp]: assumes \"d < dm\" and \"d \\<notin> ds\" and p_grid: \"p \\<in> sparsegrid' dm\" shows \"base ds p ! d = p ! d\"", "lemma base_base: assumes p_grid: \"p \\<in> sparsegrid' dm\" shows \"base ds (base ds' p) = base (ds \\<union> ds') p\"", "lemma grid_base_out: assumes \"d < dm\" and \"d \\<notin> ds\" and p_grid: \"b \\<in> sparsegrid' dm\" and \"p \\<in> grid (base ds b) ds\"\n  shows \"p ! d = b ! d\"", "lemma grid_grid_inj_on: assumes \"ds \\<inter> ds' = {}\" shows \"inj_on snd (\\<Union>p'\\<in>grid b ds. \\<Union>p''\\<in>grid p' ds'. {(p', p'')})\"", "lemma grid_level_d: assumes \"d < length b\" and p_grid: \"p \\<in> grid b {d}\" and \"p \\<noteq> b\" shows \"lv p d > lv b d\"", "lemma grid_base_base: assumes \"b \\<in> sparsegrid' dm\"\n  shows \"base ds' b \\<in> grid (base ds (base ds' b)) (ds \\<union> ds')\"", "lemma grid_base_union: assumes b_spg: \"b \\<in> sparsegrid' dm\" and p_grid: \"p \\<in> grid (base ds b) ds\" and x_grid: \"x \\<in> grid (base ds' p) ds'\"\n  shows \"x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')\"", "lemma grid_base_dim_add: assumes \"ds' \\<subseteq> ds\" and b_spg: \"b \\<in> sparsegrid' dm\" and p_grid: \"p \\<in> grid (base ds' b) ds'\"\n  shows \"p \\<in> grid (base ds b) ds\"", "lemma grid_replace_dim: assumes \"d < length b'\" and \"d < length b\" and p_grid: \"p \\<in> grid b ds\" and p'_grid: \"p' \\<in> grid b' ds\"\n  shows \"p[d := p' ! d] \\<in> grid (b[d := b' ! d]) ds\" (is \"_ \\<in> grid ?b ds\")", "lemma grid_shift_base:\n  assumes ds_dj: \"ds \\<inter> ds' = {}\" and b_spg: \"b \\<in> sparsegrid' dm\" and p_grid: \"p \\<in> grid (base (ds' \\<union> ds) b) (ds' \\<union> ds)\"\n  shows \"base ds' p \\<in> grid (base (ds \\<union> ds') b) ds\"", "lemma lift:\n  assumes \"d < dm\" and \"p \\<in> sparsegrid dm lm\"\n  and Fintro: \"\\<And> l b p \\<alpha>. \\<lbrakk> b \\<in> lgrid (start dm) ({0..<dm} - {d}) lm ;\n                          l + level b = lm ; p \\<in> sparsegrid dm lm \\<rbrakk>\n             \\<Longrightarrow> F d l b \\<alpha> p = (if b = base {d} p\n                               then (\\<Sum> p' \\<in> lgrid b {d} lm. S (\\<alpha> p') p p')\n                               else \\<alpha> p)\"\n  shows \"lift F dm lm d \\<alpha> p = (\\<Sum> p' \\<in> lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')\"\n        (is \"?lift = ?S p \\<alpha>\")", "lemma parents_split: assumes p_grid: \"p \\<in> grid (child b dir d) {d}\"\n  shows \"parents d b p = { b } \\<union> parents d (child b dir d) p\"", "lemma parents_no_parent: assumes \"d < length b\" shows \"b \\<notin> parents d (child b dir d) p\" (is \"_ \\<notin> parents _ ?ch _\")", "lemma parents_subset_lgrid: \"parents d b p \\<subseteq> lgrid b {d} (level p + 1)\"", "lemma parents_finite: \"finite (parents d b p)\"", "lemma parent_sum: assumes p_grid: \"p \\<in> grid (child b dir d) {d}\" and \"d < length b\"\n  shows \"(\\<Sum> x \\<in> parents d b p. F x) = F b + (\\<Sum> x \\<in> parents d (child b dir d) p. F x)\"", "lemma parents_single: \"parents d b b = { b }\"", "lemma grid_single_dimensional_specification:\n  assumes \"d < length b\"\n  and \"odd i\"\n  and \"lv b d + l' = l\"\n  and \"i < (ix b d + 1) * 2^l'\"\n  and \"i > (ix b d - 1) * 2^l'\"\n  shows \"b[d := (l,i)] \\<in> grid b {d}\"", "lemma grid_multi_dimensional_specification:\n  assumes \"dm \\<le> length b\" and \"length p = length b\"\n  and \"\\<And> d. d < dm \\<Longrightarrow>\n    odd (ix p d) \\<and>\n    lv b d \\<le> lv p d \\<and>\n    ix p d < (ix b d + 1) * 2^(lv p d - lv b d) \\<and>\n    ix p d > (ix b d - 1) * 2^(lv p d - lv b d)\"\n    (is \"\\<And> d. d < dm \\<Longrightarrow> ?bounded p d\")\n  and \"\\<And> d. \\<lbrakk> dm \\<le> d ; d < length b \\<rbrakk> \\<Longrightarrow> p ! d = b ! d\"\n  shows \"p \\<in> grid b {0..<dm}\"", "lemma sparsegrid:\n  \"sparsegrid dm lm = {p.\n    length p = dm \\<and> level p < lm \\<and>\n    (\\<forall> d < dm. odd (ix p d) \\<and> 0 < ix p d \\<and> ix p d < 2^(lv p d + 1))}\"\n  (is \"_ = ?set\")"], "translations": [["", "lemma grid_length[simp]: \"p' \\<in> grid p ds \\<Longrightarrow> length p' = length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' \\<in> grid p ds \\<Longrightarrow> length p' = length p", "by (erule grid.induct, auto)"], ["", "lemma grid_union_dims: \"\\<lbrakk> ds \\<subseteq> ds' ; p \\<in> grid b ds \\<rbrakk> \\<Longrightarrow> p \\<in> grid b ds'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ds \\<subseteq> ds'; p \\<in> grid b ds\\<rbrakk>\n    \\<Longrightarrow> p \\<in> grid b ds'", "by (erule grid.induct, auto)"], ["", "lemma grid_transitive: \"\\<lbrakk> a \\<in> grid b ds ; b \\<in> grid c ds' ; ds' \\<subseteq> ds'' ; ds \\<subseteq> ds'' \\<rbrakk> \\<Longrightarrow> a \\<in> grid c ds''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> grid b ds; b \\<in> grid c ds'; ds' \\<subseteq> ds'';\n     ds \\<subseteq> ds''\\<rbrakk>\n    \\<Longrightarrow> a \\<in> grid c ds''", "by (erule grid.induct, auto simp add: grid_union_dims)"], ["", "lemma grid_child[intro?]: assumes \"d \\<in> ds\" and p_grid: \"p \\<in> grid (child b dir d) ds\"\n  shows \"p \\<in> grid b ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> grid b ds", "using \\<open>d \\<in> ds\\<close> grid_transitive[OF p_grid]"], ["proof (prove)\nusing this:\n  d \\<in> ds\n  \\<lbrakk>child b dir d \\<in> grid ?c ?ds'; ?ds' \\<subseteq> ?ds'';\n   ds \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid ?c ?ds''\n\ngoal (1 subgoal):\n 1. p \\<in> grid b ds", "by auto"], ["", "lemma grid_single_level[simp]: assumes \"p \\<in> grid b ds\" and \"d < length b\"\n  shows \"lv b d \\<le> lv p d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv b d \\<le> lv p d", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  d < length b\n\ngoal (1 subgoal):\n 1. lv b d \\<le> lv p d", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> lv b d \\<le> lv b d\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ds;\n        d < length b \\<Longrightarrow> lv b d \\<le> lv p d; da \\<in> ds;\n        d < length b\\<rbrakk>\n       \\<Longrightarrow> lv b d \\<le> lv (child p dir da) d", "case (Child p' d' dir)"], ["proof (state)\nthis:\n  p' \\<in> grid b ds\n  d < length b \\<Longrightarrow> lv b d \\<le> lv p' d\n  d' \\<in> ds\n  d < length b\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> lv b d \\<le> lv b d\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ds;\n        d < length b \\<Longrightarrow> lv b d \\<le> lv p d; da \\<in> ds;\n        d < length b\\<rbrakk>\n       \\<Longrightarrow> lv b d \\<le> lv (child p dir da) d", "thus ?case"], ["proof (prove)\nusing this:\n  p' \\<in> grid b ds\n  d < length b \\<Longrightarrow> lv b d \\<le> lv p' d\n  d' \\<in> ds\n  d < length b\n\ngoal (1 subgoal):\n 1. lv b d \\<le> lv (child p' dir d') d", "by (cases \"d' = d\", auto simp add: child_def ix_def lv_def)"], ["proof (state)\nthis:\n  lv b d \\<le> lv (child p' dir d') d\n\ngoal (1 subgoal):\n 1. d < length b \\<Longrightarrow> lv b d \\<le> lv b d", "qed auto"], ["", "lemma grid_child_level:\n  assumes \"d < length b\"\n  and p_grid: \"p \\<in> grid (child b dir d) ds\"\n  shows \"lv b d < lv p d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv b d < lv p d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lv b d < lv p d", "have \"lv b d < lv (child b dir d) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv b d < lv (child b dir d) d", "using child_lv[OF \\<open>d < length b\\<close>]"], ["proof (prove)\nusing this:\n  lv (child b ?dir d) d = lv b d + 1\n\ngoal (1 subgoal):\n 1. lv b d < lv (child b dir d) d", "by auto"], ["proof (state)\nthis:\n  lv b d < lv (child b dir d) d\n\ngoal (1 subgoal):\n 1. lv b d < lv p d", "also"], ["proof (state)\nthis:\n  lv b d < lv (child b dir d) d\n\ngoal (1 subgoal):\n 1. lv b d < lv p d", "have \"\\<dots> \\<le> lv p d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv (child b dir d) d \\<le> lv p d", "using p_grid assms"], ["proof (prove)\nusing this:\n  p \\<in> grid (child b dir d) ds\n  d < length b\n  p \\<in> grid (child b dir d) ds\n\ngoal (1 subgoal):\n 1. lv (child b dir d) d \\<le> lv p d", "by (intro grid_single_level) auto"], ["proof (state)\nthis:\n  lv (child b dir d) d \\<le> lv p d\n\ngoal (1 subgoal):\n 1. lv b d < lv p d", "finally"], ["proof (chain)\npicking this:\n  lv b d < lv p d", "show ?thesis"], ["proof (prove)\nusing this:\n  lv b d < lv p d\n\ngoal (1 subgoal):\n 1. lv b d < lv p d", "."], ["proof (state)\nthis:\n  lv b d < lv p d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma child_out: \"length p \\<le> d \\<Longrightarrow> child p dir d = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p \\<le> d \\<Longrightarrow> child p dir d = p", "unfolding child_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length p \\<le> d \\<Longrightarrow>\n    p[d := (lv p d + 1, 2 * ix p d + Grid_Point.sgn dir)] = p", "by auto"], ["", "lemma grid_dim_remove:\n  assumes inset: \"p \\<in> grid b ({d} \\<union> ds)\"\n  and eq: \"d < length b \\<Longrightarrow> p ! d = b ! d\"\n  shows \"p \\<in> grid b ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> grid b ds", "using inset eq"], ["proof (prove)\nusing this:\n  p \\<in> grid b ({d} \\<union> ds)\n  d < length b \\<Longrightarrow> p ! d = b ! d\n\ngoal (1 subgoal):\n 1. p \\<in> grid b ds", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. (d < length b \\<Longrightarrow> b ! d = b ! d) \\<Longrightarrow>\n    b \\<in> grid b ds\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ({d} \\<union> ds);\n        (d < length b \\<Longrightarrow> p ! d = b ! d) \\<Longrightarrow>\n        p \\<in> grid b ds;\n        da \\<in> {d} \\<union> ds;\n        d < length b \\<Longrightarrow> child p dir da ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> child p dir da \\<in> grid b ds", "case (Child p' d' dir)"], ["proof (state)\nthis:\n  p' \\<in> grid b ({d} \\<union> ds)\n  (d < length b \\<Longrightarrow> p' ! d = b ! d) \\<Longrightarrow>\n  p' \\<in> grid b ds\n  d' \\<in> {d} \\<union> ds\n  d < length b \\<Longrightarrow> child p' dir d' ! d = b ! d\n\ngoal (2 subgoals):\n 1. (d < length b \\<Longrightarrow> b ! d = b ! d) \\<Longrightarrow>\n    b \\<in> grid b ds\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ({d} \\<union> ds);\n        (d < length b \\<Longrightarrow> p ! d = b ! d) \\<Longrightarrow>\n        p \\<in> grid b ds;\n        da \\<in> {d} \\<union> ds;\n        d < length b \\<Longrightarrow> child p dir da ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> child p dir da \\<in> grid b ds", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. child p' dir d' \\<in> grid b ds", "proof (cases \"d' \\<ge> length p'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length p' \\<le> d' \\<Longrightarrow> child p' dir d' \\<in> grid b ds\n 2. \\<not> length p' \\<le> d' \\<Longrightarrow>\n    child p' dir d' \\<in> grid b ds", "case True"], ["proof (state)\nthis:\n  length p' \\<le> d'\n\ngoal (2 subgoals):\n 1. length p' \\<le> d' \\<Longrightarrow> child p' dir d' \\<in> grid b ds\n 2. \\<not> length p' \\<le> d' \\<Longrightarrow>\n    child p' dir d' \\<in> grid b ds", "with child_out[OF this]"], ["proof (chain)\npicking this:\n  child p' ?dir d' = p'\n  length p' \\<le> d'", "show ?thesis"], ["proof (prove)\nusing this:\n  child p' ?dir d' = p'\n  length p' \\<le> d'\n\ngoal (1 subgoal):\n 1. child p' dir d' \\<in> grid b ds", "using Child"], ["proof (prove)\nusing this:\n  child p' ?dir d' = p'\n  length p' \\<le> d'\n  p' \\<in> grid b ({d} \\<union> ds)\n  (d < length b \\<Longrightarrow> p' ! d = b ! d) \\<Longrightarrow>\n  p' \\<in> grid b ds\n  d' \\<in> {d} \\<union> ds\n  d < length b \\<Longrightarrow> child p' dir d' ! d = b ! d\n\ngoal (1 subgoal):\n 1. child p' dir d' \\<in> grid b ds", "by auto"], ["proof (state)\nthis:\n  child p' dir d' \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. \\<not> length p' \\<le> d' \\<Longrightarrow>\n    child p' dir d' \\<in> grid b ds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length p' \\<le> d' \\<Longrightarrow>\n    child p' dir d' \\<in> grid b ds", "case False"], ["proof (state)\nthis:\n  \\<not> length p' \\<le> d'\n\ngoal (1 subgoal):\n 1. \\<not> length p' \\<le> d' \\<Longrightarrow>\n    child p' dir d' \\<in> grid b ds", "hence \"d' < length p'\""], ["proof (prove)\nusing this:\n  \\<not> length p' \\<le> d'\n\ngoal (1 subgoal):\n 1. d' < length p'", "by simp"], ["proof (state)\nthis:\n  d' < length p'\n\ngoal (1 subgoal):\n 1. \\<not> length p' \\<le> d' \\<Longrightarrow>\n    child p' dir d' \\<in> grid b ds", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. child p' dir d' \\<in> grid b ds", "proof (cases \"d' = d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d' = d \\<Longrightarrow> child p' dir d' \\<in> grid b ds\n 2. d' \\<noteq> d \\<Longrightarrow> child p' dir d' \\<in> grid b ds", "case True"], ["proof (state)\nthis:\n  d' = d\n\ngoal (2 subgoals):\n 1. d' = d \\<Longrightarrow> child p' dir d' \\<in> grid b ds\n 2. d' \\<noteq> d \\<Longrightarrow> child p' dir d' \\<in> grid b ds", "hence \"lv b d \\<le> lv p' d\" and \"lv p' d < lv (child p' dir d) d\""], ["proof (prove)\nusing this:\n  d' = d\n\ngoal (1 subgoal):\n 1. lv b d \\<le> lv p' d &&& lv p' d < lv (child p' dir d) d", "using child_single_level Child \\<open>d' < length p'\\<close>"], ["proof (prove)\nusing this:\n  d' = d\n  ?d < length ?p \\<Longrightarrow> lv ?p ?d < lv (child ?p ?dir ?d) ?d\n  p' \\<in> grid b ({d} \\<union> ds)\n  (d < length b \\<Longrightarrow> p' ! d = b ! d) \\<Longrightarrow>\n  p' \\<in> grid b ds\n  d' \\<in> {d} \\<union> ds\n  d < length b \\<Longrightarrow> child p' dir d' ! d = b ! d\n  d' < length p'\n\ngoal (1 subgoal):\n 1. lv b d \\<le> lv p' d &&& lv p' d < lv (child p' dir d) d", "by auto"], ["proof (state)\nthis:\n  lv b d \\<le> lv p' d\n  lv p' d < lv (child p' dir d) d\n\ngoal (2 subgoals):\n 1. d' = d \\<Longrightarrow> child p' dir d' \\<in> grid b ds\n 2. d' \\<noteq> d \\<Longrightarrow> child p' dir d' \\<in> grid b ds", "hence False"], ["proof (prove)\nusing this:\n  lv b d \\<le> lv p' d\n  lv p' d < lv (child p' dir d) d\n\ngoal (1 subgoal):\n 1. False", "using Child and \\<open>d' = d\\<close> and lv_def and \\<open>\\<not> d' \\<ge> length p'\\<close>"], ["proof (prove)\nusing this:\n  lv b d \\<le> lv p' d\n  lv p' d < lv (child p' dir d) d\n  p' \\<in> grid b ({d} \\<union> ds)\n  (d < length b \\<Longrightarrow> p' ! d = b ! d) \\<Longrightarrow>\n  p' \\<in> grid b ds\n  d' \\<in> {d} \\<union> ds\n  d < length b \\<Longrightarrow> child p' dir d' ! d = b ! d\n  d' = d\n  lv ?p ?d = fst (?p ! ?d)\n  \\<not> length p' \\<le> d'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. d' = d \\<Longrightarrow> child p' dir d' \\<in> grid b ds\n 2. d' \\<noteq> d \\<Longrightarrow> child p' dir d' \\<in> grid b ds", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. child p' dir d' \\<in> grid b ds", ".."], ["proof (state)\nthis:\n  child p' dir d' \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. d' \\<noteq> d \\<Longrightarrow> child p' dir d' \\<in> grid b ds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d' \\<noteq> d \\<Longrightarrow> child p' dir d' \\<in> grid b ds", "case False"], ["proof (state)\nthis:\n  d' \\<noteq> d\n\ngoal (1 subgoal):\n 1. d' \\<noteq> d \\<Longrightarrow> child p' dir d' \\<in> grid b ds", "hence \"d' \\<in> ds\""], ["proof (prove)\nusing this:\n  d' \\<noteq> d\n\ngoal (1 subgoal):\n 1. d' \\<in> ds", "using Child"], ["proof (prove)\nusing this:\n  d' \\<noteq> d\n  p' \\<in> grid b ({d} \\<union> ds)\n  (d < length b \\<Longrightarrow> p' ! d = b ! d) \\<Longrightarrow>\n  p' \\<in> grid b ds\n  d' \\<in> {d} \\<union> ds\n  d < length b \\<Longrightarrow> child p' dir d' ! d = b ! d\n\ngoal (1 subgoal):\n 1. d' \\<in> ds", "by auto"], ["proof (state)\nthis:\n  d' \\<in> ds\n\ngoal (1 subgoal):\n 1. d' \\<noteq> d \\<Longrightarrow> child p' dir d' \\<in> grid b ds", "moreover"], ["proof (state)\nthis:\n  d' \\<in> ds\n\ngoal (1 subgoal):\n 1. d' \\<noteq> d \\<Longrightarrow> child p' dir d' \\<in> grid b ds", "have \"d < length b \\<Longrightarrow> p' ! d = b ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length b \\<Longrightarrow> p' ! d = b ! d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d < length b \\<Longrightarrow> p' ! d = b ! d", "assume \"d < length b\""], ["proof (state)\nthis:\n  d < length b\n\ngoal (1 subgoal):\n 1. d < length b \\<Longrightarrow> p' ! d = b ! d", "hence \"d < length p'\""], ["proof (prove)\nusing this:\n  d < length b\n\ngoal (1 subgoal):\n 1. d < length p'", "using Child"], ["proof (prove)\nusing this:\n  d < length b\n  p' \\<in> grid b ({d} \\<union> ds)\n  (d < length b \\<Longrightarrow> p' ! d = b ! d) \\<Longrightarrow>\n  p' \\<in> grid b ds\n  d' \\<in> {d} \\<union> ds\n  d < length b \\<Longrightarrow> child p' dir d' ! d = b ! d\n\ngoal (1 subgoal):\n 1. d < length p'", "by auto"], ["proof (state)\nthis:\n  d < length p'\n\ngoal (1 subgoal):\n 1. d < length b \\<Longrightarrow> p' ! d = b ! d", "hence \"child p' dir d' ! d = p' ! d\""], ["proof (prove)\nusing this:\n  d < length p'\n\ngoal (1 subgoal):\n 1. child p' dir d' ! d = p' ! d", "using child_invariant and False"], ["proof (prove)\nusing this:\n  d < length p'\n  ?d' < length ?p \\<Longrightarrow>\n  (child ?p ?dir ?d ! ?d' = ?p ! ?d') = (?d \\<noteq> ?d')\n  d' \\<noteq> d\n\ngoal (1 subgoal):\n 1. child p' dir d' ! d = p' ! d", "by auto"], ["proof (state)\nthis:\n  child p' dir d' ! d = p' ! d\n\ngoal (1 subgoal):\n 1. d < length b \\<Longrightarrow> p' ! d = b ! d", "thus ?thesis"], ["proof (prove)\nusing this:\n  child p' dir d' ! d = p' ! d\n\ngoal (1 subgoal):\n 1. p' ! d = b ! d", "using Child and \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  child p' dir d' ! d = p' ! d\n  p' \\<in> grid b ({d} \\<union> ds)\n  (d < length b \\<Longrightarrow> p' ! d = b ! d) \\<Longrightarrow>\n  p' \\<in> grid b ds\n  d' \\<in> {d} \\<union> ds\n  d < length b \\<Longrightarrow> child p' dir d' ! d = b ! d\n  d < length b\n\ngoal (1 subgoal):\n 1. p' ! d = b ! d", "by auto"], ["proof (state)\nthis:\n  p' ! d = b ! d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d < length b \\<Longrightarrow> p' ! d = b ! d\n\ngoal (1 subgoal):\n 1. d' \\<noteq> d \\<Longrightarrow> child p' dir d' \\<in> grid b ds", "hence \"p' \\<in> grid b ds\""], ["proof (prove)\nusing this:\n  d < length b \\<Longrightarrow> p' ! d = b ! d\n\ngoal (1 subgoal):\n 1. p' \\<in> grid b ds", "using Child"], ["proof (prove)\nusing this:\n  d < length b \\<Longrightarrow> p' ! d = b ! d\n  p' \\<in> grid b ({d} \\<union> ds)\n  (d < length b \\<Longrightarrow> p' ! d = b ! d) \\<Longrightarrow>\n  p' \\<in> grid b ds\n  d' \\<in> {d} \\<union> ds\n  d < length b \\<Longrightarrow> child p' dir d' ! d = b ! d\n\ngoal (1 subgoal):\n 1. p' \\<in> grid b ds", "by auto"], ["proof (state)\nthis:\n  p' \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. d' \\<noteq> d \\<Longrightarrow> child p' dir d' \\<in> grid b ds", "ultimately"], ["proof (chain)\npicking this:\n  d' \\<in> ds\n  p' \\<in> grid b ds", "show ?thesis"], ["proof (prove)\nusing this:\n  d' \\<in> ds\n  p' \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. child p' dir d' \\<in> grid b ds", "using grid.Child"], ["proof (prove)\nusing this:\n  d' \\<in> ds\n  p' \\<in> grid b ds\n  \\<lbrakk>?p \\<in> grid ?b ?ds; ?d \\<in> ?ds\\<rbrakk>\n  \\<Longrightarrow> child ?p ?dir ?d \\<in> grid ?b ?ds\n\ngoal (1 subgoal):\n 1. child p' dir d' \\<in> grid b ds", "by auto"], ["proof (state)\nthis:\n  child p' dir d' \\<in> grid b ds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  child p' dir d' \\<in> grid b ds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  child p' dir d' \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. (d < length b \\<Longrightarrow> b ! d = b ! d) \\<Longrightarrow>\n    b \\<in> grid b ds", "qed auto"], ["", "lemma gridgen_dim_restrict:\n  assumes inset: \"p \\<in> grid b (ds' \\<union> ds)\"\n  and eq: \"\\<forall> d \\<in> ds'. d \\<ge> length b\"\n  shows \"p \\<in> grid b ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> grid b ds", "using inset eq"], ["proof (prove)\nusing this:\n  p \\<in> grid b (ds' \\<union> ds)\n  \\<forall>d\\<in>ds'. length b \\<le> d\n\ngoal (1 subgoal):\n 1. p \\<in> grid b ds", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball ds' ((\\<le>) (length b)) \\<Longrightarrow> b \\<in> grid b ds\n 2. \\<And>p d dir.\n       \\<lbrakk>p \\<in> grid b (ds' \\<union> ds);\n        Ball ds' ((\\<le>) (length b)) \\<Longrightarrow> p \\<in> grid b ds;\n        d \\<in> ds' \\<union> ds; Ball ds' ((\\<le>) (length b))\\<rbrakk>\n       \\<Longrightarrow> child p dir d \\<in> grid b ds", "case (Child p' d dir)"], ["proof (state)\nthis:\n  p' \\<in> grid b (ds' \\<union> ds)\n  \\<forall>a\\<in>ds'. length b \\<le> a \\<Longrightarrow> p' \\<in> grid b ds\n  d \\<in> ds' \\<union> ds\n  \\<forall>a\\<in>ds'. length b \\<le> a\n\ngoal (2 subgoals):\n 1. Ball ds' ((\\<le>) (length b)) \\<Longrightarrow> b \\<in> grid b ds\n 2. \\<And>p d dir.\n       \\<lbrakk>p \\<in> grid b (ds' \\<union> ds);\n        Ball ds' ((\\<le>) (length b)) \\<Longrightarrow> p \\<in> grid b ds;\n        d \\<in> ds' \\<union> ds; Ball ds' ((\\<le>) (length b))\\<rbrakk>\n       \\<Longrightarrow> child p dir d \\<in> grid b ds", "thus ?case"], ["proof (prove)\nusing this:\n  p' \\<in> grid b (ds' \\<union> ds)\n  \\<forall>a\\<in>ds'. length b \\<le> a \\<Longrightarrow> p' \\<in> grid b ds\n  d \\<in> ds' \\<union> ds\n  \\<forall>a\\<in>ds'. length b \\<le> a\n\ngoal (1 subgoal):\n 1. child p' dir d \\<in> grid b ds", "proof (cases \"d \\<in> ds\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p' \\<in> grid b (ds' \\<union> ds);\n     \\<forall>a\\<in>ds'. length b \\<le> a \\<Longrightarrow>\n     p' \\<in> grid b ds;\n     d \\<in> ds' \\<union> ds; \\<forall>a\\<in>ds'. length b \\<le> a;\n     d \\<in> ds\\<rbrakk>\n    \\<Longrightarrow> child p' dir d \\<in> grid b ds\n 2. \\<lbrakk>p' \\<in> grid b (ds' \\<union> ds);\n     \\<forall>a\\<in>ds'. length b \\<le> a \\<Longrightarrow>\n     p' \\<in> grid b ds;\n     d \\<in> ds' \\<union> ds; \\<forall>a\\<in>ds'. length b \\<le> a;\n     d \\<notin> ds\\<rbrakk>\n    \\<Longrightarrow> child p' dir d \\<in> grid b ds", "case False"], ["proof (state)\nthis:\n  d \\<notin> ds\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p' \\<in> grid b (ds' \\<union> ds);\n     \\<forall>a\\<in>ds'. length b \\<le> a \\<Longrightarrow>\n     p' \\<in> grid b ds;\n     d \\<in> ds' \\<union> ds; \\<forall>a\\<in>ds'. length b \\<le> a;\n     d \\<in> ds\\<rbrakk>\n    \\<Longrightarrow> child p' dir d \\<in> grid b ds\n 2. \\<lbrakk>p' \\<in> grid b (ds' \\<union> ds);\n     \\<forall>a\\<in>ds'. length b \\<le> a \\<Longrightarrow>\n     p' \\<in> grid b ds;\n     d \\<in> ds' \\<union> ds; \\<forall>a\\<in>ds'. length b \\<le> a;\n     d \\<notin> ds\\<rbrakk>\n    \\<Longrightarrow> child p' dir d \\<in> grid b ds", "thus ?thesis"], ["proof (prove)\nusing this:\n  d \\<notin> ds\n\ngoal (1 subgoal):\n 1. child p' dir d \\<in> grid b ds", "using Child and child_def"], ["proof (prove)\nusing this:\n  d \\<notin> ds\n  p' \\<in> grid b (ds' \\<union> ds)\n  \\<forall>a\\<in>ds'. length b \\<le> a \\<Longrightarrow> p' \\<in> grid b ds\n  d \\<in> ds' \\<union> ds\n  \\<forall>a\\<in>ds'. length b \\<le> a\n  child ?p ?dir ?d = ?p\n  [?d := (lv ?p ?d + 1, 2 * ix ?p ?d + Grid_Point.sgn ?dir)]\n\ngoal (1 subgoal):\n 1. child p' dir d \\<in> grid b ds", "by auto"], ["proof (state)\nthis:\n  child p' dir d \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p' \\<in> grid b (ds' \\<union> ds);\n     \\<forall>a\\<in>ds'. length b \\<le> a \\<Longrightarrow>\n     p' \\<in> grid b ds;\n     d \\<in> ds' \\<union> ds; \\<forall>a\\<in>ds'. length b \\<le> a;\n     d \\<in> ds\\<rbrakk>\n    \\<Longrightarrow> child p' dir d \\<in> grid b ds", "qed auto"], ["proof (state)\nthis:\n  child p' dir d \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. Ball ds' ((\\<le>) (length b)) \\<Longrightarrow> b \\<in> grid b ds", "qed auto"], ["", "lemma grid_dim_remove_outer: \"grid b ds = grid b {d \\<in> ds. d < length b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grid b ds = grid b {d \\<in> ds. d < length b}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. grid b ds \\<subseteq> grid b {d \\<in> ds. d < length b}\n 2. grid b {d \\<in> ds. d < length b} \\<subseteq> grid b ds", "have \"{d \\<in> ds. d < length b} \\<subseteq> ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {d \\<in> ds. d < length b} \\<subseteq> ds", "by auto"], ["proof (state)\nthis:\n  {d \\<in> ds. d < length b} \\<subseteq> ds\n\ngoal (2 subgoals):\n 1. grid b ds \\<subseteq> grid b {d \\<in> ds. d < length b}\n 2. grid b {d \\<in> ds. d < length b} \\<subseteq> grid b ds", "from grid_union_dims[OF this]"], ["proof (chain)\npicking this:\n  ?p \\<in> grid ?b {d \\<in> ds. d < length b} \\<Longrightarrow>\n  ?p \\<in> grid ?b ds", "show \"grid b {d \\<in> ds. d < length b} \\<subseteq> grid b ds\""], ["proof (prove)\nusing this:\n  ?p \\<in> grid ?b {d \\<in> ds. d < length b} \\<Longrightarrow>\n  ?p \\<in> grid ?b ds\n\ngoal (1 subgoal):\n 1. grid b {d \\<in> ds. d < length b} \\<subseteq> grid b ds", "by auto"], ["proof (state)\nthis:\n  grid b {d \\<in> ds. d < length b} \\<subseteq> grid b ds\n\ngoal (1 subgoal):\n 1. grid b ds \\<subseteq> grid b {d \\<in> ds. d < length b}", "have \"ds = (ds - {d \\<in> ds. d < length b}) \\<union> {d \\<in> ds. d < length b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ds = ds - {d \\<in> ds. d < length b} \\<union> {d \\<in> ds. d < length b}", "by auto"], ["proof (state)\nthis:\n  ds = ds - {d \\<in> ds. d < length b} \\<union> {d \\<in> ds. d < length b}\n\ngoal (1 subgoal):\n 1. grid b ds \\<subseteq> grid b {d \\<in> ds. d < length b}", "moreover"], ["proof (state)\nthis:\n  ds = ds - {d \\<in> ds. d < length b} \\<union> {d \\<in> ds. d < length b}\n\ngoal (1 subgoal):\n 1. grid b ds \\<subseteq> grid b {d \\<in> ds. d < length b}", "have \"grid b ((ds - {d \\<in> ds. d < length b}) \\<union> {d \\<in> ds. d < length b}) \\<subseteq> grid b {d \\<in> ds. d < length b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grid b\n     (ds - {d \\<in> ds. d < length b} \\<union> {d \\<in> ds. d < length b})\n    \\<subseteq> grid b {d \\<in> ds. d < length b}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grid b\n                (ds - {d \\<in> ds. d < length b} \\<union>\n                 {d \\<in> ds. d < length b}) \\<Longrightarrow>\n       x \\<in> grid b {d \\<in> ds. d < length b}", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grid b\n                (ds - {d \\<in> ds. d < length b} \\<union>\n                 {d \\<in> ds. d < length b}) \\<Longrightarrow>\n       x \\<in> grid b {d \\<in> ds. d < length b}", "assume \"p \\<in> grid b (ds - {d \\<in> ds. d < length b} \\<union> {d \\<in> ds. d < length b})\""], ["proof (state)\nthis:\n  p \\<in> grid b\n           (ds - {d \\<in> ds. d < length b} \\<union>\n            {d \\<in> ds. d < length b})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grid b\n                (ds - {d \\<in> ds. d < length b} \\<union>\n                 {d \\<in> ds. d < length b}) \\<Longrightarrow>\n       x \\<in> grid b {d \\<in> ds. d < length b}", "moreover"], ["proof (state)\nthis:\n  p \\<in> grid b\n           (ds - {d \\<in> ds. d < length b} \\<union>\n            {d \\<in> ds. d < length b})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grid b\n                (ds - {d \\<in> ds. d < length b} \\<union>\n                 {d \\<in> ds. d < length b}) \\<Longrightarrow>\n       x \\<in> grid b {d \\<in> ds. d < length b}", "have \"\\<forall> d \\<in> (ds - {d \\<in> ds. d < length b}). d \\<ge> length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d\\<in>ds - {d \\<in> ds. d < length b}. length b \\<le> d", "by auto"], ["proof (state)\nthis:\n  \\<forall>d\\<in>ds - {d \\<in> ds. d < length b}. length b \\<le> d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grid b\n                (ds - {d \\<in> ds. d < length b} \\<union>\n                 {d \\<in> ds. d < length b}) \\<Longrightarrow>\n       x \\<in> grid b {d \\<in> ds. d < length b}", "ultimately"], ["proof (chain)\npicking this:\n  p \\<in> grid b\n           (ds - {d \\<in> ds. d < length b} \\<union>\n            {d \\<in> ds. d < length b})\n  \\<forall>d\\<in>ds - {d \\<in> ds. d < length b}. length b \\<le> d", "show \"p \\<in> grid b {d \\<in> ds. d < length b}\""], ["proof (prove)\nusing this:\n  p \\<in> grid b\n           (ds - {d \\<in> ds. d < length b} \\<union>\n            {d \\<in> ds. d < length b})\n  \\<forall>d\\<in>ds - {d \\<in> ds. d < length b}. length b \\<le> d\n\ngoal (1 subgoal):\n 1. p \\<in> grid b {d \\<in> ds. d < length b}", "by (rule gridgen_dim_restrict)"], ["proof (state)\nthis:\n  p \\<in> grid b {d \\<in> ds. d < length b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  grid b\n   (ds - {d \\<in> ds. d < length b} \\<union> {d \\<in> ds. d < length b})\n  \\<subseteq> grid b {d \\<in> ds. d < length b}\n\ngoal (1 subgoal):\n 1. grid b ds \\<subseteq> grid b {d \\<in> ds. d < length b}", "ultimately"], ["proof (chain)\npicking this:\n  ds = ds - {d \\<in> ds. d < length b} \\<union> {d \\<in> ds. d < length b}\n  grid b\n   (ds - {d \\<in> ds. d < length b} \\<union> {d \\<in> ds. d < length b})\n  \\<subseteq> grid b {d \\<in> ds. d < length b}", "show \"grid b ds \\<subseteq> grid b {d \\<in> ds. d < length b}\""], ["proof (prove)\nusing this:\n  ds = ds - {d \\<in> ds. d < length b} \\<union> {d \\<in> ds. d < length b}\n  grid b\n   (ds - {d \\<in> ds. d < length b} \\<union> {d \\<in> ds. d < length b})\n  \\<subseteq> grid b {d \\<in> ds. d < length b}\n\ngoal (1 subgoal):\n 1. grid b ds \\<subseteq> grid b {d \\<in> ds. d < length b}", "by auto"], ["proof (state)\nthis:\n  grid b ds \\<subseteq> grid b {d \\<in> ds. d < length b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_level[intro]: assumes \"p \\<in> grid b ds\" shows \"level b \\<le> level p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level b \\<le> level p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. level b \\<le> level p", "have *: \"length p = length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p = length b", "using grid_length assms"], ["proof (prove)\nusing this:\n  ?p' \\<in> grid ?p ?ds \\<Longrightarrow> length ?p' = length ?p\n  p \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. length p = length b", "by auto"], ["proof (state)\nthis:\n  length p = length b\n\ngoal (1 subgoal):\n 1. level b \\<le> level p", "{"], ["proof (state)\nthis:\n  length p = length b\n\ngoal (1 subgoal):\n 1. level b \\<le> level p", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. level b \\<le> level p", "assume \"i \\<in> {0 ..< length p}\""], ["proof (state)\nthis:\n  i \\<in> {0..<length p}\n\ngoal (1 subgoal):\n 1. level b \\<le> level p", "hence \"lv b i \\<le> lv p i\""], ["proof (prove)\nusing this:\n  i \\<in> {0..<length p}\n\ngoal (1 subgoal):\n 1. lv b i \\<le> lv p i", "using \\<open>p \\<in> grid b ds\\<close> and grid_single_level *"], ["proof (prove)\nusing this:\n  i \\<in> {0..<length p}\n  p \\<in> grid b ds\n  \\<lbrakk>?p \\<in> grid ?b ?ds; ?d < length ?b\\<rbrakk>\n  \\<Longrightarrow> lv ?b ?d \\<le> lv ?p ?d\n  length p = length b\n\ngoal (1 subgoal):\n 1. lv b i \\<le> lv p i", "by auto"], ["proof (state)\nthis:\n  lv b i \\<le> lv p i\n\ngoal (1 subgoal):\n 1. level b \\<le> level p", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> {0..<length p} \\<Longrightarrow> lv b ?i2 \\<le> lv p ?i2\n\ngoal (1 subgoal):\n 1. level b \\<le> level p", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?i2 \\<in> {0..<length p} \\<Longrightarrow> lv b ?i2 \\<le> lv p ?i2\n\ngoal (1 subgoal):\n 1. level b \\<le> level p", "unfolding level_def *"], ["proof (prove)\nusing this:\n  ?i2 \\<in> {0..<length b} \\<Longrightarrow> lv b ?i2 \\<le> lv p ?i2\n\ngoal (1 subgoal):\n 1. sum (lv b) {..<length b} \\<le> sum (lv p) {..<length b}", "by (auto intro!: sum_mono)"], ["proof (state)\nthis:\n  level b \\<le> level p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_empty_ds[simp]: \"grid b {} = { b }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grid b {} = {b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. grid b {} = {b}", "have \"!! z. z \\<in> grid b {} \\<Longrightarrow> z = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> grid b {} \\<Longrightarrow> z = b", "by (erule grid.induct, auto)"], ["proof (state)\nthis:\n  ?z \\<in> grid b {} \\<Longrightarrow> ?z = b\n\ngoal (1 subgoal):\n 1. grid b {} = {b}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?z \\<in> grid b {} \\<Longrightarrow> ?z = b\n\ngoal (1 subgoal):\n 1. grid b {} = {b}", "by auto"], ["proof (state)\nthis:\n  grid b {} = {b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_Start: assumes inset: \"p \\<in> grid b ds\" and eq: \"level p = level b\" shows \"p = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = b", "using inset eq"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  level p = level b\n\ngoal (1 subgoal):\n 1. p = b", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. level b = level b \\<Longrightarrow> b = b\n 2. \\<And>p d dir.\n       \\<lbrakk>p \\<in> grid b ds;\n        level p = level b \\<Longrightarrow> p = b; d \\<in> ds;\n        level (child p dir d) = level b\\<rbrakk>\n       \\<Longrightarrow> child p dir d = b", "case (Child p d dir)"], ["proof (state)\nthis:\n  p \\<in> grid b ds\n  level p = level b \\<Longrightarrow> p = b\n  d \\<in> ds\n  level (child p dir d) = level b\n\ngoal (2 subgoals):\n 1. level b = level b \\<Longrightarrow> b = b\n 2. \\<And>p d dir.\n       \\<lbrakk>p \\<in> grid b ds;\n        level p = level b \\<Longrightarrow> p = b; d \\<in> ds;\n        level (child p dir d) = level b\\<rbrakk>\n       \\<Longrightarrow> child p dir d = b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. child p dir d = b", "proof (cases \"d < length b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> child p dir d = b\n 2. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "case True"], ["proof (state)\nthis:\n  d < length b\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> child p dir d = b\n 2. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "from Child"], ["proof (chain)\npicking this:\n  p \\<in> grid b ds\n  level p = level b \\<Longrightarrow> p = b\n  d \\<in> ds\n  level (child p dir d) = level b", "have \"level p \\<ge> level b\""], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  level p = level b \\<Longrightarrow> p = b\n  d \\<in> ds\n  level (child p dir d) = level b\n\ngoal (1 subgoal):\n 1. level b \\<le> level p", "by auto"], ["proof (state)\nthis:\n  level b \\<le> level p\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> child p dir d = b\n 2. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "moreover"], ["proof (state)\nthis:\n  level b \\<le> level p\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> child p dir d = b\n 2. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "have \"level p \\<le> level (child p dir d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level p \\<le> level (child p dir d)", "by (rule child_level_gt)"], ["proof (state)\nthis:\n  level p \\<le> level (child p dir d)\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> child p dir d = b\n 2. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "hence \"level p \\<le> level b\""], ["proof (prove)\nusing this:\n  level p \\<le> level (child p dir d)\n\ngoal (1 subgoal):\n 1. level p \\<le> level b", "using Child"], ["proof (prove)\nusing this:\n  level p \\<le> level (child p dir d)\n  p \\<in> grid b ds\n  level p = level b \\<Longrightarrow> p = b\n  d \\<in> ds\n  level (child p dir d) = level b\n\ngoal (1 subgoal):\n 1. level p \\<le> level b", "by auto"], ["proof (state)\nthis:\n  level p \\<le> level b\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> child p dir d = b\n 2. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "ultimately"], ["proof (chain)\npicking this:\n  level b \\<le> level p\n  level p \\<le> level b", "have \"level p = level b\""], ["proof (prove)\nusing this:\n  level b \\<le> level p\n  level p \\<le> level b\n\ngoal (1 subgoal):\n 1. level p = level b", "by auto"], ["proof (state)\nthis:\n  level p = level b\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> child p dir d = b\n 2. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "hence \"p = b \""], ["proof (prove)\nusing this:\n  level p = level b\n\ngoal (1 subgoal):\n 1. p = b", "using Child(2)"], ["proof (prove)\nusing this:\n  level p = level b\n  level p = level b \\<Longrightarrow> p = b\n\ngoal (1 subgoal):\n 1. p = b", "by auto"], ["proof (state)\nthis:\n  p = b\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> child p dir d = b\n 2. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "with Child(4)"], ["proof (chain)\npicking this:\n  level (child p dir d) = level b\n  p = b", "have \"level (child b dir d) = level b\""], ["proof (prove)\nusing this:\n  level (child p dir d) = level b\n  p = b\n\ngoal (1 subgoal):\n 1. level (child b dir d) = level b", "by auto"], ["proof (state)\nthis:\n  level (child b dir d) = level b\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> child p dir d = b\n 2. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "moreover"], ["proof (state)\nthis:\n  level (child b dir d) = level b\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> child p dir d = b\n 2. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "have \"level (child b dir d) \\<noteq>  level b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level (child b dir d) \\<noteq> level b", "using child_level and \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  ?d < length ?p \\<Longrightarrow> level (child ?p ?dir ?d) = level ?p + 1\n  d < length b\n\ngoal (1 subgoal):\n 1. level (child b dir d) \\<noteq> level b", "by auto"], ["proof (state)\nthis:\n  level (child b dir d) \\<noteq> level b\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow> child p dir d = b\n 2. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "ultimately"], ["proof (chain)\npicking this:\n  level (child b dir d) = level b\n  level (child b dir d) \\<noteq> level b", "show ?thesis"], ["proof (prove)\nusing this:\n  level (child b dir d) = level b\n  level (child b dir d) \\<noteq> level b\n\ngoal (1 subgoal):\n 1. child p dir d = b", "by auto"], ["proof (state)\nthis:\n  child p dir d = b\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "case False"], ["proof (state)\nthis:\n  \\<not> d < length b\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "with Child"], ["proof (chain)\npicking this:\n  p \\<in> grid b ds\n  level p = level b \\<Longrightarrow> p = b\n  d \\<in> ds\n  level (child p dir d) = level b\n  \\<not> d < length b", "have \"length p = length b\""], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  level p = level b \\<Longrightarrow> p = b\n  d \\<in> ds\n  level (child p dir d) = level b\n  \\<not> d < length b\n\ngoal (1 subgoal):\n 1. length p = length b", "by auto"], ["proof (state)\nthis:\n  length p = length b\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "with False"], ["proof (chain)\npicking this:\n  \\<not> d < length b\n  length p = length b", "have \"child p dir d = p\""], ["proof (prove)\nusing this:\n  \\<not> d < length b\n  length p = length b\n\ngoal (1 subgoal):\n 1. child p dir d = p", "using child_def"], ["proof (prove)\nusing this:\n  \\<not> d < length b\n  length p = length b\n  child ?p ?dir ?d = ?p\n  [?d := (lv ?p ?d + 1, 2 * ix ?p ?d + Grid_Point.sgn ?dir)]\n\ngoal (1 subgoal):\n 1. child p dir d = p", "by auto"], ["proof (state)\nthis:\n  child p dir d = p\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "moreover"], ["proof (state)\nthis:\n  child p dir d = p\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "with Child"], ["proof (chain)\npicking this:\n  p \\<in> grid b ds\n  level p = level b \\<Longrightarrow> p = b\n  d \\<in> ds\n  level (child p dir d) = level b\n  child p dir d = p", "have \"level p = level b\""], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  level p = level b \\<Longrightarrow> p = b\n  d \\<in> ds\n  level (child p dir d) = level b\n  child p dir d = p\n\ngoal (1 subgoal):\n 1. level p = level b", "by auto"], ["proof (state)\nthis:\n  level p = level b\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "with Child(2)"], ["proof (chain)\npicking this:\n  level p = level b \\<Longrightarrow> p = b\n  level p = level b", "have \"p = b\""], ["proof (prove)\nusing this:\n  level p = level b \\<Longrightarrow> p = b\n  level p = level b\n\ngoal (1 subgoal):\n 1. p = b", "by auto"], ["proof (state)\nthis:\n  p = b\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> child p dir d = b", "ultimately"], ["proof (chain)\npicking this:\n  child p dir d = p\n  p = b", "show ?thesis"], ["proof (prove)\nusing this:\n  child p dir d = p\n  p = b\n\ngoal (1 subgoal):\n 1. child p dir d = b", "by auto"], ["proof (state)\nthis:\n  child p dir d = b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  child p dir d = b\n\ngoal (1 subgoal):\n 1. level b = level b \\<Longrightarrow> b = b", "qed auto"], ["", "lemma grid_estimate:\n  assumes \"d < length b\" and p_grid: \"p \\<in> grid b ds\"\n  shows \"ix p d < (ix b d + 1) * 2^(lv p d - lv b d) \\<and> ix p d > (ix b d - 1) * 2^(lv p d - lv b d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d", "using p_grid"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. ix b d < (ix b d + 1) * 2 ^ (lv b d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv b d - lv b d) < ix b d\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ds;\n        ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n        (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        da \\<in> ds\\<rbrakk>\n       \\<Longrightarrow> ix (child p dir da) d\n                         < (ix b d + 1) *\n                           2 ^ (lv (child p dir da) d - lv b d) \\<and>\n                         (ix b d - 1) * 2 ^ (lv (child p dir da) d - lv b d)\n                         < ix (child p dir da) d", "case (Child p d' dir)"], ["proof (state)\nthis:\n  p \\<in> grid b ds\n  ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n  (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d\n  d' \\<in> ds\n\ngoal (2 subgoals):\n 1. ix b d < (ix b d + 1) * 2 ^ (lv b d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv b d - lv b d) < ix b d\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ds;\n        ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n        (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        da \\<in> ds\\<rbrakk>\n       \\<Longrightarrow> ix (child p dir da) d\n                         < (ix b d + 1) *\n                           2 ^ (lv (child p dir da) d - lv b d) \\<and>\n                         (ix b d - 1) * 2 ^ (lv (child p dir da) d - lv b d)\n                         < ix (child p dir da) d", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ix (child p dir d') d\n    < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n    < ix (child p dir d') d", "proof (cases \"d = d'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d = d' \\<Longrightarrow>\n    ix (child p dir d') d\n    < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n    < ix (child p dir d') d\n 2. d \\<noteq> d' \\<Longrightarrow>\n    ix (child p dir d') d\n    < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n    < ix (child p dir d') d", "case False"], ["proof (state)\nthis:\n  d \\<noteq> d'\n\ngoal (2 subgoals):\n 1. d = d' \\<Longrightarrow>\n    ix (child p dir d') d\n    < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n    < ix (child p dir d') d\n 2. d \\<noteq> d' \\<Longrightarrow>\n    ix (child p dir d') d\n    < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n    < ix (child p dir d') d", "with Child"], ["proof (chain)\npicking this:\n  p \\<in> grid b ds\n  ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n  (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d\n  d' \\<in> ds\n  d \\<noteq> d'", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n  (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d\n  d' \\<in> ds\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. ix (child p dir d') d\n    < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n    < ix (child p dir d') d", "unfolding child_def lv_def ix_def"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  snd (p ! d) < (snd (b ! d) + 1) * 2 ^ (fst (p ! d) - fst (b ! d)) \\<and>\n  (snd (b ! d) - 1) * 2 ^ (fst (p ! d) - fst (b ! d)) < snd (p ! d)\n  d' \\<in> ds\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. snd (p[d' :=\n             (fst (p ! d') + 1, 2 * snd (p ! d') + Grid_Point.sgn dir)] !\n         d)\n    < (snd (b ! d) + 1) *\n      2 ^\n      (fst (p[d' :=\n                (fst (p ! d') + 1, 2 * snd (p ! d') + Grid_Point.sgn dir)] !\n            d) -\n       fst (b ! d)) \\<and>\n    (snd (b ! d) - 1) *\n    2 ^\n    (fst (p[d' :=\n              (fst (p ! d') + 1, 2 * snd (p ! d') + Grid_Point.sgn dir)] !\n          d) -\n     fst (b ! d))\n    < snd (p[d' :=\n               (fst (p ! d') + 1, 2 * snd (p ! d') + Grid_Point.sgn dir)] !\n           d)", "by auto"], ["proof (state)\nthis:\n  ix (child p dir d') d\n  < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n  (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n  < ix (child p dir d') d\n\ngoal (1 subgoal):\n 1. d = d' \\<Longrightarrow>\n    ix (child p dir d') d\n    < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n    < ix (child p dir d') d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d = d' \\<Longrightarrow>\n    ix (child p dir d') d\n    < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n    < ix (child p dir d') d", "case True"], ["proof (state)\nthis:\n  d = d'\n\ngoal (1 subgoal):\n 1. d = d' \\<Longrightarrow>\n    ix (child p dir d') d\n    < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n    < ix (child p dir d') d", "with child_estimate_child and Child and \\<open>d < length b\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?d < length ?p; ?l \\<le> lv ?p ?d;\n   ix ?p ?d < (?i + 1) * 2 ^ (lv ?p ?d - ?l) \\<and>\n   (?i - 1) * 2 ^ (lv ?p ?d - ?l) < ix ?p ?d;\n   ?p' = child ?p ?dir ?d\\<rbrakk>\n  \\<Longrightarrow> ix ?p' ?d < (?i + 1) * 2 ^ (lv ?p' ?d - ?l) \\<and>\n                    (?i - 1) * 2 ^ (lv ?p' ?d - ?l) < ix ?p' ?d\n  p \\<in> grid b ds\n  ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n  (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d\n  d' \\<in> ds\n  d < length b\n  d = d'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?d < length ?p; ?l \\<le> lv ?p ?d;\n   ix ?p ?d < (?i + 1) * 2 ^ (lv ?p ?d - ?l) \\<and>\n   (?i - 1) * 2 ^ (lv ?p ?d - ?l) < ix ?p ?d;\n   ?p' = child ?p ?dir ?d\\<rbrakk>\n  \\<Longrightarrow> ix ?p' ?d < (?i + 1) * 2 ^ (lv ?p' ?d - ?l) \\<and>\n                    (?i - 1) * 2 ^ (lv ?p' ?d - ?l) < ix ?p' ?d\n  p \\<in> grid b ds\n  ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n  (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d\n  d' \\<in> ds\n  d < length b\n  d = d'\n\ngoal (1 subgoal):\n 1. ix (child p dir d') d\n    < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n    < ix (child p dir d') d", "using grid_single_level"], ["proof (prove)\nusing this:\n  \\<lbrakk>?d < length ?p; ?l \\<le> lv ?p ?d;\n   ix ?p ?d < (?i + 1) * 2 ^ (lv ?p ?d - ?l) \\<and>\n   (?i - 1) * 2 ^ (lv ?p ?d - ?l) < ix ?p ?d;\n   ?p' = child ?p ?dir ?d\\<rbrakk>\n  \\<Longrightarrow> ix ?p' ?d < (?i + 1) * 2 ^ (lv ?p' ?d - ?l) \\<and>\n                    (?i - 1) * 2 ^ (lv ?p' ?d - ?l) < ix ?p' ?d\n  p \\<in> grid b ds\n  ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n  (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d\n  d' \\<in> ds\n  d < length b\n  d = d'\n  \\<lbrakk>?p \\<in> grid ?b ?ds; ?d < length ?b\\<rbrakk>\n  \\<Longrightarrow> lv ?b ?d \\<le> lv ?p ?d\n\ngoal (1 subgoal):\n 1. ix (child p dir d') d\n    < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n    < ix (child p dir d') d", "by auto"], ["proof (state)\nthis:\n  ix (child p dir d') d\n  < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n  (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n  < ix (child p dir d') d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ix (child p dir d') d\n  < (ix b d + 1) * 2 ^ (lv (child p dir d') d - lv b d) \\<and>\n  (ix b d - 1) * 2 ^ (lv (child p dir d') d - lv b d)\n  < ix (child p dir d') d\n\ngoal (1 subgoal):\n 1. ix b d < (ix b d + 1) * 2 ^ (lv b d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv b d - lv b d) < ix b d", "qed auto"], ["", "lemma grid_odd: assumes \"d < length b\" and p_diff: \"p ! d \\<noteq> b ! d\" and p_grid: \"p \\<in> grid b ds\"\n  shows \"odd (ix p d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (ix p d)", "using p_grid and p_diff"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  p ! d \\<noteq> b ! d\n\ngoal (1 subgoal):\n 1. odd (ix p d)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. b ! d \\<noteq> b ! d \\<Longrightarrow> odd (ix b d)\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ds;\n        p ! d \\<noteq> b ! d \\<Longrightarrow> odd (ix p d); da \\<in> ds;\n        child p dir da ! d \\<noteq> b ! d\\<rbrakk>\n       \\<Longrightarrow> odd (ix (child p dir da) d)", "case (Child p d' dir)"], ["proof (state)\nthis:\n  p \\<in> grid b ds\n  p ! d \\<noteq> b ! d \\<Longrightarrow> odd (ix p d)\n  d' \\<in> ds\n  child p dir d' ! d \\<noteq> b ! d\n\ngoal (2 subgoals):\n 1. b ! d \\<noteq> b ! d \\<Longrightarrow> odd (ix b d)\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ds;\n        p ! d \\<noteq> b ! d \\<Longrightarrow> odd (ix p d); da \\<in> ds;\n        child p dir da ! d \\<noteq> b ! d\\<rbrakk>\n       \\<Longrightarrow> odd (ix (child p dir da) d)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (ix (child p dir d') d)", "proof (cases \"d = d'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d = d' \\<Longrightarrow> odd (ix (child p dir d') d)\n 2. d \\<noteq> d' \\<Longrightarrow> odd (ix (child p dir d') d)", "case True"], ["proof (state)\nthis:\n  d = d'\n\ngoal (2 subgoals):\n 1. d = d' \\<Longrightarrow> odd (ix (child p dir d') d)\n 2. d \\<noteq> d' \\<Longrightarrow> odd (ix (child p dir d') d)", "with child_odd and \\<open>d < length b\\<close> and Child"], ["proof (chain)\npicking this:\n  ?d < length ?p \\<Longrightarrow> odd (ix (child ?p ?dir ?d) ?d)\n  d < length b\n  p \\<in> grid b ds\n  p ! d \\<noteq> b ! d \\<Longrightarrow> odd (ix p d)\n  d' \\<in> ds\n  child p dir d' ! d \\<noteq> b ! d\n  d = d'", "show ?thesis"], ["proof (prove)\nusing this:\n  ?d < length ?p \\<Longrightarrow> odd (ix (child ?p ?dir ?d) ?d)\n  d < length b\n  p \\<in> grid b ds\n  p ! d \\<noteq> b ! d \\<Longrightarrow> odd (ix p d)\n  d' \\<in> ds\n  child p dir d' ! d \\<noteq> b ! d\n  d = d'\n\ngoal (1 subgoal):\n 1. odd (ix (child p dir d') d)", "by auto"], ["proof (state)\nthis:\n  odd (ix (child p dir d') d)\n\ngoal (1 subgoal):\n 1. d \\<noteq> d' \\<Longrightarrow> odd (ix (child p dir d') d)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<noteq> d' \\<Longrightarrow> odd (ix (child p dir d') d)", "case False"], ["proof (state)\nthis:\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. d \\<noteq> d' \\<Longrightarrow> odd (ix (child p dir d') d)", "with Child and \\<open>d < length b\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> grid b ds\n  p ! d \\<noteq> b ! d \\<Longrightarrow> odd (ix p d)\n  d' \\<in> ds\n  child p dir d' ! d \\<noteq> b ! d\n  d < length b\n  d \\<noteq> d'", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  p ! d \\<noteq> b ! d \\<Longrightarrow> odd (ix p d)\n  d' \\<in> ds\n  child p dir d' ! d \\<noteq> b ! d\n  d < length b\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. odd (ix (child p dir d') d)", "using child_def and ix_def and lv_def"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  p ! d \\<noteq> b ! d \\<Longrightarrow> odd (ix p d)\n  d' \\<in> ds\n  child p dir d' ! d \\<noteq> b ! d\n  d < length b\n  d \\<noteq> d'\n  child ?p ?dir ?d = ?p\n  [?d := (lv ?p ?d + 1, 2 * ix ?p ?d + Grid_Point.sgn ?dir)]\n  ix ?p ?d = snd (?p ! ?d)\n  lv ?p ?d = fst (?p ! ?d)\n\ngoal (1 subgoal):\n 1. odd (ix (child p dir d') d)", "by auto"], ["proof (state)\nthis:\n  odd (ix (child p dir d') d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd (ix (child p dir d') d)\n\ngoal (1 subgoal):\n 1. b ! d \\<noteq> b ! d \\<Longrightarrow> odd (ix b d)", "qed auto"], ["", "lemma grid_invariant: assumes \"d < length b\" and \"d \\<notin> ds\" and p_grid: \"p \\<in> grid b ds\"\n  shows \"p ! d = b ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! d = b ! d", "using p_grid"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. p ! d = b ! d", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. b ! d = b ! d\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ds; p ! d = b ! d; da \\<in> ds\\<rbrakk>\n       \\<Longrightarrow> child p dir da ! d = b ! d", "case (Child p d' dir)"], ["proof (state)\nthis:\n  p \\<in> grid b ds\n  p ! d = b ! d\n  d' \\<in> ds\n\ngoal (2 subgoals):\n 1. b ! d = b ! d\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ds; p ! d = b ! d; da \\<in> ds\\<rbrakk>\n       \\<Longrightarrow> child p dir da ! d = b ! d", "hence \"d' \\<noteq> d\""], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  p ! d = b ! d\n  d' \\<in> ds\n\ngoal (1 subgoal):\n 1. d' \\<noteq> d", "using \\<open>d \\<notin> ds\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  p ! d = b ! d\n  d' \\<in> ds\n  d \\<notin> ds\n\ngoal (1 subgoal):\n 1. d' \\<noteq> d", "by auto"], ["proof (state)\nthis:\n  d' \\<noteq> d\n\ngoal (2 subgoals):\n 1. b ! d = b ! d\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ds; p ! d = b ! d; da \\<in> ds\\<rbrakk>\n       \\<Longrightarrow> child p dir da ! d = b ! d", "thus ?case"], ["proof (prove)\nusing this:\n  d' \\<noteq> d\n\ngoal (1 subgoal):\n 1. child p dir d' ! d = b ! d", "using child_def and Child"], ["proof (prove)\nusing this:\n  d' \\<noteq> d\n  child ?p ?dir ?d = ?p\n  [?d := (lv ?p ?d + 1, 2 * ix ?p ?d + Grid_Point.sgn ?dir)]\n  p \\<in> grid b ds\n  p ! d = b ! d\n  d' \\<in> ds\n\ngoal (1 subgoal):\n 1. child p dir d' ! d = b ! d", "by auto"], ["proof (state)\nthis:\n  child p dir d' ! d = b ! d\n\ngoal (1 subgoal):\n 1. b ! d = b ! d", "qed auto"], ["", "lemma grid_part: assumes \"d < length b\" and p_valid: \"p \\<in> grid b {d}\" and p'_valid: \"p' \\<in> grid b {d}\"\n  and level: \"lv p' d \\<ge> lv p d\"\n  and right: \"ix p' d \\<le> (ix p d + 1) * 2^(lv p' d - lv p d)\" (is \"?right p p' d\")\n  and left: \"ix p' d \\<ge> (ix p d - 1) * 2^(lv p' d - lv p d)\" (is \"?left p p' d\")\n  shows \"p' \\<in> grid p {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' \\<in> grid p {d}", "using p'_valid left right level and p_valid"], ["proof (prove)\nusing this:\n  p' \\<in> grid b {d}\n  (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d\n  ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n  lv p d \\<le> lv p' d\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. p' \\<in> grid p {d}", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}\n 2. \\<And>pa da dir.\n       \\<lbrakk>pa \\<in> grid b {d};\n        \\<lbrakk>(ix p d - 1) * 2 ^ (lv pa d - lv p d) \\<le> ix pa d;\n         ix pa d \\<le> (ix p d + 1) * 2 ^ (lv pa d - lv p d);\n         lv p d \\<le> lv pa d; p \\<in> grid b {d}\\<rbrakk>\n        \\<Longrightarrow> pa \\<in> grid p {d};\n        da \\<in> {d};\n        (ix p d - 1) * 2 ^ (lv (child pa dir da) d - lv p d)\n        \\<le> ix (child pa dir da) d;\n        ix (child pa dir da) d\n        \\<le> (ix p d + 1) * 2 ^ (lv (child pa dir da) d - lv p d);\n        lv p d \\<le> lv (child pa dir da) d; p \\<in> grid b {d}\\<rbrakk>\n       \\<Longrightarrow> child pa dir da \\<in> grid p {d}", "case (Child p' d' dir)"], ["proof (state)\nthis:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}\n 2. \\<And>pa da dir.\n       \\<lbrakk>pa \\<in> grid b {d};\n        \\<lbrakk>(ix p d - 1) * 2 ^ (lv pa d - lv p d) \\<le> ix pa d;\n         ix pa d \\<le> (ix p d + 1) * 2 ^ (lv pa d - lv p d);\n         lv p d \\<le> lv pa d; p \\<in> grid b {d}\\<rbrakk>\n        \\<Longrightarrow> pa \\<in> grid p {d};\n        da \\<in> {d};\n        (ix p d - 1) * 2 ^ (lv (child pa dir da) d - lv p d)\n        \\<le> ix (child pa dir da) d;\n        ix (child pa dir da) d\n        \\<le> (ix p d + 1) * 2 ^ (lv (child pa dir da) d - lv p d);\n        lv p d \\<le> lv (child pa dir da) d; p \\<in> grid b {d}\\<rbrakk>\n       \\<Longrightarrow> child pa dir da \\<in> grid p {d}", "hence \"d = d'\""], ["proof (prove)\nusing this:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. d = d'", "by auto"], ["proof (state)\nthis:\n  d = d'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}\n 2. \\<And>pa da dir.\n       \\<lbrakk>pa \\<in> grid b {d};\n        \\<lbrakk>(ix p d - 1) * 2 ^ (lv pa d - lv p d) \\<le> ix pa d;\n         ix pa d \\<le> (ix p d + 1) * 2 ^ (lv pa d - lv p d);\n         lv p d \\<le> lv pa d; p \\<in> grid b {d}\\<rbrakk>\n        \\<Longrightarrow> pa \\<in> grid p {d};\n        da \\<in> {d};\n        (ix p d - 1) * 2 ^ (lv (child pa dir da) d - lv p d)\n        \\<le> ix (child pa dir da) d;\n        ix (child pa dir da) d\n        \\<le> (ix p d + 1) * 2 ^ (lv (child pa dir da) d - lv p d);\n        lv p d \\<le> lv (child pa dir da) d; p \\<in> grid b {d}\\<rbrakk>\n       \\<Longrightarrow> child pa dir da \\<in> grid p {d}", "let ?child = \"child p' dir d'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}\n 2. \\<And>pa da dir.\n       \\<lbrakk>pa \\<in> grid b {d};\n        \\<lbrakk>(ix p d - 1) * 2 ^ (lv pa d - lv p d) \\<le> ix pa d;\n         ix pa d \\<le> (ix p d + 1) * 2 ^ (lv pa d - lv p d);\n         lv p d \\<le> lv pa d; p \\<in> grid b {d}\\<rbrakk>\n        \\<Longrightarrow> pa \\<in> grid p {d};\n        da \\<in> {d};\n        (ix p d - 1) * 2 ^ (lv (child pa dir da) d - lv p d)\n        \\<le> ix (child pa dir da) d;\n        ix (child pa dir da) d\n        \\<le> (ix p d + 1) * 2 ^ (lv (child pa dir da) d - lv p d);\n        lv p d \\<le> lv (child pa dir da) d; p \\<in> grid b {d}\\<rbrakk>\n       \\<Longrightarrow> child pa dir da \\<in> grid p {d}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. child p' dir d' \\<in> grid p {d}", "proof (cases \"lv p d = lv ?child d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}\n 2. lv p d \\<noteq> lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "case False"], ["proof (state)\nthis:\n  lv p d \\<noteq> lv (child p' dir d') d\n\ngoal (2 subgoals):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}\n 2. lv p d \\<noteq> lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "moreover"], ["proof (state)\nthis:\n  lv p d \\<noteq> lv (child p' dir d') d\n\ngoal (2 subgoals):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}\n 2. lv p d \\<noteq> lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "have \"lv ?child d = lv p' d + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv (child p' dir d') d = lv p' d + 1", "using child_lv and \\<open>d < length b\\<close> and Child and \\<open>d = d'\\<close>"], ["proof (prove)\nusing this:\n  ?d < length ?p \\<Longrightarrow> lv (child ?p ?dir ?d) ?d = lv ?p ?d + 1\n  d < length b\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  d = d'\n\ngoal (1 subgoal):\n 1. lv (child p' dir d') d = lv p' d + 1", "by auto"], ["proof (state)\nthis:\n  lv (child p' dir d') d = lv p' d + 1\n\ngoal (2 subgoals):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}\n 2. lv p d \\<noteq> lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "ultimately"], ["proof (chain)\npicking this:\n  lv p d \\<noteq> lv (child p' dir d') d\n  lv (child p' dir d') d = lv p' d + 1", "have \"lv p d < lv p' d + 1\""], ["proof (prove)\nusing this:\n  lv p d \\<noteq> lv (child p' dir d') d\n  lv (child p' dir d') d = lv p' d + 1\n\ngoal (1 subgoal):\n 1. lv p d < lv p' d + 1", "using Child"], ["proof (prove)\nusing this:\n  lv p d \\<noteq> lv (child p' dir d') d\n  lv (child p' dir d') d = lv p' d + 1\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. lv p d < lv p' d + 1", "by auto"], ["proof (state)\nthis:\n  lv p d < lv p' d + 1\n\ngoal (2 subgoals):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}\n 2. lv p d \\<noteq> lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "hence lv: \"Suc (lv p' d) - lv p d = Suc (lv p' d - lv p d)\""], ["proof (prove)\nusing this:\n  lv p d < lv p' d + 1\n\ngoal (1 subgoal):\n 1. Suc (lv p' d) - lv p d = Suc (lv p' d - lv p d)", "by auto"], ["proof (state)\nthis:\n  Suc (lv p' d) - lv p d = Suc (lv p' d - lv p d)\n\ngoal (2 subgoals):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}\n 2. lv p d \\<noteq> lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "have \"?left p p' d \\<and> ?right p p' d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "proof (cases dir)"], ["proof (state)\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "case left"], ["proof (state)\nthis:\n  dir = left\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "with Child"], ["proof (chain)\npicking this:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  dir = left", "have \"2 * ix p' d - 1 \\<le> (ix p d + 1) * 2^(Suc (lv p' d) - lv p d)\""], ["proof (prove)\nusing this:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  dir = left\n\ngoal (1 subgoal):\n 1. 2 * ix p' d - 1 \\<le> (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d)", "using \\<open>d = d'\\<close> and \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  dir = left\n  d = d'\n  d < length b\n\ngoal (1 subgoal):\n 1. 2 * ix p' d - 1 \\<le> (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d)", "by (auto simp add: child_def ix_def lv_def)"], ["proof (state)\nthis:\n  2 * ix p' d - 1 \\<le> (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d)\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "also"], ["proof (state)\nthis:\n  2 * ix p' d - 1 \\<le> (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d)\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"\\<dots> = 2 * (ix p d + 1) * 2^(lv p' d - lv p d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d) =\n    2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "using lv"], ["proof (prove)\nusing this:\n  Suc (lv p' d) - lv p d = Suc (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d) =\n    2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "by auto"], ["proof (state)\nthis:\n  (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d) =\n  2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "finally"], ["proof (chain)\npicking this:\n  2 * ix p' d - 1 \\<le> 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"2 * ix p' d - 2 < 2 * (ix p d + 1) * 2^(lv p' d - lv p d)\""], ["proof (prove)\nusing this:\n  2 * ix p' d - 1 \\<le> 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. 2 * ix p' d - 2 < 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "by auto"], ["proof (state)\nthis:\n  2 * ix p' d - 2 < 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "also"], ["proof (state)\nthis:\n  2 * ix p' d - 2 < 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"\\<dots> = 2 * ((ix p d + 1) * 2^(lv p' d - lv p d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d) =\n    2 * ((ix p d + 1) * 2 ^ (lv p' d - lv p d))", "by auto"], ["proof (state)\nthis:\n  2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d) =\n  2 * ((ix p d + 1) * 2 ^ (lv p' d - lv p d))\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "finally"], ["proof (chain)\npicking this:\n  2 * ix p' d - 2 < 2 * ((ix p d + 1) * 2 ^ (lv p' d - lv p d))", "have left_r: \"ix p' d \\<le> (ix p d + 1) * 2^(lv p' d - lv p d)\""], ["proof (prove)\nusing this:\n  2 * ix p' d - 2 < 2 * ((ix p d + 1) * 2 ^ (lv p' d - lv p d))\n\ngoal (1 subgoal):\n 1. ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "by auto"], ["proof (state)\nthis:\n  ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"2 * ((ix p d - 1) * 2^(lv p' d - lv p d)) = 2 * (ix p d - 1) * 2^(lv p' d - lv p d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ((ix p d - 1) * 2 ^ (lv p' d - lv p d)) =\n    2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d)", "by auto"], ["proof (state)\nthis:\n  2 * ((ix p d - 1) * 2 ^ (lv p' d - lv p d)) =\n  2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "also"], ["proof (state)\nthis:\n  2 * ((ix p d - 1) * 2 ^ (lv p' d - lv p d)) =\n  2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"\\<dots> = (ix p d - 1) * 2^(Suc (lv p' d) - lv p d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d) =\n    (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d)", "using lv"], ["proof (prove)\nusing this:\n  Suc (lv p' d) - lv p d = Suc (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. 2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d) =\n    (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d)", "by auto"], ["proof (state)\nthis:\n  2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d) =\n  (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d)\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "also"], ["proof (state)\nthis:\n  2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d) =\n  (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d)\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"\\<dots> \\<le> 2 * ix p' d - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d) \\<le> 2 * ix p' d - 1", "using left and Child and \\<open>d = d'\\<close> and \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  dir = left\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  d = d'\n  d < length b\n\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d) \\<le> 2 * ix p' d - 1", "by (auto simp add: child_def ix_def lv_def)"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d) \\<le> 2 * ix p' d - 1\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "finally"], ["proof (chain)\npicking this:\n  2 * ((ix p d - 1) * 2 ^ (lv p' d - lv p d)) \\<le> 2 * ix p' d - 1", "have right_r: \"((ix p d - 1) * 2^(lv p' d - lv p d)) \\<le> ix p' d\""], ["proof (prove)\nusing this:\n  2 * ((ix p d - 1) * 2 ^ (lv p' d - lv p d)) \\<le> 2 * ix p' d - 1\n\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d", "by auto"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d\n\ngoal (2 subgoals):\n 1. dir = left \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n 2. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "using left_r and right_r"], ["proof (prove)\nusing this:\n  ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n  (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d\n\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "by auto"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n  ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "case right"], ["proof (state)\nthis:\n  dir = right\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "with Child"], ["proof (chain)\npicking this:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  dir = right", "have \"2 * ix p' d + 1 \\<le> (ix p d + 1) * 2^(Suc (lv p' d) - lv p d)\""], ["proof (prove)\nusing this:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  dir = right\n\ngoal (1 subgoal):\n 1. 2 * ix p' d + 1 \\<le> (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d)", "using \\<open>d = d'\\<close> and \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  dir = right\n  d = d'\n  d < length b\n\ngoal (1 subgoal):\n 1. 2 * ix p' d + 1 \\<le> (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d)", "by (auto simp add: child_def ix_def lv_def)"], ["proof (state)\nthis:\n  2 * ix p' d + 1 \\<le> (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "also"], ["proof (state)\nthis:\n  2 * ix p' d + 1 \\<le> (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"\\<dots> = 2 * (ix p d + 1) * 2^(lv p' d - lv p d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d) =\n    2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "using lv"], ["proof (prove)\nusing this:\n  Suc (lv p' d) - lv p d = Suc (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d) =\n    2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "by auto"], ["proof (state)\nthis:\n  (ix p d + 1) * 2 ^ (Suc (lv p' d) - lv p d) =\n  2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "finally"], ["proof (chain)\npicking this:\n  2 * ix p' d + 1 \\<le> 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"2 * ix p' d < 2 * (ix p d + 1) * 2^(lv p' d - lv p d)\""], ["proof (prove)\nusing this:\n  2 * ix p' d + 1 \\<le> 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. 2 * ix p' d < 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "by auto"], ["proof (state)\nthis:\n  2 * ix p' d < 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "also"], ["proof (state)\nthis:\n  2 * ix p' d < 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"\\<dots> = 2 * ((ix p d + 1) * 2^(lv p' d - lv p d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d) =\n    2 * ((ix p d + 1) * 2 ^ (lv p' d - lv p d))", "by auto"], ["proof (state)\nthis:\n  2 * (ix p d + 1) * 2 ^ (lv p' d - lv p d) =\n  2 * ((ix p d + 1) * 2 ^ (lv p' d - lv p d))\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "finally"], ["proof (chain)\npicking this:\n  2 * ix p' d < 2 * ((ix p d + 1) * 2 ^ (lv p' d - lv p d))", "have left_r: \"ix p' d \\<le> (ix p d + 1) * 2^(lv p' d - lv p d)\""], ["proof (prove)\nusing this:\n  2 * ix p' d < 2 * ((ix p d + 1) * 2 ^ (lv p' d - lv p d))\n\ngoal (1 subgoal):\n 1. ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "by auto"], ["proof (state)\nthis:\n  ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"2 * ((ix p d - 1) * 2^(lv p' d - lv p d)) = 2 * (ix p d - 1) * 2^(lv p' d - lv p d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ((ix p d - 1) * 2 ^ (lv p' d - lv p d)) =\n    2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d)", "by auto"], ["proof (state)\nthis:\n  2 * ((ix p d - 1) * 2 ^ (lv p' d - lv p d)) =\n  2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "also"], ["proof (state)\nthis:\n  2 * ((ix p d - 1) * 2 ^ (lv p' d - lv p d)) =\n  2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"\\<dots> = (ix p d - 1) * 2^(Suc (lv p' d) - lv p d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d) =\n    (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d)", "using lv"], ["proof (prove)\nusing this:\n  Suc (lv p' d) - lv p d = Suc (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. 2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d) =\n    (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d)", "by auto"], ["proof (state)\nthis:\n  2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d) =\n  (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "also"], ["proof (state)\nthis:\n  2 * (ix p d - 1) * 2 ^ (lv p' d - lv p d) =\n  (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"\\<dots> \\<le> 2 * ix p' d + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d) \\<le> 2 * ix p' d + 1", "using right and Child and \\<open>d = d'\\<close> and \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  dir = right\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  d = d'\n  d < length b\n\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d) \\<le> 2 * ix p' d + 1", "by (auto simp add: child_def ix_def lv_def)"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d) \\<le> 2 * ix p' d + 1\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "also"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (Suc (lv p' d) - lv p d) \\<le> 2 * ix p' d + 1\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"\\<dots> < 2 * (ix p' d + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ix p' d + 1 < 2 * (ix p' d + 1)", "by auto"], ["proof (state)\nthis:\n  2 * ix p' d + 1 < 2 * (ix p' d + 1)\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "finally"], ["proof (chain)\npicking this:\n  2 * ((ix p d - 1) * 2 ^ (lv p' d - lv p d)) < 2 * (ix p' d + 1)", "have right_r: \"((ix p d - 1) * 2^(lv p' d - lv p d)) \\<le> ix p' d\""], ["proof (prove)\nusing this:\n  2 * ((ix p d - 1) * 2 ^ (lv p' d - lv p d)) < 2 * (ix p' d + 1)\n\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d", "by auto"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d\n\ngoal (1 subgoal):\n 1. dir = right \\<Longrightarrow>\n    (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "using left_r and right_r"], ["proof (prove)\nusing this:\n  ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n  (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d\n\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n    ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "by auto"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n  ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n  ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (2 subgoals):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}\n 2. lv p d \\<noteq> lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "with Child and lv"], ["proof (chain)\npicking this:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  Suc (lv p' d) - lv p d = Suc (lv p' d - lv p d)\n  (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n  ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)", "have \"p' \\<in> grid p {d}\""], ["proof (prove)\nusing this:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  Suc (lv p' d) - lv p d = Suc (lv p' d - lv p d)\n  (ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d \\<and>\n  ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d)\n\ngoal (1 subgoal):\n 1. p' \\<in> grid p {d}", "by auto"], ["proof (state)\nthis:\n  p' \\<in> grid p {d}\n\ngoal (2 subgoals):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}\n 2. lv p d \\<noteq> lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "thus ?thesis"], ["proof (prove)\nusing this:\n  p' \\<in> grid p {d}\n\ngoal (1 subgoal):\n 1. child p' dir d' \\<in> grid p {d}", "using \\<open>d = d'\\<close>"], ["proof (prove)\nusing this:\n  p' \\<in> grid p {d}\n  d = d'\n\ngoal (1 subgoal):\n 1. child p' dir d' \\<in> grid p {d}", "by auto"], ["proof (state)\nthis:\n  child p' dir d' \\<in> grid p {d}\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "case True"], ["proof (state)\nthis:\n  lv p d = lv (child p' dir d') d\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "moreover"], ["proof (state)\nthis:\n  lv p d = lv (child p' dir d') d\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "with Child"], ["proof (chain)\npicking this:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  lv p d = lv (child p' dir d') d", "have \"?left p ?child d \\<and> ?right p ?child d\""], ["proof (prove)\nusing this:\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  lv p d = lv (child p' dir d') d\n\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n    \\<le> ix (child p' dir d') d \\<and>\n    ix (child p' dir d') d\n    \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)", "by auto"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d \\<and>\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "ultimately"], ["proof (chain)\npicking this:\n  lv p d = lv (child p' dir d') d\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d \\<and>\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)", "have range: \"ix p d - 1 \\<le> ix ?child d \\<and> ix ?child d \\<le> ix p d + 1\""], ["proof (prove)\nusing this:\n  lv p d = lv (child p' dir d') d\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d \\<and>\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n\ngoal (1 subgoal):\n 1. ix p d - 1 \\<le> ix (child p' dir d') d \\<and>\n    ix (child p' dir d') d \\<le> ix p d + 1", "by auto"], ["proof (state)\nthis:\n  ix p d - 1 \\<le> ix (child p' dir d') d \\<and>\n  ix (child p' dir d') d \\<le> ix p d + 1\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "have \"p ! d \\<noteq> b ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! d \\<noteq> b ! d", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p ! d \\<noteq> b ! d \\<Longrightarrow> False", "assume \"\\<not> (p ! d \\<noteq> b ! d)\""], ["proof (state)\nthis:\n  \\<not> p ! d \\<noteq> b ! d\n\ngoal (1 subgoal):\n 1. \\<not> p ! d \\<noteq> b ! d \\<Longrightarrow> False", "with \\<open>lv p d = lv ?child d\\<close>"], ["proof (chain)\npicking this:\n  lv p d = lv (child p' dir d') d\n  \\<not> p ! d \\<noteq> b ! d", "have \"lv b d = lv ?child d\""], ["proof (prove)\nusing this:\n  lv p d = lv (child p' dir d') d\n  \\<not> p ! d \\<noteq> b ! d\n\ngoal (1 subgoal):\n 1. lv b d = lv (child p' dir d') d", "by (auto simp add: lv_def)"], ["proof (state)\nthis:\n  lv b d = lv (child p' dir d') d\n\ngoal (1 subgoal):\n 1. \\<not> p ! d \\<noteq> b ! d \\<Longrightarrow> False", "hence \"lv b d = lv p' d + 1\""], ["proof (prove)\nusing this:\n  lv b d = lv (child p' dir d') d\n\ngoal (1 subgoal):\n 1. lv b d = lv p' d + 1", "using \\<open>d = d'\\<close> and Child and \\<open>d < length b\\<close> and child_lv"], ["proof (prove)\nusing this:\n  lv b d = lv (child p' dir d') d\n  d = d'\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  d < length b\n  ?d < length ?p \\<Longrightarrow> lv (child ?p ?dir ?d) ?d = lv ?p ?d + 1\n\ngoal (1 subgoal):\n 1. lv b d = lv p' d + 1", "by auto"], ["proof (state)\nthis:\n  lv b d = lv p' d + 1\n\ngoal (1 subgoal):\n 1. \\<not> p ! d \\<noteq> b ! d \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  lv b d = lv p' d + 1\n\ngoal (1 subgoal):\n 1. \\<not> p ! d \\<noteq> b ! d \\<Longrightarrow> False", "have \"lv b d \\<le> lv p' d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv b d \\<le> lv p' d", "using \\<open>d = d'\\<close> and Child and \\<open>d < length b\\<close> and grid_single_level"], ["proof (prove)\nusing this:\n  d = d'\n  p' \\<in> grid b {d}\n  \\<lbrakk>(ix p d - 1) * 2 ^ (lv p' d - lv p d) \\<le> ix p' d;\n   ix p' d \\<le> (ix p d + 1) * 2 ^ (lv p' d - lv p d);\n   lv p d \\<le> lv p' d; p \\<in> grid b {d}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid p {d}\n  d' \\<in> {d}\n  (ix p d - 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  \\<le> ix (child p' dir d') d\n  ix (child p' dir d') d\n  \\<le> (ix p d + 1) * 2 ^ (lv (child p' dir d') d - lv p d)\n  lv p d \\<le> lv (child p' dir d') d\n  p \\<in> grid b {d}\n  d < length b\n  \\<lbrakk>?p \\<in> grid ?b ?ds; ?d < length ?b\\<rbrakk>\n  \\<Longrightarrow> lv ?b ?d \\<le> lv ?p ?d\n\ngoal (1 subgoal):\n 1. lv b d \\<le> lv p' d", "by auto"], ["proof (state)\nthis:\n  lv b d \\<le> lv p' d\n\ngoal (1 subgoal):\n 1. \\<not> p ! d \\<noteq> b ! d \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  lv b d = lv p' d + 1\n  lv b d \\<le> lv p' d", "show False"], ["proof (prove)\nusing this:\n  lv b d = lv p' d + 1\n  lv b d \\<le> lv p' d\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p ! d \\<noteq> b ! d\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "hence \"odd (ix p d)\""], ["proof (prove)\nusing this:\n  p ! d \\<noteq> b ! d\n\ngoal (1 subgoal):\n 1. odd (ix p d)", "using grid_odd and \\<open>p \\<in> grid b {d}\\<close> and \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  p ! d \\<noteq> b ! d\n  \\<lbrakk>?d < length ?b; ?p ! ?d \\<noteq> ?b ! ?d;\n   ?p \\<in> grid ?b ?ds\\<rbrakk>\n  \\<Longrightarrow> odd (ix ?p ?d)\n  p \\<in> grid b {d}\n  d < length b\n\ngoal (1 subgoal):\n 1. odd (ix p d)", "by auto"], ["proof (state)\nthis:\n  odd (ix p d)\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "hence \"\\<not> odd (ix p d + 1)\" and \"\\<not> odd (ix p d - 1)\""], ["proof (prove)\nusing this:\n  odd (ix p d)\n\ngoal (1 subgoal):\n 1. \\<not> odd (ix p d + 1) &&& \\<not> odd (ix p d - 1)", "by auto"], ["proof (state)\nthis:\n  \\<not> odd (ix p d + 1)\n  \\<not> odd (ix p d - 1)\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "have \"d < length p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p'", "using \\<open>p' \\<in> grid b {d}\\<close> and \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  p' \\<in> grid b {d}\n  d < length b\n\ngoal (1 subgoal):\n 1. d < length p'", "by auto"], ["proof (state)\nthis:\n  d < length p'\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "hence odd_child: \"odd (ix ?child d)\""], ["proof (prove)\nusing this:\n  d < length p'\n\ngoal (1 subgoal):\n 1. odd (ix (child p' dir d') d)", "using child_odd and \\<open>d = d'\\<close>"], ["proof (prove)\nusing this:\n  d < length p'\n  ?d < length ?p \\<Longrightarrow> odd (ix (child ?p ?dir ?d) ?d)\n  d = d'\n\ngoal (1 subgoal):\n 1. odd (ix (child p' dir d') d)", "by auto"], ["proof (state)\nthis:\n  odd (ix (child p' dir d') d)\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "have \"ix p d - 1 \\<noteq> ix ?child d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ix p d - 1 \\<noteq> ix (child p' dir d') d", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ix p d - 1 \\<noteq> ix (child p' dir d') d \\<Longrightarrow>\n    False", "assume \"\\<not> (ix p d - 1 \\<noteq> ix ?child d)\""], ["proof (state)\nthis:\n  \\<not> ix p d - 1 \\<noteq> ix (child p' dir d') d\n\ngoal (1 subgoal):\n 1. \\<not> ix p d - 1 \\<noteq> ix (child p' dir d') d \\<Longrightarrow>\n    False", "hence \"odd (ix p d - 1)\""], ["proof (prove)\nusing this:\n  \\<not> ix p d - 1 \\<noteq> ix (child p' dir d') d\n\ngoal (1 subgoal):\n 1. odd (ix p d - 1)", "using odd_child"], ["proof (prove)\nusing this:\n  \\<not> ix p d - 1 \\<noteq> ix (child p' dir d') d\n  odd (ix (child p' dir d') d)\n\ngoal (1 subgoal):\n 1. odd (ix p d - 1)", "by auto"], ["proof (state)\nthis:\n  odd (ix p d - 1)\n\ngoal (1 subgoal):\n 1. \\<not> ix p d - 1 \\<noteq> ix (child p' dir d') d \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  odd (ix p d - 1)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> odd (ix p d - 1)\\<close>"], ["proof (prove)\nusing this:\n  odd (ix p d - 1)\n  \\<not> odd (ix p d - 1)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ix p d - 1 \\<noteq> ix (child p' dir d') d\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "moreover"], ["proof (state)\nthis:\n  ix p d - 1 \\<noteq> ix (child p' dir d') d\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "have \"ix p d + 1 \\<noteq> ix ?child d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ix p d + 1 \\<noteq> ix (child p' dir d') d", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ix p d + 1 \\<noteq> ix (child p' dir d') d \\<Longrightarrow>\n    False", "assume \"\\<not> (ix p d + 1 \\<noteq> ix ?child d)\""], ["proof (state)\nthis:\n  \\<not> ix p d + 1 \\<noteq> ix (child p' dir d') d\n\ngoal (1 subgoal):\n 1. \\<not> ix p d + 1 \\<noteq> ix (child p' dir d') d \\<Longrightarrow>\n    False", "hence \"odd (ix p d + 1)\""], ["proof (prove)\nusing this:\n  \\<not> ix p d + 1 \\<noteq> ix (child p' dir d') d\n\ngoal (1 subgoal):\n 1. odd (ix p d + 1)", "using odd_child"], ["proof (prove)\nusing this:\n  \\<not> ix p d + 1 \\<noteq> ix (child p' dir d') d\n  odd (ix (child p' dir d') d)\n\ngoal (1 subgoal):\n 1. odd (ix p d + 1)", "by auto"], ["proof (state)\nthis:\n  odd (ix p d + 1)\n\ngoal (1 subgoal):\n 1. \\<not> ix p d + 1 \\<noteq> ix (child p' dir d') d \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  odd (ix p d + 1)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> odd (ix p d + 1)\\<close>"], ["proof (prove)\nusing this:\n  odd (ix p d + 1)\n  \\<not> odd (ix p d + 1)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ix p d + 1 \\<noteq> ix (child p' dir d') d\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "ultimately"], ["proof (chain)\npicking this:\n  ix p d - 1 \\<noteq> ix (child p' dir d') d\n  ix p d + 1 \\<noteq> ix (child p' dir d') d", "have \"ix p d = ix ?child d\""], ["proof (prove)\nusing this:\n  ix p d - 1 \\<noteq> ix (child p' dir d') d\n  ix p d + 1 \\<noteq> ix (child p' dir d') d\n\ngoal (1 subgoal):\n 1. ix p d = ix (child p' dir d') d", "using range"], ["proof (prove)\nusing this:\n  ix p d - 1 \\<noteq> ix (child p' dir d') d\n  ix p d + 1 \\<noteq> ix (child p' dir d') d\n  ix p d - 1 \\<le> ix (child p' dir d') d \\<and>\n  ix (child p' dir d') d \\<le> ix p d + 1\n\ngoal (1 subgoal):\n 1. ix p d = ix (child p' dir d') d", "by auto"], ["proof (state)\nthis:\n  ix p d = ix (child p' dir d') d\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "with True"], ["proof (chain)\npicking this:\n  lv p d = lv (child p' dir d') d\n  ix p d = ix (child p' dir d') d", "have d_eq: \"p ! d = (?child) ! d\""], ["proof (prove)\nusing this:\n  lv p d = lv (child p' dir d') d\n  ix p d = ix (child p' dir d') d\n\ngoal (1 subgoal):\n 1. p ! d = child p' dir d' ! d", "by (auto simp add: prod_eqI ix_def lv_def)"], ["proof (state)\nthis:\n  p ! d = child p' dir d' ! d\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "have \"length p = length ?child\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p = length (child p' dir d')", "using \\<open>p \\<in> grid b {d}\\<close> and \\<open>p' \\<in> grid b {d}\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> grid b {d}\n  p' \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. length p = length (child p' dir d')", "by auto"], ["proof (state)\nthis:\n  length p = length (child p' dir d')\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "moreover"], ["proof (state)\nthis:\n  length p = length (child p' dir d')\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "have \"p ! d'' = ?child ! d''\" if \"d'' < length p\" for d''"], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! d'' = child p' dir d' ! d''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p ! d'' = child p' dir d' ! d''", "have \"d'' < length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d'' < length b", "using that \\<open>p \\<in> grid b {d}\\<close>"], ["proof (prove)\nusing this:\n  d'' < length p\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. d'' < length b", "by auto"], ["proof (state)\nthis:\n  d'' < length b\n\ngoal (1 subgoal):\n 1. p ! d'' = child p' dir d' ! d''", "show \"p ! d'' = ?child ! d''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! d'' = child p' dir d' ! d''", "proof (cases \"d = d''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d = d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''\n 2. d \\<noteq> d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''", "case True"], ["proof (state)\nthis:\n  d = d''\n\ngoal (2 subgoals):\n 1. d = d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''\n 2. d \\<noteq> d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''", "with d_eq"], ["proof (chain)\npicking this:\n  p ! d = child p' dir d' ! d\n  d = d''", "show ?thesis"], ["proof (prove)\nusing this:\n  p ! d = child p' dir d' ! d\n  d = d''\n\ngoal (1 subgoal):\n 1. p ! d'' = child p' dir d' ! d''", "by auto"], ["proof (state)\nthis:\n  p ! d'' = child p' dir d' ! d''\n\ngoal (1 subgoal):\n 1. d \\<noteq> d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<noteq> d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''", "case False"], ["proof (state)\nthis:\n  d \\<noteq> d''\n\ngoal (1 subgoal):\n 1. d \\<noteq> d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''", "hence \"d'' \\<notin> {d}\""], ["proof (prove)\nusing this:\n  d \\<noteq> d''\n\ngoal (1 subgoal):\n 1. d'' \\<notin> {d}", "by auto"], ["proof (state)\nthis:\n  d'' \\<notin> {d}\n\ngoal (1 subgoal):\n 1. d \\<noteq> d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''", "from \\<open>d'' < length b\\<close> and this and \\<open>p \\<in> grid b {d}\\<close>"], ["proof (chain)\npicking this:\n  d'' < length b\n  d'' \\<notin> {d}\n  p \\<in> grid b {d}", "have \"p ! d'' = b ! d''\""], ["proof (prove)\nusing this:\n  d'' < length b\n  d'' \\<notin> {d}\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. p ! d'' = b ! d''", "by (rule grid_invariant)"], ["proof (state)\nthis:\n  p ! d'' = b ! d''\n\ngoal (1 subgoal):\n 1. d \\<noteq> d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''", "also"], ["proof (state)\nthis:\n  p ! d'' = b ! d''\n\ngoal (1 subgoal):\n 1. d \\<noteq> d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''", "have \"\\<dots> = p' ! d''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ! d'' = p' ! d''", "using \\<open>d'' < length b\\<close> and \\<open>d'' \\<notin> {d}\\<close> and \\<open>p' \\<in> grid b {d}\\<close>"], ["proof (prove)\nusing this:\n  d'' < length b\n  d'' \\<notin> {d}\n  p' \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. b ! d'' = p' ! d''", "by (rule grid_invariant[symmetric])"], ["proof (state)\nthis:\n  b ! d'' = p' ! d''\n\ngoal (1 subgoal):\n 1. d \\<noteq> d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''", "also"], ["proof (state)\nthis:\n  b ! d'' = p' ! d''\n\ngoal (1 subgoal):\n 1. d \\<noteq> d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''", "have \"\\<dots> = ?child ! d''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' ! d'' = child p' dir d' ! d''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p' ! d'' = child p' dir d' ! d''", "have \"d'' < length p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d'' < length p'", "using \\<open>d'' < length b\\<close> and \\<open>p' \\<in> grid b {d}\\<close>"], ["proof (prove)\nusing this:\n  d'' < length b\n  p' \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. d'' < length p'", "by auto"], ["proof (state)\nthis:\n  d'' < length p'\n\ngoal (1 subgoal):\n 1. p' ! d'' = child p' dir d' ! d''", "hence \"?child ! d'' = p' ! d''\""], ["proof (prove)\nusing this:\n  d'' < length p'\n\ngoal (1 subgoal):\n 1. child p' dir d' ! d'' = p' ! d''", "using child_invariant and \\<open>d \\<noteq> d''\\<close> and \\<open>d = d'\\<close>"], ["proof (prove)\nusing this:\n  d'' < length p'\n  ?d' < length ?p \\<Longrightarrow>\n  (child ?p ?dir ?d ! ?d' = ?p ! ?d') = (?d \\<noteq> ?d')\n  d \\<noteq> d''\n  d = d'\n\ngoal (1 subgoal):\n 1. child p' dir d' ! d'' = p' ! d''", "by auto"], ["proof (state)\nthis:\n  child p' dir d' ! d'' = p' ! d''\n\ngoal (1 subgoal):\n 1. p' ! d'' = child p' dir d' ! d''", "thus ?thesis"], ["proof (prove)\nusing this:\n  child p' dir d' ! d'' = p' ! d''\n\ngoal (1 subgoal):\n 1. p' ! d'' = child p' dir d' ! d''", "by auto"], ["proof (state)\nthis:\n  p' ! d'' = child p' dir d' ! d''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p' ! d'' = child p' dir d' ! d''\n\ngoal (1 subgoal):\n 1. d \\<noteq> d'' \\<Longrightarrow> p ! d'' = child p' dir d' ! d''", "finally"], ["proof (chain)\npicking this:\n  p ! d'' = child p' dir d' ! d''", "show ?thesis"], ["proof (prove)\nusing this:\n  p ! d'' = child p' dir d' ! d''\n\ngoal (1 subgoal):\n 1. p ! d'' = child p' dir d' ! d''", "."], ["proof (state)\nthis:\n  p ! d'' = child p' dir d' ! d''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p ! d'' = child p' dir d' ! d''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?d'' < length p \\<Longrightarrow> p ! ?d'' = child p' dir d' ! ?d''\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "ultimately"], ["proof (chain)\npicking this:\n  length p = length (child p' dir d')\n  ?d'' < length p \\<Longrightarrow> p ! ?d'' = child p' dir d' ! ?d''", "have \"p = ?child\""], ["proof (prove)\nusing this:\n  length p = length (child p' dir d')\n  ?d'' < length p \\<Longrightarrow> p ! ?d'' = child p' dir d' ! ?d''\n\ngoal (1 subgoal):\n 1. p = child p' dir d'", "by (rule nth_equalityI)"], ["proof (state)\nthis:\n  p = child p' dir d'\n\ngoal (1 subgoal):\n 1. lv p d = lv (child p' dir d') d \\<Longrightarrow>\n    child p' dir d' \\<in> grid p {d}", "thus \"?child \\<in> grid p {d}\""], ["proof (prove)\nusing this:\n  p = child p' dir d'\n\ngoal (1 subgoal):\n 1. child p' dir d' \\<in> grid p {d}", "by auto"], ["proof (state)\nthis:\n  child p' dir d' \\<in> grid p {d}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  child p' dir d' \\<in> grid p {d}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}", "case Start"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d\n  ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d)\n  lv p d \\<le> lv b d\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}", "moreover"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d\n  ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d)\n  lv p d \\<le> lv b d\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}", "hence \"lv b d \\<le> lv p d\""], ["proof (prove)\nusing this:\n  (ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d\n  ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d)\n  lv p d \\<le> lv b d\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. lv b d \\<le> lv p d", "using grid_single_level and \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  (ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d\n  ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d)\n  lv p d \\<le> lv b d\n  p \\<in> grid b {d}\n  \\<lbrakk>?p \\<in> grid ?b ?ds; ?d < length ?b\\<rbrakk>\n  \\<Longrightarrow> lv ?b ?d \\<le> lv ?p ?d\n  d < length b\n\ngoal (1 subgoal):\n 1. lv b d \\<le> lv p d", "by auto"], ["proof (state)\nthis:\n  lv b d \\<le> lv p d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}", "ultimately"], ["proof (chain)\npicking this:\n  (ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d\n  ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d)\n  lv p d \\<le> lv b d\n  p \\<in> grid b {d}\n  lv b d \\<le> lv p d", "have \"lv b d = lv p d\""], ["proof (prove)\nusing this:\n  (ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d\n  ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d)\n  lv p d \\<le> lv b d\n  p \\<in> grid b {d}\n  lv b d \\<le> lv p d\n\ngoal (1 subgoal):\n 1. lv b d = lv p d", "by auto"], ["proof (state)\nthis:\n  lv b d = lv p d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}", "have \"level p = level b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level p = level b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. level p = level b", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. level p = level b", "fix d'"], ["proof (state)\ngoal (1 subgoal):\n 1. level p = level b", "assume \"d' < length b\""], ["proof (state)\nthis:\n  d' < length b\n\ngoal (1 subgoal):\n 1. level p = level b", "have \"lv b d' = lv p d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv b d' = lv p d'", "proof (cases \"d = d'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d = d' \\<Longrightarrow> lv b d' = lv p d'\n 2. d \\<noteq> d' \\<Longrightarrow> lv b d' = lv p d'", "case True"], ["proof (state)\nthis:\n  d = d'\n\ngoal (2 subgoals):\n 1. d = d' \\<Longrightarrow> lv b d' = lv p d'\n 2. d \\<noteq> d' \\<Longrightarrow> lv b d' = lv p d'", "with \\<open>lv b d = lv p d\\<close>"], ["proof (chain)\npicking this:\n  lv b d = lv p d\n  d = d'", "show ?thesis"], ["proof (prove)\nusing this:\n  lv b d = lv p d\n  d = d'\n\ngoal (1 subgoal):\n 1. lv b d' = lv p d'", "by auto"], ["proof (state)\nthis:\n  lv b d' = lv p d'\n\ngoal (1 subgoal):\n 1. d \\<noteq> d' \\<Longrightarrow> lv b d' = lv p d'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<noteq> d' \\<Longrightarrow> lv b d' = lv p d'", "case False"], ["proof (state)\nthis:\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. d \\<noteq> d' \\<Longrightarrow> lv b d' = lv p d'", "hence \"d' \\<notin> {d}\""], ["proof (prove)\nusing this:\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. d' \\<notin> {d}", "by auto"], ["proof (state)\nthis:\n  d' \\<notin> {d}\n\ngoal (1 subgoal):\n 1. d \\<noteq> d' \\<Longrightarrow> lv b d' = lv p d'", "from \\<open>d' < length b\\<close> and this and \\<open>p \\<in> grid b {d}\\<close>"], ["proof (chain)\npicking this:\n  d' < length b\n  d' \\<notin> {d}\n  p \\<in> grid b {d}", "have \"p ! d' = b ! d'\""], ["proof (prove)\nusing this:\n  d' < length b\n  d' \\<notin> {d}\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. p ! d' = b ! d'", "by (rule grid_invariant)"], ["proof (state)\nthis:\n  p ! d' = b ! d'\n\ngoal (1 subgoal):\n 1. d \\<noteq> d' \\<Longrightarrow> lv b d' = lv p d'", "thus ?thesis"], ["proof (prove)\nusing this:\n  p ! d' = b ! d'\n\ngoal (1 subgoal):\n 1. lv b d' = lv p d'", "by (auto simp add: lv_def)"], ["proof (state)\nthis:\n  lv b d' = lv p d'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lv b d' = lv p d'\n\ngoal (1 subgoal):\n 1. level p = level b", "}"], ["proof (state)\nthis:\n  ?d'2 < length b \\<Longrightarrow> lv b ?d'2 = lv p ?d'2\n\ngoal (1 subgoal):\n 1. level p = level b", "moreover"], ["proof (state)\nthis:\n  ?d'2 < length b \\<Longrightarrow> lv b ?d'2 = lv p ?d'2\n\ngoal (1 subgoal):\n 1. level p = level b", "have \"length b = length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length b = length p", "using \\<open>p \\<in> grid b {d}\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. length b = length p", "by auto"], ["proof (state)\nthis:\n  length b = length p\n\ngoal (1 subgoal):\n 1. level p = level b", "ultimately"], ["proof (chain)\npicking this:\n  ?d'2 < length b \\<Longrightarrow> lv b ?d'2 = lv p ?d'2\n  length b = length p", "show ?thesis"], ["proof (prove)\nusing this:\n  ?d'2 < length b \\<Longrightarrow> lv b ?d'2 = lv p ?d'2\n  length b = length p\n\ngoal (1 subgoal):\n 1. level p = level b", "by (rule level_all_eq)"], ["proof (state)\nthis:\n  level p = level b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  level p = level b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}", "hence \"p = b\""], ["proof (prove)\nusing this:\n  level p = level b\n\ngoal (1 subgoal):\n 1. p = b", "using grid_Start and \\<open>p \\<in> grid b {d}\\<close>"], ["proof (prove)\nusing this:\n  level p = level b\n  \\<lbrakk>?p \\<in> grid ?b ?ds; level ?p = level ?b\\<rbrakk>\n  \\<Longrightarrow> ?p = ?b\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. p = b", "by auto"], ["proof (state)\nthis:\n  p = b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(ix p d - 1) * 2 ^ (lv b d - lv p d) \\<le> ix b d;\n     ix b d \\<le> (ix p d + 1) * 2 ^ (lv b d - lv p d); lv p d \\<le> lv b d;\n     p \\<in> grid b {d}\\<rbrakk>\n    \\<Longrightarrow> b \\<in> grid p {d}", "thus ?case"], ["proof (prove)\nusing this:\n  p = b\n\ngoal (1 subgoal):\n 1. b \\<in> grid p {d}", "by auto"], ["proof (state)\nthis:\n  b \\<in> grid p {d}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_disjunct: assumes \"d < length p\"\n  shows \"grid (child p left d) ds \\<inter> grid (child p right d) ds = {}\"\n  (is \"grid ?l ds \\<inter> grid ?r ds = {}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. grid (child p left d) ds \\<inter> grid (child p right d) ds = {}", "proof (intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> grid (child p left d) ds \\<inter>\n               grid (child p right d) ds \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> grid (child p left d) ds \\<inter> grid (child p right d) ds", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> grid (child p left d) ds \\<inter>\n               grid (child p right d) ds \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> grid (child p left d) ds \\<inter> grid (child p right d) ds", "assume \"x \\<in> grid ?l ds \\<inter> grid ?r ds\""], ["proof (state)\nthis:\n  x \\<in> grid (child p left d) ds \\<inter> grid (child p right d) ds\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> grid (child p left d) ds \\<inter>\n               grid (child p right d) ds \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> grid (child p left d) ds \\<inter> grid (child p right d) ds", "hence \"ix x d < (ix ?l d + 1) * 2^(lv x d - lv ?l d)\"\n    and \"ix x d > (ix ?r d - 1) * 2^(lv x d - lv ?r d)\""], ["proof (prove)\nusing this:\n  x \\<in> grid (child p left d) ds \\<inter> grid (child p right d) ds\n\ngoal (1 subgoal):\n 1. ix x d\n    < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d) &&&\n    (ix (child p right d) d - 1) * 2 ^ (lv x d - lv (child p right d) d)\n    < ix x d", "using grid_estimate \\<open>d < length p\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> grid (child p left d) ds \\<inter> grid (child p right d) ds\n  \\<lbrakk>?d < length ?b; ?p \\<in> grid ?b ?ds\\<rbrakk>\n  \\<Longrightarrow> ix ?p ?d\n                    < (ix ?b ?d + 1) * 2 ^ (lv ?p ?d - lv ?b ?d) \\<and>\n                    (ix ?b ?d - 1) * 2 ^ (lv ?p ?d - lv ?b ?d) < ix ?p ?d\n  d < length p\n\ngoal (1 subgoal):\n 1. ix x d\n    < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d) &&&\n    (ix (child p right d) d - 1) * 2 ^ (lv x d - lv (child p right d) d)\n    < ix x d", "by auto"], ["proof (state)\nthis:\n  ix x d\n  < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d)\n  (ix (child p right d) d - 1) * 2 ^ (lv x d - lv (child p right d) d)\n  < ix x d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> grid (child p left d) ds \\<inter>\n               grid (child p right d) ds \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> grid (child p left d) ds \\<inter> grid (child p right d) ds", "thus \"x \\<in> {}\""], ["proof (prove)\nusing this:\n  ix x d\n  < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d)\n  (ix (child p right d) d - 1) * 2 ^ (lv x d - lv (child p right d) d)\n  < ix x d\n\ngoal (1 subgoal):\n 1. x \\<in> {}", "using \\<open>d < length p\\<close> and child_lv and child_ix"], ["proof (prove)\nusing this:\n  ix x d\n  < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d)\n  (ix (child p right d) d - 1) * 2 ^ (lv x d - lv (child p right d) d)\n  < ix x d\n  d < length p\n  ?d < length ?p \\<Longrightarrow> lv (child ?p ?dir ?d) ?d = lv ?p ?d + 1\n  ?d < length ?p \\<Longrightarrow>\n  ix (child ?p ?dir ?d) ?d = 2 * ix ?p ?d + Grid_Point.sgn ?dir\n\ngoal (1 subgoal):\n 1. x \\<in> {}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> grid (child p left d) ds \\<inter> grid (child p right d) ds", "qed auto"], ["", "lemma grid_level_eq: assumes eq: \"\\<forall> d \\<in> ds. lv p d = lv b d\" and grid: \"p \\<in> grid b ds\"\n  shows \"level p = level b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level p = level b", "proof (rule level_all_eq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>d. d < length b \\<Longrightarrow> lv b d = lv p d\n 2. length b = length p", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>d. d < length b \\<Longrightarrow> lv b d = lv p d\n 2. length b = length p", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>d. d < length b \\<Longrightarrow> lv b d = lv p d\n 2. length b = length p", "assume \"i < length b\""], ["proof (state)\nthis:\n  i < length b\n\ngoal (2 subgoals):\n 1. \\<And>d. d < length b \\<Longrightarrow> lv b d = lv p d\n 2. length b = length p", "show \"lv b i = lv p i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv b i = lv p i", "proof (cases \"i \\<in> ds\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> ds \\<Longrightarrow> lv b i = lv p i\n 2. i \\<notin> ds \\<Longrightarrow> lv b i = lv p i", "case True"], ["proof (state)\nthis:\n  i \\<in> ds\n\ngoal (2 subgoals):\n 1. i \\<in> ds \\<Longrightarrow> lv b i = lv p i\n 2. i \\<notin> ds \\<Longrightarrow> lv b i = lv p i", "with eq"], ["proof (chain)\npicking this:\n  \\<forall>d\\<in>ds. lv p d = lv b d\n  i \\<in> ds", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>ds. lv p d = lv b d\n  i \\<in> ds\n\ngoal (1 subgoal):\n 1. lv b i = lv p i", "by auto"], ["proof (state)\nthis:\n  lv b i = lv p i\n\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<Longrightarrow> lv b i = lv p i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<Longrightarrow> lv b i = lv p i", "case False"], ["proof (state)\nthis:\n  i \\<notin> ds\n\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<Longrightarrow> lv b i = lv p i", "with \\<open>i < length b\\<close> and grid"], ["proof (chain)\npicking this:\n  i < length b\n  p \\<in> grid b ds\n  i \\<notin> ds", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length b\n  p \\<in> grid b ds\n  i \\<notin> ds\n\ngoal (1 subgoal):\n 1. lv b i = lv p i", "using lv_def ix_def grid_invariant"], ["proof (prove)\nusing this:\n  i < length b\n  p \\<in> grid b ds\n  i \\<notin> ds\n  lv ?p ?d = fst (?p ! ?d)\n  ix ?p ?d = snd (?p ! ?d)\n  \\<lbrakk>?d < length ?b; ?d \\<notin> ?ds; ?p \\<in> grid ?b ?ds\\<rbrakk>\n  \\<Longrightarrow> ?p ! ?d = ?b ! ?d\n\ngoal (1 subgoal):\n 1. lv b i = lv p i", "by auto"], ["proof (state)\nthis:\n  lv b i = lv p i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lv b i = lv p i\n\ngoal (1 subgoal):\n 1. length b = length p", "}"], ["proof (state)\nthis:\n  ?i2 < length b \\<Longrightarrow> lv b ?i2 = lv p ?i2\n\ngoal (1 subgoal):\n 1. length b = length p", "show \"length b = length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length b = length p", "using grid"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. length b = length p", "by auto"], ["proof (state)\nthis:\n  length b = length p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_partition:\n  \"grid p {d} = {p} \\<union> grid (child p left d) {d} \\<union> grid (child p right d) {d}\"\n  (is \"_ = _ \\<union> grid ?l {d} \\<union> grid ?r {d}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. grid p {d} =\n    {p} \\<union> grid (child p left d) {d} \\<union>\n    grid (child p right d) {d}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. grid p {d} =\n    {p} \\<union> grid (child p left d) {d} \\<union>\n    grid (child p right d) {d}", "have \"!! x. \\<lbrakk> x \\<in> grid p {d} ; x \\<noteq> p ; x \\<notin> grid ?r {d} \\<rbrakk> \\<Longrightarrow> x \\<in> grid ?l {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "proof (cases \"d < length p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "case True"], ["proof (state)\nthis:\n  d < length p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "let \"?nr_r p\" = \"ix x d > (ix p d + 1) * 2 ^ (lv x d - lv p d)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "let \"?nr_l p\" = \"(ix p d - 1) * 2 ^ (lv x d - lv p d) > ix x d\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have ix_r_eq: \"ix ?r d = 2 * ix p d + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ix (child p right d) d = 2 * ix p d + 1", "using \\<open>d < length p\\<close> and child_ix"], ["proof (prove)\nusing this:\n  d < length p\n  ?d < length ?p \\<Longrightarrow>\n  ix (child ?p ?dir ?d) ?d = 2 * ix ?p ?d + Grid_Point.sgn ?dir\n\ngoal (1 subgoal):\n 1. ix (child p right d) d = 2 * ix p d + 1", "by auto"], ["proof (state)\nthis:\n  ix (child p right d) d = 2 * ix p d + 1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have lv_r_eq: \"lv ?r d = lv p d + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv (child p right d) d = lv p d + 1", "using \\<open>d < length p\\<close> and child_lv"], ["proof (prove)\nusing this:\n  d < length p\n  ?d < length ?p \\<Longrightarrow> lv (child ?p ?dir ?d) ?d = lv ?p ?d + 1\n\ngoal (1 subgoal):\n 1. lv (child p right d) d = lv p d + 1", "by auto"], ["proof (state)\nthis:\n  lv (child p right d) d = lv p d + 1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have ix_l_eq: \"ix ?l d = 2 * ix p d - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ix (child p left d) d = 2 * ix p d - 1", "using \\<open>d < length p\\<close> and child_ix"], ["proof (prove)\nusing this:\n  d < length p\n  ?d < length ?p \\<Longrightarrow>\n  ix (child ?p ?dir ?d) ?d = 2 * ix ?p ?d + Grid_Point.sgn ?dir\n\ngoal (1 subgoal):\n 1. ix (child p left d) d = 2 * ix p d - 1", "by auto"], ["proof (state)\nthis:\n  ix (child p left d) d = 2 * ix p d - 1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have lv_l_eq: \"lv ?l d = lv p d + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv (child p left d) d = lv p d + 1", "using \\<open>d < length p\\<close> and child_lv"], ["proof (prove)\nusing this:\n  d < length p\n  ?d < length ?p \\<Longrightarrow> lv (child ?p ?dir ?d) ?d = lv ?p ?d + 1\n\ngoal (1 subgoal):\n 1. lv (child p left d) d = lv p d + 1", "by auto"], ["proof (state)\nthis:\n  lv (child p left d) d = lv p d + 1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "assume \"x \\<in> grid p {d}\" and \"x \\<noteq> p\" and \"x \\<notin> grid ?r {d}\""], ["proof (state)\nthis:\n  x \\<in> grid p {d}\n  x \\<noteq> p\n  x \\<notin> grid (child p right d) {d}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "hence \"lv p d \\<le> lv x d\""], ["proof (prove)\nusing this:\n  x \\<in> grid p {d}\n  x \\<noteq> p\n  x \\<notin> grid (child p right d) {d}\n\ngoal (1 subgoal):\n 1. lv p d \\<le> lv x d", "using grid_single_level and \\<open>d < length p\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> grid p {d}\n  x \\<noteq> p\n  x \\<notin> grid (child p right d) {d}\n  \\<lbrakk>?p \\<in> grid ?b ?ds; ?d < length ?b\\<rbrakk>\n  \\<Longrightarrow> lv ?b ?d \\<le> lv ?p ?d\n  d < length p\n\ngoal (1 subgoal):\n 1. lv p d \\<le> lv x d", "by auto"], ["proof (state)\nthis:\n  lv p d \\<le> lv x d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "moreover"], ["proof (state)\nthis:\n  lv p d \\<le> lv x d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have \"lv p d \\<noteq> lv x d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv p d \\<noteq> lv x d", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lv p d \\<noteq> lv x d \\<Longrightarrow> False", "assume \"\\<not> lv p d \\<noteq> lv x d\""], ["proof (state)\nthis:\n  \\<not> lv p d \\<noteq> lv x d\n\ngoal (1 subgoal):\n 1. \\<not> lv p d \\<noteq> lv x d \\<Longrightarrow> False", "hence \"level x = level p\""], ["proof (prove)\nusing this:\n  \\<not> lv p d \\<noteq> lv x d\n\ngoal (1 subgoal):\n 1. level x = level p", "using \\<open>x \\<in> grid p {d}\\<close> and grid_level_eq[where ds=\"{d}\"]"], ["proof (prove)\nusing this:\n  \\<not> lv p d \\<noteq> lv x d\n  x \\<in> grid p {d}\n  \\<lbrakk>\\<forall>d\\<in>{d}. lv ?p d = lv ?b d;\n   ?p \\<in> grid ?b {d}\\<rbrakk>\n  \\<Longrightarrow> level ?p = level ?b\n\ngoal (1 subgoal):\n 1. level x = level p", "by auto"], ["proof (state)\nthis:\n  level x = level p\n\ngoal (1 subgoal):\n 1. \\<not> lv p d \\<noteq> lv x d \\<Longrightarrow> False", "hence \"x = p\""], ["proof (prove)\nusing this:\n  level x = level p\n\ngoal (1 subgoal):\n 1. x = p", "using grid_Start and \\<open>x \\<in> grid p {d}\\<close>"], ["proof (prove)\nusing this:\n  level x = level p\n  \\<lbrakk>?p \\<in> grid ?b ?ds; level ?p = level ?b\\<rbrakk>\n  \\<Longrightarrow> ?p = ?b\n  x \\<in> grid p {d}\n\ngoal (1 subgoal):\n 1. x = p", "by auto"], ["proof (state)\nthis:\n  x = p\n\ngoal (1 subgoal):\n 1. \\<not> lv p d \\<noteq> lv x d \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  x = p\n\ngoal (1 subgoal):\n 1. False", "using \\<open>x \\<noteq> p\\<close>"], ["proof (prove)\nusing this:\n  x = p\n  x \\<noteq> p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lv p d \\<noteq> lv x d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "ultimately"], ["proof (chain)\npicking this:\n  lv p d \\<le> lv x d\n  lv p d \\<noteq> lv x d", "have \"lv p d < lv x d\""], ["proof (prove)\nusing this:\n  lv p d \\<le> lv x d\n  lv p d \\<noteq> lv x d\n\ngoal (1 subgoal):\n 1. lv p d < lv x d", "by auto"], ["proof (state)\nthis:\n  lv p d < lv x d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "hence \"lv ?r d \\<le> lv x d\" and \"?r \\<in> grid p {d}\""], ["proof (prove)\nusing this:\n  lv p d < lv x d\n\ngoal (1 subgoal):\n 1. lv (child p right d) d \\<le> lv x d &&& child p right d \\<in> grid p {d}", "using child_lv and \\<open>d < length p\\<close>"], ["proof (prove)\nusing this:\n  lv p d < lv x d\n  ?d < length ?p \\<Longrightarrow> lv (child ?p ?dir ?d) ?d = lv ?p ?d + 1\n  d < length p\n\ngoal (1 subgoal):\n 1. lv (child p right d) d \\<le> lv x d &&& child p right d \\<in> grid p {d}", "by auto"], ["proof (state)\nthis:\n  lv (child p right d) d \\<le> lv x d\n  child p right d \\<in> grid p {d}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "with \\<open>d < length p\\<close> and \\<open>x \\<in> grid p {d}\\<close>"], ["proof (chain)\npicking this:\n  d < length p\n  x \\<in> grid p {d}\n  lv (child p right d) d \\<le> lv x d\n  child p right d \\<in> grid p {d}", "have r_range: \"\\<not> ?nr_r ?r \\<and> \\<not> ?nr_l ?r \\<Longrightarrow> x \\<in> grid ?r {d}\""], ["proof (prove)\nusing this:\n  d < length p\n  x \\<in> grid p {d}\n  lv (child p right d) d \\<le> lv x d\n  child p right d \\<in> grid p {d}\n\ngoal (1 subgoal):\n 1. \\<not> (ix (child p right d) d + 1) *\n           2 ^ (lv x d - lv (child p right d) d)\n           < ix x d \\<and>\n    \\<not> ix x d\n           < (ix (child p right d) d - 1) *\n             2 ^ (lv x d - lv (child p right d) d) \\<Longrightarrow>\n    x \\<in> grid (child p right d) {d}", "using grid_part[where p=\"?r\" and p'=x and b=p and d=d]"], ["proof (prove)\nusing this:\n  d < length p\n  x \\<in> grid p {d}\n  lv (child p right d) d \\<le> lv x d\n  child p right d \\<in> grid p {d}\n  \\<lbrakk>d < length p; child p right d \\<in> grid p {d};\n   x \\<in> grid p {d}; lv (child p right d) d \\<le> lv x d;\n   ix x d\n   \\<le> (ix (child p right d) d + 1) *\n         2 ^ (lv x d - lv (child p right d) d);\n   (ix (child p right d) d - 1) * 2 ^ (lv x d - lv (child p right d) d)\n   \\<le> ix x d\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (child p right d) {d}\n\ngoal (1 subgoal):\n 1. \\<not> (ix (child p right d) d + 1) *\n           2 ^ (lv x d - lv (child p right d) d)\n           < ix x d \\<and>\n    \\<not> ix x d\n           < (ix (child p right d) d - 1) *\n             2 ^ (lv x d - lv (child p right d) d) \\<Longrightarrow>\n    x \\<in> grid (child p right d) {d}", "by auto"], ["proof (state)\nthis:\n  \\<not> (ix (child p right d) d + 1) *\n         2 ^ (lv x d - lv (child p right d) d)\n         < ix x d \\<and>\n  \\<not> ix x d\n         < (ix (child p right d) d - 1) *\n           2 ^ (lv x d - lv (child p right d) d) \\<Longrightarrow>\n  x \\<in> grid (child p right d) {d}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have \"x \\<notin> grid ?r {d} \\<Longrightarrow> ?nr_l ?r \\<or> ?nr_r ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> grid (child p right d) {d} \\<Longrightarrow>\n    ix x d\n    < (ix (child p right d) d - 1) *\n      2 ^ (lv x d - lv (child p right d) d) \\<or>\n    (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)\n    < ix x d", "by (rule ccontr, auto simp add: r_range)"], ["proof (state)\nthis:\n  x \\<notin> grid (child p right d) {d} \\<Longrightarrow>\n  ix x d\n  < (ix (child p right d) d - 1) *\n    2 ^ (lv x d - lv (child p right d) d) \\<or>\n  (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)\n  < ix x d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "hence \"?nr_l ?r \\<or> ?nr_r ?r\""], ["proof (prove)\nusing this:\n  x \\<notin> grid (child p right d) {d} \\<Longrightarrow>\n  ix x d\n  < (ix (child p right d) d - 1) *\n    2 ^ (lv x d - lv (child p right d) d) \\<or>\n  (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)\n  < ix x d\n\ngoal (1 subgoal):\n 1. ix x d\n    < (ix (child p right d) d - 1) *\n      2 ^ (lv x d - lv (child p right d) d) \\<or>\n    (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)\n    < ix x d", "using \\<open>x \\<notin> grid ?r {d}\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> grid (child p right d) {d} \\<Longrightarrow>\n  ix x d\n  < (ix (child p right d) d - 1) *\n    2 ^ (lv x d - lv (child p right d) d) \\<or>\n  (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)\n  < ix x d\n  x \\<notin> grid (child p right d) {d}\n\ngoal (1 subgoal):\n 1. ix x d\n    < (ix (child p right d) d - 1) *\n      2 ^ (lv x d - lv (child p right d) d) \\<or>\n    (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)\n    < ix x d", "by auto"], ["proof (state)\nthis:\n  ix x d\n  < (ix (child p right d) d - 1) *\n    2 ^ (lv x d - lv (child p right d) d) \\<or>\n  (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)\n  < ix x d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have gt0: \"lv x d - lv p d > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lv x d - lv p d", "using \\<open>lv p d < lv x d\\<close>"], ["proof (prove)\nusing this:\n  lv p d < lv x d\n\ngoal (1 subgoal):\n 1. 0 < lv x d - lv p d", "by auto"], ["proof (state)\nthis:\n  0 < lv x d - lv p d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have ix_shift: \"ix ?r d = ix ?l d + 2\" and lv_lr: \"lv ?r d = lv ?l d\" and right1: \"!! x :: int. x + 2 - 1 = x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ix (child p right d) d = ix (child p left d) d + 2 &&&\n    lv (child p right d) d = lv (child p left d) d &&&\n    (\\<And>x. x + 2 - 1 = x + 1)", "using \\<open>d < length p\\<close> and child_ix and child_lv"], ["proof (prove)\nusing this:\n  d < length p\n  ?d < length ?p \\<Longrightarrow>\n  ix (child ?p ?dir ?d) ?d = 2 * ix ?p ?d + Grid_Point.sgn ?dir\n  ?d < length ?p \\<Longrightarrow> lv (child ?p ?dir ?d) ?d = lv ?p ?d + 1\n\ngoal (1 subgoal):\n 1. ix (child p right d) d = ix (child p left d) d + 2 &&&\n    lv (child p right d) d = lv (child p left d) d &&&\n    (\\<And>x. x + 2 - 1 = x + 1)", "by auto"], ["proof (state)\nthis:\n  ix (child p right d) d = ix (child p left d) d + 2\n  lv (child p right d) d = lv (child p left d) d\n  ?x + 2 - 1 = ?x + 1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have \"lv x d - lv p d = Suc (lv x d - (lv p d + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv x d - lv p d = Suc (lv x d - (lv p d + 1))", "using gt0"], ["proof (prove)\nusing this:\n  0 < lv x d - lv p d\n\ngoal (1 subgoal):\n 1. lv x d - lv p d = Suc (lv x d - (lv p d + 1))", "by auto"], ["proof (state)\nthis:\n  lv x d - lv p d = Suc (lv x d - (lv p d + 1))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "hence lv_shift: \"!! y :: int. y * 2 ^ (lv x d - lv p d) = y * 2 * 2 ^ (lv x d - (lv p d + 1))\""], ["proof (prove)\nusing this:\n  lv x d - lv p d = Suc (lv x d - (lv p d + 1))\n\ngoal (1 subgoal):\n 1. \\<And>y. y * 2 ^ (lv x d - lv p d) = y * 2 * 2 ^ (lv x d - (lv p d + 1))", "by auto"], ["proof (state)\nthis:\n  ?y * 2 ^ (lv x d - lv p d) = ?y * 2 * 2 ^ (lv x d - (lv p d + 1))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have \"ix x d < (ix p d + 1) * 2 ^ (lv x d - lv p d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ix x d < (ix p d + 1) * 2 ^ (lv x d - lv p d)", "using \\<open>x \\<in> grid p {d}\\<close> grid_estimate and \\<open>d < length p\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> grid p {d}\n  \\<lbrakk>?d < length ?b; ?p \\<in> grid ?b ?ds\\<rbrakk>\n  \\<Longrightarrow> ix ?p ?d\n                    < (ix ?b ?d + 1) * 2 ^ (lv ?p ?d - lv ?b ?d) \\<and>\n                    (ix ?b ?d - 1) * 2 ^ (lv ?p ?d - lv ?b ?d) < ix ?p ?d\n  d < length p\n\ngoal (1 subgoal):\n 1. ix x d < (ix p d + 1) * 2 ^ (lv x d - lv p d)", "by auto"], ["proof (state)\nthis:\n  ix x d < (ix p d + 1) * 2 ^ (lv x d - lv p d)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "also"], ["proof (state)\nthis:\n  ix x d < (ix p d + 1) * 2 ^ (lv x d - lv p d)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have \"\\<dots> = (ix ?r d + 1) * 2 ^ (lv x d - lv ?r d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix p d + 1) * 2 ^ (lv x d - lv p d) =\n    (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)", "using \\<open>lv p d < lv x d\\<close> and ix_r_eq and lv_r_eq lv_shift[where y=\"ix p d + 1\"]"], ["proof (prove)\nusing this:\n  lv p d < lv x d\n  ix (child p right d) d = 2 * ix p d + 1\n  lv (child p right d) d = lv p d + 1\n  (ix p d + 1) * 2 ^ (lv x d - lv p d) =\n  (ix p d + 1) * 2 * 2 ^ (lv x d - (lv p d + 1))\n\ngoal (1 subgoal):\n 1. (ix p d + 1) * 2 ^ (lv x d - lv p d) =\n    (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)", "by auto"], ["proof (state)\nthis:\n  (ix p d + 1) * 2 ^ (lv x d - lv p d) =\n  (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "finally"], ["proof (chain)\npicking this:\n  ix x d\n  < (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)", "have \"?nr_l ?r\""], ["proof (prove)\nusing this:\n  ix x d\n  < (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)\n\ngoal (1 subgoal):\n 1. ix x d\n    < (ix (child p right d) d - 1) * 2 ^ (lv x d - lv (child p right d) d)", "using \\<open>?nr_l ?r \\<or> ?nr_r ?r\\<close>"], ["proof (prove)\nusing this:\n  ix x d\n  < (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)\n  ix x d\n  < (ix (child p right d) d - 1) *\n    2 ^ (lv x d - lv (child p right d) d) \\<or>\n  (ix (child p right d) d + 1) * 2 ^ (lv x d - lv (child p right d) d)\n  < ix x d\n\ngoal (1 subgoal):\n 1. ix x d\n    < (ix (child p right d) d - 1) * 2 ^ (lv x d - lv (child p right d) d)", "by auto"], ["proof (state)\nthis:\n  ix x d\n  < (ix (child p right d) d - 1) * 2 ^ (lv x d - lv (child p right d) d)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "hence r_bound: \"(ix ?l d + 1) * 2 ^ (lv x d - lv ?l d) > ix x d\""], ["proof (prove)\nusing this:\n  ix x d\n  < (ix (child p right d) d - 1) * 2 ^ (lv x d - lv (child p right d) d)\n\ngoal (1 subgoal):\n 1. ix x d\n    < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d)", "unfolding ix_shift lv_lr"], ["proof (prove)\nusing this:\n  ix x d\n  < (ix (child p left d) d + 2 - 1) * 2 ^ (lv x d - lv (child p left d) d)\n\ngoal (1 subgoal):\n 1. ix x d\n    < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d)", "using right1"], ["proof (prove)\nusing this:\n  ix x d\n  < (ix (child p left d) d + 2 - 1) * 2 ^ (lv x d - lv (child p left d) d)\n  ?x + 2 - 1 = ?x + 1\n\ngoal (1 subgoal):\n 1. ix x d\n    < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d)", "by auto"], ["proof (state)\nthis:\n  ix x d\n  < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have \"(ix ?l d - 1) * 2 ^ (lv x d - lv ?l d) = (ix p d - 1) * 2 * 2 ^ (lv x d - (lv p d + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix (child p left d) d - 1) * 2 ^ (lv x d - lv (child p left d) d) =\n    (ix p d - 1) * 2 * 2 ^ (lv x d - (lv p d + 1))", "unfolding ix_l_eq lv_l_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * ix p d - 1 - 1) * 2 ^ (lv x d - (lv p d + 1)) =\n    (ix p d - 1) * 2 * 2 ^ (lv x d - (lv p d + 1))", "by auto"], ["proof (state)\nthis:\n  (ix (child p left d) d - 1) * 2 ^ (lv x d - lv (child p left d) d) =\n  (ix p d - 1) * 2 * 2 ^ (lv x d - (lv p d + 1))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "also"], ["proof (state)\nthis:\n  (ix (child p left d) d - 1) * 2 ^ (lv x d - lv (child p left d) d) =\n  (ix p d - 1) * 2 * 2 ^ (lv x d - (lv p d + 1))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have \"\\<dots> = (ix p d - 1) * 2 ^ (lv x d - lv p d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 * 2 ^ (lv x d - (lv p d + 1)) =\n    (ix p d - 1) * 2 ^ (lv x d - lv p d)", "using lv_shift[where y=\"ix p d - 1\"]"], ["proof (prove)\nusing this:\n  (ix p d - 1) * 2 ^ (lv x d - lv p d) =\n  (ix p d - 1) * 2 * 2 ^ (lv x d - (lv p d + 1))\n\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 * 2 ^ (lv x d - (lv p d + 1)) =\n    (ix p d - 1) * 2 ^ (lv x d - lv p d)", "by auto"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 * 2 ^ (lv x d - (lv p d + 1)) =\n  (ix p d - 1) * 2 ^ (lv x d - lv p d)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "also"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 * 2 ^ (lv x d - (lv p d + 1)) =\n  (ix p d - 1) * 2 ^ (lv x d - lv p d)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "have \" \\<dots> < ix x d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (lv x d - lv p d) < ix x d", "using \\<open>x \\<in> grid p {d}\\<close> grid_estimate and \\<open>d < length p\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> grid p {d}\n  \\<lbrakk>?d < length ?b; ?p \\<in> grid ?b ?ds\\<rbrakk>\n  \\<Longrightarrow> ix ?p ?d\n                    < (ix ?b ?d + 1) * 2 ^ (lv ?p ?d - lv ?b ?d) \\<and>\n                    (ix ?b ?d - 1) * 2 ^ (lv ?p ?d - lv ?b ?d) < ix ?p ?d\n  d < length p\n\ngoal (1 subgoal):\n 1. (ix p d - 1) * 2 ^ (lv x d - lv p d) < ix x d", "by auto"], ["proof (state)\nthis:\n  (ix p d - 1) * 2 ^ (lv x d - lv p d) < ix x d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "finally"], ["proof (chain)\npicking this:\n  (ix (child p left d) d - 1) * 2 ^ (lv x d - lv (child p left d) d)\n  < ix x d", "have l_bound: \"(ix ?l d - 1) * 2 ^ (lv x d - lv ?l d) < ix x d\""], ["proof (prove)\nusing this:\n  (ix (child p left d) d - 1) * 2 ^ (lv x d - lv (child p left d) d)\n  < ix x d\n\ngoal (1 subgoal):\n 1. (ix (child p left d) d - 1) * 2 ^ (lv x d - lv (child p left d) d)\n    < ix x d", "."], ["proof (state)\nthis:\n  (ix (child p left d) d - 1) * 2 ^ (lv x d - lv (child p left d) d)\n  < ix x d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "from l_bound r_bound \\<open>d < length p\\<close> and \\<open>x \\<in> grid p {d}\\<close> \\<open>lv ?r d \\<le> lv x d\\<close> and lv_lr"], ["proof (chain)\npicking this:\n  (ix (child p left d) d - 1) * 2 ^ (lv x d - lv (child p left d) d)\n  < ix x d\n  ix x d\n  < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d)\n  d < length p\n  x \\<in> grid p {d}\n  lv (child p right d) d \\<le> lv x d\n  lv (child p right d) d = lv (child p left d) d", "show \"x \\<in> grid ?l {d}\""], ["proof (prove)\nusing this:\n  (ix (child p left d) d - 1) * 2 ^ (lv x d - lv (child p left d) d)\n  < ix x d\n  ix x d\n  < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d)\n  d < length p\n  x \\<in> grid p {d}\n  lv (child p right d) d \\<le> lv x d\n  lv (child p right d) d = lv (child p left d) d\n\ngoal (1 subgoal):\n 1. x \\<in> grid (child p left d) {d}", "using grid_part[where p=\"?l\" and p'=x and d=d]"], ["proof (prove)\nusing this:\n  (ix (child p left d) d - 1) * 2 ^ (lv x d - lv (child p left d) d)\n  < ix x d\n  ix x d\n  < (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d)\n  d < length p\n  x \\<in> grid p {d}\n  lv (child p right d) d \\<le> lv x d\n  lv (child p right d) d = lv (child p left d) d\n  \\<lbrakk>d < length ?b; child p left d \\<in> grid ?b {d};\n   x \\<in> grid ?b {d}; lv (child p left d) d \\<le> lv x d;\n   ix x d\n   \\<le> (ix (child p left d) d + 1) * 2 ^ (lv x d - lv (child p left d) d);\n   (ix (child p left d) d - 1) * 2 ^ (lv x d - lv (child p left d) d)\n   \\<le> ix x d\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (child p left d) {d}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (child p left d) {d}", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (child p left d) {d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid p {d}; x \\<noteq> p;\n        x \\<notin> grid (child p right d) {d}; \\<not> d < length p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (child p left d) {d}", "qed (auto simp add: child_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> grid p {d}; ?x \\<noteq> p;\n   ?x \\<notin> grid (child p right d) {d}\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> grid (child p left d) {d}\n\ngoal (1 subgoal):\n 1. grid p {d} =\n    {p} \\<union> grid (child p left d) {d} \\<union>\n    grid (child p right d) {d}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> grid p {d}; ?x \\<noteq> p;\n   ?x \\<notin> grid (child p right d) {d}\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> grid (child p left d) {d}\n\ngoal (1 subgoal):\n 1. grid p {d} =\n    {p} \\<union> grid (child p left d) {d} \\<union>\n    grid (child p right d) {d}", "by (auto intro: grid_child)"], ["proof (state)\nthis:\n  grid p {d} =\n  {p} \\<union> grid (child p left d) {d} \\<union> grid (child p right d) {d}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_change_dim: assumes grid: \"p \\<in> grid b ds\"\n  shows \"p[d := X] \\<in> grid (b[d := X]) ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p[d := X] \\<in> grid (b[d := X]) ds", "using grid"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. p[d := X] \\<in> grid (b[d := X]) ds", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. b[d := X] \\<in> grid (b[d := X]) ds\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ds; p[d := X] \\<in> grid (b[d := X]) ds;\n        da \\<in> ds\\<rbrakk>\n       \\<Longrightarrow> (child p dir da)[d := X] \\<in> grid (b[d := X]) ds", "case (Child p d' dir)"], ["proof (state)\nthis:\n  p \\<in> grid b ds\n  p[d := X] \\<in> grid (b[d := X]) ds\n  d' \\<in> ds\n\ngoal (2 subgoals):\n 1. b[d := X] \\<in> grid (b[d := X]) ds\n 2. \\<And>p da dir.\n       \\<lbrakk>p \\<in> grid b ds; p[d := X] \\<in> grid (b[d := X]) ds;\n        da \\<in> ds\\<rbrakk>\n       \\<Longrightarrow> (child p dir da)[d := X] \\<in> grid (b[d := X]) ds", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (child p dir d')[d := X] \\<in> grid (b[d := X]) ds", "proof (cases \"d \\<noteq> d'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<noteq> d' \\<Longrightarrow>\n    (child p dir d')[d := X] \\<in> grid (b[d := X]) ds\n 2. \\<not> d \\<noteq> d' \\<Longrightarrow>\n    (child p dir d')[d := X] \\<in> grid (b[d := X]) ds", "case True"], ["proof (state)\nthis:\n  d \\<noteq> d'\n\ngoal (2 subgoals):\n 1. d \\<noteq> d' \\<Longrightarrow>\n    (child p dir d')[d := X] \\<in> grid (b[d := X]) ds\n 2. \\<not> d \\<noteq> d' \\<Longrightarrow>\n    (child p dir d')[d := X] \\<in> grid (b[d := X]) ds", "have \"(child p dir d')[d := X] = child (p[d := X]) dir d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (child p dir d')[d := X] = child (p[d := X]) dir d'", "unfolding child_def and ix_def and lv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p[d' := (fst (p ! d') + 1, 2 * snd (p ! d') + Grid_Point.sgn dir),\n      d := X] =\n    p[d := X,\n      d' :=\n        (fst (p[d := X] ! d') + 1,\n         2 * snd (p[d := X] ! d') + Grid_Point.sgn dir)]", "unfolding list_update_swap[OF \\<open>d \\<noteq> d'\\<close>] and nth_list_update_neq[OF \\<open>d \\<noteq> d'\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. p[d' := (fst (p ! d') + 1, 2 * snd (p ! d') + Grid_Point.sgn dir),\n      d := X] =\n    p[d' := (fst (p ! d') + 1, 2 * snd (p ! d') + Grid_Point.sgn dir),\n      d := X]", ".."], ["proof (state)\nthis:\n  (child p dir d')[d := X] = child (p[d := X]) dir d'\n\ngoal (2 subgoals):\n 1. d \\<noteq> d' \\<Longrightarrow>\n    (child p dir d')[d := X] \\<in> grid (b[d := X]) ds\n 2. \\<not> d \\<noteq> d' \\<Longrightarrow>\n    (child p dir d')[d := X] \\<in> grid (b[d := X]) ds", "thus ?thesis"], ["proof (prove)\nusing this:\n  (child p dir d')[d := X] = child (p[d := X]) dir d'\n\ngoal (1 subgoal):\n 1. (child p dir d')[d := X] \\<in> grid (b[d := X]) ds", "using Child"], ["proof (prove)\nusing this:\n  (child p dir d')[d := X] = child (p[d := X]) dir d'\n  p \\<in> grid b ds\n  p[d := X] \\<in> grid (b[d := X]) ds\n  d' \\<in> ds\n\ngoal (1 subgoal):\n 1. (child p dir d')[d := X] \\<in> grid (b[d := X]) ds", "by auto"], ["proof (state)\nthis:\n  (child p dir d')[d := X] \\<in> grid (b[d := X]) ds\n\ngoal (1 subgoal):\n 1. \\<not> d \\<noteq> d' \\<Longrightarrow>\n    (child p dir d')[d := X] \\<in> grid (b[d := X]) ds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d \\<noteq> d' \\<Longrightarrow>\n    (child p dir d')[d := X] \\<in> grid (b[d := X]) ds", "case False"], ["proof (state)\nthis:\n  \\<not> d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. \\<not> d \\<noteq> d' \\<Longrightarrow>\n    (child p dir d')[d := X] \\<in> grid (b[d := X]) ds", "hence \"d = d'\""], ["proof (prove)\nusing this:\n  \\<not> d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. d = d'", "by auto"], ["proof (state)\nthis:\n  d = d'\n\ngoal (1 subgoal):\n 1. \\<not> d \\<noteq> d' \\<Longrightarrow>\n    (child p dir d')[d := X] \\<in> grid (b[d := X]) ds", "with Child"], ["proof (chain)\npicking this:\n  p \\<in> grid b ds\n  p[d := X] \\<in> grid (b[d := X]) ds\n  d' \\<in> ds\n  d = d'", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  p[d := X] \\<in> grid (b[d := X]) ds\n  d' \\<in> ds\n  d = d'\n\ngoal (1 subgoal):\n 1. (child p dir d')[d := X] \\<in> grid (b[d := X]) ds", "unfolding child_def \\<open>d = d'\\<close> list_update_overwrite"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  p[d' := X] \\<in> grid (b[d' := X]) ds\n  d' \\<in> ds\n  d' = d'\n\ngoal (1 subgoal):\n 1. p[d' := X] \\<in> grid (b[d' := X]) ds", "by auto"], ["proof (state)\nthis:\n  (child p dir d')[d := X] \\<in> grid (b[d := X]) ds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (child p dir d')[d := X] \\<in> grid (b[d := X]) ds\n\ngoal (1 subgoal):\n 1. b[d := X] \\<in> grid (b[d := X]) ds", "qed auto"], ["", "lemma grid_change_dim_child: assumes grid: \"p \\<in> grid b ds\" and \"d \\<notin> ds\"\n  shows \"child p dir d \\<in> grid (child b dir d) ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. child p dir d \\<in> grid (child b dir d) ds", "proof (cases \"d < length b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow>\n    child p dir d \\<in> grid (child b dir d) ds\n 2. \\<not> d < length b \\<Longrightarrow>\n    child p dir d \\<in> grid (child b dir d) ds", "case True"], ["proof (state)\nthis:\n  d < length b\n\ngoal (2 subgoals):\n 1. d < length b \\<Longrightarrow>\n    child p dir d \\<in> grid (child b dir d) ds\n 2. \\<not> d < length b \\<Longrightarrow>\n    child p dir d \\<in> grid (child b dir d) ds", "thus ?thesis"], ["proof (prove)\nusing this:\n  d < length b\n\ngoal (1 subgoal):\n 1. child p dir d \\<in> grid (child b dir d) ds", "using grid_change_dim[OF grid]"], ["proof (prove)\nusing this:\n  d < length b\n  p[?d := ?X] \\<in> grid (b[?d := ?X]) ds\n\ngoal (1 subgoal):\n 1. child p dir d \\<in> grid (child b dir d) ds", "unfolding child_def lv_def ix_def grid_invariant[OF True \\<open>d \\<notin> ds\\<close> grid]"], ["proof (prove)\nusing this:\n  d < length b\n  p[?d := ?X] \\<in> grid (b[?d := ?X]) ds\n\ngoal (1 subgoal):\n 1. p[d := (fst (b ! d) + 1, 2 * snd (b ! d) + Grid_Point.sgn dir)]\n    \\<in> grid\n           (b[d := (fst (b ! d) + 1, 2 * snd (b ! d) + Grid_Point.sgn dir)])\n           ds", "by auto"], ["proof (state)\nthis:\n  child p dir d \\<in> grid (child b dir d) ds\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow>\n    child p dir d \\<in> grid (child b dir d) ds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow>\n    child p dir d \\<in> grid (child b dir d) ds", "case False"], ["proof (state)\nthis:\n  \\<not> d < length b\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow>\n    child p dir d \\<in> grid (child b dir d) ds", "hence \"length b \\<le> d\" and \"length p \\<le> d\""], ["proof (prove)\nusing this:\n  \\<not> d < length b\n\ngoal (1 subgoal):\n 1. length b \\<le> d &&& length p \\<le> d", "using grid"], ["proof (prove)\nusing this:\n  \\<not> d < length b\n  p \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. length b \\<le> d &&& length p \\<le> d", "by auto"], ["proof (state)\nthis:\n  length b \\<le> d\n  length p \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow>\n    child p dir d \\<in> grid (child b dir d) ds", "thus ?thesis"], ["proof (prove)\nusing this:\n  length b \\<le> d\n  length p \\<le> d\n\ngoal (1 subgoal):\n 1. child p dir d \\<in> grid (child b dir d) ds", "unfolding child_def"], ["proof (prove)\nusing this:\n  length b \\<le> d\n  length p \\<le> d\n\ngoal (1 subgoal):\n 1. p[d := (lv p d + 1, 2 * ix p d + Grid_Point.sgn dir)]\n    \\<in> grid (b[d := (lv b d + 1, 2 * ix b d + Grid_Point.sgn dir)]) ds", "using list_update_beyond assms"], ["proof (prove)\nusing this:\n  length b \\<le> d\n  length p \\<le> d\n  length ?xs \\<le> ?i \\<Longrightarrow> ?xs[?i := ?x] = ?xs\n  p \\<in> grid b ds\n  d \\<notin> ds\n\ngoal (1 subgoal):\n 1. p[d := (lv p d + 1, 2 * ix p d + Grid_Point.sgn dir)]\n    \\<in> grid (b[d := (lv b d + 1, 2 * ix b d + Grid_Point.sgn dir)]) ds", "by auto"], ["proof (state)\nthis:\n  child p dir d \\<in> grid (child b dir d) ds\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_split: assumes grid: \"p \\<in> grid b (ds' \\<union> ds)\" shows \"\\<exists> x \\<in> grid b ds. p \\<in> grid x ds'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>grid b ds. p \\<in> grid x ds'", "using grid"], ["proof (prove)\nusing this:\n  p \\<in> grid b (ds' \\<union> ds)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>grid b ds. p \\<in> grid x ds'", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>grid b ds. b \\<in> grid x ds'\n 2. \\<And>p d dir.\n       \\<lbrakk>p \\<in> grid b (ds' \\<union> ds);\n        \\<exists>x\\<in>grid b ds. p \\<in> grid x ds';\n        d \\<in> ds' \\<union> ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>grid b ds.\n                            child p dir d \\<in> grid x ds'", "case (Child p d dir)"], ["proof (state)\nthis:\n  p \\<in> grid b (ds' \\<union> ds)\n  \\<exists>x\\<in>grid b ds. p \\<in> grid x ds'\n  d \\<in> ds' \\<union> ds\n\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>grid b ds. b \\<in> grid x ds'\n 2. \\<And>p d dir.\n       \\<lbrakk>p \\<in> grid b (ds' \\<union> ds);\n        \\<exists>x\\<in>grid b ds. p \\<in> grid x ds';\n        d \\<in> ds' \\<union> ds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>grid b ds.\n                            child p dir d \\<in> grid x ds'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "proof (cases \"d \\<in> ds'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<in> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'\n 2. d \\<notin> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "case True"], ["proof (state)\nthis:\n  d \\<in> ds'\n\ngoal (2 subgoals):\n 1. d \\<in> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'\n 2. d \\<notin> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "with Child"], ["proof (chain)\npicking this:\n  p \\<in> grid b (ds' \\<union> ds)\n  \\<exists>x\\<in>grid b ds. p \\<in> grid x ds'\n  d \\<in> ds' \\<union> ds\n  d \\<in> ds'", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> grid b (ds' \\<union> ds)\n  \\<exists>x\\<in>grid b ds. p \\<in> grid x ds'\n  d \\<in> ds' \\<union> ds\n  d \\<in> ds'\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'\n\ngoal (1 subgoal):\n 1. d \\<notin> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<notin> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "case False"], ["proof (state)\nthis:\n  d \\<notin> ds'\n\ngoal (1 subgoal):\n 1. d \\<notin> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "hence \"d \\<in> ds\""], ["proof (prove)\nusing this:\n  d \\<notin> ds'\n\ngoal (1 subgoal):\n 1. d \\<in> ds", "using Child"], ["proof (prove)\nusing this:\n  d \\<notin> ds'\n  p \\<in> grid b (ds' \\<union> ds)\n  \\<exists>x\\<in>grid b ds. p \\<in> grid x ds'\n  d \\<in> ds' \\<union> ds\n\ngoal (1 subgoal):\n 1. d \\<in> ds", "by auto"], ["proof (state)\nthis:\n  d \\<in> ds\n\ngoal (1 subgoal):\n 1. d \\<notin> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "obtain x where \"x \\<in> grid b ds\" and \"p \\<in> grid x ds'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> grid b ds; p \\<in> grid x ds'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Child"], ["proof (prove)\nusing this:\n  p \\<in> grid b (ds' \\<union> ds)\n  \\<exists>x\\<in>grid b ds. p \\<in> grid x ds'\n  d \\<in> ds' \\<union> ds\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> grid b ds; p \\<in> grid x ds'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid b ds\n  p \\<in> grid x ds'\n\ngoal (1 subgoal):\n 1. d \\<notin> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "hence \"child x dir d \\<in> grid b ds\""], ["proof (prove)\nusing this:\n  x \\<in> grid b ds\n  p \\<in> grid x ds'\n\ngoal (1 subgoal):\n 1. child x dir d \\<in> grid b ds", "using \\<open>d \\<in> ds\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> grid b ds\n  p \\<in> grid x ds'\n  d \\<in> ds\n\ngoal (1 subgoal):\n 1. child x dir d \\<in> grid b ds", "by auto"], ["proof (state)\nthis:\n  child x dir d \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. d \\<notin> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "moreover"], ["proof (state)\nthis:\n  child x dir d \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. d \\<notin> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "have \"child p dir d \\<in> grid (child x dir d) ds'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. child p dir d \\<in> grid (child x dir d) ds'", "using \\<open>p \\<in> grid x ds'\\<close> False and grid_change_dim_child"], ["proof (prove)\nusing this:\n  p \\<in> grid x ds'\n  d \\<notin> ds'\n  \\<lbrakk>?p \\<in> grid ?b ?ds; ?d \\<notin> ?ds\\<rbrakk>\n  \\<Longrightarrow> child ?p ?dir ?d \\<in> grid (child ?b ?dir ?d) ?ds\n\ngoal (1 subgoal):\n 1. child p dir d \\<in> grid (child x dir d) ds'", "by auto"], ["proof (state)\nthis:\n  child p dir d \\<in> grid (child x dir d) ds'\n\ngoal (1 subgoal):\n 1. d \\<notin> ds' \\<Longrightarrow>\n    \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "ultimately"], ["proof (chain)\npicking this:\n  child x dir d \\<in> grid b ds\n  child p dir d \\<in> grid (child x dir d) ds'", "show ?thesis"], ["proof (prove)\nusing this:\n  child x dir d \\<in> grid b ds\n  child p dir d \\<in> grid (child x dir d) ds'\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x\\<in>grid b ds. child p dir d \\<in> grid x ds'\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>grid b ds. b \\<in> grid x ds'", "qed auto"], ["", "lemma grid_union_eq: \"(\\<Union> p \\<in> grid b ds. grid p ds') = grid b (ds' \\<union> ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>grid b ds. grid p ds') = grid b (ds' \\<union> ds)", "using grid_split and grid_transitive[where ds''=\"ds' \\<union> ds\" and ds=ds' and ds'=ds, OF _ _ Un_upper2 Un_upper1]"], ["proof (prove)\nusing this:\n  ?p \\<in> grid ?b (?ds' \\<union> ?ds) \\<Longrightarrow>\n  \\<exists>x\\<in>grid ?b ?ds. ?p \\<in> grid x ?ds'\n  \\<lbrakk>?a \\<in> grid ?b ds'; ?b \\<in> grid ?c ds\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> grid ?c (ds' \\<union> ds)\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>grid b ds. grid p ds') = grid b (ds' \\<union> ds)", "by auto"], ["", "lemma grid_onedim_split:\n  \"grid b (ds \\<union> {d}) = grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union> grid (child b right d) (ds \\<union> {d})\"\n  (is \"_ = ?g \\<union> ?l (ds \\<union> {d}) \\<union> ?r (ds \\<union> {d})\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. grid b (ds \\<union> {d}) =\n    grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. grid b (ds \\<union> {d}) =\n    grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d})", "have \"?g \\<union> ?l (ds \\<union> {d}) \\<union> ?r (ds \\<union> {d}) = ?g \\<union> (\\<Union> p \\<in> ?l {d}. grid p ds) \\<union> (\\<Union> p \\<in> ?r {d}. grid p ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d}) =\n    grid b ds \\<union>\n    (\\<Union>p\\<in>grid (child b left d) {d}. grid p ds) \\<union>\n    (\\<Union>p\\<in>grid (child b right d) {d}. grid p ds)", "unfolding grid_union_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d}) =\n    grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d})", ".."], ["proof (state)\nthis:\n  grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n  grid (child b right d) (ds \\<union> {d}) =\n  grid b ds \\<union>\n  (\\<Union>p\\<in>grid (child b left d) {d}. grid p ds) \\<union>\n  (\\<Union>p\\<in>grid (child b right d) {d}. grid p ds)\n\ngoal (1 subgoal):\n 1. grid b (ds \\<union> {d}) =\n    grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d})", "also"], ["proof (state)\nthis:\n  grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n  grid (child b right d) (ds \\<union> {d}) =\n  grid b ds \\<union>\n  (\\<Union>p\\<in>grid (child b left d) {d}. grid p ds) \\<union>\n  (\\<Union>p\\<in>grid (child b right d) {d}. grid p ds)\n\ngoal (1 subgoal):\n 1. grid b (ds \\<union> {d}) =\n    grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d})", "have \"\\<dots> = (\\<Union> p \\<in> ({b} \\<union> ?l {d} \\<union> ?r {d}). grid p ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grid b ds \\<union>\n    (\\<Union>p\\<in>grid (child b left d) {d}. grid p ds) \\<union>\n    (\\<Union>p\\<in>grid (child b right d) {d}. grid p ds) =\n    (\\<Union>p\\<in>{b} \\<union> grid (child b left d) {d} \\<union>\n                   grid (child b right d) {d}.\n        grid p ds)", "by auto"], ["proof (state)\nthis:\n  grid b ds \\<union>\n  (\\<Union>p\\<in>grid (child b left d) {d}. grid p ds) \\<union>\n  (\\<Union>p\\<in>grid (child b right d) {d}. grid p ds) =\n  (\\<Union>p\\<in>{b} \\<union> grid (child b left d) {d} \\<union>\n                 grid (child b right d) {d}.\n      grid p ds)\n\ngoal (1 subgoal):\n 1. grid b (ds \\<union> {d}) =\n    grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d})", "also"], ["proof (state)\nthis:\n  grid b ds \\<union>\n  (\\<Union>p\\<in>grid (child b left d) {d}. grid p ds) \\<union>\n  (\\<Union>p\\<in>grid (child b right d) {d}. grid p ds) =\n  (\\<Union>p\\<in>{b} \\<union> grid (child b left d) {d} \\<union>\n                 grid (child b right d) {d}.\n      grid p ds)\n\ngoal (1 subgoal):\n 1. grid b (ds \\<union> {d}) =\n    grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d})", "have \"\\<dots> = (\\<Union> p \\<in> grid b {d}. grid p ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>{b} \\<union> grid (child b left d) {d} \\<union>\n                   grid (child b right d) {d}.\n        grid p ds) =\n    (\\<Union>p\\<in>grid b {d}. grid p ds)", "unfolding grid_partition[where p=b]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>{b} \\<union> grid (child b left d) {d} \\<union>\n                   grid (child b right d) {d}.\n        grid p ds) =\n    (\\<Union>p\\<in>{b} \\<union> grid (child b left d) {d} \\<union>\n                   grid (child b right d) {d}.\n        grid p ds)", ".."], ["proof (state)\nthis:\n  (\\<Union>p\\<in>{b} \\<union> grid (child b left d) {d} \\<union>\n                 grid (child b right d) {d}.\n      grid p ds) =\n  (\\<Union>p\\<in>grid b {d}. grid p ds)\n\ngoal (1 subgoal):\n 1. grid b (ds \\<union> {d}) =\n    grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d})", "finally"], ["proof (chain)\npicking this:\n  grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n  grid (child b right d) (ds \\<union> {d}) =\n  (\\<Union>p\\<in>grid b {d}. grid p ds)", "show ?thesis"], ["proof (prove)\nusing this:\n  grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n  grid (child b right d) (ds \\<union> {d}) =\n  (\\<Union>p\\<in>grid b {d}. grid p ds)\n\ngoal (1 subgoal):\n 1. grid b (ds \\<union> {d}) =\n    grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d})", "unfolding grid_union_eq"], ["proof (prove)\nusing this:\n  grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n  grid (child b right d) (ds \\<union> {d}) =\n  grid b (ds \\<union> {d})\n\ngoal (1 subgoal):\n 1. grid b (ds \\<union> {d}) =\n    grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n    grid (child b right d) (ds \\<union> {d})", "by auto"], ["proof (state)\nthis:\n  grid b (ds \\<union> {d}) =\n  grid b ds \\<union> grid (child b left d) (ds \\<union> {d}) \\<union>\n  grid (child b right d) (ds \\<union> {d})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_child_without_parent: assumes grid: \"p \\<in> grid (child b dir d) ds\" (is \"p \\<in> grid ?c ds\") and \"d < length b\"\n  shows \"p \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> b", "have \"level ?c \\<le> level p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level (child b dir d) \\<le> level p", "using grid"], ["proof (prove)\nusing this:\n  p \\<in> grid (child b dir d) ds\n\ngoal (1 subgoal):\n 1. level (child b dir d) \\<le> level p", "by (rule grid_level)"], ["proof (state)\nthis:\n  level (child b dir d) \\<le> level p\n\ngoal (1 subgoal):\n 1. p \\<noteq> b", "hence \"level b < level p\""], ["proof (prove)\nusing this:\n  level (child b dir d) \\<le> level p\n\ngoal (1 subgoal):\n 1. level b < level p", "using child_level and \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  level (child b dir d) \\<le> level p\n  ?d < length ?p \\<Longrightarrow> level (child ?p ?dir ?d) = level ?p + 1\n  d < length b\n\ngoal (1 subgoal):\n 1. level b < level p", "by auto"], ["proof (state)\nthis:\n  level b < level p\n\ngoal (1 subgoal):\n 1. p \\<noteq> b", "thus ?thesis"], ["proof (prove)\nusing this:\n  level b < level p\n\ngoal (1 subgoal):\n 1. p \\<noteq> b", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_disjunct':\n  assumes \"p \\<in> grid b ds\" and \"p' \\<in> grid b ds\" and \"x \\<in> grid p ds'\" and \"p \\<noteq> p'\" and \"ds \\<inter> ds' = {}\"\n  shows \"x \\<notin> grid p' ds'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> grid p' ds'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid p' ds' \\<Longrightarrow> False", "assume \"\\<not> x \\<notin> grid p' ds'\""], ["proof (state)\nthis:\n  \\<not> x \\<notin> grid p' ds'\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid p' ds' \\<Longrightarrow> False", "hence \"x \\<in> grid p' ds'\""], ["proof (prove)\nusing this:\n  \\<not> x \\<notin> grid p' ds'\n\ngoal (1 subgoal):\n 1. x \\<in> grid p' ds'", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid p' ds'\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid p' ds' \\<Longrightarrow> False", "have l: \"length b = length p\" and l': \"length b = length p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length b = length p &&& length b = length p'", "using \\<open>p \\<in> grid b ds\\<close> and \\<open>p' \\<in> grid b ds\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  p' \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. length b = length p &&& length b = length p'", "by auto"], ["proof (state)\nthis:\n  length b = length p\n  length b = length p'\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid p' ds' \\<Longrightarrow> False", "hence \"length p' = length p\""], ["proof (prove)\nusing this:\n  length b = length p\n  length b = length p'\n\ngoal (1 subgoal):\n 1. length p' = length p", "by auto"], ["proof (state)\nthis:\n  length p' = length p\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid p' ds' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  length p' = length p\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid p' ds' \\<Longrightarrow> False", "have \"\\<forall> d < length p'. p' ! d = p ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d<length p'. p' ! d = p ! d", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d. d < length p' \\<Longrightarrow> p' ! d = p ! d", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d. d < length p' \\<Longrightarrow> p' ! d = p ! d", "assume dl': \"d < length p'\""], ["proof (state)\nthis:\n  d < length p'\n\ngoal (1 subgoal):\n 1. \\<And>d. d < length p' \\<Longrightarrow> p' ! d = p ! d", "hence \"d < length b\""], ["proof (prove)\nusing this:\n  d < length p'\n\ngoal (1 subgoal):\n 1. d < length b", "using l'"], ["proof (prove)\nusing this:\n  d < length p'\n  length b = length p'\n\ngoal (1 subgoal):\n 1. d < length b", "by auto"], ["proof (state)\nthis:\n  d < length b\n\ngoal (1 subgoal):\n 1. \\<And>d. d < length p' \\<Longrightarrow> p' ! d = p ! d", "hence dl: \"d < length p\""], ["proof (prove)\nusing this:\n  d < length b\n\ngoal (1 subgoal):\n 1. d < length p", "using l"], ["proof (prove)\nusing this:\n  d < length b\n  length b = length p\n\ngoal (1 subgoal):\n 1. d < length p", "by auto"], ["proof (state)\nthis:\n  d < length p\n\ngoal (1 subgoal):\n 1. \\<And>d. d < length p' \\<Longrightarrow> p' ! d = p ! d", "show \"p' ! d = p ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' ! d = p ! d", "proof (cases \"d \\<in> ds'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<in> ds' \\<Longrightarrow> p' ! d = p ! d\n 2. d \\<notin> ds' \\<Longrightarrow> p' ! d = p ! d", "case True"], ["proof (state)\nthis:\n  d \\<in> ds'\n\ngoal (2 subgoals):\n 1. d \\<in> ds' \\<Longrightarrow> p' ! d = p ! d\n 2. d \\<notin> ds' \\<Longrightarrow> p' ! d = p ! d", "with \\<open>ds \\<inter> ds' = {}\\<close>"], ["proof (chain)\npicking this:\n  ds \\<inter> ds' = {}\n  d \\<in> ds'", "have \"d \\<notin> ds\""], ["proof (prove)\nusing this:\n  ds \\<inter> ds' = {}\n  d \\<in> ds'\n\ngoal (1 subgoal):\n 1. d \\<notin> ds", "by auto"], ["proof (state)\nthis:\n  d \\<notin> ds\n\ngoal (2 subgoals):\n 1. d \\<in> ds' \\<Longrightarrow> p' ! d = p ! d\n 2. d \\<notin> ds' \\<Longrightarrow> p' ! d = p ! d", "hence \"p' ! d = b ! d\" and \"p ! d = b ! d\""], ["proof (prove)\nusing this:\n  d \\<notin> ds\n\ngoal (1 subgoal):\n 1. p' ! d = b ! d &&& p ! d = b ! d", "using \\<open>d < length b\\<close> \\<open>p' \\<in> grid b ds\\<close> and \\<open>p \\<in> grid b ds\\<close> and grid_invariant"], ["proof (prove)\nusing this:\n  d \\<notin> ds\n  d < length b\n  p' \\<in> grid b ds\n  p \\<in> grid b ds\n  \\<lbrakk>?d < length ?b; ?d \\<notin> ?ds; ?p \\<in> grid ?b ?ds\\<rbrakk>\n  \\<Longrightarrow> ?p ! ?d = ?b ! ?d\n\ngoal (1 subgoal):\n 1. p' ! d = b ! d &&& p ! d = b ! d", "by auto"], ["proof (state)\nthis:\n  p' ! d = b ! d\n  p ! d = b ! d\n\ngoal (2 subgoals):\n 1. d \\<in> ds' \\<Longrightarrow> p' ! d = p ! d\n 2. d \\<notin> ds' \\<Longrightarrow> p' ! d = p ! d", "thus ?thesis"], ["proof (prove)\nusing this:\n  p' ! d = b ! d\n  p ! d = b ! d\n\ngoal (1 subgoal):\n 1. p' ! d = p ! d", "by auto"], ["proof (state)\nthis:\n  p' ! d = p ! d\n\ngoal (1 subgoal):\n 1. d \\<notin> ds' \\<Longrightarrow> p' ! d = p ! d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<notin> ds' \\<Longrightarrow> p' ! d = p ! d", "case False"], ["proof (state)\nthis:\n  d \\<notin> ds'\n\ngoal (1 subgoal):\n 1. d \\<notin> ds' \\<Longrightarrow> p' ! d = p ! d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p' ! d = p ! d", "using grid_invariant[OF dl' False \\<open>x \\<in> grid p' ds'\\<close>]\n          and grid_invariant[OF dl False \\<open>x \\<in> grid p ds'\\<close>]"], ["proof (prove)\nusing this:\n  x ! d = p' ! d\n  x ! d = p ! d\n\ngoal (1 subgoal):\n 1. p' ! d = p ! d", "by auto"], ["proof (state)\nthis:\n  p' ! d = p ! d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p' ! d = p ! d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>d<length p'. p' ! d = p ! d\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid p' ds' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  length p' = length p\n  \\<forall>d<length p'. p' ! d = p ! d", "have \"p' = p\""], ["proof (prove)\nusing this:\n  length p' = length p\n  \\<forall>d<length p'. p' ! d = p ! d\n\ngoal (1 subgoal):\n 1. p' = p", "by (metis nth_equalityI)"], ["proof (state)\nthis:\n  p' = p\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid p' ds' \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  p' = p\n\ngoal (1 subgoal):\n 1. False", "using \\<open>p \\<noteq> p'\\<close>"], ["proof (prove)\nusing this:\n  p' = p\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_split1: assumes grid: \"p \\<in> grid b (ds' \\<union> ds)\" and \"ds \\<inter> ds' = {}\"\n  shows \"\\<exists>! x \\<in> grid b ds. p \\<in> grid x ds'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> grid b ds \\<and> p \\<in> grid x ds'", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. x \\<in> grid b ds \\<and> p \\<in> grid x ds'\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> grid b ds \\<and> p \\<in> grid x ds';\n        y \\<in> grid b ds \\<and> p \\<in> grid y ds'\\<rbrakk>\n       \\<Longrightarrow> x = y", "obtain x where \"x \\<in> grid b ds\" and \"p \\<in> grid x ds'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> grid b ds; p \\<in> grid x ds'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using grid_split[OF grid]"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>grid b ds. p \\<in> grid x ds'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> grid b ds; p \\<in> grid x ds'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid b ds\n  p \\<in> grid x ds'\n\ngoal (2 subgoals):\n 1. \\<exists>x. x \\<in> grid b ds \\<and> p \\<in> grid x ds'\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> grid b ds \\<and> p \\<in> grid x ds';\n        y \\<in> grid b ds \\<and> p \\<in> grid y ds'\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"\\<exists> x. x \\<in> grid b ds \\<and> p \\<in> grid x ds'\""], ["proof (prove)\nusing this:\n  x \\<in> grid b ds\n  p \\<in> grid x ds'\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> grid b ds \\<and> p \\<in> grid x ds'", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> grid b ds \\<and> p \\<in> grid x ds'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> grid b ds \\<and> p \\<in> grid x ds';\n        y \\<in> grid b ds \\<and> p \\<in> grid y ds'\\<rbrakk>\n       \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> grid b ds \\<and> p \\<in> grid x ds';\n        y \\<in> grid b ds \\<and> p \\<in> grid y ds'\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> grid b ds \\<and> p \\<in> grid x ds';\n        y \\<in> grid b ds \\<and> p \\<in> grid y ds'\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> grid b ds \\<and> p \\<in> grid x ds'\" and \"y \\<in> grid b ds \\<and> p \\<in> grid y ds'\""], ["proof (state)\nthis:\n  x \\<in> grid b ds \\<and> p \\<in> grid x ds'\n  y \\<in> grid b ds \\<and> p \\<in> grid y ds'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> grid b ds \\<and> p \\<in> grid x ds';\n        y \\<in> grid b ds \\<and> p \\<in> grid y ds'\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"x \\<in> grid b ds\" and \"p \\<in> grid x ds'\" and \"y \\<in> grid b ds\" and \"p \\<in> grid y ds'\""], ["proof (prove)\nusing this:\n  x \\<in> grid b ds \\<and> p \\<in> grid x ds'\n  y \\<in> grid b ds \\<and> p \\<in> grid y ds'\n\ngoal (1 subgoal):\n 1. (x \\<in> grid b ds &&& p \\<in> grid x ds') &&&\n    y \\<in> grid b ds &&& p \\<in> grid y ds'", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid b ds\n  p \\<in> grid x ds'\n  y \\<in> grid b ds\n  p \\<in> grid y ds'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> grid b ds \\<and> p \\<in> grid x ds';\n        y \\<in> grid b ds \\<and> p \\<in> grid y ds'\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "from grid_disjunct'[OF \\<open>x \\<in> grid b ds\\<close> \\<open>y \\<in> grid b ds\\<close> \\<open>p \\<in> grid x ds'\\<close> this \\<open>ds \\<inter> ds' = {}\\<close>]"], ["proof (chain)\npicking this:\n  p \\<notin> grid y ds'", "show False"], ["proof (prove)\nusing this:\n  p \\<notin> grid y ds'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>p \\<in> grid y ds'\\<close>"], ["proof (prove)\nusing this:\n  p \\<notin> grid y ds'\n  p \\<in> grid y ds'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Grid Restricted to a Level \\<close>"], ["", "definition lgrid :: \"grid_point \\<Rightarrow> nat set \\<Rightarrow> nat \\<Rightarrow> grid_point set\"\nwhere \"lgrid b ds lm = { p \\<in> grid b ds. level p < lm }\""], ["", "lemma lgridI[intro]:\n  \"\\<lbrakk> p \\<in> grid b ds ; level p < lm \\<rbrakk> \\<Longrightarrow> p \\<in> lgrid b ds lm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> grid b ds; level p < lm\\<rbrakk>\n    \\<Longrightarrow> p \\<in> lgrid b ds lm", "unfolding lgrid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> grid b ds; level p < lm\\<rbrakk>\n    \\<Longrightarrow> p \\<in> {p \\<in> grid b ds. level p < lm}", "by simp"], ["", "lemma lgridE[elim]:\n  assumes \"p \\<in> lgrid b ds lm\"\n  assumes \"\\<lbrakk> p \\<in> grid b ds ; level p < lm \\<rbrakk> \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> lgrid b ds lm\n  \\<lbrakk>p \\<in> grid b ds; level p < lm\\<rbrakk> \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  p \\<in> {p \\<in> grid b ds. level p < lm}\n  \\<lbrakk>p \\<in> grid b ds; level p < lm\\<rbrakk> \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by auto"], ["", "lemma lgridI_child[intro]:\n  \"d \\<in> ds \\<Longrightarrow> p \\<in> lgrid (child b dir d) ds lm \\<Longrightarrow> p \\<in> lgrid b ds lm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d \\<in> ds; p \\<in> lgrid (child b dir d) ds lm\\<rbrakk>\n    \\<Longrightarrow> p \\<in> lgrid b ds lm", "by (auto intro: grid_child)"], ["", "lemma lgrid_empty[simp]: \"lgrid p ds (level p) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lgrid p ds (level p) = {}", "proof (rule equals0I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> lgrid p ds (level p) \\<Longrightarrow> False", "fix p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> lgrid p ds (level p) \\<Longrightarrow> False", "assume \"p' \\<in> lgrid p ds (level p)\""], ["proof (state)\nthis:\n  p' \\<in> lgrid p ds (level p)\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> lgrid p ds (level p) \\<Longrightarrow> False", "hence \"level p' < level p\" and \"level p \\<le> level p'\""], ["proof (prove)\nusing this:\n  p' \\<in> lgrid p ds (level p)\n\ngoal (1 subgoal):\n 1. level p' < level p &&& level p \\<le> level p'", "by auto"], ["proof (state)\nthis:\n  level p' < level p\n  level p \\<le> level p'\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> lgrid p ds (level p) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  level p' < level p\n  level p \\<le> level p'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lgrid_empty': assumes \"lm \\<le> level p\" shows \"lgrid p ds lm = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lgrid p ds lm = {}", "proof (rule equals0I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> lgrid p ds lm \\<Longrightarrow> False", "fix p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> lgrid p ds lm \\<Longrightarrow> False", "assume \"p' \\<in> lgrid p ds lm\""], ["proof (state)\nthis:\n  p' \\<in> lgrid p ds lm\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> lgrid p ds lm \\<Longrightarrow> False", "hence \"level p' < lm\" and \"level p \\<le> level p'\""], ["proof (prove)\nusing this:\n  p' \\<in> lgrid p ds lm\n\ngoal (1 subgoal):\n 1. level p' < lm &&& level p \\<le> level p'", "by auto"], ["proof (state)\nthis:\n  level p' < lm\n  level p \\<le> level p'\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> lgrid p ds lm \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  level p' < lm\n  level p \\<le> level p'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>lm \\<le> level p\\<close>"], ["proof (prove)\nusing this:\n  level p' < lm\n  level p \\<le> level p'\n  lm \\<le> level p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_not_child:\n  assumes [simp]: \"d < length p\"\n  shows \"p \\<notin> grid (child p dir d) ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> grid (child p dir d) ds", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p \\<notin> grid (child p dir d) ds \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> p \\<notin> grid (child p dir d) ds\n\ngoal (1 subgoal):\n 1. \\<not> p \\<notin> grid (child p dir d) ds \\<Longrightarrow> False", "have \"level p < level (child p dir d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. level p < level (child p dir d)", "by auto"], ["proof (state)\nthis:\n  level p < level (child p dir d)\n\ngoal (1 subgoal):\n 1. \\<not> p \\<notin> grid (child p dir d) ds \\<Longrightarrow> False", "with grid_level[OF \\<open>\\<not> ?thesis\\<close>[unfolded not_not]]"], ["proof (chain)\npicking this:\n  level (child p dir d) \\<le> level p\n  level p < level (child p dir d)", "show False"], ["proof (prove)\nusing this:\n  level (child p dir d) \\<le> level p\n  level p < level (child p dir d)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Unbounded Sparse Grid \\<close>"], ["", "definition sparsegrid' :: \"nat \\<Rightarrow> grid_point set\"\nwhere\n  \"sparsegrid' dm = grid (start dm) { 0 ..< dm }\""], ["", "lemma grid_subset_alldim:\n  assumes p: \"p \\<in> grid b ds\"\n  defines \"dm \\<equiv> length b\"\n  shows \"p \\<in> grid b {0..<dm}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> grid b {0..<dm}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> grid b {0..<dm}", "have \"ds \\<inter> {dm..} \\<union> ds \\<inter> {0..<dm} = ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ds \\<inter> {dm..} \\<union> ds \\<inter> {0..<dm} = ds", "by auto"], ["proof (state)\nthis:\n  ds \\<inter> {dm..} \\<union> ds \\<inter> {0..<dm} = ds\n\ngoal (1 subgoal):\n 1. p \\<in> grid b {0..<dm}", "from gridgen_dim_restrict[where ds=\"ds \\<inter> {0..<dm}\" and ds'=\"ds \\<inter> {dm..}\"] this"], ["proof (chain)\npicking this:\n  \\<lbrakk>?p \\<in> grid ?b\n                     (ds \\<inter> {dm..} \\<union> ds \\<inter> {0..<dm});\n   \\<forall>d\\<in>ds \\<inter> {dm..}. length ?b \\<le> d\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> grid ?b (ds \\<inter> {0..<dm})\n  ds \\<inter> {dm..} \\<union> ds \\<inter> {0..<dm} = ds", "have \"ds \\<inter> {0..<dm} \\<subseteq> {0..<dm}\"\n    and \"p \\<in> grid b (ds \\<inter> {0..<dm})\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> grid ?b\n                     (ds \\<inter> {dm..} \\<union> ds \\<inter> {0..<dm});\n   \\<forall>d\\<in>ds \\<inter> {dm..}. length ?b \\<le> d\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> grid ?b (ds \\<inter> {0..<dm})\n  ds \\<inter> {dm..} \\<union> ds \\<inter> {0..<dm} = ds\n\ngoal (1 subgoal):\n 1. ds \\<inter> {0..<dm} \\<subseteq> {0..<dm} &&&\n    p \\<in> grid b (ds \\<inter> {0..<dm})", "using p"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> grid ?b\n                     (ds \\<inter> {dm..} \\<union> ds \\<inter> {0..<dm});\n   \\<forall>d\\<in>ds \\<inter> {dm..}. length ?b \\<le> d\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> grid ?b (ds \\<inter> {0..<dm})\n  ds \\<inter> {dm..} \\<union> ds \\<inter> {0..<dm} = ds\n  p \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. ds \\<inter> {0..<dm} \\<subseteq> {0..<dm} &&&\n    p \\<in> grid b (ds \\<inter> {0..<dm})", "unfolding dm_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> grid ?b\n                     (ds \\<inter> {length b..} \\<union>\n                      ds \\<inter> {0..<length b});\n   \\<forall>d\\<in>ds \\<inter> {length b..}. length ?b \\<le> d\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> grid ?b (ds \\<inter> {0..<length b})\n  ds \\<inter> {length b..} \\<union> ds \\<inter> {0..<length b} = ds\n  p \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. ds \\<inter> {0..<length b} \\<subseteq> {0..<length b} &&&\n    p \\<in> grid b (ds \\<inter> {0..<length b})", "by auto"], ["proof (state)\nthis:\n  ds \\<inter> {0..<dm} \\<subseteq> {0..<dm}\n  p \\<in> grid b (ds \\<inter> {0..<dm})\n\ngoal (1 subgoal):\n 1. p \\<in> grid b {0..<dm}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ds \\<inter> {0..<dm} \\<subseteq> {0..<dm}\n  p \\<in> grid b (ds \\<inter> {0..<dm})\n\ngoal (1 subgoal):\n 1. p \\<in> grid b {0..<dm}", "by (rule grid_union_dims)"], ["proof (state)\nthis:\n  p \\<in> grid b {0..<dm}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sparsegrid'_length[simp]:\n  \"b \\<in> sparsegrid' dm \\<Longrightarrow> length b = dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> sparsegrid' dm \\<Longrightarrow> length b = dm", "unfolding sparsegrid'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> grid (start dm) {0..<dm} \\<Longrightarrow> length b = dm", "by auto"], ["", "lemma sparsegrid'I[intro]:\n  assumes b: \"b \\<in> sparsegrid' dm\" and p: \"p \\<in> grid b ds\"\n  shows \"p \\<in> sparsegrid' dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid' dm", "using sparsegrid'_length[OF b] b\n       grid_transitive[OF grid_subset_alldim[OF p], where c=\"start dm\" and ds''=\"{0..<dm}\"]"], ["proof (prove)\nusing this:\n  length b = dm\n  b \\<in> sparsegrid' dm\n  \\<lbrakk>b \\<in> grid (start dm) ?ds'; ?ds' \\<subseteq> {0..<dm};\n   {0..<length b} \\<subseteq> {0..<dm}\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid' dm", "unfolding sparsegrid'_def"], ["proof (prove)\nusing this:\n  length b = dm\n  b \\<in> grid (start dm) {0..<dm}\n  \\<lbrakk>b \\<in> grid (start dm) ?ds'; ?ds' \\<subseteq> {0..<dm};\n   {0..<length b} \\<subseteq> {0..<dm}\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) {0..<dm}", "by auto"], ["", "lemma sparsegrid'_start:\n  assumes \"b \\<in> grid (start dm) ds\"\n  shows \"b \\<in> sparsegrid' dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> sparsegrid' dm", "unfolding sparsegrid'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> grid (start dm) {0..<dm}", "using grid_subset_alldim[OF assms]"], ["proof (prove)\nusing this:\n  b \\<in> grid (start dm) {0..<length (start dm)}\n\ngoal (1 subgoal):\n 1. b \\<in> grid (start dm) {0..<dm}", "by simp"], ["", "subsection \\<open> Sparse Grid \\<close>"], ["", "definition sparsegrid :: \"nat \\<Rightarrow> nat \\<Rightarrow> grid_point set\"\nwhere\n  \"sparsegrid dm lm = lgrid (start dm) { 0 ..< dm } lm\""], ["", "lemma sparsegrid_length: \"p \\<in> sparsegrid dm lm \\<Longrightarrow> length p = dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid dm lm \\<Longrightarrow> length p = dm", "by (auto simp: sparsegrid_def)"], ["", "lemma sparsegrid_subset[intro]: \"p \\<in> sparsegrid dm lm \\<Longrightarrow> p \\<in> sparsegrid' dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid dm lm \\<Longrightarrow> p \\<in> sparsegrid' dm", "unfolding sparsegrid_def sparsegrid'_def lgrid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> {p \\<in> grid (start dm) {0..<dm}.\n             level p < lm} \\<Longrightarrow>\n    p \\<in> grid (start dm) {0..<dm}", "by auto"], ["", "lemma sparsegridI[intro]:\n  assumes \"p \\<in> sparsegrid' dm\" and \"level p < lm\"\n  shows \"p \\<in> sparsegrid dm lm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid dm lm", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid' dm\n  level p < lm\n\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid dm lm", "unfolding sparsegrid'_def sparsegrid_def lgrid_def"], ["proof (prove)\nusing this:\n  p \\<in> grid (start dm) {0..<dm}\n  level p < lm\n\ngoal (1 subgoal):\n 1. p \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}", "by auto"], ["", "lemma sparsegrid_start:\n  assumes \"b \\<in> lgrid (start dm) ds lm\"\n  shows \"b \\<in> sparsegrid dm lm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> sparsegrid dm lm", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> sparsegrid' dm\n 2. level b < lm", "have \"b \\<in> grid (start dm) ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> grid (start dm) ds", "using assms"], ["proof (prove)\nusing this:\n  b \\<in> lgrid (start dm) ds lm\n\ngoal (1 subgoal):\n 1. b \\<in> grid (start dm) ds", "by auto"], ["proof (state)\nthis:\n  b \\<in> grid (start dm) ds\n\ngoal (2 subgoals):\n 1. b \\<in> sparsegrid' dm\n 2. level b < lm", "thus \"b \\<in> sparsegrid' dm\""], ["proof (prove)\nusing this:\n  b \\<in> grid (start dm) ds\n\ngoal (1 subgoal):\n 1. b \\<in> sparsegrid' dm", "by (rule sparsegrid'_start)"], ["proof (state)\nthis:\n  b \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. level b < lm", "qed (insert assms, auto)"], ["", "lemma sparsegridE[elim]:\n  assumes \"p \\<in> sparsegrid dm lm\"\n  shows \"p \\<in> sparsegrid' dm\" and \"level p < lm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid' dm &&& level p < lm", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid' dm &&& level p < lm", "unfolding sparsegrid'_def sparsegrid_def lgrid_def"], ["proof (prove)\nusing this:\n  p \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}\n\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) {0..<dm} &&& level p < lm", "by auto"], ["", "subsection \\<open> Compute Sparse Grid Points \\<close>"], ["", "fun gridgen :: \"grid_point \\<Rightarrow> nat set \\<Rightarrow> nat \\<Rightarrow> grid_point list\"\nwhere\n  \"gridgen p ds 0 = []\"\n| \"gridgen p ds (Suc l) = (let\n      sub = \\<lambda> d. gridgen (child p left d) { d' \\<in> ds . d' \\<le> d } l @\n                 gridgen (child p right d) { d' \\<in> ds . d' \\<le> d } l\n      in p # concat (map sub [ d \\<leftarrow> [0 ..< length p]. d \\<in> ds]))\""], ["", "lemma gridgen_lgrid_eq: \"set (gridgen p ds l) = lgrid p ds (level p + l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (gridgen p ds l) = lgrid p ds (level p + l)", "proof (induct l arbitrary: p ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "case (Suc l)"], ["proof (state)\nthis:\n  set (gridgen ?p ?ds l) = lgrid ?p ?ds (level ?p + l)\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "let \"?subg dir d\" = \"set (gridgen (child p dir d) { d' \\<in> ds . d' \\<le>  d } l)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "let \"?sub dir d\" = \"lgrid (child p dir d) { d' \\<in> ds . d' \\<le>  d } (level p + Suc l)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "let \"?union F dm\" = \"{p} \\<union> (\\<Union> d \\<in> { d \\<in> ds. d < dm }. F left d \\<union> F right d)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "have hyp: \"!! dir d. d < length p \\<Longrightarrow> ?subg dir d = ?sub dir d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dir d.\n       d < length p \\<Longrightarrow>\n       set (gridgen (child p dir d) {d' \\<in> ds. d' \\<le> d} l) =\n       lgrid (child p dir d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)", "using Suc.hyps"], ["proof (prove)\nusing this:\n  set (gridgen ?p ?ds l) = lgrid ?p ?ds (level ?p + l)\n\ngoal (1 subgoal):\n 1. \\<And>dir d.\n       d < length p \\<Longrightarrow>\n       set (gridgen (child p dir d) {d' \\<in> ds. d' \\<le> d} l) =\n       lgrid (child p dir d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)", "using child_level"], ["proof (prove)\nusing this:\n  set (gridgen ?p ?ds l) = lgrid ?p ?ds (level ?p + l)\n  ?d < length ?p \\<Longrightarrow> level (child ?p ?dir ?d) = level ?p + 1\n\ngoal (1 subgoal):\n 1. \\<And>dir d.\n       d < length p \\<Longrightarrow>\n       set (gridgen (child p dir d) {d' \\<in> ds. d' \\<le> d} l) =\n       lgrid (child p dir d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)", "by auto"], ["proof (state)\nthis:\n  ?d < length p \\<Longrightarrow>\n  set (gridgen (child p ?dir ?d) {d' \\<in> ds. d' \\<le> ?d} l) =\n  lgrid (child p ?dir ?d) {d' \\<in> ds. d' \\<le> ?d} (level p + Suc l)\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "{"], ["proof (state)\nthis:\n  ?d < length p \\<Longrightarrow>\n  set (gridgen (child p ?dir ?d) {d' \\<in> ds. d' \\<le> ?d} l) =\n  lgrid (child p ?dir ?d) {d' \\<in> ds. d' \\<le> ?d} (level p + Suc l)\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "fix dm"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "assume \"dm \\<le> length p\""], ["proof (state)\nthis:\n  dm \\<le> length p\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "hence \"?union ?sub dm = lgrid p {d \\<in> ds. d < dm} (level p + Suc l)\""], ["proof (prove)\nusing this:\n  dm \\<le> length p\n\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < dm} (level p + Suc l)", "proof (induct dm)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length p \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < 0}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < 0} (level p + Suc l)\n 2. \\<And>dm.\n       \\<lbrakk>dm \\<le> length p \\<Longrightarrow>\n                {p} \\<union>\n                (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n                    lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n                     (level p + Suc l) \\<union>\n                    lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n                     (level p + Suc l)) =\n                lgrid p {d \\<in> ds. d < dm} (level p + Suc l);\n        Suc dm \\<le> length p\\<rbrakk>\n       \\<Longrightarrow> {p} \\<union>\n                         (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n                             lgrid (child p left d)\n                              {d' \\<in> ds. d' \\<le> d}\n                              (level p + Suc l) \\<union>\n                             lgrid (child p right d)\n                              {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n                         lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "case (Suc dm)"], ["proof (state)\nthis:\n  dm \\<le> length p \\<Longrightarrow>\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < dm} (level p + Suc l)\n  Suc dm \\<le> length p\n\ngoal (2 subgoals):\n 1. 0 \\<le> length p \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < 0}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < 0} (level p + Suc l)\n 2. \\<And>dm.\n       \\<lbrakk>dm \\<le> length p \\<Longrightarrow>\n                {p} \\<union>\n                (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n                    lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n                     (level p + Suc l) \\<union>\n                    lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n                     (level p + Suc l)) =\n                lgrid p {d \\<in> ds. d < dm} (level p + Suc l);\n        Suc dm \\<le> length p\\<rbrakk>\n       \\<Longrightarrow> {p} \\<union>\n                         (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n                             lgrid (child p left d)\n                              {d' \\<in> ds. d' \\<le> d}\n                              (level p + Suc l) \\<union>\n                             lgrid (child p right d)\n                              {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n                         lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "hence \"dm \\<le> length p\""], ["proof (prove)\nusing this:\n  dm \\<le> length p \\<Longrightarrow>\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < dm} (level p + Suc l)\n  Suc dm \\<le> length p\n\ngoal (1 subgoal):\n 1. dm \\<le> length p", "by auto"], ["proof (state)\nthis:\n  dm \\<le> length p\n\ngoal (2 subgoals):\n 1. 0 \\<le> length p \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < 0}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < 0} (level p + Suc l)\n 2. \\<And>dm.\n       \\<lbrakk>dm \\<le> length p \\<Longrightarrow>\n                {p} \\<union>\n                (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n                    lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n                     (level p + Suc l) \\<union>\n                    lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n                     (level p + Suc l)) =\n                lgrid p {d \\<in> ds. d < dm} (level p + Suc l);\n        Suc dm \\<le> length p\\<rbrakk>\n       \\<Longrightarrow> {p} \\<union>\n                         (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n                             lgrid (child p left d)\n                              {d' \\<in> ds. d' \\<le> d}\n                              (level p + Suc l) \\<union>\n                             lgrid (child p right d)\n                              {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n                         lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "let ?l = \"child p left dm\" and ?r = \"child p right dm\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length p \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < 0}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < 0} (level p + Suc l)\n 2. \\<And>dm.\n       \\<lbrakk>dm \\<le> length p \\<Longrightarrow>\n                {p} \\<union>\n                (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n                    lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n                     (level p + Suc l) \\<union>\n                    lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n                     (level p + Suc l)) =\n                lgrid p {d \\<in> ds. d < dm} (level p + Suc l);\n        Suc dm \\<le> length p\\<rbrakk>\n       \\<Longrightarrow> {p} \\<union>\n                         (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n                             lgrid (child p left d)\n                              {d' \\<in> ds. d' \\<le> d}\n                              (level p + Suc l) \\<union>\n                             lgrid (child p right d)\n                              {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n                         lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "have p_lgrid: \"p \\<in> lgrid p {d \\<in> ds. d < dm} (level p + Suc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> lgrid p {d \\<in> ds. d < dm} (level p + Suc l)", "by auto"], ["proof (state)\nthis:\n  p \\<in> lgrid p {d \\<in> ds. d < dm} (level p + Suc l)\n\ngoal (2 subgoals):\n 1. 0 \\<le> length p \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < 0}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < 0} (level p + Suc l)\n 2. \\<And>dm.\n       \\<lbrakk>dm \\<le> length p \\<Longrightarrow>\n                {p} \\<union>\n                (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n                    lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n                     (level p + Suc l) \\<union>\n                    lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n                     (level p + Suc l)) =\n                lgrid p {d \\<in> ds. d < dm} (level p + Suc l);\n        Suc dm \\<le> length p\\<rbrakk>\n       \\<Longrightarrow> {p} \\<union>\n                         (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n                             lgrid (child p left d)\n                              {d' \\<in> ds. d' \\<le> d}\n                              (level p + Suc l) \\<union>\n                             lgrid (child p right d)\n                              {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n                         lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "proof (cases \"dm \\<in> ds\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "case True"], ["proof (state)\nthis:\n  dm \\<in> ds\n\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "let ?ds = \"{d \\<in> ds. d < dm} \\<union> {dm}\""], ["proof (state)\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "have ds_eq: \"{d' \\<in> ds. d' \\<le> dm} = ?ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {d' \\<in> ds. d' \\<le> dm} = {d \\<in> ds. d < dm} \\<union> {dm}", "using True"], ["proof (prove)\nusing this:\n  dm \\<in> ds\n\ngoal (1 subgoal):\n 1. {d' \\<in> ds. d' \\<le> dm} = {d \\<in> ds. d < dm} \\<union> {dm}", "by auto"], ["proof (state)\nthis:\n  {d' \\<in> ds. d' \\<le> dm} = {d \\<in> ds. d < dm} \\<union> {dm}\n\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "have ds_eq': \"{d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm } \\<union> {dm}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm} \\<union> {dm}", "using True"], ["proof (prove)\nusing this:\n  dm \\<in> ds\n\ngoal (1 subgoal):\n 1. {d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm} \\<union> {dm}", "by auto"], ["proof (state)\nthis:\n  {d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm} \\<union> {dm}\n\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "have \"?union ?sub (Suc dm) = ?union ?sub dm \\<union> ({p} \\<union> ?sub left dm \\<union> ?sub right dm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) \\<union>\n    ({p} \\<union>\n     lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n      (level p + Suc l) \\<union>\n     lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l))", "unfolding ds_eq'"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < dm} \\<union> {dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) \\<union>\n    ({p} \\<union>\n     lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n      (level p + Suc l) \\<union>\n     lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l))", "by auto"], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l)) \\<union>\n  ({p} \\<union>\n   lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n    (level p + Suc l) \\<union>\n   lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l))\n\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "also"], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l)) \\<union>\n  ({p} \\<union>\n   lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n    (level p + Suc l) \\<union>\n   lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l))\n\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "have \"\\<dots> = lgrid p {d \\<in> ds. d < dm} (level p + Suc l) \\<union> ?sub left dm \\<union> ?sub right dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) \\<union>\n    ({p} \\<union>\n     lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n      (level p + Suc l) \\<union>\n     lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm}\n      (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < dm} (level p + Suc l) \\<union>\n    lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n     (level p + Suc l) \\<union>\n    lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l)", "unfolding Suc.hyps[OF \\<open>dm \\<le> length p\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lgrid p {d \\<in> ds. d < dm} (level p + Suc l) \\<union>\n    ({p} \\<union>\n     lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n      (level p + Suc l) \\<union>\n     lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm}\n      (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < dm} (level p + Suc l) \\<union>\n    lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n     (level p + Suc l) \\<union>\n    lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l)", "using p_lgrid"], ["proof (prove)\nusing this:\n  p \\<in> lgrid p {d \\<in> ds. d < dm} (level p + Suc l)\n\ngoal (1 subgoal):\n 1. lgrid p {d \\<in> ds. d < dm} (level p + Suc l) \\<union>\n    ({p} \\<union>\n     lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n      (level p + Suc l) \\<union>\n     lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm}\n      (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < dm} (level p + Suc l) \\<union>\n    lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n     (level p + Suc l) \\<union>\n    lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l)", "by auto"], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l)) \\<union>\n  ({p} \\<union>\n   lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n    (level p + Suc l) \\<union>\n   lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < dm} (level p + Suc l) \\<union>\n  lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n   (level p + Suc l) \\<union>\n  lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l)\n\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "also"], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l)) \\<union>\n  ({p} \\<union>\n   lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n    (level p + Suc l) \\<union>\n   lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < dm} (level p + Suc l) \\<union>\n  lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n   (level p + Suc l) \\<union>\n  lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l)\n\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "have \"\\<dots> = {p' \\<in> grid p {d \\<in> ds. d<dm} \\<union> (grid ?l ?ds) \\<union> (grid ?r ?ds).\n          level p' < level p + Suc l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lgrid p {d \\<in> ds. d < dm} (level p + Suc l) \\<union>\n    lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n     (level p + Suc l) \\<union>\n    lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l) =\n    {p' \\<in> grid p {d \\<in> ds. d < dm} \\<union>\n              grid (child p left dm)\n               ({d \\<in> ds. d < dm} \\<union> {dm}) \\<union>\n              grid (child p right dm) ({d \\<in> ds. d < dm} \\<union> {dm}).\n     level p' < level p + Suc l}", "unfolding lgrid_def ds_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p \\<in> grid p {d \\<in> ds. d < dm}.\n     level p < level p + Suc l} \\<union>\n    {p \\<in> grid (child p left dm) ({d \\<in> ds. d < dm} \\<union> {dm}).\n     level p < level p + Suc l} \\<union>\n    {p \\<in> grid (child p right dm) ({d \\<in> ds. d < dm} \\<union> {dm}).\n     level p < level p + Suc l} =\n    {p' \\<in> grid p {d \\<in> ds. d < dm} \\<union>\n              grid (child p left dm)\n               ({d \\<in> ds. d < dm} \\<union> {dm}) \\<union>\n              grid (child p right dm) ({d \\<in> ds. d < dm} \\<union> {dm}).\n     level p' < level p + Suc l}", "by auto"], ["proof (state)\nthis:\n  lgrid p {d \\<in> ds. d < dm} (level p + Suc l) \\<union>\n  lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n   (level p + Suc l) \\<union>\n  lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l) =\n  {p' \\<in> grid p {d \\<in> ds. d < dm} \\<union>\n            grid (child p left dm)\n             ({d \\<in> ds. d < dm} \\<union> {dm}) \\<union>\n            grid (child p right dm) ({d \\<in> ds. d < dm} \\<union> {dm}).\n   level p' < level p + Suc l}\n\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "also"], ["proof (state)\nthis:\n  lgrid p {d \\<in> ds. d < dm} (level p + Suc l) \\<union>\n  lgrid (child p left dm) {d' \\<in> ds. d' \\<le> dm}\n   (level p + Suc l) \\<union>\n  lgrid (child p right dm) {d' \\<in> ds. d' \\<le> dm} (level p + Suc l) =\n  {p' \\<in> grid p {d \\<in> ds. d < dm} \\<union>\n            grid (child p left dm)\n             ({d \\<in> ds. d < dm} \\<union> {dm}) \\<union>\n            grid (child p right dm) ({d \\<in> ds. d < dm} \\<union> {dm}).\n   level p' < level p + Suc l}\n\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "have \"\\<dots> = lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p' \\<in> grid p {d \\<in> ds. d < dm} \\<union>\n              grid (child p left dm)\n               ({d \\<in> ds. d < dm} \\<union> {dm}) \\<union>\n              grid (child p right dm) ({d \\<in> ds. d < dm} \\<union> {dm}).\n     level p' < level p + Suc l} =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "unfolding lgrid_def ds_eq'"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p' \\<in> grid p {d \\<in> ds. d < dm} \\<union>\n              grid (child p left dm)\n               ({d \\<in> ds. d < dm} \\<union> {dm}) \\<union>\n              grid (child p right dm) ({d \\<in> ds. d < dm} \\<union> {dm}).\n     level p' < level p + Suc l} =\n    {p \\<in> grid p ({d \\<in> ds. d < dm} \\<union> {dm}).\n     level p < level p + Suc l}", "unfolding grid_onedim_split[where b=p]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p' \\<in> grid p {d \\<in> ds. d < dm} \\<union>\n              grid (child p left dm)\n               ({d \\<in> ds. d < dm} \\<union> {dm}) \\<union>\n              grid (child p right dm) ({d \\<in> ds. d < dm} \\<union> {dm}).\n     level p' < level p + Suc l} =\n    {p \\<in> grid p {d \\<in> ds. d < dm} \\<union>\n             grid (child p left dm)\n              ({d \\<in> ds. d < dm} \\<union> {dm}) \\<union>\n             grid (child p right dm) ({d \\<in> ds. d < dm} \\<union> {dm}).\n     level p < level p + Suc l}", ".."], ["proof (state)\nthis:\n  {p' \\<in> grid p {d \\<in> ds. d < dm} \\<union>\n            grid (child p left dm)\n             ({d \\<in> ds. d < dm} \\<union> {dm}) \\<union>\n            grid (child p right dm) ({d \\<in> ds. d < dm} \\<union> {dm}).\n   level p' < level p + Suc l} =\n  lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n\ngoal (2 subgoals):\n 1. dm \\<in> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n 2. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "finally"], ["proof (chain)\npicking this:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "show ?thesis"], ["proof (prove)\nusing this:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "."], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n\ngoal (1 subgoal):\n 1. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "case False"], ["proof (state)\nthis:\n  dm \\<notin> ds\n\ngoal (1 subgoal):\n 1. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "hence \"{d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm \\<or> d = dm}\""], ["proof (prove)\nusing this:\n  dm \\<notin> ds\n\ngoal (1 subgoal):\n 1. {d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm \\<or> d = dm}", "by auto"], ["proof (state)\nthis:\n  {d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm \\<or> d = dm}\n\ngoal (1 subgoal):\n 1. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "hence ds_eq: \"{d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm}\""], ["proof (prove)\nusing this:\n  {d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm \\<or> d = dm}\n\ngoal (1 subgoal):\n 1. {d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm}", "using \\<open>dm \\<notin> ds\\<close>"], ["proof (prove)\nusing this:\n  {d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm \\<or> d = dm}\n  dm \\<notin> ds\n\ngoal (1 subgoal):\n 1. {d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm}", "by auto"], ["proof (state)\nthis:\n  {d \\<in> ds. d < Suc dm} = {d \\<in> ds. d < dm}\n\ngoal (1 subgoal):\n 1. dm \\<notin> ds \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)", "unfolding ds_eq Suc.hyps[OF \\<open>dm \\<le> length p\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lgrid p {d \\<in> ds. d < dm} (level p + Suc l) =\n    lgrid p {d \\<in> ds. d < dm} (level p + Suc l)", ".."], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < Suc dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < Suc dm} (level p + Suc l)\n\ngoal (1 subgoal):\n 1. 0 \\<le> length p \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < 0}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < 0} (level p + Suc l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> length p \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < 0}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < 0} (level p + Suc l)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> length p\n\ngoal (1 subgoal):\n 1. 0 \\<le> length p \\<Longrightarrow>\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < 0}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < 0} (level p + Suc l)", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> length p\n\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < 0}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < 0} (level p + Suc l)", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  0 \\<le> length p\n\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < 0}.\n        {p \\<in> grid (child p left d) {d' \\<in> ds. d' \\<le> d}.\n         level p < level p + Suc l} \\<union>\n        {p \\<in> grid (child p right d) {d' \\<in> ds. d' \\<le> d}.\n         level p < level p + Suc l}) =\n    {p \\<in> grid p {d \\<in> ds. d < 0}. level p < level p + Suc l}", "by auto"], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < 0}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < 0} (level p + Suc l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < dm}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < dm} (level p + Suc l)\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "}"], ["proof (state)\nthis:\n  ?dm2 \\<le> length p \\<Longrightarrow>\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < ?dm2}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < ?dm2} (level p + Suc l)\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "hence \"?union ?sub (length p) = lgrid p {d \\<in> ds. d < length p} (level p + Suc l)\""], ["proof (prove)\nusing this:\n  ?dm2 \\<le> length p \\<Longrightarrow>\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < ?dm2}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < ?dm2} (level p + Suc l)\n\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p {d \\<in> ds. d < length p} (level p + Suc l)", "by auto"], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < length p} (level p + Suc l)\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "hence union_lgrid_eq: \"?union ?sub (length p) = lgrid p ds (level p + Suc l)\""], ["proof (prove)\nusing this:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p {d \\<in> ds. d < length p} (level p + Suc l)\n\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p ds (level p + Suc l)", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      {p \\<in> grid (child p left d) {d' \\<in> ds. d' \\<le> d}.\n       level p < level p + Suc l} \\<union>\n      {p \\<in> grid (child p right d) {d' \\<in> ds. d' \\<le> d}.\n       level p < level p + Suc l}) =\n  {p \\<in> grid p {d \\<in> ds. d < length p}. level p < level p + Suc l}\n\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n        {p \\<in> grid (child p left d) {d' \\<in> ds. d' \\<le> d}.\n         level p < level p + Suc l} \\<union>\n        {p \\<in> grid (child p right d) {d' \\<in> ds. d' \\<le> d}.\n         level p < level p + Suc l}) =\n    {p \\<in> grid p ds. level p < level p + Suc l}", "using grid_dim_remove_outer"], ["proof (prove)\nusing this:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      {p \\<in> grid (child p left d) {d' \\<in> ds. d' \\<le> d}.\n       level p < level p + Suc l} \\<union>\n      {p \\<in> grid (child p right d) {d' \\<in> ds. d' \\<le> d}.\n       level p < level p + Suc l}) =\n  {p \\<in> grid p {d \\<in> ds. d < length p}. level p < level p + Suc l}\n  grid ?b ?ds = grid ?b {d \\<in> ?ds. d < length ?b}\n\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n        {p \\<in> grid (child p left d) {d' \\<in> ds. d' \\<le> d}.\n         level p < level p + Suc l} \\<union>\n        {p \\<in> grid (child p right d) {d' \\<in> ds. d' \\<le> d}.\n         level p < level p + Suc l}) =\n    {p \\<in> grid p ds. level p < level p + Suc l}", "by auto"], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p ds (level p + Suc l)\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "have \"set (gridgen p ds (Suc l)) = ?union ?subg (length p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (gridgen p ds (Suc l)) =\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n        set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l) \\<union>\n        set (gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l))", "unfolding gridgen.simps and Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (p #\n         concat\n          (map (\\<lambda>d.\n                   gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                   gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n            (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))) =\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n        set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l) \\<union>\n        set (gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l))", "by auto"], ["proof (state)\nthis:\n  set (gridgen p ds (Suc l)) =\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l) \\<union>\n      set (gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l))\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "hence \"set (gridgen p ds (Suc l)) = ?union ?sub (length p)\""], ["proof (prove)\nusing this:\n  set (gridgen p ds (Suc l)) =\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l) \\<union>\n      set (gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l))\n\ngoal (1 subgoal):\n 1. set (gridgen p ds (Suc l)) =\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l))", "using hyp"], ["proof (prove)\nusing this:\n  set (gridgen p ds (Suc l)) =\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l) \\<union>\n      set (gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l))\n  ?d < length p \\<Longrightarrow>\n  set (gridgen (child p ?dir ?d) {d' \\<in> ds. d' \\<le> ?d} l) =\n  lgrid (child p ?dir ?d) {d' \\<in> ds. d' \\<le> ?d} (level p + Suc l)\n\ngoal (1 subgoal):\n 1. set (gridgen p ds (Suc l)) =\n    {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l))", "by auto"], ["proof (state)\nthis:\n  set (gridgen p ds (Suc l)) =\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l))\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "also"], ["proof (state)\nthis:\n  set (gridgen p ds (Suc l)) =\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l))\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "have \"\\<dots> = lgrid p ds (level p + Suc l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p ds (level p + Suc l)", "using union_lgrid_eq"], ["proof (prove)\nusing this:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p ds (level p + Suc l)\n\ngoal (1 subgoal):\n 1. {p} \\<union>\n    (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n        lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l) \\<union>\n        lgrid (child p right d) {d' \\<in> ds. d' \\<le> d}\n         (level p + Suc l)) =\n    lgrid p ds (level p + Suc l)", "."], ["proof (state)\nthis:\n  {p} \\<union>\n  (\\<Union>d\\<in>{d \\<in> ds. d < length p}.\n      lgrid (child p left d) {d' \\<in> ds. d' \\<le> d}\n       (level p + Suc l) \\<union>\n      lgrid (child p right d) {d' \\<in> ds. d' \\<le> d} (level p + Suc l)) =\n  lgrid p ds (level p + Suc l)\n\ngoal (2 subgoals):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds.\n           set (gridgen p ds l) =\n           lgrid p ds (level p + l)) \\<Longrightarrow>\n       set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "finally"], ["proof (chain)\npicking this:\n  set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "show ?case"], ["proof (prove)\nusing this:\n  set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)\n\ngoal (1 subgoal):\n 1. set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)", "."], ["proof (state)\nthis:\n  set (gridgen p ds (Suc l)) = lgrid p ds (level p + Suc l)\n\ngoal (1 subgoal):\n 1. \\<And>p ds. set (gridgen p ds 0) = lgrid p ds (level p + 0)", "qed auto"], ["", "lemma gridgen_distinct: \"distinct (gridgen p ds l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (gridgen p ds l)", "proof (induct l arbitrary: p ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ds. distinct (gridgen p ds 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds. distinct (gridgen p ds l)) \\<Longrightarrow>\n       distinct (gridgen p ds (Suc l))", "case (Suc l)"], ["proof (state)\nthis:\n  distinct (gridgen ?p ?ds l)\n\ngoal (2 subgoals):\n 1. \\<And>p ds. distinct (gridgen p ds 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds. distinct (gridgen p ds l)) \\<Longrightarrow>\n       distinct (gridgen p ds (Suc l))", "let ?ds = \"[d \\<leftarrow> [0..<length p]. d \\<in> ds]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ds. distinct (gridgen p ds 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds. distinct (gridgen p ds l)) \\<Longrightarrow>\n       distinct (gridgen p ds (Suc l))", "let \"?left d\" = \"gridgen (child p left d) { d' \\<in> ds . d' \\<le> d } l\"\n  and \"?right d\" = \"gridgen (child p right d) { d' \\<in> ds . d' \\<le> d } l\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ds. distinct (gridgen p ds 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds. distinct (gridgen p ds l)) \\<Longrightarrow>\n       distinct (gridgen p ds (Suc l))", "let \"?sub d\" = \"?left d @ ?right d\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ds. distinct (gridgen p ds 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds. distinct (gridgen p ds l)) \\<Longrightarrow>\n       distinct (gridgen p ds (Suc l))", "have \"distinct (concat (map ?sub ?ds))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (concat\n       (map (\\<lambda>a.\n                gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n                gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n         (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))", "proof (cases l)"], ["proof (state)\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    distinct\n     (concat\n       (map (\\<lambda>a.\n                gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n                gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n         (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n 2. \\<And>nat.\n       l = Suc nat \\<Longrightarrow>\n       distinct\n        (concat\n          (map (\\<lambda>a.\n                   gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n                   gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n            (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))", "case (Suc l')"], ["proof (state)\nthis:\n  l = Suc l'\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    distinct\n     (concat\n       (map (\\<lambda>a.\n                gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n                gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n         (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n 2. \\<And>nat.\n       l = Suc nat \\<Longrightarrow>\n       distinct\n        (concat\n          (map (\\<lambda>a.\n                   gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n                   gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n            (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))", "have inj_on: \"inj_on ?sub (set ?ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (\\<lambda>a.\n         gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n         gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n     (set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))", "proof (rule inj_onI, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "fix d d'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"d \\<in> set ?ds\" and \"d' \\<in> set ?ds\""], ["proof (state)\nthis:\n  d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n  d' \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"d < length p\" and \"d \\<in> set ?ds\" and \"d' < length p\""], ["proof (prove)\nusing this:\n  d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n  d' \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n\ngoal (1 subgoal):\n 1. d < length p &&&\n    d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]) &&&\n    d' < length p", "by auto"], ["proof (state)\nthis:\n  d < length p\n  d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n  d' < length p\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "assume *: \"?sub d = ?sub d'\""], ["proof (state)\nthis:\n  gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n  gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l =\n  gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n  gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have in_d: \"child p left d \\<in> set (?sub d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. child p left d\n    \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n               gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)", "using \\<open>d \\<in> set ?ds\\<close> Suc"], ["proof (prove)\nusing this:\n  d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n  l = Suc l'\n\ngoal (1 subgoal):\n 1. child p left d\n    \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n               gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)", "by (auto simp add: gridgen_lgrid_eq lgrid_def grid_Start)"], ["proof (state)\nthis:\n  child p left d\n  \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n             gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "have in_d': \"child p left d' \\<in> set (?sub d')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. child p left d'\n    \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n               gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)", "using \\<open>d \\<in> set ?ds\\<close> Suc"], ["proof (prove)\nusing this:\n  d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n  l = Suc l'\n\ngoal (1 subgoal):\n 1. child p left d'\n    \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n               gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)", "by (auto simp add: gridgen_lgrid_eq lgrid_def grid_Start)"], ["proof (state)\nthis:\n  child p left d'\n  \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n             gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  child p left d'\n  \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n             gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "fix p' d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"d \\<in> set ?ds\" and \"p' \\<in> set (?sub d)\""], ["proof (state)\nthis:\n  d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"lv p d < lv p' d\""], ["proof (prove)\nusing this:\n  d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n\ngoal (1 subgoal):\n 1. lv p d < lv p' d", "using grid_child_level"], ["proof (prove)\nusing this:\n  d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n  \\<lbrakk>?d < length ?b; ?p \\<in> grid (child ?b ?dir ?d) ?ds\\<rbrakk>\n  \\<Longrightarrow> lv ?b ?d < lv ?p ?d\n\ngoal (1 subgoal):\n 1. lv p d < lv p' d", "by (auto simp add: gridgen_lgrid_eq lgrid_def grid_child_level)"], ["proof (state)\nthis:\n  lv p d < lv p' d\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?da2 \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n   ?p'2\n   \\<in> set (gridgen (child p left ?da2) {d' \\<in> ds. d' \\<le> ?da2} l @\n              gridgen (child p right ?da2) {d' \\<in> ds. d' \\<le> ?da2}\n               l)\\<rbrakk>\n  \\<Longrightarrow> lv p ?da2 < lv ?p'2 ?da2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "note level_less = this"], ["proof (state)\nthis:\n  \\<lbrakk>?da2 \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n   ?p'2\n   \\<in> set (gridgen (child p left ?da2) {d' \\<in> ds. d' \\<le> ?da2} l @\n              gridgen (child p right ?da2) {d' \\<in> ds. d' \\<le> ?da2}\n               l)\\<rbrakk>\n  \\<Longrightarrow> lv p ?da2 < lv ?p'2 ?da2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"d \\<noteq> d'\""], ["proof (state)\nthis:\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                              [0..<length p]);\n        y \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]);\n        gridgen (child p left x) {d' \\<in> ds. d' \\<le> x} l @\n        gridgen (child p right x) {d' \\<in> ds. d' \\<le> x} l =\n        gridgen (child p left y) {d' \\<in> ds. d' \\<le> y} l @\n        gridgen (child p right y) {d' \\<in> ds. d' \\<le> y} l;\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"d' < d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d' < d \\<Longrightarrow> False\n 2. \\<not> d' < d \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  d' < d\n\ngoal (2 subgoals):\n 1. d' < d \\<Longrightarrow> False\n 2. \\<not> d' < d \\<Longrightarrow> False", "with in_d' \\<open>?sub d = ?sub d'\\<close> level_less[OF \\<open>d \\<in> set ?ds\\<close>]"], ["proof (chain)\npicking this:\n  child p left d'\n  \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n             gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n  gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n  gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l =\n  gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n  gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l\n  ?p'2\n  \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n             gridgen (child p right d) {d' \\<in> ds. d' \\<le> d}\n              l) \\<Longrightarrow>\n  lv p d < lv ?p'2 d\n  d' < d", "have \"lv p d < lv (child p left d') d\""], ["proof (prove)\nusing this:\n  child p left d'\n  \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n             gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n  gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n  gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l =\n  gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n  gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l\n  ?p'2\n  \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n             gridgen (child p right d) {d' \\<in> ds. d' \\<le> d}\n              l) \\<Longrightarrow>\n  lv p d < lv ?p'2 d\n  d' < d\n\ngoal (1 subgoal):\n 1. lv p d < lv (child p left d') d", "by simp"], ["proof (state)\nthis:\n  lv p d < lv (child p left d') d\n\ngoal (2 subgoals):\n 1. d' < d \\<Longrightarrow> False\n 2. \\<not> d' < d \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lv p d < lv (child p left d') d\n\ngoal (1 subgoal):\n 1. False", "unfolding lv_def"], ["proof (prove)\nusing this:\n  fst (p ! d) < fst (child p left d' ! d)\n\ngoal (1 subgoal):\n 1. False", "using child_invariant[OF \\<open>d < length p\\<close>, of left d'] \\<open>d \\<noteq> d'\\<close>"], ["proof (prove)\nusing this:\n  fst (p ! d) < fst (child p left d' ! d)\n  (child p left d' ! d = p ! d) = (d' \\<noteq> d)\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> d' < d \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d' < d \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> d' < d\n\ngoal (1 subgoal):\n 1. \\<not> d' < d \\<Longrightarrow> False", "hence \"d < d'\""], ["proof (prove)\nusing this:\n  \\<not> d' < d\n\ngoal (1 subgoal):\n 1. d < d'", "using \\<open>d \\<noteq> d'\\<close>"], ["proof (prove)\nusing this:\n  \\<not> d' < d\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. d < d'", "by auto"], ["proof (state)\nthis:\n  d < d'\n\ngoal (1 subgoal):\n 1. \\<not> d' < d \\<Longrightarrow> False", "with in_d \\<open>?sub d = ?sub d'\\<close> level_less[OF \\<open>d' \\<in> set ?ds\\<close>]"], ["proof (chain)\npicking this:\n  child p left d\n  \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n             gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n  gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n  gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l =\n  gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n  gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l\n  ?p'2\n  \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n             gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'}\n              l) \\<Longrightarrow>\n  lv p d' < lv ?p'2 d'\n  d < d'", "have \"lv p d' < lv (child p left d) d'\""], ["proof (prove)\nusing this:\n  child p left d\n  \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n             gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n  gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n  gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l =\n  gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n  gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l\n  ?p'2\n  \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n             gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'}\n              l) \\<Longrightarrow>\n  lv p d' < lv ?p'2 d'\n  d < d'\n\ngoal (1 subgoal):\n 1. lv p d' < lv (child p left d) d'", "by simp"], ["proof (state)\nthis:\n  lv p d' < lv (child p left d) d'\n\ngoal (1 subgoal):\n 1. \\<not> d' < d \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lv p d' < lv (child p left d) d'\n\ngoal (1 subgoal):\n 1. False", "unfolding lv_def"], ["proof (prove)\nusing this:\n  fst (p ! d') < fst (child p left d ! d')\n\ngoal (1 subgoal):\n 1. False", "using child_invariant[OF \\<open>d' < length p\\<close>, of left d] \\<open>d \\<noteq> d'\\<close>"], ["proof (prove)\nusing this:\n  fst (p ! d') < fst (child p left d ! d')\n  (child p left d ! d' = p ! d') = (d \\<noteq> d')\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on\n   (\\<lambda>a.\n       gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n       gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n   (set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))\n\ngoal (2 subgoals):\n 1. l = 0 \\<Longrightarrow>\n    distinct\n     (concat\n       (map (\\<lambda>a.\n                gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n                gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n         (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n 2. \\<And>nat.\n       l = Suc nat \\<Longrightarrow>\n       distinct\n        (concat\n          (map (\\<lambda>a.\n                   gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n                   gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n            (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (concat\n       (map (\\<lambda>a.\n                gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n                gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n         (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))", "proof (rule distinct_concat)"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct\n     (map (\\<lambda>a.\n              gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n              gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))\n 2. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>a.\n                             gridgen (child p left a)\n                              {d' \\<in> ds. d' \\<le> a} l @\n                             gridgen (child p right a)\n                              {d' \\<in> ds. d' \\<le> a} l)\n                      (filter (\\<lambda>d. d \\<in> ds)\n                        [0..<length p])) \\<Longrightarrow>\n       distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "show \"distinct (map ?sub ?ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>a.\n              gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n              gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))", "unfolding distinct_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>d. d \\<in> ds) [0..<length p]) \\<and>\n    inj_on\n     (\\<lambda>a.\n         gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n         gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n     (set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))", "using inj_on"], ["proof (prove)\nusing this:\n  inj_on\n   (\\<lambda>a.\n       gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n       gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n   (set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))\n\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>d. d \\<in> ds) [0..<length p]) \\<and>\n    inj_on\n     (\\<lambda>a.\n         gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n         gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n     (set (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))", "by simp"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>a.\n            gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n            gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n     (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>a.\n                             gridgen (child p left a)\n                              {d' \\<in> ds. d' \\<le> a} l @\n                             gridgen (child p right a)\n                              {d' \\<in> ds. d' \\<le> a} l)\n                      (filter (\\<lambda>d. d \\<in> ds)\n                        [0..<length p])) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>a.\n                             gridgen (child p left a)\n                              {d' \\<in> ds. d' \\<le> a} l @\n                             gridgen (child p right a)\n                              {d' \\<in> ds. d' \\<le> a} l)\n                      (filter (\\<lambda>d. d \\<in> ds)\n                        [0..<length p])) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "fix ys"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>a.\n                             gridgen (child p left a)\n                              {d' \\<in> ds. d' \\<le> a} l @\n                             gridgen (child p right a)\n                              {d' \\<in> ds. d' \\<le> a} l)\n                      (filter (\\<lambda>d. d \\<in> ds)\n                        [0..<length p])) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "assume \"ys \\<in> set (map ?sub ?ds)\""], ["proof (state)\nthis:\n  ys \\<in> set (map (\\<lambda>a.\n                        gridgen (child p left a) {d' \\<in> ds. d' \\<le> a}\n                         l @\n                        gridgen (child p right a) {d' \\<in> ds. d' \\<le> a}\n                         l)\n                 (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>a.\n                             gridgen (child p left a)\n                              {d' \\<in> ds. d' \\<le> a} l @\n                             gridgen (child p right a)\n                              {d' \\<in> ds. d' \\<le> a} l)\n                      (filter (\\<lambda>d. d \\<in> ds)\n                        [0..<length p])) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "then"], ["proof (chain)\npicking this:\n  ys \\<in> set (map (\\<lambda>a.\n                        gridgen (child p left a) {d' \\<in> ds. d' \\<le> a}\n                         l @\n                        gridgen (child p right a) {d' \\<in> ds. d' \\<le> a}\n                         l)\n                 (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))", "obtain d where \"d \\<in> ds\" and \"d < length p\"\n        and *: \"ys = ?sub d\""], ["proof (prove)\nusing this:\n  ys \\<in> set (map (\\<lambda>a.\n                        gridgen (child p left a) {d' \\<in> ds. d' \\<le> a}\n                         l @\n                        gridgen (child p right a) {d' \\<in> ds. d' \\<le> a}\n                         l)\n                 (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<in> ds; d < length p;\n         ys =\n         gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n         gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d \\<in> ds\n  d < length p\n  ys =\n  gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n  gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>a.\n                             gridgen (child p left a)\n                              {d' \\<in> ds. d' \\<le> a} l @\n                             gridgen (child p right a)\n                              {d' \\<in> ds. d' \\<le> a} l)\n                      (filter (\\<lambda>d. d \\<in> ds)\n                        [0..<length p])) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "show \"distinct ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ys", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n      gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)", "using grid_disjunct[OF \\<open>d < length p\\<close>, of \"{d' \\<in> ds. d' \\<le> d}\"]\n          gridgen_lgrid_eq lgrid_def \\<open>distinct (?left d)\\<close> \\<open>distinct (?right d)\\<close>"], ["proof (prove)\nusing this:\n  grid (child p left d) {d' \\<in> ds. d' \\<le> d} \\<inter>\n  grid (child p right d) {d' \\<in> ds. d' \\<le> d} =\n  {}\n  set (gridgen ?p ?ds ?l) = lgrid ?p ?ds (level ?p + ?l)\n  lgrid ?b ?ds ?lm = {p \\<in> grid ?b ?ds. level p < ?lm}\n  distinct (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l)\n  distinct (gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n\ngoal (1 subgoal):\n 1. distinct\n     (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n      gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)", "by auto"], ["proof (state)\nthis:\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "fix ys zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "assume \"ys \\<in> set (map ?sub ?ds)\""], ["proof (state)\nthis:\n  ys \\<in> set (map (\\<lambda>a.\n                        gridgen (child p left a) {d' \\<in> ds. d' \\<le> a}\n                         l @\n                        gridgen (child p right a) {d' \\<in> ds. d' \\<le> a}\n                         l)\n                 (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "then"], ["proof (chain)\npicking this:\n  ys \\<in> set (map (\\<lambda>a.\n                        gridgen (child p left a) {d' \\<in> ds. d' \\<le> a}\n                         l @\n                        gridgen (child p right a) {d' \\<in> ds. d' \\<le> a}\n                         l)\n                 (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))", "obtain d where ys: \"ys = ?sub d\" and \"d \\<in> set ?ds\""], ["proof (prove)\nusing this:\n  ys \\<in> set (map (\\<lambda>a.\n                        gridgen (child p left a) {d' \\<in> ds. d' \\<le> a}\n                         l @\n                        gridgen (child p right a) {d' \\<in> ds. d' \\<le> a}\n                         l)\n                 (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>ys =\n                 gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                 gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l;\n         d \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                       [0..<length p])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ys =\n  gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n  gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l\n  d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "hence \"d < length p\""], ["proof (prove)\nusing this:\n  ys =\n  gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n  gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l\n  d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n\ngoal (1 subgoal):\n 1. d < length p", "by auto"], ["proof (state)\nthis:\n  d < length p\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "assume \"zs \\<in> set (map ?sub ?ds)\""], ["proof (state)\nthis:\n  zs \\<in> set (map (\\<lambda>a.\n                        gridgen (child p left a) {d' \\<in> ds. d' \\<le> a}\n                         l @\n                        gridgen (child p right a) {d' \\<in> ds. d' \\<le> a}\n                         l)\n                 (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "then"], ["proof (chain)\npicking this:\n  zs \\<in> set (map (\\<lambda>a.\n                        gridgen (child p left a) {d' \\<in> ds. d' \\<le> a}\n                         l @\n                        gridgen (child p right a) {d' \\<in> ds. d' \\<le> a}\n                         l)\n                 (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))", "obtain d' where zs: \"zs = ?sub d'\" and \"d' \\<in> set ?ds\""], ["proof (prove)\nusing this:\n  zs \\<in> set (map (\\<lambda>a.\n                        gridgen (child p left a) {d' \\<in> ds. d' \\<le> a}\n                         l @\n                        gridgen (child p right a) {d' \\<in> ds. d' \\<le> a}\n                         l)\n                 (filter (\\<lambda>d. d \\<in> ds) [0..<length p]))\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>zs =\n                 gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n                 gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l;\n         d' \\<in> set (filter (\\<lambda>d. d \\<in> ds)\n                        [0..<length p])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  zs =\n  gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n  gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l\n  d' \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "hence \"d' < length p\""], ["proof (prove)\nusing this:\n  zs =\n  gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n  gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l\n  d' \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n\ngoal (1 subgoal):\n 1. d' < length p", "by auto"], ["proof (state)\nthis:\n  d' < length p\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "assume \"ys \\<noteq> zs\""], ["proof (state)\nthis:\n  ys \\<noteq> zs\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "hence \"d' \\<noteq> d\""], ["proof (prove)\nusing this:\n  ys \\<noteq> zs\n\ngoal (1 subgoal):\n 1. d' \\<noteq> d", "unfolding ys zs"], ["proof (prove)\nusing this:\n  gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n  gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l \\<noteq>\n  gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n  gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l\n\ngoal (1 subgoal):\n 1. d' \\<noteq> d", "by auto"], ["proof (state)\nthis:\n  d' \\<noteq> d\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>a.\ngridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\ngridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n                               (filter (\\<lambda>d. d \\<in> ds)\n                                 [0..<length p]));\n        zs \\<in> set (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p]));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "show \"set ys \\<inter> set zs = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<inter> set zs = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. set ys \\<inter> set zs \\<noteq> {} \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  set ys \\<inter> set zs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set ys \\<inter> set zs \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  set ys \\<inter> set zs \\<noteq> {}", "obtain p' where \"p' \\<in> set (?sub d)\" and \"p' \\<in> set (?sub d')\""], ["proof (prove)\nusing this:\n  set ys \\<inter> set zs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p' \\<in> set (gridgen (child p left d)\n                                {d' \\<in> ds. d' \\<le> d} l @\n                               gridgen (child p right d)\n                                {d' \\<in> ds. d' \\<le> d} l);\n         p' \\<in> set (gridgen (child p left d')\n                        {d'a \\<in> ds. d'a \\<le> d'} l @\n                       gridgen (child p right d')\n                        {d'a \\<in> ds. d'a \\<le> d'} l)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ys zs"], ["proof (prove)\nusing this:\n  set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n       gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l) \\<inter>\n  set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n       gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p' \\<in> set (gridgen (child p left d)\n                                {d' \\<in> ds. d' \\<le> d} l @\n                               gridgen (child p right d)\n                                {d' \\<in> ds. d' \\<le> d} l);\n         p' \\<in> set (gridgen (child p left d')\n                        {d'a \\<in> ds. d'a \\<le> d'} l @\n                       gridgen (child p right d')\n                        {d'a \\<in> ds. d'a \\<le> d'} l)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n  p' \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n                gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n\ngoal (1 subgoal):\n 1. set ys \\<inter> set zs \\<noteq> {} \\<Longrightarrow> False", "hence \"lv p d < lv p' d\" \"lv p d' < lv p' d'\""], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n  p' \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n                gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n\ngoal (1 subgoal):\n 1. lv p d < lv p' d &&& lv p d' < lv p' d'", "using grid_child_level \\<open>d \\<in> set ?ds\\<close> \\<open>d' \\<in> set ?ds\\<close>"], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n  p' \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n                gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n  \\<lbrakk>?d < length ?b; ?p \\<in> grid (child ?b ?dir ?d) ?ds\\<rbrakk>\n  \\<Longrightarrow> lv ?b ?d < lv ?p ?d\n  d \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n  d' \\<in> set (filter (\\<lambda>d. d \\<in> ds) [0..<length p])\n\ngoal (1 subgoal):\n 1. lv p d < lv p' d &&& lv p d' < lv p' d'", "by (auto simp add: gridgen_lgrid_eq lgrid_def grid_child_level)"], ["proof (state)\nthis:\n  lv p d < lv p' d\n  lv p d' < lv p' d'\n\ngoal (1 subgoal):\n 1. set ys \\<inter> set zs \\<noteq> {} \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"d < d'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d < d' \\<Longrightarrow> False\n 2. \\<not> d < d' \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  d < d'\n\ngoal (2 subgoals):\n 1. d < d' \\<Longrightarrow> False\n 2. \\<not> d < d' \\<Longrightarrow> False", "from \\<open>p' \\<in> set (?sub d)\\<close>"], ["proof (chain)\npicking this:\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)", "have \"p ! d' = p' ! d'\""], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n\ngoal (1 subgoal):\n 1. p ! d' = p' ! d'", "using grid_invariant[of d' \"child p right d\" \"{d' \\<in> ds. d' \\<le> d}\"]"], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n  \\<lbrakk>d' < length (child p right d);\n   d' \\<notin> {d' \\<in> ds. d' \\<le> d};\n   ?p \\<in> grid (child p right d) {d' \\<in> ds. d' \\<le> d}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d' = child p right d ! d'\n\ngoal (1 subgoal):\n 1. p ! d' = p' ! d'", "using grid_invariant[of d' \"child p left d\" \"{d' \\<in> ds. d' \\<le> d}\"]"], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n  \\<lbrakk>d' < length (child p right d);\n   d' \\<notin> {d' \\<in> ds. d' \\<le> d};\n   ?p \\<in> grid (child p right d) {d' \\<in> ds. d' \\<le> d}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d' = child p right d ! d'\n  \\<lbrakk>d' < length (child p left d);\n   d' \\<notin> {d' \\<in> ds. d' \\<le> d};\n   ?p \\<in> grid (child p left d) {d' \\<in> ds. d' \\<le> d}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d' = child p left d ! d'\n\ngoal (1 subgoal):\n 1. p ! d' = p' ! d'", "using child_invariant[of d' _ _ d] \\<open>d < d'\\<close> \\<open>d' < length p\\<close>"], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n  \\<lbrakk>d' < length (child p right d);\n   d' \\<notin> {d' \\<in> ds. d' \\<le> d};\n   ?p \\<in> grid (child p right d) {d' \\<in> ds. d' \\<le> d}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d' = child p right d ! d'\n  \\<lbrakk>d' < length (child p left d);\n   d' \\<notin> {d' \\<in> ds. d' \\<le> d};\n   ?p \\<in> grid (child p left d) {d' \\<in> ds. d' \\<le> d}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d' = child p left d ! d'\n  d' < length ?p \\<Longrightarrow>\n  (child ?p ?dir d ! d' = ?p ! d') = (d \\<noteq> d')\n  d < d'\n  d' < length p\n\ngoal (1 subgoal):\n 1. p ! d' = p' ! d'", "using gridgen_lgrid_eq lgrid_def"], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n  \\<lbrakk>d' < length (child p right d);\n   d' \\<notin> {d' \\<in> ds. d' \\<le> d};\n   ?p \\<in> grid (child p right d) {d' \\<in> ds. d' \\<le> d}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d' = child p right d ! d'\n  \\<lbrakk>d' < length (child p left d);\n   d' \\<notin> {d' \\<in> ds. d' \\<le> d};\n   ?p \\<in> grid (child p left d) {d' \\<in> ds. d' \\<le> d}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d' = child p left d ! d'\n  d' < length ?p \\<Longrightarrow>\n  (child ?p ?dir d ! d' = ?p ! d') = (d \\<noteq> d')\n  d < d'\n  d' < length p\n  set (gridgen ?p ?ds ?l) = lgrid ?p ?ds (level ?p + ?l)\n  lgrid ?b ?ds ?lm = {p \\<in> grid ?b ?ds. level p < ?lm}\n\ngoal (1 subgoal):\n 1. p ! d' = p' ! d'", "by auto"], ["proof (state)\nthis:\n  p ! d' = p' ! d'\n\ngoal (2 subgoals):\n 1. d < d' \\<Longrightarrow> False\n 2. \\<not> d < d' \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  p ! d' = p' ! d'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>lv p d' < lv p' d'\\<close>"], ["proof (prove)\nusing this:\n  p ! d' = p' ! d'\n  lv p d' < lv p' d'\n\ngoal (1 subgoal):\n 1. False", "unfolding lv_def"], ["proof (prove)\nusing this:\n  p ! d' = p' ! d'\n  fst (p ! d') < fst (p' ! d')\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> d < d' \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d < d' \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> d < d'\n\ngoal (1 subgoal):\n 1. \\<not> d < d' \\<Longrightarrow> False", "hence \"d' < d\""], ["proof (prove)\nusing this:\n  \\<not> d < d'\n\ngoal (1 subgoal):\n 1. d' < d", "using \\<open>d' \\<noteq> d\\<close>"], ["proof (prove)\nusing this:\n  \\<not> d < d'\n  d' \\<noteq> d\n\ngoal (1 subgoal):\n 1. d' < d", "by simp"], ["proof (state)\nthis:\n  d' < d\n\ngoal (1 subgoal):\n 1. \\<not> d < d' \\<Longrightarrow> False", "from \\<open>p' \\<in> set (?sub d')\\<close>"], ["proof (chain)\npicking this:\n  p' \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n                gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)", "have \"p ! d = p' ! d\""], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n                gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n\ngoal (1 subgoal):\n 1. p ! d = p' ! d", "using grid_invariant[of d \"child p right d'\" \"{d \\<in> ds. d \\<le> d'}\"]"], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n                gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n  \\<lbrakk>d < length (child p right d');\n   d \\<notin> {d \\<in> ds. d \\<le> d'};\n   ?p \\<in> grid (child p right d') {d \\<in> ds. d \\<le> d'}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d = child p right d' ! d\n\ngoal (1 subgoal):\n 1. p ! d = p' ! d", "using grid_invariant[of d \"child p left d'\" \"{d \\<in> ds. d \\<le> d'}\"]"], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n                gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n  \\<lbrakk>d < length (child p right d');\n   d \\<notin> {d \\<in> ds. d \\<le> d'};\n   ?p \\<in> grid (child p right d') {d \\<in> ds. d \\<le> d'}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d = child p right d' ! d\n  \\<lbrakk>d < length (child p left d');\n   d \\<notin> {d \\<in> ds. d \\<le> d'};\n   ?p \\<in> grid (child p left d') {d \\<in> ds. d \\<le> d'}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d = child p left d' ! d\n\ngoal (1 subgoal):\n 1. p ! d = p' ! d", "using child_invariant[of d _ _ d'] \\<open>d' < d\\<close> \\<open>d < length p\\<close>"], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n                gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n  \\<lbrakk>d < length (child p right d');\n   d \\<notin> {d \\<in> ds. d \\<le> d'};\n   ?p \\<in> grid (child p right d') {d \\<in> ds. d \\<le> d'}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d = child p right d' ! d\n  \\<lbrakk>d < length (child p left d');\n   d \\<notin> {d \\<in> ds. d \\<le> d'};\n   ?p \\<in> grid (child p left d') {d \\<in> ds. d \\<le> d'}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d = child p left d' ! d\n  d < length ?p \\<Longrightarrow>\n  (child ?p ?dir d' ! d = ?p ! d) = (d' \\<noteq> d)\n  d' < d\n  d < length p\n\ngoal (1 subgoal):\n 1. p ! d = p' ! d", "using gridgen_lgrid_eq lgrid_def"], ["proof (prove)\nusing this:\n  p' \\<in> set (gridgen (child p left d') {d'a \\<in> ds. d'a \\<le> d'} l @\n                gridgen (child p right d') {d'a \\<in> ds. d'a \\<le> d'} l)\n  \\<lbrakk>d < length (child p right d');\n   d \\<notin> {d \\<in> ds. d \\<le> d'};\n   ?p \\<in> grid (child p right d') {d \\<in> ds. d \\<le> d'}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d = child p right d' ! d\n  \\<lbrakk>d < length (child p left d');\n   d \\<notin> {d \\<in> ds. d \\<le> d'};\n   ?p \\<in> grid (child p left d') {d \\<in> ds. d \\<le> d'}\\<rbrakk>\n  \\<Longrightarrow> ?p ! d = child p left d' ! d\n  d < length ?p \\<Longrightarrow>\n  (child ?p ?dir d' ! d = ?p ! d) = (d' \\<noteq> d)\n  d' < d\n  d < length p\n  set (gridgen ?p ?ds ?l) = lgrid ?p ?ds (level ?p + ?l)\n  lgrid ?b ?ds ?lm = {p \\<in> grid ?b ?ds. level p < ?lm}\n\ngoal (1 subgoal):\n 1. p ! d = p' ! d", "by auto"], ["proof (state)\nthis:\n  p ! d = p' ! d\n\ngoal (1 subgoal):\n 1. \\<not> d < d' \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  p ! d = p' ! d\n\ngoal (1 subgoal):\n 1. False", "using \\<open>lv p d < lv p' d\\<close>"], ["proof (prove)\nusing this:\n  p ! d = p' ! d\n  lv p d < lv p' d\n\ngoal (1 subgoal):\n 1. False", "unfolding lv_def"], ["proof (prove)\nusing this:\n  p ! d = p' ! d\n  fst (p ! d) < fst (p' ! d)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set ys \\<inter> set zs = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct\n   (concat\n     (map (\\<lambda>a.\n              gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n              gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n       (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n\ngoal (1 subgoal):\n 1. l = 0 \\<Longrightarrow>\n    distinct\n     (concat\n       (map (\\<lambda>a.\n                gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n                gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n         (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))", "qed (simp add: map_replicate_const)"], ["proof (state)\nthis:\n  distinct\n   (concat\n     (map (\\<lambda>a.\n              gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n              gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n       (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n\ngoal (2 subgoals):\n 1. \\<And>p ds. distinct (gridgen p ds 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds. distinct (gridgen p ds l)) \\<Longrightarrow>\n       distinct (gridgen p ds (Suc l))", "moreover"], ["proof (state)\nthis:\n  distinct\n   (concat\n     (map (\\<lambda>a.\n              gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n              gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n       (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n\ngoal (2 subgoals):\n 1. \\<And>p ds. distinct (gridgen p ds 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds. distinct (gridgen p ds l)) \\<Longrightarrow>\n       distinct (gridgen p ds (Suc l))", "have \"p \\<notin> set (concat (map ?sub ?ds))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> set (concat\n                     (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))", "using gridgen_lgrid_eq lgrid_def grid_not_child[of _ p]"], ["proof (prove)\nusing this:\n  set (gridgen ?p ?ds ?l) = lgrid ?p ?ds (level ?p + ?l)\n  lgrid ?b ?ds ?lm = {p \\<in> grid ?b ?ds. level p < ?lm}\n  ?d < length p \\<Longrightarrow> p \\<notin> grid (child p ?dir ?d) ?ds\n\ngoal (1 subgoal):\n 1. p \\<notin> set (concat\n                     (map (\\<lambda>a.\n                              gridgen (child p left a)\n                               {d' \\<in> ds. d' \\<le> a} l @\n                              gridgen (child p right a)\n                               {d' \\<in> ds. d' \\<le> a} l)\n                       (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))", "by simp"], ["proof (state)\nthis:\n  p \\<notin> set (concat\n                   (map (\\<lambda>a.\n                            gridgen (child p left a)\n                             {d' \\<in> ds. d' \\<le> a} l @\n                            gridgen (child p right a)\n                             {d' \\<in> ds. d' \\<le> a} l)\n                     (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n\ngoal (2 subgoals):\n 1. \\<And>p ds. distinct (gridgen p ds 0)\n 2. \\<And>l p ds.\n       (\\<And>p ds. distinct (gridgen p ds l)) \\<Longrightarrow>\n       distinct (gridgen p ds (Suc l))", "ultimately"], ["proof (chain)\npicking this:\n  distinct\n   (concat\n     (map (\\<lambda>a.\n              gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n              gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n       (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n  p \\<notin> set (concat\n                   (map (\\<lambda>a.\n                            gridgen (child p left a)\n                             {d' \\<in> ds. d' \\<le> a} l @\n                            gridgen (child p right a)\n                             {d' \\<in> ds. d' \\<le> a} l)\n                     (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))", "show ?case"], ["proof (prove)\nusing this:\n  distinct\n   (concat\n     (map (\\<lambda>a.\n              gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n              gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n       (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n  p \\<notin> set (concat\n                   (map (\\<lambda>a.\n                            gridgen (child p left a)\n                             {d' \\<in> ds. d' \\<le> a} l @\n                            gridgen (child p right a)\n                             {d' \\<in> ds. d' \\<le> a} l)\n                     (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n\ngoal (1 subgoal):\n 1. distinct (gridgen p ds (Suc l))", "unfolding gridgen.simps Let_def distinct.simps"], ["proof (prove)\nusing this:\n  distinct\n   (concat\n     (map (\\<lambda>a.\n              gridgen (child p left a) {d' \\<in> ds. d' \\<le> a} l @\n              gridgen (child p right a) {d' \\<in> ds. d' \\<le> a} l)\n       (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n  p \\<notin> set (concat\n                   (map (\\<lambda>a.\n                            gridgen (child p left a)\n                             {d' \\<in> ds. d' \\<le> a} l @\n                            gridgen (child p right a)\n                             {d' \\<in> ds. d' \\<le> a} l)\n                     (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))\n\ngoal (1 subgoal):\n 1. p \\<notin> set (concat\n                     (map (\\<lambda>d.\n                              gridgen (child p left d)\n                               {d' \\<in> ds. d' \\<le> d} l @\n                              gridgen (child p right d)\n                               {d' \\<in> ds. d' \\<le> d} l)\n                       (filter (\\<lambda>d. d \\<in> ds)\n                         [0..<length p]))) \\<and>\n    distinct\n     (concat\n       (map (\\<lambda>d.\n                gridgen (child p left d) {d' \\<in> ds. d' \\<le> d} l @\n                gridgen (child p right d) {d' \\<in> ds. d' \\<le> d} l)\n         (filter (\\<lambda>d. d \\<in> ds) [0..<length p])))", "by simp"], ["proof (state)\nthis:\n  distinct (gridgen p ds (Suc l))\n\ngoal (1 subgoal):\n 1. \\<And>p ds. distinct (gridgen p ds 0)", "qed auto"], ["", "lemma lgrid_finite: \"finite (lgrid b ds lm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lgrid b ds lm)", "proof (cases \"level b \\<le> lm\")"], ["proof (state)\ngoal (2 subgoals):\n 1. level b \\<le> lm \\<Longrightarrow> finite (lgrid b ds lm)\n 2. \\<not> level b \\<le> lm \\<Longrightarrow> finite (lgrid b ds lm)", "case True"], ["proof (state)\nthis:\n  level b \\<le> lm\n\ngoal (2 subgoals):\n 1. level b \\<le> lm \\<Longrightarrow> finite (lgrid b ds lm)\n 2. \\<not> level b \\<le> lm \\<Longrightarrow> finite (lgrid b ds lm)", "from iffD1[OF le_iff_add True]"], ["proof (chain)\npicking this:\n  \\<exists>c. lm = level b + c", "obtain l where l: \"lm = level b + l\""], ["proof (prove)\nusing this:\n  \\<exists>c. lm = level b + c\n\ngoal (1 subgoal):\n 1. (\\<And>l. lm = level b + l \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lm = level b + l\n\ngoal (2 subgoals):\n 1. level b \\<le> lm \\<Longrightarrow> finite (lgrid b ds lm)\n 2. \\<not> level b \\<le> lm \\<Longrightarrow> finite (lgrid b ds lm)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lgrid b ds lm)", "unfolding l gridgen_lgrid_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (gridgen b ds l))", "by auto"], ["proof (state)\nthis:\n  finite (lgrid b ds lm)\n\ngoal (1 subgoal):\n 1. \\<not> level b \\<le> lm \\<Longrightarrow> finite (lgrid b ds lm)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> level b \\<le> lm \\<Longrightarrow> finite (lgrid b ds lm)", "case False"], ["proof (state)\nthis:\n  \\<not> level b \\<le> lm\n\ngoal (1 subgoal):\n 1. \\<not> level b \\<le> lm \\<Longrightarrow> finite (lgrid b ds lm)", "hence \"!! x. x \\<in> grid b ds \\<Longrightarrow> (\\<not> level x < lm)\""], ["proof (prove)\nusing this:\n  \\<not> level b \\<le> lm\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> grid b ds \\<Longrightarrow> \\<not> level x < lm", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid b ds; \\<not> level b \\<le> lm\\<rbrakk>\n       \\<Longrightarrow> \\<not> level x < lm", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid b ds; \\<not> level b \\<le> lm\\<rbrakk>\n       \\<Longrightarrow> \\<not> level x < lm", "assume \"x \\<in> grid b ds\""], ["proof (state)\nthis:\n  x \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> grid b ds; \\<not> level b \\<le> lm\\<rbrakk>\n       \\<Longrightarrow> \\<not> level x < lm", "from grid_level[OF this]"], ["proof (chain)\npicking this:\n  level b \\<le> level x", "show \"\\<not> level x < lm\""], ["proof (prove)\nusing this:\n  level b \\<le> level x\n\ngoal (1 subgoal):\n 1. \\<not> level x < lm", "using False"], ["proof (prove)\nusing this:\n  level b \\<le> level x\n  \\<not> level b \\<le> lm\n\ngoal (1 subgoal):\n 1. \\<not> level x < lm", "by auto"], ["proof (state)\nthis:\n  \\<not> level x < lm\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> grid b ds \\<Longrightarrow> \\<not> level ?x < lm\n\ngoal (1 subgoal):\n 1. \\<not> level b \\<le> lm \\<Longrightarrow> finite (lgrid b ds lm)", "hence \"lgrid b ds lm = {}\""], ["proof (prove)\nusing this:\n  ?x \\<in> grid b ds \\<Longrightarrow> \\<not> level ?x < lm\n\ngoal (1 subgoal):\n 1. lgrid b ds lm = {}", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  ?x \\<in> grid b ds \\<Longrightarrow> \\<not> level ?x < lm\n\ngoal (1 subgoal):\n 1. {p \\<in> grid b ds. level p < lm} = {}", "by auto"], ["proof (state)\nthis:\n  lgrid b ds lm = {}\n\ngoal (1 subgoal):\n 1. \\<not> level b \\<le> lm \\<Longrightarrow> finite (lgrid b ds lm)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lgrid b ds lm = {}\n\ngoal (1 subgoal):\n 1. finite (lgrid b ds lm)", "by auto"], ["proof (state)\nthis:\n  finite (lgrid b ds lm)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lgrid_sum:\n  fixes F :: \"grid_point \\<Rightarrow> real\"\n  assumes \"d < length b\" and \"level b < lm\"\n  shows \"(\\<Sum> p \\<in> lgrid b {d} lm. F p) =\n          (\\<Sum> p \\<in> lgrid (child b left d) {d} lm. F p) + (\\<Sum> p \\<in> lgrid (child b right d) {d} lm. F p) + F b\"\n  (is \"(\\<Sum> p \\<in> ?grid b. F p) = (\\<Sum> p \\<in> ?grid ?l . F p) + (?sum (?grid ?r)) + F b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    sum F (lgrid (child b left d) {d} lm) +\n    sum F (lgrid (child b right d) {d} lm) +\n    F b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    sum F (lgrid (child b left d) {d} lm) +\n    sum F (lgrid (child b right d) {d} lm) +\n    F b", "have \"!! dir. b \\<notin> ?grid (child b dir d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dir. b \\<notin> lgrid (child b dir d) {d} lm", "using grid_child_without_parent[where ds=\"{d}\"] and \\<open>d < length b\\<close> and lgrid_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> grid (child ?b ?dir ?d) {d}; ?d < length ?b\\<rbrakk>\n  \\<Longrightarrow> ?p \\<noteq> ?b\n  d < length b\n  lgrid ?b ?ds ?lm = {p \\<in> grid ?b ?ds. level p < ?lm}\n\ngoal (1 subgoal):\n 1. \\<And>dir. b \\<notin> lgrid (child b dir d) {d} lm", "by auto"], ["proof (state)\nthis:\n  b \\<notin> lgrid (child b ?dir d) {d} lm\n\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    sum F (lgrid (child b left d) {d} lm) +\n    sum F (lgrid (child b right d) {d} lm) +\n    F b", "hence b_distinct: \"b \\<notin> (?grid ?l \\<union> ?grid ?r)\""], ["proof (prove)\nusing this:\n  b \\<notin> lgrid (child b ?dir d) {d} lm\n\ngoal (1 subgoal):\n 1. b \\<notin> lgrid (child b left d) {d} lm \\<union>\n               lgrid (child b right d) {d} lm", "by auto"], ["proof (state)\nthis:\n  b \\<notin> lgrid (child b left d) {d} lm \\<union>\n             lgrid (child b right d) {d} lm\n\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    sum F (lgrid (child b left d) {d} lm) +\n    sum F (lgrid (child b right d) {d} lm) +\n    F b", "have \"?grid ?l \\<inter> ?grid ?r = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lgrid (child b left d) {d} lm \\<inter> lgrid (child b right d) {d} lm =\n    {}", "unfolding lgrid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p \\<in> grid (child b left d) {d}. level p < lm} \\<inter>\n    {p \\<in> grid (child b right d) {d}. level p < lm} =\n    {}", "using grid_disjunct and \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  ?d < length ?p \\<Longrightarrow>\n  grid (child ?p left ?d) ?ds \\<inter> grid (child ?p right ?d) ?ds = {}\n  d < length b\n\ngoal (1 subgoal):\n 1. {p \\<in> grid (child b left d) {d}. level p < lm} \\<inter>\n    {p \\<in> grid (child b right d) {d}. level p < lm} =\n    {}", "by auto"], ["proof (state)\nthis:\n  lgrid (child b left d) {d} lm \\<inter> lgrid (child b right d) {d} lm = {}\n\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    sum F (lgrid (child b left d) {d} lm) +\n    sum F (lgrid (child b right d) {d} lm) +\n    F b", "from lgrid_finite lgrid_finite and this"], ["proof (chain)\npicking this:\n  finite (lgrid ?b ?ds ?lm)\n  finite (lgrid ?b ?ds ?lm)\n  lgrid (child b left d) {d} lm \\<inter> lgrid (child b right d) {d} lm = {}", "have child_eq: \"?sum ((?grid ?l) \\<union> (?grid ?r)) = ?sum (?grid ?l) + ?sum (?grid ?r)\""], ["proof (prove)\nusing this:\n  finite (lgrid ?b ?ds ?lm)\n  finite (lgrid ?b ?ds ?lm)\n  lgrid (child b left d) {d} lm \\<inter> lgrid (child b right d) {d} lm = {}\n\ngoal (1 subgoal):\n 1. sum F\n     (lgrid (child b left d) {d} lm \\<union>\n      lgrid (child b right d) {d} lm) =\n    sum F (lgrid (child b left d) {d} lm) +\n    sum F (lgrid (child b right d) {d} lm)", "by (rule sum.union_disjoint)"], ["proof (state)\nthis:\n  sum F\n   (lgrid (child b left d) {d} lm \\<union> lgrid (child b right d) {d} lm) =\n  sum F (lgrid (child b left d) {d} lm) +\n  sum F (lgrid (child b right d) {d} lm)\n\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    sum F (lgrid (child b left d) {d} lm) +\n    sum F (lgrid (child b right d) {d} lm) +\n    F b", "have \"?grid b = {b} \\<union> (?grid ?l) \\<union> (?grid ?r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lgrid b {d} lm =\n    {b} \\<union> lgrid (child b left d) {d} lm \\<union>\n    lgrid (child b right d) {d} lm", "unfolding lgrid_def grid_partition[where p=b]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p \\<in> {b} \\<union> grid (child b left d) {d} \\<union>\n             grid (child b right d) {d}.\n     level p < lm} =\n    {b} \\<union> {p \\<in> grid (child b left d) {d}. level p < lm} \\<union>\n    {p \\<in> grid (child b right d) {d}. level p < lm}", "using assms"], ["proof (prove)\nusing this:\n  d < length b\n  level b < lm\n\ngoal (1 subgoal):\n 1. {p \\<in> {b} \\<union> grid (child b left d) {d} \\<union>\n             grid (child b right d) {d}.\n     level p < lm} =\n    {b} \\<union> {p \\<in> grid (child b left d) {d}. level p < lm} \\<union>\n    {p \\<in> grid (child b right d) {d}. level p < lm}", "by auto"], ["proof (state)\nthis:\n  lgrid b {d} lm =\n  {b} \\<union> lgrid (child b left d) {d} lm \\<union>\n  lgrid (child b right d) {d} lm\n\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    sum F (lgrid (child b left d) {d} lm) +\n    sum F (lgrid (child b right d) {d} lm) +\n    F b", "hence \"?sum (?grid b) = F b + ?sum ((?grid ?l) \\<union> (?grid ?r))\""], ["proof (prove)\nusing this:\n  lgrid b {d} lm =\n  {b} \\<union> lgrid (child b left d) {d} lm \\<union>\n  lgrid (child b right d) {d} lm\n\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    F b +\n    sum F\n     (lgrid (child b left d) {d} lm \\<union> lgrid (child b right d) {d} lm)", "using b_distinct and lgrid_finite"], ["proof (prove)\nusing this:\n  lgrid b {d} lm =\n  {b} \\<union> lgrid (child b left d) {d} lm \\<union>\n  lgrid (child b right d) {d} lm\n  b \\<notin> lgrid (child b left d) {d} lm \\<union>\n             lgrid (child b right d) {d} lm\n  finite (lgrid ?b ?ds ?lm)\n\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    F b +\n    sum F\n     (lgrid (child b left d) {d} lm \\<union> lgrid (child b right d) {d} lm)", "by auto"], ["proof (state)\nthis:\n  sum F (lgrid b {d} lm) =\n  F b +\n  sum F\n   (lgrid (child b left d) {d} lm \\<union> lgrid (child b right d) {d} lm)\n\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    sum F (lgrid (child b left d) {d} lm) +\n    sum F (lgrid (child b right d) {d} lm) +\n    F b", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum F (lgrid b {d} lm) =\n  F b +\n  sum F\n   (lgrid (child b left d) {d} lm \\<union> lgrid (child b right d) {d} lm)\n\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    sum F (lgrid (child b left d) {d} lm) +\n    sum F (lgrid (child b right d) {d} lm) +\n    F b", "using child_eq"], ["proof (prove)\nusing this:\n  sum F (lgrid b {d} lm) =\n  F b +\n  sum F\n   (lgrid (child b left d) {d} lm \\<union> lgrid (child b right d) {d} lm)\n  sum F\n   (lgrid (child b left d) {d} lm \\<union> lgrid (child b right d) {d} lm) =\n  sum F (lgrid (child b left d) {d} lm) +\n  sum F (lgrid (child b right d) {d} lm)\n\ngoal (1 subgoal):\n 1. sum F (lgrid b {d} lm) =\n    sum F (lgrid (child b left d) {d} lm) +\n    sum F (lgrid (child b right d) {d} lm) +\n    F b", "by auto"], ["proof (state)\nthis:\n  sum F (lgrid b {d} lm) =\n  sum F (lgrid (child b left d) {d} lm) +\n  sum F (lgrid (child b right d) {d} lm) +\n  F b\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Base Points \\<close>"], ["", "definition base :: \"nat set \\<Rightarrow> grid_point \\<Rightarrow> grid_point\"\nwhere \"base ds p = (THE b. b \\<in> grid (start (length p)) ({0 ..< length p} - ds) \\<and> p \\<in> grid b ds)\""], ["", "lemma baseE: assumes p_grid: \"p \\<in> sparsegrid' dm\"\n  shows \"base ds p \\<in> grid (start dm) ({0..<dm} - ds)\"\n  and \"p \\<in> grid (base ds p) ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) ({0..<dm} - ds) &&&\n    p \\<in> grid (base ds p) ds", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. base ds p \\<in> grid (start dm) ({0..<dm} - ds)\n 2. p \\<in> grid (base ds p) ds", "from p_grid[unfolded sparsegrid'_def]"], ["proof (chain)\npicking this:\n  p \\<in> grid (start dm) {0..<dm}", "have *: \"\\<exists>! x \\<in> grid (start dm) ({0..<dm} - ds). p \\<in> grid x ds\""], ["proof (prove)\nusing this:\n  p \\<in> grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds", "by (intro grid_split1) (auto intro: grid_union_dims)"], ["proof (state)\nthis:\n  \\<exists>!x.\n     x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n\ngoal (2 subgoals):\n 1. base ds p \\<in> grid (start dm) ({0..<dm} - ds)\n 2. p \\<in> grid (base ds p) ds", "then"], ["proof (chain)\npicking this:\n  \\<exists>!x.\n     x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds", "obtain x where x_eq: \"x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\""], ["proof (prove)\nusing this:\n  \\<exists>!x.\n     x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> grid (start dm) ({0..<dm} - ds) \\<and>\n        p \\<in> grid x ds \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n\ngoal (2 subgoals):\n 1. base ds p \\<in> grid (start dm) ({0..<dm} - ds)\n 2. p \\<in> grid (base ds p) ds", "with *"], ["proof (chain)\npicking this:\n  \\<exists>!x.\n     x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n  x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds", "have \"base ds p = x\""], ["proof (prove)\nusing this:\n  \\<exists>!x.\n     x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n  x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n\ngoal (1 subgoal):\n 1. base ds p = x", "unfolding base_def"], ["proof (prove)\nusing this:\n  \\<exists>!x.\n     x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n  x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n\ngoal (1 subgoal):\n 1. (THE b.\n        b \\<in> grid (start (length p)) ({0..<length p} - ds) \\<and>\n        p \\<in> grid b ds) =\n    x", "by auto"], ["proof (state)\nthis:\n  base ds p = x\n\ngoal (2 subgoals):\n 1. base ds p \\<in> grid (start dm) ({0..<dm} - ds)\n 2. p \\<in> grid (base ds p) ds", "thus \"base ds p \\<in> grid (start dm) ({0..<dm} - ds)\" and \"p \\<in> grid (base ds p) ds\""], ["proof (prove)\nusing this:\n  base ds p = x\n\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) ({0..<dm} - ds) &&&\n    p \\<in> grid (base ds p) ds", "using x_eq"], ["proof (prove)\nusing this:\n  base ds p = x\n  x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) ({0..<dm} - ds) &&&\n    p \\<in> grid (base ds p) ds", "by auto"], ["proof (state)\nthis:\n  base ds p \\<in> grid (start dm) ({0..<dm} - ds)\n  p \\<in> grid (base ds p) ds\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma baseI: assumes x_grid: \"x \\<in> grid (start dm) ({0..<dm} - ds)\" and p_xgrid: \"p \\<in> grid x ds\"\n  shows \"base ds p = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds p = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. base ds p = x", "have \"p \\<in> grid (start dm) (ds \\<union> ({0..<dm} - ds))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) (ds \\<union> ({0..<dm} - ds))", "using grid_transitive[OF p_xgrid x_grid, where ds''=\"ds \\<union> ({0..<dm} - ds)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<dm} - ds \\<subseteq> ds \\<union> ({0..<dm} - ds);\n   ds \\<subseteq> ds \\<union> ({0..<dm} - ds)\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid (start dm) (ds \\<union> ({0..<dm} - ds))\n\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) (ds \\<union> ({0..<dm} - ds))", "by auto"], ["proof (state)\nthis:\n  p \\<in> grid (start dm) (ds \\<union> ({0..<dm} - ds))\n\ngoal (1 subgoal):\n 1. base ds p = x", "moreover"], ["proof (state)\nthis:\n  p \\<in> grid (start dm) (ds \\<union> ({0..<dm} - ds))\n\ngoal (1 subgoal):\n 1. base ds p = x", "have \"ds \\<inter> ({0..<dm} - ds) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ds \\<inter> ({0..<dm} - ds) = {}", "by auto"], ["proof (state)\nthis:\n  ds \\<inter> ({0..<dm} - ds) = {}\n\ngoal (1 subgoal):\n 1. base ds p = x", "ultimately"], ["proof (chain)\npicking this:\n  p \\<in> grid (start dm) (ds \\<union> ({0..<dm} - ds))\n  ds \\<inter> ({0..<dm} - ds) = {}", "have \"\\<exists>! x \\<in> grid (start dm) ({0..<dm} - ds). p \\<in> grid x ds\""], ["proof (prove)\nusing this:\n  p \\<in> grid (start dm) (ds \\<union> ({0..<dm} - ds))\n  ds \\<inter> ({0..<dm} - ds) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds", "using grid_split1[where p=p and b=\"start dm\" and ds'=ds and ds=\"{0..<dm} - ds\"]"], ["proof (prove)\nusing this:\n  p \\<in> grid (start dm) (ds \\<union> ({0..<dm} - ds))\n  ds \\<inter> ({0..<dm} - ds) = {}\n  \\<lbrakk>p \\<in> grid (start dm) (ds \\<union> ({0..<dm} - ds));\n   ({0..<dm} - ds) \\<inter> ds = {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!x.\n                       x \\<in> grid (start dm) ({0..<dm} - ds) \\<and>\n                       p \\<in> grid x ds\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x.\n     x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n\ngoal (1 subgoal):\n 1. base ds p = x", "thus \"base ds p = x\""], ["proof (prove)\nusing this:\n  \\<exists>!x.\n     x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n\ngoal (1 subgoal):\n 1. base ds p = x", "using x_grid p_xgrid"], ["proof (prove)\nusing this:\n  \\<exists>!x.\n     x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n  x \\<in> grid (start dm) ({0..<dm} - ds)\n  p \\<in> grid x ds\n\ngoal (1 subgoal):\n 1. base ds p = x", "unfolding base_def"], ["proof (prove)\nusing this:\n  \\<exists>!x.\n     x \\<in> grid (start dm) ({0..<dm} - ds) \\<and> p \\<in> grid x ds\n  x \\<in> grid (start dm) ({0..<dm} - ds)\n  p \\<in> grid x ds\n\ngoal (1 subgoal):\n 1. (THE b.\n        b \\<in> grid (start (length p)) ({0..<length p} - ds) \\<and>\n        p \\<in> grid b ds) =\n    x", "by auto"], ["proof (state)\nthis:\n  base ds p = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_empty: assumes p_grid: \"p \\<in> sparsegrid' dm\" shows \"base {} p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base {} p = p", "using grid_empty_ds and p_grid and grid_split1[where ds=\"{0..<dm}\" and ds'=\"{}\"]"], ["proof (prove)\nusing this:\n  grid ?b {} = {?b}\n  p \\<in> sparsegrid' dm\n  \\<lbrakk>?p \\<in> grid ?b ({} \\<union> {0..<dm});\n   {0..<dm} \\<inter> {} = {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!x.\n                       x \\<in> grid ?b {0..<dm} \\<and> ?p \\<in> grid x {}\n\ngoal (1 subgoal):\n 1. base {} p = p", "unfolding base_def sparsegrid'_def"], ["proof (prove)\nusing this:\n  grid ?b {} = {?b}\n  p \\<in> grid (start dm) {0..<dm}\n  \\<lbrakk>?p \\<in> grid ?b ({} \\<union> {0..<dm});\n   {0..<dm} \\<inter> {} = {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!x.\n                       x \\<in> grid ?b {0..<dm} \\<and> ?p \\<in> grid x {}\n\ngoal (1 subgoal):\n 1. (THE b.\n        b \\<in> grid (start (length p)) ({0..<length p} - {}) \\<and>\n        p \\<in> grid b {}) =\n    p", "by auto"], ["", "lemma base_start_eq: assumes p_spg: \"p \\<in> sparsegrid dm lm\"\n  shows \"start dm = base {0..<dm} p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start dm = base {0..<dm} p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. start dm = base {0..<dm} p", "from p_spg"], ["proof (chain)\npicking this:\n  p \\<in> sparsegrid dm lm", "have \"start dm \\<in> grid (start dm) ({0..<dm} - {0..<dm})\"\n    and \"p \\<in> grid (start dm) {0..<dm}\""], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. start dm \\<in> grid (start dm) ({0..<dm} - {0..<dm}) &&&\n    p \\<in> grid (start dm) {0..<dm}", "using sparsegrid'_def"], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid dm lm\n  sparsegrid' ?dm = grid (start ?dm) {0..<?dm}\n\ngoal (1 subgoal):\n 1. start dm \\<in> grid (start dm) ({0..<dm} - {0..<dm}) &&&\n    p \\<in> grid (start dm) {0..<dm}", "by auto"], ["proof (state)\nthis:\n  start dm \\<in> grid (start dm) ({0..<dm} - {0..<dm})\n  p \\<in> grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. start dm = base {0..<dm} p", "from baseI[OF this(1) this(2)]"], ["proof (chain)\npicking this:\n  base {0..<dm} p = start dm", "show ?thesis"], ["proof (prove)\nusing this:\n  base {0..<dm} p = start dm\n\ngoal (1 subgoal):\n 1. start dm = base {0..<dm} p", "by auto"], ["proof (state)\nthis:\n  start dm = base {0..<dm} p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_in_grid: assumes p_grid: \"p \\<in> sparsegrid' dm\" shows \"base ds p \\<in> grid (start dm) {0..<dm}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) {0..<dm}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) {0..<dm}", "let ?ds = \"ds \\<union> {0..<dm}\""], ["proof (state)\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) {0..<dm}", "have ds_eq: \"{ d \\<in> ?ds. d < length (start dm) } = { 0..< dm}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {d \\<in> ds \\<union> {0..<dm}. d < length (start dm)} = {0..<dm}", "unfolding start_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {d \\<in> ds \\<union> {0..<dm}. d < length (replicate dm (0, 1))} =\n    {0..<dm}", "by auto"], ["proof (state)\nthis:\n  {d \\<in> ds \\<union> {0..<dm}. d < length (start dm)} = {0..<dm}\n\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) {0..<dm}", "have \"base ds p \\<in> grid (start dm) ?ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) (ds \\<union> {0..<dm})", "using grid_union_dims[OF _ baseE(1)[OF p_grid, where ds=ds], where ds'=\"?ds\"]"], ["proof (prove)\nusing this:\n  {0..<dm} - ds \\<subseteq> ds \\<union> {0..<dm} \\<Longrightarrow>\n  base ds p \\<in> grid (start dm) (ds \\<union> {0..<dm})\n\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) (ds \\<union> {0..<dm})", "by auto"], ["proof (state)\nthis:\n  base ds p \\<in> grid (start dm) (ds \\<union> {0..<dm})\n\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) {0..<dm}", "thus ?thesis"], ["proof (prove)\nusing this:\n  base ds p \\<in> grid (start dm) (ds \\<union> {0..<dm})\n\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) {0..<dm}", "using grid_dim_remove_outer[where b=\"start dm\" and ds=\"?ds\"]"], ["proof (prove)\nusing this:\n  base ds p \\<in> grid (start dm) (ds \\<union> {0..<dm})\n  grid (start dm) (ds \\<union> {0..<dm}) =\n  grid (start dm) {d \\<in> ds \\<union> {0..<dm}. d < length (start dm)}\n\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) {0..<dm}", "unfolding ds_eq"], ["proof (prove)\nusing this:\n  base ds p \\<in> grid (start dm) (ds \\<union> {0..<dm})\n  grid (start dm) (ds \\<union> {0..<dm}) = grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) {0..<dm}", "by auto"], ["proof (state)\nthis:\n  base ds p \\<in> grid (start dm) {0..<dm}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_grid: assumes p_grid: \"p \\<in> sparsegrid' dm\" shows \"grid (base ds p) ds \\<subseteq> sparsegrid' dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grid (base ds p) ds \\<subseteq> sparsegrid' dm", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grid (base ds p) ds \\<Longrightarrow> x \\<in> sparsegrid' dm", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grid (base ds p) ds \\<Longrightarrow> x \\<in> sparsegrid' dm", "assume xgrid: \"x \\<in> grid (base ds p) ds\""], ["proof (state)\nthis:\n  x \\<in> grid (base ds p) ds\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grid (base ds p) ds \\<Longrightarrow> x \\<in> sparsegrid' dm", "have ds_eq: \"{ d \\<in> {0..<dm} \\<union> ds. d < length (start dm) } = {0..<dm}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {d \\<in> {0..<dm} \\<union> ds. d < length (start dm)} = {0..<dm}", "by auto"], ["proof (state)\nthis:\n  {d \\<in> {0..<dm} \\<union> ds. d < length (start dm)} = {0..<dm}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> grid (base ds p) ds \\<Longrightarrow> x \\<in> sparsegrid' dm", "from grid_transitive[OF xgrid base_in_grid[OF p_grid], where ds''=\"{0..<dm} \\<union> ds\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>{0..<dm} \\<subseteq> {0..<dm} \\<union> ds;\n   ds \\<subseteq> {0..<dm} \\<union> ds\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (start dm) ({0..<dm} \\<union> ds)", "show \"x \\<in> sparsegrid' dm\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<dm} \\<subseteq> {0..<dm} \\<union> ds;\n   ds \\<subseteq> {0..<dm} \\<union> ds\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (start dm) ({0..<dm} \\<union> ds)\n\ngoal (1 subgoal):\n 1. x \\<in> sparsegrid' dm", "unfolding sparsegrid'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<dm} \\<subseteq> {0..<dm} \\<union> ds;\n   ds \\<subseteq> {0..<dm} \\<union> ds\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (start dm) ({0..<dm} \\<union> ds)\n\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm) {0..<dm}", "using grid_dim_remove_outer[where b=\"start dm\" and ds=\"{0..<dm} \\<union> ds\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<dm} \\<subseteq> {0..<dm} \\<union> ds;\n   ds \\<subseteq> {0..<dm} \\<union> ds\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (start dm) ({0..<dm} \\<union> ds)\n  grid (start dm) ({0..<dm} \\<union> ds) =\n  grid (start dm) {d \\<in> {0..<dm} \\<union> ds. d < length (start dm)}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm) {0..<dm}", "unfolding ds_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<dm} \\<subseteq> {0..<dm} \\<union> ds;\n   ds \\<subseteq> {0..<dm} \\<union> ds\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (start dm) ({0..<dm} \\<union> ds)\n  grid (start dm) ({0..<dm} \\<union> ds) = grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm) {0..<dm}", "unfolding Un_ac(3)[of \"{0..<dm}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<dm} \\<subseteq> ds \\<union> {0..<dm};\n   ds \\<subseteq> ds \\<union> {0..<dm}\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (start dm) (ds \\<union> {0..<dm})\n  grid (start dm) (ds \\<union> {0..<dm}) = grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm) {0..<dm}", "by auto"], ["proof (state)\nthis:\n  x \\<in> sparsegrid' dm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_length[simp]: assumes p_grid: \"p \\<in> sparsegrid' dm\" shows \"length (base ds p) = dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (base ds p) = dm", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (base ds p) = dm", "from baseE[OF p_grid]"], ["proof (chain)\npicking this:\n  base ?ds p \\<in> grid (start dm) ({0..<dm} - ?ds)\n  p \\<in> grid (base ?ds p) ?ds", "have \"base ds p \\<in> grid (start dm) ({0..<dm} - ds)\""], ["proof (prove)\nusing this:\n  base ?ds p \\<in> grid (start dm) ({0..<dm} - ?ds)\n  p \\<in> grid (base ?ds p) ?ds\n\ngoal (1 subgoal):\n 1. base ds p \\<in> grid (start dm) ({0..<dm} - ds)", "by auto"], ["proof (state)\nthis:\n  base ds p \\<in> grid (start dm) ({0..<dm} - ds)\n\ngoal (1 subgoal):\n 1. length (base ds p) = dm", "thus ?thesis"], ["proof (prove)\nusing this:\n  base ds p \\<in> grid (start dm) ({0..<dm} - ds)\n\ngoal (1 subgoal):\n 1. length (base ds p) = dm", "by auto"], ["proof (state)\nthis:\n  length (base ds p) = dm\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_in[simp]: assumes \"d < dm\" and \"d \\<in> ds\" and p_grid: \"p \\<in> sparsegrid' dm\" shows \"base ds p ! d = start dm ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds p ! d = start dm ! d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. base ds p ! d = start dm ! d", "have ds: \"d \\<notin> {0..<dm} - ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<notin> {0..<dm} - ds", "using \\<open>d \\<in> ds\\<close>"], ["proof (prove)\nusing this:\n  d \\<in> ds\n\ngoal (1 subgoal):\n 1. d \\<notin> {0..<dm} - ds", "by auto"], ["proof (state)\nthis:\n  d \\<notin> {0..<dm} - ds\n\ngoal (1 subgoal):\n 1. base ds p ! d = start dm ! d", "have \"d < length (start dm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length (start dm)", "using \\<open>d < dm\\<close>"], ["proof (prove)\nusing this:\n  d < dm\n\ngoal (1 subgoal):\n 1. d < length (start dm)", "by auto"], ["proof (state)\nthis:\n  d < length (start dm)\n\ngoal (1 subgoal):\n 1. base ds p ! d = start dm ! d", "with grid_invariant[OF this ds] baseE(1)[OF p_grid]"], ["proof (chain)\npicking this:\n  ?p \\<in> grid (start dm) ({0..<dm} - ds) \\<Longrightarrow>\n  ?p ! d = start dm ! d\n  base ?ds p \\<in> grid (start dm) ({0..<dm} - ?ds)\n  d < length (start dm)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?p \\<in> grid (start dm) ({0..<dm} - ds) \\<Longrightarrow>\n  ?p ! d = start dm ! d\n  base ?ds p \\<in> grid (start dm) ({0..<dm} - ?ds)\n  d < length (start dm)\n\ngoal (1 subgoal):\n 1. base ds p ! d = start dm ! d", "by auto"], ["proof (state)\nthis:\n  base ds p ! d = start dm ! d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_out[simp]: assumes \"d < dm\" and \"d \\<notin> ds\" and p_grid: \"p \\<in> sparsegrid' dm\" shows \"base ds p ! d = p ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds p ! d = p ! d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. base ds p ! d = p ! d", "have \"d < length (base ds p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length (base ds p)", "using base_length[OF p_grid] \\<open>d < dm\\<close>"], ["proof (prove)\nusing this:\n  length (base ?ds p) = dm\n  d < dm\n\ngoal (1 subgoal):\n 1. d < length (base ds p)", "by auto"], ["proof (state)\nthis:\n  d < length (base ds p)\n\ngoal (1 subgoal):\n 1. base ds p ! d = p ! d", "with grid_invariant[OF this \\<open>d \\<notin> ds\\<close>] baseE(2)[OF p_grid]"], ["proof (chain)\npicking this:\n  ?p \\<in> grid (base ds p) ds \\<Longrightarrow> ?p ! d = base ds p ! d\n  p \\<in> grid (base ?ds p) ?ds\n  d < length (base ds p)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?p \\<in> grid (base ds p) ds \\<Longrightarrow> ?p ! d = base ds p ! d\n  p \\<in> grid (base ?ds p) ?ds\n  d < length (base ds p)\n\ngoal (1 subgoal):\n 1. base ds p ! d = p ! d", "by auto"], ["proof (state)\nthis:\n  base ds p ! d = p ! d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_base: assumes p_grid: \"p \\<in> sparsegrid' dm\" shows \"base ds (base ds' p) = base (ds \\<union> ds') p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds (base ds' p) = base (ds \\<union> ds') p", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (base ds (base ds' p)) = length (base (ds \\<union> ds') p)\n 2. \\<And>i.\n       i < length (base ds (base ds' p)) \\<Longrightarrow>\n       base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "have b_spg: \"base ds' p \\<in> sparsegrid' dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds' p \\<in> sparsegrid' dm", "unfolding sparsegrid'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (start dm) {0..<dm}", "using grid_union_dims[OF Diff_subset[where A=\"{0..<dm}\" and B=\"ds'\"] baseE(1)[OF p_grid]]"], ["proof (prove)\nusing this:\n  base ds' p \\<in> grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (start dm) {0..<dm}", "."], ["proof (state)\nthis:\n  base ds' p \\<in> sparsegrid' dm\n\ngoal (2 subgoals):\n 1. length (base ds (base ds' p)) = length (base (ds \\<union> ds') p)\n 2. \\<And>i.\n       i < length (base ds (base ds' p)) \\<Longrightarrow>\n       base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "from base_length[OF b_spg] base_length[OF p_grid]"], ["proof (chain)\npicking this:\n  length (base ?ds (base ds' p)) = dm\n  length (base ?ds p) = dm", "show \"length (base ds (base ds' p)) = length (base (ds \\<union> ds') p)\""], ["proof (prove)\nusing this:\n  length (base ?ds (base ds' p)) = dm\n  length (base ?ds p) = dm\n\ngoal (1 subgoal):\n 1. length (base ds (base ds' p)) = length (base (ds \\<union> ds') p)", "by auto"], ["proof (state)\nthis:\n  length (base ds (base ds' p)) = length (base (ds \\<union> ds') p)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (base ds (base ds' p)) \\<Longrightarrow>\n       base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "show \"base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i\" if \"i < length (base ds (base ds' p))\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "have \"i < dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dm", "using that base_length[OF b_spg]"], ["proof (prove)\nusing this:\n  i < length (base ds (base ds' p))\n  length (base ?ds (base ds' p)) = dm\n\ngoal (1 subgoal):\n 1. i < dm", "by auto"], ["proof (state)\nthis:\n  i < dm\n\ngoal (1 subgoal):\n 1. base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "show \"base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "proof (cases \"i \\<in> ds \\<union> ds'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> ds \\<union> ds' \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i\n 2. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> ds \\<union> ds'\n\ngoal (2 subgoals):\n 1. i \\<in> ds \\<union> ds' \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i\n 2. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "proof (cases \"i \\<in> ds\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> ds \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i\n 2. i \\<notin> ds \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> ds\n\ngoal (2 subgoals):\n 1. i \\<in> ds \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i\n 2. i \\<notin> ds \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "from base_in[OF \\<open>i < dm\\<close> \\<open>i \\<in> ds \\<union> ds'\\<close> p_grid] base_in[OF \\<open>i < dm\\<close> this b_spg]"], ["proof (chain)\npicking this:\n  base (ds \\<union> ds') p ! i = start dm ! i\n  base ds (base ds' p) ! i = start dm ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  base (ds \\<union> ds') p ! i = start dm ! i\n  base ds (base ds' p) ! i = start dm ! i\n\ngoal (1 subgoal):\n 1. base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "by auto"], ["proof (state)\nthis:\n  base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i\n\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> ds\n\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "hence \"i \\<in> ds'\""], ["proof (prove)\nusing this:\n  i \\<notin> ds\n\ngoal (1 subgoal):\n 1. i \\<in> ds'", "using \\<open>i \\<in> ds \\<union> ds'\\<close>"], ["proof (prove)\nusing this:\n  i \\<notin> ds\n  i \\<in> ds \\<union> ds'\n\ngoal (1 subgoal):\n 1. i \\<in> ds'", "by auto"], ["proof (state)\nthis:\n  i \\<in> ds'\n\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "from base_in[OF \\<open>i < dm\\<close> \\<open>i \\<in> ds \\<union> ds'\\<close> p_grid] base_out[OF \\<open>i < dm\\<close> \\<open>i \\<notin> ds\\<close> b_spg] base_in[OF \\<open>i < dm\\<close> \\<open>i \\<in> ds'\\<close> p_grid]"], ["proof (chain)\npicking this:\n  base (ds \\<union> ds') p ! i = start dm ! i\n  base ds (base ds' p) ! i = base ds' p ! i\n  base ds' p ! i = start dm ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  base (ds \\<union> ds') p ! i = start dm ! i\n  base ds (base ds' p) ! i = base ds' p ! i\n  base ds' p ! i = start dm ! i\n\ngoal (1 subgoal):\n 1. base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "by auto"], ["proof (state)\nthis:\n  base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i\n\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> ds \\<union> ds'\n\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "hence \"i \\<notin> ds\" and \"i \\<notin> ds'\""], ["proof (prove)\nusing this:\n  i \\<notin> ds \\<union> ds'\n\ngoal (1 subgoal):\n 1. i \\<notin> ds &&& i \\<notin> ds'", "by auto"], ["proof (state)\nthis:\n  i \\<notin> ds\n  i \\<notin> ds'\n\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "from base_out[OF \\<open>i < dm\\<close> \\<open>i \\<notin> ds \\<union> ds'\\<close> p_grid] base_out[OF \\<open>i < dm\\<close> \\<open>i \\<notin> ds\\<close> b_spg] base_out[OF \\<open>i < dm\\<close> \\<open>i \\<notin> ds'\\<close> p_grid]"], ["proof (chain)\npicking this:\n  base (ds \\<union> ds') p ! i = p ! i\n  base ds (base ds' p) ! i = base ds' p ! i\n  base ds' p ! i = p ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  base (ds \\<union> ds') p ! i = p ! i\n  base ds (base ds' p) ! i = base ds' p ! i\n  base ds' p ! i = p ! i\n\ngoal (1 subgoal):\n 1. base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i", "by auto"], ["proof (state)\nthis:\n  base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  base ds (base ds' p) ! i = base (ds \\<union> ds') p ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length (base ds (base ds' p)) \\<Longrightarrow>\n  base ds (base ds' p) ! ?i = base (ds \\<union> ds') p ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_base_out: assumes \"d < dm\" and \"d \\<notin> ds\" and p_grid: \"b \\<in> sparsegrid' dm\" and \"p \\<in> grid (base ds b) ds\"\n  shows \"p ! d = b ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! d = b ! d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p ! d = b ! d", "have \"base ds b ! d = b ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds b ! d = b ! d", "using assms"], ["proof (prove)\nusing this:\n  d < dm\n  d \\<notin> ds\n  b \\<in> sparsegrid' dm\n  p \\<in> grid (base ds b) ds\n\ngoal (1 subgoal):\n 1. base ds b ! d = b ! d", "by auto"], ["proof (state)\nthis:\n  base ds b ! d = b ! d\n\ngoal (1 subgoal):\n 1. p ! d = b ! d", "moreover"], ["proof (state)\nthis:\n  base ds b ! d = b ! d\n\ngoal (1 subgoal):\n 1. p ! d = b ! d", "have \"d < length (base ds b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length (base ds b)", "using assms"], ["proof (prove)\nusing this:\n  d < dm\n  d \\<notin> ds\n  b \\<in> sparsegrid' dm\n  p \\<in> grid (base ds b) ds\n\ngoal (1 subgoal):\n 1. d < length (base ds b)", "by auto"], ["proof (state)\nthis:\n  d < length (base ds b)\n\ngoal (1 subgoal):\n 1. p ! d = b ! d", "from grid_invariant[OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>d \\<notin> ?ds; ?p \\<in> grid (base ds b) ?ds\\<rbrakk>\n  \\<Longrightarrow> ?p ! d = base ds b ! d", "have \"p ! d = base ds b ! d\""], ["proof (prove)\nusing this:\n  \\<lbrakk>d \\<notin> ?ds; ?p \\<in> grid (base ds b) ?ds\\<rbrakk>\n  \\<Longrightarrow> ?p ! d = base ds b ! d\n\ngoal (1 subgoal):\n 1. p ! d = base ds b ! d", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>d \\<notin> ?ds; ?p \\<in> grid (base ds b) ?ds\\<rbrakk>\n  \\<Longrightarrow> ?p ! d = base ds b ! d\n  d < dm\n  d \\<notin> ds\n  b \\<in> sparsegrid' dm\n  p \\<in> grid (base ds b) ds\n\ngoal (1 subgoal):\n 1. p ! d = base ds b ! d", "by auto"], ["proof (state)\nthis:\n  p ! d = base ds b ! d\n\ngoal (1 subgoal):\n 1. p ! d = b ! d", "ultimately"], ["proof (chain)\npicking this:\n  base ds b ! d = b ! d\n  p ! d = base ds b ! d", "show ?thesis"], ["proof (prove)\nusing this:\n  base ds b ! d = b ! d\n  p ! d = base ds b ! d\n\ngoal (1 subgoal):\n 1. p ! d = b ! d", "by auto"], ["proof (state)\nthis:\n  p ! d = b ! d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_grid_inj_on: assumes \"ds \\<inter> ds' = {}\" shows \"inj_on snd (\\<Union>p'\\<in>grid b ds. \\<Union>p''\\<in>grid p' ds'. {(p', p'')})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on snd\n     (\\<Union>p'\\<in>grid b ds. \\<Union>p''\\<in>grid p' ds'. {(p', p'')})", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>grid b ds.\n                            \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>grid b ds.\n                    \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>grid b ds.\n                            \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>grid b ds.\n                    \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> (\\<Union>p'\\<in>grid b ds. \\<Union>p''\\<in>grid p' ds'. {(p', p'')})\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>p'\\<in>grid b ds.\n              \\<Union>p''\\<in>grid p' ds'. {(p', p'')})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>grid b ds.\n                            \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>grid b ds.\n                    \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"snd x \\<in> grid (fst x) ds'\" and \"fst x \\<in> grid b ds\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>p'\\<in>grid b ds.\n              \\<Union>p''\\<in>grid p' ds'. {(p', p'')})\n\ngoal (1 subgoal):\n 1. snd x \\<in> grid (fst x) ds' &&& fst x \\<in> grid b ds", "by auto"], ["proof (state)\nthis:\n  snd x \\<in> grid (fst x) ds'\n  fst x \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>grid b ds.\n                            \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>grid b ds.\n                    \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"y \\<in> (\\<Union>p'\\<in>grid b ds. \\<Union>p''\\<in>grid p' ds'. {(p', p'')})\""], ["proof (state)\nthis:\n  y \\<in> (\\<Union>p'\\<in>grid b ds.\n              \\<Union>p''\\<in>grid p' ds'. {(p', p'')})\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>grid b ds.\n                            \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>grid b ds.\n                    \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"snd y \\<in> grid (fst y) ds'\" and \"fst y \\<in> grid b ds\""], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>p'\\<in>grid b ds.\n              \\<Union>p''\\<in>grid p' ds'. {(p', p'')})\n\ngoal (1 subgoal):\n 1. snd y \\<in> grid (fst y) ds' &&& fst y \\<in> grid b ds", "by auto"], ["proof (state)\nthis:\n  snd y \\<in> grid (fst y) ds'\n  fst y \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>grid b ds.\n                            \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>grid b ds.\n                    \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"snd x = snd y\""], ["proof (state)\nthis:\n  snd x = snd y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>grid b ds.\n                            \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>grid b ds.\n                    \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"fst x = fst y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x = fst y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. fst x \\<noteq> fst y \\<Longrightarrow> False", "assume \"fst x \\<noteq> fst y\""], ["proof (state)\nthis:\n  fst x \\<noteq> fst y\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> fst y \\<Longrightarrow> False", "from grid_disjunct'[OF \\<open>fst x \\<in> grid b ds\\<close> \\<open>fst y \\<in> grid b ds\\<close> \\<open>snd x \\<in> grid (fst x) ds'\\<close> this \\<open>ds \\<inter> ds' = {}\\<close>]"], ["proof (chain)\npicking this:\n  snd x \\<notin> grid (fst y) ds'", "show False"], ["proof (prove)\nusing this:\n  snd x \\<notin> grid (fst y) ds'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>snd y \\<in> grid (fst y) ds'\\<close>"], ["proof (prove)\nusing this:\n  snd x \\<notin> grid (fst y) ds'\n  snd y \\<in> grid (fst y) ds'\n\ngoal (1 subgoal):\n 1. False", "unfolding \\<open>snd x = snd y\\<close>"], ["proof (prove)\nusing this:\n  snd y \\<notin> grid (fst y) ds'\n  snd y \\<in> grid (fst y) ds'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst x = fst y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>p'\\<in>grid b ds.\n                            \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        y \\<in> (\\<Union>p'\\<in>grid b ds.\n                    \\<Union>p''\\<in>grid p' ds'. {(p', p'')});\n        snd x = snd y\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using prod_eqI[OF \\<open>fst x = fst y\\<close> \\<open>snd x = snd y\\<close>]"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y", "."], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_level_d: assumes \"d < length b\" and p_grid: \"p \\<in> grid b {d}\" and \"p \\<noteq> b\" shows \"lv p d > lv b d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv b d < lv p d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lv b d < lv p d", "from p_grid[unfolded grid_partition[where p=b]]"], ["proof (chain)\npicking this:\n  p \\<in> {b} \\<union> grid (child b left d) {d} \\<union>\n          grid (child b right d) {d}", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> {b} \\<union> grid (child b left d) {d} \\<union>\n          grid (child b right d) {d}\n\ngoal (1 subgoal):\n 1. lv b d < lv p d", "using grid_child_level"], ["proof (prove)\nusing this:\n  p \\<in> {b} \\<union> grid (child b left d) {d} \\<union>\n          grid (child b right d) {d}\n  \\<lbrakk>?d < length ?b; ?p \\<in> grid (child ?b ?dir ?d) ?ds\\<rbrakk>\n  \\<Longrightarrow> lv ?b ?d < lv ?p ?d\n\ngoal (1 subgoal):\n 1. lv b d < lv p d", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> {b} \\<union> grid (child b left d) {d} \\<union>\n          grid (child b right d) {d}\n  \\<lbrakk>?d < length ?b; ?p \\<in> grid (child ?b ?dir ?d) ?ds\\<rbrakk>\n  \\<Longrightarrow> lv ?b ?d < lv ?p ?d\n  d < length b\n  p \\<in> grid b {d}\n  p \\<noteq> b\n\ngoal (1 subgoal):\n 1. lv b d < lv p d", "by auto"], ["proof (state)\nthis:\n  lv b d < lv p d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_base_base: assumes \"b \\<in> sparsegrid' dm\"\n  shows \"base ds' b \\<in> grid (base ds (base ds' b)) (ds \\<union> ds')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds' b \\<in> grid (base ds (base ds' b)) (ds \\<union> ds')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. base ds' b \\<in> grid (base ds (base ds' b)) (ds \\<union> ds')", "from base_grid[OF \\<open>b \\<in> sparsegrid' dm\\<close>]"], ["proof (chain)\npicking this:\n  grid (base ?ds b) ?ds \\<subseteq> sparsegrid' dm", "have \"base ds' b \\<in> sparsegrid' dm\""], ["proof (prove)\nusing this:\n  grid (base ?ds b) ?ds \\<subseteq> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. base ds' b \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  base ds' b \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. base ds' b \\<in> grid (base ds (base ds' b)) (ds \\<union> ds')", "from grid_union_dims[OF _ baseE(2)[OF this], of ds \"ds \\<union> ds'\"]"], ["proof (chain)\npicking this:\n  ds \\<subseteq> ds \\<union> ds' \\<Longrightarrow>\n  base ds' b \\<in> grid (base ds (base ds' b)) (ds \\<union> ds')", "show ?thesis"], ["proof (prove)\nusing this:\n  ds \\<subseteq> ds \\<union> ds' \\<Longrightarrow>\n  base ds' b \\<in> grid (base ds (base ds' b)) (ds \\<union> ds')\n\ngoal (1 subgoal):\n 1. base ds' b \\<in> grid (base ds (base ds' b)) (ds \\<union> ds')", "by auto"], ["proof (state)\nthis:\n  base ds' b \\<in> grid (base ds (base ds' b)) (ds \\<union> ds')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_base_union: assumes b_spg: \"b \\<in> sparsegrid' dm\" and p_grid: \"p \\<in> grid (base ds b) ds\" and x_grid: \"x \\<in> grid (base ds' p) ds'\"\n  shows \"x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')", "have ds_union: \"ds \\<union> ds' = ds' \\<union> (ds \\<union> ds')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ds \\<union> ds' = ds' \\<union> (ds \\<union> ds')", "by auto"], ["proof (state)\nthis:\n  ds \\<union> ds' = ds' \\<union> (ds \\<union> ds')\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')", "from base_grid[OF b_spg] p_grid"], ["proof (chain)\npicking this:\n  grid (base ?ds b) ?ds \\<subseteq> sparsegrid' dm\n  p \\<in> grid (base ds b) ds", "have p_spg: \"p \\<in> sparsegrid' dm\""], ["proof (prove)\nusing this:\n  grid (base ?ds b) ?ds \\<subseteq> sparsegrid' dm\n  p \\<in> grid (base ds b) ds\n\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  p \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')", "with assms and grid_base_base"], ["proof (chain)\npicking this:\n  b \\<in> sparsegrid' dm\n  p \\<in> grid (base ds b) ds\n  x \\<in> grid (base ds' p) ds'\n  ?b \\<in> sparsegrid' ?dm \\<Longrightarrow>\n  base ?ds' ?b \\<in> grid (base ?ds (base ?ds' ?b)) (?ds \\<union> ?ds')\n  p \\<in> sparsegrid' dm", "have base_b': \"base ds' p \\<in> grid (base ds (base ds' p)) (ds \\<union> ds')\""], ["proof (prove)\nusing this:\n  b \\<in> sparsegrid' dm\n  p \\<in> grid (base ds b) ds\n  x \\<in> grid (base ds' p) ds'\n  ?b \\<in> sparsegrid' ?dm \\<Longrightarrow>\n  base ?ds' ?b \\<in> grid (base ?ds (base ?ds' ?b)) (?ds \\<union> ?ds')\n  p \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base ds (base ds' p)) (ds \\<union> ds')", "by auto"], ["proof (state)\nthis:\n  base ds' p \\<in> grid (base ds (base ds' p)) (ds \\<union> ds')\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')", "moreover"], ["proof (state)\nthis:\n  base ds' p \\<in> grid (base ds (base ds' p)) (ds \\<union> ds')\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')", "have \"base ds' (base ds b) = base ds' (base ds p)\" (is \"?b = ?p\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds' (base ds b) = base ds' (base ds p)", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (base ds' (base ds b)) = length (base ds' (base ds p))\n 2. \\<And>i.\n       i < length (base ds' (base ds b)) \\<Longrightarrow>\n       base ds' (base ds b) ! i = base ds' (base ds p) ! i", "have bb_spg: \"base ds b \\<in> sparsegrid' dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds b \\<in> sparsegrid' dm", "using base_grid[OF b_spg] grid.Start"], ["proof (prove)\nusing this:\n  grid (base ?ds b) ?ds \\<subseteq> sparsegrid' dm\n  ?b \\<in> grid ?b ?ds\n\ngoal (1 subgoal):\n 1. base ds b \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  base ds b \\<in> sparsegrid' dm\n\ngoal (2 subgoals):\n 1. length (base ds' (base ds b)) = length (base ds' (base ds p))\n 2. \\<And>i.\n       i < length (base ds' (base ds b)) \\<Longrightarrow>\n       base ds' (base ds b) ! i = base ds' (base ds p) ! i", "hence \"dm = length (base ds b)\""], ["proof (prove)\nusing this:\n  base ds b \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. dm = length (base ds b)", "by auto"], ["proof (state)\nthis:\n  dm = length (base ds b)\n\ngoal (2 subgoals):\n 1. length (base ds' (base ds b)) = length (base ds' (base ds p))\n 2. \\<And>i.\n       i < length (base ds' (base ds b)) \\<Longrightarrow>\n       base ds' (base ds b) ! i = base ds' (base ds p) ! i", "have bp_spg: \"base ds p \\<in> sparsegrid' dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds p \\<in> sparsegrid' dm", "using base_grid[OF p_spg] grid.Start"], ["proof (prove)\nusing this:\n  grid (base ?ds p) ?ds \\<subseteq> sparsegrid' dm\n  ?b \\<in> grid ?b ?ds\n\ngoal (1 subgoal):\n 1. base ds p \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  base ds p \\<in> sparsegrid' dm\n\ngoal (2 subgoals):\n 1. length (base ds' (base ds b)) = length (base ds' (base ds p))\n 2. \\<And>i.\n       i < length (base ds' (base ds b)) \\<Longrightarrow>\n       base ds' (base ds b) ! i = base ds' (base ds p) ! i", "show \"length ?b = length ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (base ds' (base ds b)) = length (base ds' (base ds p))", "using base_length[OF bp_spg] base_length[OF bb_spg]"], ["proof (prove)\nusing this:\n  length (base ?ds (base ds p)) = dm\n  length (base ?ds (base ds b)) = dm\n\ngoal (1 subgoal):\n 1. length (base ds' (base ds b)) = length (base ds' (base ds p))", "by auto"], ["proof (state)\nthis:\n  length (base ds' (base ds b)) = length (base ds' (base ds p))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (base ds' (base ds b)) \\<Longrightarrow>\n       base ds' (base ds b) ! i = base ds' (base ds p) ! i", "show \"?b ! i = ?p ! i\" if \"i < length ?b\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds' (base ds b) ! i = base ds' (base ds p) ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. base ds' (base ds b) ! i = base ds' (base ds p) ! i", "have \"i < dm\" and \"i < length (base ds b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dm &&& i < length (base ds b)", "using that base_length[OF bb_spg] \\<open>dm = length (base ds b)\\<close>"], ["proof (prove)\nusing this:\n  i < length (base ds' (base ds b))\n  length (base ?ds (base ds b)) = dm\n  dm = length (base ds b)\n\ngoal (1 subgoal):\n 1. i < dm &&& i < length (base ds b)", "by auto"], ["proof (state)\nthis:\n  i < dm\n  i < length (base ds b)\n\ngoal (1 subgoal):\n 1. base ds' (base ds b) ! i = base ds' (base ds p) ! i", "show \"?b ! i = ?p ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds' (base ds b) ! i = base ds' (base ds p) ! i", "proof (cases \"i \\<in> ds \\<union> ds'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> ds \\<union> ds' \\<Longrightarrow>\n    base ds' (base ds b) ! i = base ds' (base ds p) ! i\n 2. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds' (base ds b) ! i = base ds' (base ds p) ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> ds \\<union> ds'\n\ngoal (2 subgoals):\n 1. i \\<in> ds \\<union> ds' \\<Longrightarrow>\n    base ds' (base ds b) ! i = base ds' (base ds p) ! i\n 2. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds' (base ds b) ! i = base ds' (base ds p) ! i", "hence \"!! x. base ds x \\<in> sparsegrid' dm \\<Longrightarrow> x \\<in> sparsegrid' dm \\<Longrightarrow> base ds' (base ds x) ! i = (start dm) ! i\""], ["proof (prove)\nusing this:\n  i \\<in> ds \\<union> ds'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>base ds x \\<in> sparsegrid' dm;\n        x \\<in> sparsegrid' dm\\<rbrakk>\n       \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>base ds x \\<in> sparsegrid' dm; x \\<in> sparsegrid' dm;\n        i \\<in> ds \\<union> ds'\\<rbrakk>\n       \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>base ds x \\<in> sparsegrid' dm; x \\<in> sparsegrid' dm;\n        i \\<in> ds \\<union> ds'\\<rbrakk>\n       \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i", "assume x_spg: \"x \\<in> sparsegrid' dm\" and xb_spg: \"base ds x \\<in> sparsegrid' dm\""], ["proof (state)\nthis:\n  x \\<in> sparsegrid' dm\n  base ds x \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>base ds x \\<in> sparsegrid' dm; x \\<in> sparsegrid' dm;\n        i \\<in> ds \\<union> ds'\\<rbrakk>\n       \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i", "show \"base ds' (base ds x) ! i = (start dm) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds' (base ds x) ! i = start dm ! i", "proof (cases \"i \\<in> ds'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> ds' \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i\n 2. i \\<notin> ds' \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> ds'\n\ngoal (2 subgoals):\n 1. i \\<in> ds' \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i\n 2. i \\<notin> ds' \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i", "from base_in[OF \\<open>i < dm\\<close> this xb_spg]"], ["proof (chain)\npicking this:\n  base ds' (base ds x) ! i = start dm ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  base ds' (base ds x) ! i = start dm ! i\n\ngoal (1 subgoal):\n 1. base ds' (base ds x) ! i = start dm ! i", "."], ["proof (state)\nthis:\n  base ds' (base ds x) ! i = start dm ! i\n\ngoal (1 subgoal):\n 1. i \\<notin> ds' \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> ds' \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> ds'\n\ngoal (1 subgoal):\n 1. i \\<notin> ds' \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i", "hence \"i \\<in> ds\""], ["proof (prove)\nusing this:\n  i \\<notin> ds'\n\ngoal (1 subgoal):\n 1. i \\<in> ds", "using \\<open>i \\<in> ds \\<union> ds'\\<close>"], ["proof (prove)\nusing this:\n  i \\<notin> ds'\n  i \\<in> ds \\<union> ds'\n\ngoal (1 subgoal):\n 1. i \\<in> ds", "by auto"], ["proof (state)\nthis:\n  i \\<in> ds\n\ngoal (1 subgoal):\n 1. i \\<notin> ds' \\<Longrightarrow> base ds' (base ds x) ! i = start dm ! i", "from base_out[OF \\<open>i < dm\\<close> False xb_spg] base_in[OF \\<open>i < dm\\<close> this x_spg]"], ["proof (chain)\npicking this:\n  base ds' (base ds x) ! i = base ds x ! i\n  base ds x ! i = start dm ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  base ds' (base ds x) ! i = base ds x ! i\n  base ds x ! i = start dm ! i\n\ngoal (1 subgoal):\n 1. base ds' (base ds x) ! i = start dm ! i", "by auto"], ["proof (state)\nthis:\n  base ds' (base ds x) ! i = start dm ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  base ds' (base ds x) ! i = start dm ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>base ds ?x \\<in> sparsegrid' dm; ?x \\<in> sparsegrid' dm\\<rbrakk>\n  \\<Longrightarrow> base ds' (base ds ?x) ! i = start dm ! i\n\ngoal (2 subgoals):\n 1. i \\<in> ds \\<union> ds' \\<Longrightarrow>\n    base ds' (base ds b) ! i = base ds' (base ds p) ! i\n 2. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds' (base ds b) ! i = base ds' (base ds p) ! i", "from this[OF bp_spg p_spg] this[OF bb_spg b_spg]"], ["proof (chain)\npicking this:\n  base ds' (base ds p) ! i = start dm ! i\n  base ds' (base ds b) ! i = start dm ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  base ds' (base ds p) ! i = start dm ! i\n  base ds' (base ds b) ! i = start dm ! i\n\ngoal (1 subgoal):\n 1. base ds' (base ds b) ! i = base ds' (base ds p) ! i", "by auto"], ["proof (state)\nthis:\n  base ds' (base ds b) ! i = base ds' (base ds p) ! i\n\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds' (base ds b) ! i = base ds' (base ds p) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds' (base ds b) ! i = base ds' (base ds p) ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> ds \\<union> ds'\n\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds' (base ds b) ! i = base ds' (base ds p) ! i", "hence \"i \\<notin> ds\" and \"i \\<notin> ds'\""], ["proof (prove)\nusing this:\n  i \\<notin> ds \\<union> ds'\n\ngoal (1 subgoal):\n 1. i \\<notin> ds &&& i \\<notin> ds'", "by auto"], ["proof (state)\nthis:\n  i \\<notin> ds\n  i \\<notin> ds'\n\ngoal (1 subgoal):\n 1. i \\<notin> ds \\<union> ds' \\<Longrightarrow>\n    base ds' (base ds b) ! i = base ds' (base ds p) ! i", "from grid_invariant[OF \\<open>i < length (base ds b)\\<close> \\<open>i \\<notin> ds\\<close> p_grid]\n          base_out[OF \\<open>i < dm\\<close> \\<open>i \\<notin> ds'\\<close> bp_spg] base_out[OF \\<open>i < dm\\<close> \\<open>i \\<notin> ds\\<close> p_spg] base_out[OF \\<open>i < dm\\<close> \\<open>i \\<notin> ds'\\<close> bb_spg]"], ["proof (chain)\npicking this:\n  p ! i = base ds b ! i\n  base ds' (base ds p) ! i = base ds p ! i\n  base ds p ! i = p ! i\n  base ds' (base ds b) ! i = base ds b ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  p ! i = base ds b ! i\n  base ds' (base ds p) ! i = base ds p ! i\n  base ds p ! i = p ! i\n  base ds' (base ds b) ! i = base ds b ! i\n\ngoal (1 subgoal):\n 1. base ds' (base ds b) ! i = base ds' (base ds p) ! i", "by auto"], ["proof (state)\nthis:\n  base ds' (base ds b) ! i = base ds' (base ds p) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  base ds' (base ds b) ! i = base ds' (base ds p) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length (base ds' (base ds b)) \\<Longrightarrow>\n  base ds' (base ds b) ! ?i = base ds' (base ds p) ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  base ds' (base ds b) = base ds' (base ds p)\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')", "ultimately"], ["proof (chain)\npicking this:\n  base ds' p \\<in> grid (base ds (base ds' p)) (ds \\<union> ds')\n  base ds' (base ds b) = base ds' (base ds p)", "have \"base ds' p \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')\""], ["proof (prove)\nusing this:\n  base ds' p \\<in> grid (base ds (base ds' p)) (ds \\<union> ds')\n  base ds' (base ds b) = base ds' (base ds p)\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')", "by (simp only: base_base[OF p_spg] base_base[OF b_spg] Un_ac(3))"], ["proof (state)\nthis:\n  base ds' p \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')", "from grid_transitive[OF x_grid this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>ds \\<union> ds' \\<subseteq> ?ds''; ds' \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (base (ds \\<union> ds') b) ?ds''", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ds \\<union> ds' \\<subseteq> ?ds''; ds' \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (base (ds \\<union> ds') b) ?ds''\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')", "using ds_union"], ["proof (prove)\nusing this:\n  \\<lbrakk>ds \\<union> ds' \\<subseteq> ?ds''; ds' \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> x \\<in> grid (base (ds \\<union> ds') b) ?ds''\n  ds \\<union> ds' = ds' \\<union> (ds \\<union> ds')\n\ngoal (1 subgoal):\n 1. x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (base (ds \\<union> ds') b) (ds \\<union> ds')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_base_dim_add: assumes \"ds' \\<subseteq> ds\" and b_spg: \"b \\<in> sparsegrid' dm\" and p_grid: \"p \\<in> grid (base ds' b) ds'\"\n  shows \"p \\<in> grid (base ds b) ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> grid (base ds b) ds", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> grid (base ds b) ds", "have ds_eq: \"ds' \\<union> ds = ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ds' \\<union> ds = ds", "using assms"], ["proof (prove)\nusing this:\n  ds' \\<subseteq> ds\n  b \\<in> sparsegrid' dm\n  p \\<in> grid (base ds' b) ds'\n\ngoal (1 subgoal):\n 1. ds' \\<union> ds = ds", "by auto"], ["proof (state)\nthis:\n  ds' \\<union> ds = ds\n\ngoal (1 subgoal):\n 1. p \\<in> grid (base ds b) ds", "have \"p \\<in> sparsegrid' dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid' dm", "using base_grid[OF b_spg] p_grid"], ["proof (prove)\nusing this:\n  grid (base ?ds b) ?ds \\<subseteq> sparsegrid' dm\n  p \\<in> grid (base ds' b) ds'\n\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  p \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. p \\<in> grid (base ds b) ds", "hence \"p \\<in> grid (base ds p) ds\""], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. p \\<in> grid (base ds p) ds", "using baseE"], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid' dm\n  ?p \\<in> sparsegrid' ?dm \\<Longrightarrow>\n  base ?ds ?p \\<in> grid (start ?dm) ({0..<?dm} - ?ds)\n  ?p \\<in> sparsegrid' ?dm \\<Longrightarrow> ?p \\<in> grid (base ?ds ?p) ?ds\n\ngoal (1 subgoal):\n 1. p \\<in> grid (base ds p) ds", "by auto"], ["proof (state)\nthis:\n  p \\<in> grid (base ds p) ds\n\ngoal (1 subgoal):\n 1. p \\<in> grid (base ds b) ds", "from grid_base_union[OF b_spg p_grid this]"], ["proof (chain)\npicking this:\n  p \\<in> grid (base (ds' \\<union> ds) b) (ds' \\<union> ds)", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> grid (base (ds' \\<union> ds) b) (ds' \\<union> ds)\n\ngoal (1 subgoal):\n 1. p \\<in> grid (base ds b) ds", "using ds_eq"], ["proof (prove)\nusing this:\n  p \\<in> grid (base (ds' \\<union> ds) b) (ds' \\<union> ds)\n  ds' \\<union> ds = ds\n\ngoal (1 subgoal):\n 1. p \\<in> grid (base ds b) ds", "by auto"], ["proof (state)\nthis:\n  p \\<in> grid (base ds b) ds\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_replace_dim: assumes \"d < length b'\" and \"d < length b\" and p_grid: \"p \\<in> grid b ds\" and p'_grid: \"p' \\<in> grid b' ds\"\n  shows \"p[d := p' ! d] \\<in> grid (b[d := b' ! d]) ds\" (is \"_ \\<in> grid ?b ds\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. p[d := p' ! d] \\<in> grid (b[d := b' ! d]) ds", "using p'_grid and p_grid"], ["proof (prove)\nusing this:\n  p' \\<in> grid b' ds\n  p \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. p[d := p' ! d] \\<in> grid (b[d := b' ! d]) ds", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<in> grid b ds \\<Longrightarrow>\n    p[d := b' ! d] \\<in> grid (b[d := b' ! d]) ds\n 2. \\<And>pa da dir.\n       \\<lbrakk>pa \\<in> grid b' ds;\n        p \\<in> grid b ds \\<Longrightarrow>\n        p[d := pa ! d] \\<in> grid (b[d := b' ! d]) ds;\n        da \\<in> ds; p \\<in> grid b ds\\<rbrakk>\n       \\<Longrightarrow> p[d := child pa dir da ! d]\n                         \\<in> grid (b[d := b' ! d]) ds", "case (Child p'' d' dir)"], ["proof (state)\nthis:\n  p'' \\<in> grid b' ds\n  p \\<in> grid b ds \\<Longrightarrow>\n  p[d := p'' ! d] \\<in> grid (b[d := b' ! d]) ds\n  d' \\<in> ds\n  p \\<in> grid b ds\n\ngoal (2 subgoals):\n 1. p \\<in> grid b ds \\<Longrightarrow>\n    p[d := b' ! d] \\<in> grid (b[d := b' ! d]) ds\n 2. \\<And>pa da dir.\n       \\<lbrakk>pa \\<in> grid b' ds;\n        p \\<in> grid b ds \\<Longrightarrow>\n        p[d := pa ! d] \\<in> grid (b[d := b' ! d]) ds;\n        da \\<in> ds; p \\<in> grid b ds\\<rbrakk>\n       \\<Longrightarrow> p[d := child pa dir da ! d]\n                         \\<in> grid (b[d := b' ! d]) ds", "hence p''_grid: \"p[d := p'' ! d] \\<in> grid ?b ds\" and \"d < length p''\""], ["proof (prove)\nusing this:\n  p'' \\<in> grid b' ds\n  p \\<in> grid b ds \\<Longrightarrow>\n  p[d := p'' ! d] \\<in> grid (b[d := b' ! d]) ds\n  d' \\<in> ds\n  p \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. p[d := p'' ! d] \\<in> grid (b[d := b' ! d]) ds &&& d < length p''", "using assms"], ["proof (prove)\nusing this:\n  p'' \\<in> grid b' ds\n  p \\<in> grid b ds \\<Longrightarrow>\n  p[d := p'' ! d] \\<in> grid (b[d := b' ! d]) ds\n  d' \\<in> ds\n  p \\<in> grid b ds\n  d < length b'\n  d < length b\n  p \\<in> grid b ds\n  p' \\<in> grid b' ds\n\ngoal (1 subgoal):\n 1. p[d := p'' ! d] \\<in> grid (b[d := b' ! d]) ds &&& d < length p''", "by auto"], ["proof (state)\nthis:\n  p[d := p'' ! d] \\<in> grid (b[d := b' ! d]) ds\n  d < length p''\n\ngoal (2 subgoals):\n 1. p \\<in> grid b ds \\<Longrightarrow>\n    p[d := b' ! d] \\<in> grid (b[d := b' ! d]) ds\n 2. \\<And>pa da dir.\n       \\<lbrakk>pa \\<in> grid b' ds;\n        p \\<in> grid b ds \\<Longrightarrow>\n        p[d := pa ! d] \\<in> grid (b[d := b' ! d]) ds;\n        da \\<in> ds; p \\<in> grid b ds\\<rbrakk>\n       \\<Longrightarrow> p[d := child pa dir da ! d]\n                         \\<in> grid (b[d := b' ! d]) ds", "have \"d < length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length p", "using p_grid assms"], ["proof (prove)\nusing this:\n  p \\<in> grid b ds\n  d < length b'\n  d < length b\n  p \\<in> grid b ds\n  p' \\<in> grid b' ds\n\ngoal (1 subgoal):\n 1. d < length p", "by auto"], ["proof (state)\nthis:\n  d < length p\n\ngoal (2 subgoals):\n 1. p \\<in> grid b ds \\<Longrightarrow>\n    p[d := b' ! d] \\<in> grid (b[d := b' ! d]) ds\n 2. \\<And>pa da dir.\n       \\<lbrakk>pa \\<in> grid b' ds;\n        p \\<in> grid b ds \\<Longrightarrow>\n        p[d := pa ! d] \\<in> grid (b[d := b' ! d]) ds;\n        da \\<in> ds; p \\<in> grid b ds\\<rbrakk>\n       \\<Longrightarrow> p[d := child pa dir da ! d]\n                         \\<in> grid (b[d := b' ! d]) ds", "thus ?case"], ["proof (prove)\nusing this:\n  d < length p\n\ngoal (1 subgoal):\n 1. p[d := child p'' dir d' ! d] \\<in> grid (b[d := b' ! d]) ds", "proof (cases \"d' = d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>d < length p; d' = d\\<rbrakk>\n    \\<Longrightarrow> p[d := child p'' dir d' ! d]\n                      \\<in> grid (b[d := b' ! d]) ds\n 2. \\<lbrakk>d < length p; d' \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> p[d := child p'' dir d' ! d]\n                      \\<in> grid (b[d := b' ! d]) ds", "case True"], ["proof (state)\nthis:\n  d' = d\n\ngoal (2 subgoals):\n 1. \\<lbrakk>d < length p; d' = d\\<rbrakk>\n    \\<Longrightarrow> p[d := child p'' dir d' ! d]\n                      \\<in> grid (b[d := b' ! d]) ds\n 2. \\<lbrakk>d < length p; d' \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> p[d := child p'' dir d' ! d]\n                      \\<in> grid (b[d := b' ! d]) ds", "from grid.Child[OF p''_grid \\<open>d' \\<in> ds\\<close>]"], ["proof (chain)\npicking this:\n  child (p[d := p'' ! d]) ?dir d' \\<in> grid (b[d := b' ! d]) ds", "show ?thesis"], ["proof (prove)\nusing this:\n  child (p[d := p'' ! d]) ?dir d' \\<in> grid (b[d := b' ! d]) ds\n\ngoal (1 subgoal):\n 1. p[d := child p'' dir d' ! d] \\<in> grid (b[d := b' ! d]) ds", "unfolding child_def ix_def lv_def list_update_overwrite \\<open>d' = d\\<close> nth_list_update_eq[OF \\<open>d < length p''\\<close>] nth_list_update_eq[OF \\<open>d < length p\\<close>]"], ["proof (prove)\nusing this:\n  p[d := (fst (p'' ! d) + 1, 2 * snd (p'' ! d) + Grid_Point.sgn ?dir)]\n  \\<in> grid (b[d := b' ! d]) ds\n\ngoal (1 subgoal):\n 1. p[d := (fst (p'' ! d) + 1, 2 * snd (p'' ! d) + Grid_Point.sgn dir)]\n    \\<in> grid (b[d := b' ! d]) ds", "."], ["proof (state)\nthis:\n  p[d := child p'' dir d' ! d] \\<in> grid (b[d := b' ! d]) ds\n\ngoal (1 subgoal):\n 1. \\<lbrakk>d < length p; d' \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> p[d := child p'' dir d' ! d]\n                      \\<in> grid (b[d := b' ! d]) ds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>d < length p; d' \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> p[d := child p'' dir d' ! d]\n                      \\<in> grid (b[d := b' ! d]) ds", "case False"], ["proof (state)\nthis:\n  d' \\<noteq> d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>d < length p; d' \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> p[d := child p'' dir d' ! d]\n                      \\<in> grid (b[d := b' ! d]) ds", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p[d := child p'' dir d' ! d] \\<in> grid (b[d := b' ! d]) ds", "unfolding child_def nth_list_update_neq[OF False]"], ["proof (prove)\ngoal (1 subgoal):\n 1. p[d := p'' ! d] \\<in> grid (b[d := b' ! d]) ds", "using Child"], ["proof (prove)\nusing this:\n  p'' \\<in> grid b' ds\n  p \\<in> grid b ds \\<Longrightarrow>\n  p[d := p'' ! d] \\<in> grid (b[d := b' ! d]) ds\n  d' \\<in> ds\n  p \\<in> grid b ds\n\ngoal (1 subgoal):\n 1. p[d := p'' ! d] \\<in> grid (b[d := b' ! d]) ds", "by auto"], ["proof (state)\nthis:\n  p[d := child p'' dir d' ! d] \\<in> grid (b[d := b' ! d]) ds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p[d := child p'' dir d' ! d] \\<in> grid (b[d := b' ! d]) ds\n\ngoal (1 subgoal):\n 1. p \\<in> grid b ds \\<Longrightarrow>\n    p[d := b' ! d] \\<in> grid (b[d := b' ! d]) ds", "qed (rule grid_change_dim)"], ["", "lemma grid_shift_base:\n  assumes ds_dj: \"ds \\<inter> ds' = {}\" and b_spg: \"b \\<in> sparsegrid' dm\" and p_grid: \"p \\<in> grid (base (ds' \\<union> ds) b) (ds' \\<union> ds)\"\n  shows \"base ds' p \\<in> grid (base (ds \\<union> ds') b) ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "from grid_split[OF p_grid]"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>grid (base (ds' \\<union> ds) b) ds. p \\<in> grid x ds'", "obtain x where x_grid: \"x \\<in> grid (base (ds' \\<union> ds) b) ds\" and p_xgrid: \"p \\<in> grid x ds'\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>grid (base (ds' \\<union> ds) b) ds. p \\<in> grid x ds'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> grid (base (ds' \\<union> ds) b) ds;\n         p \\<in> grid x ds'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (base (ds' \\<union> ds) b) ds\n  p \\<in> grid x ds'\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "from grid_union_dims[OF _ this(1)]"], ["proof (chain)\npicking this:\n  ds \\<subseteq> ?ds' \\<Longrightarrow>\n  x \\<in> grid (base (ds' \\<union> ds) b) ?ds'", "have x_spg: \"x \\<in> sparsegrid' dm\""], ["proof (prove)\nusing this:\n  ds \\<subseteq> ?ds' \\<Longrightarrow>\n  x \\<in> grid (base (ds' \\<union> ds) b) ?ds'\n\ngoal (1 subgoal):\n 1. x \\<in> sparsegrid' dm", "using base_grid[OF b_spg]"], ["proof (prove)\nusing this:\n  ds \\<subseteq> ?ds' \\<Longrightarrow>\n  x \\<in> grid (base (ds' \\<union> ds) b) ?ds'\n  grid (base ?ds b) ?ds \\<subseteq> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. x \\<in> sparsegrid' dm", "by auto"], ["proof (state)\nthis:\n  x \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "have b_len: \"length (base (ds' \\<union> ds) b) = dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (base (ds' \\<union> ds) b) = dm", "using base_length[OF b_spg]"], ["proof (prove)\nusing this:\n  length (base ?ds b) = dm\n\ngoal (1 subgoal):\n 1. length (base (ds' \\<union> ds) b) = dm", "by auto"], ["proof (state)\nthis:\n  length (base (ds' \\<union> ds) b) = dm\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "define d' where \"d' = dm\""], ["proof (state)\nthis:\n  d' = dm\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "moreover"], ["proof (state)\nthis:\n  d' = dm\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "have \"d' \\<le> dm \\<Longrightarrow> x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d' \\<le> dm \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'})", "proof (induct d')"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> dm \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < 0})\n 2. \\<And>d'.\n       \\<lbrakk>d' \\<le> dm \\<Longrightarrow>\n                x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'});\n        Suc d' \\<le> dm\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (start dm)\n                                  ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "case (Suc d')"], ["proof (state)\nthis:\n  d' \\<le> dm \\<Longrightarrow>\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'})\n  Suc d' \\<le> dm\n\ngoal (2 subgoals):\n 1. 0 \\<le> dm \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < 0})\n 2. \\<And>d'.\n       \\<lbrakk>d' \\<le> dm \\<Longrightarrow>\n                x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'});\n        Suc d' \\<le> dm\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (start dm)\n                                  ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "with b_len"], ["proof (chain)\npicking this:\n  length (base (ds' \\<union> ds) b) = dm\n  d' \\<le> dm \\<Longrightarrow>\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'})\n  Suc d' \\<le> dm", "have d'_b: \"d' < length (base (ds' \\<union> ds) b)\""], ["proof (prove)\nusing this:\n  length (base (ds' \\<union> ds) b) = dm\n  d' \\<le> dm \\<Longrightarrow>\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'})\n  Suc d' \\<le> dm\n\ngoal (1 subgoal):\n 1. d' < length (base (ds' \\<union> ds) b)", "by auto"], ["proof (state)\nthis:\n  d' < length (base (ds' \\<union> ds) b)\n\ngoal (2 subgoals):\n 1. 0 \\<le> dm \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < 0})\n 2. \\<And>d'.\n       \\<lbrakk>d' \\<le> dm \\<Longrightarrow>\n                x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'});\n        Suc d' \\<le> dm\\<rbrakk>\n       \\<Longrightarrow> x \\<in> grid (start dm)\n                                  ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "proof (cases \"d' \\<in> ds'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d' \\<in> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n 2. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "case True"], ["proof (state)\nthis:\n  d' \\<in> ds'\n\ngoal (2 subgoals):\n 1. d' \\<in> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n 2. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "hence \"d' \\<notin> ds\" and \"d' \\<in> ds' \\<union> ds\""], ["proof (prove)\nusing this:\n  d' \\<in> ds'\n\ngoal (1 subgoal):\n 1. d' \\<notin> ds &&& d' \\<in> ds' \\<union> ds", "using ds_dj"], ["proof (prove)\nusing this:\n  d' \\<in> ds'\n  ds \\<inter> ds' = {}\n\ngoal (1 subgoal):\n 1. d' \\<notin> ds &&& d' \\<in> ds' \\<union> ds", "by auto"], ["proof (state)\nthis:\n  d' \\<notin> ds\n  d' \\<in> ds' \\<union> ds\n\ngoal (2 subgoals):\n 1. d' \\<in> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n 2. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "have \"{0..<dm} - {d \\<in> ds'. d < d'} = ({0..<dm} - {d \\<in> ds'. d < d'}) - {d'} \\<union> {d'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<dm} - {d \\<in> ds'. d < d'} =\n    {0..<dm} - {d \\<in> ds'. d < d'} - {d'} \\<union> {d'}", "using \\<open>Suc d' \\<le> dm\\<close>"], ["proof (prove)\nusing this:\n  Suc d' \\<le> dm\n\ngoal (1 subgoal):\n 1. {0..<dm} - {d \\<in> ds'. d < d'} =\n    {0..<dm} - {d \\<in> ds'. d < d'} - {d'} \\<union> {d'}", "by auto"], ["proof (state)\nthis:\n  {0..<dm} - {d \\<in> ds'. d < d'} =\n  {0..<dm} - {d \\<in> ds'. d < d'} - {d'} \\<union> {d'}\n\ngoal (2 subgoals):\n 1. d' \\<in> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n 2. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "also"], ["proof (state)\nthis:\n  {0..<dm} - {d \\<in> ds'. d < d'} =\n  {0..<dm} - {d \\<in> ds'. d < d'} - {d'} \\<union> {d'}\n\ngoal (2 subgoals):\n 1. d' \\<in> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n 2. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "have \"\\<dots> = ({0..<dm} - {d \\<in> ds'. d < Suc d'}) \\<union> {d'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<dm} - {d \\<in> ds'. d < d'} - {d'} \\<union> {d'} =\n    {0..<dm} - {d \\<in> ds'. d < Suc d'} \\<union> {d'}", "by auto"], ["proof (state)\nthis:\n  {0..<dm} - {d \\<in> ds'. d < d'} - {d'} \\<union> {d'} =\n  {0..<dm} - {d \\<in> ds'. d < Suc d'} \\<union> {d'}\n\ngoal (2 subgoals):\n 1. d' \\<in> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n 2. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "finally"], ["proof (chain)\npicking this:\n  {0..<dm} - {d \\<in> ds'. d < d'} =\n  {0..<dm} - {d \\<in> ds'. d < Suc d'} \\<union> {d'}", "have x_g: \"x \\<in> grid (start dm) ({d'} \\<union> ({0..<dm} - {d \\<in> ds'. d < Suc d'}))\""], ["proof (prove)\nusing this:\n  {0..<dm} - {d \\<in> ds'. d < d'} =\n  {0..<dm} - {d \\<in> ds'. d < Suc d'} \\<union> {d'}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm)\n             ({d'} \\<union> ({0..<dm} - {d \\<in> ds'. d < Suc d'}))", "using Suc"], ["proof (prove)\nusing this:\n  {0..<dm} - {d \\<in> ds'. d < d'} =\n  {0..<dm} - {d \\<in> ds'. d < Suc d'} \\<union> {d'}\n  d' \\<le> dm \\<Longrightarrow>\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'})\n  Suc d' \\<le> dm\n\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm)\n             ({d'} \\<union> ({0..<dm} - {d \\<in> ds'. d < Suc d'}))", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (start dm)\n           ({d'} \\<union> ({0..<dm} - {d \\<in> ds'. d < Suc d'}))\n\ngoal (2 subgoals):\n 1. d' \\<in> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n 2. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "from grid_invariant[OF d'_b \\<open>d' \\<notin> ds\\<close> x_grid] base_in[OF _ \\<open>d' \\<in> ds' \\<union> ds\\<close> b_spg] \\<open>Suc d' \\<le> dm\\<close>"], ["proof (chain)\npicking this:\n  x ! d' = base (ds' \\<union> ds) b ! d'\n  d' < dm \\<Longrightarrow> base (ds' \\<union> ds) b ! d' = start dm ! d'\n  Suc d' \\<le> dm", "have \"x ! d' = start dm ! d'\""], ["proof (prove)\nusing this:\n  x ! d' = base (ds' \\<union> ds) b ! d'\n  d' < dm \\<Longrightarrow> base (ds' \\<union> ds) b ! d' = start dm ! d'\n  Suc d' \\<le> dm\n\ngoal (1 subgoal):\n 1. x ! d' = start dm ! d'", "by auto"], ["proof (state)\nthis:\n  x ! d' = start dm ! d'\n\ngoal (2 subgoals):\n 1. d' \\<in> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n 2. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "from grid_dim_remove[OF x_g this]"], ["proof (chain)\npicking this:\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "."], ["proof (state)\nthis:\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n\ngoal (1 subgoal):\n 1. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "case False"], ["proof (state)\nthis:\n  d' \\<notin> ds'\n\ngoal (1 subgoal):\n 1. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "hence \"{d \\<in> ds'. d < Suc d'} = {d \\<in> ds'. d < d' \\<or> d = d'}\""], ["proof (prove)\nusing this:\n  d' \\<notin> ds'\n\ngoal (1 subgoal):\n 1. {d \\<in> ds'. d < Suc d'} = {d \\<in> ds'. d < d' \\<or> d = d'}", "by auto"], ["proof (state)\nthis:\n  {d \\<in> ds'. d < Suc d'} = {d \\<in> ds'. d < d' \\<or> d = d'}\n\ngoal (1 subgoal):\n 1. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "also"], ["proof (state)\nthis:\n  {d \\<in> ds'. d < Suc d'} = {d \\<in> ds'. d < d' \\<or> d = d'}\n\ngoal (1 subgoal):\n 1. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "have \"\\<dots> = {d \\<in> ds'. d < d'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {d \\<in> ds'. d < d' \\<or> d = d'} = {d \\<in> ds'. d < d'}", "using False"], ["proof (prove)\nusing this:\n  d' \\<notin> ds'\n\ngoal (1 subgoal):\n 1. {d \\<in> ds'. d < d' \\<or> d = d'} = {d \\<in> ds'. d < d'}", "by auto"], ["proof (state)\nthis:\n  {d \\<in> ds'. d < d' \\<or> d = d'} = {d \\<in> ds'. d < d'}\n\ngoal (1 subgoal):\n 1. d' \\<notin> ds' \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "finally"], ["proof (chain)\npicking this:\n  {d \\<in> ds'. d < Suc d'} = {d \\<in> ds'. d < d'}", "show ?thesis"], ["proof (prove)\nusing this:\n  {d \\<in> ds'. d < Suc d'} = {d \\<in> ds'. d < d'}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "using Suc"], ["proof (prove)\nusing this:\n  {d \\<in> ds'. d < Suc d'} = {d \\<in> ds'. d < d'}\n  d' \\<le> dm \\<Longrightarrow>\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'})\n  Suc d' \\<le> dm\n\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < Suc d'})\n\ngoal (1 subgoal):\n 1. 0 \\<le> dm \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < 0})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> dm \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < 0})", "case 0"], ["proof (state)\nthis:\n  0 \\<le> dm\n\ngoal (1 subgoal):\n 1. 0 \\<le> dm \\<Longrightarrow>\n    x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < 0})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < 0})", "using x_spg[unfolded sparsegrid'_def]"], ["proof (prove)\nusing this:\n  x \\<in> grid (start dm) {0..<dm}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < 0})", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < 0})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d' \\<le> dm \\<Longrightarrow>\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'})\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "moreover"], ["proof (state)\nthis:\n  d' \\<le> dm \\<Longrightarrow>\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'})\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "have \"{0..<dm} - ds' = {0..<dm} - {d \\<in> ds'. d < dm}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<dm} - ds' = {0..<dm} - {d \\<in> ds'. d < dm}", "by auto"], ["proof (state)\nthis:\n  {0..<dm} - ds' = {0..<dm} - {d \\<in> ds'. d < dm}\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "ultimately"], ["proof (chain)\npicking this:\n  d' = dm\n  d' \\<le> dm \\<Longrightarrow>\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'})\n  {0..<dm} - ds' = {0..<dm} - {d \\<in> ds'. d < dm}", "have \"x \\<in> grid (start dm) ({0..<dm} - ds')\""], ["proof (prove)\nusing this:\n  d' = dm\n  d' \\<le> dm \\<Longrightarrow>\n  x \\<in> grid (start dm) ({0..<dm} - {d \\<in> ds'. d < d'})\n  {0..<dm} - ds' = {0..<dm} - {d \\<in> ds'. d < dm}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (start dm) ({0..<dm} - ds')", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (start dm) ({0..<dm} - ds')\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "from baseI[OF this p_xgrid] and x_grid"], ["proof (chain)\npicking this:\n  base ds' p = x\n  x \\<in> grid (base (ds' \\<union> ds) b) ds", "show ?thesis"], ["proof (prove)\nusing this:\n  base ds' p = x\n  x \\<in> grid (base (ds' \\<union> ds) b) ds\n\ngoal (1 subgoal):\n 1. base ds' p \\<in> grid (base (ds \\<union> ds') b) ds", "by (auto simp: Un_ac(3))"], ["proof (state)\nthis:\n  base ds' p \\<in> grid (base (ds \\<union> ds') b) ds\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Lift Operation over all Grid Points \\<close>"], ["", "definition lift :: \"(nat \\<Rightarrow> nat \\<Rightarrow> grid_point \\<Rightarrow> vector \\<Rightarrow> vector) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> vector \\<Rightarrow> vector\"\nwhere \"lift f dm lm d = foldr (\\<lambda> p. f d (lm - level p) p) (gridgen (start dm) ({ 0 ..< dm } - { d }) lm)\""], ["", "lemma lift:\n  assumes \"d < dm\" and \"p \\<in> sparsegrid dm lm\"\n  and Fintro: \"\\<And> l b p \\<alpha>. \\<lbrakk> b \\<in> lgrid (start dm) ({0..<dm} - {d}) lm ;\n                          l + level b = lm ; p \\<in> sparsegrid dm lm \\<rbrakk>\n             \\<Longrightarrow> F d l b \\<alpha> p = (if b = base {d} p\n                               then (\\<Sum> p' \\<in> lgrid b {d} lm. S (\\<alpha> p') p p')\n                               else \\<alpha> p)\"\n  shows \"lift F dm lm d \\<alpha> p = (\\<Sum> p' \\<in> lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')\"\n        (is \"?lift = ?S p \\<alpha>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "let ?gridgen = \"gridgen (start dm) ({0..<dm} - {d}) lm\""], ["proof (state)\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "let \"?f p\" = \"F d (lm - level p) p\""], ["proof (state)\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "fix bs \\<beta> b"], ["proof (state)\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "assume \"set bs \\<subseteq> set ?gridgen\" and \"distinct bs\" and \"p \\<in> sparsegrid dm lm\""], ["proof (state)\nthis:\n  set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct bs\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "hence \"foldr ?f bs \\<beta> p = (if base {d} p \\<in> set bs then ?S p \\<beta> else \\<beta> p)\""], ["proof (prove)\nusing this:\n  set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct bs\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n    (if base {d} p \\<in> set bs\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "proof (induct bs arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>set []\n                \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n        distinct []; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) [] \\<beta>\n                          p =\n                         (if base {d} p \\<in> set []\n                          then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                                 S (\\<beta> p') p p'\n                          else \\<beta> p)\n 2. \\<And>a bs p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>set bs\n                            \\<subseteq> set\n   (gridgen (start dm) ({0..<dm} - {d}) lm);\n                    distinct bs; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> foldr\n(\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n                                     (if base {d} p \\<in> set bs\nthen \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\nelse \\<beta> p);\n        set (a # bs)\n        \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n        distinct (a # bs); p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) (a # bs)\n                          \\<beta> p =\n                         (if base {d} p \\<in> set (a # bs)\n                          then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                                 S (\\<beta> p') p p'\n                          else \\<beta> p)", "case (Cons b bs)"], ["proof (state)\nthis:\n  \\<lbrakk>set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct bs; ?p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> ?p =\n                    (if base {d} ?p \\<in> set bs\n                     then \\<Sum>p'\\<in>lgrid (base {d} ?p) {d} lm.\n                            S (\\<beta> p') ?p p'\n                     else \\<beta> ?p)\n  set (b # bs) \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct (b # bs)\n  p \\<in> sparsegrid dm lm\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>set []\n                \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n        distinct []; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) [] \\<beta>\n                          p =\n                         (if base {d} p \\<in> set []\n                          then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                                 S (\\<beta> p') p p'\n                          else \\<beta> p)\n 2. \\<And>a bs p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>set bs\n                            \\<subseteq> set\n   (gridgen (start dm) ({0..<dm} - {d}) lm);\n                    distinct bs; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> foldr\n(\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n                                     (if base {d} p \\<in> set bs\nthen \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\nelse \\<beta> p);\n        set (a # bs)\n        \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n        distinct (a # bs); p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) (a # bs)\n                          \\<beta> p =\n                         (if base {d} p \\<in> set (a # bs)\n                          then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                                 S (\\<beta> p') p p'\n                          else \\<beta> p)", "hence \"b \\<in> lgrid (start dm) ({0..<dm} - {d}) lm\"\n        and \"(lm - level b) + level b = lm\"\n        and b_grid: \"b \\<in> grid (start dm) ({0..<dm} - {d})\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct bs; ?p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> ?p =\n                    (if base {d} ?p \\<in> set bs\n                     then \\<Sum>p'\\<in>lgrid (base {d} ?p) {d} lm.\n                            S (\\<beta> p') ?p p'\n                     else \\<beta> ?p)\n  set (b # bs) \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct (b # bs)\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. b \\<in> lgrid (start dm) ({0..<dm} - {d}) lm &&&\n    lm - level b + level b = lm &&& b \\<in> grid (start dm) ({0..<dm} - {d})", "using lgrid_def gridgen_lgrid_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct bs; ?p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> ?p =\n                    (if base {d} ?p \\<in> set bs\n                     then \\<Sum>p'\\<in>lgrid (base {d} ?p) {d} lm.\n                            S (\\<beta> p') ?p p'\n                     else \\<beta> ?p)\n  set (b # bs) \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct (b # bs)\n  p \\<in> sparsegrid dm lm\n  lgrid ?b ?ds ?lm = {p \\<in> grid ?b ?ds. level p < ?lm}\n  set (gridgen ?p ?ds ?l) = lgrid ?p ?ds (level ?p + ?l)\n\ngoal (1 subgoal):\n 1. b \\<in> lgrid (start dm) ({0..<dm} - {d}) lm &&&\n    lm - level b + level b = lm &&& b \\<in> grid (start dm) ({0..<dm} - {d})", "by auto"], ["proof (state)\nthis:\n  b \\<in> lgrid (start dm) ({0..<dm} - {d}) lm\n  lm - level b + level b = lm\n  b \\<in> grid (start dm) ({0..<dm} - {d})\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>set []\n                \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n        distinct []; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) [] \\<beta>\n                          p =\n                         (if base {d} p \\<in> set []\n                          then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                                 S (\\<beta> p') p p'\n                          else \\<beta> p)\n 2. \\<And>a bs p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>set bs\n                            \\<subseteq> set\n   (gridgen (start dm) ({0..<dm} - {d}) lm);\n                    distinct bs; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> foldr\n(\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n                                     (if base {d} p \\<in> set bs\nthen \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\nelse \\<beta> p);\n        set (a # bs)\n        \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n        distinct (a # bs); p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) (a # bs)\n                          \\<beta> p =\n                         (if base {d} p \\<in> set (a # bs)\n                          then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                                 S (\\<beta> p') p p'\n                          else \\<beta> p)", "note F = Fintro[OF this(1,2) \\<open>p \\<in> sparsegrid dm lm\\<close>]"], ["proof (state)\nthis:\n  F d (lm - level b) b ?\\<alpha> p =\n  (if b = base {d} p then \\<Sum>p'\\<in>lgrid b {d} lm. S (?\\<alpha> p') p p'\n   else ?\\<alpha> p)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>set []\n                \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n        distinct []; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) [] \\<beta>\n                          p =\n                         (if base {d} p \\<in> set []\n                          then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                                 S (\\<beta> p') p p'\n                          else \\<beta> p)\n 2. \\<And>a bs p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>set bs\n                            \\<subseteq> set\n   (gridgen (start dm) ({0..<dm} - {d}) lm);\n                    distinct bs; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> foldr\n(\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n                                     (if base {d} p \\<in> set bs\nthen \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\nelse \\<beta> p);\n        set (a # bs)\n        \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n        distinct (a # bs); p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) (a # bs)\n                          \\<beta> p =\n                         (if base {d} p \\<in> set (a # bs)\n                          then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                                 S (\\<beta> p') p p'\n                          else \\<beta> p)", "have \"b \\<notin> set bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> set bs", "using \\<open>distinct (b#bs)\\<close>"], ["proof (prove)\nusing this:\n  distinct (b # bs)\n\ngoal (1 subgoal):\n 1. b \\<notin> set bs", "by auto"], ["proof (state)\nthis:\n  b \\<notin> set bs\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>set []\n                \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n        distinct []; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) [] \\<beta>\n                          p =\n                         (if base {d} p \\<in> set []\n                          then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                                 S (\\<beta> p') p p'\n                          else \\<beta> p)\n 2. \\<And>a bs p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>set bs\n                            \\<subseteq> set\n   (gridgen (start dm) ({0..<dm} - {d}) lm);\n                    distinct bs; p \\<in> sparsegrid dm lm\\<rbrakk>\n                   \\<Longrightarrow> foldr\n(\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n                                     (if base {d} p \\<in> set bs\nthen \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\nelse \\<beta> p);\n        set (a # bs)\n        \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n        distinct (a # bs); p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) (a # bs)\n                          \\<beta> p =\n                         (if base {d} p \\<in> set (a # bs)\n                          then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                                 S (\\<beta> p') p p'\n                          else \\<beta> p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "proof (cases \"base {d} p \\<in> set (b#bs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. base {d} p \\<in> set (b # bs) \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. base {d} p \\<notin> set (b # bs) \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "case True"], ["proof (state)\nthis:\n  base {d} p \\<in> set (b # bs)\n\ngoal (2 subgoals):\n 1. base {d} p \\<in> set (b # bs) \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. base {d} p \\<notin> set (b # bs) \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "note base_in_set = this"], ["proof (state)\nthis:\n  base {d} p \\<in> set (b # bs)\n\ngoal (2 subgoals):\n 1. base {d} p \\<in> set (b # bs) \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. base {d} p \\<notin> set (b # bs) \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "proof (cases \"b = base {d} p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "case True"], ["proof (state)\nthis:\n  b = base {d} p\n\ngoal (2 subgoals):\n 1. b = base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "moreover"], ["proof (state)\nthis:\n  b = base {d} p\n\ngoal (2 subgoals):\n 1. b = base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "{"], ["proof (state)\nthis:\n  b = base {d} p\n\ngoal (2 subgoals):\n 1. b = base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "fix p'"], ["proof (state)\ngoal (2 subgoals):\n 1. b = base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "assume \"p' \\<in> lgrid b {d} lm\""], ["proof (state)\nthis:\n  p' \\<in> lgrid b {d} lm\n\ngoal (2 subgoals):\n 1. b = base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "hence \"p' \\<in> grid b {d}\" and \"level p' < lm\""], ["proof (prove)\nusing this:\n  p' \\<in> lgrid b {d} lm\n\ngoal (1 subgoal):\n 1. p' \\<in> grid b {d} &&& level p' < lm", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  p' \\<in> {p \\<in> grid b {d}. level p < lm}\n\ngoal (1 subgoal):\n 1. p' \\<in> grid b {d} &&& level p' < lm", "by auto"], ["proof (state)\nthis:\n  p' \\<in> grid b {d}\n  level p' < lm\n\ngoal (2 subgoals):\n 1. b = base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "from grid_transitive[OF this(1) b_grid, of \"{0..<dm}\"] \\<open>d < dm\\<close>\n              baseI[OF b_grid \\<open>p' \\<in> grid b {d}\\<close>] \\<open>b \\<notin> set bs\\<close>\n              Cons.prems Cons.hyps[of p'] this(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>{0..<dm} - {d} \\<subseteq> {0..<dm};\n   {d} \\<subseteq> {0..<dm}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid (start dm) {0..<dm}\n  d < dm\n  base {d} p' = b\n  b \\<notin> set bs\n  set (b # bs) \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct (b # bs)\n  p \\<in> sparsegrid dm lm\n  \\<lbrakk>set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct bs; p' \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p' =\n                    (if base {d} p' \\<in> set bs\n                     then \\<Sum>p'a\\<in>lgrid (base {d} p') {d} lm.\n                            S (\\<beta> p'a) p' p'a\n                     else \\<beta> p')\n  level p' < lm", "have \"foldr ?f bs \\<beta> p' = \\<beta> p'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<dm} - {d} \\<subseteq> {0..<dm};\n   {d} \\<subseteq> {0..<dm}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid (start dm) {0..<dm}\n  d < dm\n  base {d} p' = b\n  b \\<notin> set bs\n  set (b # bs) \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct (b # bs)\n  p \\<in> sparsegrid dm lm\n  \\<lbrakk>set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct bs; p' \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p' =\n                    (if base {d} p' \\<in> set bs\n                     then \\<Sum>p'a\\<in>lgrid (base {d} p') {d} lm.\n                            S (\\<beta> p'a) p' p'a\n                     else \\<beta> p')\n  level p' < lm\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p' = \\<beta> p'", "unfolding sparsegrid_def lgrid_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<dm} - {d} \\<subseteq> {0..<dm};\n   {d} \\<subseteq> {0..<dm}\\<rbrakk>\n  \\<Longrightarrow> p' \\<in> grid (start dm) {0..<dm}\n  d < dm\n  base {d} p' = b\n  b \\<notin> set bs\n  set (b # bs) \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct (b # bs)\n  p \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}\n  \\<lbrakk>set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct bs;\n   p' \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p' =\n                    (if base {d} p' \\<in> set bs\n                     then \\<Sum>p'a\\<in>{p \\<in> grid (base {d} p') {d}.\n   level p < lm}.\n                            S (\\<beta> p'a) p' p'a\n                     else \\<beta> p')\n  level p' < lm\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p' = \\<beta> p'", "by auto"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p' = \\<beta> p'\n\ngoal (2 subgoals):\n 1. b = base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "}"], ["proof (state)\nthis:\n  ?p'2 \\<in> lgrid b {d} lm \\<Longrightarrow>\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> ?p'2 = \\<beta> ?p'2\n\ngoal (2 subgoals):\n 1. b = base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)\n 2. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "ultimately"], ["proof (chain)\npicking this:\n  b = base {d} p\n  ?p'2 \\<in> lgrid b {d} lm \\<Longrightarrow>\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> ?p'2 = \\<beta> ?p'2", "show ?thesis"], ["proof (prove)\nusing this:\n  b = base {d} p\n  ?p'2 \\<in> lgrid b {d} lm \\<Longrightarrow>\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> ?p'2 = \\<beta> ?p'2\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "using F base_in_set"], ["proof (prove)\nusing this:\n  b = base {d} p\n  ?p'2 \\<in> lgrid b {d} lm \\<Longrightarrow>\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> ?p'2 = \\<beta> ?p'2\n  F d (lm - level b) b ?\\<alpha> p =\n  (if b = base {d} p then \\<Sum>p'\\<in>lgrid b {d} lm. S (?\\<alpha> p') p p'\n   else ?\\<alpha> p)\n  base {d} p \\<in> set (b # bs)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "by auto"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n  (if base {d} p \\<in> set (b # bs)\n   then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n   else \\<beta> p)\n\ngoal (1 subgoal):\n 1. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "case False"], ["proof (state)\nthis:\n  b \\<noteq> base {d} p\n\ngoal (1 subgoal):\n 1. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "with base_in_set"], ["proof (chain)\npicking this:\n  base {d} p \\<in> set (b # bs)\n  b \\<noteq> base {d} p", "have \"base {d} p \\<in> set bs\""], ["proof (prove)\nusing this:\n  base {d} p \\<in> set (b # bs)\n  b \\<noteq> base {d} p\n\ngoal (1 subgoal):\n 1. base {d} p \\<in> set bs", "by auto"], ["proof (state)\nthis:\n  base {d} p \\<in> set bs\n\ngoal (1 subgoal):\n 1. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "with Cons.hyps[of p] Cons.prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct bs; p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n                    (if base {d} p \\<in> set bs\n                     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                            S (\\<beta> p') p p'\n                     else \\<beta> p)\n  set (b # bs) \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct (b # bs)\n  p \\<in> sparsegrid dm lm\n  base {d} p \\<in> set bs", "have \"foldr ?f bs \\<beta> p = ?S p \\<beta>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct bs; p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n                    (if base {d} p \\<in> set bs\n                     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                            S (\\<beta> p') p p'\n                     else \\<beta> p)\n  set (b # bs) \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct (b # bs)\n  p \\<in> sparsegrid dm lm\n  base {d} p \\<in> set bs\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p')", "by auto"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n  (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p')\n\ngoal (1 subgoal):\n 1. b \\<noteq> base {d} p \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n  (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p')\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "using F base_in_set False"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n  (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p')\n  F d (lm - level b) b ?\\<alpha> p =\n  (if b = base {d} p then \\<Sum>p'\\<in>lgrid b {d} lm. S (?\\<alpha> p') p p'\n   else ?\\<alpha> p)\n  base {d} p \\<in> set (b # bs)\n  b \\<noteq> base {d} p\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "by auto"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n  (if base {d} p \\<in> set (b # bs)\n   then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n   else \\<beta> p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n  (if base {d} p \\<in> set (b # bs)\n   then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n   else \\<beta> p)\n\ngoal (1 subgoal):\n 1. base {d} p \\<notin> set (b # bs) \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. base {d} p \\<notin> set (b # bs) \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "case False"], ["proof (state)\nthis:\n  base {d} p \\<notin> set (b # bs)\n\ngoal (1 subgoal):\n 1. base {d} p \\<notin> set (b # bs) \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "hence \"b \\<noteq> base {d} p\""], ["proof (prove)\nusing this:\n  base {d} p \\<notin> set (b # bs)\n\ngoal (1 subgoal):\n 1. b \\<noteq> base {d} p", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> base {d} p\n\ngoal (1 subgoal):\n 1. base {d} p \\<notin> set (b # bs) \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "from False Cons.hyps[of p] Cons.prems"], ["proof (chain)\npicking this:\n  base {d} p \\<notin> set (b # bs)\n  \\<lbrakk>set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct bs; p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n                    (if base {d} p \\<in> set bs\n                     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                            S (\\<beta> p') p p'\n                     else \\<beta> p)\n  set (b # bs) \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct (b # bs)\n  p \\<in> sparsegrid dm lm", "have \"foldr ?f bs \\<beta> p = \\<beta> p\""], ["proof (prove)\nusing this:\n  base {d} p \\<notin> set (b # bs)\n  \\<lbrakk>set bs \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct bs; p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n                    (if base {d} p \\<in> set bs\n                     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                            S (\\<beta> p') p p'\n                     else \\<beta> p)\n  set (b # bs) \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct (b # bs)\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p = \\<beta> p", "by auto"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p = \\<beta> p\n\ngoal (1 subgoal):\n 1. base {d} p \\<notin> set (b # bs) \\<Longrightarrow>\n    foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p = \\<beta> p\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "using False F \\<open>b \\<noteq> base {d} p\\<close>"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p = \\<beta> p\n  base {d} p \\<notin> set (b # bs)\n  F d (lm - level b) b ?\\<alpha> p =\n  (if b = base {d} p then \\<Sum>p'\\<in>lgrid b {d} lm. S (?\\<alpha> p') p p'\n   else ?\\<alpha> p)\n  b \\<noteq> base {d} p\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n    (if base {d} p \\<in> set (b # bs)\n     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n     else \\<beta> p)", "by auto"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n  (if base {d} p \\<in> set (b # bs)\n   then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n   else \\<beta> p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. F d (lm - level a) a) (b # bs) \\<beta> p =\n  (if base {d} p \\<in> set (b # bs)\n   then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n   else \\<beta> p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>set []\n                \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n        distinct []; p \\<in> sparsegrid dm lm\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) [] \\<beta>\n                          p =\n                         (if base {d} p \\<in> set []\n                          then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                                 S (\\<beta> p') p p'\n                          else \\<beta> p)", "qed auto"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. F d (lm - level a) a) bs \\<beta> p =\n  (if base {d} p \\<in> set bs\n   then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<beta> p') p p'\n   else \\<beta> p)\n\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>set ?bs2\n           \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct ?bs2; p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) ?bs2 ?\\<beta>2\n                     p =\n                    (if base {d} p \\<in> set ?bs2\n                     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                            S (?\\<beta>2 p') p p'\n                     else ?\\<beta>2 p)\n\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>set ?bs2\n           \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct ?bs2; p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) ?bs2 ?\\<beta>2\n                     p =\n                    (if base {d} p \\<in> set ?bs2\n                     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                            S (?\\<beta>2 p') p p'\n                     else ?\\<beta>2 p)\n\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "have \"base {d} p \\<in> set ?gridgen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base {d} p \\<in> set (gridgen (start dm) ({0..<dm} - {d}) lm)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. base {d} p \\<in> set (gridgen (start dm) ({0..<dm} - {d}) lm)", "have \"p \\<in> grid (base {d} p) {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> grid (base {d} p) {d}", "using \\<open>p \\<in> sparsegrid dm lm\\<close>[THEN sparsegrid_subset]"], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid' dm\n\ngoal (1 subgoal):\n 1. p \\<in> grid (base {d} p) {d}", "by (rule baseE)"], ["proof (state)\nthis:\n  p \\<in> grid (base {d} p) {d}\n\ngoal (1 subgoal):\n 1. base {d} p \\<in> set (gridgen (start dm) ({0..<dm} - {d}) lm)", "from grid_level[OF this] baseE(1)[OF sparsegrid_subset[OF \\<open>p \\<in> sparsegrid dm lm\\<close>]]"], ["proof (chain)\npicking this:\n  level (base {d} p) \\<le> level p\n  base ?ds p \\<in> grid (start dm) ({0..<dm} - ?ds)", "show ?thesis"], ["proof (prove)\nusing this:\n  level (base {d} p) \\<le> level p\n  base ?ds p \\<in> grid (start dm) ({0..<dm} - ?ds)\n\ngoal (1 subgoal):\n 1. base {d} p \\<in> set (gridgen (start dm) ({0..<dm} - {d}) lm)", "using \\<open>p \\<in> sparsegrid dm lm\\<close>"], ["proof (prove)\nusing this:\n  level (base {d} p) \\<le> level p\n  base ?ds p \\<in> grid (start dm) ({0..<dm} - ?ds)\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. base {d} p \\<in> set (gridgen (start dm) ({0..<dm} - {d}) lm)", "unfolding gridgen_lgrid_eq sparsegrid'_def lgrid_def sparsegrid_def"], ["proof (prove)\nusing this:\n  level (base {d} p) \\<le> level p\n  base ?ds p \\<in> grid (start dm) ({0..<dm} - ?ds)\n  p \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}\n\ngoal (1 subgoal):\n 1. base {d} p\n    \\<in> {p \\<in> grid (start dm) ({0..<dm} - {d}).\n           level p < level (start dm) + lm}", "by auto"], ["proof (state)\nthis:\n  base {d} p \\<in> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  base {d} p \\<in> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ?bs2\n           \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct ?bs2; p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) ?bs2 ?\\<beta>2\n                     p =\n                    (if base {d} p \\<in> set ?bs2\n                     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                            S (?\\<beta>2 p') p p'\n                     else ?\\<beta>2 p)\n  base {d} p \\<in> set (gridgen (start dm) ({0..<dm} - {d}) lm)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?bs2\n           \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct ?bs2; p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) ?bs2 ?\\<beta>2\n                     p =\n                    (if base {d} p \\<in> set ?bs2\n                     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                            S (?\\<beta>2 p') p p'\n                     else ?\\<beta>2 p)\n  base {d} p \\<in> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n\ngoal (1 subgoal):\n 1. lift F dm lm d \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "unfolding lift_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?bs2\n           \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct ?bs2; p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) ?bs2 ?\\<beta>2\n                     p =\n                    (if base {d} p \\<in> set ?bs2\n                     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                            S (?\\<beta>2 p') p p'\n                     else ?\\<beta>2 p)\n  base {d} p \\<in> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>p. F d (lm - level p) p)\n     (gridgen (start dm) ({0..<dm} - {d}) lm) \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "using gridgen_distinct \\<open>p \\<in> sparsegrid dm lm\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?bs2\n           \\<subseteq> set (gridgen (start dm) ({0..<dm} - {d}) lm);\n   distinct ?bs2; p \\<in> sparsegrid dm lm\\<rbrakk>\n  \\<Longrightarrow> foldr (\\<lambda>a. F d (lm - level a) a) ?bs2 ?\\<beta>2\n                     p =\n                    (if base {d} p \\<in> set ?bs2\n                     then \\<Sum>p'\\<in>lgrid (base {d} p) {d} lm.\n                            S (?\\<beta>2 p') p p'\n                     else ?\\<beta>2 p)\n  base {d} p \\<in> set (gridgen (start dm) ({0..<dm} - {d}) lm)\n  distinct (gridgen ?p ?ds ?l)\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>p. F d (lm - level p) p)\n     (gridgen (start dm) ({0..<dm} - {d}) lm) \\<alpha> p =\n    (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')", "by auto"], ["proof (state)\nthis:\n  lift F dm lm d \\<alpha> p =\n  (\\<Sum>p'\\<in>lgrid (base {d} p) {d} lm. S (\\<alpha> p') p p')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Parent Points \\<close>"], ["", "definition parents :: \"nat \\<Rightarrow> grid_point \\<Rightarrow> grid_point \\<Rightarrow> grid_point set\"\nwhere \"parents d b p = { x \\<in> grid b {d}. p \\<in> grid x {d} }\""], ["", "lemma parents_split: assumes p_grid: \"p \\<in> grid (child b dir d) {d}\"\n  shows \"parents d b p = { b } \\<union> parents d (child b dir d) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parents d b p = {b} \\<union> parents d (child b dir d) p", "proof (intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> {b} \\<union> parents d (child b dir d) p\n 2. \\<And>x.\n       x \\<in> {b} \\<union> parents d (child b dir d) p \\<Longrightarrow>\n       x \\<in> parents d b p", "let ?chd = \"child b dir d\" and ?chid = \"child b (inv dir) d\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> {b} \\<union> parents d (child b dir d) p\n 2. \\<And>x.\n       x \\<in> {b} \\<union> parents d (child b dir d) p \\<Longrightarrow>\n       x \\<in> parents d b p", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> {b} \\<union> parents d (child b dir d) p\n 2. \\<And>x.\n       x \\<in> {b} \\<union> parents d (child b dir d) p \\<Longrightarrow>\n       x \\<in> parents d b p", "assume \"x \\<in> parents d b p\""], ["proof (state)\nthis:\n  x \\<in> parents d b p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> {b} \\<union> parents d (child b dir d) p\n 2. \\<And>x.\n       x \\<in> {b} \\<union> parents d (child b dir d) p \\<Longrightarrow>\n       x \\<in> parents d b p", "hence \"x \\<in> grid b {d}\" and \"p \\<in> grid x {d}\""], ["proof (prove)\nusing this:\n  x \\<in> parents d b p\n\ngoal (1 subgoal):\n 1. x \\<in> grid b {d} &&& p \\<in> grid x {d}", "unfolding parents_def"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> grid b {d}. p \\<in> grid x {d}}\n\ngoal (1 subgoal):\n 1. x \\<in> grid b {d} &&& p \\<in> grid x {d}", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid b {d}\n  p \\<in> grid x {d}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> {b} \\<union> parents d (child b dir d) p\n 2. \\<And>x.\n       x \\<in> {b} \\<union> parents d (child b dir d) p \\<Longrightarrow>\n       x \\<in> parents d b p", "hence x_split: \"x \\<in> {b} \\<union> grid ?chd {d} \\<union> grid ?chid {d}\""], ["proof (prove)\nusing this:\n  x \\<in> grid b {d}\n  p \\<in> grid x {d}\n\ngoal (1 subgoal):\n 1. x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n            grid (child b (Grid_Point.inv dir) d) {d}", "using grid_onedim_split[where ds=\"{}\" and b=b] and grid_empty_ds"], ["proof (prove)\nusing this:\n  x \\<in> grid b {d}\n  p \\<in> grid x {d}\n  grid b ({} \\<union> {?d}) =\n  grid b {} \\<union> grid (child b left ?d) ({} \\<union> {?d}) \\<union>\n  grid (child b right ?d) ({} \\<union> {?d})\n  grid ?b {} = {?b}\n\ngoal (1 subgoal):\n 1. x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n            grid (child b (Grid_Point.inv dir) d) {d}", "by (cases dir, auto)"], ["proof (state)\nthis:\n  x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n          grid (child b (Grid_Point.inv dir) d) {d}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> {b} \\<union> parents d (child b dir d) p\n 2. \\<And>x.\n       x \\<in> {b} \\<union> parents d (child b dir d) p \\<Longrightarrow>\n       x \\<in> parents d b p", "thus \"x \\<in> {b} \\<union> parents d (child b dir d) p\""], ["proof (prove)\nusing this:\n  x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n          grid (child b (Grid_Point.inv dir) d) {d}\n\ngoal (1 subgoal):\n 1. x \\<in> {b} \\<union> parents d (child b dir d) p", "proof (cases \"x = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n                     grid (child b (Grid_Point.inv dir) d) {d};\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {b} \\<union> parents d (child b dir d) p\n 2. \\<lbrakk>x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n                     grid (child b (Grid_Point.inv dir) d) {d};\n     x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {b} \\<union> parents d (child b dir d) p", "case False"], ["proof (state)\nthis:\n  x \\<noteq> b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n                     grid (child b (Grid_Point.inv dir) d) {d};\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {b} \\<union> parents d (child b dir d) p\n 2. \\<lbrakk>x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n                     grid (child b (Grid_Point.inv dir) d) {d};\n     x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {b} \\<union> parents d (child b dir d) p", "have \"d < length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length b", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> False", "assume \"\\<not> d < length b\""], ["proof (state)\nthis:\n  \\<not> d < length b\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> False", "hence empty: \"{d' \\<in> {d}. d' < length b} = {}\""], ["proof (prove)\nusing this:\n  \\<not> d < length b\n\ngoal (1 subgoal):\n 1. {d' \\<in> {d}. d' < length b} = {}", "by auto"], ["proof (state)\nthis:\n  {d' \\<in> {d}. d' < length b} = {}\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> False", "have \"x = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = b", "using \\<open>x \\<in> grid b {d}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. x = b", "unfolding grid_dim_remove_outer[where ds=\"{d}\" and b=b] empty"], ["proof (prove)\nusing this:\n  x \\<in> grid b {}\n\ngoal (1 subgoal):\n 1. x = b", "using grid_empty_ds"], ["proof (prove)\nusing this:\n  x \\<in> grid b {}\n  grid ?b {} = {?b}\n\ngoal (1 subgoal):\n 1. x = b", "by auto"], ["proof (state)\nthis:\n  x = b\n\ngoal (1 subgoal):\n 1. \\<not> d < length b \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  x = b\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> x = b\\<close>"], ["proof (prove)\nusing this:\n  x = b\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d < length b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n                     grid (child b (Grid_Point.inv dir) d) {d};\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {b} \\<union> parents d (child b dir d) p\n 2. \\<lbrakk>x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n                     grid (child b (Grid_Point.inv dir) d) {d};\n     x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {b} \\<union> parents d (child b dir d) p", "have \"x \\<notin> grid ?chid {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> grid (child b (Grid_Point.inv dir) d) {d}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid (child b (Grid_Point.inv dir) d)\n                       {d} \\<Longrightarrow>\n    False", "assume \"\\<not> x \\<notin> grid ?chid {d}\""], ["proof (state)\nthis:\n  \\<not> x \\<notin> grid (child b (Grid_Point.inv dir) d) {d}\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid (child b (Grid_Point.inv dir) d)\n                       {d} \\<Longrightarrow>\n    False", "hence \"p \\<in> grid ?chid {d}\""], ["proof (prove)\nusing this:\n  \\<not> x \\<notin> grid (child b (Grid_Point.inv dir) d) {d}\n\ngoal (1 subgoal):\n 1. p \\<in> grid (child b (Grid_Point.inv dir) d) {d}", "using grid_transitive[OF \\<open>p \\<in> grid x {d}\\<close>, where ds'=\"{d}\"]"], ["proof (prove)\nusing this:\n  \\<not> x \\<notin> grid (child b (Grid_Point.inv dir) d) {d}\n  \\<lbrakk>x \\<in> grid ?c {d}; {d} \\<subseteq> ?ds'';\n   {d} \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid ?c ?ds''\n\ngoal (1 subgoal):\n 1. p \\<in> grid (child b (Grid_Point.inv dir) d) {d}", "by auto"], ["proof (state)\nthis:\n  p \\<in> grid (child b (Grid_Point.inv dir) d) {d}\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid (child b (Grid_Point.inv dir) d)\n                       {d} \\<Longrightarrow>\n    False", "hence \"p \\<notin> grid ?chd {d}\""], ["proof (prove)\nusing this:\n  p \\<in> grid (child b (Grid_Point.inv dir) d) {d}\n\ngoal (1 subgoal):\n 1. p \\<notin> grid (child b dir d) {d}", "using grid_disjunct[OF \\<open>d < length b\\<close>]"], ["proof (prove)\nusing this:\n  p \\<in> grid (child b (Grid_Point.inv dir) d) {d}\n  grid (child b left d) ?ds \\<inter> grid (child b right d) ?ds = {}\n\ngoal (1 subgoal):\n 1. p \\<notin> grid (child b dir d) {d}", "by (cases dir, auto)"], ["proof (state)\nthis:\n  p \\<notin> grid (child b dir d) {d}\n\ngoal (1 subgoal):\n 1. \\<not> x \\<notin> grid (child b (Grid_Point.inv dir) d)\n                       {d} \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  p \\<notin> grid (child b dir d) {d}\n\ngoal (1 subgoal):\n 1. False", "using \\<open>p \\<in> grid ?chd {d}\\<close>"], ["proof (prove)\nusing this:\n  p \\<notin> grid (child b dir d) {d}\n  p \\<in> grid (child b dir d) {d}\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> grid (child b (Grid_Point.inv dir) d) {d}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n                     grid (child b (Grid_Point.inv dir) d) {d};\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {b} \\<union> parents d (child b dir d) p\n 2. \\<lbrakk>x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n                     grid (child b (Grid_Point.inv dir) d) {d};\n     x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {b} \\<union> parents d (child b dir d) p", "with False and x_split"], ["proof (chain)\npicking this:\n  x \\<noteq> b\n  x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n          grid (child b (Grid_Point.inv dir) d) {d}\n  x \\<notin> grid (child b (Grid_Point.inv dir) d) {d}", "have \"x \\<in> grid ?chd {d}\""], ["proof (prove)\nusing this:\n  x \\<noteq> b\n  x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n          grid (child b (Grid_Point.inv dir) d) {d}\n  x \\<notin> grid (child b (Grid_Point.inv dir) d) {d}\n\ngoal (1 subgoal):\n 1. x \\<in> grid (child b dir d) {d}", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid (child b dir d) {d}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n                     grid (child b (Grid_Point.inv dir) d) {d};\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {b} \\<union> parents d (child b dir d) p\n 2. \\<lbrakk>x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n                     grid (child b (Grid_Point.inv dir) d) {d};\n     x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {b} \\<union> parents d (child b dir d) p", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> grid (child b dir d) {d}\n\ngoal (1 subgoal):\n 1. x \\<in> {b} \\<union> parents d (child b dir d) p", "unfolding parents_def"], ["proof (prove)\nusing this:\n  x \\<in> grid (child b dir d) {d}\n\ngoal (1 subgoal):\n 1. x \\<in> {b} \\<union>\n            {x \\<in> grid (child b dir d) {d}. p \\<in> grid x {d}}", "using \\<open>p \\<in> grid x {d}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> grid (child b dir d) {d}\n  p \\<in> grid x {d}\n\ngoal (1 subgoal):\n 1. x \\<in> {b} \\<union>\n            {x \\<in> grid (child b dir d) {d}. p \\<in> grid x {d}}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {b} \\<union> parents d (child b dir d) p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {b} \\<union> grid (child b dir d) {d} \\<union>\n                     grid (child b (Grid_Point.inv dir) d) {d};\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {b} \\<union> parents d (child b dir d) p", "qed auto"], ["proof (state)\nthis:\n  x \\<in> {b} \\<union> parents d (child b dir d) p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {b} \\<union> parents d (child b dir d) p \\<Longrightarrow>\n       x \\<in> parents d b p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {b} \\<union> parents d (child b dir d) p \\<Longrightarrow>\n       x \\<in> parents d b p", "let ?chd = \"child b dir d\" and ?chid = \"child b (inv dir) d\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {b} \\<union> parents d (child b dir d) p \\<Longrightarrow>\n       x \\<in> parents d b p", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {b} \\<union> parents d (child b dir d) p \\<Longrightarrow>\n       x \\<in> parents d b p", "assume x_in: \"x \\<in> {b} \\<union> parents d ?chd p\""], ["proof (state)\nthis:\n  x \\<in> {b} \\<union> parents d (child b dir d) p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {b} \\<union> parents d (child b dir d) p \\<Longrightarrow>\n       x \\<in> parents d b p", "thus \"x \\<in> parents d b p\""], ["proof (prove)\nusing this:\n  x \\<in> {b} \\<union> parents d (child b dir d) p\n\ngoal (1 subgoal):\n 1. x \\<in> parents d b p", "proof (cases \"x = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {b} \\<union> parents d (child b dir d) p;\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> parents d b p\n 2. \\<lbrakk>x \\<in> {b} \\<union> parents d (child b dir d) p;\n     x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> parents d b p", "case False"], ["proof (state)\nthis:\n  x \\<noteq> b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {b} \\<union> parents d (child b dir d) p;\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> parents d b p\n 2. \\<lbrakk>x \\<in> {b} \\<union> parents d (child b dir d) p;\n     x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> parents d b p", "hence \"x \\<in> parents d ?chd p\""], ["proof (prove)\nusing this:\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. x \\<in> parents d (child b dir d) p", "using x_in"], ["proof (prove)\nusing this:\n  x \\<noteq> b\n  x \\<in> {b} \\<union> parents d (child b dir d) p\n\ngoal (1 subgoal):\n 1. x \\<in> parents d (child b dir d) p", "by auto"], ["proof (state)\nthis:\n  x \\<in> parents d (child b dir d) p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> {b} \\<union> parents d (child b dir d) p;\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> parents d b p\n 2. \\<lbrakk>x \\<in> {b} \\<union> parents d (child b dir d) p;\n     x \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> parents d b p", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> parents d (child b dir d) p\n\ngoal (1 subgoal):\n 1. x \\<in> parents d b p", "unfolding parents_def"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> grid (child b dir d) {d}. p \\<in> grid x {d}}\n\ngoal (1 subgoal):\n 1. x \\<in> {x \\<in> grid b {d}. p \\<in> grid x {d}}", "using grid_child[where b=b]"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> grid (child b dir d) {d}. p \\<in> grid x {d}}\n  \\<lbrakk>?d \\<in> ?ds; ?p \\<in> grid (child b ?dir ?d) ?ds\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> grid b ?ds\n\ngoal (1 subgoal):\n 1. x \\<in> {x \\<in> grid b {d}. p \\<in> grid x {d}}", "by auto"], ["proof (state)\nthis:\n  x \\<in> parents d b p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {b} \\<union> parents d (child b dir d) p;\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> parents d b p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {b} \\<union> parents d (child b dir d) p;\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> parents d b p", "from p_grid"], ["proof (chain)\npicking this:\n  p \\<in> grid (child b dir d) {d}", "have \"p \\<in> grid b {d}\""], ["proof (prove)\nusing this:\n  p \\<in> grid (child b dir d) {d}\n\ngoal (1 subgoal):\n 1. p \\<in> grid b {d}", "using grid_child[where b=b]"], ["proof (prove)\nusing this:\n  p \\<in> grid (child b dir d) {d}\n  \\<lbrakk>?d \\<in> ?ds; ?p \\<in> grid (child b ?dir ?d) ?ds\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> grid b ?ds\n\ngoal (1 subgoal):\n 1. p \\<in> grid b {d}", "by auto"], ["proof (state)\nthis:\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {b} \\<union> parents d (child b dir d) p;\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> parents d b p", "case True"], ["proof (state)\nthis:\n  x = b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {b} \\<union> parents d (child b dir d) p;\n     x = b\\<rbrakk>\n    \\<Longrightarrow> x \\<in> parents d b p", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = b\n\ngoal (1 subgoal):\n 1. x \\<in> parents d b p", "unfolding parents_def"], ["proof (prove)\nusing this:\n  x = b\n\ngoal (1 subgoal):\n 1. x \\<in> {x \\<in> grid b {d}. p \\<in> grid x {d}}", "using \\<open>p \\<in> grid b {d}\\<close>"], ["proof (prove)\nusing this:\n  x = b\n  p \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. x \\<in> {x \\<in> grid b {d}. p \\<in> grid x {d}}", "by auto"], ["proof (state)\nthis:\n  x \\<in> parents d b p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> parents d b p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parents_no_parent: assumes \"d < length b\" shows \"b \\<notin> parents d (child b dir d) p\" (is \"_ \\<notin> parents _ ?ch _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<notin> parents d (child b dir d) p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> parents d (child b dir d) p \\<Longrightarrow> False", "assume \"b \\<in> parents d ?ch p\""], ["proof (state)\nthis:\n  b \\<in> parents d (child b dir d) p\n\ngoal (1 subgoal):\n 1. b \\<in> parents d (child b dir d) p \\<Longrightarrow> False", "hence \"b \\<in> grid ?ch {d}\""], ["proof (prove)\nusing this:\n  b \\<in> parents d (child b dir d) p\n\ngoal (1 subgoal):\n 1. b \\<in> grid (child b dir d) {d}", "unfolding parents_def"], ["proof (prove)\nusing this:\n  b \\<in> {x \\<in> grid (child b dir d) {d}. p \\<in> grid x {d}}\n\ngoal (1 subgoal):\n 1. b \\<in> grid (child b dir d) {d}", "by auto"], ["proof (state)\nthis:\n  b \\<in> grid (child b dir d) {d}\n\ngoal (1 subgoal):\n 1. b \\<in> parents d (child b dir d) p \\<Longrightarrow> False", "from grid_level[OF this]"], ["proof (chain)\npicking this:\n  level (child b dir d) \\<le> level b", "have \"level b + 1 \\<le> level b\""], ["proof (prove)\nusing this:\n  level (child b dir d) \\<le> level b\n\ngoal (1 subgoal):\n 1. level b + 1 \\<le> level b", "unfolding child_level[OF \\<open>d < length b\\<close>]"], ["proof (prove)\nusing this:\n  level b + 1 \\<le> level b\n\ngoal (1 subgoal):\n 1. level b + 1 \\<le> level b", "."], ["proof (state)\nthis:\n  level b + 1 \\<le> level b\n\ngoal (1 subgoal):\n 1. b \\<in> parents d (child b dir d) p \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  level b + 1 \\<le> level b\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parents_subset_lgrid: \"parents d b p \\<subseteq> lgrid b {d} (level p + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parents d b p \\<subseteq> lgrid b {d} (level p + 1)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> lgrid b {d} (level p + 1)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> lgrid b {d} (level p + 1)", "assume \"x \\<in> parents d b p\""], ["proof (state)\nthis:\n  x \\<in> parents d b p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> lgrid b {d} (level p + 1)", "hence \"x \\<in> grid b {d}\" and \"p \\<in> grid x {d}\""], ["proof (prove)\nusing this:\n  x \\<in> parents d b p\n\ngoal (1 subgoal):\n 1. x \\<in> grid b {d} &&& p \\<in> grid x {d}", "unfolding parents_def"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> grid b {d}. p \\<in> grid x {d}}\n\ngoal (1 subgoal):\n 1. x \\<in> grid b {d} &&& p \\<in> grid x {d}", "by auto"], ["proof (state)\nthis:\n  x \\<in> grid b {d}\n  p \\<in> grid x {d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> lgrid b {d} (level p + 1)", "moreover"], ["proof (state)\nthis:\n  x \\<in> grid b {d}\n  p \\<in> grid x {d}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> lgrid b {d} (level p + 1)", "hence \"level x \\<le> level p\""], ["proof (prove)\nusing this:\n  x \\<in> grid b {d}\n  p \\<in> grid x {d}\n\ngoal (1 subgoal):\n 1. level x \\<le> level p", "using grid_level"], ["proof (prove)\nusing this:\n  x \\<in> grid b {d}\n  p \\<in> grid x {d}\n  ?p \\<in> grid ?b ?ds \\<Longrightarrow> level ?b \\<le> level ?p\n\ngoal (1 subgoal):\n 1. level x \\<le> level p", "by auto"], ["proof (state)\nthis:\n  level x \\<le> level p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> lgrid b {d} (level p + 1)", "hence \"level x < level p + 1\""], ["proof (prove)\nusing this:\n  level x \\<le> level p\n\ngoal (1 subgoal):\n 1. level x < level p + 1", "by auto"], ["proof (state)\nthis:\n  level x < level p + 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parents d b p \\<Longrightarrow>\n       x \\<in> lgrid b {d} (level p + 1)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> grid b {d}\n  p \\<in> grid x {d}\n  level x < level p + 1", "show \"x \\<in> lgrid b {d} (level p + 1)\""], ["proof (prove)\nusing this:\n  x \\<in> grid b {d}\n  p \\<in> grid x {d}\n  level x < level p + 1\n\ngoal (1 subgoal):\n 1. x \\<in> lgrid b {d} (level p + 1)", "unfolding lgrid_def"], ["proof (prove)\nusing this:\n  x \\<in> grid b {d}\n  p \\<in> grid x {d}\n  level x < level p + 1\n\ngoal (1 subgoal):\n 1. x \\<in> {pa \\<in> grid b {d}. level pa < level p + 1}", "by auto"], ["proof (state)\nthis:\n  x \\<in> lgrid b {d} (level p + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parents_finite: \"finite (parents d b p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (parents d b p)", "using finite_subset[OF parents_subset_lgrid lgrid_finite]"], ["proof (prove)\nusing this:\n  finite (parents ?d2 ?b1 ?p2)\n\ngoal (1 subgoal):\n 1. finite (parents d b p)", "."], ["", "lemma parent_sum: assumes p_grid: \"p \\<in> grid (child b dir d) {d}\" and \"d < length b\"\n  shows \"(\\<Sum> x \\<in> parents d b p. F x) = F b + (\\<Sum> x \\<in> parents d (child b dir d) p. F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum F (parents d b p) = F b + sum F (parents d (child b dir d) p)", "unfolding parents_split[OF p_grid]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum F ({b} \\<union> parents d (child b dir d) p) =\n    F b + sum F (parents d (child b dir d) p)", "using parents_no_parent[OF \\<open>d < length b\\<close>, where dir=dir and p=p]"], ["proof (prove)\nusing this:\n  b \\<notin> parents d (child b dir d) p\n\ngoal (1 subgoal):\n 1. sum F ({b} \\<union> parents d (child b dir d) p) =\n    F b + sum F (parents d (child b dir d) p)", "using parents_finite"], ["proof (prove)\nusing this:\n  b \\<notin> parents d (child b dir d) p\n  finite (parents ?d ?b ?p)\n\ngoal (1 subgoal):\n 1. sum F ({b} \\<union> parents d (child b dir d) p) =\n    F b + sum F (parents d (child b dir d) p)", "by auto"], ["", "lemma parents_single: \"parents d b b = { b }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parents d b b = {b}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. parents d b b \\<subseteq> {b}\n 2. {b} \\<subseteq> parents d b b", "have \"parents d b b \\<subseteq> lgrid b {d} (level b + (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parents d b b \\<subseteq> lgrid b {d} (level b + Suc 0)", "using parents_subset_lgrid"], ["proof (prove)\nusing this:\n  parents ?d ?b ?p \\<subseteq> lgrid ?b {?d} (level ?p + 1)\n\ngoal (1 subgoal):\n 1. parents d b b \\<subseteq> lgrid b {d} (level b + Suc 0)", "by auto"], ["proof (state)\nthis:\n  parents d b b \\<subseteq> lgrid b {d} (level b + Suc 0)\n\ngoal (2 subgoals):\n 1. parents d b b \\<subseteq> {b}\n 2. {b} \\<subseteq> parents d b b", "also"], ["proof (state)\nthis:\n  parents d b b \\<subseteq> lgrid b {d} (level b + Suc 0)\n\ngoal (2 subgoals):\n 1. parents d b b \\<subseteq> {b}\n 2. {b} \\<subseteq> parents d b b", "have \"\\<dots> = {b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lgrid b {d} (level b + Suc 0) = {b}", "unfolding gridgen_lgrid_eq[symmetric] gridgen.simps Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (b #\n         concat\n          (map (\\<lambda>d. [] @ [])\n            (filter (\\<lambda>da. da \\<in> {d}) [0..<length b]))) =\n    {b}", "by auto"], ["proof (state)\nthis:\n  lgrid b {d} (level b + Suc 0) = {b}\n\ngoal (2 subgoals):\n 1. parents d b b \\<subseteq> {b}\n 2. {b} \\<subseteq> parents d b b", "finally"], ["proof (chain)\npicking this:\n  parents d b b \\<subseteq> {b}", "show \"parents d b b \\<subseteq> { b }\""], ["proof (prove)\nusing this:\n  parents d b b \\<subseteq> {b}\n\ngoal (1 subgoal):\n 1. parents d b b \\<subseteq> {b}", "."], ["proof (state)\nthis:\n  parents d b b \\<subseteq> {b}\n\ngoal (1 subgoal):\n 1. {b} \\<subseteq> parents d b b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {b} \\<subseteq> parents d b b", "have \"b \\<in> parents d b b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> parents d b b", "unfolding parents_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> {x \\<in> grid b {d}. b \\<in> grid x {d}}", "by auto"], ["proof (state)\nthis:\n  b \\<in> parents d b b\n\ngoal (1 subgoal):\n 1. {b} \\<subseteq> parents d b b", "thus \"{ b } \\<subseteq> parents d b b\""], ["proof (prove)\nusing this:\n  b \\<in> parents d b b\n\ngoal (1 subgoal):\n 1. {b} \\<subseteq> parents d b b", "by auto"], ["proof (state)\nthis:\n  {b} \\<subseteq> parents d b b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_single_dimensional_specification:\n  assumes \"d < length b\"\n  and \"odd i\"\n  and \"lv b d + l' = l\"\n  and \"i < (ix b d + 1) * 2^l'\"\n  and \"i > (ix b d - 1) * 2^l'\"\n  shows \"b[d := (l,i)] \\<in> grid b {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b[d := (l, i)] \\<in> grid b {d}", "using assms"], ["proof (prove)\nusing this:\n  d < length b\n  odd i\n  lv b d + l' = l\n  i < (ix b d + 1) * 2 ^ l'\n  (ix b d - 1) * 2 ^ l' < i\n\ngoal (1 subgoal):\n 1. b[d := (l, i)] \\<in> grid b {d}", "proof (induct l' arbitrary: b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>d < length b; odd i; lv b d + 0 = l;\n        i < (ix b d + 1) * 2 ^ 0; (ix b d - 1) * 2 ^ 0 < i\\<rbrakk>\n       \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}\n 2. \\<And>l' b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>d < length b; odd i; lv b d + l' = l;\n                    i < (ix b d + 1) * 2 ^ l';\n                    (ix b d - 1) * 2 ^ l' < i\\<rbrakk>\n                   \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d};\n        d < length b; odd i; lv b d + Suc l' = l;\n        i < (ix b d + 1) * 2 ^ Suc l';\n        (ix b d - 1) * 2 ^ Suc l' < i\\<rbrakk>\n       \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}", "case 0"], ["proof (state)\nthis:\n  d < length b\n  odd i\n  lv b d + 0 = l\n  i < (ix b d + 1) * 2 ^ 0\n  (ix b d - 1) * 2 ^ 0 < i\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>d < length b; odd i; lv b d + 0 = l;\n        i < (ix b d + 1) * 2 ^ 0; (ix b d - 1) * 2 ^ 0 < i\\<rbrakk>\n       \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}\n 2. \\<And>l' b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>d < length b; odd i; lv b d + l' = l;\n                    i < (ix b d + 1) * 2 ^ l';\n                    (ix b d - 1) * 2 ^ l' < i\\<rbrakk>\n                   \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d};\n        d < length b; odd i; lv b d + Suc l' = l;\n        i < (ix b d + 1) * 2 ^ Suc l';\n        (ix b d - 1) * 2 ^ Suc l' < i\\<rbrakk>\n       \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}", "hence \"i = ix b d\" and \"l = lv b d\""], ["proof (prove)\nusing this:\n  d < length b\n  odd i\n  lv b d + 0 = l\n  i < (ix b d + 1) * 2 ^ 0\n  (ix b d - 1) * 2 ^ 0 < i\n\ngoal (1 subgoal):\n 1. i = ix b d &&& l = lv b d", "by auto"], ["proof (state)\nthis:\n  i = ix b d\n  l = lv b d\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>d < length b; odd i; lv b d + 0 = l;\n        i < (ix b d + 1) * 2 ^ 0; (ix b d - 1) * 2 ^ 0 < i\\<rbrakk>\n       \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}\n 2. \\<And>l' b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>d < length b; odd i; lv b d + l' = l;\n                    i < (ix b d + 1) * 2 ^ l';\n                    (ix b d - 1) * 2 ^ l' < i\\<rbrakk>\n                   \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d};\n        d < length b; odd i; lv b d + Suc l' = l;\n        i < (ix b d + 1) * 2 ^ Suc l';\n        (ix b d - 1) * 2 ^ Suc l' < i\\<rbrakk>\n       \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}", "thus ?case"], ["proof (prove)\nusing this:\n  i = ix b d\n  l = lv b d\n\ngoal (1 subgoal):\n 1. b[d := (l, i)] \\<in> grid b {d}", "unfolding ix_def lv_def"], ["proof (prove)\nusing this:\n  i = snd (b ! d)\n  l = fst (b ! d)\n\ngoal (1 subgoal):\n 1. b[d := (l, i)] \\<in> grid b {d}", "by auto"], ["proof (state)\nthis:\n  b[d := (l, i)] \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. \\<And>l' b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>d < length b; odd i; lv b d + l' = l;\n                    i < (ix b d + 1) * 2 ^ l';\n                    (ix b d - 1) * 2 ^ l' < i\\<rbrakk>\n                   \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d};\n        d < length b; odd i; lv b d + Suc l' = l;\n        i < (ix b d + 1) * 2 ^ Suc l';\n        (ix b d - 1) * 2 ^ Suc l' < i\\<rbrakk>\n       \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l' b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>d < length b; odd i; lv b d + l' = l;\n                    i < (ix b d + 1) * 2 ^ l';\n                    (ix b d - 1) * 2 ^ l' < i\\<rbrakk>\n                   \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d};\n        d < length b; odd i; lv b d + Suc l' = l;\n        i < (ix b d + 1) * 2 ^ Suc l';\n        (ix b d - 1) * 2 ^ Suc l' < i\\<rbrakk>\n       \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}", "case (Suc l')"], ["proof (state)\nthis:\n  \\<lbrakk>d < length ?b; odd i; lv ?b d + l' = l;\n   i < (ix ?b d + 1) * 2 ^ l'; (ix ?b d - 1) * 2 ^ l' < i\\<rbrakk>\n  \\<Longrightarrow> ?b[d := (l, i)] \\<in> grid ?b {d}\n  d < length b\n  odd i\n  lv b d + Suc l' = l\n  i < (ix b d + 1) * 2 ^ Suc l'\n  (ix b d - 1) * 2 ^ Suc l' < i\n\ngoal (1 subgoal):\n 1. \\<And>l' b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>d < length b; odd i; lv b d + l' = l;\n                    i < (ix b d + 1) * 2 ^ l';\n                    (ix b d - 1) * 2 ^ l' < i\\<rbrakk>\n                   \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d};\n        d < length b; odd i; lv b d + Suc l' = l;\n        i < (ix b d + 1) * 2 ^ Suc l';\n        (ix b d - 1) * 2 ^ Suc l' < i\\<rbrakk>\n       \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}", "have \"d \\<in> {d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<in> {d}", "by auto"], ["proof (state)\nthis:\n  d \\<in> {d}\n\ngoal (1 subgoal):\n 1. \\<And>l' b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>d < length b; odd i; lv b d + l' = l;\n                    i < (ix b d + 1) * 2 ^ l';\n                    (ix b d - 1) * 2 ^ l' < i\\<rbrakk>\n                   \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d};\n        d < length b; odd i; lv b d + Suc l' = l;\n        i < (ix b d + 1) * 2 ^ Suc l';\n        (ix b d - 1) * 2 ^ Suc l' < i\\<rbrakk>\n       \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. b[d := (l, i)] \\<in> grid b {d}", "proof (rule linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}\n 2. ?x = ?y \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}\n 3. ?y < ?x \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}", "assume \"i = ix b d * 2^(Suc l')\""], ["proof (state)\nthis:\n  i = ix b d * 2 ^ Suc l'\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}\n 2. ?x = ?y \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}\n 3. ?y < ?x \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}", "hence \"even i\""], ["proof (prove)\nusing this:\n  i = ix b d * 2 ^ Suc l'\n\ngoal (1 subgoal):\n 1. even i", "by auto"], ["proof (state)\nthis:\n  even i\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}\n 2. ?x = ?y \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}\n 3. ?y < ?x \\<Longrightarrow> b[d := (l, i)] \\<in> grid b {d}", "thus ?thesis"], ["proof (prove)\nusing this:\n  even i\n\ngoal (1 subgoal):\n 1. b[d := (l, i)] \\<in> grid b {d}", "using \\<open>odd i\\<close>"], ["proof (prove)\nusing this:\n  even i\n  odd i\n\ngoal (1 subgoal):\n 1. b[d := (l, i)] \\<in> grid b {d}", "by blast"], ["proof (state)\nthis:\n  b[d := (l, i)] \\<in> grid b {d}\n\ngoal (2 subgoals):\n 1. i < ix b d * 2 ^ Suc l' \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}\n 2. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i < ix b d * 2 ^ Suc l' \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}\n 2. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "assume *: \"i < ix b d * 2^(Suc l')\""], ["proof (state)\nthis:\n  i < ix b d * 2 ^ Suc l'\n\ngoal (2 subgoals):\n 1. i < ix b d * 2 ^ Suc l' \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}\n 2. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "let ?b = \"child b left d\""], ["proof (state)\ngoal (2 subgoals):\n 1. i < ix b d * 2 ^ Suc l' \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}\n 2. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "have \"d < length ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length (child b left d)", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>d < length ?b; odd i; lv ?b d + l' = l;\n   i < (ix ?b d + 1) * 2 ^ l'; (ix ?b d - 1) * 2 ^ l' < i\\<rbrakk>\n  \\<Longrightarrow> ?b[d := (l, i)] \\<in> grid ?b {d}\n  d < length b\n  odd i\n  lv b d + Suc l' = l\n  i < (ix b d + 1) * 2 ^ Suc l'\n  (ix b d - 1) * 2 ^ Suc l' < i\n\ngoal (1 subgoal):\n 1. d < length (child b left d)", "by auto"], ["proof (state)\nthis:\n  d < length (child b left d)\n\ngoal (2 subgoals):\n 1. i < ix b d * 2 ^ Suc l' \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}\n 2. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "moreover"], ["proof (state)\nthis:\n  d < length (child b left d)\n\ngoal (2 subgoals):\n 1. i < ix b d * 2 ^ Suc l' \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}\n 2. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "note \\<open>odd i\\<close>"], ["proof (state)\nthis:\n  odd i\n\ngoal (2 subgoals):\n 1. i < ix b d * 2 ^ Suc l' \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}\n 2. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "moreover"], ["proof (state)\nthis:\n  odd i\n\ngoal (2 subgoals):\n 1. i < ix b d * 2 ^ Suc l' \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}\n 2. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "have \"lv ?b d + l' = l\"\n      and \"i < (ix ?b d + 1) * 2^l'\"\n      and \"(ix ?b d - 1) * 2^l' < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv (child b left d) d + l' = l &&&\n    i < (ix (child b left d) d + 1) * 2 ^ l' &&&\n    (ix (child b left d) d - 1) * 2 ^ l' < i", "unfolding child_ix_left[OF Suc.prems(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lv (child b left d) d + l' = l &&&\n    i < (2 * ix b d - 1 + 1) * 2 ^ l' &&& (2 * ix b d - 1 - 1) * 2 ^ l' < i", "using Suc.prems * child_lv"], ["proof (prove)\nusing this:\n  d < length b\n  odd i\n  lv b d + Suc l' = l\n  i < (ix b d + 1) * 2 ^ Suc l'\n  (ix b d - 1) * 2 ^ Suc l' < i\n  i < ix b d * 2 ^ Suc l'\n  ?d < length ?p \\<Longrightarrow> lv (child ?p ?dir ?d) ?d = lv ?p ?d + 1\n\ngoal (1 subgoal):\n 1. lv (child b left d) d + l' = l &&&\n    i < (2 * ix b d - 1 + 1) * 2 ^ l' &&& (2 * ix b d - 1 - 1) * 2 ^ l' < i", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  lv (child b left d) d + l' = l\n  i < (ix (child b left d) d + 1) * 2 ^ l'\n  (ix (child b left d) d - 1) * 2 ^ l' < i\n\ngoal (2 subgoals):\n 1. i < ix b d * 2 ^ Suc l' \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}\n 2. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "ultimately"], ["proof (chain)\npicking this:\n  d < length (child b left d)\n  odd i\n  lv (child b left d) d + l' = l\n  i < (ix (child b left d) d + 1) * 2 ^ l'\n  (ix (child b left d) d - 1) * 2 ^ l' < i", "have \"?b[d := (l,i)] \\<in> grid ?b {d}\""], ["proof (prove)\nusing this:\n  d < length (child b left d)\n  odd i\n  lv (child b left d) d + l' = l\n  i < (ix (child b left d) d + 1) * 2 ^ l'\n  (ix (child b left d) d - 1) * 2 ^ l' < i\n\ngoal (1 subgoal):\n 1. (child b left d)[d := (l, i)] \\<in> grid (child b left d) {d}", "by (rule Suc.hyps)"], ["proof (state)\nthis:\n  (child b left d)[d := (l, i)] \\<in> grid (child b left d) {d}\n\ngoal (2 subgoals):\n 1. i < ix b d * 2 ^ Suc l' \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}\n 2. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (child b left d)[d := (l, i)] \\<in> grid (child b left d) {d}\n\ngoal (1 subgoal):\n 1. b[d := (l, i)] \\<in> grid b {d}", "by (auto intro!: grid_child[OF \\<open>d \\<in> {d}\\<close>, of _ b left]\n        simp add: child_def)"], ["proof (state)\nthis:\n  b[d := (l, i)] \\<in> grid b {d}\n\ngoal (1 subgoal):\n 1. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "assume *: \"ix b d * 2^(Suc l') < i\""], ["proof (state)\nthis:\n  ix b d * 2 ^ Suc l' < i\n\ngoal (1 subgoal):\n 1. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "let ?b = \"child b right d\""], ["proof (state)\ngoal (1 subgoal):\n 1. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "have \"d < length ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < length (child b right d)", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>d < length ?b; odd i; lv ?b d + l' = l;\n   i < (ix ?b d + 1) * 2 ^ l'; (ix ?b d - 1) * 2 ^ l' < i\\<rbrakk>\n  \\<Longrightarrow> ?b[d := (l, i)] \\<in> grid ?b {d}\n  d < length b\n  odd i\n  lv b d + Suc l' = l\n  i < (ix b d + 1) * 2 ^ Suc l'\n  (ix b d - 1) * 2 ^ Suc l' < i\n\ngoal (1 subgoal):\n 1. d < length (child b right d)", "by auto"], ["proof (state)\nthis:\n  d < length (child b right d)\n\ngoal (1 subgoal):\n 1. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "moreover"], ["proof (state)\nthis:\n  d < length (child b right d)\n\ngoal (1 subgoal):\n 1. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "note \\<open>odd i\\<close>"], ["proof (state)\nthis:\n  odd i\n\ngoal (1 subgoal):\n 1. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "moreover"], ["proof (state)\nthis:\n  odd i\n\ngoal (1 subgoal):\n 1. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "have \"lv ?b d + l' = l\"\n      and \"i < (ix ?b d + 1) * 2^l'\"\n      and \"(ix ?b d - 1) * 2^l' < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv (child b right d) d + l' = l &&&\n    i < (ix (child b right d) d + 1) * 2 ^ l' &&&\n    (ix (child b right d) d - 1) * 2 ^ l' < i", "unfolding child_ix_right[OF Suc.prems(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lv (child b right d) d + l' = l &&&\n    i < (2 * ix b d + 1 + 1) * 2 ^ l' &&& (2 * ix b d + 1 - 1) * 2 ^ l' < i", "using Suc.prems * child_lv"], ["proof (prove)\nusing this:\n  d < length b\n  odd i\n  lv b d + Suc l' = l\n  i < (ix b d + 1) * 2 ^ Suc l'\n  (ix b d - 1) * 2 ^ Suc l' < i\n  ix b d * 2 ^ Suc l' < i\n  ?d < length ?p \\<Longrightarrow> lv (child ?p ?dir ?d) ?d = lv ?p ?d + 1\n\ngoal (1 subgoal):\n 1. lv (child b right d) d + l' = l &&&\n    i < (2 * ix b d + 1 + 1) * 2 ^ l' &&& (2 * ix b d + 1 - 1) * 2 ^ l' < i", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  lv (child b right d) d + l' = l\n  i < (ix (child b right d) d + 1) * 2 ^ l'\n  (ix (child b right d) d - 1) * 2 ^ l' < i\n\ngoal (1 subgoal):\n 1. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "ultimately"], ["proof (chain)\npicking this:\n  d < length (child b right d)\n  odd i\n  lv (child b right d) d + l' = l\n  i < (ix (child b right d) d + 1) * 2 ^ l'\n  (ix (child b right d) d - 1) * 2 ^ l' < i", "have \"?b[d := (l,i)] \\<in> grid ?b {d}\""], ["proof (prove)\nusing this:\n  d < length (child b right d)\n  odd i\n  lv (child b right d) d + l' = l\n  i < (ix (child b right d) d + 1) * 2 ^ l'\n  (ix (child b right d) d - 1) * 2 ^ l' < i\n\ngoal (1 subgoal):\n 1. (child b right d)[d := (l, i)] \\<in> grid (child b right d) {d}", "by (rule Suc.hyps)"], ["proof (state)\nthis:\n  (child b right d)[d := (l, i)] \\<in> grid (child b right d) {d}\n\ngoal (1 subgoal):\n 1. ix b d * 2 ^ Suc l' < i \\<Longrightarrow>\n    b[d := (l, i)] \\<in> grid b {d}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (child b right d)[d := (l, i)] \\<in> grid (child b right d) {d}\n\ngoal (1 subgoal):\n 1. b[d := (l, i)] \\<in> grid b {d}", "by (auto intro!: grid_child[OF \\<open>d \\<in> {d}\\<close>, of _ b right]\n        simp add: child_def)"], ["proof (state)\nthis:\n  b[d := (l, i)] \\<in> grid b {d}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b[d := (l, i)] \\<in> grid b {d}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma grid_multi_dimensional_specification:\n  assumes \"dm \\<le> length b\" and \"length p = length b\"\n  and \"\\<And> d. d < dm \\<Longrightarrow>\n    odd (ix p d) \\<and>\n    lv b d \\<le> lv p d \\<and>\n    ix p d < (ix b d + 1) * 2^(lv p d - lv b d) \\<and>\n    ix p d > (ix b d - 1) * 2^(lv p d - lv b d)\"\n    (is \"\\<And> d. d < dm \\<Longrightarrow> ?bounded p d\")\n  and \"\\<And> d. \\<lbrakk> dm \\<le> d ; d < length b \\<rbrakk> \\<Longrightarrow> p ! d = b ! d\"\n  shows \"p \\<in> grid b {0..<dm}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> grid b {0..<dm}", "using assms"], ["proof (prove)\nusing this:\n  dm \\<le> length b\n  length p = length b\n  ?d < dm \\<Longrightarrow>\n  odd (ix p ?d) \\<and>\n  lv b ?d \\<le> lv p ?d \\<and>\n  ix p ?d < (ix b ?d + 1) * 2 ^ (lv p ?d - lv b ?d) \\<and>\n  (ix b ?d - 1) * 2 ^ (lv p ?d - lv b ?d) < ix p ?d\n  \\<lbrakk>dm \\<le> ?d; ?d < length b\\<rbrakk>\n  \\<Longrightarrow> p ! ?d = b ! ?d\n\ngoal (1 subgoal):\n 1. p \\<in> grid b {0..<dm}", "proof (induct dm arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 \\<le> length b; length p = length b;\n        \\<And>d.\n           d < 0 \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>0 \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<0}\n 2. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "case 0"], ["proof (state)\nthis:\n  0 \\<le> length b\n  length p = length b\n  ?d < 0 \\<Longrightarrow>\n  odd (ix p ?d) \\<and>\n  lv b ?d \\<le> lv p ?d \\<and>\n  ix p ?d < (ix b ?d + 1) * 2 ^ (lv p ?d - lv b ?d) \\<and>\n  (ix b ?d - 1) * 2 ^ (lv p ?d - lv b ?d) < ix p ?d\n  \\<lbrakk>0 \\<le> ?d; ?d < length b\\<rbrakk>\n  \\<Longrightarrow> p ! ?d = b ! ?d\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 \\<le> length b; length p = length b;\n        \\<And>d.\n           d < 0 \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>0 \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<0}\n 2. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "hence \"p = b\""], ["proof (prove)\nusing this:\n  0 \\<le> length b\n  length p = length b\n  ?d < 0 \\<Longrightarrow>\n  odd (ix p ?d) \\<and>\n  lv b ?d \\<le> lv p ?d \\<and>\n  ix p ?d < (ix b ?d + 1) * 2 ^ (lv p ?d - lv b ?d) \\<and>\n  (ix b ?d - 1) * 2 ^ (lv p ?d - lv b ?d) < ix p ?d\n  \\<lbrakk>0 \\<le> ?d; ?d < length b\\<rbrakk>\n  \\<Longrightarrow> p ! ?d = b ! ?d\n\ngoal (1 subgoal):\n 1. p = b", "by (auto intro!: nth_equalityI)"], ["proof (state)\nthis:\n  p = b\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 \\<le> length b; length p = length b;\n        \\<And>d.\n           d < 0 \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>0 \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<0}\n 2. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "thus ?case"], ["proof (prove)\nusing this:\n  p = b\n\ngoal (1 subgoal):\n 1. p \\<in> grid b {0..<0}", "by auto"], ["proof (state)\nthis:\n  p \\<in> grid b {0..<0}\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "case (Suc dm)"], ["proof (state)\nthis:\n  \\<lbrakk>dm \\<le> length b; length ?p = length b;\n   \\<And>d.\n      d < dm \\<Longrightarrow>\n      odd (ix ?p d) \\<and>\n      lv b d \\<le> lv ?p d \\<and>\n      ix ?p d < (ix b d + 1) * 2 ^ (lv ?p d - lv b d) \\<and>\n      (ix b d - 1) * 2 ^ (lv ?p d - lv b d) < ix ?p d;\n   \\<And>d.\n      \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n      \\<Longrightarrow> ?p ! d = b ! d\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> grid b {0..<dm}\n  Suc dm \\<le> length b\n  length p = length b\n  ?d < Suc dm \\<Longrightarrow>\n  odd (ix p ?d) \\<and>\n  lv b ?d \\<le> lv p ?d \\<and>\n  ix p ?d < (ix b ?d + 1) * 2 ^ (lv p ?d - lv b ?d) \\<and>\n  (ix b ?d - 1) * 2 ^ (lv p ?d - lv b ?d) < ix p ?d\n  \\<lbrakk>Suc dm \\<le> ?d; ?d < length b\\<rbrakk>\n  \\<Longrightarrow> p ! ?d = b ! ?d\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "hence \"dm \\<le> length b\"\n    and \"dm < length p\""], ["proof (prove)\nusing this:\n  \\<lbrakk>dm \\<le> length b; length ?p = length b;\n   \\<And>d.\n      d < dm \\<Longrightarrow>\n      odd (ix ?p d) \\<and>\n      lv b d \\<le> lv ?p d \\<and>\n      ix ?p d < (ix b d + 1) * 2 ^ (lv ?p d - lv b d) \\<and>\n      (ix b d - 1) * 2 ^ (lv ?p d - lv b d) < ix ?p d;\n   \\<And>d.\n      \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n      \\<Longrightarrow> ?p ! d = b ! d\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> grid b {0..<dm}\n  Suc dm \\<le> length b\n  length p = length b\n  ?d < Suc dm \\<Longrightarrow>\n  odd (ix p ?d) \\<and>\n  lv b ?d \\<le> lv p ?d \\<and>\n  ix p ?d < (ix b ?d + 1) * 2 ^ (lv p ?d - lv b ?d) \\<and>\n  (ix b ?d - 1) * 2 ^ (lv p ?d - lv b ?d) < ix p ?d\n  \\<lbrakk>Suc dm \\<le> ?d; ?d < length b\\<rbrakk>\n  \\<Longrightarrow> p ! ?d = b ! ?d\n\ngoal (1 subgoal):\n 1. dm \\<le> length b &&& dm < length p", "by auto"], ["proof (state)\nthis:\n  dm \\<le> length b\n  dm < length p\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "let ?p = \"p[dm := b ! dm]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "note \\<open>dm \\<le> length b\\<close>"], ["proof (state)\nthis:\n  dm \\<le> length b\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "moreover"], ["proof (state)\nthis:\n  dm \\<le> length b\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "have \"length ?p = length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (p[dm := b ! dm]) = length b", "using \\<open>length p = length b\\<close>"], ["proof (prove)\nusing this:\n  length p = length b\n\ngoal (1 subgoal):\n 1. length (p[dm := b ! dm]) = length b", "by simp"], ["proof (state)\nthis:\n  length (p[dm := b ! dm]) = length b\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "moreover"], ["proof (state)\nthis:\n  length (p[dm := b ! dm]) = length b\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "{"], ["proof (state)\nthis:\n  length (p[dm := b ! dm]) = length b\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "assume \"d < dm\""], ["proof (state)\nthis:\n  d < dm\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "hence *: \"d < Suc dm\" and \"dm \\<noteq> d\""], ["proof (prove)\nusing this:\n  d < dm\n\ngoal (1 subgoal):\n 1. d < Suc dm &&& dm \\<noteq> d", "by auto"], ["proof (state)\nthis:\n  d < Suc dm\n  dm \\<noteq> d\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "have \"?p ! d = p ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p[dm := b ! dm] ! d = p ! d", "by (rule nth_list_update_neq[OF \\<open>dm \\<noteq> d\\<close>])"], ["proof (state)\nthis:\n  p[dm := b ! dm] ! d = p ! d\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "hence \"?bounded ?p d\""], ["proof (prove)\nusing this:\n  p[dm := b ! dm] ! d = p ! d\n\ngoal (1 subgoal):\n 1. odd (ix (p[dm := b ! dm]) d) \\<and>\n    lv b d \\<le> lv (p[dm := b ! dm]) d \\<and>\n    ix (p[dm := b ! dm]) d\n    < (ix b d + 1) * 2 ^ (lv (p[dm := b ! dm]) d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (p[dm := b ! dm]) d - lv b d)\n    < ix (p[dm := b ! dm]) d", "using Suc.prems(3)[OF *] lv_def ix_def"], ["proof (prove)\nusing this:\n  p[dm := b ! dm] ! d = p ! d\n  odd (ix p d) \\<and>\n  lv b d \\<le> lv p d \\<and>\n  ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n  (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d\n  lv ?p ?d = fst (?p ! ?d)\n  ix ?p ?d = snd (?p ! ?d)\n\ngoal (1 subgoal):\n 1. odd (ix (p[dm := b ! dm]) d) \\<and>\n    lv b d \\<le> lv (p[dm := b ! dm]) d \\<and>\n    ix (p[dm := b ! dm]) d\n    < (ix b d + 1) * 2 ^ (lv (p[dm := b ! dm]) d - lv b d) \\<and>\n    (ix b d - 1) * 2 ^ (lv (p[dm := b ! dm]) d - lv b d)\n    < ix (p[dm := b ! dm]) d", "by simp"], ["proof (state)\nthis:\n  odd (ix (p[dm := b ! dm]) d) \\<and>\n  lv b d \\<le> lv (p[dm := b ! dm]) d \\<and>\n  ix (p[dm := b ! dm]) d\n  < (ix b d + 1) * 2 ^ (lv (p[dm := b ! dm]) d - lv b d) \\<and>\n  (ix b d - 1) * 2 ^ (lv (p[dm := b ! dm]) d - lv b d)\n  < ix (p[dm := b ! dm]) d\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "}"], ["proof (state)\nthis:\n  ?d2 < dm \\<Longrightarrow>\n  odd (ix (p[dm := b ! dm]) ?d2) \\<and>\n  lv b ?d2 \\<le> lv (p[dm := b ! dm]) ?d2 \\<and>\n  ix (p[dm := b ! dm]) ?d2\n  < (ix b ?d2 + 1) * 2 ^ (lv (p[dm := b ! dm]) ?d2 - lv b ?d2) \\<and>\n  (ix b ?d2 - 1) * 2 ^ (lv (p[dm := b ! dm]) ?d2 - lv b ?d2)\n  < ix (p[dm := b ! dm]) ?d2\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "moreover"], ["proof (state)\nthis:\n  ?d2 < dm \\<Longrightarrow>\n  odd (ix (p[dm := b ! dm]) ?d2) \\<and>\n  lv b ?d2 \\<le> lv (p[dm := b ! dm]) ?d2 \\<and>\n  ix (p[dm := b ! dm]) ?d2\n  < (ix b ?d2 + 1) * 2 ^ (lv (p[dm := b ! dm]) ?d2 - lv b ?d2) \\<and>\n  (ix b ?d2 - 1) * 2 ^ (lv (p[dm := b ! dm]) ?d2 - lv b ?d2)\n  < ix (p[dm := b ! dm]) ?d2\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "{"], ["proof (state)\nthis:\n  ?d2 < dm \\<Longrightarrow>\n  odd (ix (p[dm := b ! dm]) ?d2) \\<and>\n  lv b ?d2 \\<le> lv (p[dm := b ! dm]) ?d2 \\<and>\n  ix (p[dm := b ! dm]) ?d2\n  < (ix b ?d2 + 1) * 2 ^ (lv (p[dm := b ! dm]) ?d2 - lv b ?d2) \\<and>\n  (ix b ?d2 - 1) * 2 ^ (lv (p[dm := b ! dm]) ?d2 - lv b ?d2)\n  < ix (p[dm := b ! dm]) ?d2\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "assume \"dm \\<le> d\" and \"d < length b\""], ["proof (state)\nthis:\n  dm \\<le> d\n  d < length b\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "have \"?p ! d = b ! d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p[dm := b ! dm] ! d = b ! d", "proof (cases \"d = dm\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d = dm \\<Longrightarrow> p[dm := b ! dm] ! d = b ! d\n 2. d \\<noteq> dm \\<Longrightarrow> p[dm := b ! dm] ! d = b ! d", "case True"], ["proof (state)\nthis:\n  d = dm\n\ngoal (2 subgoals):\n 1. d = dm \\<Longrightarrow> p[dm := b ! dm] ! d = b ! d\n 2. d \\<noteq> dm \\<Longrightarrow> p[dm := b ! dm] ! d = b ! d", "thus ?thesis"], ["proof (prove)\nusing this:\n  d = dm\n\ngoal (1 subgoal):\n 1. p[dm := b ! dm] ! d = b ! d", "using \\<open>d < length b\\<close> \\<open>length p = length b\\<close>"], ["proof (prove)\nusing this:\n  d = dm\n  d < length b\n  length p = length b\n\ngoal (1 subgoal):\n 1. p[dm := b ! dm] ! d = b ! d", "by auto"], ["proof (state)\nthis:\n  p[dm := b ! dm] ! d = b ! d\n\ngoal (1 subgoal):\n 1. d \\<noteq> dm \\<Longrightarrow> p[dm := b ! dm] ! d = b ! d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<noteq> dm \\<Longrightarrow> p[dm := b ! dm] ! d = b ! d", "case False"], ["proof (state)\nthis:\n  d \\<noteq> dm\n\ngoal (1 subgoal):\n 1. d \\<noteq> dm \\<Longrightarrow> p[dm := b ! dm] ! d = b ! d", "hence \"Suc dm \\<le> d\""], ["proof (prove)\nusing this:\n  d \\<noteq> dm\n\ngoal (1 subgoal):\n 1. Suc dm \\<le> d", "using \\<open>dm \\<le> d\\<close>"], ["proof (prove)\nusing this:\n  d \\<noteq> dm\n  dm \\<le> d\n\ngoal (1 subgoal):\n 1. Suc dm \\<le> d", "by auto"], ["proof (state)\nthis:\n  Suc dm \\<le> d\n\ngoal (1 subgoal):\n 1. d \\<noteq> dm \\<Longrightarrow> p[dm := b ! dm] ! d = b ! d", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc dm \\<le> d\n\ngoal (1 subgoal):\n 1. p[dm := b ! dm] ! d = b ! d", "using Suc.prems(4) \\<open>d < length b\\<close>"], ["proof (prove)\nusing this:\n  Suc dm \\<le> d\n  \\<lbrakk>Suc dm \\<le> ?d; ?d < length b\\<rbrakk>\n  \\<Longrightarrow> p ! ?d = b ! ?d\n  d < length b\n\ngoal (1 subgoal):\n 1. p[dm := b ! dm] ! d = b ! d", "by auto"], ["proof (state)\nthis:\n  p[dm := b ! dm] ! d = b ! d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p[dm := b ! dm] ! d = b ! d\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>dm \\<le> ?d2; ?d2 < length b\\<rbrakk>\n  \\<Longrightarrow> p[dm := b ! dm] ! ?d2 = b ! ?d2\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "ultimately"], ["proof (chain)\npicking this:\n  dm \\<le> length b\n  length (p[dm := b ! dm]) = length b\n  ?d2 < dm \\<Longrightarrow>\n  odd (ix (p[dm := b ! dm]) ?d2) \\<and>\n  lv b ?d2 \\<le> lv (p[dm := b ! dm]) ?d2 \\<and>\n  ix (p[dm := b ! dm]) ?d2\n  < (ix b ?d2 + 1) * 2 ^ (lv (p[dm := b ! dm]) ?d2 - lv b ?d2) \\<and>\n  (ix b ?d2 - 1) * 2 ^ (lv (p[dm := b ! dm]) ?d2 - lv b ?d2)\n  < ix (p[dm := b ! dm]) ?d2\n  \\<lbrakk>dm \\<le> ?d2; ?d2 < length b\\<rbrakk>\n  \\<Longrightarrow> p[dm := b ! dm] ! ?d2 = b ! ?d2", "have *: \"?p \\<in> grid b {0..<dm}\""], ["proof (prove)\nusing this:\n  dm \\<le> length b\n  length (p[dm := b ! dm]) = length b\n  ?d2 < dm \\<Longrightarrow>\n  odd (ix (p[dm := b ! dm]) ?d2) \\<and>\n  lv b ?d2 \\<le> lv (p[dm := b ! dm]) ?d2 \\<and>\n  ix (p[dm := b ! dm]) ?d2\n  < (ix b ?d2 + 1) * 2 ^ (lv (p[dm := b ! dm]) ?d2 - lv b ?d2) \\<and>\n  (ix b ?d2 - 1) * 2 ^ (lv (p[dm := b ! dm]) ?d2 - lv b ?d2)\n  < ix (p[dm := b ! dm]) ?d2\n  \\<lbrakk>dm \\<le> ?d2; ?d2 < length b\\<rbrakk>\n  \\<Longrightarrow> p[dm := b ! dm] ! ?d2 = b ! ?d2\n\ngoal (1 subgoal):\n 1. p[dm := b ! dm] \\<in> grid b {0..<dm}", "by (auto intro!: Suc.hyps)"], ["proof (state)\nthis:\n  p[dm := b ! dm] \\<in> grid b {0..<dm}\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "have \"lv b dm \\<le> lv p dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv b dm \\<le> lv p dm", "using Suc.prems(3)[OF lessI]"], ["proof (prove)\nusing this:\n  odd (ix p dm) \\<and>\n  lv b dm \\<le> lv p dm \\<and>\n  ix p dm < (ix b dm + 1) * 2 ^ (lv p dm - lv b dm) \\<and>\n  (ix b dm - 1) * 2 ^ (lv p dm - lv b dm) < ix p dm\n\ngoal (1 subgoal):\n 1. lv b dm \\<le> lv p dm", "by simp"], ["proof (state)\nthis:\n  lv b dm \\<le> lv p dm\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "have [simp]: \"lv ?p dm = lv b dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lv (p[dm := b ! dm]) dm = lv b dm", "using lv_def \\<open>dm < length p\\<close>"], ["proof (prove)\nusing this:\n  lv ?p ?d = fst (?p ! ?d)\n  dm < length p\n\ngoal (1 subgoal):\n 1. lv (p[dm := b ! dm]) dm = lv b dm", "by auto"], ["proof (state)\nthis:\n  lv (p[dm := b ! dm]) dm = lv b dm\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "have [simp]: \"ix ?p dm = ix b dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ix (p[dm := b ! dm]) dm = ix b dm", "using ix_def \\<open>dm < length p\\<close>"], ["proof (prove)\nusing this:\n  ix ?p ?d = snd (?p ! ?d)\n  dm < length p\n\ngoal (1 subgoal):\n 1. ix (p[dm := b ! dm]) dm = ix b dm", "by auto"], ["proof (state)\nthis:\n  ix (p[dm := b ! dm]) dm = ix b dm\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "have [simp]: \"p[dm := (lv p dm, ix p dm)] = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p[dm := (lv p dm, ix p dm)] = p", "using lv_def ix_def \\<open>dm < length p\\<close>"], ["proof (prove)\nusing this:\n  lv ?p ?d = fst (?p ! ?d)\n  ix ?p ?d = snd (?p ! ?d)\n  dm < length p\n\ngoal (1 subgoal):\n 1. p[dm := (lv p dm, ix p dm)] = p", "by auto"], ["proof (state)\nthis:\n  p[dm := (lv p dm, ix p dm)] = p\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "have \"dm < length ?p\" and\n    [simp]: \"lv b dm + (lv p dm - lv b dm) = lv p dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dm < length (p[dm := b ! dm]) &&&\n    lv b dm + (lv p dm - lv b dm) = lv p dm", "using \\<open>dm < length p\\<close> \\<open>lv b dm \\<le> lv p dm\\<close>"], ["proof (prove)\nusing this:\n  dm < length p\n  lv b dm \\<le> lv p dm\n\ngoal (1 subgoal):\n 1. dm < length (p[dm := b ! dm]) &&&\n    lv b dm + (lv p dm - lv b dm) = lv p dm", "by auto"], ["proof (state)\nthis:\n  dm < length (p[dm := b ! dm])\n  lv b dm + (lv p dm - lv b dm) = lv p dm\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "from grid_single_dimensional_specification[OF this(1),\n    where l=\"lv p dm\" and i=\"ix p dm\" and l'=\"lv p dm - lv b dm\", simplified]"], ["proof (chain)\npicking this:\n  \\<lbrakk>odd (ix p dm); ix p dm < (ix b dm + 1) * 2 ^ (lv p dm - lv b dm);\n   (ix b dm - 1) * 2 ^ (lv p dm - lv b dm) < ix p dm\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid (p[dm := b ! dm]) {dm}", "have \"p \\<in> grid ?p {dm}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>odd (ix p dm); ix p dm < (ix b dm + 1) * 2 ^ (lv p dm - lv b dm);\n   (ix b dm - 1) * 2 ^ (lv p dm - lv b dm) < ix p dm\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid (p[dm := b ! dm]) {dm}\n\ngoal (1 subgoal):\n 1. p \\<in> grid (p[dm := b ! dm]) {dm}", "using Suc.prems(3)[OF lessI]"], ["proof (prove)\nusing this:\n  \\<lbrakk>odd (ix p dm); ix p dm < (ix b dm + 1) * 2 ^ (lv p dm - lv b dm);\n   (ix b dm - 1) * 2 ^ (lv p dm - lv b dm) < ix p dm\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid (p[dm := b ! dm]) {dm}\n  odd (ix p dm) \\<and>\n  lv b dm \\<le> lv p dm \\<and>\n  ix p dm < (ix b dm + 1) * 2 ^ (lv p dm - lv b dm) \\<and>\n  (ix b dm - 1) * 2 ^ (lv p dm - lv b dm) < ix p dm\n\ngoal (1 subgoal):\n 1. p \\<in> grid (p[dm := b ! dm]) {dm}", "by blast"], ["proof (state)\nthis:\n  p \\<in> grid (p[dm := b ! dm]) {dm}\n\ngoal (1 subgoal):\n 1. \\<And>dm p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>dm \\<le> length b; length p = length b;\n                    \\<And>d.\n                       d < dm \\<Longrightarrow>\n                       odd (ix p d) \\<and>\n                       lv b d \\<le> lv p d \\<and>\n                       ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n                       (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n                    \\<And>d.\n                       \\<lbrakk>dm \\<le> d; d < length b\\<rbrakk>\n                       \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n                   \\<Longrightarrow> p \\<in> grid b {0..<dm};\n        Suc dm \\<le> length b; length p = length b;\n        \\<And>d.\n           d < Suc dm \\<Longrightarrow>\n           odd (ix p d) \\<and>\n           lv b d \\<le> lv p d \\<and>\n           ix p d < (ix b d + 1) * 2 ^ (lv p d - lv b d) \\<and>\n           (ix b d - 1) * 2 ^ (lv p d - lv b d) < ix p d;\n        \\<And>d.\n           \\<lbrakk>Suc dm \\<le> d; d < length b\\<rbrakk>\n           \\<Longrightarrow> p ! d = b ! d\\<rbrakk>\n       \\<Longrightarrow> p \\<in> grid b {0..<Suc dm}", "from grid_transitive[OF this *]"], ["proof (chain)\npicking this:\n  \\<lbrakk>{0..<dm} \\<subseteq> ?ds''; {dm} \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid b ?ds''", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>{0..<dm} \\<subseteq> ?ds''; {dm} \\<subseteq> ?ds''\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid b ?ds''\n\ngoal (1 subgoal):\n 1. p \\<in> grid b {0..<Suc dm}", "by auto"], ["proof (state)\nthis:\n  p \\<in> grid b {0..<Suc dm}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sparsegrid:\n  \"sparsegrid dm lm = {p.\n    length p = dm \\<and> level p < lm \\<and>\n    (\\<forall> d < dm. odd (ix p d) \\<and> 0 < ix p d \\<and> ix p d < 2^(lv p d + 1))}\"\n  (is \"_ = ?set\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sparsegrid dm lm =\n    {p. length p = dm \\<and>\n        level p < lm \\<and>\n        (\\<forall>d<dm.\n            odd (ix p d) \\<and>\n            0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}", "proof (rule equalityI[OF subsetI subsetI])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "assume *: \"p \\<in> sparsegrid dm lm\""], ["proof (state)\nthis:\n  p \\<in> sparsegrid dm lm\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "hence \"length p = dm\" and \"level p < lm\""], ["proof (prove)\nusing this:\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. length p = dm &&& level p < lm", "unfolding sparsegrid_def"], ["proof (prove)\nusing this:\n  p \\<in> lgrid (start dm) {0..<dm} lm\n\ngoal (1 subgoal):\n 1. length p = dm &&& level p < lm", "by auto"], ["proof (state)\nthis:\n  length p = dm\n  level p < lm\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "moreover"], ["proof (state)\nthis:\n  length p = dm\n  level p < lm\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "{"], ["proof (state)\nthis:\n  length p = dm\n  level p < lm\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "fix d"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "assume \"d < dm\""], ["proof (state)\nthis:\n  d < dm\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "hence **: \"p \\<in> grid (start dm) {0..<dm}\" and \"d < length (start dm)\""], ["proof (prove)\nusing this:\n  d < dm\n\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) {0..<dm} &&& d < length (start dm)", "using *"], ["proof (prove)\nusing this:\n  d < dm\n  p \\<in> sparsegrid dm lm\n\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) {0..<dm} &&& d < length (start dm)", "unfolding sparsegrid_def"], ["proof (prove)\nusing this:\n  d < dm\n  p \\<in> lgrid (start dm) {0..<dm} lm\n\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) {0..<dm} &&& d < length (start dm)", "by auto"], ["proof (state)\nthis:\n  p \\<in> grid (start dm) {0..<dm}\n  d < length (start dm)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "have \"odd (ix p d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (ix p d)", "proof (cases \"p ! d = start dm ! d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p ! d = start dm ! d \\<Longrightarrow> odd (ix p d)\n 2. p ! d \\<noteq> start dm ! d \\<Longrightarrow> odd (ix p d)", "case True"], ["proof (state)\nthis:\n  p ! d = start dm ! d\n\ngoal (2 subgoals):\n 1. p ! d = start dm ! d \\<Longrightarrow> odd (ix p d)\n 2. p ! d \\<noteq> start dm ! d \\<Longrightarrow> odd (ix p d)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p ! d = start dm ! d\n\ngoal (1 subgoal):\n 1. odd (ix p d)", "unfolding start_def"], ["proof (prove)\nusing this:\n  p ! d = replicate dm (0, 1) ! d\n\ngoal (1 subgoal):\n 1. odd (ix p d)", "using \\<open>d < dm\\<close> ix_def"], ["proof (prove)\nusing this:\n  p ! d = replicate dm (0, 1) ! d\n  d < dm\n  ix ?p ?d = snd (?p ! ?d)\n\ngoal (1 subgoal):\n 1. odd (ix p d)", "by auto"], ["proof (state)\nthis:\n  odd (ix p d)\n\ngoal (1 subgoal):\n 1. p ! d \\<noteq> start dm ! d \\<Longrightarrow> odd (ix p d)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p ! d \\<noteq> start dm ! d \\<Longrightarrow> odd (ix p d)", "case False"], ["proof (state)\nthis:\n  p ! d \\<noteq> start dm ! d\n\ngoal (1 subgoal):\n 1. p ! d \\<noteq> start dm ! d \\<Longrightarrow> odd (ix p d)", "from grid_odd[OF _ this **]"], ["proof (chain)\npicking this:\n  d < length (start dm) \\<Longrightarrow> odd (ix p d)", "show ?thesis"], ["proof (prove)\nusing this:\n  d < length (start dm) \\<Longrightarrow> odd (ix p d)\n\ngoal (1 subgoal):\n 1. odd (ix p d)", "using \\<open>d < dm\\<close>"], ["proof (prove)\nusing this:\n  d < length (start dm) \\<Longrightarrow> odd (ix p d)\n  d < dm\n\ngoal (1 subgoal):\n 1. odd (ix p d)", "by auto"], ["proof (state)\nthis:\n  odd (ix p d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  odd (ix p d)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "hence \"odd (ix p d) \\<and> 0 < ix p d \\<and> ix p d < 2^(lv p d + 1)\""], ["proof (prove)\nusing this:\n  odd (ix p d)\n\ngoal (1 subgoal):\n 1. odd (ix p d) \\<and> 0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1)", "using grid_estimate[OF \\<open>d < length (start dm)\\<close> **]"], ["proof (prove)\nusing this:\n  odd (ix p d)\n  ix p d < (ix (start dm) d + 1) * 2 ^ (lv p d - lv (start dm) d) \\<and>\n  (ix (start dm) d - 1) * 2 ^ (lv p d - lv (start dm) d) < ix p d\n\ngoal (1 subgoal):\n 1. odd (ix p d) \\<and> 0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1)", "unfolding ix_def lv_def start_def"], ["proof (prove)\nusing this:\n  odd (snd (p ! d))\n  snd (p ! d)\n  < (snd (replicate dm (0, 1) ! d) + 1) *\n    2 ^ (fst (p ! d) - fst (replicate dm (0, 1) ! d)) \\<and>\n  (snd (replicate dm (0, 1) ! d) - 1) *\n  2 ^ (fst (p ! d) - fst (replicate dm (0, 1) ! d))\n  < snd (p ! d)\n\ngoal (1 subgoal):\n 1. odd (snd (p ! d)) \\<and>\n    0 < snd (p ! d) \\<and> snd (p ! d) < 2 ^ (fst (p ! d) + 1)", "using \\<open>d < dm\\<close>"], ["proof (prove)\nusing this:\n  odd (snd (p ! d))\n  snd (p ! d)\n  < (snd (replicate dm (0, 1) ! d) + 1) *\n    2 ^ (fst (p ! d) - fst (replicate dm (0, 1) ! d)) \\<and>\n  (snd (replicate dm (0, 1) ! d) - 1) *\n  2 ^ (fst (p ! d) - fst (replicate dm (0, 1) ! d))\n  < snd (p ! d)\n  d < dm\n\ngoal (1 subgoal):\n 1. odd (snd (p ! d)) \\<and>\n    0 < snd (p ! d) \\<and> snd (p ! d) < 2 ^ (fst (p ! d) + 1)", "by auto"], ["proof (state)\nthis:\n  odd (ix p d) \\<and> 0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "}"], ["proof (state)\nthis:\n  ?d2 < dm \\<Longrightarrow>\n  odd (ix p ?d2) \\<and> 0 < ix p ?d2 \\<and> ix p ?d2 < 2 ^ (lv p ?d2 + 1)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sparsegrid dm lm \\<Longrightarrow>\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n 2. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "ultimately"], ["proof (chain)\npicking this:\n  length p = dm\n  level p < lm\n  ?d2 < dm \\<Longrightarrow>\n  odd (ix p ?d2) \\<and> 0 < ix p ?d2 \\<and> ix p ?d2 < 2 ^ (lv p ?d2 + 1)", "show \"p \\<in> ?set\""], ["proof (prove)\nusing this:\n  length p = dm\n  level p < lm\n  ?d2 < dm \\<Longrightarrow>\n  odd (ix p ?d2) \\<and> 0 < ix p ?d2 \\<and> ix p ?d2 < 2 ^ (lv p ?d2 + 1)\n\ngoal (1 subgoal):\n 1. p \\<in> {p. length p = dm \\<and>\n                level p < lm \\<and>\n                (\\<forall>d<dm.\n                    odd (ix p d) \\<and>\n                    0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}", "using sparsegrid_def lgrid_def"], ["proof (prove)\nusing this:\n  length p = dm\n  level p < lm\n  ?d2 < dm \\<Longrightarrow>\n  odd (ix p ?d2) \\<and> 0 < ix p ?d2 \\<and> ix p ?d2 < 2 ^ (lv p ?d2 + 1)\n  sparsegrid ?dm ?lm = lgrid (start ?dm) {0..<?dm} ?lm\n  lgrid ?b ?ds ?lm = {p \\<in> grid ?b ?ds. level p < ?lm}\n\ngoal (1 subgoal):\n 1. p \\<in> {p. length p = dm \\<and>\n                level p < lm \\<and>\n                (\\<forall>d<dm.\n                    odd (ix p d) \\<and>\n                    0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}", "by auto"], ["proof (state)\nthis:\n  p \\<in> {p. length p = dm \\<and>\n              level p < lm \\<and>\n              (\\<forall>d<dm.\n                  odd (ix p d) \\<and>\n                  0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "assume \"p \\<in> ?set\""], ["proof (state)\nthis:\n  p \\<in> {p. length p = dm \\<and>\n              level p < lm \\<and>\n              (\\<forall>d<dm.\n                  odd (ix p d) \\<and>\n                  0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "with grid_multi_dimensional_specification[of dm \"start dm\" p]"], ["proof (chain)\npicking this:\n  \\<lbrakk>dm \\<le> length (start dm); length p = length (start dm);\n   \\<And>d.\n      d < dm \\<Longrightarrow>\n      odd (ix p d) \\<and>\n      lv (start dm) d \\<le> lv p d \\<and>\n      ix p d < (ix (start dm) d + 1) * 2 ^ (lv p d - lv (start dm) d) \\<and>\n      (ix (start dm) d - 1) * 2 ^ (lv p d - lv (start dm) d) < ix p d;\n   \\<And>d.\n      \\<lbrakk>dm \\<le> d; d < length (start dm)\\<rbrakk>\n      \\<Longrightarrow> p ! d = start dm ! d\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid (start dm) {0..<dm}\n  p \\<in> {p. length p = dm \\<and>\n              level p < lm \\<and>\n              (\\<forall>d<dm.\n                  odd (ix p d) \\<and>\n                  0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}", "have \"p \\<in> grid (start dm) {0..<dm}\" and \"level p < lm\""], ["proof (prove)\nusing this:\n  \\<lbrakk>dm \\<le> length (start dm); length p = length (start dm);\n   \\<And>d.\n      d < dm \\<Longrightarrow>\n      odd (ix p d) \\<and>\n      lv (start dm) d \\<le> lv p d \\<and>\n      ix p d < (ix (start dm) d + 1) * 2 ^ (lv p d - lv (start dm) d) \\<and>\n      (ix (start dm) d - 1) * 2 ^ (lv p d - lv (start dm) d) < ix p d;\n   \\<And>d.\n      \\<lbrakk>dm \\<le> d; d < length (start dm)\\<rbrakk>\n      \\<Longrightarrow> p ! d = start dm ! d\\<rbrakk>\n  \\<Longrightarrow> p \\<in> grid (start dm) {0..<dm}\n  p \\<in> {p. length p = dm \\<and>\n              level p < lm \\<and>\n              (\\<forall>d<dm.\n                  odd (ix p d) \\<and>\n                  0 < ix p d \\<and> ix p d < 2 ^ (lv p d + 1))}\n\ngoal (1 subgoal):\n 1. p \\<in> grid (start dm) {0..<dm} &&& level p < lm", "by auto"], ["proof (state)\nthis:\n  p \\<in> grid (start dm) {0..<dm}\n  level p < lm\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. length p = dm \\<and>\n                   level p < lm \\<and>\n                   (\\<forall>d<dm.\n                       odd (ix p d) \\<and>\n                       0 < ix p d \\<and>\n                       ix p d < 2 ^ (lv p d + 1))} \\<Longrightarrow>\n       x \\<in> sparsegrid dm lm", "thus \"p \\<in> sparsegrid dm lm\""], ["proof (prove)\nusing this:\n  p \\<in> grid (start dm) {0..<dm}\n  level p < lm\n\ngoal (1 subgoal):\n 1. p \\<in> sparsegrid dm lm", "unfolding sparsegrid_def lgrid_def"], ["proof (prove)\nusing this:\n  p \\<in> grid (start dm) {0..<dm}\n  level p < lm\n\ngoal (1 subgoal):\n 1. p \\<in> {p \\<in> grid (start dm) {0..<dm}. level p < lm}", "by auto"], ["proof (state)\nthis:\n  p \\<in> sparsegrid dm lm\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}