{"file_name": "/home/qj213/afp-2021-10-22/thys/Functional_Ordered_Resolution_Prover/IsaFoR_Term.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Functional_Ordered_Resolution_Prover", "problem_names": ["lemma vars_clause_mono: \"S \\<subseteq># C \\<Longrightarrow> vars_clause S \\<subseteq> vars_clause C\"", "lemma is_ground_atm_is_ground_on_var:\n  assumes \"is_ground_atm (A \\<cdot> \\<sigma>)\" and \"v \\<in> vars_term A\"\n  shows \"is_ground_atm (\\<sigma> v)\"", "lemma is_ground_lit_is_ground_on_var:\n  assumes ground_lit: \"is_ground_lit (subst_lit L \\<sigma>)\" and v_in_L: \"v \\<in> vars_lit L\"\n  shows \"is_ground_atm (\\<sigma> v)\"", "lemma is_ground_cls_is_ground_on_var:\n  assumes\n    ground_clause: \"is_ground_cls (subst_cls C \\<sigma>)\" and\n    v_in_C: \"v \\<in> vars_clause C\"\n  shows \"is_ground_atm (\\<sigma> v)\"", "lemma is_ground_cls_list_is_ground_on_var:\n  assumes ground_list: \"is_ground_cls_list (subst_cls_list Cs \\<sigma>)\"\n    and v_in_Cs: \"v \\<in> vars_clause_list Cs\"\n  shows \"is_ground_atm (\\<sigma> v)\"", "lemma same_on_vars_lit:\n  assumes \"\\<forall>v \\<in> vars_lit L. \\<sigma> v = \\<tau> v\"\n  shows \"subst_lit L \\<sigma> = subst_lit L \\<tau>\"", "lemma in_list_of_mset_in_S:\n  assumes \"i < length (list_of_mset S)\"\n  shows \"list_of_mset S ! i \\<in># S\"", "lemma same_on_vars_clause:\n  assumes \"\\<forall>v \\<in> vars_clause S. \\<sigma> v = \\<tau> v\"\n  shows \"subst_cls S \\<sigma> = subst_cls S \\<tau>\"", "lemma vars_partitioned_var_disjoint:\n  assumes \"vars_partitioned Cs\"\n  shows \"var_disjoint Cs\"", "lemma vars_in_instance_in_range_term:\n  \"vars_term (subst_atm_abbrev A \\<sigma>) \\<subseteq> Union (image vars_term (range \\<sigma>))\"", "lemma vars_in_instance_in_range_lit: \"vars_lit (subst_lit L \\<sigma>) \\<subseteq> Union (image vars_term (range \\<sigma>))\"", "lemma vars_in_instance_in_range_cls:\n  \"vars_clause (subst_cls C \\<sigma>) \\<subseteq> Union (image vars_term (range \\<sigma>))\"", "lemma len_renamings_apart: \"length (renamings_apart Cs) = length Cs\"", "lemma renamings_apart_is_Var: \"\\<forall>\\<sigma> \\<in> set (renamings_apart Cs). \\<forall>x. is_Var (\\<sigma> x)\"", "lemma renamings_apart_inj: \"\\<forall>\\<sigma> \\<in> set (renamings_apart Cs). inj \\<sigma>\"", "lemma finite_vars_clause[simp]: \"finite (vars_clause x)\"", "lemma finite_vars_clause_list[simp]: \"finite (vars_clause_list Cs)\"", "lemma Suc_Max_notin_set: \"finite X \\<Longrightarrow> Suc (v + Max (insert 0 X)) \\<notin> X\"", "lemma vars_partitioned_Nil[simp]: \"vars_partitioned []\"", "lemma subst_cls_lists_Nil[simp]: \"subst_cls_lists Cs [] = []\"", "lemma vars_clause_hd_partitioned_from_tl:\n  assumes \"Cs \\<noteq>[]\"\n  shows \"vars_clause (hd (subst_cls_lists Cs (renamings_apart Cs)))\n    \\<inter> vars_clause_list (tl (subst_cls_lists Cs (renamings_apart Cs))) = {}\"", "lemma vars_partitioned_renamings_apart: \"vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))\"", "lemma class_linorder_compare: \"class.linorder (le_of_comp compare) (lt_of_comp compare)\"", "lemma unifies_all_pairs_iff:\n  \"(\\<forall>p \\<in> set (pairs xs). fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) \\<longleftrightarrow> (\\<forall>a \\<in> set xs. \\<forall>b \\<in> set xs. a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)\"", "lemma in_pair_in_set:\n  assumes \"(A,B) \\<in> set ((pairs As))\"\n  shows \"A \\<in> set As \\<and> B \\<in> set As\"", "lemma in_pairs_sorted_list_of_set_in_set:\n  assumes\n    \"finite AAA\"\n    \"\\<forall>AA \\<in> AAA. finite AA\"\n    \"AB_pairs \\<in> (pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA\" and\n    \"(A :: _ :: compare, B) \\<in> set AB_pairs\"\n  shows \"\\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA\"", "lemma unifiers_Pairs:\n  assumes\n    \"finite AAA\" and\n    \"\\<forall>AA \\<in> AAA. finite AA\"\n  shows \"unifiers (set (Pairs AAA)) = {\\<sigma>. is_unifiers \\<sigma> AAA}\"", "lemma kbo_code[code]: \"kbo s t =\n  (let wt = weight t; ws = weight s in\n  if vars_term_ms (KBO.SCF t) \\<subseteq># vars_term_ms (KBO.SCF s) \\<and> wt \\<le> ws\n  then\n    (if wt < ws then (True, True)\n    else\n      (case s of\n        Var y \\<Rightarrow> (False, case t of Var x \\<Rightarrow> True | Fun g ts \\<Rightarrow> ts = [] \\<and> least weights g)\n      | Fun f ss \\<Rightarrow>\n          (case t of\n            Var x \\<Rightarrow> (True, True)\n          | Fun g ts \\<Rightarrow>\n              if pr_strict weights (f, length ss) (g, length ts) then (True, True)\n              else if (f, length ss) = (g, length ts) then lex_ext_unbounded kbo ss ts\n              else (False, False))))\n  else (False, False))\"", "lemma less_kbo_gtotal: \"ground s \\<Longrightarrow> ground t \\<Longrightarrow> s = t \\<or> less_kbo s t \\<or> less_kbo t s\"", "lemma less_kbo_subst:\n  fixes \\<sigma> :: \"('f :: weighted, 'v) subst\"\n  shows \"less_kbo s t \\<Longrightarrow> less_kbo (s \\<cdot> \\<sigma>) (t \\<cdot> \\<sigma>)\"", "lemma wfP_less_kbo: \"wfP less_kbo\"", "lemma less_trm_extension: \"{(s,t). less_kbo s t} \\<subseteq> leq_term\"", "lemma less_trm_well_order: \"well_order leq_term\"", "lemma leq_term_minus_Id: \"leq_term - Id = {(x,y). x < y}\"", "lemma less_term_alt: \"(<) = in_rel (leq_term - Id)\"", "lemma ground_less_less_kbo: \"ground s \\<Longrightarrow> ground t \\<Longrightarrow> s < t \\<Longrightarrow> less_kbo s t\"", "lemma less_kbo_less: \"less_kbo s t \\<Longrightarrow> s < t\"", "lemma is_ground_atm_ground: \"is_ground_atm t \\<longleftrightarrow> ground t\""], "translations": [["", "lemma vars_clause_mono: \"S \\<subseteq># C \\<Longrightarrow> vars_clause S \\<subseteq> vars_clause C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq># C \\<Longrightarrow>\n    vars_clause S \\<subseteq> vars_clause C", "unfolding vars_clause_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq># C \\<Longrightarrow>\n    \\<Union> (set_mset (image_mset vars_lit S))\n    \\<subseteq> \\<Union> (set_mset (image_mset vars_lit C))", "by auto"], ["", "interpretation substitution_ops \"(\\<cdot>)\" Var \"(\\<circ>\\<^sub>s)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma is_ground_atm_is_ground_on_var:\n  assumes \"is_ground_atm (A \\<cdot> \\<sigma>)\" and \"v \\<in> vars_term A\"\n  shows \"is_ground_atm (\\<sigma> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "using assms"], ["proof (prove)\nusing this:\n  is_ground_atm (A \\<cdot> \\<sigma>)\n  v \\<in> vars_term A\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "proof (induction A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_ground_atm (Var x \\<cdot> \\<sigma>);\n        v \\<in> vars_term (Var x)\\<rbrakk>\n       \\<Longrightarrow> is_ground_atm (\\<sigma> v)\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    is_ground_atm (x2a \\<cdot> \\<sigma>);\n                    v \\<in> vars_term x2a\\<rbrakk>\n                   \\<Longrightarrow> is_ground_atm (\\<sigma> v);\n        is_ground_atm (Fun x1a x2 \\<cdot> \\<sigma>);\n        v \\<in> vars_term (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> is_ground_atm (\\<sigma> v)", "case (Var x)"], ["proof (state)\nthis:\n  is_ground_atm (Var x \\<cdot> \\<sigma>)\n  v \\<in> vars_term (Var x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_ground_atm (Var x \\<cdot> \\<sigma>);\n        v \\<in> vars_term (Var x)\\<rbrakk>\n       \\<Longrightarrow> is_ground_atm (\\<sigma> v)\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    is_ground_atm (x2a \\<cdot> \\<sigma>);\n                    v \\<in> vars_term x2a\\<rbrakk>\n                   \\<Longrightarrow> is_ground_atm (\\<sigma> v);\n        is_ground_atm (Fun x1a x2 \\<cdot> \\<sigma>);\n        v \\<in> vars_term (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> is_ground_atm (\\<sigma> v)", "then"], ["proof (chain)\npicking this:\n  is_ground_atm (Var x \\<cdot> \\<sigma>)\n  v \\<in> vars_term (Var x)", "show ?case"], ["proof (prove)\nusing this:\n  is_ground_atm (Var x \\<cdot> \\<sigma>)\n  v \\<in> vars_term (Var x)\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "by auto"], ["proof (state)\nthis:\n  is_ground_atm (\\<sigma> v)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    is_ground_atm (x2a \\<cdot> \\<sigma>);\n                    v \\<in> vars_term x2a\\<rbrakk>\n                   \\<Longrightarrow> is_ground_atm (\\<sigma> v);\n        is_ground_atm (Fun x1a x2 \\<cdot> \\<sigma>);\n        v \\<in> vars_term (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> is_ground_atm (\\<sigma> v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    is_ground_atm (x2a \\<cdot> \\<sigma>);\n                    v \\<in> vars_term x2a\\<rbrakk>\n                   \\<Longrightarrow> is_ground_atm (\\<sigma> v);\n        is_ground_atm (Fun x1a x2 \\<cdot> \\<sigma>);\n        v \\<in> vars_term (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> is_ground_atm (\\<sigma> v)", "case (Fun f ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set ts; is_ground_atm (?x2a \\<cdot> \\<sigma>);\n   v \\<in> vars_term ?x2a\\<rbrakk>\n  \\<Longrightarrow> is_ground_atm (\\<sigma> v)\n  is_ground_atm (Fun f ts \\<cdot> \\<sigma>)\n  v \\<in> vars_term (Fun f ts)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    is_ground_atm (x2a \\<cdot> \\<sigma>);\n                    v \\<in> vars_term x2a\\<rbrakk>\n                   \\<Longrightarrow> is_ground_atm (\\<sigma> v);\n        is_ground_atm (Fun x1a x2 \\<cdot> \\<sigma>);\n        v \\<in> vars_term (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> is_ground_atm (\\<sigma> v)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set ts; is_ground_atm (?x2a \\<cdot> \\<sigma>);\n   v \\<in> vars_term ?x2a\\<rbrakk>\n  \\<Longrightarrow> is_ground_atm (\\<sigma> v)\n  is_ground_atm (Fun f ts \\<cdot> \\<sigma>)\n  v \\<in> vars_term (Fun f ts)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set ts; is_ground_atm (?x2a \\<cdot> \\<sigma>);\n   v \\<in> vars_term ?x2a\\<rbrakk>\n  \\<Longrightarrow> is_ground_atm (\\<sigma> v)\n  is_ground_atm (Fun f ts \\<cdot> \\<sigma>)\n  v \\<in> vars_term (Fun f ts)\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "unfolding is_ground_atm_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set ts;\n   \\<forall>\\<sigma>'.\n      ?x2a \\<cdot> \\<sigma> =\n      subst_atm_abbrev (?x2a \\<cdot> \\<sigma>) \\<sigma>';\n   v \\<in> vars_term ?x2a\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<sigma>'.\n                       \\<sigma> v = subst_atm_abbrev (\\<sigma> v) \\<sigma>'\n  \\<forall>\\<sigma>'.\n     Fun f ts \\<cdot> \\<sigma> =\n     subst_atm_abbrev (Fun f ts \\<cdot> \\<sigma>) \\<sigma>'\n  v \\<in> vars_term (Fun f ts)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>'. \\<sigma> v = subst_atm_abbrev (\\<sigma> v) \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  is_ground_atm (\\<sigma> v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_ground_lit_is_ground_on_var:\n  assumes ground_lit: \"is_ground_lit (subst_lit L \\<sigma>)\" and v_in_L: \"v \\<in> vars_lit L\"\n  shows \"is_ground_atm (\\<sigma> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "let ?A = \"atm_of L\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "from v_in_L"], ["proof (chain)\npicking this:\n  v \\<in> vars_lit L", "have A_p: \"v \\<in> vars_term ?A\""], ["proof (prove)\nusing this:\n  v \\<in> vars_lit L\n\ngoal (1 subgoal):\n 1. v \\<in> vars_lit L", "by auto"], ["proof (state)\nthis:\n  v \\<in> vars_lit L\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "then"], ["proof (chain)\npicking this:\n  v \\<in> vars_lit L", "have \"is_ground_atm (?A \\<cdot> \\<sigma>)\""], ["proof (prove)\nusing this:\n  v \\<in> vars_lit L\n\ngoal (1 subgoal):\n 1. is_ground_atm (subst_atm_abbrev (atm_of L) \\<sigma>)", "using ground_lit"], ["proof (prove)\nusing this:\n  v \\<in> vars_lit L\n  is_ground_lit (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. is_ground_atm (subst_atm_abbrev (atm_of L) \\<sigma>)", "unfolding is_ground_lit_def"], ["proof (prove)\nusing this:\n  v \\<in> vars_lit L\n  is_ground_atm (atm_of (subst_lit L \\<sigma>))\n\ngoal (1 subgoal):\n 1. is_ground_atm (subst_atm_abbrev (atm_of L) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  is_ground_atm (subst_atm_abbrev (atm_of L) \\<sigma>)\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "then"], ["proof (chain)\npicking this:\n  is_ground_atm (subst_atm_abbrev (atm_of L) \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_ground_atm (subst_atm_abbrev (atm_of L) \\<sigma>)\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "using A_p is_ground_atm_is_ground_on_var"], ["proof (prove)\nusing this:\n  is_ground_atm (subst_atm_abbrev (atm_of L) \\<sigma>)\n  v \\<in> vars_lit L\n  \\<lbrakk>is_ground_atm (?A \\<cdot> ?\\<sigma>);\n   ?v \\<in> vars_term ?A\\<rbrakk>\n  \\<Longrightarrow> is_ground_atm (?\\<sigma> ?v)\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "by metis"], ["proof (state)\nthis:\n  is_ground_atm (\\<sigma> v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_ground_cls_is_ground_on_var:\n  assumes\n    ground_clause: \"is_ground_cls (subst_cls C \\<sigma>)\" and\n    v_in_C: \"v \\<in> vars_clause C\"\n  shows \"is_ground_atm (\\<sigma> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "from v_in_C"], ["proof (chain)\npicking this:\n  v \\<in> vars_clause C", "obtain L where L_p: \"L \\<in># C\" \"v \\<in> vars_lit L\""], ["proof (prove)\nusing this:\n  v \\<in> vars_clause C\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in># C; v \\<in> vars_lit L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding vars_clause_def"], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set_mset (image_mset vars_lit C))\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in># C; v \\<in> vars_lit L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L \\<in># C\n  v \\<in> vars_lit L\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "then"], ["proof (chain)\npicking this:\n  L \\<in># C\n  v \\<in> vars_lit L", "have \"is_ground_lit (subst_lit L \\<sigma>)\""], ["proof (prove)\nusing this:\n  L \\<in># C\n  v \\<in> vars_lit L\n\ngoal (1 subgoal):\n 1. is_ground_lit (subst_lit L \\<sigma>)", "using ground_clause"], ["proof (prove)\nusing this:\n  L \\<in># C\n  v \\<in> vars_lit L\n  is_ground_cls (subst_cls C \\<sigma>)\n\ngoal (1 subgoal):\n 1. is_ground_lit (subst_lit L \\<sigma>)", "unfolding is_ground_cls_def subst_cls_def"], ["proof (prove)\nusing this:\n  L \\<in># C\n  v \\<in> vars_lit L\n  \\<forall>L.\n     L \\<in># {#subst_lit A \\<sigma>. A \\<in># C#} \\<longrightarrow>\n     is_ground_lit L\n\ngoal (1 subgoal):\n 1. is_ground_lit (subst_lit L \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  is_ground_lit (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "then"], ["proof (chain)\npicking this:\n  is_ground_lit (subst_lit L \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_ground_lit (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "using L_p is_ground_lit_is_ground_on_var"], ["proof (prove)\nusing this:\n  is_ground_lit (subst_lit L \\<sigma>)\n  L \\<in># C\n  v \\<in> vars_lit L\n  \\<lbrakk>is_ground_lit (subst_lit ?L ?\\<sigma>);\n   ?v \\<in> vars_lit ?L\\<rbrakk>\n  \\<Longrightarrow> is_ground_atm (?\\<sigma> ?v)\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "by metis"], ["proof (state)\nthis:\n  is_ground_atm (\\<sigma> v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_ground_cls_list_is_ground_on_var:\n  assumes ground_list: \"is_ground_cls_list (subst_cls_list Cs \\<sigma>)\"\n    and v_in_Cs: \"v \\<in> vars_clause_list Cs\"\n  shows \"is_ground_atm (\\<sigma> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "from v_in_Cs"], ["proof (chain)\npicking this:\n  v \\<in> vars_clause_list Cs", "obtain C where C_p: \"C \\<in> set Cs\" \"v \\<in> vars_clause C\""], ["proof (prove)\nusing this:\n  v \\<in> vars_clause_list Cs\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> set Cs; v \\<in> vars_clause C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding vars_clause_list_def"], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (vars_clause ` set Cs)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> set Cs; v \\<in> vars_clause C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C \\<in> set Cs\n  v \\<in> vars_clause C\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "then"], ["proof (chain)\npicking this:\n  C \\<in> set Cs\n  v \\<in> vars_clause C", "have \"is_ground_cls (subst_cls C \\<sigma>)\""], ["proof (prove)\nusing this:\n  C \\<in> set Cs\n  v \\<in> vars_clause C\n\ngoal (1 subgoal):\n 1. is_ground_cls (subst_cls C \\<sigma>)", "using ground_list"], ["proof (prove)\nusing this:\n  C \\<in> set Cs\n  v \\<in> vars_clause C\n  is_ground_cls_list (subst_cls_list Cs \\<sigma>)\n\ngoal (1 subgoal):\n 1. is_ground_cls (subst_cls C \\<sigma>)", "unfolding is_ground_cls_list_def subst_cls_list_def"], ["proof (prove)\nusing this:\n  C \\<in> set Cs\n  v \\<in> vars_clause C\n  Ball (set (map (\\<lambda>A. subst_cls A \\<sigma>) Cs)) is_ground_cls\n\ngoal (1 subgoal):\n 1. is_ground_cls (subst_cls C \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  is_ground_cls (subst_cls C \\<sigma>)\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "then"], ["proof (chain)\npicking this:\n  is_ground_cls (subst_cls C \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_ground_cls (subst_cls C \\<sigma>)\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "using C_p is_ground_cls_is_ground_on_var"], ["proof (prove)\nusing this:\n  is_ground_cls (subst_cls C \\<sigma>)\n  C \\<in> set Cs\n  v \\<in> vars_clause C\n  \\<lbrakk>is_ground_cls (subst_cls ?C ?\\<sigma>);\n   ?v \\<in> vars_clause ?C\\<rbrakk>\n  \\<Longrightarrow> is_ground_atm (?\\<sigma> ?v)\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<sigma> v)", "by metis"], ["proof (state)\nthis:\n  is_ground_atm (\\<sigma> v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma same_on_vars_lit:\n  assumes \"\\<forall>v \\<in> vars_lit L. \\<sigma> v = \\<tau> v\"\n  shows \"subst_lit L \\<sigma> = subst_lit L \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit L \\<tau>", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_lit L. \\<sigma> v = \\<tau> v\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit L \\<tau>", "proof (induction L)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>v\\<in>vars_lit (Pos x).\n          \\<sigma> v = \\<tau> v \\<Longrightarrow>\n       subst_lit (Pos x) \\<sigma> = subst_lit (Pos x) \\<tau>\n 2. \\<And>x.\n       \\<forall>v\\<in>vars_lit (Neg x).\n          \\<sigma> v = \\<tau> v \\<Longrightarrow>\n       subst_lit (Neg x) \\<sigma> = subst_lit (Neg x) \\<tau>", "case (Pos x)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>vars_lit (Pos x). \\<sigma> v = \\<tau> v\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>v\\<in>vars_lit (Pos x).\n          \\<sigma> v = \\<tau> v \\<Longrightarrow>\n       subst_lit (Pos x) \\<sigma> = subst_lit (Pos x) \\<tau>\n 2. \\<And>x.\n       \\<forall>v\\<in>vars_lit (Neg x).\n          \\<sigma> v = \\<tau> v \\<Longrightarrow>\n       subst_lit (Neg x) \\<sigma> = subst_lit (Neg x) \\<tau>", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>vars_lit (Pos x). \\<sigma> v = \\<tau> v", "have \"\\<forall>v \\<in> vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow> subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_lit (Pos x). \\<sigma> v = \\<tau> v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n    subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>", "using term_subst_eq"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_lit (Pos x). \\<sigma> v = \\<tau> v\n  (\\<And>x.\n      x \\<in> vars_term ?t \\<Longrightarrow>\n      ?\\<sigma> x = ?\\<tau> x) \\<Longrightarrow>\n  ?t \\<cdot> ?\\<sigma> = ?t \\<cdot> ?\\<tau>\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n    subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>", "by metis+"], ["proof (state)\nthis:\n  \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n  subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>v\\<in>vars_lit (Pos x).\n          \\<sigma> v = \\<tau> v \\<Longrightarrow>\n       subst_lit (Pos x) \\<sigma> = subst_lit (Pos x) \\<tau>\n 2. \\<And>x.\n       \\<forall>v\\<in>vars_lit (Neg x).\n          \\<sigma> v = \\<tau> v \\<Longrightarrow>\n       subst_lit (Neg x) \\<sigma> = subst_lit (Neg x) \\<tau>", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n  subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n  subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>\n\ngoal (1 subgoal):\n 1. subst_lit (Pos x) \\<sigma> = subst_lit (Pos x) \\<tau>", "unfolding subst_lit_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n  subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>\n\ngoal (1 subgoal):\n 1. Pos x \\<cdot>lit \\<sigma> = Pos x \\<cdot>lit \\<tau>", "using Pos"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n  subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>\n  \\<forall>v\\<in>vars_lit (Pos x). \\<sigma> v = \\<tau> v\n\ngoal (1 subgoal):\n 1. Pos x \\<cdot>lit \\<sigma> = Pos x \\<cdot>lit \\<tau>", "by auto"], ["proof (state)\nthis:\n  subst_lit (Pos x) \\<sigma> = subst_lit (Pos x) \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>v\\<in>vars_lit (Neg x).\n          \\<sigma> v = \\<tau> v \\<Longrightarrow>\n       subst_lit (Neg x) \\<sigma> = subst_lit (Neg x) \\<tau>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>v\\<in>vars_lit (Neg x).\n          \\<sigma> v = \\<tau> v \\<Longrightarrow>\n       subst_lit (Neg x) \\<sigma> = subst_lit (Neg x) \\<tau>", "case (Neg x)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>vars_lit (Neg x). \\<sigma> v = \\<tau> v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>v\\<in>vars_lit (Neg x).\n          \\<sigma> v = \\<tau> v \\<Longrightarrow>\n       subst_lit (Neg x) \\<sigma> = subst_lit (Neg x) \\<tau>", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>vars_lit (Neg x). \\<sigma> v = \\<tau> v", "have \"\\<forall>v \\<in> vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow> subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_lit (Neg x). \\<sigma> v = \\<tau> v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n    subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>", "using term_subst_eq"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_lit (Neg x). \\<sigma> v = \\<tau> v\n  (\\<And>x.\n      x \\<in> vars_term ?t \\<Longrightarrow>\n      ?\\<sigma> x = ?\\<tau> x) \\<Longrightarrow>\n  ?t \\<cdot> ?\\<sigma> = ?t \\<cdot> ?\\<tau>\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n    subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>", "by metis+"], ["proof (state)\nthis:\n  \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n  subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>v\\<in>vars_lit (Neg x).\n          \\<sigma> v = \\<tau> v \\<Longrightarrow>\n       subst_lit (Neg x) \\<sigma> = subst_lit (Neg x) \\<tau>", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n  subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n  subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>\n\ngoal (1 subgoal):\n 1. subst_lit (Neg x) \\<sigma> = subst_lit (Neg x) \\<tau>", "unfolding subst_lit_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n  subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>\n\ngoal (1 subgoal):\n 1. Neg x \\<cdot>lit \\<sigma> = Neg x \\<cdot>lit \\<tau>", "using Neg"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_term x. \\<sigma> v = \\<tau> v \\<Longrightarrow>\n  subst_atm_abbrev x \\<sigma> = subst_atm_abbrev x \\<tau>\n  \\<forall>v\\<in>vars_lit (Neg x). \\<sigma> v = \\<tau> v\n\ngoal (1 subgoal):\n 1. Neg x \\<cdot>lit \\<sigma> = Neg x \\<cdot>lit \\<tau>", "by auto"], ["proof (state)\nthis:\n  subst_lit (Neg x) \\<sigma> = subst_lit (Neg x) \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_list_of_mset_in_S:\n  assumes \"i < length (list_of_mset S)\"\n  shows \"list_of_mset S ! i \\<in># S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_mset S ! i \\<in># S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_mset S ! i \\<in># S", "from assms"], ["proof (chain)\npicking this:\n  i < length (list_of_mset S)", "have \"list_of_mset S ! i \\<in> set (list_of_mset S)\""], ["proof (prove)\nusing this:\n  i < length (list_of_mset S)\n\ngoal (1 subgoal):\n 1. list_of_mset S ! i \\<in> set (list_of_mset S)", "by auto"], ["proof (state)\nthis:\n  list_of_mset S ! i \\<in> set (list_of_mset S)\n\ngoal (1 subgoal):\n 1. list_of_mset S ! i \\<in># S", "then"], ["proof (chain)\npicking this:\n  list_of_mset S ! i \\<in> set (list_of_mset S)", "have \"list_of_mset S ! i \\<in># mset (list_of_mset S)\""], ["proof (prove)\nusing this:\n  list_of_mset S ! i \\<in> set (list_of_mset S)\n\ngoal (1 subgoal):\n 1. list_of_mset S ! i \\<in># mset (list_of_mset S)", "by (meson in_multiset_in_set)"], ["proof (state)\nthis:\n  list_of_mset S ! i \\<in># mset (list_of_mset S)\n\ngoal (1 subgoal):\n 1. list_of_mset S ! i \\<in># S", "then"], ["proof (chain)\npicking this:\n  list_of_mset S ! i \\<in># mset (list_of_mset S)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_of_mset S ! i \\<in># mset (list_of_mset S)\n\ngoal (1 subgoal):\n 1. list_of_mset S ! i \\<in># S", "by auto"], ["proof (state)\nthis:\n  list_of_mset S ! i \\<in># S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma same_on_vars_clause:\n  assumes \"\\<forall>v \\<in> vars_clause S. \\<sigma> v = \\<tau> v\"\n  shows \"subst_cls S \\<sigma> = subst_cls S \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cls S \\<sigma> = subst_cls S \\<tau>", "by (smt assms image_eqI image_mset_cong2 mem_simps(9) same_on_vars_lit set_image_mset\n      subst_cls_def vars_clause_def)"], ["", "lemma vars_partitioned_var_disjoint:\n  assumes \"vars_partitioned Cs\"\n  shows \"var_disjoint Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var_disjoint Cs", "unfolding var_disjoint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<longrightarrow>\n       (\\<exists>\\<tau>.\n           \\<forall>i<length Cs.\n              \\<forall>S.\n                 S \\<subseteq># Cs ! i \\<longrightarrow>\n                 subst_cls S (\\<sigma>s ! i) = subst_cls S \\<tau>)", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          \\<forall>i<length Cs.\n             \\<forall>S.\n                S \\<subseteq># Cs ! i \\<longrightarrow>\n                subst_cls S (\\<sigma>s ! i) = subst_cls S \\<tau>", "fix \\<sigma>s :: \\<open>('b \\<Rightarrow> ('a, 'b) term) list\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          \\<forall>i<length Cs.\n             \\<forall>S.\n                S \\<subseteq># Cs ! i \\<longrightarrow>\n                subst_cls S (\\<sigma>s ! i) = subst_cls S \\<tau>", "assume \"length \\<sigma>s = length Cs\""], ["proof (state)\nthis:\n  length \\<sigma>s = length Cs\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          \\<forall>i<length Cs.\n             \\<forall>S.\n                S \\<subseteq># Cs ! i \\<longrightarrow>\n                subst_cls S (\\<sigma>s ! i) = subst_cls S \\<tau>", "with assms[unfolded vars_partitioned_def] Fun_More.fun_merge[of \"map vars_clause Cs\" \"nth \\<sigma>s\"]"], ["proof (chain)\npicking this:\n  \\<forall>i<length Cs.\n     \\<forall>j<length Cs.\n        i \\<noteq> j \\<longrightarrow>\n        vars_clause (Cs ! i) \\<inter> vars_clause (Cs ! j) = {}\n  \\<forall>i<length (map vars_clause Cs).\n     \\<forall>j<length (map vars_clause Cs).\n        i \\<noteq> j \\<longrightarrow>\n        map vars_clause Cs ! i \\<inter> map vars_clause Cs ! j =\n        {} \\<Longrightarrow>\n  \\<exists>\\<sigma>.\n     \\<forall>i<length (map vars_clause Cs).\n        \\<forall>x\\<in>map vars_clause Cs ! i.\n           \\<sigma> x = (\\<sigma>s ! i) x\n  length \\<sigma>s = length Cs", "obtain \\<sigma> where\n    \\<sigma>_p: \"\\<forall>i < length (map vars_clause Cs). \\<forall>x \\<in> map vars_clause Cs ! i. \\<sigma> x = (\\<sigma>s ! i) x\""], ["proof (prove)\nusing this:\n  \\<forall>i<length Cs.\n     \\<forall>j<length Cs.\n        i \\<noteq> j \\<longrightarrow>\n        vars_clause (Cs ! i) \\<inter> vars_clause (Cs ! j) = {}\n  \\<forall>i<length (map vars_clause Cs).\n     \\<forall>j<length (map vars_clause Cs).\n        i \\<noteq> j \\<longrightarrow>\n        map vars_clause Cs ! i \\<inter> map vars_clause Cs ! j =\n        {} \\<Longrightarrow>\n  \\<exists>\\<sigma>.\n     \\<forall>i<length (map vars_clause Cs).\n        \\<forall>x\\<in>map vars_clause Cs ! i.\n           \\<sigma> x = (\\<sigma>s ! i) x\n  length \\<sigma>s = length Cs\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<forall>i<length (map vars_clause Cs).\n           \\<forall>x\\<in>map vars_clause Cs ! i.\n              \\<sigma> x = (\\<sigma>s ! i) x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length (map vars_clause Cs).\n     \\<forall>x\\<in>map vars_clause Cs ! i. \\<sigma> x = (\\<sigma>s ! i) x\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          \\<forall>i<length Cs.\n             \\<forall>S.\n                S \\<subseteq># Cs ! i \\<longrightarrow>\n                subst_cls S (\\<sigma>s ! i) = subst_cls S \\<tau>", "have \"\\<forall>i < length Cs. \\<forall>S. S \\<subseteq># Cs ! i \\<longrightarrow> subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length Cs.\n       \\<forall>S.\n          S \\<subseteq># Cs ! i \\<longrightarrow>\n          subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>", "proof (rule, rule, rule, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i S.\n       \\<lbrakk>i < length Cs; S \\<subseteq># Cs ! i\\<rbrakk>\n       \\<Longrightarrow> subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>", "fix i :: nat and S :: \"('a, 'b) term literal multiset\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i S.\n       \\<lbrakk>i < length Cs; S \\<subseteq># Cs ! i\\<rbrakk>\n       \\<Longrightarrow> subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>", "assume\n      \"i < length Cs\" and\n      \"S \\<subseteq># Cs ! i\""], ["proof (state)\nthis:\n  i < length Cs\n  S \\<subseteq># Cs ! i\n\ngoal (1 subgoal):\n 1. \\<And>i S.\n       \\<lbrakk>i < length Cs; S \\<subseteq># Cs ! i\\<rbrakk>\n       \\<Longrightarrow> subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>", "then"], ["proof (chain)\npicking this:\n  i < length Cs\n  S \\<subseteq># Cs ! i", "have \"\\<forall>v \\<in> vars_clause S. (\\<sigma>s ! i) v = \\<sigma> v\""], ["proof (prove)\nusing this:\n  i < length Cs\n  S \\<subseteq># Cs ! i\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>vars_clause S. (\\<sigma>s ! i) v = \\<sigma> v", "using vars_clause_mono[of S \"Cs ! i\"] \\<sigma>_p"], ["proof (prove)\nusing this:\n  i < length Cs\n  S \\<subseteq># Cs ! i\n  S \\<subseteq># Cs ! i \\<Longrightarrow>\n  vars_clause S \\<subseteq> vars_clause (Cs ! i)\n  \\<forall>i<length (map vars_clause Cs).\n     \\<forall>x\\<in>map vars_clause Cs ! i. \\<sigma> x = (\\<sigma>s ! i) x\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>vars_clause S. (\\<sigma>s ! i) v = \\<sigma> v", "by auto"], ["proof (state)\nthis:\n  \\<forall>v\\<in>vars_clause S. (\\<sigma>s ! i) v = \\<sigma> v\n\ngoal (1 subgoal):\n 1. \\<And>i S.\n       \\<lbrakk>i < length Cs; S \\<subseteq># Cs ! i\\<rbrakk>\n       \\<Longrightarrow> subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>vars_clause S. (\\<sigma>s ! i) v = \\<sigma> v", "show \"subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_clause S. (\\<sigma>s ! i) v = \\<sigma> v\n\ngoal (1 subgoal):\n 1. subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>", "using same_on_vars_clause"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_clause S. (\\<sigma>s ! i) v = \\<sigma> v\n  \\<forall>v\\<in>vars_clause ?S. ?\\<sigma> v = ?\\<tau> v \\<Longrightarrow>\n  subst_cls ?S ?\\<sigma> = subst_cls ?S ?\\<tau>\n\ngoal (1 subgoal):\n 1. subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length Cs.\n     \\<forall>S.\n        S \\<subseteq># Cs ! i \\<longrightarrow>\n        subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>s.\n       length \\<sigma>s = length Cs \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          \\<forall>i<length Cs.\n             \\<forall>S.\n                S \\<subseteq># Cs ! i \\<longrightarrow>\n                subst_cls S (\\<sigma>s ! i) = subst_cls S \\<tau>", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length Cs.\n     \\<forall>S.\n        S \\<subseteq># Cs ! i \\<longrightarrow>\n        subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>", "show \"\\<exists>\\<tau>. \\<forall>i<length Cs. \\<forall>S. S \\<subseteq># Cs ! i \\<longrightarrow> subst_cls S (\\<sigma>s ! i) = subst_cls S \\<tau>\""], ["proof (prove)\nusing this:\n  \\<forall>i<length Cs.\n     \\<forall>S.\n        S \\<subseteq># Cs ! i \\<longrightarrow>\n        subst_cls S (\\<sigma>s ! i) = subst_cls S \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>.\n       \\<forall>i<length Cs.\n          \\<forall>S.\n             S \\<subseteq># Cs ! i \\<longrightarrow>\n             subst_cls S (\\<sigma>s ! i) = subst_cls S \\<tau>", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<tau>.\n     \\<forall>i<length Cs.\n        \\<forall>S.\n           S \\<subseteq># Cs ! i \\<longrightarrow>\n           subst_cls S (\\<sigma>s ! i) = subst_cls S \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_in_instance_in_range_term:\n  \"vars_term (subst_atm_abbrev A \\<sigma>) \\<subseteq> Union (image vars_term (range \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_term (subst_atm_abbrev A \\<sigma>)\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "by (induction A) auto"], ["", "lemma vars_in_instance_in_range_lit: \"vars_lit (subst_lit L \\<sigma>) \\<subseteq> Union (image vars_term (range \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_lit (subst_lit L \\<sigma>)\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "proof (induction L)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       vars_lit (subst_lit (Pos x) \\<sigma>)\n       \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n 2. \\<And>x.\n       vars_lit (subst_lit (Neg x) \\<sigma>)\n       \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "case (Pos A)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       vars_lit (subst_lit (Pos x) \\<sigma>)\n       \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n 2. \\<And>x.\n       vars_lit (subst_lit (Neg x) \\<sigma>)\n       \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "have \"vars_term (A \\<cdot> \\<sigma>) \\<subseteq> Union (image vars_term (range \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_term (subst_atm_abbrev A \\<sigma>)\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "using vars_in_instance_in_range_term[of A \\<sigma>]"], ["proof (prove)\nusing this:\n  vars_term (subst_atm_abbrev A \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_term (subst_atm_abbrev A \\<sigma>)\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  vars_term (subst_atm_abbrev A \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       vars_lit (subst_lit (Pos x) \\<sigma>)\n       \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n 2. \\<And>x.\n       vars_lit (subst_lit (Neg x) \\<sigma>)\n       \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  vars_term (subst_atm_abbrev A \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "show ?case"], ["proof (prove)\nusing this:\n  vars_term (subst_atm_abbrev A \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_lit (subst_lit (Pos A) \\<sigma>)\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  vars_lit (subst_lit (Pos A) \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       vars_lit (subst_lit (Neg x) \\<sigma>)\n       \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       vars_lit (subst_lit (Neg x) \\<sigma>)\n       \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "case (Neg A)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x.\n       vars_lit (subst_lit (Neg x) \\<sigma>)\n       \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "have \"vars_term (A \\<cdot> \\<sigma>) \\<subseteq> Union (image vars_term (range \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_term (subst_atm_abbrev A \\<sigma>)\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "using vars_in_instance_in_range_term[of A \\<sigma>]"], ["proof (prove)\nusing this:\n  vars_term (subst_atm_abbrev A \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_term (subst_atm_abbrev A \\<sigma>)\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  vars_term (subst_atm_abbrev A \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       vars_lit (subst_lit (Neg x) \\<sigma>)\n       \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  vars_term (subst_atm_abbrev A \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "show ?case"], ["proof (prove)\nusing this:\n  vars_term (subst_atm_abbrev A \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_lit (subst_lit (Neg A) \\<sigma>)\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  vars_lit (subst_lit (Neg A) \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_in_instance_in_range_cls:\n  \"vars_clause (subst_cls C \\<sigma>) \\<subseteq> Union (image vars_term (range \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_clause (subst_cls C \\<sigma>)\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "unfolding vars_clause_def subst_cls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_mset (image_mset vars_lit {#subst_lit A \\<sigma>. A \\<in># C#}))\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "using vars_in_instance_in_range_lit[of _ \\<sigma>]"], ["proof (prove)\nusing this:\n  vars_lit (subst_lit ?L \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (set_mset (image_mset vars_lit {#subst_lit A \\<sigma>. A \\<in># C#}))\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "by auto"], ["", "primrec renamings_apart :: \"('f, nat) term clause list \\<Rightarrow> (('f, nat) subst) list\" where\n  \"renamings_apart [] = []\"\n| \"renamings_apart (C # Cs) =\n   (let \\<sigma>s = renamings_apart Cs in\n      (\\<lambda>v. Var (v + Max (vars_clause_list (subst_cls_lists Cs \\<sigma>s) \\<union> {0}) + 1)) # \\<sigma>s)\""], ["", "definition var_map_of_subst :: \"('f, nat) subst \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"var_map_of_subst \\<sigma> v = the_Var (\\<sigma> v)\""], ["", "lemma len_renamings_apart: \"length (renamings_apart Cs) = length Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (renamings_apart Cs) = length Cs", "by (induction Cs) (auto simp: Let_def)"], ["", "lemma renamings_apart_is_Var: \"\\<forall>\\<sigma> \\<in> set (renamings_apart Cs). \\<forall>x. is_Var (\\<sigma> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<in>set (renamings_apart Cs).\n       \\<forall>x. is_Var (\\<sigma> x)", "by (induction Cs) (auto simp: Let_def)"], ["", "lemma renamings_apart_inj: \"\\<forall>\\<sigma> \\<in> set (renamings_apart Cs). inj \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<in>set (renamings_apart Cs). inj \\<sigma>", "proof (induction Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>\\<in>set (renamings_apart []). inj \\<sigma>\n 2. \\<And>a Cs.\n       \\<forall>\\<sigma>\\<in>set (renamings_apart Cs).\n          inj \\<sigma> \\<Longrightarrow>\n       \\<forall>\\<sigma>\\<in>set (renamings_apart (a # Cs)). inj \\<sigma>", "case (Cons a Cs)"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>\\<in>set (renamings_apart Cs). inj \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>\\<in>set (renamings_apart []). inj \\<sigma>\n 2. \\<And>a Cs.\n       \\<forall>\\<sigma>\\<in>set (renamings_apart Cs).\n          inj \\<sigma> \\<Longrightarrow>\n       \\<forall>\\<sigma>\\<in>set (renamings_apart (a # Cs)). inj \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<sigma>\\<in>set (renamings_apart Cs). inj \\<sigma>", "have \"inj (\\<lambda>v. Var (Suc (v + Max (vars_clause_list\n               (subst_cls_lists Cs (renamings_apart Cs)) \\<union> {0}))))\""], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>\\<in>set (renamings_apart Cs). inj \\<sigma>\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>v.\n            Var (Suc (v +\n                      Max (vars_clause_list\n                            (subst_cls_lists Cs\n                              (renamings_apart Cs)) \\<union>\n                           {0}))))", "by (meson add_right_imp_eq injI nat.inject term.inject(1))"], ["proof (state)\nthis:\n  inj (\\<lambda>v.\n          Var (Suc (v +\n                    Max (vars_clause_list\n                          (subst_cls_lists Cs (renamings_apart Cs)) \\<union>\n                         {0}))))\n\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>\\<in>set (renamings_apart []). inj \\<sigma>\n 2. \\<And>a Cs.\n       \\<forall>\\<sigma>\\<in>set (renamings_apart Cs).\n          inj \\<sigma> \\<Longrightarrow>\n       \\<forall>\\<sigma>\\<in>set (renamings_apart (a # Cs)). inj \\<sigma>", "then"], ["proof (chain)\npicking this:\n  inj (\\<lambda>v.\n          Var (Suc (v +\n                    Max (vars_clause_list\n                          (subst_cls_lists Cs (renamings_apart Cs)) \\<union>\n                         {0}))))", "show ?case"], ["proof (prove)\nusing this:\n  inj (\\<lambda>v.\n          Var (Suc (v +\n                    Max (vars_clause_list\n                          (subst_cls_lists Cs (renamings_apart Cs)) \\<union>\n                         {0}))))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<in>set (renamings_apart (a # Cs)). inj \\<sigma>", "using Cons"], ["proof (prove)\nusing this:\n  inj (\\<lambda>v.\n          Var (Suc (v +\n                    Max (vars_clause_list\n                          (subst_cls_lists Cs (renamings_apart Cs)) \\<union>\n                         {0}))))\n  \\<forall>\\<sigma>\\<in>set (renamings_apart Cs). inj \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<in>set (renamings_apart (a # Cs)). inj \\<sigma>", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>\\<in>set (renamings_apart (a # Cs)). inj \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<in>set (renamings_apart []). inj \\<sigma>", "qed auto"], ["", "lemma finite_vars_clause[simp]: \"finite (vars_clause x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (vars_clause x)", "unfolding vars_clause_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (set_mset (image_mset vars_lit x)))", "by auto"], ["", "lemma finite_vars_clause_list[simp]: \"finite (vars_clause_list Cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (vars_clause_list Cs)", "unfolding vars_clause_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (vars_clause ` set Cs))", "by (induction Cs) auto"], ["", "lemma Suc_Max_notin_set: \"finite X \\<Longrightarrow> Suc (v + Max (insert 0 X)) \\<notin> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> Suc (v + Max (insert 0 X)) \\<notin> X", "by (metis Max.boundedE Suc_n_not_le_n empty_iff finite.insertI le_add2 vimageE vimageI\n      vimage_Suc_insert_0)"], ["", "lemma vars_partitioned_Nil[simp]: \"vars_partitioned []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_partitioned []", "unfolding vars_partitioned_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length [].\n       \\<forall>j<length [].\n          i \\<noteq> j \\<longrightarrow>\n          vars_clause ([] ! i) \\<inter> vars_clause ([] ! j) = {}", "by auto"], ["", "lemma subst_cls_lists_Nil[simp]: \"subst_cls_lists Cs [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cls_lists Cs [] = []", "unfolding subst_cls_lists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map2.map2 subst_cls Cs [] = []", "by auto"], ["", "lemma vars_clause_hd_partitioned_from_tl:\n  assumes \"Cs \\<noteq>[]\"\n  shows \"vars_clause (hd (subst_cls_lists Cs (renamings_apart Cs)))\n    \\<inter> vars_clause_list (tl (subst_cls_lists Cs (renamings_apart Cs))) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_clause (hd (subst_cls_lists Cs (renamings_apart Cs))) \\<inter>\n    vars_clause_list (tl (subst_cls_lists Cs (renamings_apart Cs))) =\n    {}", "using assms"], ["proof (prove)\nusing this:\n  Cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. vars_clause (hd (subst_cls_lists Cs (renamings_apart Cs))) \\<inter>\n    vars_clause_list (tl (subst_cls_lists Cs (renamings_apart Cs))) =\n    {}", "proof (induction Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    vars_clause (hd (subst_cls_lists [] (renamings_apart []))) \\<inter>\n    vars_clause_list (tl (subst_cls_lists [] (renamings_apart []))) =\n    {}\n 2. \\<And>a Cs.\n       \\<lbrakk>Cs \\<noteq> [] \\<Longrightarrow>\n                vars_clause\n                 (hd (subst_cls_lists Cs (renamings_apart Cs))) \\<inter>\n                vars_clause_list\n                 (tl (subst_cls_lists Cs (renamings_apart Cs))) =\n                {};\n        a # Cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (hd (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) \\<inter>\n                         vars_clause_list\n                          (tl (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) =\n                         {}", "case (Cons C Cs)"], ["proof (state)\nthis:\n  Cs \\<noteq> [] \\<Longrightarrow>\n  vars_clause (hd (subst_cls_lists Cs (renamings_apart Cs))) \\<inter>\n  vars_clause_list (tl (subst_cls_lists Cs (renamings_apart Cs))) =\n  {}\n  C # Cs \\<noteq> []\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    vars_clause (hd (subst_cls_lists [] (renamings_apart []))) \\<inter>\n    vars_clause_list (tl (subst_cls_lists [] (renamings_apart []))) =\n    {}\n 2. \\<And>a Cs.\n       \\<lbrakk>Cs \\<noteq> [] \\<Longrightarrow>\n                vars_clause\n                 (hd (subst_cls_lists Cs (renamings_apart Cs))) \\<inter>\n                vars_clause_list\n                 (tl (subst_cls_lists Cs (renamings_apart Cs))) =\n                {};\n        a # Cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (hd (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) \\<inter>\n                         vars_clause_list\n                          (tl (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) =\n                         {}", "define \\<sigma>' :: \"nat \\<Rightarrow> nat\"\n    where \"\\<sigma>' = (\\<lambda>v. (Suc (v + Max ((vars_clause_list (subst_cls_lists Cs\n                        (renamings_apart Cs))) \\<union> {0}))))\""], ["proof (state)\nthis:\n  \\<sigma>' =\n  (\\<lambda>v.\n      Suc (v +\n           Max (vars_clause_list\n                 (subst_cls_lists Cs (renamings_apart Cs)) \\<union>\n                {0})))\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    vars_clause (hd (subst_cls_lists [] (renamings_apart []))) \\<inter>\n    vars_clause_list (tl (subst_cls_lists [] (renamings_apart []))) =\n    {}\n 2. \\<And>a Cs.\n       \\<lbrakk>Cs \\<noteq> [] \\<Longrightarrow>\n                vars_clause\n                 (hd (subst_cls_lists Cs (renamings_apart Cs))) \\<inter>\n                vars_clause_list\n                 (tl (subst_cls_lists Cs (renamings_apart Cs))) =\n                {};\n        a # Cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (hd (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) \\<inter>\n                         vars_clause_list\n                          (tl (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) =\n                         {}", "define \\<sigma> :: \"nat \\<Rightarrow> ('a, nat) term\"\n    where \"\\<sigma> = (\\<lambda>v. Var (\\<sigma>' v))\""], ["proof (state)\nthis:\n  \\<sigma> = (\\<lambda>v. Var (\\<sigma>' v))\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    vars_clause (hd (subst_cls_lists [] (renamings_apart []))) \\<inter>\n    vars_clause_list (tl (subst_cls_lists [] (renamings_apart []))) =\n    {}\n 2. \\<And>a Cs.\n       \\<lbrakk>Cs \\<noteq> [] \\<Longrightarrow>\n                vars_clause\n                 (hd (subst_cls_lists Cs (renamings_apart Cs))) \\<inter>\n                vars_clause_list\n                 (tl (subst_cls_lists Cs (renamings_apart Cs))) =\n                {};\n        a # Cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (hd (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) \\<inter>\n                         vars_clause_list\n                          (tl (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) =\n                         {}", "have \"vars_clause (subst_cls C \\<sigma>) \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_clause (subst_cls C \\<sigma>)\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "using vars_in_instance_in_range_cls[of C \"hd (renamings_apart (C # Cs))\"] \\<sigma>_def \\<sigma>'_def"], ["proof (prove)\nusing this:\n  vars_clause (subst_cls C (hd (renamings_apart (C # Cs))))\n  \\<subseteq> \\<Union> (vars_term ` range (hd (renamings_apart (C # Cs))))\n  \\<sigma> = (\\<lambda>v. Var (\\<sigma>' v))\n  \\<sigma>' =\n  (\\<lambda>v.\n      Suc (v +\n           Max (vars_clause_list\n                 (subst_cls_lists Cs (renamings_apart Cs)) \\<union>\n                {0})))\n\ngoal (1 subgoal):\n 1. vars_clause (subst_cls C \\<sigma>)\n    \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  vars_clause (subst_cls C \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    vars_clause (hd (subst_cls_lists [] (renamings_apart []))) \\<inter>\n    vars_clause_list (tl (subst_cls_lists [] (renamings_apart []))) =\n    {}\n 2. \\<And>a Cs.\n       \\<lbrakk>Cs \\<noteq> [] \\<Longrightarrow>\n                vars_clause\n                 (hd (subst_cls_lists Cs (renamings_apart Cs))) \\<inter>\n                vars_clause_list\n                 (tl (subst_cls_lists Cs (renamings_apart Cs))) =\n                {};\n        a # Cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (hd (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) \\<inter>\n                         vars_clause_list\n                          (tl (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) =\n                         {}", "moreover"], ["proof (state)\nthis:\n  vars_clause (subst_cls C \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    vars_clause (hd (subst_cls_lists [] (renamings_apart []))) \\<inter>\n    vars_clause_list (tl (subst_cls_lists [] (renamings_apart []))) =\n    {}\n 2. \\<And>a Cs.\n       \\<lbrakk>Cs \\<noteq> [] \\<Longrightarrow>\n                vars_clause\n                 (hd (subst_cls_lists Cs (renamings_apart Cs))) \\<inter>\n                vars_clause_list\n                 (tl (subst_cls_lists Cs (renamings_apart Cs))) =\n                {};\n        a # Cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (hd (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) \\<inter>\n                         vars_clause_list\n                          (tl (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) =\n                         {}", "have \"\\<Union> (vars_term ` range \\<sigma>)\n    \\<inter> vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (vars_term ` range \\<sigma>) \\<inter>\n    vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (vars_term ` range \\<sigma>) \\<inter>\n    vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n    {}", "have \"range \\<sigma>' \\<inter> vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range \\<sigma>' \\<inter>\n    vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n    {}", "unfolding \\<sigma>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range\n     (\\<lambda>v.\n         Suc (v +\n              Max (vars_clause_list\n                    (subst_cls_lists Cs (renamings_apart Cs)) \\<union>\n                   {0}))) \\<inter>\n    vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n    {}", "using Suc_Max_notin_set"], ["proof (prove)\nusing this:\n  finite ?X \\<Longrightarrow> Suc (?v + Max (insert 0 ?X)) \\<notin> ?X\n\ngoal (1 subgoal):\n 1. range\n     (\\<lambda>v.\n         Suc (v +\n              Max (vars_clause_list\n                    (subst_cls_lists Cs (renamings_apart Cs)) \\<union>\n                   {0}))) \\<inter>\n    vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n    {}", "by auto"], ["proof (state)\nthis:\n  range \\<sigma>' \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<Union> (vars_term ` range \\<sigma>) \\<inter>\n    vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n    {}", "then"], ["proof (chain)\npicking this:\n  range \\<sigma>' \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  range \\<sigma>' \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<Union> (vars_term ` range \\<sigma>) \\<inter>\n    vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n    {}", "unfolding \\<sigma>_def \\<sigma>'_def"], ["proof (prove)\nusing this:\n  range\n   (\\<lambda>v.\n       Suc (v +\n            Max (vars_clause_list\n                  (subst_cls_lists Cs (renamings_apart Cs)) \\<union>\n                 {0}))) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (vars_term `\n      range\n       (\\<lambda>v.\n           Var (Suc (v +\n                     Max (vars_clause_list\n                           (subst_cls_lists Cs\n                             (renamings_apart Cs)) \\<union>\n                          {0}))))) \\<inter>\n    vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n    {}", "by auto"], ["proof (state)\nthis:\n  \\<Union> (vars_term ` range \\<sigma>) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> (vars_term ` range \\<sigma>) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    vars_clause (hd (subst_cls_lists [] (renamings_apart []))) \\<inter>\n    vars_clause_list (tl (subst_cls_lists [] (renamings_apart []))) =\n    {}\n 2. \\<And>a Cs.\n       \\<lbrakk>Cs \\<noteq> [] \\<Longrightarrow>\n                vars_clause\n                 (hd (subst_cls_lists Cs (renamings_apart Cs))) \\<inter>\n                vars_clause_list\n                 (tl (subst_cls_lists Cs (renamings_apart Cs))) =\n                {};\n        a # Cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (hd (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) \\<inter>\n                         vars_clause_list\n                          (tl (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) =\n                         {}", "ultimately"], ["proof (chain)\npicking this:\n  vars_clause (subst_cls C \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n  \\<Union> (vars_term ` range \\<sigma>) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}", "have \"vars_clause (subst_cls C \\<sigma>)\n     \\<inter> vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) = {}\""], ["proof (prove)\nusing this:\n  vars_clause (subst_cls C \\<sigma>)\n  \\<subseteq> \\<Union> (vars_term ` range \\<sigma>)\n  \\<Union> (vars_term ` range \\<sigma>) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal (1 subgoal):\n 1. vars_clause (subst_cls C \\<sigma>) \\<inter>\n    vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n    {}", "by auto"], ["proof (state)\nthis:\n  vars_clause (subst_cls C \\<sigma>) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    vars_clause (hd (subst_cls_lists [] (renamings_apart []))) \\<inter>\n    vars_clause_list (tl (subst_cls_lists [] (renamings_apart []))) =\n    {}\n 2. \\<And>a Cs.\n       \\<lbrakk>Cs \\<noteq> [] \\<Longrightarrow>\n                vars_clause\n                 (hd (subst_cls_lists Cs (renamings_apart Cs))) \\<inter>\n                vars_clause_list\n                 (tl (subst_cls_lists Cs (renamings_apart Cs))) =\n                {};\n        a # Cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (hd (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) \\<inter>\n                         vars_clause_list\n                          (tl (subst_cls_lists (a # Cs)\n                                (renamings_apart (a # Cs)))) =\n                         {}", "then"], ["proof (chain)\npicking this:\n  vars_clause (subst_cls C \\<sigma>) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}", "show ?case"], ["proof (prove)\nusing this:\n  vars_clause (subst_cls C \\<sigma>) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal (1 subgoal):\n 1. vars_clause\n     (hd (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)))) \\<inter>\n    vars_clause_list\n     (tl (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)))) =\n    {}", "unfolding \\<sigma>_def \\<sigma>'_def"], ["proof (prove)\nusing this:\n  vars_clause\n   (subst_cls C\n     (\\<lambda>v.\n         Var (Suc (v +\n                   Max (vars_clause_list\n                         (subst_cls_lists Cs (renamings_apart Cs)) \\<union>\n                        {0}))))) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal (1 subgoal):\n 1. vars_clause\n     (hd (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)))) \\<inter>\n    vars_clause_list\n     (tl (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)))) =\n    {}", "unfolding subst_cls_lists_def"], ["proof (prove)\nusing this:\n  vars_clause\n   (subst_cls C\n     (\\<lambda>v.\n         Var (Suc (v +\n                   Max (vars_clause_list\n                         (Map2.map2 subst_cls Cs\n                           (renamings_apart Cs)) \\<union>\n                        {0}))))) \\<inter>\n  vars_clause_list (Map2.map2 subst_cls Cs (renamings_apart Cs)) =\n  {}\n\ngoal (1 subgoal):\n 1. vars_clause\n     (hd (Map2.map2 subst_cls (C # Cs) (renamings_apart (C # Cs)))) \\<inter>\n    vars_clause_list\n     (tl (Map2.map2 subst_cls (C # Cs) (renamings_apart (C # Cs)))) =\n    {}", "by (simp add: Let_def subst_cls_lists_def)"], ["proof (state)\nthis:\n  vars_clause\n   (hd (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)))) \\<inter>\n  vars_clause_list\n   (tl (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)))) =\n  {}\n\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    vars_clause (hd (subst_cls_lists [] (renamings_apart []))) \\<inter>\n    vars_clause_list (tl (subst_cls_lists [] (renamings_apart []))) =\n    {}", "qed auto"], ["", "lemma vars_partitioned_renamings_apart: \"vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))", "proof (induction Cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. vars_partitioned (subst_cls_lists [] (renamings_apart []))\n 2. \\<And>a Cs.\n       vars_partitioned\n        (subst_cls_lists Cs (renamings_apart Cs)) \\<Longrightarrow>\n       vars_partitioned\n        (subst_cls_lists (a # Cs) (renamings_apart (a # Cs)))", "case (Cons C Cs)"], ["proof (state)\nthis:\n  vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (2 subgoals):\n 1. vars_partitioned (subst_cls_lists [] (renamings_apart []))\n 2. \\<And>a Cs.\n       vars_partitioned\n        (subst_cls_lists Cs (renamings_apart Cs)) \\<Longrightarrow>\n       vars_partitioned\n        (subst_cls_lists (a # Cs) (renamings_apart (a # Cs)))", "{"], ["proof (state)\nthis:\n  vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (2 subgoals):\n 1. vars_partitioned (subst_cls_lists [] (renamings_apart []))\n 2. \\<And>a Cs.\n       vars_partitioned\n        (subst_cls_lists Cs (renamings_apart Cs)) \\<Longrightarrow>\n       vars_partitioned\n        (subst_cls_lists (a # Cs) (renamings_apart (a # Cs)))", "fix i :: nat and j :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. vars_partitioned (subst_cls_lists [] (renamings_apart []))\n 2. \\<And>a Cs.\n       vars_partitioned\n        (subst_cls_lists Cs (renamings_apart Cs)) \\<Longrightarrow>\n       vars_partitioned\n        (subst_cls_lists (a # Cs) (renamings_apart (a # Cs)))", "assume ij:\n      \"i < Suc (length Cs)\"\n      \"j < i\""], ["proof (state)\nthis:\n  i < Suc (length Cs)\n  j < i\n\ngoal (2 subgoals):\n 1. vars_partitioned (subst_cls_lists [] (renamings_apart []))\n 2. \\<And>a Cs.\n       vars_partitioned\n        (subst_cls_lists Cs (renamings_apart Cs)) \\<Longrightarrow>\n       vars_partitioned\n        (subst_cls_lists (a # Cs) (renamings_apart (a # Cs)))", "have \"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n        vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n        {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n    vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n    {}", "proof (cases i; cases j)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = 0; j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 4. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "fix j' :: nat"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = 0; j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 4. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "assume i'j':\n        \"i = 0\"\n        \"j = Suc j'\""], ["proof (state)\nthis:\n  i = 0\n  j = Suc j'\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = 0; j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 4. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "then"], ["proof (chain)\npicking this:\n  i = 0\n  j = Suc j'", "show \"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n        vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n        {}\""], ["proof (prove)\nusing this:\n  i = 0\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n    vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n    {}", "using ij"], ["proof (prove)\nusing this:\n  i = 0\n  j = Suc j'\n  i < Suc (length Cs)\n  j < i\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n    vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n    {}", "by auto"], ["proof (state)\nthis:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n  vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n  {}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "fix i' :: nat"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "assume i'j':\n        \"i = Suc i'\"\n        \"j = 0\""], ["proof (state)\nthis:\n  i = Suc i'\n  j = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "have disjoin_C_Cs: \"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n        vars_clause_list ((subst_cls_lists Cs (renamings_apart Cs))) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n    vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n    {}", "using vars_clause_hd_partitioned_from_tl[of \"C # Cs\"]"], ["proof (prove)\nusing this:\n  C # Cs \\<noteq> [] \\<Longrightarrow>\n  vars_clause\n   (hd (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)))) \\<inter>\n  vars_clause_list\n   (tl (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)))) =\n  {}\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n    vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n    {}", "by (simp add: Let_def subst_cls_lists_def)"], ["proof (state)\nthis:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "{"], ["proof (state)\nthis:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "assume asm: \"x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\""], ["proof (state)\nthis:\n  x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "then"], ["proof (chain)\npicking this:\n  x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')", "have \"(subst_cls_lists Cs (renamings_apart Cs) ! i')\n          \\<in> set (subst_cls_lists Cs (renamings_apart Cs))\""], ["proof (prove)\nusing this:\n  x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n\ngoal (1 subgoal):\n 1. subst_cls_lists Cs (renamings_apart Cs) ! i'\n    \\<in> set (subst_cls_lists Cs (renamings_apart Cs))", "using i'j' ij"], ["proof (prove)\nusing this:\n  x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n  i = Suc i'\n  j = 0\n  i < Suc (length Cs)\n  j < i\n\ngoal (1 subgoal):\n 1. subst_cls_lists Cs (renamings_apart Cs) ! i'\n    \\<in> set (subst_cls_lists Cs (renamings_apart Cs))", "unfolding subst_cls_lists_def"], ["proof (prove)\nusing this:\n  x \\<in> vars_clause (Map2.map2 subst_cls Cs (renamings_apart Cs) ! i')\n  i = Suc i'\n  j = 0\n  i < Suc (length Cs)\n  j < i\n\ngoal (1 subgoal):\n 1. Map2.map2 subst_cls Cs (renamings_apart Cs) ! i'\n    \\<in> set (Map2.map2 subst_cls Cs (renamings_apart Cs))", "by (metis Suc_less_SucD length_map len_renamings_apart length_zip min_less_iff_conj\n              nth_mem)"], ["proof (state)\nthis:\n  subst_cls_lists Cs (renamings_apart Cs) ! i'\n  \\<in> set (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "moreover"], ["proof (state)\nthis:\n  subst_cls_lists Cs (renamings_apart Cs) ! i'\n  \\<in> set (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "from asm"], ["proof (chain)\npicking this:\n  x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')", "have\n          \"x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\""], ["proof (prove)\nusing this:\n  x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n\ngoal (1 subgoal):\n 1. x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')", "using i'j' ij"], ["proof (prove)\nusing this:\n  x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n  i = Suc i'\n  j = 0\n  i < Suc (length Cs)\n  j < i\n\ngoal (1 subgoal):\n 1. x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')", "unfolding subst_cls_lists_def"], ["proof (prove)\nusing this:\n  x \\<in> vars_clause (Map2.map2 subst_cls Cs (renamings_apart Cs) ! i')\n  i = Suc i'\n  j = 0\n  i < Suc (length Cs)\n  j < i\n\ngoal (1 subgoal):\n 1. x \\<in> vars_clause (Map2.map2 subst_cls Cs (renamings_apart Cs) ! i')", "by simp"], ["proof (state)\nthis:\n  x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "ultimately"], ["proof (chain)\npicking this:\n  subst_cls_lists Cs (renamings_apart Cs) ! i'\n  \\<in> set (subst_cls_lists Cs (renamings_apart Cs))\n  x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')", "have \"\\<exists>D \\<in> set (subst_cls_lists Cs (renamings_apart Cs)). x \\<in> vars_clause D\""], ["proof (prove)\nusing this:\n  subst_cls_lists Cs (renamings_apart Cs) ! i'\n  \\<in> set (subst_cls_lists Cs (renamings_apart Cs))\n  x \\<in> vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n\ngoal (1 subgoal):\n 1. \\<exists>D\\<in>set (subst_cls_lists Cs (renamings_apart Cs)).\n       x \\<in> vars_clause D", "by auto"], ["proof (state)\nthis:\n  \\<exists>D\\<in>set (subst_cls_lists Cs (renamings_apart Cs)).\n     x \\<in> vars_clause D\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "}"], ["proof (state)\nthis:\n  ?x2\n  \\<in> vars_clause\n         (subst_cls_lists Cs (renamings_apart Cs) ! i') \\<Longrightarrow>\n  \\<exists>D\\<in>set (subst_cls_lists Cs (renamings_apart Cs)).\n     ?x2 \\<in> vars_clause D\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "then"], ["proof (chain)\npicking this:\n  ?x2\n  \\<in> vars_clause\n         (subst_cls_lists Cs (renamings_apart Cs) ! i') \\<Longrightarrow>\n  \\<exists>D\\<in>set (subst_cls_lists Cs (renamings_apart Cs)).\n     ?x2 \\<in> vars_clause D", "have \"vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n        \\<subseteq> Union (set (map vars_clause ((subst_cls_lists Cs (renamings_apart Cs)))))\""], ["proof (prove)\nusing this:\n  ?x2\n  \\<in> vars_clause\n         (subst_cls_lists Cs (renamings_apart Cs) ! i') \\<Longrightarrow>\n  \\<exists>D\\<in>set (subst_cls_lists Cs (renamings_apart Cs)).\n     ?x2 \\<in> vars_clause D\n\ngoal (1 subgoal):\n 1. vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n    \\<subseteq> \\<Union>\n                 (set (map vars_clause\n                        (subst_cls_lists Cs (renamings_apart Cs))))", "by auto"], ["proof (state)\nthis:\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n  \\<subseteq> \\<Union>\n               (set (map vars_clause\n                      (subst_cls_lists Cs (renamings_apart Cs))))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "then"], ["proof (chain)\npicking this:\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n  \\<subseteq> \\<Union>\n               (set (map vars_clause\n                      (subst_cls_lists Cs (renamings_apart Cs))))", "have \"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n        vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') =\n        {}\""], ["proof (prove)\nusing this:\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n  \\<subseteq> \\<Union>\n               (set (map vars_clause\n                      (subst_cls_lists Cs (renamings_apart Cs))))\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n    vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') =\n    {}", "using disjoin_C_Cs"], ["proof (prove)\nusing this:\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n  \\<subseteq> \\<Union>\n               (set (map vars_clause\n                      (subst_cls_lists Cs (renamings_apart Cs))))\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n  vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) =\n  {}\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n    vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') =\n    {}", "unfolding vars_clause_list_def"], ["proof (prove)\nusing this:\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')\n  \\<subseteq> \\<Union>\n               (set (map vars_clause\n                      (subst_cls_lists Cs (renamings_apart Cs))))\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n  \\<Union> (vars_clause ` set (subst_cls_lists Cs (renamings_apart Cs))) =\n  {}\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n    vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') =\n    {}", "by auto"], ["proof (state)\nthis:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') =\n  {}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "moreover"], ["proof (state)\nthis:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') =\n  {}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "have \"subst_cls_lists Cs (renamings_apart Cs) ! i' =\n        subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cls_lists Cs (renamings_apart Cs) ! i' =\n    subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i", "using i'j' ij"], ["proof (prove)\nusing this:\n  i = Suc i'\n  j = 0\n  i < Suc (length Cs)\n  j < i\n\ngoal (1 subgoal):\n 1. subst_cls_lists Cs (renamings_apart Cs) ! i' =\n    subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i", "unfolding subst_cls_lists_def"], ["proof (prove)\nusing this:\n  i = Suc i'\n  j = 0\n  i < Suc (length Cs)\n  j < i\n\ngoal (1 subgoal):\n 1. Map2.map2 subst_cls Cs (renamings_apart Cs) ! i' =\n    Map2.map2 subst_cls (C # Cs) (renamings_apart (C # Cs)) ! i", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  subst_cls_lists Cs (renamings_apart Cs) ! i' =\n  subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i\n\ngoal (3 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat.\n       \\<lbrakk>i = Suc nat; j = 0\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}\n 3. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "ultimately"], ["proof (chain)\npicking this:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') =\n  {}\n  subst_cls_lists Cs (renamings_apart Cs) ! i' =\n  subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i", "show \"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n        vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n        {}\""], ["proof (prove)\nusing this:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') =\n  {}\n  subst_cls_lists Cs (renamings_apart Cs) ! i' =\n  subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n    vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n    {}", "using i'j'"], ["proof (prove)\nusing this:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) \\<inter>\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') =\n  {}\n  subst_cls_lists Cs (renamings_apart Cs) ! i' =\n  subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i\n  i = Suc i'\n  j = 0\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n    vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n    {}", "by (simp add: Int_commute)"], ["proof (state)\nthis:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n  vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n  {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "fix i' :: nat and j' :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "assume i'j':\n        \"i = Suc i'\"\n        \"j = Suc j'\""], ["proof (state)\nthis:\n  i = Suc i'\n  j = Suc j'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "have \"i'<length (subst_cls_lists Cs (renamings_apart Cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' < length (subst_cls_lists Cs (renamings_apart Cs))", "using ij i'j'"], ["proof (prove)\nusing this:\n  i < Suc (length Cs)\n  j < i\n  i = Suc i'\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. i' < length (subst_cls_lists Cs (renamings_apart Cs))", "unfolding subst_cls_lists_def"], ["proof (prove)\nusing this:\n  i < Suc (length Cs)\n  j < i\n  i = Suc i'\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. i' < length (Map2.map2 subst_cls Cs (renamings_apart Cs))", "by (auto simp: len_renamings_apart)"], ["proof (state)\nthis:\n  i' < length (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "moreover"], ["proof (state)\nthis:\n  i' < length (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "have \"j'<length (subst_cls_lists Cs (renamings_apart Cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j' < length (subst_cls_lists Cs (renamings_apart Cs))", "using ij i'j'"], ["proof (prove)\nusing this:\n  i < Suc (length Cs)\n  j < i\n  i = Suc i'\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. j' < length (subst_cls_lists Cs (renamings_apart Cs))", "unfolding subst_cls_lists_def"], ["proof (prove)\nusing this:\n  i < Suc (length Cs)\n  j < i\n  i = Suc i'\n  j = Suc j'\n\ngoal (1 subgoal):\n 1. j' < length (Map2.map2 subst_cls Cs (renamings_apart Cs))", "by (auto simp: len_renamings_apart)"], ["proof (state)\nthis:\n  j' < length (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "moreover"], ["proof (state)\nthis:\n  j' < length (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "have \"i' \\<noteq> j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<noteq> j'", "using \\<open>i = Suc i'\\<close> \\<open>j = Suc j'\\<close> ij"], ["proof (prove)\nusing this:\n  i = Suc i'\n  j = Suc j'\n  i < Suc (length Cs)\n  j < i\n\ngoal (1 subgoal):\n 1. i' \\<noteq> j'", "by blast"], ["proof (state)\nthis:\n  i' \\<noteq> j'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "ultimately"], ["proof (chain)\npicking this:\n  i' < length (subst_cls_lists Cs (renamings_apart Cs))\n  j' < length (subst_cls_lists Cs (renamings_apart Cs))\n  i' \\<noteq> j'", "have \"vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') \\<inter>\n          vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! j') =\n          {}\""], ["proof (prove)\nusing this:\n  i' < length (subst_cls_lists Cs (renamings_apart Cs))\n  j' < length (subst_cls_lists Cs (renamings_apart Cs))\n  i' \\<noteq> j'\n\ngoal (1 subgoal):\n 1. vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') \\<inter>\n    vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! j') =\n    {}", "using Cons"], ["proof (prove)\nusing this:\n  i' < length (subst_cls_lists Cs (renamings_apart Cs))\n  j' < length (subst_cls_lists Cs (renamings_apart Cs))\n  i' \\<noteq> j'\n  vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (1 subgoal):\n 1. vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') \\<inter>\n    vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! j') =\n    {}", "unfolding vars_partitioned_def"], ["proof (prove)\nusing this:\n  i' < length (subst_cls_lists Cs (renamings_apart Cs))\n  j' < length (subst_cls_lists Cs (renamings_apart Cs))\n  i' \\<noteq> j'\n  \\<forall>i<length (subst_cls_lists Cs (renamings_apart Cs)).\n     \\<forall>j<length (subst_cls_lists Cs (renamings_apart Cs)).\n        i \\<noteq> j \\<longrightarrow>\n        vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i) \\<inter>\n        vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! j) =\n        {}\n\ngoal (1 subgoal):\n 1. vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') \\<inter>\n    vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! j') =\n    {}", "by auto"], ["proof (state)\nthis:\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') \\<inter>\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! j') =\n  {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}\n 2. \\<And>nat nata.\n       \\<lbrakk>i = Suc nat; j = Suc nata\\<rbrakk>\n       \\<Longrightarrow> vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           i) \\<inter>\n                         vars_clause\n                          (subst_cls_lists (C # Cs)\n                            (renamings_apart (C # Cs)) !\n                           j) =\n                         {}", "then"], ["proof (chain)\npicking this:\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') \\<inter>\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! j') =\n  {}", "show \"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n        vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n        {}\""], ["proof (prove)\nusing this:\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') \\<inter>\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! j') =\n  {}\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n    vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n    {}", "unfolding i'j'"], ["proof (prove)\nusing this:\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') \\<inter>\n  vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! j') =\n  {}\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! Suc i') \\<inter>\n    vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! Suc j') =\n    {}", "by (simp add: subst_cls_lists_def Let_def)"], ["proof (state)\nthis:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n  vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}", "assume\n        \\<open>i = 0\\<close> and\n        \\<open>j = 0\\<close>"], ["proof (state)\nthis:\n  i = 0\n  j = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 0; j = 0\\<rbrakk>\n    \\<Longrightarrow> vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        i) \\<inter>\n                      vars_clause\n                       (subst_cls_lists (C # Cs)\n                         (renamings_apart (C # Cs)) !\n                        j) =\n                      {}", "then"], ["proof (chain)\npicking this:\n  i = 0\n  j = 0", "show \\<open>vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n        vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n        {}\\<close>"], ["proof (prove)\nusing this:\n  i = 0\n  j = 0\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n    vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n    {}", "using ij"], ["proof (prove)\nusing this:\n  i = 0\n  j = 0\n  i < Suc (length Cs)\n  j < i\n\ngoal (1 subgoal):\n 1. vars_clause\n     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n    vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n    {}", "by auto"], ["proof (state)\nthis:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n  vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars_clause\n   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) \\<inter>\n  vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n  {}\n\ngoal (2 subgoals):\n 1. vars_partitioned (subst_cls_lists [] (renamings_apart []))\n 2. \\<And>a Cs.\n       vars_partitioned\n        (subst_cls_lists Cs (renamings_apart Cs)) \\<Longrightarrow>\n       vars_partitioned\n        (subst_cls_lists (a # Cs) (renamings_apart (a # Cs)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < Suc (length Cs); ?j2 < ?i2\\<rbrakk>\n  \\<Longrightarrow> vars_clause\n                     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) !\n                      ?i2) \\<inter>\n                    vars_clause\n                     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) !\n                      ?j2) =\n                    {}\n\ngoal (2 subgoals):\n 1. vars_partitioned (subst_cls_lists [] (renamings_apart []))\n 2. \\<And>a Cs.\n       vars_partitioned\n        (subst_cls_lists Cs (renamings_apart Cs)) \\<Longrightarrow>\n       vars_partitioned\n        (subst_cls_lists (a # Cs) (renamings_apart (a # Cs)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < Suc (length Cs); ?j2 < ?i2\\<rbrakk>\n  \\<Longrightarrow> vars_clause\n                     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) !\n                      ?i2) \\<inter>\n                    vars_clause\n                     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) !\n                      ?j2) =\n                    {}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < Suc (length Cs); ?j2 < ?i2\\<rbrakk>\n  \\<Longrightarrow> vars_clause\n                     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) !\n                      ?i2) \\<inter>\n                    vars_clause\n                     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) !\n                      ?j2) =\n                    {}\n\ngoal (1 subgoal):\n 1. vars_partitioned (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)))", "unfolding vars_partitioned_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < Suc (length Cs); ?j2 < ?i2\\<rbrakk>\n  \\<Longrightarrow> vars_clause\n                     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) !\n                      ?i2) \\<inter>\n                    vars_clause\n                     (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) !\n                      ?j2) =\n                    {}\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (subst_cls_lists (C # Cs) (renamings_apart (C # Cs))).\n       \\<forall>j<length\n                   (subst_cls_lists (C # Cs) (renamings_apart (C # Cs))).\n          i \\<noteq> j \\<longrightarrow>\n          vars_clause\n           (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) !\n            i) \\<inter>\n          vars_clause\n           (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =\n          {}", "by (metis (no_types, lifting) Int_commute Suc_lessI len_renamings_apart length_map\n        length_nth_simps(2) length_zip min.idem nat.inject not_less_eq subst_cls_lists_def)"], ["proof (state)\nthis:\n  vars_partitioned (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)))\n\ngoal (1 subgoal):\n 1. vars_partitioned (subst_cls_lists [] (renamings_apart []))", "qed auto"], ["", "interpretation substitution \"(\\<cdot>)\" \"Var :: _ \\<Rightarrow> ('f, nat) term\" \"(\\<circ>\\<^sub>s)\" renamings_apart \"Fun undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. substitution subst_atm_abbrev Var comp_subst_abbrev renamings_apart\n     (Fun undefined)", "proof (standard)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>A. subst_atm_abbrev A Var = A\n 2. \\<And>A \\<sigma> \\<tau>.\n       subst_atm_abbrev A (comp_subst_abbrev \\<sigma> \\<tau>) =\n       subst_atm_abbrev (subst_atm_abbrev A \\<sigma>) \\<tau>\n 3. \\<And>\\<sigma> \\<tau>.\n       (\\<And>A.\n           subst_atm_abbrev A \\<sigma> =\n           subst_atm_abbrev A \\<tau>) \\<Longrightarrow>\n       \\<sigma> = \\<tau>\n 4. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 5. wfP strictly_generalizes_atm\n 6. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 7. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 8. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 9. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "show \"\\<And>A. A \\<cdot> Var = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. subst_atm_abbrev A Var = A", "by auto"], ["proof (state)\nthis:\n  subst_atm_abbrev ?A Var = ?A\n\ngoal (8 subgoals):\n 1. \\<And>A \\<sigma> \\<tau>.\n       subst_atm_abbrev A (comp_subst_abbrev \\<sigma> \\<tau>) =\n       subst_atm_abbrev (subst_atm_abbrev A \\<sigma>) \\<tau>\n 2. \\<And>\\<sigma> \\<tau>.\n       (\\<And>A.\n           subst_atm_abbrev A \\<sigma> =\n           subst_atm_abbrev A \\<tau>) \\<Longrightarrow>\n       \\<sigma> = \\<tau>\n 3. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 4. wfP strictly_generalizes_atm\n 5. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 6. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 7. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 8. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>A \\<sigma> \\<tau>.\n       subst_atm_abbrev A (comp_subst_abbrev \\<sigma> \\<tau>) =\n       subst_atm_abbrev (subst_atm_abbrev A \\<sigma>) \\<tau>\n 2. \\<And>\\<sigma> \\<tau>.\n       (\\<And>A.\n           subst_atm_abbrev A \\<sigma> =\n           subst_atm_abbrev A \\<tau>) \\<Longrightarrow>\n       \\<sigma> = \\<tau>\n 3. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 4. wfP strictly_generalizes_atm\n 5. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 6. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 7. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 8. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "show \"\\<And>A \\<tau> \\<sigma>. A \\<cdot> \\<tau> \\<circ>\\<^sub>s \\<sigma> = A \\<cdot> \\<tau> \\<cdot> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A \\<tau> \\<sigma>.\n       A \\<cdot> \\<tau> \\<circ>\\<^sub>s \\<sigma> =\n       A \\<cdot> \\<tau> \\<cdot> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  ?A \\<cdot> ?\\<tau> \\<circ>\\<^sub>s ?\\<sigma> =\n  ?A \\<cdot> ?\\<tau> \\<cdot> ?\\<sigma>\n\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> \\<tau>.\n       (\\<And>A.\n           subst_atm_abbrev A \\<sigma> =\n           subst_atm_abbrev A \\<tau>) \\<Longrightarrow>\n       \\<sigma> = \\<tau>\n 2. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 3. wfP strictly_generalizes_atm\n 4. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 5. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 6. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 7. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> \\<tau>.\n       (\\<And>A.\n           subst_atm_abbrev A \\<sigma> =\n           subst_atm_abbrev A \\<tau>) \\<Longrightarrow>\n       \\<sigma> = \\<tau>\n 2. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 3. wfP strictly_generalizes_atm\n 4. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 5. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 6. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 7. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "show \"\\<And>\\<sigma> \\<tau>. (\\<And>A. A \\<cdot> \\<sigma> = A \\<cdot> \\<tau>) \\<Longrightarrow> \\<sigma> = \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<tau>.\n       (\\<And>A. A \\<cdot> \\<sigma> = A \\<cdot> \\<tau>) \\<Longrightarrow>\n       \\<sigma> = \\<tau>", "by (simp add: subst_term_eqI)"], ["proof (state)\nthis:\n  (\\<And>A. A \\<cdot> ?\\<sigma> = A \\<cdot> ?\\<tau>) \\<Longrightarrow>\n  ?\\<sigma> = ?\\<tau>\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "fix C :: \"('f, nat) term clause\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "fix \\<sigma>"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "assume \"is_ground_cls (subst_cls C \\<sigma>)\""], ["proof (state)\nthis:\n  is_ground_cls (subst_cls C \\<sigma>)\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "then"], ["proof (chain)\npicking this:\n  is_ground_cls (subst_cls C \\<sigma>)", "have ground_atms_\\<sigma>: \"\\<And>v. v \\<in> vars_clause C \\<Longrightarrow> is_ground_atm (\\<sigma> v)\""], ["proof (prove)\nusing this:\n  is_ground_cls (subst_cls C \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars_clause C \\<Longrightarrow> is_ground_atm (\\<sigma> v)", "by (meson is_ground_cls_is_ground_on_var)"], ["proof (state)\nthis:\n  ?v \\<in> vars_clause C \\<Longrightarrow> is_ground_atm (\\<sigma> ?v)\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "define some_ground_trm :: \"('f, nat) term\" where \"some_ground_trm = (Fun undefined [])\""], ["proof (state)\nthis:\n  some_ground_trm = Fun undefined []\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "have ground_trm: \"is_ground_atm some_ground_trm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm some_ground_trm", "unfolding is_ground_atm_def some_ground_trm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       Fun undefined [] = subst_atm_abbrev (Fun undefined []) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  is_ground_atm some_ground_trm\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "define \\<tau> where \"\\<tau> = (\\<lambda>v. if v \\<in> vars_clause C then \\<sigma> v else some_ground_trm)\""], ["proof (state)\nthis:\n  \\<tau> =\n  (\\<lambda>v.\n      if v \\<in> vars_clause C then \\<sigma> v else some_ground_trm)\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "then"], ["proof (chain)\npicking this:\n  \\<tau> =\n  (\\<lambda>v.\n      if v \\<in> vars_clause C then \\<sigma> v else some_ground_trm)", "have \\<tau>_\\<sigma>: \"\\<forall>v \\<in> vars_clause C. \\<sigma> v = \\<tau> v\""], ["proof (prove)\nusing this:\n  \\<tau> =\n  (\\<lambda>v.\n      if v \\<in> vars_clause C then \\<sigma> v else some_ground_trm)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v", "unfolding \\<tau>_def"], ["proof (prove)\nusing this:\n  (\\<lambda>v.\n      if v \\<in> vars_clause C then \\<sigma> v else some_ground_trm) =\n  (\\<lambda>v.\n      if v \\<in> vars_clause C then \\<sigma> v else some_ground_trm)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>vars_clause C.\n       \\<sigma> v =\n       (if v \\<in> vars_clause C then \\<sigma> v else some_ground_trm)", "by auto"], ["proof (state)\nthis:\n  \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "have all_ground_\\<tau>: \"is_ground_atm (\\<tau> v)\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm (\\<tau> v)", "proof (cases \"v \\<in> vars_clause C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> vars_clause C \\<Longrightarrow> is_ground_atm (\\<tau> v)\n 2. v \\<notin> vars_clause C \\<Longrightarrow> is_ground_atm (\\<tau> v)", "case True"], ["proof (state)\nthis:\n  v \\<in> vars_clause C\n\ngoal (2 subgoals):\n 1. v \\<in> vars_clause C \\<Longrightarrow> is_ground_atm (\\<tau> v)\n 2. v \\<notin> vars_clause C \\<Longrightarrow> is_ground_atm (\\<tau> v)", "then"], ["proof (chain)\npicking this:\n  v \\<in> vars_clause C", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> vars_clause C\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<tau> v)", "using ground_atms_\\<sigma> \\<tau>_\\<sigma>"], ["proof (prove)\nusing this:\n  v \\<in> vars_clause C\n  ?v \\<in> vars_clause C \\<Longrightarrow> is_ground_atm (\\<sigma> ?v)\n  \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<tau> v)", "by auto"], ["proof (state)\nthis:\n  is_ground_atm (\\<tau> v)\n\ngoal (1 subgoal):\n 1. v \\<notin> vars_clause C \\<Longrightarrow> is_ground_atm (\\<tau> v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> vars_clause C \\<Longrightarrow> is_ground_atm (\\<tau> v)", "case False"], ["proof (state)\nthis:\n  v \\<notin> vars_clause C\n\ngoal (1 subgoal):\n 1. v \\<notin> vars_clause C \\<Longrightarrow> is_ground_atm (\\<tau> v)", "then"], ["proof (chain)\npicking this:\n  v \\<notin> vars_clause C", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> vars_clause C\n\ngoal (1 subgoal):\n 1. is_ground_atm (\\<tau> v)", "unfolding \\<tau>_def"], ["proof (prove)\nusing this:\n  v \\<notin> vars_clause C\n\ngoal (1 subgoal):\n 1. is_ground_atm\n     (if v \\<in> vars_clause C then \\<sigma> v else some_ground_trm)", "using ground_trm"], ["proof (prove)\nusing this:\n  v \\<notin> vars_clause C\n  is_ground_atm some_ground_trm\n\ngoal (1 subgoal):\n 1. is_ground_atm\n     (if v \\<in> vars_clause C then \\<sigma> v else some_ground_trm)", "by auto"], ["proof (state)\nthis:\n  is_ground_atm (\\<tau> v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_ground_atm (\\<tau> ?v)\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "have \"is_ground_subst \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_subst \\<tau>", "unfolding is_ground_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. is_ground_atm (subst_atm_abbrev A \\<tau>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. is_ground_atm (subst_atm_abbrev A \\<tau>)", "fix A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. is_ground_atm (subst_atm_abbrev A \\<tau>)", "show \"is_ground_atm (subst_atm_abbrev A \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm (subst_atm_abbrev A \\<tau>)", "proof (induction A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. is_ground_atm (subst_atm_abbrev (Var x) \\<tau>)\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           is_ground_atm (subst_atm_abbrev x2a \\<tau>)) \\<Longrightarrow>\n       is_ground_atm (subst_atm_abbrev (Fun x1a x2) \\<tau>)", "case (Var v)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. is_ground_atm (subst_atm_abbrev (Var x) \\<tau>)\n 2. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           is_ground_atm (subst_atm_abbrev x2a \\<tau>)) \\<Longrightarrow>\n       is_ground_atm (subst_atm_abbrev (Fun x1a x2) \\<tau>)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm (subst_atm_abbrev (Var v) \\<tau>)", "using all_ground_\\<tau>"], ["proof (prove)\nusing this:\n  is_ground_atm (\\<tau> ?v)\n\ngoal (1 subgoal):\n 1. is_ground_atm (subst_atm_abbrev (Var v) \\<tau>)", "by auto"], ["proof (state)\nthis:\n  is_ground_atm (subst_atm_abbrev (Var v) \\<tau>)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           is_ground_atm (subst_atm_abbrev x2a \\<tau>)) \\<Longrightarrow>\n       is_ground_atm (subst_atm_abbrev (Fun x1a x2) \\<tau>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           is_ground_atm (subst_atm_abbrev x2a \\<tau>)) \\<Longrightarrow>\n       is_ground_atm (subst_atm_abbrev (Fun x1a x2) \\<tau>)", "case (Fun f As)"], ["proof (state)\nthis:\n  ?x2a \\<in> set As \\<Longrightarrow>\n  is_ground_atm (subst_atm_abbrev ?x2a \\<tau>)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           is_ground_atm (subst_atm_abbrev x2a \\<tau>)) \\<Longrightarrow>\n       is_ground_atm (subst_atm_abbrev (Fun x1a x2) \\<tau>)", "then"], ["proof (chain)\npicking this:\n  ?x2a \\<in> set As \\<Longrightarrow>\n  is_ground_atm (subst_atm_abbrev ?x2a \\<tau>)", "show ?case"], ["proof (prove)\nusing this:\n  ?x2a \\<in> set As \\<Longrightarrow>\n  is_ground_atm (subst_atm_abbrev ?x2a \\<tau>)\n\ngoal (1 subgoal):\n 1. is_ground_atm (subst_atm_abbrev (Fun f As) \\<tau>)", "using all_ground_\\<tau>"], ["proof (prove)\nusing this:\n  ?x2a \\<in> set As \\<Longrightarrow>\n  is_ground_atm (subst_atm_abbrev ?x2a \\<tau>)\n  is_ground_atm (\\<tau> ?v)\n\ngoal (1 subgoal):\n 1. is_ground_atm (subst_atm_abbrev (Fun f As) \\<tau>)", "by (simp add: is_ground_atm_def)"], ["proof (state)\nthis:\n  is_ground_atm (subst_atm_abbrev (Fun f As) \\<tau>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_ground_atm (subst_atm_abbrev A \\<tau>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_ground_subst \\<tau>\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "moreover"], ["proof (state)\nthis:\n  is_ground_subst \\<tau>\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "have \"\\<forall>v \\<in> vars_clause C. \\<sigma> v = \\<tau> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v", "using \\<tau>_\\<sigma>"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v", "unfolding vars_clause_list_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v", "by blast"], ["proof (state)\nthis:\n  \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v", "have \"subst_cls C \\<sigma> = subst_cls C \\<tau>\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v\n\ngoal (1 subgoal):\n 1. subst_cls C \\<sigma> = subst_cls C \\<tau>", "using same_on_vars_clause"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_clause C. \\<sigma> v = \\<tau> v\n  \\<forall>v\\<in>vars_clause ?S. ?\\<sigma> v = ?\\<tau> v \\<Longrightarrow>\n  subst_cls ?S ?\\<sigma> = subst_cls ?S ?\\<tau>\n\ngoal (1 subgoal):\n 1. subst_cls C \\<sigma> = subst_cls C \\<tau>", "by auto"], ["proof (state)\nthis:\n  subst_cls C \\<sigma> = subst_cls C \\<tau>\n\ngoal (6 subgoals):\n 1. \\<And>C \\<sigma>.\n       is_ground_cls (subst_cls C \\<sigma>) \\<Longrightarrow>\n       \\<exists>\\<tau>.\n          is_ground_subst \\<tau> \\<and>\n          subst_cls C \\<tau> = subst_cls C \\<sigma>\n 2. wfP strictly_generalizes_atm\n 3. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 4. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 5. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 6. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "ultimately"], ["proof (chain)\npicking this:\n  is_ground_subst \\<tau>\n  subst_cls C \\<sigma> = subst_cls C \\<tau>", "show \"\\<exists>\\<tau>. is_ground_subst \\<tau> \\<and> subst_cls C \\<tau> = subst_cls C \\<sigma>\""], ["proof (prove)\nusing this:\n  is_ground_subst \\<tau>\n  subst_cls C \\<sigma> = subst_cls C \\<tau>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>.\n       is_ground_subst \\<tau> \\<and>\n       subst_cls C \\<tau> = subst_cls C \\<sigma>", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<tau>.\n     is_ground_subst \\<tau> \\<and> subst_cls C \\<tau> = subst_cls C \\<sigma>\n\ngoal (5 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 3. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 4. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 5. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 3. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 4. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 5. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "fix Cs :: \"('f, nat) term clause list\""], ["proof (state)\ngoal (5 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>Cs. length (renamings_apart Cs) = length Cs\n 3. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 4. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 5. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "show \"length (renamings_apart Cs) = length Cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (renamings_apart Cs) = length Cs", "using len_renamings_apart"], ["proof (prove)\nusing this:\n  length (renamings_apart ?Cs) = length ?Cs\n\ngoal (1 subgoal):\n 1. length (renamings_apart Cs) = length Cs", "by auto"], ["proof (state)\nthis:\n  length (renamings_apart Cs) = length Cs\n\ngoal (4 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 3. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 4. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 3. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 4. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "fix Cs :: \"('f, nat) term clause list\""], ["proof (state)\ngoal (4 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 3. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 4. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "fix \\<rho> ::  \"nat \\<Rightarrow> ('f, nat) Term.term\""], ["proof (state)\ngoal (4 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 3. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 4. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "assume \\<rho>_renaming: \"\\<rho> \\<in> set (renamings_apart Cs)\""], ["proof (state)\nthis:\n  \\<rho> \\<in> set (renamings_apart Cs)\n\ngoal (4 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 3. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 4. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "{"], ["proof (state)\nthis:\n  \\<rho> \\<in> set (renamings_apart Cs)\n\ngoal (4 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 3. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 4. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "have inj_is_renaming:\n      \"\\<And>\\<sigma> :: ('f, nat) subst. (\\<And>x. is_Var (\\<sigma> x)) \\<Longrightarrow> inj \\<sigma> \\<Longrightarrow> is_renaming \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "fix \\<sigma> :: \"('f, nat) subst\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "assume is_var_\\<sigma>: \"\\<And>x. is_Var (\\<sigma> x)\""], ["proof (state)\nthis:\n  is_Var (\\<sigma> ?x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "assume inj_\\<sigma>: \"inj \\<sigma>\""], ["proof (state)\nthis:\n  inj \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "define \\<sigma>' where \"\\<sigma>' = var_map_of_subst \\<sigma>\""], ["proof (state)\nthis:\n  \\<sigma>' = var_map_of_subst \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "have \\<sigma>: \"\\<sigma> = Var \\<circ> \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> = Var \\<circ> \\<sigma>'", "unfolding \\<sigma>'_def var_map_of_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> = Var \\<circ> (\\<lambda>v. the_Var (\\<sigma> v))", "using is_var_\\<sigma>"], ["proof (prove)\nusing this:\n  is_Var (\\<sigma> ?x)\n\ngoal (1 subgoal):\n 1. \\<sigma> = Var \\<circ> (\\<lambda>v. the_Var (\\<sigma> v))", "by auto"], ["proof (state)\nthis:\n  \\<sigma> = Var \\<circ> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "from is_var_\\<sigma> inj_\\<sigma>"], ["proof (chain)\npicking this:\n  is_Var (\\<sigma> ?x)\n  inj \\<sigma>", "have \"inj \\<sigma>'\""], ["proof (prove)\nusing this:\n  is_Var (\\<sigma> ?x)\n  inj \\<sigma>\n\ngoal (1 subgoal):\n 1. inj \\<sigma>'", "unfolding is_renaming_def"], ["proof (prove)\nusing this:\n  is_Var (\\<sigma> ?x)\n  inj \\<sigma>\n\ngoal (1 subgoal):\n 1. inj \\<sigma>'", "unfolding subst_domain_def inj_on_def \\<sigma>'_def var_map_of_subst_def"], ["proof (prove)\nusing this:\n  is_Var (\\<sigma> ?x)\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV. \\<sigma> x = \\<sigma> y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          the_Var (\\<sigma> x) = the_Var (\\<sigma> y) \\<longrightarrow>\n          x = y", "by (metis term.collapse(1))"], ["proof (state)\nthis:\n  inj \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "then"], ["proof (chain)\npicking this:\n  inj \\<sigma>'", "have \"inv \\<sigma>' \\<circ> \\<sigma>' = id\""], ["proof (prove)\nusing this:\n  inj \\<sigma>'\n\ngoal (1 subgoal):\n 1. inv \\<sigma>' \\<circ> \\<sigma>' = id", "using inv_o_cancel[of \\<sigma>']"], ["proof (prove)\nusing this:\n  inj \\<sigma>'\n  inj \\<sigma>' \\<Longrightarrow> inv \\<sigma>' \\<circ> \\<sigma>' = id\n\ngoal (1 subgoal):\n 1. inv \\<sigma>' \\<circ> \\<sigma>' = id", "by simp"], ["proof (state)\nthis:\n  inv \\<sigma>' \\<circ> \\<sigma>' = id\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "then"], ["proof (chain)\npicking this:\n  inv \\<sigma>' \\<circ> \\<sigma>' = id", "have \"Var \\<circ> (inv \\<sigma>' \\<circ> \\<sigma>') = Var\""], ["proof (prove)\nusing this:\n  inv \\<sigma>' \\<circ> \\<sigma>' = id\n\ngoal (1 subgoal):\n 1. Var \\<circ> (inv \\<sigma>' \\<circ> \\<sigma>') = Var", "by simp"], ["proof (state)\nthis:\n  Var \\<circ> (inv \\<sigma>' \\<circ> \\<sigma>') = Var\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "then"], ["proof (chain)\npicking this:\n  Var \\<circ> (inv \\<sigma>' \\<circ> \\<sigma>') = Var", "have \"\\<forall>x. (Var \\<circ> (inv \\<sigma>' \\<circ> \\<sigma>')) x = Var x\""], ["proof (prove)\nusing this:\n  Var \\<circ> (inv \\<sigma>' \\<circ> \\<sigma>') = Var\n\ngoal (1 subgoal):\n 1. \\<forall>x. (Var \\<circ> (inv \\<sigma>' \\<circ> \\<sigma>')) x = Var x", "by metis"], ["proof (state)\nthis:\n  \\<forall>x. (Var \\<circ> (inv \\<sigma>' \\<circ> \\<sigma>')) x = Var x\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. (Var \\<circ> (inv \\<sigma>' \\<circ> \\<sigma>')) x = Var x", "have \"\\<forall>x. ((Var \\<circ> \\<sigma>') \\<circ>\\<^sub>s (Var \\<circ> (inv \\<sigma>'))) x = Var x\""], ["proof (prove)\nusing this:\n  \\<forall>x. (Var \\<circ> (inv \\<sigma>' \\<circ> \\<sigma>')) x = Var x\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       comp_subst_abbrev (Var \\<circ> \\<sigma>') (Var \\<circ> inv \\<sigma>')\n        x =\n       Var x", "unfolding subst_compose_def"], ["proof (prove)\nusing this:\n  \\<forall>x. (Var \\<circ> (inv \\<sigma>' \\<circ> \\<sigma>')) x = Var x\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       subst_atm_abbrev ((Var \\<circ> \\<sigma>') x)\n        (Var \\<circ> inv \\<sigma>') =\n       Var x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     comp_subst_abbrev (Var \\<circ> \\<sigma>') (Var \\<circ> inv \\<sigma>')\n      x =\n     Var x\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     comp_subst_abbrev (Var \\<circ> \\<sigma>') (Var \\<circ> inv \\<sigma>')\n      x =\n     Var x", "have \"\\<sigma> \\<circ>\\<^sub>s (Var \\<circ> (inv \\<sigma>')) = Var\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     comp_subst_abbrev (Var \\<circ> \\<sigma>') (Var \\<circ> inv \\<sigma>')\n      x =\n     Var x\n\ngoal (1 subgoal):\n 1. comp_subst_abbrev \\<sigma> (Var \\<circ> inv \\<sigma>') = Var", "using \\<sigma>"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     comp_subst_abbrev (Var \\<circ> \\<sigma>') (Var \\<circ> inv \\<sigma>')\n      x =\n     Var x\n  \\<sigma> = Var \\<circ> \\<sigma>'\n\ngoal (1 subgoal):\n 1. comp_subst_abbrev \\<sigma> (Var \\<circ> inv \\<sigma>') = Var", "by auto"], ["proof (state)\nthis:\n  comp_subst_abbrev \\<sigma> (Var \\<circ> inv \\<sigma>') = Var\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x. is_Var (\\<sigma> x); inj \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_renaming \\<sigma>", "then"], ["proof (chain)\npicking this:\n  comp_subst_abbrev \\<sigma> (Var \\<circ> inv \\<sigma>') = Var", "show \"is_renaming \\<sigma>\""], ["proof (prove)\nusing this:\n  comp_subst_abbrev \\<sigma> (Var \\<circ> inv \\<sigma>') = Var\n\ngoal (1 subgoal):\n 1. IsaFoR_Term.is_renaming \\<sigma>", "unfolding is_renaming_def"], ["proof (prove)\nusing this:\n  comp_subst_abbrev \\<sigma> (Var \\<circ> inv \\<sigma>') = Var\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>. comp_subst_abbrev \\<sigma> \\<tau> = Var", "by blast"], ["proof (state)\nthis:\n  IsaFoR_Term.is_renaming \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x. is_Var (?\\<sigma> x); inj ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> IsaFoR_Term.is_renaming ?\\<sigma>\n\ngoal (4 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 3. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 4. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x. is_Var (?\\<sigma> x); inj ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> IsaFoR_Term.is_renaming ?\\<sigma>", "have \"\\<forall>\\<sigma> \\<in> (set (renamings_apart Cs)). is_renaming \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. is_Var (?\\<sigma> x); inj ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> IsaFoR_Term.is_renaming ?\\<sigma>\n\ngoal (1 subgoal):\n 1. Ball (set (renamings_apart Cs)) IsaFoR_Term.is_renaming", "using renamings_apart_is_Var renamings_apart_inj"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. is_Var (?\\<sigma> x); inj ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> IsaFoR_Term.is_renaming ?\\<sigma>\n  \\<forall>\\<sigma>\\<in>set (renamings_apart ?Cs).\n     \\<forall>x. is_Var (\\<sigma> x)\n  \\<forall>\\<sigma>\\<in>set (renamings_apart ?Cs). inj \\<sigma>\n\ngoal (1 subgoal):\n 1. Ball (set (renamings_apart Cs)) IsaFoR_Term.is_renaming", "by blast"], ["proof (state)\nthis:\n  Ball (set (renamings_apart Cs)) IsaFoR_Term.is_renaming\n\ngoal (4 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 3. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 4. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "}"], ["proof (state)\nthis:\n  Ball (set (renamings_apart Cs)) IsaFoR_Term.is_renaming\n\ngoal (4 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>\\<rho> Cs.\n       \\<rho> \\<in> set (renamings_apart Cs) \\<Longrightarrow>\n       IsaFoR_Term.is_renaming \\<rho>\n 3. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 4. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "then"], ["proof (chain)\npicking this:\n  Ball (set (renamings_apart Cs)) IsaFoR_Term.is_renaming", "show \"is_renaming \\<rho>\""], ["proof (prove)\nusing this:\n  Ball (set (renamings_apart Cs)) IsaFoR_Term.is_renaming\n\ngoal (1 subgoal):\n 1. IsaFoR_Term.is_renaming \\<rho>", "using \\<rho>_renaming"], ["proof (prove)\nusing this:\n  Ball (set (renamings_apart Cs)) IsaFoR_Term.is_renaming\n  \\<rho> \\<in> set (renamings_apart Cs)\n\ngoal (1 subgoal):\n 1. IsaFoR_Term.is_renaming \\<rho>", "by auto"], ["proof (state)\nthis:\n  IsaFoR_Term.is_renaming \\<rho>\n\ngoal (3 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 3. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 3. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "fix Cs :: \"('f, nat) term clause list\""], ["proof (state)\ngoal (3 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 3. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "have \"vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))", "using vars_partitioned_renamings_apart"], ["proof (prove)\nusing this:\n  vars_partitioned (subst_cls_lists ?Cs (renamings_apart ?Cs))\n\ngoal (1 subgoal):\n 1. vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))", "by auto"], ["proof (state)\nthis:\n  vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (3 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>Cs. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n 3. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "then"], ["proof (chain)\npicking this:\n  vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))", "show \"var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\""], ["proof (prove)\nusing this:\n  vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (1 subgoal):\n 1. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))", "using vars_partitioned_var_disjoint"], ["proof (prove)\nusing this:\n  vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))\n  vars_partitioned ?Cs \\<Longrightarrow> var_disjoint ?Cs\n\ngoal (1 subgoal):\n 1. var_disjoint (subst_cls_lists Cs (renamings_apart Cs))", "by auto"], ["proof (state)\nthis:\n  var_disjoint (subst_cls_lists Cs (renamings_apart Cs))\n\ngoal (2 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. wfP strictly_generalizes_atm\n 2. \\<And>\\<sigma> As Bs.\n       (subst_atm_abbrev (Fun undefined As) \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. subst_atm_abbrev A \\<sigma>) As = Bs)", "show \"\\<And>\\<sigma> As Bs. Fun undefined As \\<cdot> \\<sigma> = Fun undefined Bs \\<longleftrightarrow> map (\\<lambda>A. A \\<cdot> \\<sigma>) As = Bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> As Bs.\n       (Fun undefined As \\<cdot> \\<sigma> = Fun undefined Bs) =\n       (map (\\<lambda>A. A \\<cdot> \\<sigma>) As = Bs)", "by simp"], ["proof (state)\nthis:\n  (Fun undefined ?As \\<cdot> ?\\<sigma> = Fun undefined ?Bs) =\n  (map (\\<lambda>A. A \\<cdot> ?\\<sigma>) ?As = ?Bs)\n\ngoal (1 subgoal):\n 1. wfP strictly_generalizes_atm", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP strictly_generalizes_atm", "show \"wfP (strictly_generalizes_atm :: ('f, 'v) term \\<Rightarrow> _ \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP strictly_generalizes_atm", "unfolding wfP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(x, y). strictly_generalizes_atm x y}", "by (rule wf_subset[OF wf_subsumes])\n      (auto simp: strictly_generalizes_atm_def generalizes_atm_def term_subsumable.subsumes_def\n        subsumeseq_term.simps)"], ["proof (state)\nthis:\n  wfP strictly_generalizes_atm\n\ngoal:\nNo subgoals!", "qed"], ["", "fun pairs :: \"'a list \\<Rightarrow> ('a \\<times> 'a) list\" where\n  \"pairs (x # y # xs) = (x, y) # pairs (y # xs)\" |\n  \"pairs _ = []\""], ["", "derive compare \"term\""], ["", "derive compare \"literal\""], ["", "lemma class_linorder_compare: \"class.linorder (le_of_comp compare) (lt_of_comp compare)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (le_of_comp compare) (lt_of_comp compare)", "apply standard"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. lt_of_comp compare x y = strict (le_of_comp compare) x y\n 2. \\<And>x. le_of_comp compare x x\n 3. \\<And>x y z.\n       \\<lbrakk>le_of_comp compare x y; le_of_comp compare y z\\<rbrakk>\n       \\<Longrightarrow> le_of_comp compare x z\n 4. \\<And>x y.\n       \\<lbrakk>le_of_comp compare x y; le_of_comp compare y x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y. le_of_comp compare x y \\<or> le_of_comp compare y x", "apply (simp_all add: lt_of_comp_def le_of_comp_def split: order.splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y. compare y x = Lt \\<longrightarrow> compare x y \\<noteq> Lt\n 2. \\<And>x y z.\n       \\<lbrakk>compare x y = Lt; compare y z = Lt\\<rbrakk>\n       \\<Longrightarrow> compare x z \\<noteq> Gt\n 3. \\<And>x y.\n       \\<lbrakk>compare x y = Lt; compare y x = Lt\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y. compare x y = Gt \\<longrightarrow> compare y x \\<noteq> Gt", "apply (metis comparator.sym comparator_compare invert_order.simps(1) order.distinct(5))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>compare x y = Lt; compare y z = Lt\\<rbrakk>\n       \\<Longrightarrow> compare x z \\<noteq> Gt\n 2. \\<And>x y.\n       \\<lbrakk>compare x y = Lt; compare y x = Lt\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y. compare x y = Gt \\<longrightarrow> compare y x \\<noteq> Gt", "apply (metis comparator_compare comparator_def order.distinct(5))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>compare x y = Lt; compare y x = Lt\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y. compare x y = Gt \\<longrightarrow> compare y x \\<noteq> Gt", "apply (metis comparator.sym comparator_compare invert_order.simps(1) order.distinct(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. compare x y = Gt \\<longrightarrow> compare y x \\<noteq> Gt", "by (metis comparator.sym comparator_compare invert_order.simps(2) order.distinct(5))"], ["", "context begin"], ["", "interpretation compare_linorder: linorder\n  \"le_of_comp compare\"\n  \"lt_of_comp compare\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (le_of_comp compare) (lt_of_comp compare)", "by (rule class_linorder_compare)"], ["", "definition Pairs where\n  \"Pairs AAA = concat (compare_linorder.sorted_list_of_set\n     ((pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA))\""], ["", "lemma unifies_all_pairs_iff:\n  \"(\\<forall>p \\<in> set (pairs xs). fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) \\<longleftrightarrow> (\\<forall>a \\<in> set xs. \\<forall>b \\<in> set xs. a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set (pairs xs).\n        fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n    (\\<forall>a\\<in>set xs.\n        \\<forall>b\\<in>set xs. a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)", "proof (induct xs rule: pairs.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y xs.\n       (\\<forall>p\\<in>set (pairs (y # xs)).\n           fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n       (\\<forall>a\\<in>set (y # xs).\n           \\<forall>b\\<in>set (y # xs).\n              a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>) \\<Longrightarrow>\n       (\\<forall>p\\<in>set (pairs (x # y # xs)).\n           fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n       (\\<forall>a\\<in>set (x # y # xs).\n           \\<forall>b\\<in>set (x # y # xs).\n              a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)\n 2. (\\<forall>p\\<in>set (pairs []).\n        fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n    (\\<forall>a\\<in>set [].\n        \\<forall>b\\<in>set []. a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)\n 3. \\<And>v.\n       (\\<forall>p\\<in>set (pairs [v]).\n           fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n       (\\<forall>a\\<in>set [v].\n           \\<forall>b\\<in>set [v]. a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)", "case (1 x y xs)"], ["proof (state)\nthis:\n  (\\<forall>p\\<in>set (pairs (y # xs)).\n      fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n  (\\<forall>a\\<in>set (y # xs).\n      \\<forall>b\\<in>set (y # xs). a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)\n\ngoal (3 subgoals):\n 1. \\<And>x y xs.\n       (\\<forall>p\\<in>set (pairs (y # xs)).\n           fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n       (\\<forall>a\\<in>set (y # xs).\n           \\<forall>b\\<in>set (y # xs).\n              a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>) \\<Longrightarrow>\n       (\\<forall>p\\<in>set (pairs (x # y # xs)).\n           fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n       (\\<forall>a\\<in>set (x # y # xs).\n           \\<forall>b\\<in>set (x # y # xs).\n              a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)\n 2. (\\<forall>p\\<in>set (pairs []).\n        fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n    (\\<forall>a\\<in>set [].\n        \\<forall>b\\<in>set []. a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)\n 3. \\<And>v.\n       (\\<forall>p\\<in>set (pairs [v]).\n           fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n       (\\<forall>a\\<in>set [v].\n           \\<forall>b\\<in>set [v]. a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  (\\<forall>p\\<in>set (pairs (y # xs)).\n      fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n  (\\<forall>a\\<in>set (y # xs).\n      \\<forall>b\\<in>set (y # xs). a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>p\\<in>set (pairs (y # xs)).\n      fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n  (\\<forall>a\\<in>set (y # xs).\n      \\<forall>b\\<in>set (y # xs). a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>set (pairs (x # y # xs)).\n        fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n    (\\<forall>a\\<in>set (x # y # xs).\n        \\<forall>b\\<in>set (x # y # xs).\n           a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)", "unfolding pairs.simps list.set ball_Un ball_simps simp_thms fst_conv snd_conv"], ["proof (prove)\nusing this:\n  (\\<forall>p\\<in>set (pairs (y # xs)).\n      fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n  ((\\<forall>b\\<in>set xs. y \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>) \\<and>\n   (\\<forall>a\\<in>set xs.\n       a \\<cdot> \\<sigma> = y \\<cdot> \\<sigma> \\<and>\n       (\\<forall>b\\<in>set xs. a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)))\n\ngoal (1 subgoal):\n 1. (x \\<cdot> \\<sigma> = y \\<cdot> \\<sigma> \\<and>\n     (\\<forall>p\\<in>set (pairs (y # xs)).\n         fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>)) =\n    ((x \\<cdot> \\<sigma> = y \\<cdot> \\<sigma> \\<and>\n      (\\<forall>b\\<in>set xs.\n          x \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)) \\<and>\n     (y \\<cdot> \\<sigma> = x \\<cdot> \\<sigma> \\<and>\n      (\\<forall>b\\<in>set xs.\n          y \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)) \\<and>\n     (\\<forall>a\\<in>set xs.\n         a \\<cdot> \\<sigma> = x \\<cdot> \\<sigma> \\<and>\n         a \\<cdot> \\<sigma> = y \\<cdot> \\<sigma> \\<and>\n         (\\<forall>b\\<in>set xs. a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)))", "by metis"], ["proof (state)\nthis:\n  (\\<forall>p\\<in>set (pairs (x # y # xs)).\n      fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n  (\\<forall>a\\<in>set (x # y # xs).\n      \\<forall>b\\<in>set (x # y # xs).\n         a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)\n\ngoal (2 subgoals):\n 1. (\\<forall>p\\<in>set (pairs []).\n        fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n    (\\<forall>a\\<in>set [].\n        \\<forall>b\\<in>set []. a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)\n 2. \\<And>v.\n       (\\<forall>p\\<in>set (pairs [v]).\n           fst p \\<cdot> \\<sigma> = snd p \\<cdot> \\<sigma>) =\n       (\\<forall>a\\<in>set [v].\n           \\<forall>b\\<in>set [v]. a \\<cdot> \\<sigma> = b \\<cdot> \\<sigma>)", "qed simp_all"], ["", "lemma in_pair_in_set:\n  assumes \"(A,B) \\<in> set ((pairs As))\"\n  shows \"A \\<in> set As \\<and> B \\<in> set As\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> set As \\<and> B \\<in> set As", "using assms"], ["proof (prove)\nusing this:\n  (A, B) \\<in> set (pairs As)\n\ngoal (1 subgoal):\n 1. A \\<in> set As \\<and> B \\<in> set As", "proof (induction As)"], ["proof (state)\ngoal (2 subgoals):\n 1. (A, B) \\<in> set (pairs []) \\<Longrightarrow>\n    A \\<in> set [] \\<and> B \\<in> set []\n 2. \\<And>a As.\n       \\<lbrakk>(A, B) \\<in> set (pairs As) \\<Longrightarrow>\n                A \\<in> set As \\<and> B \\<in> set As;\n        (A, B) \\<in> set (pairs (a # As))\\<rbrakk>\n       \\<Longrightarrow> A \\<in> set (a # As) \\<and> B \\<in> set (a # As)", "case (Cons A As)"], ["proof (state)\nthis:\n  (A, B) \\<in> set (pairs As) \\<Longrightarrow>\n  A \\<in> set As \\<and> B \\<in> set As\n  (A, B) \\<in> set (pairs (A # As))\n\ngoal (2 subgoals):\n 1. (A, B) \\<in> set (pairs []) \\<Longrightarrow>\n    A \\<in> set [] \\<and> B \\<in> set []\n 2. \\<And>a As.\n       \\<lbrakk>(A, B) \\<in> set (pairs As) \\<Longrightarrow>\n                A \\<in> set As \\<and> B \\<in> set As;\n        (A, B) \\<in> set (pairs (a # As))\\<rbrakk>\n       \\<Longrightarrow> A \\<in> set (a # As) \\<and> B \\<in> set (a # As)", "note Cons_outer = this"], ["proof (state)\nthis:\n  (A, B) \\<in> set (pairs As) \\<Longrightarrow>\n  A \\<in> set As \\<and> B \\<in> set As\n  (A, B) \\<in> set (pairs (A # As))\n\ngoal (2 subgoals):\n 1. (A, B) \\<in> set (pairs []) \\<Longrightarrow>\n    A \\<in> set [] \\<and> B \\<in> set []\n 2. \\<And>a As.\n       \\<lbrakk>(A, B) \\<in> set (pairs As) \\<Longrightarrow>\n                A \\<in> set As \\<and> B \\<in> set As;\n        (A, B) \\<in> set (pairs (a # As))\\<rbrakk>\n       \\<Longrightarrow> A \\<in> set (a # As) \\<and> B \\<in> set (a # As)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> set (A # As) \\<and> B \\<in> set (A # As)", "proof (cases As)"], ["proof (state)\ngoal (2 subgoals):\n 1. As = [] \\<Longrightarrow>\n    A \\<in> set (A # As) \\<and> B \\<in> set (A # As)\n 2. \\<And>a list.\n       As = a # list \\<Longrightarrow>\n       A \\<in> set (A # As) \\<and> B \\<in> set (A # As)", "case Nil"], ["proof (state)\nthis:\n  As = []\n\ngoal (2 subgoals):\n 1. As = [] \\<Longrightarrow>\n    A \\<in> set (A # As) \\<and> B \\<in> set (A # As)\n 2. \\<And>a list.\n       As = a # list \\<Longrightarrow>\n       A \\<in> set (A # As) \\<and> B \\<in> set (A # As)", "then"], ["proof (chain)\npicking this:\n  As = []", "show ?thesis"], ["proof (prove)\nusing this:\n  As = []\n\ngoal (1 subgoal):\n 1. A \\<in> set (A # As) \\<and> B \\<in> set (A # As)", "using Cons_outer"], ["proof (prove)\nusing this:\n  As = []\n  (A, B) \\<in> set (pairs As) \\<Longrightarrow>\n  A \\<in> set As \\<and> B \\<in> set As\n  (A, B) \\<in> set (pairs (A # As))\n\ngoal (1 subgoal):\n 1. A \\<in> set (A # As) \\<and> B \\<in> set (A # As)", "by auto"], ["proof (state)\nthis:\n  A \\<in> set (A # As) \\<and> B \\<in> set (A # As)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       As = a # list \\<Longrightarrow>\n       A \\<in> set (A # As) \\<and> B \\<in> set (A # As)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       As = a # list \\<Longrightarrow>\n       A \\<in> set (A # As) \\<and> B \\<in> set (A # As)", "case (Cons B As')"], ["proof (state)\nthis:\n  As = B # As'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       As = a # list \\<Longrightarrow>\n       A \\<in> set (A # As) \\<and> B \\<in> set (A # As)", "then"], ["proof (chain)\npicking this:\n  As = B # As'", "show ?thesis"], ["proof (prove)\nusing this:\n  As = B # As'\n\ngoal (1 subgoal):\n 1. A \\<in> set (A # As) \\<and> B \\<in> set (A # As)", "using Cons_outer"], ["proof (prove)\nusing this:\n  As = B # As'\n  (A, B) \\<in> set (pairs As) \\<Longrightarrow>\n  A \\<in> set As \\<and> B \\<in> set As\n  (A, B) \\<in> set (pairs (A # As))\n\ngoal (1 subgoal):\n 1. A \\<in> set (A # As) \\<and> B \\<in> set (A # As)", "by auto"], ["proof (state)\nthis:\n  A \\<in> set (A # As) \\<and> B \\<in> set (A # As)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A \\<in> set (A # As) \\<and> B \\<in> set (A # As)\n\ngoal (1 subgoal):\n 1. (A, B) \\<in> set (pairs []) \\<Longrightarrow>\n    A \\<in> set [] \\<and> B \\<in> set []", "qed auto"], ["", "lemma in_pairs_sorted_list_of_set_in_set:\n  assumes\n    \"finite AAA\"\n    \"\\<forall>AA \\<in> AAA. finite AA\"\n    \"AB_pairs \\<in> (pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA\" and\n    \"(A :: _ :: compare, B) \\<in> set AB_pairs\"\n  shows \"\\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA", "from assms"], ["proof (chain)\npicking this:\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  AB_pairs \\<in> (pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA\n  (A, B) \\<in> set AB_pairs", "have \"AB_pairs \\<in> (pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA\""], ["proof (prove)\nusing this:\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  AB_pairs \\<in> (pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA\n  (A, B) \\<in> set AB_pairs\n\ngoal (1 subgoal):\n 1. AB_pairs \\<in> (pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA", "by auto"], ["proof (state)\nthis:\n  AB_pairs \\<in> (pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA\n\ngoal (1 subgoal):\n 1. \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA", "then"], ["proof (chain)\npicking this:\n  AB_pairs \\<in> (pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA", "obtain AA where\n    AA_p: \"AA \\<in> AAA \\<and> (pairs \\<circ> compare_linorder.sorted_list_of_set) AA = AB_pairs\""], ["proof (prove)\nusing this:\n  AB_pairs \\<in> (pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA\n\ngoal (1 subgoal):\n 1. (\\<And>AA.\n        AA \\<in> AAA \\<and>\n        (pairs \\<circ> compare_linorder.sorted_list_of_set) AA =\n        AB_pairs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  AA \\<in> AAA \\<and>\n  (pairs \\<circ> compare_linorder.sorted_list_of_set) AA = AB_pairs\n\ngoal (1 subgoal):\n 1. \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA", "have \"(A, B) \\<in> set (pairs (compare_linorder.sorted_list_of_set AA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, B) \\<in> set (pairs (compare_linorder.sorted_list_of_set AA))", "using AA_p[] assms(4)"], ["proof (prove)\nusing this:\n  AA \\<in> AAA \\<and>\n  (pairs \\<circ> compare_linorder.sorted_list_of_set) AA = AB_pairs\n  (A, B) \\<in> set AB_pairs\n\ngoal (1 subgoal):\n 1. (A, B) \\<in> set (pairs (compare_linorder.sorted_list_of_set AA))", "by auto"], ["proof (state)\nthis:\n  (A, B) \\<in> set (pairs (compare_linorder.sorted_list_of_set AA))\n\ngoal (1 subgoal):\n 1. \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA", "then"], ["proof (chain)\npicking this:\n  (A, B) \\<in> set (pairs (compare_linorder.sorted_list_of_set AA))", "have \"A \\<in> set (compare_linorder.sorted_list_of_set AA)\" and\n    \"B \\<in> set (compare_linorder.sorted_list_of_set AA)\""], ["proof (prove)\nusing this:\n  (A, B) \\<in> set (pairs (compare_linorder.sorted_list_of_set AA))\n\ngoal (1 subgoal):\n 1. A \\<in> set (compare_linorder.sorted_list_of_set AA) &&&\n    B \\<in> set (compare_linorder.sorted_list_of_set AA)", "using in_pair_in_set[of A]"], ["proof (prove)\nusing this:\n  (A, B) \\<in> set (pairs (compare_linorder.sorted_list_of_set AA))\n  (A, ?B) \\<in> set (pairs ?As) \\<Longrightarrow>\n  A \\<in> set ?As \\<and> ?B \\<in> set ?As\n\ngoal (1 subgoal):\n 1. A \\<in> set (compare_linorder.sorted_list_of_set AA) &&&\n    B \\<in> set (compare_linorder.sorted_list_of_set AA)", "by auto"], ["proof (state)\nthis:\n  A \\<in> set (compare_linorder.sorted_list_of_set AA)\n  B \\<in> set (compare_linorder.sorted_list_of_set AA)\n\ngoal (1 subgoal):\n 1. \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA", "then"], ["proof (chain)\npicking this:\n  A \\<in> set (compare_linorder.sorted_list_of_set AA)\n  B \\<in> set (compare_linorder.sorted_list_of_set AA)", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<in> set (compare_linorder.sorted_list_of_set AA)\n  B \\<in> set (compare_linorder.sorted_list_of_set AA)\n\ngoal (1 subgoal):\n 1. \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA", "using assms(2) AA_p"], ["proof (prove)\nusing this:\n  A \\<in> set (compare_linorder.sorted_list_of_set AA)\n  B \\<in> set (compare_linorder.sorted_list_of_set AA)\n  \\<forall>AA\\<in>AAA. finite AA\n  AA \\<in> AAA \\<and>\n  (pairs \\<circ> compare_linorder.sorted_list_of_set) AA = AB_pairs\n\ngoal (1 subgoal):\n 1. \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA", "by auto"], ["proof (state)\nthis:\n  \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unifiers_Pairs:\n  assumes\n    \"finite AAA\" and\n    \"\\<forall>AA \\<in> AAA. finite AA\"\n  shows \"unifiers (set (Pairs AAA)) = {\\<sigma>. is_unifiers \\<sigma> AAA}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unifiers (set (Pairs AAA)) = {\\<sigma>. is_unifiers \\<sigma> AAA}", "proof (rule; rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> unifiers (set (Pairs AAA)) \\<Longrightarrow>\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n 2. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "fix \\<sigma> :: \"('a, 'b) subst\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> unifiers (set (Pairs AAA)) \\<Longrightarrow>\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n 2. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "assume asm: \"\\<sigma> \\<in> unifiers (set (Pairs AAA))\""], ["proof (state)\nthis:\n  \\<sigma> \\<in> unifiers (set (Pairs AAA))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> unifiers (set (Pairs AAA)) \\<Longrightarrow>\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n 2. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "have \"\\<And>AA. AA \\<in> AAA \\<Longrightarrow> card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA.\n       AA \\<in> AAA \\<Longrightarrow>\n       card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>AA.\n       AA \\<in> AAA \\<Longrightarrow>\n       card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0", "fix AA :: \"('a, 'b) term set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>AA.\n       AA \\<in> AAA \\<Longrightarrow>\n       card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0", "assume asm': \"AA \\<in> AAA\""], ["proof (state)\nthis:\n  AA \\<in> AAA\n\ngoal (1 subgoal):\n 1. \\<And>AA.\n       AA \\<in> AAA \\<Longrightarrow>\n       card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0", "then"], ["proof (chain)\npicking this:\n  AA \\<in> AAA", "have \"\\<forall>p \\<in> set (pairs (compare_linorder.sorted_list_of_set AA)).\n      subst_atm_abbrev (fst p) \\<sigma> = subst_atm_abbrev (snd p) \\<sigma>\""], ["proof (prove)\nusing this:\n  AA \\<in> AAA\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (pairs (compare_linorder.sorted_list_of_set AA)).\n       subst_atm_abbrev (fst p) \\<sigma> = subst_atm_abbrev (snd p) \\<sigma>", "using assms asm"], ["proof (prove)\nusing this:\n  AA \\<in> AAA\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  \\<sigma> \\<in> unifiers (set (Pairs AAA))\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (pairs (compare_linorder.sorted_list_of_set AA)).\n       subst_atm_abbrev (fst p) \\<sigma> = subst_atm_abbrev (snd p) \\<sigma>", "unfolding Pairs_def"], ["proof (prove)\nusing this:\n  AA \\<in> AAA\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  \\<sigma>\n  \\<in> unifiers\n         (set (concat\n                (compare_linorder.sorted_list_of_set\n                  ((pairs \\<circ> compare_linorder.sorted_list_of_set) `\n                   AAA))))\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (pairs (compare_linorder.sorted_list_of_set AA)).\n       subst_atm_abbrev (fst p) \\<sigma> = subst_atm_abbrev (snd p) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (pairs (compare_linorder.sorted_list_of_set AA)).\n     subst_atm_abbrev (fst p) \\<sigma> = subst_atm_abbrev (snd p) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>AA.\n       AA \\<in> AAA \\<Longrightarrow>\n       card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set (pairs (compare_linorder.sorted_list_of_set AA)).\n     subst_atm_abbrev (fst p) \\<sigma> = subst_atm_abbrev (snd p) \\<sigma>", "have \"\\<forall>A \\<in> AA. \\<forall>B \\<in> AA. subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (pairs (compare_linorder.sorted_list_of_set AA)).\n     subst_atm_abbrev (fst p) \\<sigma> = subst_atm_abbrev (snd p) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>AA.\n       \\<forall>B\\<in>AA.\n          subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "using assms asm'"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (pairs (compare_linorder.sorted_list_of_set AA)).\n     subst_atm_abbrev (fst p) \\<sigma> = subst_atm_abbrev (snd p) \\<sigma>\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  AA \\<in> AAA\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>AA.\n       \\<forall>B\\<in>AA.\n          subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "unfolding unifies_all_pairs_iff"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (compare_linorder.sorted_list_of_set AA).\n     \\<forall>b\\<in>set (compare_linorder.sorted_list_of_set AA).\n        subst_atm_abbrev a \\<sigma> = subst_atm_abbrev b \\<sigma>\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  AA \\<in> AAA\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>AA.\n       \\<forall>B\\<in>AA.\n          subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "using compare_linorder.sorted_list_of_set"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (compare_linorder.sorted_list_of_set AA).\n     \\<forall>b\\<in>set (compare_linorder.sorted_list_of_set AA).\n        subst_atm_abbrev a \\<sigma> = subst_atm_abbrev b \\<sigma>\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  AA \\<in> AAA\n  finite ?A \\<Longrightarrow>\n  set (compare_linorder.sorted_list_of_set ?A) = ?A\n  compare_linorder.sorted (compare_linorder.sorted_list_of_set ?A)\n  distinct (compare_linorder.sorted_list_of_set ?A)\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>AA.\n       \\<forall>B\\<in>AA.\n          subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>A\\<in>AA.\n     \\<forall>B\\<in>AA.\n        subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>AA.\n       AA \\<in> AAA \\<Longrightarrow>\n       card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>AA.\n     \\<forall>B\\<in>AA.\n        subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "show \"card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>AA.\n     \\<forall>B\\<in>AA.\n        subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\n\ngoal (1 subgoal):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0", "by (smt imageE card.empty card_Suc_eq card_mono finite.intros(1) finite_insert le_SucI\n           singletonI subsetI)"], ["proof (state)\nthis:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?AA1 \\<in> AAA \\<Longrightarrow>\n  card (?AA1 \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> unifiers (set (Pairs AAA)) \\<Longrightarrow>\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n 2. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "then"], ["proof (chain)\npicking this:\n  ?AA1 \\<in> AAA \\<Longrightarrow>\n  card (?AA1 \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0", "show \"\\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\""], ["proof (prove)\nusing this:\n  ?AA1 \\<in> AAA \\<Longrightarrow>\n  card (?AA1 \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}", "using assms"], ["proof (prove)\nusing this:\n  ?AA1 \\<in> AAA \\<Longrightarrow>\n  card (?AA1 \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}", "by (auto simp: is_unifiers_def is_unifier_def subst_atms_def)"], ["proof (state)\nthis:\n  \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "fix \\<sigma> :: \"('a, 'b) subst\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "assume asm: \"\\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\""], ["proof (state)\nthis:\n  \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "{"], ["proof (state)\nthis:\n  \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "fix AB_pairs A B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "assume\n      \"AB_pairs \\<in> set (compare_linorder.sorted_list_of_set\n         ((pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA))\" and\n      \"(A, B) \\<in> set AB_pairs\""], ["proof (state)\nthis:\n  AB_pairs\n  \\<in> set (compare_linorder.sorted_list_of_set\n              ((pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA))\n  (A, B) \\<in> set AB_pairs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "then"], ["proof (chain)\npicking this:\n  AB_pairs\n  \\<in> set (compare_linorder.sorted_list_of_set\n              ((pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA))\n  (A, B) \\<in> set AB_pairs", "have \"\\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA\""], ["proof (prove)\nusing this:\n  AB_pairs\n  \\<in> set (compare_linorder.sorted_list_of_set\n              ((pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA))\n  (A, B) \\<in> set AB_pairs\n\ngoal (1 subgoal):\n 1. \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA", "using assms"], ["proof (prove)\nusing this:\n  AB_pairs\n  \\<in> set (compare_linorder.sorted_list_of_set\n              ((pairs \\<circ> compare_linorder.sorted_list_of_set) ` AAA))\n  (A, B) \\<in> set AB_pairs\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n\ngoal (1 subgoal):\n 1. \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA", "by (simp add: in_pairs_sorted_list_of_set_in_set)"], ["proof (state)\nthis:\n  \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "then"], ["proof (chain)\npicking this:\n  \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA", "obtain AA where\n     a: \"AA \\<in> AAA\" \"A \\<in> AA\" \"B \\<in> AA\""], ["proof (prove)\nusing this:\n  \\<exists>AA. AA \\<in> AAA \\<and> A \\<in> AA \\<and> B \\<in> AA\n\ngoal (1 subgoal):\n 1. (\\<And>AA.\n        \\<lbrakk>AA \\<in> AAA; A \\<in> AA; B \\<in> AA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  AA \\<in> AAA\n  A \\<in> AA\n  B \\<in> AA\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "from a assms asm"], ["proof (chain)\npicking this:\n  AA \\<in> AAA\n  A \\<in> AA\n  B \\<in> AA\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}", "have card_AA_\\<sigma>: \"card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  AA \\<in> AAA\n  A \\<in> AA\n  B \\<in> AA\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n\ngoal (1 subgoal):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0", "unfolding is_unifiers_def is_unifier_def subst_atms_def"], ["proof (prove)\nusing this:\n  AA \\<in> AAA\n  A \\<in> AA\n  B \\<in> AA\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  \\<sigma>\n  \\<in> {\\<sigma>.\n         \\<forall>AA\\<in>AAA.\n            card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> 1}\n\ngoal (1 subgoal):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0", "by auto"], ["proof (state)\nthis:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "have \"subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "proof (cases \"card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = Suc 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) =\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\n 2. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq>\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "case True"], ["proof (state)\nthis:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = Suc 0\n\ngoal (2 subgoals):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) =\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\n 2. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq>\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "moreover"], ["proof (state)\nthis:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = Suc 0\n\ngoal (2 subgoals):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) =\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\n 2. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq>\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "have \"subst_atm_abbrev A \\<sigma> \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_atm_abbrev A \\<sigma>\n    \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>", "using a assms asm card_AA_\\<sigma>"], ["proof (prove)\nusing this:\n  AA \\<in> AAA\n  A \\<in> AA\n  B \\<in> AA\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. subst_atm_abbrev A \\<sigma>\n    \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_atm_abbrev A \\<sigma>\n  \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>\n\ngoal (2 subgoals):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) =\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\n 2. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq>\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "moreover"], ["proof (state)\nthis:\n  subst_atm_abbrev A \\<sigma>\n  \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>\n\ngoal (2 subgoals):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) =\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\n 2. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq>\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "have \"subst_atm_abbrev B \\<sigma> \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_atm_abbrev B \\<sigma>\n    \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>", "using a assms asm card_AA_\\<sigma>"], ["proof (prove)\nusing this:\n  AA \\<in> AAA\n  A \\<in> AA\n  B \\<in> AA\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. subst_atm_abbrev B \\<sigma>\n    \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_atm_abbrev B \\<sigma>\n  \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>\n\ngoal (2 subgoals):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) =\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\n 2. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq>\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "ultimately"], ["proof (chain)\npicking this:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = Suc 0\n  subst_atm_abbrev A \\<sigma>\n  \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>\n  subst_atm_abbrev B \\<sigma>\n  \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = Suc 0\n  subst_atm_abbrev A \\<sigma>\n  \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>\n  subst_atm_abbrev B \\<sigma>\n  \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "using a assms asm card_AA_\\<sigma>"], ["proof (prove)\nusing this:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = Suc 0\n  subst_atm_abbrev A \\<sigma>\n  \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>\n  subst_atm_abbrev B \\<sigma>\n  \\<in> AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>\n  AA \\<in> AAA\n  A \\<in> AA\n  B \\<in> AA\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "by (metis (no_types, lifting) card_Suc_eq singletonD)"], ["proof (state)\nthis:\n  subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\n\ngoal (1 subgoal):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq>\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq>\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "case False"], ["proof (state)\nthis:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq> Suc 0\n\ngoal (1 subgoal):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq>\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "then"], ["proof (chain)\npicking this:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq> Suc 0", "have \"card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = 0\""], ["proof (prove)\nusing this:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq> Suc 0\n\ngoal (1 subgoal):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = 0", "using a assms asm card_AA_\\<sigma>"], ["proof (prove)\nusing this:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq> Suc 0\n  AA \\<in> AAA\n  A \\<in> AA\n  B \\<in> AA\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = 0", "by arith"], ["proof (state)\nthis:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = 0\n\ngoal (1 subgoal):\n 1. card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<noteq>\n    Suc 0 \\<Longrightarrow>\n    subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "then"], ["proof (chain)\npicking this:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = 0\n\ngoal (1 subgoal):\n 1. subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "using a assms asm card_AA_\\<sigma>"], ["proof (prove)\nusing this:\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) = 0\n  AA \\<in> AAA\n  A \\<in> AA\n  B \\<in> AA\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}\n  card (AA \\<cdot>\\<^sub>s\\<^sub>e\\<^sub>t \\<sigma>) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_atm_abbrev A \\<sigma> = subst_atm_abbrev B \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?AB_pairs3\n           \\<in> set (compare_linorder.sorted_list_of_set\n                       ((pairs \\<circ>\n                         compare_linorder.sorted_list_of_set) `\n                        AAA));\n   (?A3, ?B3) \\<in> set ?AB_pairs3\\<rbrakk>\n  \\<Longrightarrow> subst_atm_abbrev ?A3 \\<sigma> =\n                    subst_atm_abbrev ?B3 \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<Longrightarrow>\n       x \\<in> unifiers (set (Pairs AAA))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?AB_pairs3\n           \\<in> set (compare_linorder.sorted_list_of_set\n                       ((pairs \\<circ>\n                         compare_linorder.sorted_list_of_set) `\n                        AAA));\n   (?A3, ?B3) \\<in> set ?AB_pairs3\\<rbrakk>\n  \\<Longrightarrow> subst_atm_abbrev ?A3 \\<sigma> =\n                    subst_atm_abbrev ?B3 \\<sigma>", "show \"\\<sigma> \\<in> unifiers (set (Pairs AAA))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?AB_pairs3\n           \\<in> set (compare_linorder.sorted_list_of_set\n                       ((pairs \\<circ>\n                         compare_linorder.sorted_list_of_set) `\n                        AAA));\n   (?A3, ?B3) \\<in> set ?AB_pairs3\\<rbrakk>\n  \\<Longrightarrow> subst_atm_abbrev ?A3 \\<sigma> =\n                    subst_atm_abbrev ?B3 \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<in> unifiers (set (Pairs AAA))", "unfolding Pairs_def unifiers_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?AB_pairs3\n           \\<in> set (compare_linorder.sorted_list_of_set\n                       ((pairs \\<circ>\n                         compare_linorder.sorted_list_of_set) `\n                        AAA));\n   (?A3, ?B3) \\<in> set ?AB_pairs3\\<rbrakk>\n  \\<Longrightarrow> subst_atm_abbrev ?A3 \\<sigma> =\n                    subst_atm_abbrev ?B3 \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma>\n    \\<in> {\\<sigma>.\n           \\<forall>p\\<in>set (concat\n                                (compare_linorder.sorted_list_of_set\n                                  ((pairs \\<circ>\n                                    compare_linorder.sorted_list_of_set) `\n                                   AAA))).\n              subst_atm_abbrev (fst p) \\<sigma> =\n              subst_atm_abbrev (snd p) \\<sigma>}", "by auto"], ["proof (state)\nthis:\n  \\<sigma> \\<in> unifiers (set (Pairs AAA))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition \"mgu_sets AAA = map_option subst_of (unify (Pairs AAA) [])\""], ["", "interpretation mgu \"(\\<cdot>)\" \"Var :: _ \\<Rightarrow> ('f :: compare, nat) term\" \"(\\<circ>\\<^sub>s)\" \"Fun undefined\"\n  renamings_apart mgu_sets"], ["proof (prove)\ngoal (1 subgoal):\n 1. mgu subst_atm_abbrev Var comp_subst_abbrev (Fun undefined)\n     renamings_apart mgu_sets", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        mgu_sets AAA = Some \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_mgu \\<sigma> AAA\n 2. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        is_unifiers \\<sigma> AAA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>", "fix AAA :: \"('a :: compare, nat) term set set\" and \\<sigma> :: \"('a, nat) subst\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        mgu_sets AAA = Some \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_mgu \\<sigma> AAA\n 2. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        is_unifiers \\<sigma> AAA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>", "assume fin: \"finite AAA\" \"\\<forall>AA \\<in> AAA. finite AA\" and \"mgu_sets AAA = Some \\<sigma>\""], ["proof (state)\nthis:\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  mgu_sets AAA = Some \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        mgu_sets AAA = Some \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_mgu \\<sigma> AAA\n 2. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        is_unifiers \\<sigma> AAA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>", "then"], ["proof (chain)\npicking this:\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  mgu_sets AAA = Some \\<sigma>", "have \"is_imgu \\<sigma> (set (Pairs AAA))\""], ["proof (prove)\nusing this:\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  mgu_sets AAA = Some \\<sigma>\n\ngoal (1 subgoal):\n 1. is_imgu \\<sigma> (set (Pairs AAA))", "using unify_sound"], ["proof (prove)\nusing this:\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  mgu_sets AAA = Some \\<sigma>\n  unify ?E [] = Some ?cs \\<Longrightarrow> is_imgu (subst_of ?cs) (set ?E)\n\ngoal (1 subgoal):\n 1. is_imgu \\<sigma> (set (Pairs AAA))", "unfolding mgu_sets_def"], ["proof (prove)\nusing this:\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  map_option subst_of (unify (Pairs AAA) []) = Some \\<sigma>\n  unify ?E [] = Some ?cs \\<Longrightarrow> is_imgu (subst_of ?cs) (set ?E)\n\ngoal (1 subgoal):\n 1. is_imgu \\<sigma> (set (Pairs AAA))", "by blast"], ["proof (state)\nthis:\n  is_imgu \\<sigma> (set (Pairs AAA))\n\ngoal (2 subgoals):\n 1. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        mgu_sets AAA = Some \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> IsaFoR_Term.is_mgu \\<sigma> AAA\n 2. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        is_unifiers \\<sigma> AAA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>", "then"], ["proof (chain)\npicking this:\n  is_imgu \\<sigma> (set (Pairs AAA))", "show \"is_mgu \\<sigma> AAA\""], ["proof (prove)\nusing this:\n  is_imgu \\<sigma> (set (Pairs AAA))\n\ngoal (1 subgoal):\n 1. IsaFoR_Term.is_mgu \\<sigma> AAA", "unfolding is_imgu_def is_mgu_def unifiers_Pairs[OF fin]"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA} \\<and>\n  (\\<forall>\\<tau>\\<in>{\\<sigma>. is_unifiers \\<sigma> AAA}.\n      \\<tau> = comp_subst_abbrev \\<sigma> \\<tau>)\n\ngoal (1 subgoal):\n 1. is_unifiers \\<sigma> AAA \\<and>\n    (\\<forall>\\<tau>.\n        is_unifiers \\<tau> AAA \\<longrightarrow>\n        (\\<exists>\\<gamma>. \\<tau> = comp_subst_abbrev \\<sigma> \\<gamma>))", "by auto"], ["proof (state)\nthis:\n  IsaFoR_Term.is_mgu \\<sigma> AAA\n\ngoal (1 subgoal):\n 1. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        is_unifiers \\<sigma> AAA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        is_unifiers \\<sigma> AAA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>", "fix AAA :: \"('a :: compare, nat) term set set\" and \\<sigma> :: \"('a, nat) subst\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        is_unifiers \\<sigma> AAA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>", "assume fin: \"finite AAA\" \"\\<forall>AA \\<in> AAA. finite AA\" and \"is_unifiers \\<sigma> AAA\""], ["proof (state)\nthis:\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  is_unifiers \\<sigma> AAA\n\ngoal (1 subgoal):\n 1. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        is_unifiers \\<sigma> AAA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>", "then"], ["proof (chain)\npicking this:\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  is_unifiers \\<sigma> AAA", "have \"\\<sigma> \\<in> unifiers (set (Pairs AAA))\""], ["proof (prove)\nusing this:\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  is_unifiers \\<sigma> AAA\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<in> unifiers (set (Pairs AAA))", "unfolding is_mgu_def unifiers_Pairs[OF fin]"], ["proof (prove)\nusing this:\n  finite AAA\n  \\<forall>AA\\<in>AAA. finite AA\n  is_unifiers \\<sigma> AAA\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<in> {\\<sigma>. is_unifiers \\<sigma> AAA}", "by auto"], ["proof (state)\nthis:\n  \\<sigma> \\<in> unifiers (set (Pairs AAA))\n\ngoal (1 subgoal):\n 1. \\<And>AAA \\<sigma>.\n       \\<lbrakk>finite AAA; \\<forall>AA\\<in>AAA. finite AA;\n        is_unifiers \\<sigma> AAA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>", "then"], ["proof (chain)\npicking this:\n  \\<sigma> \\<in> unifiers (set (Pairs AAA))", "show \"\\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> unifiers (set (Pairs AAA))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>", "using unify_complete"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> unifiers (set (Pairs AAA))\n  unify ?E ?bs = None \\<Longrightarrow> unifiers (set ?E) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>", "unfolding mgu_sets_def"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> unifiers (set (Pairs AAA))\n  unify ?E ?bs = None \\<Longrightarrow> unifiers (set ?E) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>.\n       map_option subst_of (unify (Pairs AAA) []) = Some \\<tau>", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<tau>. mgu_sets AAA = Some \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "derive linorder prod"], ["", "derive linorder list"], ["", "text \\<open>\nThis part extends and integrates and the Knuth--Bendix order defined in\n\\textsf{IsaFoR}.\n\\<close>"], ["", "record 'f weights =\n  w :: \"'f \\<times> nat \\<Rightarrow> nat\"\n  w0 :: nat\n  pr_strict :: \"'f \\<times> nat \\<Rightarrow> 'f \\<times> nat \\<Rightarrow> bool\"\n  least :: \"'f \\<Rightarrow> bool\"\n  scf :: \"'f \\<times> nat \\<Rightarrow> nat \\<Rightarrow> nat\""], ["", "class weighted =\n  fixes weights :: \"'a weights\"\n  assumes weights_adm:\n    \"admissible_kbo\n       (w weights) (w0 weights) (pr_strict weights) ((pr_strict weights)\\<^sup>=\\<^sup>=) (least weights) (scf weights)\"\n  and pr_strict_total: \"fi = gj \\<or> pr_strict weights fi gj \\<or> pr_strict weights gj fi\"\n  and pr_strict_asymp: \"asymp (pr_strict weights)\"\n  and scf_ok: \"i < n \\<Longrightarrow> scf weights (f, n) i \\<le> 1\""], ["", "instantiation unit :: weighted begin"], ["", "definition weights_unit :: \"unit weights\" where \"weights_unit =\n  \\<lparr>w = Suc \\<circ> snd, w0 = 1, pr_strict = \\<lambda>(_, n) (_, m). n > m, least = \\<lambda>_. True, scf = \\<lambda>_ _. 1\\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, weighted_class)", "by (intro_classes, unfold_locales) (auto simp: weights_unit_def SN_iff_wf asymp.simps irreflp_def\n      intro!: wf_subset[OF wf_inv_image[OF wf], of _ snd])"], ["", "end"], ["", "global_interpretation KBO:\n  admissible_kbo\n    \"w (weights :: 'f :: weighted weights)\" \"w0 (weights :: 'f :: weighted weights)\"\n    \"pr_strict weights\" \"((pr_strict weights)\\<^sup>=\\<^sup>=)\" \"least weights\" \"scf weights\"\n    defines weight = KBO.weight\n    and kbo = KBO.kbo"], ["proof (prove)\ngoal (1 subgoal):\n 1. admissible_kbo (w weights) (w0 weights) (pr_strict weights)\n     (pr_strict weights)\\<^sup>=\\<^sup>= (least weights) (scf weights)", "by (simp add: weights_adm)"], ["", "lemma kbo_code[code]: \"kbo s t =\n  (let wt = weight t; ws = weight s in\n  if vars_term_ms (KBO.SCF t) \\<subseteq># vars_term_ms (KBO.SCF s) \\<and> wt \\<le> ws\n  then\n    (if wt < ws then (True, True)\n    else\n      (case s of\n        Var y \\<Rightarrow> (False, case t of Var x \\<Rightarrow> True | Fun g ts \\<Rightarrow> ts = [] \\<and> least weights g)\n      | Fun f ss \\<Rightarrow>\n          (case t of\n            Var x \\<Rightarrow> (True, True)\n          | Fun g ts \\<Rightarrow>\n              if pr_strict weights (f, length ss) (g, length ts) then (True, True)\n              else if (f, length ss) = (g, length ts) then lex_ext_unbounded kbo ss ts\n              else (False, False))))\n  else (False, False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kbo s t =\n    (let wt = weight t; ws = weight s\n     in if vars_term_ms (KBO.SCF t) \\<subseteq>#\n           vars_term_ms (KBO.SCF s) \\<and>\n           wt \\<le> ws\n        then if wt < ws then (True, True)\n             else case s of\n                  Var y \\<Rightarrow>\n                    (False,\n                     case t of Var x \\<Rightarrow> True\n                     | Fun g ts \\<Rightarrow>\n                         ts = [] \\<and> least weights g)\n                  | Fun f ss \\<Rightarrow>\n                      case t of Var x \\<Rightarrow> (True, True)\n                      | Fun g ts \\<Rightarrow>\n                          if pr_strict weights (f, length ss) (g, length ts)\n                          then (True, True)\n                          else if (f, length ss) = (g, length ts)\n                               then lex_ext_unbounded kbo ss ts\n                               else (False, False)\n        else (False, False))", "by (subst KBO.kbo.simps) (auto simp: Let_def split: term.splits)"], ["", "definition \"less_kbo s t = fst (kbo t s)\""], ["", "lemma less_kbo_gtotal: \"ground s \\<Longrightarrow> ground t \\<Longrightarrow> s = t \\<or> less_kbo s t \\<or> less_kbo t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ground s; ground t\\<rbrakk>\n    \\<Longrightarrow> s = t \\<or> less_kbo s t \\<or> less_kbo t s", "unfolding less_kbo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ground s; ground t\\<rbrakk>\n    \\<Longrightarrow> s = t \\<or> fst (kbo t s) \\<or> fst (kbo s t)", "using KBO.S_ground_total"], ["proof (prove)\nusing this:\n  \\<lbrakk>(pr_strict weights)\\<^sup>=\\<^sup>= =\n           (pr_strict weights)\\<^sup>=\\<^sup>=;\n   \\<And>f g.\n      \\<lbrakk>f \\<in> ?F; g \\<in> ?F\\<rbrakk>\n      \\<Longrightarrow> f = g \\<or>\n                        pr_strict weights f g \\<or> pr_strict weights g f;\n   funas_term ?s \\<subseteq> ?F; ground ?s; funas_term ?t \\<subseteq> ?F;\n   ground ?t\\<rbrakk>\n  \\<Longrightarrow> ?s = ?t \\<or> fst (kbo ?s ?t) \\<or> fst (kbo ?t ?s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ground s; ground t\\<rbrakk>\n    \\<Longrightarrow> s = t \\<or> fst (kbo t s) \\<or> fst (kbo s t)", "by (metis pr_strict_total subset_UNIV)"], ["", "lemma less_kbo_subst:\n  fixes \\<sigma> :: \"('f :: weighted, 'v) subst\"\n  shows \"less_kbo s t \\<Longrightarrow> less_kbo (s \\<cdot> \\<sigma>) (t \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. less_kbo s t \\<Longrightarrow>\n    less_kbo (subst_atm_abbrev s \\<sigma>) (subst_atm_abbrev t \\<sigma>)", "unfolding less_kbo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (kbo t s) \\<Longrightarrow>\n    fst (kbo (subst_atm_abbrev t \\<sigma>) (subst_atm_abbrev s \\<sigma>))", "by (rule KBO.S_subst)"], ["", "lemma wfP_less_kbo: \"wfP less_kbo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP less_kbo", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP less_kbo", "have \"SN {(x, y). fst (kbo x y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN {(x, y). fst (kbo x y)}", "using pr_strict_asymp"], ["proof (prove)\nusing this:\n  asymp (pr_strict weights)\n\ngoal (1 subgoal):\n 1. SN {(x, y). fst (kbo x y)}", "by (fastforce simp: asymp.simps irreflp_def intro!: KBO.S_SN scf_ok)"], ["proof (state)\nthis:\n  SN {(x, y). fst (kbo x y)}\n\ngoal (1 subgoal):\n 1. wfP less_kbo", "then"], ["proof (chain)\npicking this:\n  SN {(x, y). fst (kbo x y)}", "show ?thesis"], ["proof (prove)\nusing this:\n  SN {(x, y). fst (kbo x y)}\n\ngoal (1 subgoal):\n 1. wfP less_kbo", "unfolding SN_iff_wf wfP_def"], ["proof (prove)\nusing this:\n  wf ({(x, y). fst (kbo x y)}\\<inverse>)\n\ngoal (1 subgoal):\n 1. wf {(x, y). less_kbo x y}", "by (rule wf_subset) (auto simp: less_kbo_def)"], ["proof (state)\nthis:\n  wfP less_kbo\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation \"term\" :: (weighted, type) linorder begin"], ["", "definition \"leq_term = (SOME leq. {(s,t). less_kbo s t} \\<subseteq> leq \\<and> Well_order leq \\<and> Field leq = UNIV)\""], ["", "lemma less_trm_extension: \"{(s,t). less_kbo s t} \\<subseteq> leq_term\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t). less_kbo s t} \\<subseteq> leq_term", "unfolding leq_term_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t). less_kbo s t}\n    \\<subseteq> (SOME leq.\n                    {(x, y). less_kbo x y} \\<subseteq> leq \\<and>\n                    Well_order leq \\<and> Field leq = UNIV)", "by (rule someI2_ex[OF total_well_order_extension[OF wfP_less_kbo[unfolded wfP_def]]]) auto"], ["", "lemma less_trm_well_order: \"well_order leq_term\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_order leq_term", "unfolding leq_term_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. well_order\n     (SOME leq.\n         {(x, y). less_kbo x y} \\<subseteq> leq \\<and>\n         Well_order leq \\<and> Field leq = UNIV)", "by (rule someI2_ex[OF total_well_order_extension[OF wfP_less_kbo[unfolded wfP_def]]]) auto"], ["", "definition less_eq_term :: \"('a :: weighted, 'b) term \\<Rightarrow> _ \\<Rightarrow> bool\" where\n  \"less_eq_term = in_rel leq_term\""], ["", "definition less_term :: \"('a :: weighted, 'b) term \\<Rightarrow> _ \\<Rightarrow> bool\" where\n  \"less_term s t = strict (\\<le>) s t\""], ["", "lemma leq_term_minus_Id: \"leq_term - Id = {(x,y). x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leq_term - Id = {(x, y). x < y}", "using less_trm_well_order"], ["proof (prove)\nusing this:\n  well_order leq_term\n\ngoal (1 subgoal):\n 1. leq_term - Id = {(x, y). x < y}", "unfolding well_order_on_def linear_order_on_def partial_order_on_def antisym_def less_term_def less_eq_term_def"], ["proof (prove)\nusing this:\n  ((preorder_on UNIV leq_term \\<and>\n    (\\<forall>x y.\n        (x, y) \\<in> leq_term \\<longrightarrow>\n        (y, x) \\<in> leq_term \\<longrightarrow> x = y)) \\<and>\n   total leq_term) \\<and>\n  wf (leq_term - Id)\n\ngoal (1 subgoal):\n 1. leq_term - Id = {(x, y). strict (in_rel leq_term) x y}", "by auto"], ["", "lemma less_term_alt: \"(<) = in_rel (leq_term - Id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<) = in_rel (leq_term - Id)", "by (simp add: in_rel_Collect_case_prod_eq leq_term_minus_Id)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) Term.term, linorder_class)", "proof (standard, goal_cases less_less_eq refl trans antisym total)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = strict (\\<le>) x y\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "case (less_less_eq x y)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = strict (\\<le>) x y\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = strict (\\<le>) x y", "unfolding less_term_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict (\\<le>) x y = strict (\\<le>) x y", ".."], ["proof (state)\nthis:\n  (x < y) = strict (\\<le>) x y\n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "case (refl x)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "using less_trm_well_order"], ["proof (prove)\nusing this:\n  well_order leq_term\n\ngoal (1 subgoal):\n 1. x \\<le> x", "unfolding well_order_on_def linear_order_on_def partial_order_on_def preorder_on_def refl_on_def\n      less_eq_term_def"], ["proof (prove)\nusing this:\n  ((((leq_term \\<subseteq> UNIV \\<times> UNIV \\<and>\n      (\\<forall>x\\<in>UNIV. (x, x) \\<in> leq_term)) \\<and>\n     trans leq_term) \\<and>\n    antisym leq_term) \\<and>\n   total leq_term) \\<and>\n  wf (leq_term - Id)\n\ngoal (1 subgoal):\n 1. in_rel leq_term x x", "by auto"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "case (trans x y z)"], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> z\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "then"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> z", "show ?case"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> z", "using less_trm_well_order"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n  well_order leq_term\n\ngoal (1 subgoal):\n 1. x \\<le> z", "unfolding well_order_on_def linear_order_on_def partial_order_on_def preorder_on_def trans_def\n      less_eq_term_def"], ["proof (prove)\nusing this:\n  in_rel leq_term x y\n  in_rel leq_term y z\n  (((refl leq_term \\<and>\n     (\\<forall>x y z.\n         (x, y) \\<in> leq_term \\<longrightarrow>\n         (y, z) \\<in> leq_term \\<longrightarrow>\n         (x, z) \\<in> leq_term)) \\<and>\n    antisym leq_term) \\<and>\n   total leq_term) \\<and>\n  wf (leq_term - Id)\n\ngoal (1 subgoal):\n 1. in_rel leq_term x z", "by auto"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "case (antisym x y)"], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "then"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> x", "show ?case"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "using less_trm_well_order"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n  well_order leq_term\n\ngoal (1 subgoal):\n 1. x = y", "unfolding well_order_on_def linear_order_on_def partial_order_on_def antisym_def\n      less_eq_term_def"], ["proof (prove)\nusing this:\n  in_rel leq_term x y\n  in_rel leq_term y x\n  ((preorder_on UNIV leq_term \\<and>\n    (\\<forall>x y.\n        (x, y) \\<in> leq_term \\<longrightarrow>\n        (y, x) \\<in> leq_term \\<longrightarrow> x = y)) \\<and>\n   total leq_term) \\<and>\n  wf (leq_term - Id)\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "case (total x y)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<or> y \\<le> x", "using less_trm_well_order"], ["proof (prove)\nusing this:\n  well_order leq_term\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<or> y \\<le> x", "unfolding well_order_on_def linear_order_on_def partial_order_on_def preorder_on_def refl_on_def\n      Relation.total_on_def less_eq_term_def"], ["proof (prove)\nusing this:\n  ((((leq_term \\<subseteq> UNIV \\<times> UNIV \\<and>\n      (\\<forall>x\\<in>UNIV. (x, x) \\<in> leq_term)) \\<and>\n     trans leq_term) \\<and>\n    antisym leq_term) \\<and>\n   (\\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          x \\<noteq> y \\<longrightarrow>\n          (x, y) \\<in> leq_term \\<or> (y, x) \\<in> leq_term)) \\<and>\n  wf (leq_term - Id)\n\ngoal (1 subgoal):\n 1. in_rel leq_term x y \\<or> in_rel leq_term y x", "by (cases \"x = y\") auto"], ["proof (state)\nthis:\n  x \\<le> y \\<or> y \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation \"term\" :: (weighted, type) wellorder begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) Term.term, wellorder_class)", "using less_trm_well_order[unfolded well_order_on_def wf_def leq_term_minus_Id, THEN conjunct2]"], ["proof (prove)\nusing this:\n  \\<forall>P.\n     (\\<forall>x.\n         (\\<forall>y.\n             (y, x) \\<in> {(x, y). x < y} \\<longrightarrow>\n             P y) \\<longrightarrow>\n         P x) \\<longrightarrow>\n     All P\n\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) Term.term, wellorder_class)", "by intro_classes (atomize, auto)"], ["", "end"], ["", "lemma ground_less_less_kbo: \"ground s \\<Longrightarrow> ground t \\<Longrightarrow> s < t \\<Longrightarrow> less_kbo s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ground s; ground t; s < t\\<rbrakk>\n    \\<Longrightarrow> less_kbo s t", "using less_kbo_gtotal[of s t] less_trm_extension"], ["proof (prove)\nusing this:\n  \\<lbrakk>ground s; ground t\\<rbrakk>\n  \\<Longrightarrow> s = t \\<or> less_kbo s t \\<or> less_kbo t s\n  {(s, t). less_kbo s t} \\<subseteq> leq_term\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ground s; ground t; s < t\\<rbrakk>\n    \\<Longrightarrow> less_kbo s t", "by (auto simp: less_term_def less_eq_term_def)"], ["", "lemma less_kbo_less: \"less_kbo s t \\<Longrightarrow> s < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. less_kbo s t \\<Longrightarrow> s < t", "using less_trm_extension"], ["proof (prove)\nusing this:\n  {(s, t). less_kbo s t} \\<subseteq> leq_term\n\ngoal (1 subgoal):\n 1. less_kbo s t \\<Longrightarrow> s < t", "by (auto simp: less_term_alt less_kbo_def KBO.S_irrefl)"], ["", "lemma is_ground_atm_ground: \"is_ground_atm t \\<longleftrightarrow> ground t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ground_atm t = ground t", "unfolding is_ground_atm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<sigma>. t = subst_atm_abbrev t \\<sigma>) = ground t", "by (induct t) (fastforce simp: in_set_conv_nth list_eq_iff_nth_eq)+"], ["", "end"]]}