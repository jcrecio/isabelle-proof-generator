{"file_name": "/home/qj213/afp-2021-10-22/thys/Functional_Ordered_Resolution_Prover/Executable_FO_Ordered_Resolution_Prover.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Functional_Ordered_Resolution_Prover", "problem_names": ["lemma remove1_mset_subset_eq: \"remove1_mset a A \\<subseteq># B \\<longleftrightarrow> A \\<subseteq># add_mset a B\"", "lemma Bex_cong: \"(\\<And>b. b \\<in> B \\<Longrightarrow> P b = Q b) \\<Longrightarrow> Bex B P = Bex B Q\"", "lemma is_reducible_lit_code[code]: \"RP.is_reducible_lit Ds C L =\n  (\\<exists>D \\<in> set Ds. (\\<exists>L' \\<in> set D.\n     if is_pos L' = is_neg L then\n       (case match_term_list [(atm_of L', atm_of L)] Map.empty of\n         None \\<Rightarrow> False\n       | Some \\<sigma> \\<Rightarrow> subsumes_list (remove1 L' D) C \\<sigma>)\n     else False))\"", "theorem prover_complete_refutation: \"prover N \\<longleftrightarrow> satisfiable (RP.grounded_N0 N)\"", "lemma\n  assumes\n     \"p a a a a a a a a a a a a a a\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 a \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 b)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 a b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 b a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 a b b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 b a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 a b b b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 b a a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 a b b b b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 x9 b a a a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 a b b b b b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 b a a a a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 a b b b b b b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 b a a a a a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6.\n       \\<not> p x1 x2 x3 x4 x5 x6 a b b b b b b b \\<or>\n       p x1 x2 x3 x4 x5 x6 b a a a a a a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5.\n       \\<not> p x1 x2 x3 x4 x5 a b b b b b b b b \\<or>\n       p x1 x2 x3 x4 x5 b a a a a a a a a)\"\n     \"(\\<forall>x1 x2 x3 x4.\n       \\<not> p x1 x2 x3 x4 a b b b b b b b b b \\<or>\n       p x1 x2 x3 x4 b a a a a a a a a a)\"\n     \"(\\<forall>x1 x2 x3.\n       \\<not> p x1 x2 x3 a b b b b b b b b b b \\<or>\n       p x1 x2 x3 b a a a a a a a a a a)\"\n     \"(\\<forall>x1 x2.\n       \\<not> p x1 x2 a b b b b b b b b b b b \\<or>\n       p x1 x2 b a a a a a a a a a a a)\"\n     \"(\\<forall>x1.\n       \\<not> p x1 a b b b b b b b b b b b b \\<or>\n       p x1 b a a a a a a a a a a a a)\"\n     \"(\\<not> p a b b b b b b b b b b b b b \\<or>\n       p b a a a a a a a a a a a a a)\"\n     \"\\<not> p b b b b b b b b b b b b b b\"\n   shows False"], "translations": [["", "lemma remove1_mset_subset_eq: \"remove1_mset a A \\<subseteq># B \\<longleftrightarrow> A \\<subseteq># add_mset a B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (remove1_mset a A \\<subseteq># B) = (A \\<subseteq># add_mset a B)", "by (metis add_mset_add_single subset_eq_diff_conv)"], ["", "lemma Bex_cong: \"(\\<And>b. b \\<in> B \\<Longrightarrow> P b = Q b) \\<Longrightarrow> Bex B P = Bex B Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b. b \\<in> B \\<Longrightarrow> P b = Q b) \\<Longrightarrow>\n    Bex B P = Bex B Q", "by auto"], ["", "lemma is_reducible_lit_code[code]: \"RP.is_reducible_lit Ds C L =\n  (\\<exists>D \\<in> set Ds. (\\<exists>L' \\<in> set D.\n     if is_pos L' = is_neg L then\n       (case match_term_list [(atm_of L', atm_of L)] Map.empty of\n         None \\<Rightarrow> False\n       | Some \\<sigma> \\<Rightarrow> subsumes_list (remove1 L' D) C \\<sigma>)\n     else False))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_reducible_lit Ds C L =\n    (\\<exists>D\\<in>set Ds.\n        \\<exists>L'\\<in>set D.\n           if is_pos L' = is_neg L\n           then case match_term_list [(atm_of L', atm_of L)] Map.empty of\n                None \\<Rightarrow> False\n                | Some \\<sigma> \\<Rightarrow>\n                    subsumes_list (remove1 L' D) C \\<sigma>\n           else False)", "unfolding RP.is_reducible_lit_def subsumes_list_alt subsumes_modulo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>D\\<in>set Ds.\n        \\<exists>L'\\<in>set D.\n           \\<exists>\\<sigma>.\n              - L = subst_lit L' \\<sigma> \\<and>\n              subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n              mset C) =\n    (\\<exists>D\\<in>set Ds.\n        \\<exists>L'\\<in>set D.\n           if is_pos L' = is_neg L\n           then case match_term_list [(atm_of L', atm_of L)] Map.empty of\n                None \\<Rightarrow> False\n                | Some \\<sigma> \\<Rightarrow>\n                    \\<exists>\\<tau>.\n                       dom \\<tau> =\n                       vars_clause (mset (remove1 L' D)) \\<union>\n                       dom \\<sigma> \\<and>\n                       extends_subst \\<sigma> \\<tau> \\<and>\n                       subst_cls (mset (remove1 L' D))\n                        (subst_of_map Var \\<tau>) \\<subseteq>#\n                       mset C\n           else False)", "apply (rule Bex_cong)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ba.\n       \\<lbrakk>b \\<in> set Ds; ba \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>\\<sigma>.\n                             - L = subst_lit ba \\<sigma> \\<and>\n                             subst_cls (mset (remove1 ba b))\n                              \\<sigma> \\<subseteq>#\n                             mset C) =\n                         (if is_pos ba = is_neg L\n                          then case match_term_list [(atm_of ba, atm_of L)]\n                                     Map.empty of\n                               None \\<Rightarrow> False\n                               | Some \\<sigma> \\<Rightarrow>\n                                   \\<exists>\\<tau>.\ndom \\<tau> = vars_clause (mset (remove1 ba b)) \\<union> dom \\<sigma> \\<and>\nextends_subst \\<sigma> \\<tau> \\<and>\nsubst_cls (mset (remove1 ba b)) (subst_of_map Var \\<tau>) \\<subseteq>#\nmset C\n                          else False)", "subgoal for D L'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>\\<sigma>.\n                          - L = subst_lit L' \\<sigma> \\<and>\n                          subst_cls (mset (remove1 L' D))\n                           \\<sigma> \\<subseteq>#\n                          mset C) =\n                      (if is_pos L' = is_neg L\n                       then case match_term_list [(atm_of L', atm_of L)]\n                                  Map.empty of\n                            None \\<Rightarrow> False\n                            | Some \\<sigma> \\<Rightarrow>\n                                \\<exists>\\<tau>.\n                                   dom \\<tau> =\n                                   vars_clause\n                                    (mset (remove1 L' D)) \\<union>\n                                   dom \\<sigma> \\<and>\n                                   extends_subst \\<sigma> \\<tau> \\<and>\n                                   subst_cls (mset (remove1 L' D))\n                                    (subst_of_map Var \\<tau>) \\<subseteq>#\n                                   mset C\n                       else False)", "apply (split if_splits option.splits)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D\\<rbrakk>\n    \\<Longrightarrow> (match_term_list [(atm_of L', atm_of L)] Map.empty =\n                       None \\<longrightarrow>\n                       (is_pos L' = is_neg L \\<longrightarrow>\n                        (\\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C) =\n                        False) \\<and>\n                       (is_pos L' \\<noteq> is_neg L \\<longrightarrow>\n                        (\\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C) =\n                        False)) \\<and>\n                      (\\<forall>x2.\n                          match_term_list [(atm_of L', atm_of L)]\n                           Map.empty =\n                          Some x2 \\<longrightarrow>\n                          (is_pos L' = is_neg L \\<longrightarrow>\n                           (\\<exists>\\<sigma>.\n                               - L = subst_lit L' \\<sigma> \\<and>\n                               subst_cls (mset (remove1 L' D))\n                                \\<sigma> \\<subseteq>#\n                               mset C) =\n                           (\\<exists>\\<tau>.\n                               dom \\<tau> =\n                               vars_clause (mset (remove1 L' D)) \\<union>\n                               dom x2 \\<and>\n                               extends_subst x2 \\<tau> \\<and>\n                               subst_cls (mset (remove1 L' D))\n                                (subst_of_map Var \\<tau>) \\<subseteq>#\n                               mset C)) \\<and>\n                          (is_pos L' \\<noteq> is_neg L \\<longrightarrow>\n                           (\\<exists>\\<sigma>.\n                               - L = subst_lit L' \\<sigma> \\<and>\n                               subst_cls (mset (remove1 L' D))\n                                \\<sigma> \\<subseteq>#\n                               mset C) =\n                           False))", "apply safe"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_pos L';\n        is_neg L; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_neg L';\n        is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_pos L';\n        is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_neg L;\n        is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_neg L; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 6. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_neg L;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 7. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 8. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 9. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>x2 \\<sigma>.\n        \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n         match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n         is_neg L; is_neg L'; - L = subst_lit L' \\<sigma>;\n         subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n         mset C\\<rbrakk>\n        \\<Longrightarrow> False", "subgoal for \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_pos L';\n     is_neg L; - L = subst_lit L' \\<sigma>;\n     subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> False", "using term_subst_eq[of _ \"subst_of_map Var (\\<lambda>x. if x \\<in> vars_lit L' then Some (\\<sigma> x) else None)\" \\<sigma>]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> vars_term ?t \\<Longrightarrow>\n      subst_of_map Var\n       (\\<lambda>x. if x \\<in> vars_lit L' then Some (\\<sigma> x) else None)\n       x =\n      \\<sigma> x) \\<Longrightarrow>\n  subst_atm_abbrev ?t\n   (subst_of_map Var\n     (\\<lambda>x.\n         if x \\<in> vars_lit L' then Some (\\<sigma> x) else None)) =\n  subst_atm_abbrev ?t \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_pos L';\n     is_neg L; - L = subst_lit L' \\<sigma>;\n     subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases L; cases L';\n        auto simp add: subst_lit_def subst_of_map_def\n          dest!:  match_term_list_complete[of _ _ \"\\<lambda>x. if x \\<in> vars_lit L' then Some (\\<sigma> x) else None\"])"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_neg L';\n        is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_pos L';\n        is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_neg L;\n        is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_neg L; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 5. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_neg L;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 6. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 7. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 8. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L; is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_neg L';\n     is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n     subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> False", "using term_subst_eq[of _ \"subst_of_map Var (\\<lambda>x. if x \\<in> vars_lit L' then Some (\\<sigma> x) else None)\" \\<sigma>]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> vars_term ?t \\<Longrightarrow>\n      subst_of_map Var\n       (\\<lambda>x. if x \\<in> vars_lit L' then Some (\\<sigma> x) else None)\n       x =\n      \\<sigma> x) \\<Longrightarrow>\n  subst_atm_abbrev ?t\n   (subst_of_map Var\n     (\\<lambda>x.\n         if x \\<in> vars_lit L' then Some (\\<sigma> x) else None)) =\n  subst_atm_abbrev ?t \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_neg L';\n     is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n     subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases L; cases L';\n        auto simp add: subst_lit_def subst_of_map_def\n          dest!:  match_term_list_complete[of _ _ \"\\<lambda>x. if x \\<in> vars_lit L' then Some (\\<sigma> x) else None\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_pos L';\n        is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_neg L;\n        is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_neg L; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 4. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_neg L;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 5. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 6. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 7. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L; is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_pos L';\n     is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n     subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases L; cases L'; simp add: subst_lit_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_neg L;\n        is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_neg L; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 3. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_neg L;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 4. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 5. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 6. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L; is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = None; is_neg L;\n     is_neg L'; - L = subst_lit L' \\<sigma>;\n     subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases L; cases L'; simp add: subst_lit_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_neg L; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 2. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_neg L;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 3. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 4. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 5. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L; is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for \\<sigma> \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = Some \\<sigma>;\n     is_pos L'; is_neg L; - L = subst_lit L' \\<tau>;\n     subst_cls (mset (remove1 L' D)) \\<tau> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<tau>.\n                         dom \\<tau> =\n                         vars_clause (mset (remove1 L' D)) \\<union>\n                         dom \\<sigma> \\<and>\n                         extends_subst \\<sigma> \\<tau> \\<and>\n                         subst_cls (mset (remove1 L' D))\n                          (subst_of_map Var \\<tau>) \\<subseteq>#\n                         mset C", "using same_on_vars_clause[of \"mset (remove1 L' D)\" \"subst_of_map Var\n        (\\<lambda>x. if x \\<in> vars_clause (remove1_mset L' (mset D)) \\<union> dom \\<sigma> then Some (\\<tau> x) else None)\" \\<tau>]"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_clause (mset (remove1 L' D)).\n     subst_of_map Var\n      (\\<lambda>x.\n          if x \\<in> vars_clause (remove1_mset L' (mset D)) \\<union>\n                     dom \\<sigma>\n          then Some (\\<tau> x) else None)\n      v =\n     \\<tau> v \\<Longrightarrow>\n  subst_cls (mset (remove1 L' D))\n   (subst_of_map Var\n     (\\<lambda>x.\n         if x \\<in> vars_clause (remove1_mset L' (mset D)) \\<union>\n                    dom \\<sigma>\n         then Some (\\<tau> x) else None)) =\n  subst_cls (mset (remove1 L' D)) \\<tau>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = Some \\<sigma>;\n     is_pos L'; is_neg L; - L = subst_lit L' \\<tau>;\n     subst_cls (mset (remove1 L' D)) \\<tau> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<tau>.\n                         dom \\<tau> =\n                         vars_clause (mset (remove1 L' D)) \\<union>\n                         dom \\<sigma> \\<and>\n                         extends_subst \\<sigma> \\<tau> \\<and>\n                         subst_cls (mset (remove1 L' D))\n                          (subst_of_map Var \\<tau>) \\<subseteq>#\n                         mset C", "apply (cases L; cases L'; auto simp add: subst_lit_def dom_def subst_of_map_def\n        dest!: match_term_list_sound split: option.splits if_splits\n        intro!: exI[of _ \"\\<lambda>x. if x \\<in> vars_clause (remove1_mset L' (mset D)) \\<union> dom \\<sigma> then Some (\\<tau> x) else None\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       \\<lbrakk>D \\<in> set Ds; Pos x1 \\<in> set D;\n        subst_cls (remove1_mset (Pos x1) (mset D)) \\<tau> \\<subseteq>#\n        mset C;\n        subst_cls (remove1_mset (Pos x1) (mset D))\n         (subst_of_map Var\n           (\\<lambda>x.\n               if x \\<in> vars_clause (remove1_mset (Pos x1) (mset D)) \\<or>\n                  (\\<exists>y. \\<sigma> x = Some y)\n               then Some (\\<tau> x) else None)) =\n        subst_cls (remove1_mset (Pos x1) (mset D)) \\<tau>;\n        L = Neg (subst_atm_abbrev x1 \\<tau>); L' = Pos x1;\n        {a. \\<exists>y. \\<sigma> a = Some y} = vars_term x1;\n        subst_atm_abbrev x1 (subst_of_map Var \\<sigma>) =\n        subst_atm_abbrev x1 \\<tau>\\<rbrakk>\n       \\<Longrightarrow> extends_subst \\<sigma>\n                          (\\<lambda>\\<tau>'.\n                              if \\<tau>'\n                                 \\<in> vars_clause\n  (remove1_mset (Pos x1) (mset D)) \\<or>\n                                 \\<tau>' \\<in> vars_term x1\n                              then Some (\\<tau> \\<tau>') else None)", "by (auto 0 4 simp: extends_subst_def subst_of_map_def split: option.splits dest!: term_subst_eq_rev)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_neg L;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 2. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 3. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 4. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L; is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for \\<sigma> \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = Some \\<sigma>;\n     is_pos L'; is_neg L;\n     dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom \\<sigma>;\n     extends_subst \\<sigma> \\<tau>;\n     subst_cls (mset (remove1 L' D)) (subst_of_map Var \\<tau>) \\<subseteq>#\n     mset C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>.\n                         - L = subst_lit L' \\<sigma> \\<and>\n                         subst_cls (mset (remove1 L' D))\n                          \\<sigma> \\<subseteq>#\n                         mset C", "by (cases L; cases L'; auto simp add: subst_lit_def subst_of_map_def extends_subst_def\n        dest!: match_term_list_sound intro!: exI[of _ \"subst_of_map Var \\<tau>\"] term_subst_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (remove1 L' D)) \\<union>\n                            dom x2 \\<and>\n                            extends_subst x2 \\<tau> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset C\n 2. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 3. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L; is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for \\<sigma> \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = Some \\<sigma>;\n     is_neg L'; is_pos L; \\<not> False; - L = subst_lit L' \\<tau>;\n     subst_cls (mset (remove1 L' D)) \\<tau> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<tau>.\n                         dom \\<tau> =\n                         vars_clause (mset (remove1 L' D)) \\<union>\n                         dom \\<sigma> \\<and>\n                         extends_subst \\<sigma> \\<tau> \\<and>\n                         subst_cls (mset (remove1 L' D))\n                          (subst_of_map Var \\<tau>) \\<subseteq>#\n                         mset C", "using same_on_vars_clause[of \"mset (remove1 L' D)\" \"subst_of_map Var\n        (\\<lambda>x. if x \\<in> vars_clause (remove1_mset L' (mset D)) \\<union> dom \\<sigma> then Some (\\<tau> x) else None)\" \\<tau>]"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>vars_clause (mset (remove1 L' D)).\n     subst_of_map Var\n      (\\<lambda>x.\n          if x \\<in> vars_clause (remove1_mset L' (mset D)) \\<union>\n                     dom \\<sigma>\n          then Some (\\<tau> x) else None)\n      v =\n     \\<tau> v \\<Longrightarrow>\n  subst_cls (mset (remove1 L' D))\n   (subst_of_map Var\n     (\\<lambda>x.\n         if x \\<in> vars_clause (remove1_mset L' (mset D)) \\<union>\n                    dom \\<sigma>\n         then Some (\\<tau> x) else None)) =\n  subst_cls (mset (remove1 L' D)) \\<tau>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = Some \\<sigma>;\n     is_neg L'; is_pos L; \\<not> False; - L = subst_lit L' \\<tau>;\n     subst_cls (mset (remove1 L' D)) \\<tau> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<tau>.\n                         dom \\<tau> =\n                         vars_clause (mset (remove1 L' D)) \\<union>\n                         dom \\<sigma> \\<and>\n                         extends_subst \\<sigma> \\<tau> \\<and>\n                         subst_cls (mset (remove1 L' D))\n                          (subst_of_map Var \\<tau>) \\<subseteq>#\n                         mset C", "apply (cases L; cases L'; auto simp add: subst_lit_def dom_def subst_of_map_def\n        dest!: match_term_list_sound split: option.splits if_splits\n        intro!: exI[of _ \"\\<lambda>x. if x \\<in> vars_clause (remove1_mset L' (mset D)) \\<union> dom \\<sigma> then Some (\\<tau> x) else None\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>D \\<in> set Ds; Neg x2 \\<in> set D;\n        subst_cls (remove1_mset (Neg x2) (mset D)) \\<tau> \\<subseteq>#\n        mset C;\n        subst_cls (remove1_mset (Neg x2) (mset D))\n         (subst_of_map Var\n           (\\<lambda>x.\n               if x \\<in> vars_clause (remove1_mset (Neg x2) (mset D)) \\<or>\n                  (\\<exists>y. \\<sigma> x = Some y)\n               then Some (\\<tau> x) else None)) =\n        subst_cls (remove1_mset (Neg x2) (mset D)) \\<tau>;\n        L = Pos (subst_atm_abbrev x2 \\<tau>); L' = Neg x2;\n        {a. \\<exists>y. \\<sigma> a = Some y} = vars_term x2;\n        subst_atm_abbrev x2 (subst_of_map Var \\<sigma>) =\n        subst_atm_abbrev x2 \\<tau>\\<rbrakk>\n       \\<Longrightarrow> extends_subst \\<sigma>\n                          (\\<lambda>\\<tau>'.\n                              if \\<tau>'\n                                 \\<in> vars_clause\n  (remove1_mset (Neg x2) (mset D)) \\<or>\n                                 \\<tau>' \\<in> vars_term x2\n                              then Some (\\<tau> \\<tau>') else None)", "by (auto 0 4 simp: extends_subst_def subst_of_map_def split: option.splits dest!: term_subst_eq_rev)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x2 \\<tau>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L'; is_pos L; \\<not> False;\n        dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom x2;\n        extends_subst x2 \\<tau>;\n        subst_cls (mset (remove1 L' D))\n         (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            - L = subst_lit L' \\<sigma> \\<and>\n                            subst_cls (mset (remove1 L' D))\n                             \\<sigma> \\<subseteq>#\n                            mset C\n 2. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L; is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for \\<sigma> \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = Some \\<sigma>;\n     is_neg L'; is_pos L; \\<not> False;\n     dom \\<tau> = vars_clause (mset (remove1 L' D)) \\<union> dom \\<sigma>;\n     extends_subst \\<sigma> \\<tau>;\n     subst_cls (mset (remove1 L' D)) (subst_of_map Var \\<tau>) \\<subseteq>#\n     mset C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>.\n                         - L = subst_lit L' \\<sigma> \\<and>\n                         subst_cls (mset (remove1 L' D))\n                          \\<sigma> \\<subseteq>#\n                         mset C", "by (cases L; cases L'; auto simp add: subst_lit_def subst_of_map_def extends_subst_def\n        dest!: match_term_list_sound intro!: exI[of _ \"subst_of_map Var \\<tau>\"] term_subst_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_pos L'; is_pos L; \\<not> False; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L; is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for \\<sigma> \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = Some \\<sigma>;\n     is_pos L'; is_pos L; \\<not> False; - L = subst_lit L' \\<tau>;\n     subst_cls (mset (remove1 L' D)) \\<tau> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases L; cases L'; simp add: subst_lit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 \\<sigma>.\n       \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n        match_term_list [(atm_of L', atm_of L)] Map.empty = Some x2;\n        is_neg L; is_neg L'; - L = subst_lit L' \\<sigma>;\n        subst_cls (mset (remove1 L' D)) \\<sigma> \\<subseteq>#\n        mset C\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for \\<sigma> \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>D \\<in> set Ds; L' \\<in> set D;\n     match_term_list [(atm_of L', atm_of L)] Map.empty = Some \\<sigma>;\n     is_neg L; is_neg L'; - L = subst_lit L' \\<tau>;\n     subst_cls (mset (remove1 L' D)) \\<tau> \\<subseteq># mset C\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases L; cases L'; simp add: subst_lit_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare\n  Pairs_def[folded sorted_list_of_set_def, code]\n  linorder.sorted_list_of_set_sort_remdups[OF class_linorder_compare,\n    folded sorted_list_of_set_def sort_key_def, code]\n  linorder.sort_key_def[OF class_linorder_compare, folded sort_key_def insort_key_def, code]\n  linorder.insort_key.simps[OF class_linorder_compare, folded insort_key_def, code]"], ["", "export_code St0 in SML"], ["", "export_code deterministic_RP in SML module_name RP"], ["", "(*arbitrary*)"], ["", "instantiation nat :: weighted begin"], ["", "definition weights_nat :: \"nat weights\" where \"weights_nat =\n  \\<lparr>w = Suc \\<circ> prod_encode, w0 = 1, pr_strict = \\<lambda>(f, n) (g, m). f > g \\<or> f = g \\<and> n > m, least = \\<lambda>n. n = 0, scf = \\<lambda>_ _. 1\\<rparr>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, weighted_class)", "by (intro_classes, unfold_locales)\n    (auto simp: weights_nat_def SN_iff_wf asymp.simps irreflp_def prod_encode_def\n      intro!: wf_subset[OF wf_lex_prod])"], ["", "end"], ["", "definition prover :: \"((nat, nat) Term.term literal list \\<times> nat) list \\<Rightarrow> bool\" where\n  \"prover N = (case deterministic_RP (St0 N 0) of\n      None \\<Rightarrow> True\n    | Some R \\<Rightarrow> [] \\<notin> set R)\""], ["", "theorem prover_complete_refutation: \"prover N \\<longleftrightarrow> satisfiable (RP.grounded_N0 N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prover N = satisfiable (RP.grounded_N0 N)", "unfolding prover_def St0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case deterministic_RP (RP.St0 N 0) of None \\<Rightarrow> True\n     | Some R \\<Rightarrow> [] \\<notin> set R) =\n    satisfiable (RP.grounded_N0 N)", "using RP.deterministic_RP_complete[of N 0] RP.deterministic_RP_refutation[of N 0]"], ["proof (prove)\nusing this:\n  deterministic_RP (RP.St0 N 0) = None \\<Longrightarrow>\n  satisfiable (RP.grounded_N0 N)\n  deterministic_RP (RP.St0 N 0) = Some ?R \\<Longrightarrow>\n  (\\<not> satisfiable (RP.grounded_N0 N)) = ({#} \\<in> RP.grounded_R ?R)\n\ngoal (1 subgoal):\n 1. (case deterministic_RP (RP.St0 N 0) of None \\<Rightarrow> True\n     | Some R \\<Rightarrow> [] \\<notin> set R) =\n    satisfiable (RP.grounded_N0 N)", "by (force simp: grounding_of_clss_def grounding_of_cls_def ex_ground_subst\n    split: option.splits if_splits)"], ["", "definition string_literal_of_nat :: \"nat \\<Rightarrow> String.literal\" where\n  \"string_literal_of_nat n = String.implode (show n)\""], ["", "export_code prover Fun Var Pos Neg string_literal_of_nat \"0::nat\" \"Suc\" in SML module_name RPx"], ["", "abbreviation \"\\<pp> \\<equiv> Fun 42\""], ["", "abbreviation \"\\<aa> \\<equiv> Fun 0 []\""], ["", "abbreviation \"\\<bb> \\<equiv> Fun 1 []\""], ["", "abbreviation \"\\<cc> \\<equiv> Fun 2 []\""], ["", "abbreviation \"X \\<equiv> Var 0\""], ["", "abbreviation \"Y \\<equiv> Var 1\""], ["", "abbreviation \"Z \\<equiv> Var 2\""], ["", "value \"prover\n  ([([Neg (\\<pp>[X,Y,Z]), Pos (\\<pp>[Y,Z,X])], 1),\n    ([Pos (\\<pp>[\\<cc>,\\<aa>,\\<bb>])], 1),\n    ([Neg (\\<pp>[\\<bb>,\\<cc>,\\<aa>])], 1)]\n  :: ((nat, nat) Term.term literal list \\<times> nat) list)\""], ["", "value \"prover\n  ([([Pos (\\<pp>[X,Y])], 1), ([Neg (\\<pp>[X,X])], 1)]\n  :: ((nat, nat) Term.term literal list \\<times> nat) list)\""], ["", "value \"prover ([([Neg (\\<pp>[X,Y,Z]), Pos (\\<pp>[Y,Z,X])], 1)]\n  :: ((nat, nat) Term.term literal list \\<times> nat) list)\""], ["", "definition mk_MSC015_1 :: \"nat \\<Rightarrow> ((nat, nat) Term.term literal list \\<times> nat) list\" where\n  \"mk_MSC015_1 n =\n     (let\n       init = ([Pos (\\<pp> (replicate n \\<aa>))], 1);\n       rules = map (\\<lambda>i. ([Neg (\\<pp> (map Var [0 ..< n - i - 1] @ \\<aa> # replicate i \\<bb>)),\n                         Pos (\\<pp> (map Var [0 ..< n - i - 1] @ \\<bb> # replicate i \\<aa>))], 1)) [0 ..< n];\n       goal = ([Neg (\\<pp> (replicate n \\<bb>))], 1)\n     in init # rules @ [goal])\""], ["", "value \"prover (mk_MSC015_1 1)\""], ["", "value \"prover (mk_MSC015_1 2)\""], ["", "value \"prover (mk_MSC015_1 3)\""], ["", "value \"prover (mk_MSC015_1 4)\""], ["", "value \"prover (mk_MSC015_1 5)\""], ["", "value \"prover (mk_MSC015_1 10)\""], ["", "lemma\n  assumes\n     \"p a a a a a a a a a a a a a a\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 a \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 b)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 a b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 b a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 a b b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 b a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 a b b b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 b a a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 a b b b b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 x9 b a a a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7 x8.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 a b b b b b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 x8 b a a a a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6 x7.\n       \\<not> p x1 x2 x3 x4 x5 x6 x7 a b b b b b b \\<or>\n       p x1 x2 x3 x4 x5 x6 x7 b a a a a a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5 x6.\n       \\<not> p x1 x2 x3 x4 x5 x6 a b b b b b b b \\<or>\n       p x1 x2 x3 x4 x5 x6 b a a a a a a a)\"\n     \"(\\<forall>x1 x2 x3 x4 x5.\n       \\<not> p x1 x2 x3 x4 x5 a b b b b b b b b \\<or>\n       p x1 x2 x3 x4 x5 b a a a a a a a a)\"\n     \"(\\<forall>x1 x2 x3 x4.\n       \\<not> p x1 x2 x3 x4 a b b b b b b b b b \\<or>\n       p x1 x2 x3 x4 b a a a a a a a a a)\"\n     \"(\\<forall>x1 x2 x3.\n       \\<not> p x1 x2 x3 a b b b b b b b b b b \\<or>\n       p x1 x2 x3 b a a a a a a a a a a)\"\n     \"(\\<forall>x1 x2.\n       \\<not> p x1 x2 a b b b b b b b b b b b \\<or>\n       p x1 x2 b a a a a a a a a a a a)\"\n     \"(\\<forall>x1.\n       \\<not> p x1 a b b b b b b b b b b b b \\<or>\n       p x1 b a a a a a a a a a a a a)\"\n     \"(\\<not> p a b b b b b b b b b b b b b \\<or>\n       p b a a a a a a a a a a a a a)\"\n     \"\\<not> p b b b b b b b b b b b b b b\"\n   shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  p a a a a a a a a a a a a a a\n  \\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13.\n     \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 a \\<or>\n     p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 b\n  \\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12.\n     \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 a b \\<or>\n     p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 b a\n  \\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11.\n     \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 a b b \\<or>\n     p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 b a a\n  \\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9 x10.\n     \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 a b b b \\<or>\n     p x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 b a a a\n  \\<forall>x1 x2 x3 x4 x5 x6 x7 x8 x9.\n     \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 x9 a b b b b \\<or>\n     p x1 x2 x3 x4 x5 x6 x7 x8 x9 b a a a a\n  \\<forall>x1 x2 x3 x4 x5 x6 x7 x8.\n     \\<not> p x1 x2 x3 x4 x5 x6 x7 x8 a b b b b b \\<or>\n     p x1 x2 x3 x4 x5 x6 x7 x8 b a a a a a\n  \\<forall>x1 x2 x3 x4 x5 x6 x7.\n     \\<not> p x1 x2 x3 x4 x5 x6 x7 a b b b b b b \\<or>\n     p x1 x2 x3 x4 x5 x6 x7 b a a a a a a\n  \\<forall>x1 x2 x3 x4 x5 x6.\n     \\<not> p x1 x2 x3 x4 x5 x6 a b b b b b b b \\<or>\n     p x1 x2 x3 x4 x5 x6 b a a a a a a a\n  \\<forall>x1 x2 x3 x4 x5.\n     \\<not> p x1 x2 x3 x4 x5 a b b b b b b b b \\<or>\n     p x1 x2 x3 x4 x5 b a a a a a a a a\n  \\<forall>x1 x2 x3 x4.\n     \\<not> p x1 x2 x3 x4 a b b b b b b b b b \\<or>\n     p x1 x2 x3 x4 b a a a a a a a a a\n  \\<forall>x1 x2 x3.\n     \\<not> p x1 x2 x3 a b b b b b b b b b b \\<or>\n     p x1 x2 x3 b a a a a a a a a a a\n  \\<forall>x1 x2.\n     \\<not> p x1 x2 a b b b b b b b b b b b \\<or>\n     p x1 x2 b a a a a a a a a a a a\n  \\<forall>x1.\n     \\<not> p x1 a b b b b b b b b b b b b \\<or>\n     p x1 b a a a a a a a a a a a a\n  \\<not> p a b b b b b b b b b b b b b \\<or> p b a a a a a a a a a a a a a\n  \\<not> p b b b b b b b b b b b b b b\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["", "end"]]}