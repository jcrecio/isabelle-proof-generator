{"file_name": "/home/qj213/afp-2021-10-22/thys/Functional_Ordered_Resolution_Prover/Executable_Subsumption.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Functional_Ordered_Resolution_Prover", "problem_names": ["lemma atm_of_map_literal[simp]: \"atm_of (map_literal f l) = f (atm_of l)\"", "lemma extends_subst_refl[simp]: \"extends_subst \\<sigma> \\<sigma>\"", "lemma extends_subst_trans: \"extends_subst \\<sigma> \\<tau> \\<Longrightarrow> extends_subst \\<tau> \\<rho> \\<Longrightarrow> extends_subst \\<sigma> \\<rho>\"", "lemma extends_subst_dom: \"extends_subst \\<sigma> \\<tau> \\<Longrightarrow> dom \\<sigma> \\<subseteq> dom \\<tau>\"", "lemma extends_subst_extends: \"extends_subst \\<sigma> \\<tau> \\<Longrightarrow> x \\<in> dom \\<sigma> \\<Longrightarrow> \\<tau> x = \\<sigma> x\"", "lemma extends_subst_fun_upd_new:\n  \"\\<sigma> x = None \\<Longrightarrow> extends_subst (\\<sigma>(x \\<mapsto> t)) \\<tau> \\<longleftrightarrow> extends_subst \\<sigma> \\<tau> \\<and> \\<tau> x = Some t\"", "lemma extends_subst_fun_upd_matching:\n  \"\\<sigma> x = Some t \\<Longrightarrow> extends_subst (\\<sigma>(x \\<mapsto> t)) \\<tau> \\<longleftrightarrow> extends_subst \\<sigma> \\<tau>\"", "lemma extends_subst_empty[simp]: \"extends_subst Map.empty \\<tau>\"", "lemma extends_subst_cong_term:\n  \"extends_subst \\<sigma> \\<tau> \\<Longrightarrow> vars_term t \\<subseteq> dom \\<sigma> \\<Longrightarrow> t \\<cdot> subst_of_map Var \\<sigma> = t \\<cdot> subst_of_map Var \\<tau>\"", "lemma extends_subst_cong_lit:\n  \"extends_subst \\<sigma> \\<tau> \\<Longrightarrow> vars_lit L \\<subseteq> dom \\<sigma> \\<Longrightarrow> L \\<cdot>lit subst_of_map Var \\<sigma> = L \\<cdot>lit subst_of_map Var \\<tau>\"", "lemma vars_clause_add_mset[simp]: \"vars_clause (add_mset L C) = vars_lit L \\<union> vars_clause C\"", "lemma subsumes_list_modulo_Cons: \"subsumes_list_modulo (L # Ls) Ks \\<sigma> \\<longleftrightarrow>\n  (\\<exists>K \\<in> set Ks. \\<exists>\\<tau>. extends_subst \\<sigma> \\<tau> \\<and> dom \\<tau> = vars_lit L \\<union> dom \\<sigma> \\<and> L \\<cdot>lit (subst_of_map Var \\<tau>) = K\n     \\<and> subsumes_list_modulo Ls (remove1 K Ks) \\<tau>)\"", "lemma decompose_Some_var_terms: \"decompose (Fun f ss) (Fun g ts) = Some eqs \\<Longrightarrow>\n   f = g \\<and> length ss = length ts \\<and> eqs = zip ss ts \\<and>\n   (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n   (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t)\"", "lemma match_term_list_sound: \"match_term_list tus \\<sigma> = Some \\<tau> \\<Longrightarrow>\n  extends_subst \\<sigma> \\<tau> \\<and> dom \\<tau> = (\\<Union>(t, u)\\<in>set tus. vars_term t) \\<union> dom \\<sigma> \\<and>\n  (\\<forall>(t,u)\\<in>set tus. t \\<cdot> subst_of_map Var \\<tau> = u)\"", "lemma match_term_list_complete: \"match_term_list tus \\<sigma> = None \\<Longrightarrow>\n   extends_subst \\<sigma> \\<tau> \\<Longrightarrow> dom \\<tau> = (\\<Union>(t, u)\\<in>set tus. vars_term t) \\<union> dom \\<sigma> \\<Longrightarrow>\n    (\\<exists>(t,u)\\<in>set tus. t \\<cdot> subst_of_map Var \\<tau> \\<noteq> u)\"", "lemma unique_extends_subst:\n  assumes extends: \"extends_subst \\<sigma> \\<tau>\" \"extends_subst \\<sigma> \\<rho>\" and\n    dom: \"dom \\<tau> = vars_term t \\<union> dom \\<sigma>\" \"dom \\<rho> = vars_term t \\<union> dom \\<sigma>\" and\n    eq: \"t \\<cdot> subst_of_map Var \\<rho> = t \\<cdot> subst_of_map Var \\<tau>\"\n  shows \"\\<rho> = \\<tau>\"", "lemma subsumes_list_alt:\n  \"subsumes_list Ls Ks \\<sigma> \\<longleftrightarrow> subsumes_list_modulo Ls Ks \\<sigma>\"", "lemma subsumes_subsumes_list[code_unfold]:\n  \"subsumes (mset Ls) (mset Ks) = subsumes_list Ls Ks Map.empty\"", "lemma strictly_subsumes_subsumes_list[code_unfold]:\n  \"strictly_subsumes (mset Ls) (mset Ks) =\n    (subsumes_list Ls Ks Map.empty \\<and> \\<not> subsumes_list Ks Ls Map.empty)\"", "lemma subsumes_list_filterD: \"subsumes_list Ls (filter P Ks) \\<sigma> \\<Longrightarrow> subsumes_list Ls Ks \\<sigma>\"", "lemma subsumes_list_filterI:\n  assumes match: \"(\\<And>L K \\<sigma> \\<tau>. L \\<in> set Ls \\<Longrightarrow>\n    match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau> \\<Longrightarrow> is_pos L = is_pos K \\<Longrightarrow> P K)\"\n  shows \"subsumes_list Ls Ks \\<sigma> \\<Longrightarrow> subsumes_list Ls (filter P Ks) \\<sigma>\"", "lemma subsumes_list_Cons_filter_iff:\n  assumes sorted_wrt: \"sorted_wrt leq (L # Ls)\" and trans: \"transp leq\"\n  and match: \"(\\<And>L K \\<sigma> \\<tau>.\n    match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau> \\<Longrightarrow> is_pos L = is_pos K \\<Longrightarrow> leq L K)\"\nshows \"subsumes_list (L # Ls) (filter (leq L) Ks) \\<sigma> \\<longleftrightarrow> subsumes_list (L # Ls) Ks \\<sigma>\"", "lemma transp_leq_lit[simp]: \"transp leq_lit\"", "lemma reflp_leq_lit[simp]: \"reflp_on leq_lit A\"", "lemma total_leq_lit[simp]: \"total_on leq_lit A\"", "lemma leq_head_subst[simp]: \"leq_head t (t \\<cdot> \\<sigma>)\"", "lemma leq_lit_match:\n  fixes L K :: \"('f :: linorder, 'v) term literal\"\n  shows \"match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau> \\<Longrightarrow> is_pos L = is_pos K \\<Longrightarrow> leq_lit L K\"", "lemma sorted_wrt_subsumes_list_subsumes_list_filter:\n  \"sorted_wrt leq_lit Ls \\<Longrightarrow> subsumes_list Ls Ks \\<sigma> = subsumes_list_filter Ls Ks \\<sigma>\"", "theorem mset_quicksort [simp]: \"mset (quicksort R xs) = mset xs\"", "theorem sorted_wrt_quicksort:\n  assumes \"transp R\" and \"total_on R (set xs)\" and \"reflp_on R (set xs)\"\n  shows   \"sorted_wrt R (quicksort R xs)\"", "lemma subsumes_list_subsumes_list_filter[abs_def, code_unfold]:\n  \"subsumes_list Ls Ks \\<sigma> = subsumes_list_filter (quicksort leq_lit Ls) Ks \\<sigma>\""], "translations": [["", "lemma atm_of_map_literal[simp]: \"atm_of (map_literal f l) = f (atm_of l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atm_of (map_literal f l) = f (atm_of l)", "by (cases l; simp)"], ["", "definition \"extends_subst \\<sigma> \\<tau> = (\\<forall>x \\<in> dom \\<sigma>. \\<sigma> x = \\<tau> x)\""], ["", "lemma extends_subst_refl[simp]: \"extends_subst \\<sigma> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extends_subst \\<sigma> \\<sigma>", "unfolding extends_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>dom \\<sigma>. \\<sigma> x = \\<sigma> x", "by auto"], ["", "lemma extends_subst_trans: \"extends_subst \\<sigma> \\<tau> \\<Longrightarrow> extends_subst \\<tau> \\<rho> \\<Longrightarrow> extends_subst \\<sigma> \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extends_subst \\<sigma> \\<tau>;\n     extends_subst \\<tau> \\<rho>\\<rbrakk>\n    \\<Longrightarrow> extends_subst \\<sigma> \\<rho>", "unfolding extends_subst_def dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>{a. \\<sigma> a \\<noteq> None}.\n                \\<sigma> x = \\<tau> x;\n     \\<forall>x\\<in>{a. \\<tau> a \\<noteq> None}.\n        \\<tau> x = \\<rho> x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>{a. \\<sigma> a \\<noteq> None}.\n                         \\<sigma> x = \\<rho> x", "by (metis mem_Collect_eq)"], ["", "lemma extends_subst_dom: \"extends_subst \\<sigma> \\<tau> \\<Longrightarrow> dom \\<sigma> \\<subseteq> dom \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extends_subst \\<sigma> \\<tau> \\<Longrightarrow>\n    dom \\<sigma> \\<subseteq> dom \\<tau>", "unfolding extends_subst_def dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{a. \\<sigma> a \\<noteq> None}.\n       \\<sigma> x = \\<tau> x \\<Longrightarrow>\n    {a. \\<sigma> a \\<noteq> None} \\<subseteq> {a. \\<tau> a \\<noteq> None}", "by auto"], ["", "lemma extends_subst_extends: \"extends_subst \\<sigma> \\<tau> \\<Longrightarrow> x \\<in> dom \\<sigma> \\<Longrightarrow> \\<tau> x = \\<sigma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extends_subst \\<sigma> \\<tau>; x \\<in> dom \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> x = \\<sigma> x", "unfolding extends_subst_def dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>{a. \\<sigma> a \\<noteq> None}.\n                \\<sigma> x = \\<tau> x;\n     x \\<in> {a. \\<sigma> a \\<noteq> None}\\<rbrakk>\n    \\<Longrightarrow> \\<tau> x = \\<sigma> x", "by auto"], ["", "lemma extends_subst_fun_upd_new:\n  \"\\<sigma> x = None \\<Longrightarrow> extends_subst (\\<sigma>(x \\<mapsto> t)) \\<tau> \\<longleftrightarrow> extends_subst \\<sigma> \\<tau> \\<and> \\<tau> x = Some t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> x = None \\<Longrightarrow>\n    extends_subst (\\<sigma>(x \\<mapsto> t)) \\<tau> =\n    (extends_subst \\<sigma> \\<tau> \\<and> \\<tau> x = Some t)", "unfolding extends_subst_def dom_fun_upd subst_of_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> x = None \\<Longrightarrow>\n    (\\<forall>xa\\<in>if Some t = None then dom \\<sigma> - {x}\n                     else insert x (dom \\<sigma>).\n        (\\<sigma>(x \\<mapsto> t)) xa = \\<tau> xa) =\n    ((\\<forall>x\\<in>dom \\<sigma>. \\<sigma> x = \\<tau> x) \\<and>\n     \\<tau> x = Some t)", "by (force simp add: dom_def split: option.splits)"], ["", "lemma extends_subst_fun_upd_matching:\n  \"\\<sigma> x = Some t \\<Longrightarrow> extends_subst (\\<sigma>(x \\<mapsto> t)) \\<tau> \\<longleftrightarrow> extends_subst \\<sigma> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> x = Some t \\<Longrightarrow>\n    extends_subst (\\<sigma>(x \\<mapsto> t)) \\<tau> =\n    extends_subst \\<sigma> \\<tau>", "unfolding extends_subst_def dom_fun_upd subst_of_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> x = Some t \\<Longrightarrow>\n    (\\<forall>xa\\<in>if Some t = None then dom \\<sigma> - {x}\n                     else insert x (dom \\<sigma>).\n        (\\<sigma>(x \\<mapsto> t)) xa = \\<tau> xa) =\n    (\\<forall>x\\<in>dom \\<sigma>. \\<sigma> x = \\<tau> x)", "by (auto simp add: dom_def split: option.splits)"], ["", "lemma extends_subst_empty[simp]: \"extends_subst Map.empty \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extends_subst Map.empty \\<tau>", "unfolding extends_subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>dom Map.empty. None = \\<tau> x", "by auto"], ["", "lemma extends_subst_cong_term:\n  \"extends_subst \\<sigma> \\<tau> \\<Longrightarrow> vars_term t \\<subseteq> dom \\<sigma> \\<Longrightarrow> t \\<cdot> subst_of_map Var \\<sigma> = t \\<cdot> subst_of_map Var \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extends_subst \\<sigma> \\<tau>;\n     vars_term t \\<subseteq> dom \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> subst_atm_abbrev t (subst_of_map Var \\<sigma>) =\n                      subst_atm_abbrev t (subst_of_map Var \\<tau>)", "by (force simp: extends_subst_def subst_of_map_def split: option.splits intro!: term_subst_eq)"], ["", "lemma extends_subst_cong_lit:\n  \"extends_subst \\<sigma> \\<tau> \\<Longrightarrow> vars_lit L \\<subseteq> dom \\<sigma> \\<Longrightarrow> L \\<cdot>lit subst_of_map Var \\<sigma> = L \\<cdot>lit subst_of_map Var \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extends_subst \\<sigma> \\<tau>;\n     vars_lit L \\<subseteq> dom \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> L \\<cdot>lit subst_of_map Var \\<sigma> =\n                      L \\<cdot>lit subst_of_map Var \\<tau>", "by (cases L) (auto simp: extends_subst_cong_term)"], ["", "definition \"subsumes_modulo C D \\<sigma> =\n   (\\<exists>\\<tau>. dom \\<tau> = vars_clause C \\<union> dom \\<sigma> \\<and> extends_subst \\<sigma> \\<tau> \\<and> subst_cls C (subst_of_map Var \\<tau>) \\<subseteq># D)\""], ["", "abbreviation subsumes_list_modulo where\n  \"subsumes_list_modulo Ls Ks \\<sigma> \\<equiv> subsumes_modulo (mset Ls) (mset Ks) \\<sigma>\""], ["", "lemma vars_clause_add_mset[simp]: \"vars_clause (add_mset L C) = vars_lit L \\<union> vars_clause C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_clause (add_mset L C) = vars_lit L \\<union> vars_clause C", "unfolding vars_clause_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set_mset (image_mset vars_lit (add_mset L C))) =\n    vars_lit L \\<union> \\<Union> (set_mset (image_mset vars_lit C))", "by auto"], ["", "lemma subsumes_list_modulo_Cons: \"subsumes_list_modulo (L # Ls) Ks \\<sigma> \\<longleftrightarrow>\n  (\\<exists>K \\<in> set Ks. \\<exists>\\<tau>. extends_subst \\<sigma> \\<tau> \\<and> dom \\<tau> = vars_lit L \\<union> dom \\<sigma> \\<and> L \\<cdot>lit (subst_of_map Var \\<tau>) = K\n     \\<and> subsumes_list_modulo Ls (remove1 K Ks) \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes_list_modulo (L # Ls) Ks \\<sigma> =\n    (\\<exists>K\\<in>set Ks.\n        \\<exists>\\<tau>.\n           extends_subst \\<sigma> \\<tau> \\<and>\n           dom \\<tau> = vars_lit L \\<union> dom \\<sigma> \\<and>\n           L \\<cdot>lit subst_of_map Var \\<tau> = K \\<and>\n           subsumes_list_modulo Ls (remove1 K Ks) \\<tau>)", "unfolding subsumes_modulo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<tau>.\n        dom \\<tau> =\n        vars_clause (mset (L # Ls)) \\<union> dom \\<sigma> \\<and>\n        extends_subst \\<sigma> \\<tau> \\<and>\n        subst_cls (mset (L # Ls)) (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset Ks) =\n    (\\<exists>K\\<in>set Ks.\n        \\<exists>\\<tau>.\n           extends_subst \\<sigma> \\<tau> \\<and>\n           dom \\<tau> = vars_lit L \\<union> dom \\<sigma> \\<and>\n           L \\<cdot>lit subst_of_map Var \\<tau> = K \\<and>\n           (\\<exists>\\<tau>'.\n               dom \\<tau>' =\n               vars_clause (mset Ls) \\<union> dom \\<tau> \\<and>\n               extends_subst \\<tau> \\<tau>' \\<and>\n               subst_cls (mset Ls) (subst_of_map Var \\<tau>') \\<subseteq>#\n               mset (remove1 K Ks)))", "proof (safe, goal_cases left_right right_left)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>dom \\<tau> =\n                vars_clause (mset (L # Ls)) \\<union> dom \\<sigma>;\n        extends_subst \\<sigma> \\<tau>;\n        subst_cls (mset (L # Ls)) (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset Ks\\<rbrakk>\n       \\<Longrightarrow> \\<exists>K\\<in>set Ks.\n                            \\<exists>\\<tau>.\n                               extends_subst \\<sigma> \\<tau> \\<and>\n                               dom \\<tau> =\n                               vars_lit L \\<union> dom \\<sigma> \\<and>\n                               L \\<cdot>lit subst_of_map Var \\<tau> =\n                               K \\<and>\n                               (\\<exists>\\<tau>'.\n                                   dom \\<tau>' =\n                                   vars_clause (mset Ls) \\<union>\n                                   dom \\<tau> \\<and>\n                                   extends_subst \\<tau> \\<tau>' \\<and>\n                                   subst_cls (mset Ls)\n                                    (subst_of_map Var \\<tau>') \\<subseteq>#\n                                   mset (remove1 K Ks))\n 2. \\<And>K \\<tau> \\<tau>'.\n       \\<lbrakk>L \\<cdot>lit subst_of_map Var \\<tau> \\<in> set Ks;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        dom \\<tau>' = vars_clause (mset Ls) \\<union> dom \\<tau>;\n        extends_subst \\<tau> \\<tau>';\n        subst_cls (mset Ls) (subst_of_map Var \\<tau>') \\<subseteq>#\n        mset (remove1 (L \\<cdot>lit subst_of_map Var \\<tau>) Ks)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (L # Ls)) \\<union>\n                            dom \\<sigma> \\<and>\n                            extends_subst \\<sigma> \\<tau> \\<and>\n                            subst_cls (mset (L # Ls))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset Ks", "case (left_right \\<tau>)"], ["proof (state)\nthis:\n  dom \\<tau> = vars_clause (mset (L # Ls)) \\<union> dom \\<sigma>\n  extends_subst \\<sigma> \\<tau>\n  subst_cls (mset (L # Ls)) (subst_of_map Var \\<tau>) \\<subseteq># mset Ks\n\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>dom \\<tau> =\n                vars_clause (mset (L # Ls)) \\<union> dom \\<sigma>;\n        extends_subst \\<sigma> \\<tau>;\n        subst_cls (mset (L # Ls)) (subst_of_map Var \\<tau>) \\<subseteq>#\n        mset Ks\\<rbrakk>\n       \\<Longrightarrow> \\<exists>K\\<in>set Ks.\n                            \\<exists>\\<tau>.\n                               extends_subst \\<sigma> \\<tau> \\<and>\n                               dom \\<tau> =\n                               vars_lit L \\<union> dom \\<sigma> \\<and>\n                               L \\<cdot>lit subst_of_map Var \\<tau> =\n                               K \\<and>\n                               (\\<exists>\\<tau>'.\n                                   dom \\<tau>' =\n                                   vars_clause (mset Ls) \\<union>\n                                   dom \\<tau> \\<and>\n                                   extends_subst \\<tau> \\<tau>' \\<and>\n                                   subst_cls (mset Ls)\n                                    (subst_of_map Var \\<tau>') \\<subseteq>#\n                                   mset (remove1 K Ks))\n 2. \\<And>K \\<tau> \\<tau>'.\n       \\<lbrakk>L \\<cdot>lit subst_of_map Var \\<tau> \\<in> set Ks;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        dom \\<tau>' = vars_clause (mset Ls) \\<union> dom \\<tau>;\n        extends_subst \\<tau> \\<tau>';\n        subst_cls (mset Ls) (subst_of_map Var \\<tau>') \\<subseteq>#\n        mset (remove1 (L \\<cdot>lit subst_of_map Var \\<tau>) Ks)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (L # Ls)) \\<union>\n                            dom \\<sigma> \\<and>\n                            extends_subst \\<sigma> \\<tau> \\<and>\n                            subst_cls (mset (L # Ls))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset Ks", "then"], ["proof (chain)\npicking this:\n  dom \\<tau> = vars_clause (mset (L # Ls)) \\<union> dom \\<sigma>\n  extends_subst \\<sigma> \\<tau>\n  subst_cls (mset (L # Ls)) (subst_of_map Var \\<tau>) \\<subseteq># mset Ks", "show ?case"], ["proof (prove)\nusing this:\n  dom \\<tau> = vars_clause (mset (L # Ls)) \\<union> dom \\<sigma>\n  extends_subst \\<sigma> \\<tau>\n  subst_cls (mset (L # Ls)) (subst_of_map Var \\<tau>) \\<subseteq># mset Ks\n\ngoal (1 subgoal):\n 1. \\<exists>K\\<in>set Ks.\n       \\<exists>\\<tau>.\n          extends_subst \\<sigma> \\<tau> \\<and>\n          dom \\<tau> = vars_lit L \\<union> dom \\<sigma> \\<and>\n          L \\<cdot>lit subst_of_map Var \\<tau> = K \\<and>\n          (\\<exists>\\<tau>'.\n              dom \\<tau>' = vars_clause (mset Ls) \\<union> dom \\<tau> \\<and>\n              extends_subst \\<tau> \\<tau>' \\<and>\n              subst_cls (mset Ls) (subst_of_map Var \\<tau>') \\<subseteq>#\n              mset (remove1 K Ks))", "by (intro bexI[of _ \"L \\<cdot>lit subst_of_map Var \\<tau>\"]\n      exI[of _ \"\\<lambda>x. if x \\<in> vars_lit L \\<union> dom \\<sigma> then \\<tau> x else None\"], intro conjI exI[of _ \\<tau>])\n      (auto 0 3 simp: extends_subst_def dom_def split: if_splits\n      simp: insert_subset_eq_iff subst_lit_def  intro!: extends_subst_cong_lit)"], ["proof (state)\nthis:\n  \\<exists>K\\<in>set Ks.\n     \\<exists>\\<tau>.\n        extends_subst \\<sigma> \\<tau> \\<and>\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma> \\<and>\n        L \\<cdot>lit subst_of_map Var \\<tau> = K \\<and>\n        (\\<exists>\\<tau>'.\n            dom \\<tau>' = vars_clause (mset Ls) \\<union> dom \\<tau> \\<and>\n            extends_subst \\<tau> \\<tau>' \\<and>\n            subst_cls (mset Ls) (subst_of_map Var \\<tau>') \\<subseteq>#\n            mset (remove1 K Ks))\n\ngoal (1 subgoal):\n 1. \\<And>K \\<tau> \\<tau>'.\n       \\<lbrakk>L \\<cdot>lit subst_of_map Var \\<tau> \\<in> set Ks;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        dom \\<tau>' = vars_clause (mset Ls) \\<union> dom \\<tau>;\n        extends_subst \\<tau> \\<tau>';\n        subst_cls (mset Ls) (subst_of_map Var \\<tau>') \\<subseteq>#\n        mset (remove1 (L \\<cdot>lit subst_of_map Var \\<tau>) Ks)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (L # Ls)) \\<union>\n                            dom \\<sigma> \\<and>\n                            extends_subst \\<sigma> \\<tau> \\<and>\n                            subst_cls (mset (L # Ls))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset Ks", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K \\<tau> \\<tau>'.\n       \\<lbrakk>L \\<cdot>lit subst_of_map Var \\<tau> \\<in> set Ks;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        dom \\<tau>' = vars_clause (mset Ls) \\<union> dom \\<tau>;\n        extends_subst \\<tau> \\<tau>';\n        subst_cls (mset Ls) (subst_of_map Var \\<tau>') \\<subseteq>#\n        mset (remove1 (L \\<cdot>lit subst_of_map Var \\<tau>) Ks)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (L # Ls)) \\<union>\n                            dom \\<sigma> \\<and>\n                            extends_subst \\<sigma> \\<tau> \\<and>\n                            subst_cls (mset (L # Ls))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset Ks", "case (right_left K \\<tau> \\<tau>')"], ["proof (state)\nthis:\n  L \\<cdot>lit subst_of_map Var \\<tau> \\<in> set Ks\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> = vars_lit L \\<union> dom \\<sigma>\n  dom \\<tau>' = vars_clause (mset Ls) \\<union> dom \\<tau>\n  extends_subst \\<tau> \\<tau>'\n  subst_cls (mset Ls) (subst_of_map Var \\<tau>') \\<subseteq>#\n  mset (remove1 (L \\<cdot>lit subst_of_map Var \\<tau>) Ks)\n\ngoal (1 subgoal):\n 1. \\<And>K \\<tau> \\<tau>'.\n       \\<lbrakk>L \\<cdot>lit subst_of_map Var \\<tau> \\<in> set Ks;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        dom \\<tau>' = vars_clause (mset Ls) \\<union> dom \\<tau>;\n        extends_subst \\<tau> \\<tau>';\n        subst_cls (mset Ls) (subst_of_map Var \\<tau>') \\<subseteq>#\n        mset (remove1 (L \\<cdot>lit subst_of_map Var \\<tau>) Ks)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            dom \\<tau> =\n                            vars_clause (mset (L # Ls)) \\<union>\n                            dom \\<sigma> \\<and>\n                            extends_subst \\<sigma> \\<tau> \\<and>\n                            subst_cls (mset (L # Ls))\n                             (subst_of_map Var \\<tau>) \\<subseteq>#\n                            mset Ks", "then"], ["proof (chain)\npicking this:\n  L \\<cdot>lit subst_of_map Var \\<tau> \\<in> set Ks\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> = vars_lit L \\<union> dom \\<sigma>\n  dom \\<tau>' = vars_clause (mset Ls) \\<union> dom \\<tau>\n  extends_subst \\<tau> \\<tau>'\n  subst_cls (mset Ls) (subst_of_map Var \\<tau>') \\<subseteq>#\n  mset (remove1 (L \\<cdot>lit subst_of_map Var \\<tau>) Ks)", "show ?case"], ["proof (prove)\nusing this:\n  L \\<cdot>lit subst_of_map Var \\<tau> \\<in> set Ks\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> = vars_lit L \\<union> dom \\<sigma>\n  dom \\<tau>' = vars_clause (mset Ls) \\<union> dom \\<tau>\n  extends_subst \\<tau> \\<tau>'\n  subst_cls (mset Ls) (subst_of_map Var \\<tau>') \\<subseteq>#\n  mset (remove1 (L \\<cdot>lit subst_of_map Var \\<tau>) Ks)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>.\n       dom \\<tau> = vars_clause (mset (L # Ls)) \\<union> dom \\<sigma> \\<and>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       subst_cls (mset (L # Ls)) (subst_of_map Var \\<tau>) \\<subseteq>#\n       mset Ks", "by (intro bexI[of _ \"L \\<cdot>lit subst_of_map Var \\<tau>\"] exI[of _ \\<tau>'], intro conjI exI[of _ \\<tau>])\n     (auto simp: insert_subset_eq_iff subst_lit_def extends_subst_cong_lit\n       intro: extends_subst_trans)"], ["proof (state)\nthis:\n  \\<exists>\\<tau>.\n     dom \\<tau> = vars_clause (mset (L # Ls)) \\<union> dom \\<sigma> \\<and>\n     extends_subst \\<sigma> \\<tau> \\<and>\n     subst_cls (mset (L # Ls)) (subst_of_map Var \\<tau>) \\<subseteq>#\n     mset Ks\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decompose_Some_var_terms: \"decompose (Fun f ss) (Fun g ts) = Some eqs \\<Longrightarrow>\n   f = g \\<and> length ss = length ts \\<and> eqs = zip ss ts \\<and>\n   (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n   (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose (Fun f ss) (Fun g ts) = Some eqs \\<Longrightarrow>\n    f = g \\<and>\n    length ss = length ts \\<and>\n    eqs = zip ss ts \\<and>\n    (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n    (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t)", "by (drule decompose_Some)\n    (fastforce simp: in_set_zip in_set_conv_nth Bex_def image_iff)"], ["", "lemma match_term_list_sound: \"match_term_list tus \\<sigma> = Some \\<tau> \\<Longrightarrow>\n  extends_subst \\<sigma> \\<tau> \\<and> dom \\<tau> = (\\<Union>(t, u)\\<in>set tus. vars_term t) \\<union> dom \\<sigma> \\<and>\n  (\\<forall>(t,u)\\<in>set tus. t \\<cdot> subst_of_map Var \\<tau> = u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_term_list tus \\<sigma> = Some \\<tau> \\<Longrightarrow>\n    extends_subst \\<sigma> \\<tau> \\<and>\n    dom \\<tau> =\n    (\\<Union>(t, u)\\<in>set tus. vars_term t) \\<union> dom \\<sigma> \\<and>\n    (\\<forall>(t, u)\\<in>set tus.\n        subst_atm_abbrev t (subst_of_map Var \\<tau>) = u)", "proof (induct tus \\<sigma> rule: match_term_list.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>.\n       match_term_list [] \\<sigma> = Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union> dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set [].\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)\n 2. \\<And>x t P \\<sigma>.\n       \\<lbrakk>\\<lbrakk>\\<sigma> x = None \\<or> \\<sigma> x = Some t;\n                 match_term_list P (\\<sigma>(x \\<mapsto> t)) =\n                 Some \\<tau>\\<rbrakk>\n                \\<Longrightarrow> extends_subst (\\<sigma>(x \\<mapsto> t))\n                                   \\<tau> \\<and>\n                                  dom \\<tau> =\n                                  (\\<Union>(t, u)\\<in>set P.\nvars_term t) \\<union>\n                                  dom (\\<sigma>(x \\<mapsto> t)) \\<and>\n                                  (\\<forall>(t, y)\\<in>set P.\nsubst_atm_abbrev t (subst_of_map Var \\<tau>) = y);\n        match_term_list ((Var x, t) # P) \\<sigma> = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                         dom \\<tau> =\n                         (\\<Union>(t, u)\\<in>set ((Var x, t) # P).\n                             vars_term t) \\<union>\n                         dom \\<sigma> \\<and>\n                         (\\<forall>(t, y)\\<in>set ((Var x, t) # P).\n                             subst_atm_abbrev t (subst_of_map Var \\<tau>) =\n                             y)\n 3. \\<And>f ss g ts P \\<sigma>.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    match_term_list (x2 @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                                     dom \\<tau> =\n                                     (\\<Union>(t, u)\\<in>set (x2 @ P).\n   vars_term t) \\<union>\n                                     dom \\<sigma> \\<and>\n                                     (\\<forall>(t, y)\\<in>set (x2 @ P).\n   subst_atm_abbrev t (subst_of_map Var \\<tau>) = y);\n        match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> =\n        Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                         dom \\<tau> =\n                         (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n                             vars_term t) \\<union>\n                         dom \\<sigma> \\<and>\n                         (\\<forall>(t, y)\n                                   \\<in>set ((Fun f ss, Fun g ts) # P).\n                             subst_atm_abbrev t (subst_of_map Var \\<tau>) =\n                             y)\n 4. \\<And>f ss x P \\<sigma>.\n       match_term_list ((Fun f ss, Var x) # P) \\<sigma> =\n       Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n           vars_term t) \\<union>\n       dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set ((Fun f ss, Var x) # P).\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)", "case (2 x t P \\<sigma>)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<sigma> x = None \\<or> \\<sigma> x = Some t;\n   match_term_list P (\\<sigma>(x \\<mapsto> t)) = Some \\<tau>\\<rbrakk>\n  \\<Longrightarrow> extends_subst (\\<sigma>(x \\<mapsto> t)) \\<tau> \\<and>\n                    dom \\<tau> =\n                    (\\<Union>a\\<in>set P.\n                        case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n                    dom (\\<sigma>(x \\<mapsto> t)) \\<and>\n                    (\\<forall>a\\<in>set P.\n                        case a of\n                        (t, a) \\<Rightarrow>\n                          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a)\n  match_term_list ((Var x, t) # P) \\<sigma> = Some \\<tau>\n\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>.\n       match_term_list [] \\<sigma> = Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union> dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set [].\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)\n 2. \\<And>x t P \\<sigma>.\n       \\<lbrakk>\\<lbrakk>\\<sigma> x = None \\<or> \\<sigma> x = Some t;\n                 match_term_list P (\\<sigma>(x \\<mapsto> t)) =\n                 Some \\<tau>\\<rbrakk>\n                \\<Longrightarrow> extends_subst (\\<sigma>(x \\<mapsto> t))\n                                   \\<tau> \\<and>\n                                  dom \\<tau> =\n                                  (\\<Union>(t, u)\\<in>set P.\nvars_term t) \\<union>\n                                  dom (\\<sigma>(x \\<mapsto> t)) \\<and>\n                                  (\\<forall>(t, y)\\<in>set P.\nsubst_atm_abbrev t (subst_of_map Var \\<tau>) = y);\n        match_term_list ((Var x, t) # P) \\<sigma> = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                         dom \\<tau> =\n                         (\\<Union>(t, u)\\<in>set ((Var x, t) # P).\n                             vars_term t) \\<union>\n                         dom \\<sigma> \\<and>\n                         (\\<forall>(t, y)\\<in>set ((Var x, t) # P).\n                             subst_atm_abbrev t (subst_of_map Var \\<tau>) =\n                             y)\n 3. \\<And>f ss g ts P \\<sigma>.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    match_term_list (x2 @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                                     dom \\<tau> =\n                                     (\\<Union>(t, u)\\<in>set (x2 @ P).\n   vars_term t) \\<union>\n                                     dom \\<sigma> \\<and>\n                                     (\\<forall>(t, y)\\<in>set (x2 @ P).\n   subst_atm_abbrev t (subst_of_map Var \\<tau>) = y);\n        match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> =\n        Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                         dom \\<tau> =\n                         (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n                             vars_term t) \\<union>\n                         dom \\<sigma> \\<and>\n                         (\\<forall>(t, y)\n                                   \\<in>set ((Fun f ss, Fun g ts) # P).\n                             subst_atm_abbrev t (subst_of_map Var \\<tau>) =\n                             y)\n 4. \\<And>f ss x P \\<sigma>.\n       match_term_list ((Fun f ss, Var x) # P) \\<sigma> =\n       Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n           vars_term t) \\<union>\n       dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set ((Fun f ss, Var x) # P).\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<sigma> x = None \\<or> \\<sigma> x = Some t;\n   match_term_list P (\\<sigma>(x \\<mapsto> t)) = Some \\<tau>\\<rbrakk>\n  \\<Longrightarrow> extends_subst (\\<sigma>(x \\<mapsto> t)) \\<tau> \\<and>\n                    dom \\<tau> =\n                    (\\<Union>a\\<in>set P.\n                        case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n                    dom (\\<sigma>(x \\<mapsto> t)) \\<and>\n                    (\\<forall>a\\<in>set P.\n                        case a of\n                        (t, a) \\<Rightarrow>\n                          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a)\n  match_term_list ((Var x, t) # P) \\<sigma> = Some \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<sigma> x = None \\<or> \\<sigma> x = Some t;\n   match_term_list P (\\<sigma>(x \\<mapsto> t)) = Some \\<tau>\\<rbrakk>\n  \\<Longrightarrow> extends_subst (\\<sigma>(x \\<mapsto> t)) \\<tau> \\<and>\n                    dom \\<tau> =\n                    (\\<Union>a\\<in>set P.\n                        case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n                    dom (\\<sigma>(x \\<mapsto> t)) \\<and>\n                    (\\<forall>a\\<in>set P.\n                        case a of\n                        (t, a) \\<Rightarrow>\n                          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a)\n  match_term_list ((Var x, t) # P) \\<sigma> = Some \\<tau>\n\ngoal (1 subgoal):\n 1. extends_subst \\<sigma> \\<tau> \\<and>\n    dom \\<tau> =\n    (\\<Union>a\\<in>set ((Var x, t) # P).\n        case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n    dom \\<sigma> \\<and>\n    (\\<forall>a\\<in>set ((Var x, t) # P).\n        case a of\n        (t, a) \\<Rightarrow>\n          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a)", "by (auto 0 3 simp: extends_subst_fun_upd_new extends_subst_fun_upd_matching\n      subst_of_map_def dest: extends_subst_extends simp del: fun_upd_apply\n      split: if_splits option.splits)"], ["proof (state)\nthis:\n  extends_subst \\<sigma> \\<tau> \\<and>\n  dom \\<tau> =\n  (\\<Union>a\\<in>set ((Var x, t) # P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n  dom \\<sigma> \\<and>\n  (\\<forall>a\\<in>set ((Var x, t) # P).\n      case a of\n      (t, a) \\<Rightarrow> subst_atm_abbrev t (subst_of_map Var \\<tau>) = a)\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>.\n       match_term_list [] \\<sigma> = Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union> dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set [].\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)\n 2. \\<And>f ss g ts P \\<sigma>.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    match_term_list (x2 @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                                     dom \\<tau> =\n                                     (\\<Union>(t, u)\\<in>set (x2 @ P).\n   vars_term t) \\<union>\n                                     dom \\<sigma> \\<and>\n                                     (\\<forall>(t, y)\\<in>set (x2 @ P).\n   subst_atm_abbrev t (subst_of_map Var \\<tau>) = y);\n        match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> =\n        Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                         dom \\<tau> =\n                         (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n                             vars_term t) \\<union>\n                         dom \\<sigma> \\<and>\n                         (\\<forall>(t, y)\n                                   \\<in>set ((Fun f ss, Fun g ts) # P).\n                             subst_atm_abbrev t (subst_of_map Var \\<tau>) =\n                             y)\n 3. \\<And>f ss x P \\<sigma>.\n       match_term_list ((Fun f ss, Var x) # P) \\<sigma> =\n       Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n           vars_term t) \\<union>\n       dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set ((Fun f ss, Var x) # P).\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>.\n       match_term_list [] \\<sigma> = Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union> dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set [].\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)\n 2. \\<And>f ss g ts P \\<sigma>.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    match_term_list (x2 @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                                     dom \\<tau> =\n                                     (\\<Union>(t, u)\\<in>set (x2 @ P).\n   vars_term t) \\<union>\n                                     dom \\<sigma> \\<and>\n                                     (\\<forall>(t, y)\\<in>set (x2 @ P).\n   subst_atm_abbrev t (subst_of_map Var \\<tau>) = y);\n        match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> =\n        Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                         dom \\<tau> =\n                         (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n                             vars_term t) \\<union>\n                         dom \\<sigma> \\<and>\n                         (\\<forall>(t, y)\n                                   \\<in>set ((Fun f ss, Fun g ts) # P).\n                             subst_atm_abbrev t (subst_of_map Var \\<tau>) =\n                             y)\n 3. \\<And>f ss x P \\<sigma>.\n       match_term_list ((Fun f ss, Var x) # P) \\<sigma> =\n       Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n           vars_term t) \\<union>\n       dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set ((Fun f ss, Var x) # P).\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)", "case (3 f ss g ts P \\<sigma>)"], ["proof (state)\nthis:\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?x2.0;\n   match_term_list (?x2.0 @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n  \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                    dom \\<tau> =\n                    (\\<Union>a\\<in>set (?x2.0 @ P).\n                        case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n                    dom \\<sigma> \\<and>\n                    (\\<forall>a\\<in>set (?x2.0 @ P).\n                        case a of\n                        (t, a) \\<Rightarrow>\n                          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a)\n  match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> = Some \\<tau>\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>.\n       match_term_list [] \\<sigma> = Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union> dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set [].\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)\n 2. \\<And>f ss g ts P \\<sigma>.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    match_term_list (x2 @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                                     dom \\<tau> =\n                                     (\\<Union>(t, u)\\<in>set (x2 @ P).\n   vars_term t) \\<union>\n                                     dom \\<sigma> \\<and>\n                                     (\\<forall>(t, y)\\<in>set (x2 @ P).\n   subst_atm_abbrev t (subst_of_map Var \\<tau>) = y);\n        match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> =\n        Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                         dom \\<tau> =\n                         (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n                             vars_term t) \\<union>\n                         dom \\<sigma> \\<and>\n                         (\\<forall>(t, y)\n                                   \\<in>set ((Fun f ss, Fun g ts) # P).\n                             subst_atm_abbrev t (subst_of_map Var \\<tau>) =\n                             y)\n 3. \\<And>f ss x P \\<sigma>.\n       match_term_list ((Fun f ss, Var x) # P) \\<sigma> =\n       Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n           vars_term t) \\<union>\n       dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set ((Fun f ss, Var x) # P).\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)", "from 3(2)"], ["proof (chain)\npicking this:\n  match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> = Some \\<tau>", "obtain eqs where \"decompose (Fun f ss) (Fun g ts) = Some eqs\"\n    \"match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\""], ["proof (prove)\nusing this:\n  match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> = Some \\<tau>\n\ngoal (1 subgoal):\n 1. (\\<And>eqs.\n        \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some eqs;\n         match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  decompose (Fun f ss) (Fun g ts) = Some eqs\n  match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>.\n       match_term_list [] \\<sigma> = Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union> dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set [].\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)\n 2. \\<And>f ss g ts P \\<sigma>.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    match_term_list (x2 @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                                     dom \\<tau> =\n                                     (\\<Union>(t, u)\\<in>set (x2 @ P).\n   vars_term t) \\<union>\n                                     dom \\<sigma> \\<and>\n                                     (\\<forall>(t, y)\\<in>set (x2 @ P).\n   subst_atm_abbrev t (subst_of_map Var \\<tau>) = y);\n        match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> =\n        Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> extends_subst \\<sigma> \\<tau> \\<and>\n                         dom \\<tau> =\n                         (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n                             vars_term t) \\<union>\n                         dom \\<sigma> \\<and>\n                         (\\<forall>(t, y)\n                                   \\<in>set ((Fun f ss, Fun g ts) # P).\n                             subst_atm_abbrev t (subst_of_map Var \\<tau>) =\n                             y)\n 3. \\<And>f ss x P \\<sigma>.\n       match_term_list ((Fun f ss, Var x) # P) \\<sigma> =\n       Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n           vars_term t) \\<union>\n       dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set ((Fun f ss, Var x) # P).\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)", "with 3(1)[OF this]"], ["proof (chain)\npicking this:\n  extends_subst \\<sigma> \\<tau> \\<and>\n  dom \\<tau> =\n  (\\<Union>a\\<in>set (eqs @ P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n  dom \\<sigma> \\<and>\n  (\\<forall>a\\<in>set (eqs @ P).\n      case a of\n      (t, a) \\<Rightarrow> subst_atm_abbrev t (subst_of_map Var \\<tau>) = a)\n  decompose (Fun f ss) (Fun g ts) = Some eqs\n  match_term_list (eqs @ P) \\<sigma> = Some \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  extends_subst \\<sigma> \\<tau> \\<and>\n  dom \\<tau> =\n  (\\<Union>a\\<in>set (eqs @ P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n  dom \\<sigma> \\<and>\n  (\\<forall>a\\<in>set (eqs @ P).\n      case a of\n      (t, a) \\<Rightarrow> subst_atm_abbrev t (subst_of_map Var \\<tau>) = a)\n  decompose (Fun f ss) (Fun g ts) = Some eqs\n  match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\n\ngoal (1 subgoal):\n 1. extends_subst \\<sigma> \\<tau> \\<and>\n    dom \\<tau> =\n    (\\<Union>a\\<in>set ((Fun f ss, Fun g ts) # P).\n        case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n    dom \\<sigma> \\<and>\n    (\\<forall>a\\<in>set ((Fun f ss, Fun g ts) # P).\n        case a of\n        (t, a) \\<Rightarrow>\n          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a)", "proof (elim decompose_Some_var_terms[where P = P, elim_format] conjE, intro conjI, goal_cases extend dom subst)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>match_term_list (eqs @ P) \\<sigma> = Some \\<tau>;\n     extends_subst \\<sigma> \\<tau>; f = g;\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma>;\n     \\<forall>a\\<in>set (eqs @ P).\n        case a of\n        (t, a) \\<Rightarrow>\n          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a;\n     length ss = length ts; eqs = zip ss ts;\n     (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n     (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t);\n     extends_subst \\<sigma> \\<tau> \\<and>\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma> \\<and>\n     (\\<forall>a\\<in>set (eqs @ P).\n         case a of\n         (t, a) \\<Rightarrow>\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = a);\n     decompose (Fun f ss) (Fun g ts) = Some eqs;\n     match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n    \\<Longrightarrow> extends_subst \\<sigma> \\<tau>\n 2. \\<lbrakk>match_term_list (eqs @ P) \\<sigma> = Some \\<tau>;\n     extends_subst \\<sigma> \\<tau>; f = g;\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma>;\n     \\<forall>a\\<in>set (eqs @ P).\n        case a of\n        (t, a) \\<Rightarrow>\n          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a;\n     length ss = length ts; eqs = zip ss ts;\n     (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n     (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t);\n     extends_subst \\<sigma> \\<tau> \\<and>\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma> \\<and>\n     (\\<forall>a\\<in>set (eqs @ P).\n         case a of\n         (t, a) \\<Rightarrow>\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = a);\n     decompose (Fun f ss) (Fun g ts) = Some eqs;\n     match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n    \\<Longrightarrow> dom \\<tau> =\n                      (\\<Union>a\\<in>set ((Fun f ss, Fun g ts) # P).\n                          case a of\n                          (t, u) \\<Rightarrow> vars_term t) \\<union>\n                      dom \\<sigma>\n 3. \\<lbrakk>match_term_list (eqs @ P) \\<sigma> = Some \\<tau>;\n     extends_subst \\<sigma> \\<tau>; f = g;\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma>;\n     \\<forall>a\\<in>set (eqs @ P).\n        case a of\n        (t, a) \\<Rightarrow>\n          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a;\n     length ss = length ts; eqs = zip ss ts;\n     (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n     (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t);\n     extends_subst \\<sigma> \\<tau> \\<and>\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma> \\<and>\n     (\\<forall>a\\<in>set (eqs @ P).\n         case a of\n         (t, a) \\<Rightarrow>\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = a);\n     decompose (Fun f ss) (Fun g ts) = Some eqs;\n     match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set ((Fun f ss, Fun g ts) # P).\n                         case a of\n                         (t, a) \\<Rightarrow>\n                           subst_atm_abbrev t (subst_of_map Var \\<tau>) = a", "case subst"], ["proof (state)\nthis:\n  match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\n  extends_subst \\<sigma> \\<tau>\n  f = g\n  dom \\<tau> =\n  (\\<Union>a\\<in>set (eqs @ P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n  dom \\<sigma>\n  \\<forall>a\\<in>set (eqs @ P).\n     case a of\n     (t, a) \\<Rightarrow> subst_atm_abbrev t (subst_of_map Var \\<tau>) = a\n  length ss = length ts\n  eqs = zip ss ts\n  (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n  (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t)\n  extends_subst \\<sigma> \\<tau> \\<and>\n  dom \\<tau> =\n  (\\<Union>a\\<in>set (eqs @ P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n  dom \\<sigma> \\<and>\n  (\\<forall>a\\<in>set (eqs @ P).\n      case a of\n      (t, a) \\<Rightarrow> subst_atm_abbrev t (subst_of_map Var \\<tau>) = a)\n  decompose (Fun f ss) (Fun g ts) = Some eqs\n  match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>match_term_list (eqs @ P) \\<sigma> = Some \\<tau>;\n     extends_subst \\<sigma> \\<tau>; f = g;\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma>;\n     \\<forall>a\\<in>set (eqs @ P).\n        case a of\n        (t, a) \\<Rightarrow>\n          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a;\n     length ss = length ts; eqs = zip ss ts;\n     (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n     (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t);\n     extends_subst \\<sigma> \\<tau> \\<and>\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma> \\<and>\n     (\\<forall>a\\<in>set (eqs @ P).\n         case a of\n         (t, a) \\<Rightarrow>\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = a);\n     decompose (Fun f ss) (Fun g ts) = Some eqs;\n     match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n    \\<Longrightarrow> extends_subst \\<sigma> \\<tau>\n 2. \\<lbrakk>match_term_list (eqs @ P) \\<sigma> = Some \\<tau>;\n     extends_subst \\<sigma> \\<tau>; f = g;\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma>;\n     \\<forall>a\\<in>set (eqs @ P).\n        case a of\n        (t, a) \\<Rightarrow>\n          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a;\n     length ss = length ts; eqs = zip ss ts;\n     (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n     (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t);\n     extends_subst \\<sigma> \\<tau> \\<and>\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma> \\<and>\n     (\\<forall>a\\<in>set (eqs @ P).\n         case a of\n         (t, a) \\<Rightarrow>\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = a);\n     decompose (Fun f ss) (Fun g ts) = Some eqs;\n     match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n    \\<Longrightarrow> dom \\<tau> =\n                      (\\<Union>a\\<in>set ((Fun f ss, Fun g ts) # P).\n                          case a of\n                          (t, u) \\<Rightarrow> vars_term t) \\<union>\n                      dom \\<sigma>\n 3. \\<lbrakk>match_term_list (eqs @ P) \\<sigma> = Some \\<tau>;\n     extends_subst \\<sigma> \\<tau>; f = g;\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma>;\n     \\<forall>a\\<in>set (eqs @ P).\n        case a of\n        (t, a) \\<Rightarrow>\n          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a;\n     length ss = length ts; eqs = zip ss ts;\n     (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n     (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t);\n     extends_subst \\<sigma> \\<tau> \\<and>\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma> \\<and>\n     (\\<forall>a\\<in>set (eqs @ P).\n         case a of\n         (t, a) \\<Rightarrow>\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = a);\n     decompose (Fun f ss) (Fun g ts) = Some eqs;\n     match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set ((Fun f ss, Fun g ts) # P).\n                         case a of\n                         (t, a) \\<Rightarrow>\n                           subst_atm_abbrev t (subst_of_map Var \\<tau>) = a", "from subst(3,5,6,7)"], ["proof (chain)\npicking this:\n  f = g\n  \\<forall>a\\<in>set (eqs @ P).\n     case a of\n     (t, a) \\<Rightarrow> subst_atm_abbrev t (subst_of_map Var \\<tau>) = a\n  length ss = length ts\n  eqs = zip ss ts", "show ?case"], ["proof (prove)\nusing this:\n  f = g\n  \\<forall>a\\<in>set (eqs @ P).\n     case a of\n     (t, a) \\<Rightarrow> subst_atm_abbrev t (subst_of_map Var \\<tau>) = a\n  length ss = length ts\n  eqs = zip ss ts\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set ((Fun f ss, Fun g ts) # P).\n       case a of\n       (t, a) \\<Rightarrow> subst_atm_abbrev t (subst_of_map Var \\<tau>) = a", "by (auto 0 6 simp: in_set_conv_nth list_eq_iff_nth_eq Ball_def)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ((Fun f ss, Fun g ts) # P).\n     case a of\n     (t, a) \\<Rightarrow> subst_atm_abbrev t (subst_of_map Var \\<tau>) = a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>match_term_list (eqs @ P) \\<sigma> = Some \\<tau>;\n     extends_subst \\<sigma> \\<tau>; f = g;\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma>;\n     \\<forall>a\\<in>set (eqs @ P).\n        case a of\n        (t, a) \\<Rightarrow>\n          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a;\n     length ss = length ts; eqs = zip ss ts;\n     (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n     (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t);\n     extends_subst \\<sigma> \\<tau> \\<and>\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma> \\<and>\n     (\\<forall>a\\<in>set (eqs @ P).\n         case a of\n         (t, a) \\<Rightarrow>\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = a);\n     decompose (Fun f ss) (Fun g ts) = Some eqs;\n     match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n    \\<Longrightarrow> extends_subst \\<sigma> \\<tau>\n 2. \\<lbrakk>match_term_list (eqs @ P) \\<sigma> = Some \\<tau>;\n     extends_subst \\<sigma> \\<tau>; f = g;\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma>;\n     \\<forall>a\\<in>set (eqs @ P).\n        case a of\n        (t, a) \\<Rightarrow>\n          subst_atm_abbrev t (subst_of_map Var \\<tau>) = a;\n     length ss = length ts; eqs = zip ss ts;\n     (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n     (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t);\n     extends_subst \\<sigma> \\<tau> \\<and>\n     dom \\<tau> =\n     (\\<Union>a\\<in>set (eqs @ P).\n         case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n     dom \\<sigma> \\<and>\n     (\\<forall>a\\<in>set (eqs @ P).\n         case a of\n         (t, a) \\<Rightarrow>\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = a);\n     decompose (Fun f ss) (Fun g ts) = Some eqs;\n     match_term_list (eqs @ P) \\<sigma> = Some \\<tau>\\<rbrakk>\n    \\<Longrightarrow> dom \\<tau> =\n                      (\\<Union>a\\<in>set ((Fun f ss, Fun g ts) # P).\n                          case a of\n                          (t, u) \\<Rightarrow> vars_term t) \\<union>\n                      dom \\<sigma>", "qed auto"], ["proof (state)\nthis:\n  extends_subst \\<sigma> \\<tau> \\<and>\n  dom \\<tau> =\n  (\\<Union>a\\<in>set ((Fun f ss, Fun g ts) # P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n  dom \\<sigma> \\<and>\n  (\\<forall>a\\<in>set ((Fun f ss, Fun g ts) # P).\n      case a of\n      (t, a) \\<Rightarrow> subst_atm_abbrev t (subst_of_map Var \\<tau>) = a)\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       match_term_list [] \\<sigma> = Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union> dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set [].\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)\n 2. \\<And>f ss x P \\<sigma>.\n       match_term_list ((Fun f ss, Var x) # P) \\<sigma> =\n       Some \\<tau> \\<Longrightarrow>\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> =\n       (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n           vars_term t) \\<union>\n       dom \\<sigma> \\<and>\n       (\\<forall>(t, y)\\<in>set ((Fun f ss, Var x) # P).\n           subst_atm_abbrev t (subst_of_map Var \\<tau>) = y)", "qed auto"], ["", "lemma match_term_list_complete: \"match_term_list tus \\<sigma> = None \\<Longrightarrow>\n   extends_subst \\<sigma> \\<tau> \\<Longrightarrow> dom \\<tau> = (\\<Union>(t, u)\\<in>set tus. vars_term t) \\<union> dom \\<sigma> \\<Longrightarrow>\n    (\\<exists>(t,u)\\<in>set tus. t \\<cdot> subst_of_map Var \\<tau> \\<noteq> u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match_term_list tus \\<sigma> = None;\n     extends_subst \\<sigma> \\<tau>;\n     dom \\<tau> =\n     (\\<Union>(t, u)\\<in>set tus. vars_term t) \\<union>\n     dom \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>(t, u)\\<in>set tus.\n                         subst_atm_abbrev t\n                          (subst_of_map Var \\<tau>) \\<noteq>\n                         u", "proof (induct tus \\<sigma> arbitrary: \\<tau> rule: match_term_list.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list [] \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set [].\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 2. \\<And>x t P \\<sigma> \\<tau>.\n       \\<lbrakk>\\<And>\\<tau>.\n                   \\<lbrakk>\\<sigma> x = None \\<or> \\<sigma> x = Some t;\n                    match_term_list P (\\<sigma>(x \\<mapsto> t)) = None;\n                    extends_subst (\\<sigma>(x \\<mapsto> t)) \\<tau>;\n                    dom \\<tau> =\n                    (\\<Union>(t, u)\\<in>set P. vars_term t) \\<union>\n                    dom (\\<sigma>(x \\<mapsto> t))\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>(t, u)\\<in>set P.\n  subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u;\n        match_term_list ((Var x, t) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Var x, t) # P). vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Var x, t) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 3. \\<And>f ss g ts P \\<sigma> \\<tau>.\n       \\<lbrakk>\\<And>x2 \\<tau>.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    match_term_list (x2 @ P) \\<sigma> = None;\n                    extends_subst \\<sigma> \\<tau>;\n                    dom \\<tau> =\n                    (\\<Union>(t, u)\\<in>set (x2 @ P). vars_term t) \\<union>\n                    dom \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>(t, u)\\<in>set (x2 @ P).\n  subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u;\n        match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n            vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 4. \\<And>f ss x P \\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list ((Fun f ss, Var x) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n            vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u", "case (2 x t P \\<sigma>)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<sigma> x = None \\<or> \\<sigma> x = Some t;\n   match_term_list P (\\<sigma>(x \\<mapsto> t)) = None;\n   extends_subst (\\<sigma>(x \\<mapsto> t)) ?\\<tau>;\n   dom ?\\<tau> =\n   (\\<Union>a\\<in>set P.\n       case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n   dom (\\<sigma>(x \\<mapsto> t))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<in>set P.\n                       case a of\n                       (t, u) \\<Rightarrow>\n                         subst_atm_abbrev t\n                          (subst_of_map Var ?\\<tau>) \\<noteq>\n                         u\n  match_term_list ((Var x, t) # P) \\<sigma> = None\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> =\n  (\\<Union>a\\<in>set ((Var x, t) # P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n  dom \\<sigma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list [] \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set [].\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 2. \\<And>x t P \\<sigma> \\<tau>.\n       \\<lbrakk>\\<And>\\<tau>.\n                   \\<lbrakk>\\<sigma> x = None \\<or> \\<sigma> x = Some t;\n                    match_term_list P (\\<sigma>(x \\<mapsto> t)) = None;\n                    extends_subst (\\<sigma>(x \\<mapsto> t)) \\<tau>;\n                    dom \\<tau> =\n                    (\\<Union>(t, u)\\<in>set P. vars_term t) \\<union>\n                    dom (\\<sigma>(x \\<mapsto> t))\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>(t, u)\\<in>set P.\n  subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u;\n        match_term_list ((Var x, t) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Var x, t) # P). vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Var x, t) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 3. \\<And>f ss g ts P \\<sigma> \\<tau>.\n       \\<lbrakk>\\<And>x2 \\<tau>.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    match_term_list (x2 @ P) \\<sigma> = None;\n                    extends_subst \\<sigma> \\<tau>;\n                    dom \\<tau> =\n                    (\\<Union>(t, u)\\<in>set (x2 @ P). vars_term t) \\<union>\n                    dom \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>(t, u)\\<in>set (x2 @ P).\n  subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u;\n        match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n            vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 4. \\<And>f ss x P \\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list ((Fun f ss, Var x) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n            vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<sigma> x = None \\<or> \\<sigma> x = Some t;\n   match_term_list P (\\<sigma>(x \\<mapsto> t)) = None;\n   extends_subst (\\<sigma>(x \\<mapsto> t)) ?\\<tau>;\n   dom ?\\<tau> =\n   (\\<Union>a\\<in>set P.\n       case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n   dom (\\<sigma>(x \\<mapsto> t))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<in>set P.\n                       case a of\n                       (t, u) \\<Rightarrow>\n                         subst_atm_abbrev t\n                          (subst_of_map Var ?\\<tau>) \\<noteq>\n                         u\n  match_term_list ((Var x, t) # P) \\<sigma> = None\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> =\n  (\\<Union>a\\<in>set ((Var x, t) # P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n  dom \\<sigma>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<sigma> x = None \\<or> \\<sigma> x = Some t;\n   match_term_list P (\\<sigma>(x \\<mapsto> t)) = None;\n   extends_subst (\\<sigma>(x \\<mapsto> t)) ?\\<tau>;\n   dom ?\\<tau> =\n   (\\<Union>a\\<in>set P.\n       case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n   dom (\\<sigma>(x \\<mapsto> t))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<in>set P.\n                       case a of\n                       (t, u) \\<Rightarrow>\n                         subst_atm_abbrev t\n                          (subst_of_map Var ?\\<tau>) \\<noteq>\n                         u\n  match_term_list ((Var x, t) # P) \\<sigma> = None\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> =\n  (\\<Union>a\\<in>set ((Var x, t) # P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n  dom \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set ((Var x, t) # P).\n       case a of\n       (t, u) \\<Rightarrow>\n         subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u", "by (auto simp: extends_subst_fun_upd_new extends_subst_fun_upd_matching\n      subst_of_map_def dest: extends_subst_extends simp del: fun_upd_apply\n      split: if_splits option.splits)"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set ((Var x, t) # P).\n     case a of\n     (t, u) \\<Rightarrow>\n       subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list [] \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set [].\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 2. \\<And>f ss g ts P \\<sigma> \\<tau>.\n       \\<lbrakk>\\<And>x2 \\<tau>.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    match_term_list (x2 @ P) \\<sigma> = None;\n                    extends_subst \\<sigma> \\<tau>;\n                    dom \\<tau> =\n                    (\\<Union>(t, u)\\<in>set (x2 @ P). vars_term t) \\<union>\n                    dom \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>(t, u)\\<in>set (x2 @ P).\n  subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u;\n        match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n            vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 3. \\<And>f ss x P \\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list ((Fun f ss, Var x) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n            vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list [] \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set [].\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 2. \\<And>f ss g ts P \\<sigma> \\<tau>.\n       \\<lbrakk>\\<And>x2 \\<tau>.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    match_term_list (x2 @ P) \\<sigma> = None;\n                    extends_subst \\<sigma> \\<tau>;\n                    dom \\<tau> =\n                    (\\<Union>(t, u)\\<in>set (x2 @ P). vars_term t) \\<union>\n                    dom \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>(t, u)\\<in>set (x2 @ P).\n  subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u;\n        match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n            vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 3. \\<And>f ss x P \\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list ((Fun f ss, Var x) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n            vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u", "case (3 f ss g ts P \\<sigma>)"], ["proof (state)\nthis:\n  \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some ?x2.0;\n   match_term_list (?x2.0 @ P) \\<sigma> = None;\n   extends_subst \\<sigma> ?\\<tau>;\n   dom ?\\<tau> =\n   (\\<Union>a\\<in>set (?x2.0 @ P).\n       case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n   dom \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<in>set (?x2.0 @ P).\n                       case a of\n                       (t, u) \\<Rightarrow>\n                         subst_atm_abbrev t\n                          (subst_of_map Var ?\\<tau>) \\<noteq>\n                         u\n  match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> = None\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> =\n  (\\<Union>a\\<in>set ((Fun f ss, Fun g ts) # P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<union>\n  dom \\<sigma>\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list [] \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set [].\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 2. \\<And>f ss g ts P \\<sigma> \\<tau>.\n       \\<lbrakk>\\<And>x2 \\<tau>.\n                   \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some x2;\n                    match_term_list (x2 @ P) \\<sigma> = None;\n                    extends_subst \\<sigma> \\<tau>;\n                    dom \\<tau> =\n                    (\\<Union>(t, u)\\<in>set (x2 @ P). vars_term t) \\<union>\n                    dom \\<sigma>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>(t, u)\\<in>set (x2 @ P).\n  subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u;\n        match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n            vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 3. \\<And>f ss x P \\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list ((Fun f ss, Var x) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n            vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n       case a of\n       (t, u) \\<Rightarrow>\n         subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u", "proof (cases \"decompose (Fun f ss) (Fun g ts) = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow>\n    \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n       case a of\n       (t, u) \\<Rightarrow>\n         subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n 2. decompose (Fun f ss) (Fun g ts) \\<noteq> None \\<Longrightarrow>\n    \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n       case a of\n       (t, u) \\<Rightarrow>\n         subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u", "case False"], ["proof (state)\nthis:\n  decompose (Fun f ss) (Fun g ts) \\<noteq> None\n\ngoal (2 subgoals):\n 1. decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow>\n    \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n       case a of\n       (t, u) \\<Rightarrow>\n         subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n 2. decompose (Fun f ss) (Fun g ts) \\<noteq> None \\<Longrightarrow>\n    \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n       case a of\n       (t, u) \\<Rightarrow>\n         subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u", "with 3(2)"], ["proof (chain)\npicking this:\n  match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> = None\n  decompose (Fun f ss) (Fun g ts) \\<noteq> None", "obtain eqs where \"decompose (Fun f ss) (Fun g ts) = Some eqs\"\n      \"match_term_list (eqs @ P) \\<sigma> = None\""], ["proof (prove)\nusing this:\n  match_term_list ((Fun f ss, Fun g ts) # P) \\<sigma> = None\n  decompose (Fun f ss) (Fun g ts) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>eqs.\n        \\<lbrakk>decompose (Fun f ss) (Fun g ts) = Some eqs;\n         match_term_list (eqs @ P) \\<sigma> = None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  decompose (Fun f ss) (Fun g ts) = Some eqs\n  match_term_list (eqs @ P) \\<sigma> = None\n\ngoal (2 subgoals):\n 1. decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow>\n    \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n       case a of\n       (t, u) \\<Rightarrow>\n         subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n 2. decompose (Fun f ss) (Fun g ts) \\<noteq> None \\<Longrightarrow>\n    \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n       case a of\n       (t, u) \\<Rightarrow>\n         subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u", "with 3(1)[OF this 3(3) trans[OF 3(4) arg_cong[of _ _ \"\\<lambda>x. x \\<union> dom \\<sigma>\"]]]"], ["proof (chain)\npicking this:\n  (\\<Union>a\\<in>set ((Fun f ss, Fun g ts) # P).\n      case a of (t, u) \\<Rightarrow> vars_term t) =\n  (\\<Union>a\\<in>set (eqs @ P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<Longrightarrow>\n  \\<exists>a\\<in>set (eqs @ P).\n     case a of\n     (t, u) \\<Rightarrow>\n       subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n  decompose (Fun f ss) (Fun g ts) = Some eqs\n  match_term_list (eqs @ P) \\<sigma> = None", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Union>a\\<in>set ((Fun f ss, Fun g ts) # P).\n      case a of (t, u) \\<Rightarrow> vars_term t) =\n  (\\<Union>a\\<in>set (eqs @ P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<Longrightarrow>\n  \\<exists>a\\<in>set (eqs @ P).\n     case a of\n     (t, u) \\<Rightarrow>\n       subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n  decompose (Fun f ss) (Fun g ts) = Some eqs\n  match_term_list (eqs @ P) \\<sigma> = None\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n       case a of\n       (t, u) \\<Rightarrow>\n         subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u", "proof (elim decompose_Some_var_terms[where P = P, elim_format] conjE, goal_cases subst)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Union>a\\<in>set ((Fun f ss, Fun g ts) # P).\n                 case a of (t, u) \\<Rightarrow> vars_term t) =\n             (\\<Union>a\\<in>set (eqs @ P).\n                 case a of\n                 (t, u) \\<Rightarrow> vars_term t) \\<Longrightarrow>\n             \\<exists>a\\<in>set (eqs @ P).\n                case a of\n                (t, u) \\<Rightarrow>\n                  subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u;\n     match_term_list (eqs @ P) \\<sigma> = None; f = g;\n     length ss = length ts; eqs = zip ss ts;\n     (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n     (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n                         case a of\n                         (t, u) \\<Rightarrow>\n                           subst_atm_abbrev t\n                            (subst_of_map Var \\<tau>) \\<noteq>\n                           u", "case subst"], ["proof (state)\nthis:\n  (\\<Union>a\\<in>set ((Fun f ss, Fun g ts) # P).\n      case a of (t, u) \\<Rightarrow> vars_term t) =\n  (\\<Union>a\\<in>set (eqs @ P).\n      case a of (t, u) \\<Rightarrow> vars_term t) \\<Longrightarrow>\n  \\<exists>a\\<in>set (eqs @ P).\n     case a of\n     (t, u) \\<Rightarrow>\n       subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n  match_term_list (eqs @ P) \\<sigma> = None\n  f = g\n  length ss = length ts\n  eqs = zip ss ts\n  (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n  (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Union>a\\<in>set ((Fun f ss, Fun g ts) # P).\n                 case a of (t, u) \\<Rightarrow> vars_term t) =\n             (\\<Union>a\\<in>set (eqs @ P).\n                 case a of\n                 (t, u) \\<Rightarrow> vars_term t) \\<Longrightarrow>\n             \\<exists>a\\<in>set (eqs @ P).\n                case a of\n                (t, u) \\<Rightarrow>\n                  subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u;\n     match_term_list (eqs @ P) \\<sigma> = None; f = g;\n     length ss = length ts; eqs = zip ss ts;\n     (\\<Union>(t, u)\\<in>set ((Fun f ss, Fun g ts) # P). vars_term t) =\n     (\\<Union>(t, u)\\<in>set (eqs @ P). vars_term t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n                         case a of\n                         (t, u) \\<Rightarrow>\n                           subst_atm_abbrev t\n                            (subst_of_map Var \\<tau>) \\<noteq>\n                           u", "from subst(1)[OF subst(6)] subst(4,5)"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>set (eqs @ P).\n     case a of\n     (t, u) \\<Rightarrow>\n       subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n  length ss = length ts\n  eqs = zip ss ts", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>set (eqs @ P).\n     case a of\n     (t, u) \\<Rightarrow>\n       subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n  length ss = length ts\n  eqs = zip ss ts\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n       case a of\n       (t, u) \\<Rightarrow>\n         subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u", "by (auto 0 3 simp: in_set_conv_nth list_eq_iff_nth_eq Ball_def)"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n     case a of\n     (t, u) \\<Rightarrow>\n       subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n     case a of\n     (t, u) \\<Rightarrow>\n       subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n\ngoal (1 subgoal):\n 1. decompose (Fun f ss) (Fun g ts) = None \\<Longrightarrow>\n    \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n       case a of\n       (t, u) \\<Rightarrow>\n         subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u", "qed auto"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set ((Fun f ss, Fun g ts) # P).\n     case a of\n     (t, u) \\<Rightarrow>\n       subst_atm_abbrev t (subst_of_map Var \\<tau>) \\<noteq> u\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list [] \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set []. vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set [].\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u\n 2. \\<And>f ss x P \\<sigma> \\<tau>.\n       \\<lbrakk>match_term_list ((Fun f ss, Var x) # P) \\<sigma> = None;\n        extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> =\n        (\\<Union>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n            vars_term t) \\<union>\n        dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>(t, u)\\<in>set ((Fun f ss, Var x) # P).\n                            subst_atm_abbrev t\n                             (subst_of_map Var \\<tau>) \\<noteq>\n                            u", "qed auto"], ["", "lemma unique_extends_subst:\n  assumes extends: \"extends_subst \\<sigma> \\<tau>\" \"extends_subst \\<sigma> \\<rho>\" and\n    dom: \"dom \\<tau> = vars_term t \\<union> dom \\<sigma>\" \"dom \\<rho> = vars_term t \\<union> dom \\<sigma>\" and\n    eq: \"t \\<cdot> subst_of_map Var \\<rho> = t \\<cdot> subst_of_map Var \\<tau>\"\n  shows \"\\<rho> = \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> = \\<tau>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<rho> x = \\<tau> x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<rho> x = \\<tau> x", "consider (a) \"x \\<in> dom \\<sigma>\" | (b) \"x \\<in> vars_term t\" | (c) \"x \\<notin> dom \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom \\<sigma> \\<Longrightarrow> thesis;\n     x \\<in> vars_term t \\<Longrightarrow> thesis;\n     x \\<notin> dom \\<tau> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  extends_subst \\<sigma> \\<tau>\n  extends_subst \\<sigma> \\<rho>\n  dom \\<tau> = vars_term t \\<union> dom \\<sigma>\n  dom \\<rho> = vars_term t \\<union> dom \\<sigma>\n  subst_atm_abbrev t (subst_of_map Var \\<rho>) =\n  subst_atm_abbrev t (subst_of_map Var \\<tau>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom \\<sigma> \\<Longrightarrow> thesis;\n     x \\<in> vars_term t \\<Longrightarrow> thesis;\n     x \\<notin> dom \\<tau> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> dom \\<sigma> \\<Longrightarrow> ?thesis;\n   x \\<in> vars_term t \\<Longrightarrow> ?thesis;\n   x \\<notin> dom \\<tau> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<rho> x = \\<tau> x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> dom \\<sigma> \\<Longrightarrow> ?thesis;\n   x \\<in> vars_term t \\<Longrightarrow> ?thesis;\n   x \\<notin> dom \\<tau> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"\\<rho> x = \\<tau> x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> dom \\<sigma> \\<Longrightarrow> ?thesis;\n   x \\<in> vars_term t \\<Longrightarrow> ?thesis;\n   x \\<notin> dom \\<tau> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<rho> x = \\<tau> x", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<in> dom \\<sigma> \\<Longrightarrow> \\<rho> x = \\<tau> x\n 2. x \\<in> vars_term t \\<Longrightarrow> \\<rho> x = \\<tau> x\n 3. x \\<notin> dom \\<tau> \\<Longrightarrow> \\<rho> x = \\<tau> x", "case a"], ["proof (state)\nthis:\n  x \\<in> dom \\<sigma>\n\ngoal (3 subgoals):\n 1. x \\<in> dom \\<sigma> \\<Longrightarrow> \\<rho> x = \\<tau> x\n 2. x \\<in> vars_term t \\<Longrightarrow> \\<rho> x = \\<tau> x\n 3. x \\<notin> dom \\<tau> \\<Longrightarrow> \\<rho> x = \\<tau> x", "then"], ["proof (chain)\npicking this:\n  x \\<in> dom \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> dom \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<rho> x = \\<tau> x", "using extends"], ["proof (prove)\nusing this:\n  x \\<in> dom \\<sigma>\n  extends_subst \\<sigma> \\<tau>\n  extends_subst \\<sigma> \\<rho>\n\ngoal (1 subgoal):\n 1. \\<rho> x = \\<tau> x", "unfolding extends_subst_def"], ["proof (prove)\nusing this:\n  x \\<in> dom \\<sigma>\n  \\<forall>x\\<in>dom \\<sigma>. \\<sigma> x = \\<tau> x\n  \\<forall>x\\<in>dom \\<sigma>. \\<sigma> x = \\<rho> x\n\ngoal (1 subgoal):\n 1. \\<rho> x = \\<tau> x", "by auto"], ["proof (state)\nthis:\n  \\<rho> x = \\<tau> x\n\ngoal (2 subgoals):\n 1. x \\<in> vars_term t \\<Longrightarrow> \\<rho> x = \\<tau> x\n 2. x \\<notin> dom \\<tau> \\<Longrightarrow> \\<rho> x = \\<tau> x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> vars_term t \\<Longrightarrow> \\<rho> x = \\<tau> x\n 2. x \\<notin> dom \\<tau> \\<Longrightarrow> \\<rho> x = \\<tau> x", "case b"], ["proof (state)\nthis:\n  x \\<in> vars_term t\n\ngoal (2 subgoals):\n 1. x \\<in> vars_term t \\<Longrightarrow> \\<rho> x = \\<tau> x\n 2. x \\<notin> dom \\<tau> \\<Longrightarrow> \\<rho> x = \\<tau> x", "with eq"], ["proof (chain)\npicking this:\n  subst_atm_abbrev t (subst_of_map Var \\<rho>) =\n  subst_atm_abbrev t (subst_of_map Var \\<tau>)\n  x \\<in> vars_term t", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_atm_abbrev t (subst_of_map Var \\<rho>) =\n  subst_atm_abbrev t (subst_of_map Var \\<tau>)\n  x \\<in> vars_term t\n\ngoal (1 subgoal):\n 1. \\<rho> x = \\<tau> x", "proof (induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>subst_atm_abbrev (Var xa) (subst_of_map Var \\<rho>) =\n                subst_atm_abbrev (Var xa) (subst_of_map Var \\<tau>);\n        x \\<in> vars_term (Var xa)\\<rbrakk>\n       \\<Longrightarrow> \\<rho> x = \\<tau> x\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    subst_atm_abbrev x2a (subst_of_map Var \\<rho>) =\n                    subst_atm_abbrev x2a (subst_of_map Var \\<tau>);\n                    x \\<in> vars_term x2a\\<rbrakk>\n                   \\<Longrightarrow> \\<rho> x = \\<tau> x;\n        subst_atm_abbrev (Fun x1a x2) (subst_of_map Var \\<rho>) =\n        subst_atm_abbrev (Fun x1a x2) (subst_of_map Var \\<tau>);\n        x \\<in> vars_term (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> \\<rho> x = \\<tau> x", "case (Var x)"], ["proof (state)\nthis:\n  subst_atm_abbrev (Var x) (subst_of_map Var \\<rho>) =\n  subst_atm_abbrev (Var x) (subst_of_map Var \\<tau>)\n  x__ \\<in> vars_term (Var x)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>subst_atm_abbrev (Var xa) (subst_of_map Var \\<rho>) =\n                subst_atm_abbrev (Var xa) (subst_of_map Var \\<tau>);\n        x__ \\<in> vars_term (Var xa)\\<rbrakk>\n       \\<Longrightarrow> \\<rho> x__ = \\<tau> x__\n 2. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    subst_atm_abbrev x2a (subst_of_map Var \\<rho>) =\n                    subst_atm_abbrev x2a (subst_of_map Var \\<tau>);\n                    x__ \\<in> vars_term x2a\\<rbrakk>\n                   \\<Longrightarrow> \\<rho> x__ = \\<tau> x__;\n        subst_atm_abbrev (Fun x1a x2) (subst_of_map Var \\<rho>) =\n        subst_atm_abbrev (Fun x1a x2) (subst_of_map Var \\<tau>);\n        x__ \\<in> vars_term (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> \\<rho> x__ = \\<tau> x__", "with trans[OF dom(1) dom(2)[symmetric]]"], ["proof (chain)\npicking this:\n  dom \\<tau> = dom \\<rho>\n  subst_atm_abbrev (Var x) (subst_of_map Var \\<rho>) =\n  subst_atm_abbrev (Var x) (subst_of_map Var \\<tau>)\n  x__ \\<in> vars_term (Var x)", "show ?case"], ["proof (prove)\nusing this:\n  dom \\<tau> = dom \\<rho>\n  subst_atm_abbrev (Var x) (subst_of_map Var \\<rho>) =\n  subst_atm_abbrev (Var x) (subst_of_map Var \\<tau>)\n  x__ \\<in> vars_term (Var x)\n\ngoal (1 subgoal):\n 1. \\<rho> x__ = \\<tau> x__", "by (auto simp: subst_of_map_def split: option.splits)"], ["proof (state)\nthis:\n  \\<rho> x__ = \\<tau> x__\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    subst_atm_abbrev x2a (subst_of_map Var \\<rho>) =\n                    subst_atm_abbrev x2a (subst_of_map Var \\<tau>);\n                    x__ \\<in> vars_term x2a\\<rbrakk>\n                   \\<Longrightarrow> \\<rho> x__ = \\<tau> x__;\n        subst_atm_abbrev (Fun x1a x2) (subst_of_map Var \\<rho>) =\n        subst_atm_abbrev (Fun x1a x2) (subst_of_map Var \\<tau>);\n        x__ \\<in> vars_term (Fun x1a x2)\\<rbrakk>\n       \\<Longrightarrow> \\<rho> x__ = \\<tau> x__", "qed auto"], ["proof (state)\nthis:\n  \\<rho> x = \\<tau> x\n\ngoal (1 subgoal):\n 1. x \\<notin> dom \\<tau> \\<Longrightarrow> \\<rho> x = \\<tau> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> dom \\<tau> \\<Longrightarrow> \\<rho> x = \\<tau> x", "case c"], ["proof (state)\nthis:\n  x \\<notin> dom \\<tau>\n\ngoal (1 subgoal):\n 1. x \\<notin> dom \\<tau> \\<Longrightarrow> \\<rho> x = \\<tau> x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> dom \\<tau>", "have \"\\<rho> x = None\" \"\\<tau> x = None\""], ["proof (prove)\nusing this:\n  x \\<notin> dom \\<tau>\n\ngoal (1 subgoal):\n 1. \\<rho> x = None &&& \\<tau> x = None", "using dom"], ["proof (prove)\nusing this:\n  x \\<notin> dom \\<tau>\n  dom \\<tau> = vars_term t \\<union> dom \\<sigma>\n  dom \\<rho> = vars_term t \\<union> dom \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<rho> x = None &&& \\<tau> x = None", "by auto"], ["proof (state)\nthis:\n  \\<rho> x = None\n  \\<tau> x = None\n\ngoal (1 subgoal):\n 1. x \\<notin> dom \\<tau> \\<Longrightarrow> \\<rho> x = \\<tau> x", "then"], ["proof (chain)\npicking this:\n  \\<rho> x = None\n  \\<tau> x = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<rho> x = None\n  \\<tau> x = None\n\ngoal (1 subgoal):\n 1. \\<rho> x = \\<tau> x", "by simp"], ["proof (state)\nthis:\n  \\<rho> x = \\<tau> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<rho> x = \\<tau> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subsumes_list_alt:\n  \"subsumes_list Ls Ks \\<sigma> \\<longleftrightarrow> subsumes_list_modulo Ls Ks \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes_list Ls Ks \\<sigma> = subsumes_list_modulo Ls Ks \\<sigma>", "proof (induction Ls Ks \\<sigma> rule: subsumes_list.induct[case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ks \\<sigma>.\n       subsumes_list [] Ks \\<sigma> = subsumes_list_modulo [] Ks \\<sigma>\n 2. \\<And>L Ls Ks \\<sigma>.\n       (\\<And>x x2.\n           \\<lbrakk>x \\<in> set Ks;\n            match_term_list [(atm_of L, atm_of x)] \\<sigma> =\n            Some x2\\<rbrakk>\n           \\<Longrightarrow> subsumes_list Ls (remove1 x Ks) x2 =\n                             subsumes_list_modulo Ls (remove1 x Ks)\n                              x2) \\<Longrightarrow>\n       subsumes_list (L # Ls) Ks \\<sigma> =\n       subsumes_list_modulo (L # Ls) Ks \\<sigma>", "case (Cons L Ls Ks \\<sigma>)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set Ks;\n   match_term_list [(atm_of L, atm_of ?x)] \\<sigma> = Some ?x2.0\\<rbrakk>\n  \\<Longrightarrow> subsumes_list Ls (remove1 ?x Ks) ?x2.0 =\n                    subsumes_list_modulo Ls (remove1 ?x Ks) ?x2.0\n\ngoal (2 subgoals):\n 1. \\<And>Ks \\<sigma>.\n       subsumes_list [] Ks \\<sigma> = subsumes_list_modulo [] Ks \\<sigma>\n 2. \\<And>L Ls Ks \\<sigma>.\n       (\\<And>x x2.\n           \\<lbrakk>x \\<in> set Ks;\n            match_term_list [(atm_of L, atm_of x)] \\<sigma> =\n            Some x2\\<rbrakk>\n           \\<Longrightarrow> subsumes_list Ls (remove1 x Ks) x2 =\n                             subsumes_list_modulo Ls (remove1 x Ks)\n                              x2) \\<Longrightarrow>\n       subsumes_list (L # Ls) Ks \\<sigma> =\n       subsumes_list_modulo (L # Ls) Ks \\<sigma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes_list (L # Ls) Ks \\<sigma> =\n    subsumes_list_modulo (L # Ls) Ks \\<sigma>", "unfolding subsumes_list_modulo_Cons subsumes_list.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>K\\<in>set Ks.\n        is_pos K = is_pos L \\<and>\n        (case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n         None \\<Rightarrow> False\n         | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x)) =\n    (\\<exists>K\\<in>set Ks.\n        \\<exists>\\<tau>.\n           extends_subst \\<sigma> \\<tau> \\<and>\n           dom \\<tau> = vars_lit L \\<union> dom \\<sigma> \\<and>\n           L \\<cdot>lit subst_of_map Var \\<tau> = K \\<and>\n           subsumes_list_modulo Ls (remove1 K Ks) \\<tau>)", "proof ((intro bex_cong[OF refl] ext iffI; elim exE conjE), goal_cases LR RL)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>K \\<in> set Ks; is_pos K = is_pos L;\n        case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n        None \\<Rightarrow> False\n        | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            extends_subst \\<sigma> \\<tau> \\<and>\n                            dom \\<tau> =\n                            vars_lit L \\<union> dom \\<sigma> \\<and>\n                            L \\<cdot>lit subst_of_map Var \\<tau> = K \\<and>\n                            subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\n 2. \\<And>K \\<tau>.\n       \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        L \\<cdot>lit subst_of_map Var \\<tau> = K;\n        subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                         (case match_term_list [(atm_of L, atm_of K)]\n                                \\<sigma> of\n                          None \\<Rightarrow> False\n                          | Some x \\<Rightarrow>\n                              subsumes_list Ls (remove1 K Ks) x)", "case (LR K)"], ["proof (state)\nthis:\n  K \\<in> set Ks\n  is_pos K = is_pos L\n  case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n  None \\<Rightarrow> False\n  | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x\n\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>K \\<in> set Ks; is_pos K = is_pos L;\n        case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n        None \\<Rightarrow> False\n        | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>.\n                            extends_subst \\<sigma> \\<tau> \\<and>\n                            dom \\<tau> =\n                            vars_lit L \\<union> dom \\<sigma> \\<and>\n                            L \\<cdot>lit subst_of_map Var \\<tau> = K \\<and>\n                            subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\n 2. \\<And>K \\<tau>.\n       \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        L \\<cdot>lit subst_of_map Var \\<tau> = K;\n        subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                         (case match_term_list [(atm_of L, atm_of K)]\n                                \\<sigma> of\n                          None \\<Rightarrow> False\n                          | Some x \\<Rightarrow>\n                              subsumes_list Ls (remove1 K Ks) x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>.\n       extends_subst \\<sigma> \\<tau> \\<and>\n       dom \\<tau> = vars_lit L \\<union> dom \\<sigma> \\<and>\n       L \\<cdot>lit subst_of_map Var \\<tau> = K \\<and>\n       subsumes_list_modulo Ls (remove1 K Ks) \\<tau>", "by (insert LR; cases K; cases L; auto simp: Cons.IH split: option.splits dest!: match_term_list_sound)"], ["proof (state)\nthis:\n  \\<exists>\\<tau>.\n     extends_subst \\<sigma> \\<tau> \\<and>\n     dom \\<tau> = vars_lit L \\<union> dom \\<sigma> \\<and>\n     L \\<cdot>lit subst_of_map Var \\<tau> = K \\<and>\n     subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>K \\<tau>.\n       \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        L \\<cdot>lit subst_of_map Var \\<tau> = K;\n        subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                         (case match_term_list [(atm_of L, atm_of K)]\n                                \\<sigma> of\n                          None \\<Rightarrow> False\n                          | Some x \\<Rightarrow>\n                              subsumes_list Ls (remove1 K Ks) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>K \\<tau>.\n       \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        L \\<cdot>lit subst_of_map Var \\<tau> = K;\n        subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                         (case match_term_list [(atm_of L, atm_of K)]\n                                \\<sigma> of\n                          None \\<Rightarrow> False\n                          | Some x \\<Rightarrow>\n                              subsumes_list Ls (remove1 K Ks) x)", "case (RL K \\<tau>)"], ["proof (state)\nthis:\n  K \\<in> set Ks\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> = vars_lit L \\<union> dom \\<sigma>\n  L \\<cdot>lit subst_of_map Var \\<tau> = K\n  subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>K \\<tau>.\n       \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        L \\<cdot>lit subst_of_map Var \\<tau> = K;\n        subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                         (case match_term_list [(atm_of L, atm_of K)]\n                                \\<sigma> of\n                          None \\<Rightarrow> False\n                          | Some x \\<Rightarrow>\n                              subsumes_list Ls (remove1 K Ks) x)", "then"], ["proof (chain)\npicking this:\n  K \\<in> set Ks\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> = vars_lit L \\<union> dom \\<sigma>\n  L \\<cdot>lit subst_of_map Var \\<tau> = K\n  subsumes_list_modulo Ls (remove1 K Ks) \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  K \\<in> set Ks\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> = vars_lit L \\<union> dom \\<sigma>\n  L \\<cdot>lit subst_of_map Var \\<tau> = K\n  subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\n\ngoal (1 subgoal):\n 1. is_pos K = is_pos L \\<and>\n    (case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n     None \\<Rightarrow> False\n     | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x)", "proof (cases \"match_term_list [(atm_of L, atm_of K)] \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n     dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n     L \\<cdot>lit subst_of_map Var \\<tau> = K;\n     subsumes_list_modulo Ls (remove1 K Ks) \\<tau>;\n     match_term_list [(atm_of L, atm_of K)] \\<sigma> = None\\<rbrakk>\n    \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                      (case match_term_list [(atm_of L, atm_of K)]\n                             \\<sigma> of\n                       None \\<Rightarrow> False\n                       | Some x \\<Rightarrow>\n                           subsumes_list Ls (remove1 K Ks) x)\n 2. \\<And>a.\n       \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        L \\<cdot>lit subst_of_map Var \\<tau> = K;\n        subsumes_list_modulo Ls (remove1 K Ks) \\<tau>;\n        match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some a\\<rbrakk>\n       \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                         (case match_term_list [(atm_of L, atm_of K)]\n                                \\<sigma> of\n                          None \\<Rightarrow> False\n                          | Some x \\<Rightarrow>\n                              subsumes_list Ls (remove1 K Ks) x)", "case None"], ["proof (state)\nthis:\n  match_term_list [(atm_of L, atm_of K)] \\<sigma> = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n     dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n     L \\<cdot>lit subst_of_map Var \\<tau> = K;\n     subsumes_list_modulo Ls (remove1 K Ks) \\<tau>;\n     match_term_list [(atm_of L, atm_of K)] \\<sigma> = None\\<rbrakk>\n    \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                      (case match_term_list [(atm_of L, atm_of K)]\n                             \\<sigma> of\n                       None \\<Rightarrow> False\n                       | Some x \\<Rightarrow>\n                           subsumes_list Ls (remove1 K Ks) x)\n 2. \\<And>a.\n       \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        L \\<cdot>lit subst_of_map Var \\<tau> = K;\n        subsumes_list_modulo Ls (remove1 K Ks) \\<tau>;\n        match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some a\\<rbrakk>\n       \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                         (case match_term_list [(atm_of L, atm_of K)]\n                                \\<sigma> of\n                          None \\<Rightarrow> False\n                          | Some x \\<Rightarrow>\n                              subsumes_list Ls (remove1 K Ks) x)", "with RL"], ["proof (chain)\npicking this:\n  K \\<in> set Ks\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> = vars_lit L \\<union> dom \\<sigma>\n  L \\<cdot>lit subst_of_map Var \\<tau> = K\n  subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\n  match_term_list [(atm_of L, atm_of K)] \\<sigma> = None", "show ?thesis"], ["proof (prove)\nusing this:\n  K \\<in> set Ks\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> = vars_lit L \\<union> dom \\<sigma>\n  L \\<cdot>lit subst_of_map Var \\<tau> = K\n  subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\n  match_term_list [(atm_of L, atm_of K)] \\<sigma> = None\n\ngoal (1 subgoal):\n 1. is_pos K = is_pos L \\<and>\n    (case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n     None \\<Rightarrow> False\n     | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x)", "by (auto simp: Cons.IH dest!: match_term_list_complete)"], ["proof (state)\nthis:\n  is_pos K = is_pos L \\<and>\n  (case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n   None \\<Rightarrow> False\n   | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        L \\<cdot>lit subst_of_map Var \\<tau> = K;\n        subsumes_list_modulo Ls (remove1 K Ks) \\<tau>;\n        match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some a\\<rbrakk>\n       \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                         (case match_term_list [(atm_of L, atm_of K)]\n                                \\<sigma> of\n                          None \\<Rightarrow> False\n                          | Some x \\<Rightarrow>\n                              subsumes_list Ls (remove1 K Ks) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        L \\<cdot>lit subst_of_map Var \\<tau> = K;\n        subsumes_list_modulo Ls (remove1 K Ks) \\<tau>;\n        match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some a\\<rbrakk>\n       \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                         (case match_term_list [(atm_of L, atm_of K)]\n                                \\<sigma> of\n                          None \\<Rightarrow> False\n                          | Some x \\<Rightarrow>\n                              subsumes_list Ls (remove1 K Ks) x)", "case (Some \\<tau>')"], ["proof (state)\nthis:\n  match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>K \\<in> set Ks; extends_subst \\<sigma> \\<tau>;\n        dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n        L \\<cdot>lit subst_of_map Var \\<tau> = K;\n        subsumes_list_modulo Ls (remove1 K Ks) \\<tau>;\n        match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some a\\<rbrakk>\n       \\<Longrightarrow> is_pos K = is_pos L \\<and>\n                         (case match_term_list [(atm_of L, atm_of K)]\n                                \\<sigma> of\n                          None \\<Rightarrow> False\n                          | Some x \\<Rightarrow>\n                              subsumes_list Ls (remove1 K Ks) x)", "with RL"], ["proof (chain)\npicking this:\n  K \\<in> set Ks\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> = vars_lit L \\<union> dom \\<sigma>\n  L \\<cdot>lit subst_of_map Var \\<tau> = K\n  subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\n  match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>'", "show ?thesis"], ["proof (prove)\nusing this:\n  K \\<in> set Ks\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> = vars_lit L \\<union> dom \\<sigma>\n  L \\<cdot>lit subst_of_map Var \\<tau> = K\n  subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\n  match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>'\n\ngoal (1 subgoal):\n 1. is_pos K = is_pos L \\<and>\n    (case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n     None \\<Rightarrow> False\n     | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x)", "using unique_extends_subst[of \\<sigma> \\<tau> \\<tau>' \"atm_of L\"]"], ["proof (prove)\nusing this:\n  K \\<in> set Ks\n  extends_subst \\<sigma> \\<tau>\n  dom \\<tau> = vars_lit L \\<union> dom \\<sigma>\n  L \\<cdot>lit subst_of_map Var \\<tau> = K\n  subsumes_list_modulo Ls (remove1 K Ks) \\<tau>\n  match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>'\n  \\<lbrakk>extends_subst \\<sigma> \\<tau>; extends_subst \\<sigma> \\<tau>';\n   dom \\<tau> = vars_lit L \\<union> dom \\<sigma>;\n   dom \\<tau>' = vars_lit L \\<union> dom \\<sigma>;\n   subst_atm_abbrev (atm_of L) (subst_of_map Var \\<tau>') =\n   subst_atm_abbrev (atm_of L) (subst_of_map Var \\<tau>)\\<rbrakk>\n  \\<Longrightarrow> \\<tau>' = \\<tau>\n\ngoal (1 subgoal):\n 1. is_pos K = is_pos L \\<and>\n    (case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n     None \\<Rightarrow> False\n     | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x)", "by (auto simp: Cons.IH dest!: match_term_list_sound)"], ["proof (state)\nthis:\n  is_pos K = is_pos L \\<and>\n  (case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n   None \\<Rightarrow> False\n   | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_pos K = is_pos L \\<and>\n  (case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n   None \\<Rightarrow> False\n   | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subsumes_list (L # Ls) Ks \\<sigma> =\n  subsumes_list_modulo (L # Ls) Ks \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>Ks \\<sigma>.\n       subsumes_list [] Ks \\<sigma> = subsumes_list_modulo [] Ks \\<sigma>", "qed (auto simp: subsumes_modulo_def subst_cls_def vars_clause_def intro: extends_subst_refl)"], ["", "lemma subsumes_subsumes_list[code_unfold]:\n  \"subsumes (mset Ls) (mset Ks) = subsumes_list Ls Ks Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes (mset Ls) (mset Ks) = subsumes_list Ls Ks Map.empty", "unfolding subsumes_list_alt[of Ls Ks Map.empty]"], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes (mset Ls) (mset Ks) = subsumes_list_modulo Ls Ks Map.empty", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. subsumes (mset Ls) (mset Ks) \\<Longrightarrow>\n    subsumes_list_modulo Ls Ks Map.empty\n 2. subsumes_list_modulo Ls Ks Map.empty \\<Longrightarrow>\n    subsumes (mset Ls) (mset Ks)", "assume \"subsumes (mset Ls) (mset Ks)\""], ["proof (state)\nthis:\n  subsumes (mset Ls) (mset Ks)\n\ngoal (2 subgoals):\n 1. subsumes (mset Ls) (mset Ks) \\<Longrightarrow>\n    subsumes_list_modulo Ls Ks Map.empty\n 2. subsumes_list_modulo Ls Ks Map.empty \\<Longrightarrow>\n    subsumes (mset Ls) (mset Ks)", "then"], ["proof (chain)\npicking this:\n  subsumes (mset Ls) (mset Ks)", "obtain \\<sigma> where \"subst_cls (mset Ls) \\<sigma> \\<subseteq># mset Ks\""], ["proof (prove)\nusing this:\n  subsumes (mset Ls) (mset Ks)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        subst_cls (mset Ls) \\<sigma> \\<subseteq># mset Ks \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding subsumes_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>. subst_cls (mset Ls) \\<sigma> \\<subseteq># mset Ks\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        subst_cls (mset Ls) \\<sigma> \\<subseteq># mset Ks \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  subst_cls (mset Ls) \\<sigma> \\<subseteq># mset Ks\n\ngoal (2 subgoals):\n 1. subsumes (mset Ls) (mset Ks) \\<Longrightarrow>\n    subsumes_list_modulo Ls Ks Map.empty\n 2. subsumes_list_modulo Ls Ks Map.empty \\<Longrightarrow>\n    subsumes (mset Ls) (mset Ks)", "moreover"], ["proof (state)\nthis:\n  subst_cls (mset Ls) \\<sigma> \\<subseteq># mset Ks\n\ngoal (2 subgoals):\n 1. subsumes (mset Ls) (mset Ks) \\<Longrightarrow>\n    subsumes_list_modulo Ls Ks Map.empty\n 2. subsumes_list_modulo Ls Ks Map.empty \\<Longrightarrow>\n    subsumes (mset Ls) (mset Ks)", "define \\<tau> where \"\\<tau> = (\\<lambda>x. if x \\<in> vars_clause (mset Ls) then Some (\\<sigma> x) else None)\""], ["proof (state)\nthis:\n  \\<tau> =\n  (\\<lambda>x.\n      if x \\<in> vars_clause (mset Ls) then Some (\\<sigma> x) else None)\n\ngoal (2 subgoals):\n 1. subsumes (mset Ls) (mset Ks) \\<Longrightarrow>\n    subsumes_list_modulo Ls Ks Map.empty\n 2. subsumes_list_modulo Ls Ks Map.empty \\<Longrightarrow>\n    subsumes (mset Ls) (mset Ks)", "ultimately"], ["proof (chain)\npicking this:\n  subst_cls (mset Ls) \\<sigma> \\<subseteq># mset Ks\n  \\<tau> =\n  (\\<lambda>x.\n      if x \\<in> vars_clause (mset Ls) then Some (\\<sigma> x) else None)", "show \"subsumes_list_modulo Ls Ks Map.empty\""], ["proof (prove)\nusing this:\n  subst_cls (mset Ls) \\<sigma> \\<subseteq># mset Ks\n  \\<tau> =\n  (\\<lambda>x.\n      if x \\<in> vars_clause (mset Ls) then Some (\\<sigma> x) else None)\n\ngoal (1 subgoal):\n 1. subsumes_list_modulo Ls Ks Map.empty", "unfolding subsumes_modulo_def"], ["proof (prove)\nusing this:\n  subst_cls (mset Ls) \\<sigma> \\<subseteq># mset Ks\n  \\<tau> =\n  (\\<lambda>x.\n      if x \\<in> vars_clause (mset Ls) then Some (\\<sigma> x) else None)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>.\n       dom \\<tau> = vars_clause (mset Ls) \\<union> dom Map.empty \\<and>\n       extends_subst Map.empty \\<tau> \\<and>\n       subst_cls (mset Ls) (subst_of_map Var \\<tau>) \\<subseteq># mset Ks", "by (subst (asm) same_on_vars_clause[of _ \\<sigma> \"subst_of_map Var \\<tau>\"])\n      (auto intro!: exI[of _ \\<tau>] simp: subst_of_map_def[abs_def] split: if_splits)"], ["proof (state)\nthis:\n  subsumes_list_modulo Ls Ks Map.empty\n\ngoal (1 subgoal):\n 1. subsumes_list_modulo Ls Ks Map.empty \\<Longrightarrow>\n    subsumes (mset Ls) (mset Ks)", "qed (auto simp: subsumes_modulo_def subst_lit_def subsumes_def)"], ["", "lemma strictly_subsumes_subsumes_list[code_unfold]:\n  \"strictly_subsumes (mset Ls) (mset Ks) =\n    (subsumes_list Ls Ks Map.empty \\<and> \\<not> subsumes_list Ks Ls Map.empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_subsumes (mset Ls) (mset Ks) =\n    (subsumes_list Ls Ks Map.empty \\<and>\n     \\<not> subsumes_list Ks Ls Map.empty)", "unfolding strictly_subsumes_def subsumes_subsumes_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. (subsumes_list Ls Ks Map.empty \\<and>\n     \\<not> subsumes_list Ks Ls Map.empty) =\n    (subsumes_list Ls Ks Map.empty \\<and>\n     \\<not> subsumes_list Ks Ls Map.empty)", "by simp"], ["", "lemma subsumes_list_filterD: \"subsumes_list Ls (filter P Ks) \\<sigma> \\<Longrightarrow> subsumes_list Ls Ks \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes_list Ls (filter P Ks) \\<sigma> \\<Longrightarrow>\n    subsumes_list Ls Ks \\<sigma>", "proof (induction Ls arbitrary: Ks \\<sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ks \\<sigma>.\n       subsumes_list [] (filter P Ks) \\<sigma> \\<Longrightarrow>\n       subsumes_list [] Ks \\<sigma>\n 2. \\<And>a Ls Ks \\<sigma>.\n       \\<lbrakk>\\<And>Ks \\<sigma>.\n                   subsumes_list Ls (filter P Ks) \\<sigma> \\<Longrightarrow>\n                   subsumes_list Ls Ks \\<sigma>;\n        subsumes_list (a # Ls) (filter P Ks) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> subsumes_list (a # Ls) Ks \\<sigma>", "case (Cons L Ls)"], ["proof (state)\nthis:\n  subsumes_list Ls (filter P ?Ks) ?\\<sigma> \\<Longrightarrow>\n  subsumes_list Ls ?Ks ?\\<sigma>\n  subsumes_list (L # Ls) (filter P Ks) \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>Ks \\<sigma>.\n       subsumes_list [] (filter P Ks) \\<sigma> \\<Longrightarrow>\n       subsumes_list [] Ks \\<sigma>\n 2. \\<And>a Ls Ks \\<sigma>.\n       \\<lbrakk>\\<And>Ks \\<sigma>.\n                   subsumes_list Ls (filter P Ks) \\<sigma> \\<Longrightarrow>\n                   subsumes_list Ls Ks \\<sigma>;\n        subsumes_list (a # Ls) (filter P Ks) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> subsumes_list (a # Ls) Ks \\<sigma>", "from Cons.prems"], ["proof (chain)\npicking this:\n  subsumes_list (L # Ls) (filter P Ks) \\<sigma>", "show ?case"], ["proof (prove)\nusing this:\n  subsumes_list (L # Ls) (filter P Ks) \\<sigma>\n\ngoal (1 subgoal):\n 1. subsumes_list (L # Ls) Ks \\<sigma>", "by (auto dest!: Cons.IH simp: filter_remove1[symmetric] split: option.splits)"], ["proof (state)\nthis:\n  subsumes_list (L # Ls) Ks \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>Ks \\<sigma>.\n       subsumes_list [] (filter P Ks) \\<sigma> \\<Longrightarrow>\n       subsumes_list [] Ks \\<sigma>", "qed simp"], ["", "lemma subsumes_list_filterI:\n  assumes match: \"(\\<And>L K \\<sigma> \\<tau>. L \\<in> set Ls \\<Longrightarrow>\n    match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau> \\<Longrightarrow> is_pos L = is_pos K \\<Longrightarrow> P K)\"\n  shows \"subsumes_list Ls Ks \\<sigma> \\<Longrightarrow> subsumes_list Ls (filter P Ks) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes_list Ls Ks \\<sigma> \\<Longrightarrow>\n    subsumes_list Ls (filter P Ks) \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?L \\<in> set Ls;\n   match_term_list [(atm_of ?L, atm_of ?K)] ?\\<sigma> = Some ?\\<tau>;\n   is_pos ?L = is_pos ?K\\<rbrakk>\n  \\<Longrightarrow> P ?K\n\ngoal (1 subgoal):\n 1. subsumes_list Ls Ks \\<sigma> \\<Longrightarrow>\n    subsumes_list Ls (filter P Ks) \\<sigma>", "proof (induction Ls Ks \\<sigma> rule: subsumes_list.induct[case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ks \\<sigma>.\n       \\<lbrakk>subsumes_list [] Ks \\<sigma>;\n        \\<And>L K \\<sigma> \\<tau>.\n           \\<lbrakk>L \\<in> set [];\n            match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>;\n            is_pos L = is_pos K\\<rbrakk>\n           \\<Longrightarrow> P K\\<rbrakk>\n       \\<Longrightarrow> subsumes_list [] (filter P Ks) \\<sigma>\n 2. \\<And>L Ls Ks \\<sigma>.\n       \\<lbrakk>\\<And>x x2.\n                   \\<lbrakk>x \\<in> set Ks;\n                    match_term_list [(atm_of L, atm_of x)] \\<sigma> =\n                    Some x2;\n                    subsumes_list Ls (remove1 x Ks) x2;\n                    \\<And>L K \\<sigma> \\<tau>.\n                       \\<lbrakk>L \\<in> set Ls;\n                        match_term_list [(atm_of L, atm_of K)] \\<sigma> =\n                        Some \\<tau>;\n                        is_pos L = is_pos K\\<rbrakk>\n                       \\<Longrightarrow> P K\\<rbrakk>\n                   \\<Longrightarrow> subsumes_list Ls\n(filter P (remove1 x Ks)) x2;\n        subsumes_list (L # Ls) Ks \\<sigma>;\n        \\<And>La K \\<sigma> \\<tau>.\n           \\<lbrakk>La \\<in> set (L # Ls);\n            match_term_list [(atm_of La, atm_of K)] \\<sigma> = Some \\<tau>;\n            is_pos La = is_pos K\\<rbrakk>\n           \\<Longrightarrow> P K\\<rbrakk>\n       \\<Longrightarrow> subsumes_list (L # Ls) (filter P Ks) \\<sigma>", "case (Cons L Ls Ks \\<sigma>)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set Ks;\n   match_term_list [(atm_of L, atm_of ?x)] \\<sigma> = Some ?x2.0;\n   subsumes_list Ls (remove1 ?x Ks) ?x2.0;\n   \\<And>L K \\<sigma> \\<tau>.\n      \\<lbrakk>L \\<in> set Ls;\n       match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>;\n       is_pos L = is_pos K\\<rbrakk>\n      \\<Longrightarrow> P K\\<rbrakk>\n  \\<Longrightarrow> subsumes_list Ls (filter P (remove1 ?x Ks)) ?x2.0\n  subsumes_list (L # Ls) Ks \\<sigma>\n  \\<lbrakk>?L \\<in> set (L # Ls);\n   match_term_list [(atm_of ?L, atm_of ?K)] ?\\<sigma> = Some ?\\<tau>;\n   is_pos ?L = is_pos ?K\\<rbrakk>\n  \\<Longrightarrow> P ?K\n\ngoal (2 subgoals):\n 1. \\<And>Ks \\<sigma>.\n       \\<lbrakk>subsumes_list [] Ks \\<sigma>;\n        \\<And>L K \\<sigma> \\<tau>.\n           \\<lbrakk>L \\<in> set [];\n            match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>;\n            is_pos L = is_pos K\\<rbrakk>\n           \\<Longrightarrow> P K\\<rbrakk>\n       \\<Longrightarrow> subsumes_list [] (filter P Ks) \\<sigma>\n 2. \\<And>L Ls Ks \\<sigma>.\n       \\<lbrakk>\\<And>x x2.\n                   \\<lbrakk>x \\<in> set Ks;\n                    match_term_list [(atm_of L, atm_of x)] \\<sigma> =\n                    Some x2;\n                    subsumes_list Ls (remove1 x Ks) x2;\n                    \\<And>L K \\<sigma> \\<tau>.\n                       \\<lbrakk>L \\<in> set Ls;\n                        match_term_list [(atm_of L, atm_of K)] \\<sigma> =\n                        Some \\<tau>;\n                        is_pos L = is_pos K\\<rbrakk>\n                       \\<Longrightarrow> P K\\<rbrakk>\n                   \\<Longrightarrow> subsumes_list Ls\n(filter P (remove1 x Ks)) x2;\n        subsumes_list (L # Ls) Ks \\<sigma>;\n        \\<And>La K \\<sigma> \\<tau>.\n           \\<lbrakk>La \\<in> set (L # Ls);\n            match_term_list [(atm_of La, atm_of K)] \\<sigma> = Some \\<tau>;\n            is_pos La = is_pos K\\<rbrakk>\n           \\<Longrightarrow> P K\\<rbrakk>\n       \\<Longrightarrow> subsumes_list (L # Ls) (filter P Ks) \\<sigma>", "from Cons.prems"], ["proof (chain)\npicking this:\n  subsumes_list (L # Ls) Ks \\<sigma>\n  \\<lbrakk>?L \\<in> set (L # Ls);\n   match_term_list [(atm_of ?L, atm_of ?K)] ?\\<sigma> = Some ?\\<tau>;\n   is_pos ?L = is_pos ?K\\<rbrakk>\n  \\<Longrightarrow> P ?K", "show ?case"], ["proof (prove)\nusing this:\n  subsumes_list (L # Ls) Ks \\<sigma>\n  \\<lbrakk>?L \\<in> set (L # Ls);\n   match_term_list [(atm_of ?L, atm_of ?K)] ?\\<sigma> = Some ?\\<tau>;\n   is_pos ?L = is_pos ?K\\<rbrakk>\n  \\<Longrightarrow> P ?K\n\ngoal (1 subgoal):\n 1. subsumes_list (L # Ls) (filter P Ks) \\<sigma>", "unfolding subsumes_list.simps set_filter bex_simps conj_assoc"], ["proof (prove)\nusing this:\n  \\<exists>K\\<in>set Ks.\n     is_pos K = is_pos L \\<and>\n     (case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n      None \\<Rightarrow> False\n      | Some x \\<Rightarrow> subsumes_list Ls (remove1 K Ks) x)\n  \\<lbrakk>?L \\<in> set (L # Ls);\n   match_term_list [(atm_of ?L, atm_of ?K)] ?\\<sigma> = Some ?\\<tau>;\n   is_pos ?L = is_pos ?K\\<rbrakk>\n  \\<Longrightarrow> P ?K\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> set Ks \\<and>\n       P x \\<and>\n       is_pos x = is_pos L \\<and>\n       (case match_term_list [(atm_of L, atm_of x)] \\<sigma> of\n        None \\<Rightarrow> False\n        | Some xa \\<Rightarrow>\n            subsumes_list Ls (remove1 x (filter P Ks)) xa)", "by (elim bexE conjE)\n      (rule exI, rule conjI, assumption,\n        auto split: option.splits simp: filter_remove1[symmetric] intro!: Cons.IH)"], ["proof (state)\nthis:\n  subsumes_list (L # Ls) (filter P Ks) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>Ks \\<sigma>.\n       \\<lbrakk>subsumes_list [] Ks \\<sigma>;\n        \\<And>L K \\<sigma> \\<tau>.\n           \\<lbrakk>L \\<in> set [];\n            match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>;\n            is_pos L = is_pos K\\<rbrakk>\n           \\<Longrightarrow> P K\\<rbrakk>\n       \\<Longrightarrow> subsumes_list [] (filter P Ks) \\<sigma>", "qed simp"], ["", "lemma subsumes_list_Cons_filter_iff:\n  assumes sorted_wrt: \"sorted_wrt leq (L # Ls)\" and trans: \"transp leq\"\n  and match: \"(\\<And>L K \\<sigma> \\<tau>.\n    match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau> \\<Longrightarrow> is_pos L = is_pos K \\<Longrightarrow> leq L K)\"\nshows \"subsumes_list (L # Ls) (filter (leq L) Ks) \\<sigma> \\<longleftrightarrow> subsumes_list (L # Ls) Ks \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes_list (L # Ls) (filter (leq L) Ks) \\<sigma> =\n    subsumes_list (L # Ls) Ks \\<sigma>", "apply (rule iffI[OF subsumes_list_filterD subsumes_list_filterI]; assumption?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>La K \\<sigma>' \\<tau>.\n       \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>; La \\<in> set (L # Ls);\n        match_term_list [(atm_of La, atm_of K)] \\<sigma>' = Some \\<tau>;\n        is_pos La = is_pos K\\<rbrakk>\n       \\<Longrightarrow> leq L K", "unfolding list.set insert_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>La K \\<sigma>' \\<tau>.\n       \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>;\n        La = L \\<or> La \\<in> set Ls;\n        match_term_list [(atm_of La, atm_of K)] \\<sigma>' = Some \\<tau>;\n        is_pos La = is_pos K\\<rbrakk>\n       \\<Longrightarrow> leq L K", "apply (elim disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>La K \\<sigma>' \\<tau>.\n       \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>;\n        match_term_list [(atm_of La, atm_of K)] \\<sigma>' = Some \\<tau>;\n        is_pos La = is_pos K; La = L\\<rbrakk>\n       \\<Longrightarrow> leq L K\n 2. \\<And>La K \\<sigma>' \\<tau>.\n       \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>;\n        match_term_list [(atm_of La, atm_of K)] \\<sigma>' = Some \\<tau>;\n        is_pos La = is_pos K; La \\<in> set Ls\\<rbrakk>\n       \\<Longrightarrow> leq L K", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>;\n     match_term_list [(atm_of La_, atm_of K_)] \\<sigma>'_ = Some \\<tau>_;\n     is_pos La_ = is_pos K_; La_ = L\\<rbrakk>\n    \\<Longrightarrow> leq L K_", "by (auto split: option.splits elim!: match)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>La K \\<sigma>' \\<tau>.\n       \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>;\n        match_term_list [(atm_of La, atm_of K)] \\<sigma>' = Some \\<tau>;\n        is_pos La = is_pos K; La \\<in> set Ls\\<rbrakk>\n       \\<Longrightarrow> leq L K", "subgoal for L K \\<sigma> \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>;\n     match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>;\n     is_pos L = is_pos K; L \\<in> set Ls\\<rbrakk>\n    \\<Longrightarrow> leq L K", "using sorted_wrt"], ["proof (prove)\nusing this:\n  sorted_wrt leq (L # Ls)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>;\n     match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>;\n     is_pos L = is_pos K; L \\<in> set Ls\\<rbrakk>\n    \\<Longrightarrow> leq L K", "unfolding List.sorted_wrt.simps(2)"], ["proof (prove)\nusing this:\n  Ball (set Ls) (leq L) \\<and> sorted_wrt leq Ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>;\n     match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>;\n     is_pos L = is_pos K; L \\<in> set Ls\\<rbrakk>\n    \\<Longrightarrow> leq L K", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>;\n     match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>;\n     is_pos L = is_pos K; L \\<in> set Ls; Ball (set Ls) (leq L);\n     sorted_wrt leq Ls\\<rbrakk>\n    \\<Longrightarrow> leq L K", "apply (drule bspec, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>;\n     match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>;\n     is_pos L = is_pos K; L \\<in> set Ls; sorted_wrt leq Ls;\n     leq L L\\<rbrakk>\n    \\<Longrightarrow> leq L K", "apply (erule transpD[OF trans])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>;\n     match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>;\n     is_pos L = is_pos K; L \\<in> set Ls; sorted_wrt leq Ls\\<rbrakk>\n    \\<Longrightarrow> leq L K", "apply (erule match)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subsumes_list (L # Ls) Ks \\<sigma>; is_pos L = is_pos K;\n     L \\<in> set Ls; sorted_wrt leq Ls\\<rbrakk>\n    \\<Longrightarrow> is_pos L = is_pos K", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition leq_head  :: \"('f::linorder, 'v) term \\<Rightarrow> ('f, 'v) term \\<Rightarrow> bool\" where\n  \"leq_head t u = (case (root t, root u) of\n    (None, _) \\<Rightarrow> True\n  | (_, None) \\<Rightarrow> False\n  | (Some f, Some g) \\<Rightarrow> f \\<le> g)\""], ["", "definition \"leq_lit L K = (case (K, L) of\n    (Neg _, Pos _) \\<Rightarrow> True\n  | (Pos _, Neg _) \\<Rightarrow> False\n  | _ \\<Rightarrow> leq_head (atm_of L) (atm_of K))\""], ["", "lemma transp_leq_lit[simp]: \"transp leq_lit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp leq_lit", "unfolding transp_def leq_lit_def leq_head_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (case (y, x) of\n        (Pos xa, Pos a) \\<Rightarrow>\n          case (root (atm_of x), root (atm_of y)) of\n          (None, xa) \\<Rightarrow> True | (Some a, None) \\<Rightarrow> False\n          | (Some a, Some x) \\<Rightarrow> a \\<le> x\n        | (Pos xa, Neg xaa) \\<Rightarrow> False\n        | (Neg xa, Pos xaa) \\<Rightarrow> True\n        | (Neg xa, Neg a) \\<Rightarrow>\n            case (root (atm_of x), root (atm_of y)) of\n            (None, xa) \\<Rightarrow> True\n            | (Some a, None) \\<Rightarrow> False\n            | (Some a, Some x) \\<Rightarrow> a \\<le> x) \\<longrightarrow>\n       (case (z, y) of\n        (Pos x, Pos a) \\<Rightarrow>\n          case (root (atm_of y), root (atm_of z)) of\n          (None, xa) \\<Rightarrow> True | (Some a, None) \\<Rightarrow> False\n          | (Some a, Some x) \\<Rightarrow> a \\<le> x\n        | (Pos x, Neg xa) \\<Rightarrow> False\n        | (Neg x, Pos xa) \\<Rightarrow> True\n        | (Neg x, Neg a) \\<Rightarrow>\n            case (root (atm_of y), root (atm_of z)) of\n            (None, xa) \\<Rightarrow> True\n            | (Some a, None) \\<Rightarrow> False\n            | (Some a, Some x) \\<Rightarrow> a \\<le> x) \\<longrightarrow>\n       (case (z, x) of\n        (Pos xa, Pos a) \\<Rightarrow>\n          case (root (atm_of x), root (atm_of z)) of\n          (None, xa) \\<Rightarrow> True | (Some a, None) \\<Rightarrow> False\n          | (Some a, Some x) \\<Rightarrow> a \\<le> x\n        | (Pos xa, Neg xaa) \\<Rightarrow> False\n        | (Neg xa, Pos xaa) \\<Rightarrow> True\n        | (Neg xa, Neg a) \\<Rightarrow>\n            case (root (atm_of x), root (atm_of z)) of\n            (None, xa) \\<Rightarrow> True\n            | (Some a, None) \\<Rightarrow> False\n            | (Some a, Some x) \\<Rightarrow> a \\<le> x)", "by (force split: option.splits literal.splits)"], ["", "lemma reflp_leq_lit[simp]: \"reflp_on leq_lit A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp_on leq_lit A", "unfolding reflp_on_def leq_lit_def leq_head_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>A.\n       case (a, a) of\n       (Pos x, Pos aa) \\<Rightarrow>\n         case (root (atm_of a), root (atm_of a)) of\n         (None, xa) \\<Rightarrow> True | (Some a, None) \\<Rightarrow> False\n         | (Some a, Some x) \\<Rightarrow> a \\<le> x\n       | (Pos x, Neg xa) \\<Rightarrow> False\n       | (Neg x, Pos xa) \\<Rightarrow> True\n       | (Neg x, Neg aa) \\<Rightarrow>\n           case (root (atm_of a), root (atm_of a)) of\n           (None, xa) \\<Rightarrow> True\n           | (Some a, None) \\<Rightarrow> False\n           | (Some a, Some x) \\<Rightarrow> a \\<le> x", "by (auto split: option.splits literal.splits)"], ["", "lemma total_leq_lit[simp]: \"total_on leq_lit A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Restricted_Predicates.total_on leq_lit A", "unfolding total_on_def leq_lit_def leq_head_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A.\n          x = y \\<or>\n          (case (y, x) of\n           (Pos xa, Pos a) \\<Rightarrow>\n             case (root (atm_of x), root (atm_of y)) of\n             (None, xa) \\<Rightarrow> True\n             | (Some a, None) \\<Rightarrow> False\n             | (Some a, Some x) \\<Rightarrow> a \\<le> x\n           | (Pos xa, Neg xaa) \\<Rightarrow> False\n           | (Neg xa, Pos xaa) \\<Rightarrow> True\n           | (Neg xa, Neg a) \\<Rightarrow>\n               case (root (atm_of x), root (atm_of y)) of\n               (None, xa) \\<Rightarrow> True\n               | (Some a, None) \\<Rightarrow> False\n               | (Some a, Some x) \\<Rightarrow> a \\<le> x) \\<or>\n          (case (x, y) of\n           (Pos xa, Pos a) \\<Rightarrow>\n             case (root (atm_of y), root (atm_of x)) of\n             (None, xa) \\<Rightarrow> True\n             | (Some a, None) \\<Rightarrow> False\n             | (Some a, Some x) \\<Rightarrow> a \\<le> x\n           | (Pos xa, Neg xaa) \\<Rightarrow> False\n           | (Neg xa, Pos xaa) \\<Rightarrow> True\n           | (Neg xa, Neg a) \\<Rightarrow>\n               case (root (atm_of y), root (atm_of x)) of\n               (None, xa) \\<Rightarrow> True\n               | (Some a, None) \\<Rightarrow> False\n               | (Some a, Some x) \\<Rightarrow> a \\<le> x)", "by (auto split: option.splits literal.splits)"], ["", "lemma leq_head_subst[simp]: \"leq_head t (t \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leq_head t (subst_atm_abbrev t \\<sigma>)", "by (induct t) (auto simp: leq_head_def)"], ["", "lemma leq_lit_match:\n  fixes L K :: \"('f :: linorder, 'v) term literal\"\n  shows \"match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau> \\<Longrightarrow> is_pos L = is_pos K \\<Longrightarrow> leq_lit L K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match_term_list [(atm_of L, atm_of K)] \\<sigma> = Some \\<tau>;\n     is_pos L = is_pos K\\<rbrakk>\n    \\<Longrightarrow> leq_lit L K", "by (cases L; cases K)\n    (auto simp: leq_lit_def dest!: match_term_list_sound split: option.splits)"], ["", "subsection \\<open>Optimized Implementation of Clause Subsumption\\<close>"], ["", "fun subsumes_list_filter where\n  \"subsumes_list_filter [] Ks \\<sigma> = True\"\n| \"subsumes_list_filter (L # Ls) Ks \\<sigma> =\n     (let Ks = filter (leq_lit L) Ks in\n     (\\<exists>K \\<in> set Ks. is_pos K = is_pos L \\<and>\n       (case match_term_list [(atm_of L, atm_of K)] \\<sigma> of\n         None \\<Rightarrow> False\n       | Some \\<rho> \\<Rightarrow> subsumes_list_filter Ls (remove1 K Ks) \\<rho>)))\""], ["", "lemma sorted_wrt_subsumes_list_subsumes_list_filter:\n  \"sorted_wrt leq_lit Ls \\<Longrightarrow> subsumes_list Ls Ks \\<sigma> = subsumes_list_filter Ls Ks \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt leq_lit Ls \\<Longrightarrow>\n    subsumes_list Ls Ks \\<sigma> = subsumes_list_filter Ls Ks \\<sigma>", "proof (induction Ls arbitrary: Ks \\<sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ks \\<sigma>.\n       sorted_wrt leq_lit [] \\<Longrightarrow>\n       subsumes_list [] Ks \\<sigma> = subsumes_list_filter [] Ks \\<sigma>\n 2. \\<And>a Ls Ks \\<sigma>.\n       \\<lbrakk>\\<And>Ks \\<sigma>.\n                   sorted_wrt leq_lit Ls \\<Longrightarrow>\n                   subsumes_list Ls Ks \\<sigma> =\n                   subsumes_list_filter Ls Ks \\<sigma>;\n        sorted_wrt leq_lit (a # Ls)\\<rbrakk>\n       \\<Longrightarrow> subsumes_list (a # Ls) Ks \\<sigma> =\n                         subsumes_list_filter (a # Ls) Ks \\<sigma>", "case (Cons L Ls)"], ["proof (state)\nthis:\n  sorted_wrt leq_lit Ls \\<Longrightarrow>\n  subsumes_list Ls ?Ks ?\\<sigma> = subsumes_list_filter Ls ?Ks ?\\<sigma>\n  sorted_wrt leq_lit (L # Ls)\n\ngoal (2 subgoals):\n 1. \\<And>Ks \\<sigma>.\n       sorted_wrt leq_lit [] \\<Longrightarrow>\n       subsumes_list [] Ks \\<sigma> = subsumes_list_filter [] Ks \\<sigma>\n 2. \\<And>a Ls Ks \\<sigma>.\n       \\<lbrakk>\\<And>Ks \\<sigma>.\n                   sorted_wrt leq_lit Ls \\<Longrightarrow>\n                   subsumes_list Ls Ks \\<sigma> =\n                   subsumes_list_filter Ls Ks \\<sigma>;\n        sorted_wrt leq_lit (a # Ls)\\<rbrakk>\n       \\<Longrightarrow> subsumes_list (a # Ls) Ks \\<sigma> =\n                         subsumes_list_filter (a # Ls) Ks \\<sigma>", "from Cons.prems"], ["proof (chain)\npicking this:\n  sorted_wrt leq_lit (L # Ls)", "have \"subsumes_list (L # Ls) Ks \\<sigma> = subsumes_list (L # Ls) (filter (leq_lit L) Ks) \\<sigma>\""], ["proof (prove)\nusing this:\n  sorted_wrt leq_lit (L # Ls)\n\ngoal (1 subgoal):\n 1. subsumes_list (L # Ls) Ks \\<sigma> =\n    subsumes_list (L # Ls) (filter (leq_lit L) Ks) \\<sigma>", "by (intro subsumes_list_Cons_filter_iff[symmetric]) (auto dest: leq_lit_match)"], ["proof (state)\nthis:\n  subsumes_list (L # Ls) Ks \\<sigma> =\n  subsumes_list (L # Ls) (filter (leq_lit L) Ks) \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>Ks \\<sigma>.\n       sorted_wrt leq_lit [] \\<Longrightarrow>\n       subsumes_list [] Ks \\<sigma> = subsumes_list_filter [] Ks \\<sigma>\n 2. \\<And>a Ls Ks \\<sigma>.\n       \\<lbrakk>\\<And>Ks \\<sigma>.\n                   sorted_wrt leq_lit Ls \\<Longrightarrow>\n                   subsumes_list Ls Ks \\<sigma> =\n                   subsumes_list_filter Ls Ks \\<sigma>;\n        sorted_wrt leq_lit (a # Ls)\\<rbrakk>\n       \\<Longrightarrow> subsumes_list (a # Ls) Ks \\<sigma> =\n                         subsumes_list_filter (a # Ls) Ks \\<sigma>", "also"], ["proof (state)\nthis:\n  subsumes_list (L # Ls) Ks \\<sigma> =\n  subsumes_list (L # Ls) (filter (leq_lit L) Ks) \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>Ks \\<sigma>.\n       sorted_wrt leq_lit [] \\<Longrightarrow>\n       subsumes_list [] Ks \\<sigma> = subsumes_list_filter [] Ks \\<sigma>\n 2. \\<And>a Ls Ks \\<sigma>.\n       \\<lbrakk>\\<And>Ks \\<sigma>.\n                   sorted_wrt leq_lit Ls \\<Longrightarrow>\n                   subsumes_list Ls Ks \\<sigma> =\n                   subsumes_list_filter Ls Ks \\<sigma>;\n        sorted_wrt leq_lit (a # Ls)\\<rbrakk>\n       \\<Longrightarrow> subsumes_list (a # Ls) Ks \\<sigma> =\n                         subsumes_list_filter (a # Ls) Ks \\<sigma>", "have \"subsumes_list (L # Ls) (filter (leq_lit L) Ks) \\<sigma> = subsumes_list_filter (L # Ls) Ks \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes_list (L # Ls) (filter (leq_lit L) Ks) \\<sigma> =\n    subsumes_list_filter (L # Ls) Ks \\<sigma>", "using Cons.prems"], ["proof (prove)\nusing this:\n  sorted_wrt leq_lit (L # Ls)\n\ngoal (1 subgoal):\n 1. subsumes_list (L # Ls) (filter (leq_lit L) Ks) \\<sigma> =\n    subsumes_list_filter (L # Ls) Ks \\<sigma>", "by (auto simp: Cons.IH split: option.splits)"], ["proof (state)\nthis:\n  subsumes_list (L # Ls) (filter (leq_lit L) Ks) \\<sigma> =\n  subsumes_list_filter (L # Ls) Ks \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>Ks \\<sigma>.\n       sorted_wrt leq_lit [] \\<Longrightarrow>\n       subsumes_list [] Ks \\<sigma> = subsumes_list_filter [] Ks \\<sigma>\n 2. \\<And>a Ls Ks \\<sigma>.\n       \\<lbrakk>\\<And>Ks \\<sigma>.\n                   sorted_wrt leq_lit Ls \\<Longrightarrow>\n                   subsumes_list Ls Ks \\<sigma> =\n                   subsumes_list_filter Ls Ks \\<sigma>;\n        sorted_wrt leq_lit (a # Ls)\\<rbrakk>\n       \\<Longrightarrow> subsumes_list (a # Ls) Ks \\<sigma> =\n                         subsumes_list_filter (a # Ls) Ks \\<sigma>", "finally"], ["proof (chain)\npicking this:\n  subsumes_list (L # Ls) Ks \\<sigma> =\n  subsumes_list_filter (L # Ls) Ks \\<sigma>", "show ?case"], ["proof (prove)\nusing this:\n  subsumes_list (L # Ls) Ks \\<sigma> =\n  subsumes_list_filter (L # Ls) Ks \\<sigma>\n\ngoal (1 subgoal):\n 1. subsumes_list (L # Ls) Ks \\<sigma> =\n    subsumes_list_filter (L # Ls) Ks \\<sigma>", "."], ["proof (state)\nthis:\n  subsumes_list (L # Ls) Ks \\<sigma> =\n  subsumes_list_filter (L # Ls) Ks \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>Ks \\<sigma>.\n       sorted_wrt leq_lit [] \\<Longrightarrow>\n       subsumes_list [] Ks \\<sigma> = subsumes_list_filter [] Ks \\<sigma>", "qed simp"], ["", "subsection \\<open>Definition of Deterministic QuickSort\\<close>"], ["", "text \\<open>\n  This is the functional description of the standard variant of deterministic\n  QuickSort that always chooses the first list element as the pivot as given\n  by Hoare in 1962. For a list that is already sorted, this leads to $n(n-1)$\n  comparisons, but as is well known, the average case is much better.\n\n  The code below is adapted from Manuel Eberl's \\<open>Quick_Sort_Cost\\<close> AFP\n  entry, but without invoking probability theory and using a predicate instead\n  of a set.\n\\<close>"], ["", "fun quicksort :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"quicksort _ [] = []\"\n| \"quicksort R (x # xs) =\n     quicksort R (filter (\\<lambda>y. R y x) xs) @ [x] @ quicksort R (filter (\\<lambda>y. \\<not> R y x) xs)\""], ["", "text \\<open>\n  We can easily show that this QuickSort is correct:\n\\<close>"], ["", "theorem mset_quicksort [simp]: \"mset (quicksort R xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (quicksort R xs) = mset xs", "by (induction R xs rule: quicksort.induct) simp_all"], ["", "corollary set_quicksort [simp]: \"set (quicksort R xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (quicksort R xs) = set xs", "by (induction R xs rule: quicksort.induct) auto"], ["", "theorem sorted_wrt_quicksort:\n  assumes \"transp R\" and \"total_on R (set xs)\" and \"reflp_on R (set xs)\"\n  shows   \"sorted_wrt R (quicksort R xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R (quicksort R xs)", "using assms"], ["proof (prove)\nusing this:\n  transp R\n  Restricted_Predicates.total_on R (set xs)\n  reflp_on R (set xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt R (quicksort R xs)", "proof (induction R xs rule: quicksort.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       \\<lbrakk>transp uu_; Restricted_Predicates.total_on uu_ (set []);\n        reflp_on uu_ (set [])\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt uu_ (quicksort uu_ [])\n 2. \\<And>R x xs.\n       \\<lbrakk>\\<lbrakk>transp R;\n                 Restricted_Predicates.total_on R\n                  (set (filter (\\<lambda>y. R y x) xs));\n                 reflp_on R (set (filter (\\<lambda>y. R y x) xs))\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R\n                                   (quicksort R\n                                     (filter (\\<lambda>y. R y x) xs));\n        \\<lbrakk>transp R;\n         Restricted_Predicates.total_on R\n          (set (filter (\\<lambda>y. \\<not> R y x) xs));\n         reflp_on R (set (filter (\\<lambda>y. \\<not> R y x) xs))\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt R\n                           (quicksort R\n                             (filter (\\<lambda>y. \\<not> R y x) xs));\n        transp R; Restricted_Predicates.total_on R (set (x # xs));\n        reflp_on R (set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (quicksort R (x # xs))", "case (2 R x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>transp R;\n   Restricted_Predicates.total_on R (set (filter (\\<lambda>y. R y x) xs));\n   reflp_on R (set (filter (\\<lambda>y. R y x) xs))\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt R\n                     (quicksort R (filter (\\<lambda>y. R y x) xs))\n  \\<lbrakk>transp R;\n   Restricted_Predicates.total_on R\n    (set (filter (\\<lambda>y. \\<not> R y x) xs));\n   reflp_on R (set (filter (\\<lambda>y. \\<not> R y x) xs))\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt R\n                     (quicksort R (filter (\\<lambda>y. \\<not> R y x) xs))\n  transp R\n  Restricted_Predicates.total_on R (set (x # xs))\n  reflp_on R (set (x # xs))\n\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       \\<lbrakk>transp uu_; Restricted_Predicates.total_on uu_ (set []);\n        reflp_on uu_ (set [])\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt uu_ (quicksort uu_ [])\n 2. \\<And>R x xs.\n       \\<lbrakk>\\<lbrakk>transp R;\n                 Restricted_Predicates.total_on R\n                  (set (filter (\\<lambda>y. R y x) xs));\n                 reflp_on R (set (filter (\\<lambda>y. R y x) xs))\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R\n                                   (quicksort R\n                                     (filter (\\<lambda>y. R y x) xs));\n        \\<lbrakk>transp R;\n         Restricted_Predicates.total_on R\n          (set (filter (\\<lambda>y. \\<not> R y x) xs));\n         reflp_on R (set (filter (\\<lambda>y. \\<not> R y x) xs))\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt R\n                           (quicksort R\n                             (filter (\\<lambda>y. \\<not> R y x) xs));\n        transp R; Restricted_Predicates.total_on R (set (x # xs));\n        reflp_on R (set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (quicksort R (x # xs))", "have total: \"R a b\" if \"\\<not> R b a\" \"a \\<in> set (x#xs)\" \"b \\<in> set (x#xs)\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. R a b", "using \"2.prems\" that"], ["proof (prove)\nusing this:\n  transp R\n  Restricted_Predicates.total_on R (set (x # xs))\n  reflp_on R (set (x # xs))\n  \\<not> R b a\n  a \\<in> set (x # xs)\n  b \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. R a b", "unfolding total_on_def reflp_on_def"], ["proof (prove)\nusing this:\n  transp R\n  \\<forall>xa\\<in>set (x # xs).\n     \\<forall>y\\<in>set (x # xs). xa = y \\<or> R xa y \\<or> R y xa\n  \\<forall>a\\<in>set (x # xs). R a a\n  \\<not> R b a\n  a \\<in> set (x # xs)\n  b \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. R a b", "by (cases \"a = b\") auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> R ?b ?a; ?a \\<in> set (x # xs);\n   ?b \\<in> set (x # xs)\\<rbrakk>\n  \\<Longrightarrow> R ?a ?b\n\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       \\<lbrakk>transp uu_; Restricted_Predicates.total_on uu_ (set []);\n        reflp_on uu_ (set [])\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt uu_ (quicksort uu_ [])\n 2. \\<And>R x xs.\n       \\<lbrakk>\\<lbrakk>transp R;\n                 Restricted_Predicates.total_on R\n                  (set (filter (\\<lambda>y. R y x) xs));\n                 reflp_on R (set (filter (\\<lambda>y. R y x) xs))\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R\n                                   (quicksort R\n                                     (filter (\\<lambda>y. R y x) xs));\n        \\<lbrakk>transp R;\n         Restricted_Predicates.total_on R\n          (set (filter (\\<lambda>y. \\<not> R y x) xs));\n         reflp_on R (set (filter (\\<lambda>y. \\<not> R y x) xs))\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt R\n                           (quicksort R\n                             (filter (\\<lambda>y. \\<not> R y x) xs));\n        transp R; Restricted_Predicates.total_on R (set (x # xs));\n        reflp_on R (set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (quicksort R (x # xs))", "have \"sorted_wrt R (quicksort R (filter (\\<lambda>y. R y x) xs))\"\n          \"sorted_wrt R (quicksort R (filter (\\<lambda>y. \\<not> R y x) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R (quicksort R (filter (\\<lambda>y. R y x) xs)) &&&\n    sorted_wrt R (quicksort R (filter (\\<lambda>y. \\<not> R y x) xs))", "using \"2.prems\""], ["proof (prove)\nusing this:\n  transp R\n  Restricted_Predicates.total_on R (set (x # xs))\n  reflp_on R (set (x # xs))\n\ngoal (1 subgoal):\n 1. sorted_wrt R (quicksort R (filter (\\<lambda>y. R y x) xs)) &&&\n    sorted_wrt R (quicksort R (filter (\\<lambda>y. \\<not> R y x) xs))", "by (intro \"2.IH\"; auto simp: total_on_def reflp_on_def)+"], ["proof (state)\nthis:\n  sorted_wrt R (quicksort R (filter (\\<lambda>y. R y x) xs))\n  sorted_wrt R (quicksort R (filter (\\<lambda>y. \\<not> R y x) xs))\n\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       \\<lbrakk>transp uu_; Restricted_Predicates.total_on uu_ (set []);\n        reflp_on uu_ (set [])\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt uu_ (quicksort uu_ [])\n 2. \\<And>R x xs.\n       \\<lbrakk>\\<lbrakk>transp R;\n                 Restricted_Predicates.total_on R\n                  (set (filter (\\<lambda>y. R y x) xs));\n                 reflp_on R (set (filter (\\<lambda>y. R y x) xs))\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R\n                                   (quicksort R\n                                     (filter (\\<lambda>y. R y x) xs));\n        \\<lbrakk>transp R;\n         Restricted_Predicates.total_on R\n          (set (filter (\\<lambda>y. \\<not> R y x) xs));\n         reflp_on R (set (filter (\\<lambda>y. \\<not> R y x) xs))\\<rbrakk>\n        \\<Longrightarrow> sorted_wrt R\n                           (quicksort R\n                             (filter (\\<lambda>y. \\<not> R y x) xs));\n        transp R; Restricted_Predicates.total_on R (set (x # xs));\n        reflp_on R (set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (quicksort R (x # xs))", "then"], ["proof (chain)\npicking this:\n  sorted_wrt R (quicksort R (filter (\\<lambda>y. R y x) xs))\n  sorted_wrt R (quicksort R (filter (\\<lambda>y. \\<not> R y x) xs))", "show ?case"], ["proof (prove)\nusing this:\n  sorted_wrt R (quicksort R (filter (\\<lambda>y. R y x) xs))\n  sorted_wrt R (quicksort R (filter (\\<lambda>y. \\<not> R y x) xs))\n\ngoal (1 subgoal):\n 1. sorted_wrt R (quicksort R (x # xs))", "by (auto simp: sorted_wrt_append \\<open>transp R\\<close>\n     intro: transpD[OF \\<open>transp R\\<close>] dest!: total)"], ["proof (state)\nthis:\n  sorted_wrt R (quicksort R (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>uu_.\n       \\<lbrakk>transp uu_; Restricted_Predicates.total_on uu_ (set []);\n        reflp_on uu_ (set [])\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt uu_ (quicksort uu_ [])", "qed auto"], ["", "text \\<open>\nEnd of the material adapted from Eberl's \\<open>Quick_Sort_Cost\\<close>.\n\\<close>"], ["", "lemma subsumes_list_subsumes_list_filter[abs_def, code_unfold]:\n  \"subsumes_list Ls Ks \\<sigma> = subsumes_list_filter (quicksort leq_lit Ls) Ks \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumes_list Ls Ks \\<sigma> =\n    subsumes_list_filter (quicksort leq_lit Ls) Ks \\<sigma>", "by (rule trans[OF box_equals[OF _ subsumes_list_alt[symmetric] subsumes_list_alt[symmetric]]\n    sorted_wrt_subsumes_list_subsumes_list_filter])\n    (auto simp: sorted_wrt_quicksort)"], ["", "end"]]}