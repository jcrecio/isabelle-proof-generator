{"file_name": "/home/qj213/afp-2021-10-22/thys/Functional_Ordered_Resolution_Prover/Deterministic_FO_Ordered_Resolution_Prover.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Functional_Ordered_Resolution_Prover", "problem_names": ["lemma apfst_fst_snd: \"apfst f x = (f (fst x), snd x)\"", "lemma apfst_comp_rpair_const: \"apfst f \\<circ> (\\<lambda>x. (x, y)) = (\\<lambda>x. (x, y)) \\<circ> f\"", "lemma length_remove1_less[termination_simp]: \"x \\<in> set xs \\<Longrightarrow> length (remove1 x xs) < length xs\"", "lemma map_filter_neq_eq_filter_map:\n  \"map f (filter (\\<lambda>y. f x \\<noteq> f y) xs) = filter (\\<lambda>z. f x \\<noteq> z) (map f xs)\"", "lemma mset_map_remdups_gen:\n  \"mset (map f (remdups_gen f xs)) = mset (remdups_gen (\\<lambda>x. x) (map f xs))\"", "lemma mset_remdups_gen_ident: \"mset (remdups_gen (\\<lambda>x. x) xs) = mset_set (set xs)\"", "lemma funpow_fixpoint: \"f x = x \\<Longrightarrow> (f ^^ n) x = x\"", "lemma rtranclp_imp_eq_image: \"(\\<forall>x y. R x y \\<longrightarrow> f x = f y) \\<Longrightarrow> R\\<^sup>*\\<^sup>* x y \\<Longrightarrow> f x = f y\"", "lemma tranclp_imp_eq_image: \"(\\<forall>x y. R x y \\<longrightarrow> f x = f y) \\<Longrightarrow> R\\<^sup>+\\<^sup>+ x y \\<Longrightarrow> f x = f y\"", "lemma less_atm_irrefl: \"\\<not> less_atm A A\"", "lemma remove_all_mset_minus: \"mset ys \\<subseteq># mset xs \\<Longrightarrow> mset (remove_all xs ys) = mset xs - mset ys\"", "lemma select_min_weight_clause_in: \"select_min_weight_clause P0 P \\<in> set (P0 # P)\"", "lemma is_final_dstate_imp_not_weighted_RP: \"is_final_dstate St \\<Longrightarrow> \\<not> wstate_of_dstate St \\<leadsto>\\<^sub>w St'\"", "lemma is_final_dstate_funpow_imp_deterministic_RP_neq_None:\n  \"is_final_dstate ((deterministic_RP_step ^^ k) St) \\<Longrightarrow> deterministic_RP St \\<noteq> None\"", "lemma is_reducible_lit_mono_cls:\n  \"mset C \\<subseteq># mset C' \\<Longrightarrow> is_reducible_lit Ds C L \\<Longrightarrow> is_reducible_lit Ds C' L\"", "lemma is_reducible_lit_mset_iff:\n  \"mset C = mset C' \\<Longrightarrow> is_reducible_lit Ds C' L \\<longleftrightarrow> is_reducible_lit Ds C L\"", "lemma is_reducible_lit_remove1_Cons_iff:\n  assumes \"L \\<in> set C'\"\n  shows \"is_reducible_lit Ds (C @ remove1 L (M # C')) L \\<longleftrightarrow>\n    is_reducible_lit Ds (M # C @ remove1 L C') L\"", "lemma reduce_mset_eq: \"mset C = mset C' \\<Longrightarrow> reduce Ds C E = reduce Ds C' E\"", "lemma reduce_rotate[simp]: \"reduce Ds (C @ [L]) E = reduce Ds (L # C) E\"", "lemma mset_reduce_subset: \"mset (reduce Ds C E) \\<subseteq># mset E\"", "lemma reduce_idem: \"reduce Ds C (reduce Ds C E) = reduce Ds C E\"", "lemma is_reducible_lit_imp_is_reducible:\n  \"L \\<in> set C' \\<Longrightarrow> is_reducible_lit Ds (C @ remove1 L C') L \\<Longrightarrow> reduce Ds C C' \\<noteq> C'\"", "lemma is_reducible_imp_is_reducible_lit:\n  \"reduce Ds C C' \\<noteq> C' \\<Longrightarrow> \\<exists>L \\<in> set C'. is_reducible_lit Ds (C @ remove1 L C') L\"", "lemma is_irreducible_iff_nexists_is_reducible_lit:\n  \"reduce Ds C C' = C' \\<longleftrightarrow> \\<not> (\\<exists>L \\<in> set C'. is_reducible_lit Ds (C @ remove1 L C') L)\"", "lemma is_irreducible_mset_iff: \"mset E = mset E' \\<Longrightarrow> reduce Ds C E = E \\<longleftrightarrow> reduce Ds C E' = E'\"", "lemma select_min_weight_clause_min_weight:\n  assumes \"Ci = select_min_weight_clause P0 P\"\n  shows \"weight (apfst mset Ci) = Min ((weight \\<circ> apfst mset) ` set (P0 # P))\"", "lemma remdups_clss_Nil_iff: \"remdups_clss Cs = [] \\<longleftrightarrow> Cs = []\"", "lemma empty_N_if_Nil_in_P_or_Q:\n  assumes nil_in: \"[] \\<in> fst ` set (P @ Q)\"\n  shows \"wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ([], P, Q, n)\"", "lemma remove_strictly_subsumed_clauses_in_P:\n  assumes\n    c_in: \"C \\<in> fst ` set N\" and\n    p_nsubs: \"\\<forall>D \\<in> fst ` set P. \\<not> strictly_subsume [C] D\"\n  shows \"wstate_of_dstate (N, P @ P', Q, n)\n    \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\"", "lemma remove_strictly_subsumed_clauses_in_Q:\n  assumes c_in: \"C \\<in> fst ` set N\"\n  shows \"wstate_of_dstate (N, P, Q @ Q', n)\n    \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, P, Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) Q', n)\"", "lemma reduce_clause_in_P:\n  assumes\n    c_in: \"C \\<in> fst ` set N\" and\n    p_irred: \"\\<forall>(E, k) \\<in> set (P @ P'). k > j \\<longrightarrow> is_irreducible [C] E\"\n  shows \"wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)\n    \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, P @ (D @ reduce [C] D D', j) # P', Q, n)\"", "lemma reduce_clause_in_Q:\n  assumes\n    c_in: \"C \\<in> fst ` set N\" and\n    p_irred: \"\\<forall>(E, k) \\<in> set P. k > j \\<longrightarrow> is_irreducible [C] E\" and\n    d'_red: \"reduce [C] D D' \\<noteq> D'\"\n  shows \"wstate_of_dstate (N, P, Q @ (D @ D', j) # Q', n)\n    \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, (D @ reduce [C] D D', j) # P, Q @ Q', n)\"", "lemma reduce_clauses_in_P:\n  assumes\n    c_in: \"C \\<in> fst ` set N\" and\n    p_irred: \"\\<forall>(E, k) \\<in> set P. is_irreducible [C] E\"\n  shows \"wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, P @ reduce_all C P', Q, n)\"", "lemma reduce_clauses_in_Q:\n  assumes\n    c_in: \"C \\<in> fst ` set N\" and\n    p_irred: \"\\<forall>(E, k) \\<in> set P. is_irreducible [C] E\"\n  shows \"wstate_of_dstate (N, P, Q @ Q', n)\n    \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, fst (reduce_all2 C Q') @ P, Q @ snd (reduce_all2 C Q'), n)\"", "lemma eligible_iff:\n  \"eligible S \\<sigma> As DA \\<longleftrightarrow> As = [] \\<or> length As = 1 \\<and> maximal_wrt (hd As \\<cdot>a \\<sigma>) (DA \\<cdot> \\<sigma>)\"", "lemma ord_resolve_one_side_prem:\n  \"ord_resolve S CAs DA AAs As \\<sigma> E \\<Longrightarrow> length CAs = 1 \\<and> length AAs = 1 \\<and> length As = 1\"", "lemma ord_resolve_rename_one_side_prem:\n  \"ord_resolve_rename S CAs DA AAs As \\<sigma> E \\<Longrightarrow> length CAs = 1 \\<and> length AAs = 1 \\<and> length As = 1\"", "lemma resolve_on_eq_UNION_Bin_ord_resolve:\n  \"mset ` set (resolve_on A D CA) =\n   {E. \\<exists>AA \\<sigma>. ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\"", "lemma set_resolve_eq_UNION_set_resolve_on:\n  \"set (resolve C D) =\n   (\\<Union>L \\<in> set D.\n      (case L of\n         Pos _ \\<Rightarrow> {}\n       | Neg A \\<Rightarrow> if maximal_wrt A (mset D) then set (resolve_on A (remove1 L D) C) else {}))\"", "lemma resolve_eq_Bin_ord_resolve: \"mset ` set (resolve C D) = Bin_ord_resolve (mset C) (mset D)\"", "lemma poss_in_map_clauseD:\n  \"poss AA \\<subseteq># map_clause f C \\<Longrightarrow> \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> AA = {#f A. A \\<in># AA0#}\"", "lemma poss_subset_filterD:\n  \"poss AA \\<subseteq># {#L \\<cdot>l \\<rho>. L \\<in># mset C#} \\<Longrightarrow> \\<exists>AA0. poss AA0 \\<subseteq># mset C \\<and> AA = AA0 \\<cdot>am \\<rho>\"", "lemma neg_in_map_literalD: \"Neg A \\<in> map_literal f ` D \\<Longrightarrow> \\<exists>A0. Neg A0 \\<in> D \\<and> A = f A0\"", "lemma neg_in_filterD: \"Neg A \\<in># {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} \\<Longrightarrow> \\<exists>A0. Neg A0 \\<in># mset D \\<and> A = A0 \\<cdot>a \\<rho>'\"", "lemma resolve_rename_eq_Bin_ord_resolve_rename:\n  \"mset ` set (resolve_rename C D) = Bin_ord_resolve_rename (mset C) (mset D)\"", "lemma bin_ord_FO_\\<Gamma>_def:\n  \"ord_FO_\\<Gamma> S = {Infer {#CA#} DA E | CA DA AA A \\<sigma> E. ord_resolve_rename S [CA] DA [AA] [A] \\<sigma> E}\"", "lemma ord_FO_\\<Gamma>_side_prem: \"\\<gamma> \\<in> ord_FO_\\<Gamma> S \\<Longrightarrow> side_prems_of \\<gamma> = {#THE D. D \\<in># side_prems_of \\<gamma>#}\"", "lemma ord_FO_\\<Gamma>_infer_from_Collect_eq:\n  \"{\\<gamma> \\<in> ord_FO_\\<Gamma> S. infer_from (DD \\<union> {C}) \\<gamma> \\<and> C \\<in># prems_of \\<gamma>} =\n   {\\<gamma> \\<in> ord_FO_\\<Gamma> S. \\<exists>D \\<in> DD \\<union> {C}. prems_of \\<gamma> = {#C, D#}}\"", "lemma inferences_between_eq_UNION: \"inference_system.inferences_between (ord_FO_\\<Gamma> S) Q C =\n  inference_system.inferences_between (ord_FO_\\<Gamma> S) {C} C\n  \\<union> (\\<Union>D \\<in> Q. inference_system.inferences_between (ord_FO_\\<Gamma> S) {D} C)\"", "lemma concls_of_inferences_between_singleton_eq_Bin_ord_resolve_rename:\n  \"concls_of (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D} C) =\n   Bin_ord_resolve_rename C C \\<union> Bin_ord_resolve_rename C D \\<union> Bin_ord_resolve_rename D C\"", "lemma concls_of_inferences_between_eq_Bin_ord_resolve_rename:\n  \"concls_of (inference_system.inferences_between (ord_FO_\\<Gamma> S) Q C) =\n   Bin_ord_resolve_rename C C \\<union> (\\<Union>D \\<in> Q. Bin_ord_resolve_rename C D \\<union> Bin_ord_resolve_rename D C)\"", "lemma resolve_rename_either_way_eq_congls_of_inferences_between:\n  \"mset ` set (resolve_rename C C) \\<union> (\\<Union>D \\<in> Q. mset ` set (resolve_rename_either_way C D)) =\n   concls_of (inference_system.inferences_between (ord_FO_\\<Gamma> S) (mset ` Q) (mset C))\"", "lemma compute_inferences:\n  assumes\n    ci_in: \"(C, i) \\<in> set P\" and\n    ci_min: \"\\<forall>(D, j) \\<in># mset (map (apfst mset) P). weight (mset C, i) \\<le> weight (D, j)\"\n  shows\n    \"wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\n     wstate_of_dstate (map (\\<lambda>D. (D, n)) (remdups_gen mset (resolve_rename C C @\n         concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n       filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q, Suc n)\"\n    (is \"_ \\<leadsto>\\<^sub>w wstate_of_dstate (?N, _)\")", "lemma nonfinal_deterministic_RP_step:\n  assumes\n    nonfinal: \"\\<not> is_final_dstate St\" and\n    step: \"St' = deterministic_RP_step St\"\n  shows \"wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\"", "lemma final_deterministic_RP_step: \"is_final_dstate St \\<Longrightarrow> deterministic_RP_step St = St\"", "lemma deterministic_RP_SomeD:\n  assumes \"deterministic_RP (N, P, Q, n) = Some R\"\n  shows \"\\<exists>N' P' Q' n'. (\\<exists>k. (deterministic_RP_step ^^ k) (N, P, Q, n) = (N', P', Q', n'))\n    \\<and> is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'\"", "lemma full_deriv_wSts_trancl_weighted_RP: \"full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) wSts\"", "lemmas deriv_wSts_trancl_weighted_RP = full_chain_imp_chain[OF full_deriv_wSts_trancl_weighted_RP]", "lemma sswSts:\n  \"full_chain (\\<leadsto>\\<^sub>w) sswSts \\<and> emb wSts sswSts \\<and> lhd sswSts = lhd wSts \\<and> llast sswSts = llast wSts\"", "lemmas full_deriv_sswSts_weighted_RP = sswSts[THEN conjunct1]", "lemmas emb_sswSts = sswSts[THEN conjunct2, THEN conjunct1]", "lemmas lfinite_sswSts_iff = emb_lfinite[OF emb_sswSts]", "lemmas lhd_sswSts = sswSts[THEN conjunct2, THEN conjunct2, THEN conjunct1]", "lemmas llast_sswSts = sswSts[THEN conjunct2, THEN conjunct2, THEN conjunct2]", "lemmas deriv_sswSts_weighted_RP = full_chain_imp_chain[OF full_deriv_sswSts_weighted_RP]", "lemma not_lnull_sswSts: \"\\<not> lnull sswSts\"", "lemma empty_ssgP0: \"wrp.P_of_wstate (lhd sswSts) = {}\"", "lemma empty_ssgQ0: \"wrp.Q_of_wstate (lhd sswSts) = {}\"", "lemmas sswSts_thms = full_deriv_sswSts_weighted_RP empty_ssgP0 empty_ssgQ0", "lemma lfinite_Sts: \"lfinite Sts\"", "lemma lfinite_wSts: \"lfinite wSts\"", "lemmas lfinite_sswSts = lfinite_sswSts_iff[THEN iffD2, OF lfinite_wSts]", "theorem\n  deterministic_RP_saturated: \"saturated_upto grounded_R\" (is ?saturated) and\n  deterministic_RP_model: \"I \\<Turnstile>s grounded_N0 \\<longleftrightarrow> I \\<Turnstile>s grounded_R\" (is ?model)", "theorem deterministic_RP_complete: \"satisfiable grounded_N0\""], "translations": [["", "lemma apfst_fst_snd: \"apfst f x = (f (fst x), snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apfst f x = (f (fst x), snd x)", "by (rule apfst_conv[of _ \"fst x\" \"snd x\" for x, unfolded prod.collapse])"], ["", "lemma apfst_comp_rpair_const: \"apfst f \\<circ> (\\<lambda>x. (x, y)) = (\\<lambda>x. (x, y)) \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apfst f \\<circ> (\\<lambda>x. (x, y)) = (\\<lambda>x. (x, y)) \\<circ> f", "by (simp add: comp_def)"], ["", "(* TODO: Move to Isabelle's \"List.thy\"? *)"], ["", "lemma length_remove1_less[termination_simp]: \"x \\<in> set xs \\<Longrightarrow> length (remove1 x xs) < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> length (remove1 x xs) < length xs", "by (induct xs) auto"], ["", "lemma map_filter_neq_eq_filter_map:\n  \"map f (filter (\\<lambda>y. f x \\<noteq> f y) xs) = filter (\\<lambda>z. f x \\<noteq> z) (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (filter (\\<lambda>y. f x \\<noteq> f y) xs) =\n    filter ((\\<noteq>) (f x)) (map f xs)", "by (induct xs) auto"], ["", "lemma mset_map_remdups_gen:\n  \"mset (map f (remdups_gen f xs)) = mset (remdups_gen (\\<lambda>x. x) (map f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (map f (remdups_gen f xs)) =\n    mset (remdups_gen (\\<lambda>x. x) (map f xs))", "by (induct f xs rule: remdups_gen.induct) (auto simp: map_filter_neq_eq_filter_map)"], ["", "lemma mset_remdups_gen_ident: \"mset (remdups_gen (\\<lambda>x. x) xs) = mset_set (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (remdups_gen (\\<lambda>x. x) xs) = mset_set (set xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset (remdups_gen (\\<lambda>x. x) xs) = mset_set (set xs)", "have \"f = (\\<lambda>x. x) \\<Longrightarrow> mset (remdups_gen f xs) = mset_set (set xs)\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = (\\<lambda>x. x) \\<Longrightarrow>\n    mset (remdups_gen f xs) = mset_set (set xs)", "proof (induct f xs rule: remdups_gen.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       f = (\\<lambda>x. x) \\<Longrightarrow>\n       mset (remdups_gen f []) = mset_set (set [])\n 2. \\<And>f x xs.\n       \\<lbrakk>f = (\\<lambda>x. x) \\<Longrightarrow>\n                mset\n                 (remdups_gen f\n                   (filter (\\<lambda>y. f x \\<noteq> f y) xs)) =\n                mset_set (set (filter (\\<lambda>y. f x \\<noteq> f y) xs));\n        f = (\\<lambda>x. x)\\<rbrakk>\n       \\<Longrightarrow> mset (remdups_gen f (x # xs)) =\n                         mset_set (set (x # xs))", "case (2 f x xs)"], ["proof (state)\nthis:\n  f = (\\<lambda>x. x) \\<Longrightarrow>\n  mset (remdups_gen f (filter (\\<lambda>y. f x \\<noteq> f y) xs)) =\n  mset_set (set (filter (\\<lambda>y. f x \\<noteq> f y) xs))\n  f = (\\<lambda>x. x)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f = (\\<lambda>x. x) \\<Longrightarrow>\n       mset (remdups_gen f []) = mset_set (set [])\n 2. \\<And>f x xs.\n       \\<lbrakk>f = (\\<lambda>x. x) \\<Longrightarrow>\n                mset\n                 (remdups_gen f\n                   (filter (\\<lambda>y. f x \\<noteq> f y) xs)) =\n                mset_set (set (filter (\\<lambda>y. f x \\<noteq> f y) xs));\n        f = (\\<lambda>x. x)\\<rbrakk>\n       \\<Longrightarrow> mset (remdups_gen f (x # xs)) =\n                         mset_set (set (x # xs))", "note ih = this(1) and f = this(2)"], ["proof (state)\nthis:\n  f = (\\<lambda>x. x) \\<Longrightarrow>\n  mset (remdups_gen f (filter (\\<lambda>y. f x \\<noteq> f y) xs)) =\n  mset_set (set (filter (\\<lambda>y. f x \\<noteq> f y) xs))\n  f = (\\<lambda>x. x)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f = (\\<lambda>x. x) \\<Longrightarrow>\n       mset (remdups_gen f []) = mset_set (set [])\n 2. \\<And>f x xs.\n       \\<lbrakk>f = (\\<lambda>x. x) \\<Longrightarrow>\n                mset\n                 (remdups_gen f\n                   (filter (\\<lambda>y. f x \\<noteq> f y) xs)) =\n                mset_set (set (filter (\\<lambda>y. f x \\<noteq> f y) xs));\n        f = (\\<lambda>x. x)\\<rbrakk>\n       \\<Longrightarrow> mset (remdups_gen f (x # xs)) =\n                         mset_set (set (x # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (remdups_gen f (x # xs)) = mset_set (set (x # xs))", "unfolding f remdups_gen.simps ih[OF f, unfolded f] mset.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset x (mset_set (set (filter ((\\<noteq>) x) xs))) =\n    mset_set (set (x # xs))", "by (metis finite_set list.simps(15) mset_set.insert_remove removeAll_filter_not_eq\n          remove_code(1) remove_def)"], ["proof (state)\nthis:\n  mset (remdups_gen f (x # xs)) = mset_set (set (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f = (\\<lambda>x. x) \\<Longrightarrow>\n       mset (remdups_gen f []) = mset_set (set [])", "qed simp"], ["proof (state)\nthis:\n  ?f = (\\<lambda>x. x) \\<Longrightarrow>\n  mset (remdups_gen ?f xs) = mset_set (set xs)\n\ngoal (1 subgoal):\n 1. mset (remdups_gen (\\<lambda>x. x) xs) = mset_set (set xs)", "then"], ["proof (chain)\npicking this:\n  ?f = (\\<lambda>x. x) \\<Longrightarrow>\n  mset (remdups_gen ?f xs) = mset_set (set xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?f = (\\<lambda>x. x) \\<Longrightarrow>\n  mset (remdups_gen ?f xs) = mset_set (set xs)\n\ngoal (1 subgoal):\n 1. mset (remdups_gen (\\<lambda>x. x) xs) = mset_set (set xs)", "by simp"], ["proof (state)\nthis:\n  mset (remdups_gen (\\<lambda>x. x) xs) = mset_set (set xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Move to Isabelle? *)"], ["", "lemma funpow_fixpoint: \"f x = x \\<Longrightarrow> (f ^^ n) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = x \\<Longrightarrow> (f ^^ n) x = x", "by (induct n) auto"], ["", "lemma rtranclp_imp_eq_image: \"(\\<forall>x y. R x y \\<longrightarrow> f x = f y) \\<Longrightarrow> R\\<^sup>*\\<^sup>* x y \\<Longrightarrow> f x = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. R x y \\<longrightarrow> f x = f y;\n     R\\<^sup>*\\<^sup>* x y\\<rbrakk>\n    \\<Longrightarrow> f x = f y", "by (erule rtranclp.induct) auto"], ["", "lemma tranclp_imp_eq_image: \"(\\<forall>x y. R x y \\<longrightarrow> f x = f y) \\<Longrightarrow> R\\<^sup>+\\<^sup>+ x y \\<Longrightarrow> f x = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. R x y \\<longrightarrow> f x = f y;\n     R\\<^sup>+\\<^sup>+ x y\\<rbrakk>\n    \\<Longrightarrow> f x = f y", "by (erule tranclp.induct) auto"], ["", "subsection \\<open>Prover\\<close>"], ["", "type_synonym 'a lclause = \"'a literal list\""], ["", "type_synonym 'a dclause = \"'a lclause \\<times> nat\""], ["", "type_synonym 'a dstate = \"'a dclause list \\<times> 'a dclause list \\<times> 'a dclause list \\<times> nat\""], ["", "locale deterministic_FO_resolution_prover =\n  weighted_FO_resolution_prover_with_size_timestamp_factors S subst_atm id_subst comp_subst\n    renamings_apart atm_of_atms mgu less_atm size_atm timestamp_factor size_factor\n  for\n    S :: \"('a :: wellorder) clause \\<Rightarrow> 'a clause\" and\n    subst_atm :: \"'a \\<Rightarrow> 's \\<Rightarrow> 'a\" and\n    id_subst :: \"'s\" and\n    comp_subst :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\" and\n    renamings_apart :: \"'a literal multiset list \\<Rightarrow> 's list\" and\n    atm_of_atms :: \"'a list \\<Rightarrow> 'a\" and\n    mgu :: \"'a set set \\<Rightarrow> 's option\" and\n    less_atm :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and\n    size_atm :: \"'a \\<Rightarrow> nat\" and\n    timestamp_factor :: nat and\n    size_factor :: nat +\n  assumes\n    S_empty: \"S C = {#}\"\nbegin"], ["", "lemma less_atm_irrefl: \"\\<not> less_atm A A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> less_atm A A", "using ex_ground_subst less_atm_ground less_atm_stable"], ["proof (prove)\nusing this:\n  Ex is_ground_subst\n  \\<lbrakk>is_ground_atm ?A; is_ground_atm ?B; less_atm ?A ?B\\<rbrakk>\n  \\<Longrightarrow> ?A < ?B\n  less_atm ?A ?B \\<Longrightarrow>\n  less_atm (?A \\<cdot>a ?\\<sigma>) (?B \\<cdot>a ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> less_atm A A", "unfolding is_ground_subst_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>. \\<forall>A. is_ground_atm (A \\<cdot>a \\<sigma>)\n  \\<lbrakk>is_ground_atm ?A; is_ground_atm ?B; less_atm ?A ?B\\<rbrakk>\n  \\<Longrightarrow> ?A < ?B\n  less_atm ?A ?B \\<Longrightarrow>\n  less_atm (?A \\<cdot>a ?\\<sigma>) (?B \\<cdot>a ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> less_atm A A", "by blast"], ["", "fun wstate_of_dstate :: \"'a dstate \\<Rightarrow> 'a wstate\" where\n  \"wstate_of_dstate (N, P, Q, n) =\n   (mset (map (apfst mset) N), mset (map (apfst mset) P), mset (map (apfst mset) Q), n)\""], ["", "fun state_of_dstate :: \"'a dstate \\<Rightarrow> 'a state\" where\n  \"state_of_dstate (N, P, Q, _) =\n   (set (map (mset \\<circ> fst) N), set (map (mset \\<circ> fst) P), set (map (mset \\<circ> fst) Q))\""], ["", "abbreviation clss_of_dstate :: \"'a dstate \\<Rightarrow> 'a clause set\" where\n  \"clss_of_dstate St \\<equiv> clss_of_state (state_of_dstate St)\""], ["", "fun is_final_dstate :: \"'a dstate \\<Rightarrow> bool\" where\n  \"is_final_dstate (N, P, Q, n) \\<longleftrightarrow> N = [] \\<and> P = []\""], ["", "declare is_final_dstate.simps [simp del]"], ["", "abbreviation rtrancl_weighted_RP (infix \"\\<leadsto>\\<^sub>w\\<^sup>*\" 50) where\n  \"(\\<leadsto>\\<^sub>w\\<^sup>*) \\<equiv> (\\<leadsto>\\<^sub>w)\\<^sup>*\\<^sup>*\""], ["", "abbreviation trancl_weighted_RP (infix \"\\<leadsto>\\<^sub>w\\<^sup>+\" 50) where\n  \"(\\<leadsto>\\<^sub>w\\<^sup>+) \\<equiv> (\\<leadsto>\\<^sub>w)\\<^sup>+\\<^sup>+\""], ["", "definition is_tautology :: \"'a lclause \\<Rightarrow> bool\" where\n  \"is_tautology C \\<longleftrightarrow> (\\<exists>A \\<in> set (map atm_of C). Pos A \\<in> set C \\<and> Neg A \\<in> set C)\""], ["", "definition subsume :: \"'a lclause list \\<Rightarrow> 'a lclause \\<Rightarrow> bool\" where\n  \"subsume Ds C \\<longleftrightarrow> (\\<exists>D \\<in> set Ds. subsumes (mset D) (mset C))\""], ["", "definition strictly_subsume :: \"'a lclause list \\<Rightarrow> 'a lclause \\<Rightarrow> bool\" where\n  \"strictly_subsume Ds C \\<longleftrightarrow> (\\<exists>D \\<in> set Ds. strictly_subsumes (mset D) (mset C))\""], ["", "definition is_reducible_on :: \"'a literal \\<Rightarrow> 'a lclause \\<Rightarrow> 'a literal \\<Rightarrow> 'a lclause \\<Rightarrow> bool\" where\n  \"is_reducible_on M D L C \\<longleftrightarrow> subsumes (mset D + {#- M#}) (mset C + {#L#})\""], ["", "definition is_reducible_lit :: \"'a lclause list \\<Rightarrow> 'a lclause \\<Rightarrow> 'a literal \\<Rightarrow> bool\" where\n  \"is_reducible_lit Ds C L \\<longleftrightarrow>\n   (\\<exists>D \\<in> set Ds. \\<exists>L' \\<in> set D. \\<exists>\\<sigma>. - L = L' \\<cdot>l \\<sigma> \\<and> mset (remove1 L' D) \\<cdot> \\<sigma> \\<subseteq># mset C)\""], ["", "primrec reduce :: \"'a lclause list \\<Rightarrow> 'a lclause \\<Rightarrow> 'a lclause \\<Rightarrow> 'a lclause\" where\n  \"reduce _ _ [] = []\"\n| \"reduce Ds C (L # C') =\n   (if is_reducible_lit Ds (C @ C') L then reduce Ds C C' else L # reduce Ds (L # C) C')\""], ["", "abbreviation is_irreducible :: \"'a lclause list \\<Rightarrow> 'a lclause \\<Rightarrow> bool\" where\n  \"is_irreducible Ds C \\<equiv> reduce Ds [] C = C\""], ["", "abbreviation is_reducible :: \"'a lclause list \\<Rightarrow> 'a lclause \\<Rightarrow> bool\" where\n  \"is_reducible Ds C \\<equiv> reduce Ds [] C \\<noteq> C\""], ["", "definition reduce_all :: \"'a lclause \\<Rightarrow> 'a dclause list \\<Rightarrow> 'a dclause list\" where\n  \"reduce_all D = map (apfst (reduce [D] []))\""], ["", "fun reduce_all2 :: \"'a lclause \\<Rightarrow> 'a dclause list \\<Rightarrow> 'a dclause list \\<times> 'a dclause list\" where\n  \"reduce_all2 _ [] = ([], [])\"\n| \"reduce_all2 D (Ci # Cs) =\n   (let\n      (C, i) = Ci;\n      C' = reduce [D] [] C\n    in\n      (if C' = C then apsnd else apfst) (Cons (C', i)) (reduce_all2 D Cs))\""], ["", "fun remove_all :: \"'b list \\<Rightarrow> 'b list \\<Rightarrow> 'b list\" where\n  \"remove_all xs [] = xs\"\n| \"remove_all xs (y # ys) = (if y \\<in> set xs then remove_all (remove1 y xs) ys else remove_all xs ys)\""], ["", "lemma remove_all_mset_minus: \"mset ys \\<subseteq># mset xs \\<Longrightarrow> mset (remove_all xs ys) = mset xs - mset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ys \\<subseteq># mset xs \\<Longrightarrow>\n    mset (remove_all xs ys) = mset xs - mset ys", "proof (induction ys arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       mset [] \\<subseteq># mset xs \\<Longrightarrow>\n       mset (remove_all xs []) = mset xs - mset []\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   mset ys \\<subseteq># mset xs \\<Longrightarrow>\n                   mset (remove_all xs ys) = mset xs - mset ys;\n        mset (a # ys) \\<subseteq># mset xs\\<rbrakk>\n       \\<Longrightarrow> mset (remove_all xs (a # ys)) =\n                         mset xs - mset (a # ys)", "case (Cons y ys)"], ["proof (state)\nthis:\n  mset ys \\<subseteq># mset ?xs \\<Longrightarrow>\n  mset (remove_all ?xs ys) = mset ?xs - mset ys\n  mset (y # ys) \\<subseteq># mset xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       mset [] \\<subseteq># mset xs \\<Longrightarrow>\n       mset (remove_all xs []) = mset xs - mset []\n 2. \\<And>a ys xs.\n       \\<lbrakk>\\<And>xs.\n                   mset ys \\<subseteq># mset xs \\<Longrightarrow>\n                   mset (remove_all xs ys) = mset xs - mset ys;\n        mset (a # ys) \\<subseteq># mset xs\\<rbrakk>\n       \\<Longrightarrow> mset (remove_all xs (a # ys)) =\n                         mset xs - mset (a # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)", "proof (cases \"y \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> set xs \\<Longrightarrow>\n    mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)\n 2. y \\<notin> set xs \\<Longrightarrow>\n    mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)", "case y_in: True"], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (2 subgoals):\n 1. y \\<in> set xs \\<Longrightarrow>\n    mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)\n 2. y \\<notin> set xs \\<Longrightarrow>\n    mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)", "then"], ["proof (chain)\npicking this:\n  y \\<in> set xs", "have subs: \"mset ys \\<subseteq># mset (remove1 y xs)\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. mset ys \\<subseteq># mset (remove1 y xs)", "using Cons(2)"], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  mset (y # ys) \\<subseteq># mset xs\n\ngoal (1 subgoal):\n 1. mset ys \\<subseteq># mset (remove1 y xs)", "by (simp add: insert_subset_eq_iff)"], ["proof (state)\nthis:\n  mset ys \\<subseteq># mset (remove1 y xs)\n\ngoal (2 subgoals):\n 1. y \\<in> set xs \\<Longrightarrow>\n    mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)\n 2. y \\<notin> set xs \\<Longrightarrow>\n    mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)", "using y_in Cons subs"], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  mset ys \\<subseteq># mset ?xs \\<Longrightarrow>\n  mset (remove_all ?xs ys) = mset ?xs - mset ys\n  mset (y # ys) \\<subseteq># mset xs\n  mset ys \\<subseteq># mset (remove1 y xs)\n\ngoal (1 subgoal):\n 1. mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)", "by auto"], ["proof (state)\nthis:\n  mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)\n\ngoal (1 subgoal):\n 1. y \\<notin> set xs \\<Longrightarrow>\n    mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> set xs \\<Longrightarrow>\n    mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)", "case False"], ["proof (state)\nthis:\n  y \\<notin> set xs\n\ngoal (1 subgoal):\n 1. y \\<notin> set xs \\<Longrightarrow>\n    mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)", "then"], ["proof (chain)\npicking this:\n  y \\<notin> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<notin> set xs\n\ngoal (1 subgoal):\n 1. mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)", "using Cons"], ["proof (prove)\nusing this:\n  y \\<notin> set xs\n  mset ys \\<subseteq># mset ?xs \\<Longrightarrow>\n  mset (remove_all ?xs ys) = mset ?xs - mset ys\n  mset (y # ys) \\<subseteq># mset xs\n\ngoal (1 subgoal):\n 1. mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)", "by auto"], ["proof (state)\nthis:\n  mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset (remove_all xs (y # ys)) = mset xs - mset (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       mset [] \\<subseteq># mset xs \\<Longrightarrow>\n       mset (remove_all xs []) = mset xs - mset []", "qed auto"], ["", "definition resolvent :: \"'a lclause \\<Rightarrow> 'a \\<Rightarrow>'a lclause \\<Rightarrow> 'a lclause \\<Rightarrow> 'a lclause\" where\n  \"resolvent D A CA Ls =\n   map (\\<lambda>M. M \\<cdot>l (the (mgu {insert A (atms_of (mset Ls))}))) (remove_all CA Ls @ D)\""], ["", "definition resolvable :: \"'a \\<Rightarrow> 'a lclause \\<Rightarrow> 'a lclause \\<Rightarrow> 'a lclause \\<Rightarrow> bool\" where\n  \"resolvable A D CA Ls \\<longleftrightarrow>\n   (let \\<sigma> = (mgu {insert A (atms_of (mset Ls))}) in\n        \\<sigma> \\<noteq> None\n      \\<and> Ls \\<noteq> []\n      \\<and> maximal_wrt (A \\<cdot>a the \\<sigma>) ((add_mset (Neg A) (mset D)) \\<cdot> the \\<sigma>)\n      \\<and> strictly_maximal_wrt (A \\<cdot>a the \\<sigma>) ((mset CA - mset Ls) \\<cdot> the \\<sigma>)\n      \\<and> (\\<forall>L \\<in> set Ls. is_pos L))\""], ["", "definition resolve_on :: \"'a \\<Rightarrow> 'a lclause \\<Rightarrow> 'a lclause \\<Rightarrow> 'a lclause list\" where\n  \"resolve_on A D CA = map (resolvent D A CA) (filter (resolvable A D CA) (subseqs CA))\""], ["", "definition resolve :: \"'a lclause \\<Rightarrow> 'a lclause \\<Rightarrow> 'a lclause list\" where\n  \"resolve C D =\n   concat (map (\\<lambda>L.\n     (case L of\n        Pos A \\<Rightarrow> []\n      | Neg A \\<Rightarrow>\n        if maximal_wrt A (mset D) then\n          resolve_on A (remove1 L D) C\n        else\n          [])) D)\""], ["", "definition resolve_rename :: \"'a lclause \\<Rightarrow> 'a lclause \\<Rightarrow> 'a lclause list\" where\n  \"resolve_rename C D =\n   (let \\<sigma>s = renamings_apart [mset D, mset C] in\n      resolve (map (\\<lambda>L. L \\<cdot>l last \\<sigma>s) C) (map (\\<lambda>L. L \\<cdot>l hd \\<sigma>s) D))\""], ["", "definition resolve_rename_either_way :: \"'a lclause \\<Rightarrow> 'a lclause \\<Rightarrow> 'a lclause list\" where\n  \"resolve_rename_either_way C D = resolve_rename C D @ resolve_rename D C\""], ["", "fun select_min_weight_clause :: \"'a dclause \\<Rightarrow> 'a dclause list \\<Rightarrow> 'a dclause\" where\n  \"select_min_weight_clause Ci [] = Ci\"\n| \"select_min_weight_clause Ci (Dj # Djs) =\n   select_min_weight_clause\n     (if weight (apfst mset Dj) < weight (apfst mset Ci) then Dj else Ci) Djs\""], ["", "lemma select_min_weight_clause_in: \"select_min_weight_clause P0 P \\<in> set (P0 # P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select_min_weight_clause P0 P \\<in> set (P0 # P)", "by (induct P arbitrary: P0) auto"], ["", "function remdups_clss :: \"'a dclause list \\<Rightarrow> 'a dclause list\" where\n  \"remdups_clss [] = []\"\n| \"remdups_clss (Ci # Cis) =\n   (let\n      Ci' = select_min_weight_clause Ci Cis\n    in\n      Ci' # remdups_clss (filter (\\<lambda>(D, _). mset D \\<noteq> mset (fst Ci')) (Ci # Cis)))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>Ci Cis. x = Ci # Cis \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. [] = [] \\<Longrightarrow> [] = []\n 3. \\<And>Ci Cis.\n       [] = Ci # Cis \\<Longrightarrow>\n       [] =\n       (let Ci' = select_min_weight_clause Ci Cis\n        in Ci' #\n           remdups_clss_sumC\n            (filter (\\<lambda>(D, uu_). mset D \\<noteq> mset (fst Ci'))\n              (Ci # Cis)))\n 4. \\<And>Ci Cis Cia Cisa.\n       Ci # Cis = Cia # Cisa \\<Longrightarrow>\n       (let Ci' = select_min_weight_clause Ci Cis\n        in Ci' #\n           remdups_clss_sumC\n            (filter (\\<lambda>(D, uu_). mset D \\<noteq> mset (fst Ci'))\n              (Ci # Cis))) =\n       (let Ci' = select_min_weight_clause Cia Cisa\n        in Ci' #\n           remdups_clss_sumC\n            (filter (\\<lambda>(D, uu_). mset D \\<noteq> mset (fst Ci'))\n              (Cia # Cisa)))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All remdups_clss_dom", "apply (relation \"measure length\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>Ci Cis x.\n       x = select_min_weight_clause Ci Cis \\<Longrightarrow>\n       (filter (\\<lambda>(D, uu_). mset D \\<noteq> mset (fst x)) (Ci # Cis),\n        Ci # Cis)\n       \\<in> measure length", "apply (rule wf_measure)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ci Cis x.\n       x = select_min_weight_clause Ci Cis \\<Longrightarrow>\n       (filter (\\<lambda>(D, uu_). mset D \\<noteq> mset (fst x)) (Ci # Cis),\n        Ci # Cis)\n       \\<in> measure length", "by (metis (mono_tags) in_measure length_filter_less prod.case_eq_if select_min_weight_clause_in)"], ["", "declare remdups_clss.simps(2) [simp del]"], ["", "fun deterministic_RP_step :: \"'a dstate \\<Rightarrow> 'a dstate\" where\n  \"deterministic_RP_step (N, P, Q, n) =\n   (if \\<exists>Ci \\<in> set (P @ Q). fst Ci = [] then\n      ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\n    else\n      (case N of\n        [] \\<Rightarrow>\n        (case P of\n           [] \\<Rightarrow> (N, P, Q, n)\n         | P0 # P' \\<Rightarrow>\n           let\n             (C, i) = select_min_weight_clause P0 P';\n             N = map (\\<lambda>D. (D, n)) (remdups_gen mset (resolve_rename C C\n               @ concat (map (resolve_rename_either_way C \\<circ> fst) Q)));\n             P = filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P;\n             Q = (C, i) # Q;\n             n = Suc n\n           in\n             (N, P, Q, n))\n      | (C, i) # N \\<Rightarrow>\n        let\n          C = reduce (map fst (P @ Q)) [] C\n        in\n          if C = [] then\n            ([], [], [([], i)], Suc n)\n          else if is_tautology C \\<or> subsume (map fst (P @ Q)) C then\n            (N, P, Q, n)\n          else\n            let\n              P = reduce_all C P;\n              (back_to_P, Q) = reduce_all2 C Q;\n              P = back_to_P @ P;\n              Q = filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) Q;\n              P = filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P;\n              P = (C, i) # P\n            in\n              (N, P, Q, n)))\""], ["", "declare deterministic_RP_step.simps [simp del]"], ["", "partial_function (option) deterministic_RP :: \"'a dstate \\<Rightarrow> 'a lclause list option\" where\n  \"deterministic_RP St =\n   (if is_final_dstate St then\n      let (_, _, Q, _) = St in Some (map fst Q)\n    else\n      deterministic_RP (deterministic_RP_step St))\""], ["", "lemma is_final_dstate_imp_not_weighted_RP: \"is_final_dstate St \\<Longrightarrow> \\<not> wstate_of_dstate St \\<leadsto>\\<^sub>w St'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_final_dstate St \\<Longrightarrow>\n    \\<not> wstate_of_dstate St \\<leadsto>\\<^sub>w St'", "using wrp.final_weighted_RP"], ["proof (prove)\nusing this:\n  \\<not> ({#}, {#}, ?Q, ?n) \\<leadsto>\\<^sub>w ?St\n\ngoal (1 subgoal):\n 1. is_final_dstate St \\<Longrightarrow>\n    \\<not> wstate_of_dstate St \\<leadsto>\\<^sub>w St'", "by (cases St) (auto intro: wrp.final_weighted_RP simp: is_final_dstate.simps)"], ["", "lemma is_final_dstate_funpow_imp_deterministic_RP_neq_None:\n  \"is_final_dstate ((deterministic_RP_step ^^ k) St) \\<Longrightarrow> deterministic_RP St \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_final_dstate ((deterministic_RP_step ^^ k) St) \\<Longrightarrow>\n    deterministic_RP St \\<noteq> None", "proof (induct k arbitrary: St)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>St.\n       is_final_dstate ((deterministic_RP_step ^^ 0) St) \\<Longrightarrow>\n       deterministic_RP St \\<noteq> None\n 2. \\<And>k St.\n       \\<lbrakk>\\<And>St.\n                   is_final_dstate\n                    ((deterministic_RP_step ^^ k) St) \\<Longrightarrow>\n                   deterministic_RP St \\<noteq> None;\n        is_final_dstate ((deterministic_RP_step ^^ Suc k) St)\\<rbrakk>\n       \\<Longrightarrow> deterministic_RP St \\<noteq> None", "case (Suc k)"], ["proof (state)\nthis:\n  is_final_dstate ((deterministic_RP_step ^^ k) ?St) \\<Longrightarrow>\n  deterministic_RP ?St \\<noteq> None\n  is_final_dstate ((deterministic_RP_step ^^ Suc k) St)\n\ngoal (2 subgoals):\n 1. \\<And>St.\n       is_final_dstate ((deterministic_RP_step ^^ 0) St) \\<Longrightarrow>\n       deterministic_RP St \\<noteq> None\n 2. \\<And>k St.\n       \\<lbrakk>\\<And>St.\n                   is_final_dstate\n                    ((deterministic_RP_step ^^ k) St) \\<Longrightarrow>\n                   deterministic_RP St \\<noteq> None;\n        is_final_dstate ((deterministic_RP_step ^^ Suc k) St)\\<rbrakk>\n       \\<Longrightarrow> deterministic_RP St \\<noteq> None", "note ih = this(1) and final_Sk = this(2)[simplified, unfolded funpow_swap1]"], ["proof (state)\nthis:\n  is_final_dstate ((deterministic_RP_step ^^ k) ?St) \\<Longrightarrow>\n  deterministic_RP ?St \\<noteq> None\n  is_final_dstate ((deterministic_RP_step ^^ k) (deterministic_RP_step St))\n\ngoal (2 subgoals):\n 1. \\<And>St.\n       is_final_dstate ((deterministic_RP_step ^^ 0) St) \\<Longrightarrow>\n       deterministic_RP St \\<noteq> None\n 2. \\<And>k St.\n       \\<lbrakk>\\<And>St.\n                   is_final_dstate\n                    ((deterministic_RP_step ^^ k) St) \\<Longrightarrow>\n                   deterministic_RP St \\<noteq> None;\n        is_final_dstate ((deterministic_RP_step ^^ Suc k) St)\\<rbrakk>\n       \\<Longrightarrow> deterministic_RP St \\<noteq> None", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic_RP St \\<noteq> None", "using ih[OF final_Sk]"], ["proof (prove)\nusing this:\n  deterministic_RP (deterministic_RP_step St) \\<noteq> None\n\ngoal (1 subgoal):\n 1. deterministic_RP St \\<noteq> None", "by (subst deterministic_RP.simps) (simp add: prod.case_eq_if)"], ["proof (state)\nthis:\n  deterministic_RP St \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>St.\n       is_final_dstate ((deterministic_RP_step ^^ 0) St) \\<Longrightarrow>\n       deterministic_RP St \\<noteq> None", "qed (subst deterministic_RP.simps, simp add: prod.case_eq_if)"], ["", "lemma is_reducible_lit_mono_cls:\n  \"mset C \\<subseteq># mset C' \\<Longrightarrow> is_reducible_lit Ds C L \\<Longrightarrow> is_reducible_lit Ds C' L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mset C \\<subseteq># mset C'; is_reducible_lit Ds C L\\<rbrakk>\n    \\<Longrightarrow> is_reducible_lit Ds C' L", "unfolding is_reducible_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mset C \\<subseteq># mset C';\n     \\<exists>D\\<in>set Ds.\n        \\<exists>L'\\<in>set D.\n           \\<exists>\\<sigma>.\n              - L = L' \\<cdot>l \\<sigma> \\<and>\n              mset (remove1 L' D) \\<cdot> \\<sigma> \\<subseteq>#\n              mset C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D\\<in>set Ds.\n                         \\<exists>L'\\<in>set D.\n                            \\<exists>\\<sigma>.\n                               - L = L' \\<cdot>l \\<sigma> \\<and>\n                               mset (remove1 L' D) \\<cdot>\n                               \\<sigma> \\<subseteq>#\n                               mset C'", "by (blast intro: subset_mset.order.trans)"], ["", "lemma is_reducible_lit_mset_iff:\n  \"mset C = mset C' \\<Longrightarrow> is_reducible_lit Ds C' L \\<longleftrightarrow> is_reducible_lit Ds C L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset C = mset C' \\<Longrightarrow>\n    is_reducible_lit Ds C' L = is_reducible_lit Ds C L", "by (metis is_reducible_lit_mono_cls subset_mset.order_refl)"], ["", "lemma is_reducible_lit_remove1_Cons_iff:\n  assumes \"L \\<in> set C'\"\n  shows \"is_reducible_lit Ds (C @ remove1 L (M # C')) L \\<longleftrightarrow>\n    is_reducible_lit Ds (M # C @ remove1 L C') L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_reducible_lit Ds (C @ remove1 L (M # C')) L =\n    is_reducible_lit Ds (M # C @ remove1 L C') L", "using assms"], ["proof (prove)\nusing this:\n  L \\<in> set C'\n\ngoal (1 subgoal):\n 1. is_reducible_lit Ds (C @ remove1 L (M # C')) L =\n    is_reducible_lit Ds (M # C @ remove1 L C') L", "by (subst is_reducible_lit_mset_iff, auto)"], ["", "lemma reduce_mset_eq: \"mset C = mset C' \\<Longrightarrow> reduce Ds C E = reduce Ds C' E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset C = mset C' \\<Longrightarrow> reduce Ds C E = reduce Ds C' E", "proof (induct E arbitrary: C C')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C C'.\n       mset C = mset C' \\<Longrightarrow> reduce Ds C [] = reduce Ds C' []\n 2. \\<And>a E C C'.\n       \\<lbrakk>\\<And>C C'.\n                   mset C = mset C' \\<Longrightarrow>\n                   reduce Ds C E = reduce Ds C' E;\n        mset C = mset C'\\<rbrakk>\n       \\<Longrightarrow> reduce Ds C (a # E) = reduce Ds C' (a # E)", "case (Cons L E)"], ["proof (state)\nthis:\n  mset ?C = mset ?C' \\<Longrightarrow> reduce Ds ?C E = reduce Ds ?C' E\n  mset C = mset C'\n\ngoal (2 subgoals):\n 1. \\<And>C C'.\n       mset C = mset C' \\<Longrightarrow> reduce Ds C [] = reduce Ds C' []\n 2. \\<And>a E C C'.\n       \\<lbrakk>\\<And>C C'.\n                   mset C = mset C' \\<Longrightarrow>\n                   reduce Ds C E = reduce Ds C' E;\n        mset C = mset C'\\<rbrakk>\n       \\<Longrightarrow> reduce Ds C (a # E) = reduce Ds C' (a # E)", "note ih = this(1) and mset_eq = this(2)"], ["proof (state)\nthis:\n  mset ?C = mset ?C' \\<Longrightarrow> reduce Ds ?C E = reduce Ds ?C' E\n  mset C = mset C'\n\ngoal (2 subgoals):\n 1. \\<And>C C'.\n       mset C = mset C' \\<Longrightarrow> reduce Ds C [] = reduce Ds C' []\n 2. \\<And>a E C C'.\n       \\<lbrakk>\\<And>C C'.\n                   mset C = mset C' \\<Longrightarrow>\n                   reduce Ds C E = reduce Ds C' E;\n        mset C = mset C'\\<rbrakk>\n       \\<Longrightarrow> reduce Ds C (a # E) = reduce Ds C' (a # E)", "have\n    mset_lc_eq: \"mset (L # C) = mset (L # C')\" and\n    mset_ce_eq: \"mset (C @ E) = mset (C' @ E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (L # C) = mset (L # C') &&& mset (C @ E) = mset (C' @ E)", "using mset_eq"], ["proof (prove)\nusing this:\n  mset C = mset C'\n\ngoal (1 subgoal):\n 1. mset (L # C) = mset (L # C') &&& mset (C @ E) = mset (C' @ E)", "by simp+"], ["proof (state)\nthis:\n  mset (L # C) = mset (L # C')\n  mset (C @ E) = mset (C' @ E)\n\ngoal (2 subgoals):\n 1. \\<And>C C'.\n       mset C = mset C' \\<Longrightarrow> reduce Ds C [] = reduce Ds C' []\n 2. \\<And>a E C C'.\n       \\<lbrakk>\\<And>C C'.\n                   mset C = mset C' \\<Longrightarrow>\n                   reduce Ds C E = reduce Ds C' E;\n        mset C = mset C'\\<rbrakk>\n       \\<Longrightarrow> reduce Ds C (a # E) = reduce Ds C' (a # E)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce Ds C (L # E) = reduce Ds C' (L # E)", "using ih[OF mset_eq] ih[OF mset_lc_eq]"], ["proof (prove)\nusing this:\n  reduce Ds C E = reduce Ds C' E\n  reduce Ds (L # C) E = reduce Ds (L # C') E\n\ngoal (1 subgoal):\n 1. reduce Ds C (L # E) = reduce Ds C' (L # E)", "by (simp add: is_reducible_lit_mset_iff[OF mset_ce_eq])"], ["proof (state)\nthis:\n  reduce Ds C (L # E) = reduce Ds C' (L # E)\n\ngoal (1 subgoal):\n 1. \\<And>C C'.\n       mset C = mset C' \\<Longrightarrow> reduce Ds C [] = reduce Ds C' []", "qed simp"], ["", "lemma reduce_rotate[simp]: \"reduce Ds (C @ [L]) E = reduce Ds (L # C) E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce Ds (C @ [L]) E = reduce Ds (L # C) E", "by (rule reduce_mset_eq) simp"], ["", "lemma mset_reduce_subset: \"mset (reduce Ds C E) \\<subseteq># mset E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (reduce Ds C E) \\<subseteq># mset E", "by (induct E arbitrary: C) (auto intro: subset_mset_imp_subset_add_mset)"], ["", "lemma reduce_idem: \"reduce Ds C (reduce Ds C E) = reduce Ds C E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce Ds C (reduce Ds C E) = reduce Ds C E", "by (induct E arbitrary: C)\n    (auto intro!: mset_reduce_subset\n      dest!: is_reducible_lit_mono_cls[of \"C @ reduce Ds (L # C) E\" \"C @ E\" Ds L for L E C,\n        rotated])"], ["", "lemma is_reducible_lit_imp_is_reducible:\n  \"L \\<in> set C' \\<Longrightarrow> is_reducible_lit Ds (C @ remove1 L C') L \\<Longrightarrow> reduce Ds C C' \\<noteq> C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L \\<in> set C';\n     is_reducible_lit Ds (C @ remove1 L C') L\\<rbrakk>\n    \\<Longrightarrow> reduce Ds C C' \\<noteq> C'", "proof (induct C' arbitrary: C)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>L \\<in> set [];\n        is_reducible_lit Ds (C @ remove1 L []) L\\<rbrakk>\n       \\<Longrightarrow> reduce Ds C [] \\<noteq> []\n 2. \\<And>a C' C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>L \\<in> set C';\n                    is_reducible_lit Ds (C @ remove1 L C') L\\<rbrakk>\n                   \\<Longrightarrow> reduce Ds C C' \\<noteq> C';\n        L \\<in> set (a # C');\n        is_reducible_lit Ds (C @ remove1 L (a # C')) L\\<rbrakk>\n       \\<Longrightarrow> reduce Ds C (a # C') \\<noteq> a # C'", "case (Cons M C')"], ["proof (state)\nthis:\n  \\<lbrakk>L \\<in> set C';\n   is_reducible_lit Ds (?C @ remove1 L C') L\\<rbrakk>\n  \\<Longrightarrow> reduce Ds ?C C' \\<noteq> C'\n  L \\<in> set (M # C')\n  is_reducible_lit Ds (C @ remove1 L (M # C')) L\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>L \\<in> set [];\n        is_reducible_lit Ds (C @ remove1 L []) L\\<rbrakk>\n       \\<Longrightarrow> reduce Ds C [] \\<noteq> []\n 2. \\<And>a C' C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>L \\<in> set C';\n                    is_reducible_lit Ds (C @ remove1 L C') L\\<rbrakk>\n                   \\<Longrightarrow> reduce Ds C C' \\<noteq> C';\n        L \\<in> set (a # C');\n        is_reducible_lit Ds (C @ remove1 L (a # C')) L\\<rbrakk>\n       \\<Longrightarrow> reduce Ds C (a # C') \\<noteq> a # C'", "note ih = this(1) and l_in = this(2) and l_red = this(3)"], ["proof (state)\nthis:\n  \\<lbrakk>L \\<in> set C';\n   is_reducible_lit Ds (?C @ remove1 L C') L\\<rbrakk>\n  \\<Longrightarrow> reduce Ds ?C C' \\<noteq> C'\n  L \\<in> set (M # C')\n  is_reducible_lit Ds (C @ remove1 L (M # C')) L\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>L \\<in> set [];\n        is_reducible_lit Ds (C @ remove1 L []) L\\<rbrakk>\n       \\<Longrightarrow> reduce Ds C [] \\<noteq> []\n 2. \\<And>a C' C.\n       \\<lbrakk>\\<And>C.\n                   \\<lbrakk>L \\<in> set C';\n                    is_reducible_lit Ds (C @ remove1 L C') L\\<rbrakk>\n                   \\<Longrightarrow> reduce Ds C C' \\<noteq> C';\n        L \\<in> set (a # C');\n        is_reducible_lit Ds (C @ remove1 L (a # C')) L\\<rbrakk>\n       \\<Longrightarrow> reduce Ds C (a # C') \\<noteq> a # C'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce Ds C (M # C') \\<noteq> M # C'", "proof (cases \"is_reducible_lit Ds (C @ C') M\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    reduce Ds C (M # C') \\<noteq> M # C'\n 2. \\<not> is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    reduce Ds C (M # C') \\<noteq> M # C'", "case True"], ["proof (state)\nthis:\n  is_reducible_lit Ds (C @ C') M\n\ngoal (2 subgoals):\n 1. is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    reduce Ds C (M # C') \\<noteq> M # C'\n 2. \\<not> is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    reduce Ds C (M # C') \\<noteq> M # C'", "then"], ["proof (chain)\npicking this:\n  is_reducible_lit Ds (C @ C') M", "show ?thesis"], ["proof (prove)\nusing this:\n  is_reducible_lit Ds (C @ C') M\n\ngoal (1 subgoal):\n 1. reduce Ds C (M # C') \\<noteq> M # C'", "by simp (metis mset.simps(2) mset_reduce_subset multi_self_add_other_not_self\n          subset_mset.eq_iff subset_mset_imp_subset_add_mset)"], ["proof (state)\nthis:\n  reduce Ds C (M # C') \\<noteq> M # C'\n\ngoal (1 subgoal):\n 1. \\<not> is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    reduce Ds C (M # C') \\<noteq> M # C'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    reduce Ds C (M # C') \\<noteq> M # C'", "case m_irred: False"], ["proof (state)\nthis:\n  \\<not> is_reducible_lit Ds (C @ C') M\n\ngoal (1 subgoal):\n 1. \\<not> is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    reduce Ds C (M # C') \\<noteq> M # C'", "have\n      \"L \\<in> set C'\" and\n      \"is_reducible_lit Ds (M # C @ remove1 L C') L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<in> set C' &&& is_reducible_lit Ds (M # C @ remove1 L C') L", "using l_in l_red m_irred is_reducible_lit_remove1_Cons_iff"], ["proof (prove)\nusing this:\n  L \\<in> set (M # C')\n  is_reducible_lit Ds (C @ remove1 L (M # C')) L\n  \\<not> is_reducible_lit Ds (C @ C') M\n  ?L \\<in> set ?C' \\<Longrightarrow>\n  is_reducible_lit ?Ds (?C @ remove1 ?L (?M # ?C')) ?L =\n  is_reducible_lit ?Ds (?M # ?C @ remove1 ?L ?C') ?L\n\ngoal (1 subgoal):\n 1. L \\<in> set C' &&& is_reducible_lit Ds (M # C @ remove1 L C') L", "by auto"], ["proof (state)\nthis:\n  L \\<in> set C'\n  is_reducible_lit Ds (M # C @ remove1 L C') L\n\ngoal (1 subgoal):\n 1. \\<not> is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    reduce Ds C (M # C') \\<noteq> M # C'", "then"], ["proof (chain)\npicking this:\n  L \\<in> set C'\n  is_reducible_lit Ds (M # C @ remove1 L C') L", "show ?thesis"], ["proof (prove)\nusing this:\n  L \\<in> set C'\n  is_reducible_lit Ds (M # C @ remove1 L C') L\n\ngoal (1 subgoal):\n 1. reduce Ds C (M # C') \\<noteq> M # C'", "by (simp add: ih[of \"M # C\"] m_irred)"], ["proof (state)\nthis:\n  reduce Ds C (M # C') \\<noteq> M # C'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reduce Ds C (M # C') \\<noteq> M # C'\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>L \\<in> set [];\n        is_reducible_lit Ds (C @ remove1 L []) L\\<rbrakk>\n       \\<Longrightarrow> reduce Ds C [] \\<noteq> []", "qed simp"], ["", "lemma is_reducible_imp_is_reducible_lit:\n  \"reduce Ds C C' \\<noteq> C' \\<Longrightarrow> \\<exists>L \\<in> set C'. is_reducible_lit Ds (C @ remove1 L C') L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce Ds C C' \\<noteq> C' \\<Longrightarrow>\n    \\<exists>L\\<in>set C'. is_reducible_lit Ds (C @ remove1 L C') L", "proof (induct C' arbitrary: C)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       reduce Ds C [] \\<noteq> [] \\<Longrightarrow>\n       \\<exists>L\\<in>set []. is_reducible_lit Ds (C @ remove1 L []) L\n 2. \\<And>a C' C.\n       \\<lbrakk>\\<And>C.\n                   reduce Ds C C' \\<noteq> C' \\<Longrightarrow>\n                   \\<exists>L\\<in>set C'.\n                      is_reducible_lit Ds (C @ remove1 L C') L;\n        reduce Ds C (a # C') \\<noteq> a # C'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L\\<in>set (a # C').\n                            is_reducible_lit Ds (C @ remove1 L (a # C')) L", "case (Cons M C')"], ["proof (state)\nthis:\n  reduce Ds ?C C' \\<noteq> C' \\<Longrightarrow>\n  \\<exists>L\\<in>set C'. is_reducible_lit Ds (?C @ remove1 L C') L\n  reduce Ds C (M # C') \\<noteq> M # C'\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       reduce Ds C [] \\<noteq> [] \\<Longrightarrow>\n       \\<exists>L\\<in>set []. is_reducible_lit Ds (C @ remove1 L []) L\n 2. \\<And>a C' C.\n       \\<lbrakk>\\<And>C.\n                   reduce Ds C C' \\<noteq> C' \\<Longrightarrow>\n                   \\<exists>L\\<in>set C'.\n                      is_reducible_lit Ds (C @ remove1 L C') L;\n        reduce Ds C (a # C') \\<noteq> a # C'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L\\<in>set (a # C').\n                            is_reducible_lit Ds (C @ remove1 L (a # C')) L", "note ih = this(1) and mc'_red = this(2)"], ["proof (state)\nthis:\n  reduce Ds ?C C' \\<noteq> C' \\<Longrightarrow>\n  \\<exists>L\\<in>set C'. is_reducible_lit Ds (?C @ remove1 L C') L\n  reduce Ds C (M # C') \\<noteq> M # C'\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       reduce Ds C [] \\<noteq> [] \\<Longrightarrow>\n       \\<exists>L\\<in>set []. is_reducible_lit Ds (C @ remove1 L []) L\n 2. \\<And>a C' C.\n       \\<lbrakk>\\<And>C.\n                   reduce Ds C C' \\<noteq> C' \\<Longrightarrow>\n                   \\<exists>L\\<in>set C'.\n                      is_reducible_lit Ds (C @ remove1 L C') L;\n        reduce Ds C (a # C') \\<noteq> a # C'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>L\\<in>set (a # C').\n                            is_reducible_lit Ds (C @ remove1 L (a # C')) L", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>set (M # C').\n       is_reducible_lit Ds (C @ remove1 L (M # C')) L", "proof (cases \"is_reducible_lit Ds (C @ C') M\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    \\<exists>L\\<in>set (M # C').\n       is_reducible_lit Ds (C @ remove1 L (M # C')) L\n 2. \\<not> is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    \\<exists>L\\<in>set (M # C').\n       is_reducible_lit Ds (C @ remove1 L (M # C')) L", "case m_irred: False"], ["proof (state)\nthis:\n  \\<not> is_reducible_lit Ds (C @ C') M\n\ngoal (2 subgoals):\n 1. is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    \\<exists>L\\<in>set (M # C').\n       is_reducible_lit Ds (C @ remove1 L (M # C')) L\n 2. \\<not> is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    \\<exists>L\\<in>set (M # C').\n       is_reducible_lit Ds (C @ remove1 L (M # C')) L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>set (M # C').\n       is_reducible_lit Ds (C @ remove1 L (M # C')) L", "using ih[of \"M # C\"] mc'_red[simplified, simplified m_irred, simplified] m_irred\n        is_reducible_lit_remove1_Cons_iff"], ["proof (prove)\nusing this:\n  reduce Ds (M # C) C' \\<noteq> C' \\<Longrightarrow>\n  \\<exists>L\\<in>set C'. is_reducible_lit Ds ((M # C) @ remove1 L C') L\n  reduce Ds (M # C) C' \\<noteq> C'\n  \\<not> is_reducible_lit Ds (C @ C') M\n  ?L \\<in> set ?C' \\<Longrightarrow>\n  is_reducible_lit ?Ds (?C @ remove1 ?L (?M # ?C')) ?L =\n  is_reducible_lit ?Ds (?M # ?C @ remove1 ?L ?C') ?L\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>set (M # C').\n       is_reducible_lit Ds (C @ remove1 L (M # C')) L", "by auto"], ["proof (state)\nthis:\n  \\<exists>L\\<in>set (M # C').\n     is_reducible_lit Ds (C @ remove1 L (M # C')) L\n\ngoal (1 subgoal):\n 1. is_reducible_lit Ds (C @ C') M \\<Longrightarrow>\n    \\<exists>L\\<in>set (M # C').\n       is_reducible_lit Ds (C @ remove1 L (M # C')) L", "qed simp"], ["proof (state)\nthis:\n  \\<exists>L\\<in>set (M # C').\n     is_reducible_lit Ds (C @ remove1 L (M # C')) L\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       reduce Ds C [] \\<noteq> [] \\<Longrightarrow>\n       \\<exists>L\\<in>set []. is_reducible_lit Ds (C @ remove1 L []) L", "qed simp"], ["", "lemma is_irreducible_iff_nexists_is_reducible_lit:\n  \"reduce Ds C C' = C' \\<longleftrightarrow> \\<not> (\\<exists>L \\<in> set C'. is_reducible_lit Ds (C @ remove1 L C') L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (reduce Ds C C' = C') =\n    (\\<not> (\\<exists>L\\<in>set C'.\n                is_reducible_lit Ds (C @ remove1 L C') L))", "using is_reducible_imp_is_reducible_lit is_reducible_lit_imp_is_reducible"], ["proof (prove)\nusing this:\n  reduce ?Ds ?C ?C' \\<noteq> ?C' \\<Longrightarrow>\n  \\<exists>L\\<in>set ?C'. is_reducible_lit ?Ds (?C @ remove1 L ?C') L\n  \\<lbrakk>?L \\<in> set ?C';\n   is_reducible_lit ?Ds (?C @ remove1 ?L ?C') ?L\\<rbrakk>\n  \\<Longrightarrow> reduce ?Ds ?C ?C' \\<noteq> ?C'\n\ngoal (1 subgoal):\n 1. (reduce Ds C C' = C') =\n    (\\<not> (\\<exists>L\\<in>set C'.\n                is_reducible_lit Ds (C @ remove1 L C') L))", "by blast"], ["", "lemma is_irreducible_mset_iff: \"mset E = mset E' \\<Longrightarrow> reduce Ds C E = E \\<longleftrightarrow> reduce Ds C E' = E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset E = mset E' \\<Longrightarrow>\n    (reduce Ds C E = E) = (reduce Ds C E' = E')", "unfolding is_irreducible_iff_nexists_is_reducible_lit"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset E = mset E' \\<Longrightarrow>\n    (\\<not> (\\<exists>L\\<in>set E.\n                is_reducible_lit Ds (C @ remove1 L E) L)) =\n    (\\<not> (\\<exists>L\\<in>set E'.\n                is_reducible_lit Ds (C @ remove1 L E') L))", "by (metis (full_types) is_reducible_lit_mset_iff mset_remove1 set_mset_mset union_code)"], ["", "lemma select_min_weight_clause_min_weight:\n  assumes \"Ci = select_min_weight_clause P0 P\"\n  shows \"weight (apfst mset Ci) = Min ((weight \\<circ> apfst mset) ` set (P0 # P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P))", "using assms"], ["proof (prove)\nusing this:\n  Ci = select_min_weight_clause P0 P\n\ngoal (1 subgoal):\n 1. weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P))", "proof (induct P arbitrary: P0 Ci)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P0 Ci.\n       Ci = select_min_weight_clause P0 [] \\<Longrightarrow>\n       weight (apfst mset Ci) = Min ((weight \\<circ> apfst mset) ` set [P0])\n 2. \\<And>a P P0 Ci.\n       \\<lbrakk>\\<And>P0 Ci.\n                   Ci = select_min_weight_clause P0 P \\<Longrightarrow>\n                   weight (apfst mset Ci) =\n                   Min ((weight \\<circ> apfst mset) ` set (P0 # P));\n        Ci = select_min_weight_clause P0 (a # P)\\<rbrakk>\n       \\<Longrightarrow> weight (apfst mset Ci) =\n                         Min ((weight \\<circ> apfst mset) `\n                              set (P0 # a # P))", "case (Cons P1 P)"], ["proof (state)\nthis:\n  ?Ci = select_min_weight_clause ?P0.0 P \\<Longrightarrow>\n  weight (apfst mset ?Ci) =\n  Min ((weight \\<circ> apfst mset) ` set (?P0.0 # P))\n  Ci = select_min_weight_clause P0 (P1 # P)\n\ngoal (2 subgoals):\n 1. \\<And>P0 Ci.\n       Ci = select_min_weight_clause P0 [] \\<Longrightarrow>\n       weight (apfst mset Ci) = Min ((weight \\<circ> apfst mset) ` set [P0])\n 2. \\<And>a P P0 Ci.\n       \\<lbrakk>\\<And>P0 Ci.\n                   Ci = select_min_weight_clause P0 P \\<Longrightarrow>\n                   weight (apfst mset Ci) =\n                   Min ((weight \\<circ> apfst mset) ` set (P0 # P));\n        Ci = select_min_weight_clause P0 (a # P)\\<rbrakk>\n       \\<Longrightarrow> weight (apfst mset Ci) =\n                         Min ((weight \\<circ> apfst mset) `\n                              set (P0 # a # P))", "note ih = this(1) and ci = this(2)"], ["proof (state)\nthis:\n  ?Ci = select_min_weight_clause ?P0.0 P \\<Longrightarrow>\n  weight (apfst mset ?Ci) =\n  Min ((weight \\<circ> apfst mset) ` set (?P0.0 # P))\n  Ci = select_min_weight_clause P0 (P1 # P)\n\ngoal (2 subgoals):\n 1. \\<And>P0 Ci.\n       Ci = select_min_weight_clause P0 [] \\<Longrightarrow>\n       weight (apfst mset Ci) = Min ((weight \\<circ> apfst mset) ` set [P0])\n 2. \\<And>a P P0 Ci.\n       \\<lbrakk>\\<And>P0 Ci.\n                   Ci = select_min_weight_clause P0 P \\<Longrightarrow>\n                   weight (apfst mset Ci) =\n                   Min ((weight \\<circ> apfst mset) ` set (P0 # P));\n        Ci = select_min_weight_clause P0 (a # P)\\<rbrakk>\n       \\<Longrightarrow> weight (apfst mset Ci) =\n                         Min ((weight \\<circ> apfst mset) `\n                              set (P0 # a # P))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))", "proof (cases \"weight (apfst mset P1) < weight (apfst mset P0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. weight (apfst mset P1) < weight (apfst mset P0) \\<Longrightarrow>\n    weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))\n 2. \\<not> weight (apfst mset P1) < weight (apfst mset P0) \\<Longrightarrow>\n    weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))", "case True"], ["proof (state)\nthis:\n  weight (apfst mset P1) < weight (apfst mset P0)\n\ngoal (2 subgoals):\n 1. weight (apfst mset P1) < weight (apfst mset P0) \\<Longrightarrow>\n    weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))\n 2. \\<not> weight (apfst mset P1) < weight (apfst mset P0) \\<Longrightarrow>\n    weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))", "then"], ["proof (chain)\npicking this:\n  weight (apfst mset P1) < weight (apfst mset P0)", "have min: \"Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P)) =\n      Min ((weight \\<circ> apfst mset) ` set (P1 # P))\""], ["proof (prove)\nusing this:\n  weight (apfst mset P1) < weight (apfst mset P0)\n\ngoal (1 subgoal):\n 1. Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P)) =\n    Min ((weight \\<circ> apfst mset) ` set (P1 # P))", "by (simp add: min_def)"], ["proof (state)\nthis:\n  Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P)) =\n  Min ((weight \\<circ> apfst mset) ` set (P1 # P))\n\ngoal (2 subgoals):\n 1. weight (apfst mset P1) < weight (apfst mset P0) \\<Longrightarrow>\n    weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))\n 2. \\<not> weight (apfst mset P1) < weight (apfst mset P0) \\<Longrightarrow>\n    weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))", "unfolding min"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P1 # P))", "by (rule ih[of Ci P1]) (simp add: ih[of Ci P1] ci True)"], ["proof (state)\nthis:\n  weight (apfst mset Ci) =\n  Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))\n\ngoal (1 subgoal):\n 1. \\<not> weight (apfst mset P1) < weight (apfst mset P0) \\<Longrightarrow>\n    weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> weight (apfst mset P1) < weight (apfst mset P0) \\<Longrightarrow>\n    weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))", "case False"], ["proof (state)\nthis:\n  \\<not> weight (apfst mset P1) < weight (apfst mset P0)\n\ngoal (1 subgoal):\n 1. \\<not> weight (apfst mset P1) < weight (apfst mset P0) \\<Longrightarrow>\n    weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))", "have \"Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P)) =\n      Min ((weight \\<circ> apfst mset) ` set (P1 # P0 # P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P)) =\n    Min ((weight \\<circ> apfst mset) ` set (P1 # P0 # P))", "by (rule arg_cong[of _ _ Min]) auto"], ["proof (state)\nthis:\n  Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P)) =\n  Min ((weight \\<circ> apfst mset) ` set (P1 # P0 # P))\n\ngoal (1 subgoal):\n 1. \\<not> weight (apfst mset P1) < weight (apfst mset P0) \\<Longrightarrow>\n    weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))", "then"], ["proof (chain)\npicking this:\n  Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P)) =\n  Min ((weight \\<circ> apfst mset) ` set (P1 # P0 # P))", "have min: \"Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P)) =\n      Min ((weight \\<circ> apfst mset) ` set (P0 # P))\""], ["proof (prove)\nusing this:\n  Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P)) =\n  Min ((weight \\<circ> apfst mset) ` set (P1 # P0 # P))\n\ngoal (1 subgoal):\n 1. Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P)) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P))", "by (simp add: min_def) (use False eq_iff in fastforce)"], ["proof (state)\nthis:\n  Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P)) =\n  Min ((weight \\<circ> apfst mset) ` set (P0 # P))\n\ngoal (1 subgoal):\n 1. \\<not> weight (apfst mset P1) < weight (apfst mset P0) \\<Longrightarrow>\n    weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))", "unfolding min"], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (apfst mset Ci) =\n    Min ((weight \\<circ> apfst mset) ` set (P0 # P))", "by (rule ih[of Ci P0]) (simp add: ih[of Ci P1] ci False)"], ["proof (state)\nthis:\n  weight (apfst mset Ci) =\n  Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  weight (apfst mset Ci) =\n  Min ((weight \\<circ> apfst mset) ` set (P0 # P1 # P))\n\ngoal (1 subgoal):\n 1. \\<And>P0 Ci.\n       Ci = select_min_weight_clause P0 [] \\<Longrightarrow>\n       weight (apfst mset Ci) = Min ((weight \\<circ> apfst mset) ` set [P0])", "qed simp"], ["", "lemma remdups_clss_Nil_iff: \"remdups_clss Cs = [] \\<longleftrightarrow> Cs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (remdups_clss Cs = []) = (Cs = [])", "by (cases Cs, simp, hypsubst, subst remdups_clss.simps(2), simp add: Let_def)"], ["", "lemma empty_N_if_Nil_in_P_or_Q:\n  assumes nil_in: \"[] \\<in> fst ` set (P @ Q)\"\n  shows \"wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ([], P, Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ([], P, Q, n)", "proof (induct N)"], ["proof (state)\ngoal (2 subgoals):\n 1. wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ([], P, Q, n)\n 2. \\<And>a N.\n       wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate ([], P, Q, n) \\<Longrightarrow>\n       wstate_of_dstate (a # N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate ([], P, Q, n)", "case ih: (Cons N0 N)"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], P, Q, n)\n\ngoal (2 subgoals):\n 1. wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ([], P, Q, n)\n 2. \\<And>a N.\n       wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate ([], P, Q, n) \\<Longrightarrow>\n       wstate_of_dstate (a # N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate ([], P, Q, n)", "have \"wstate_of_dstate (N0 # N, P, Q, n) \\<leadsto>\\<^sub>w wstate_of_dstate (N, P, Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N0 # N, P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N, P, Q, n)", "by (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w)\", OF _ _\n          wrp.forward_subsumption[of \"{#}\" \"mset (map (apfst mset) P)\" \"mset (map (apfst mset) Q)\"\n            \"mset (fst N0)\" \"mset (map (apfst mset) N)\" \"snd N0\" n]])\n      (use nil_in in \\<open>force simp: image_def apfst_fst_snd\\<close>)+"], ["proof (state)\nthis:\n  wstate_of_dstate (N0 # N, P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, P, Q, n)\n\ngoal (2 subgoals):\n 1. wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ([], P, Q, n)\n 2. \\<And>a N.\n       wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate ([], P, Q, n) \\<Longrightarrow>\n       wstate_of_dstate (a # N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate ([], P, Q, n)", "then"], ["proof (chain)\npicking this:\n  wstate_of_dstate (N0 # N, P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, P, Q, n)", "show ?case"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N0 # N, P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N0 # N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ([], P, Q, n)", "using ih"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N0 # N, P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, P, Q, n)\n  wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N0 # N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ([], P, Q, n)", "by (rule converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  wstate_of_dstate (N0 # N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ([], P, Q, n)", "qed simp"], ["", "lemma remove_strictly_subsumed_clauses_in_P:\n  assumes\n    c_in: \"C \\<in> fst ` set N\" and\n    p_nsubs: \"\\<forall>D \\<in> fst ` set P. \\<not> strictly_subsume [C] D\"\n  shows \"wstate_of_dstate (N, P @ P', Q, n)\n    \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "using p_nsubs"], ["proof (prove)\nusing this:\n  \\<forall>D\\<in>fst ` set P. \\<not> strictly_subsume [C] D\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "proof (induct \"length P'\" arbitrary: P P' rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P' P.\n       \\<lbrakk>\\<And>P'a P.\n                   \\<lbrakk>length P'a < length P';\n                    \\<forall>D\\<in>fst ` set P.\n                       \\<not> strictly_subsume [C] D\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P'a, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P'a, Q, n);\n        \\<forall>D\\<in>fst ` set P. \\<not> strictly_subsume [C] D\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @\n                              filter\n                               (Not \\<circ> strictly_subsume [C] \\<circ>\n                                fst)\n                               P',\n                           Q, n)", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>length ?P' < length P';\n   \\<forall>D\\<in>fst ` set ?P. \\<not> strictly_subsume [C] D\\<rbrakk>\n  \\<Longrightarrow> wstate_of_dstate\n                     (N, ?P @ ?P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                    wstate_of_dstate\n                     (N, ?P @\n                         filter\n                          (Not \\<circ> strictly_subsume [C] \\<circ> fst)\n                          ?P',\n                      Q, n)\n  \\<forall>D\\<in>fst ` set P. \\<not> strictly_subsume [C] D\n\ngoal (1 subgoal):\n 1. \\<And>P' P.\n       \\<lbrakk>\\<And>P'a P.\n                   \\<lbrakk>length P'a < length P';\n                    \\<forall>D\\<in>fst ` set P.\n                       \\<not> strictly_subsume [C] D\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P'a, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P'a, Q, n);\n        \\<forall>D\\<in>fst ` set P. \\<not> strictly_subsume [C] D\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @\n                              filter\n                               (Not \\<circ> strictly_subsume [C] \\<circ>\n                                fst)\n                               P',\n                           Q, n)", "note ih = this(1) and p_nsubs = this(2)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?P' < length P';\n   \\<forall>D\\<in>fst ` set ?P. \\<not> strictly_subsume [C] D\\<rbrakk>\n  \\<Longrightarrow> wstate_of_dstate\n                     (N, ?P @ ?P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                    wstate_of_dstate\n                     (N, ?P @\n                         filter\n                          (Not \\<circ> strictly_subsume [C] \\<circ> fst)\n                          ?P',\n                      Q, n)\n  \\<forall>D\\<in>fst ` set P. \\<not> strictly_subsume [C] D\n\ngoal (1 subgoal):\n 1. \\<And>P' P.\n       \\<lbrakk>\\<And>P'a P.\n                   \\<lbrakk>length P'a < length P';\n                    \\<forall>D\\<in>fst ` set P.\n                       \\<not> strictly_subsume [C] D\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P'a, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P'a, Q, n);\n        \\<forall>D\\<in>fst ` set P. \\<not> strictly_subsume [C] D\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @\n                              filter\n                               (Not \\<circ> strictly_subsume [C] \\<circ>\n                                fst)\n                               P',\n                           Q, n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "proof (cases \"length P'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length P' = 0 \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<And>nat.\n       length P' = Suc nat \\<Longrightarrow>\n       wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q,\n         n)", "case Suc"], ["proof (state)\nthis:\n  length P' = Suc nat_\n\ngoal (2 subgoals):\n 1. length P' = 0 \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<And>nat.\n       length P' = Suc nat \\<Longrightarrow>\n       wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q,\n         n)", "let ?Dj = \"hd P'\""], ["proof (state)\ngoal (2 subgoals):\n 1. length P' = 0 \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<And>nat.\n       length P' = Suc nat \\<Longrightarrow>\n       wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q,\n         n)", "let ?P'' = \"tl P'\""], ["proof (state)\ngoal (2 subgoals):\n 1. length P' = 0 \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<And>nat.\n       length P' = Suc nat \\<Longrightarrow>\n       wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q,\n         n)", "have p': \"P' = hd P' # tl P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' = hd P' # tl P'", "using Suc"], ["proof (prove)\nusing this:\n  length P' = Suc nat_\n\ngoal (1 subgoal):\n 1. P' = hd P' # tl P'", "by (metis length_Suc_conv list.distinct(1) list.exhaust_sel)"], ["proof (state)\nthis:\n  P' = hd P' # tl P'\n\ngoal (2 subgoals):\n 1. length P' = 0 \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<And>nat.\n       length P' = Suc nat \\<Longrightarrow>\n       wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q,\n         n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "proof (cases \"strictly_subsume [C] (fst ?Dj)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "case subs: True"], ["proof (state)\nthis:\n  strictly_subsume [C] (fst (hd P'))\n\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "have p_filtered: \"{#(E, k) \\<in># image_mset (apfst mset) (mset P). E \\<noteq> mset (fst ?Dj)#} =\n        image_mset (apfst mset) (mset P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#(E, k) \\<in># image_mset (apfst mset) (mset P).\n     E \\<noteq> mset (fst (hd P'))#} =\n    image_mset (apfst mset) (mset P)", "by (rule filter_mset_cong[OF refl, of _ _ \"\\<lambda>_. True\", simplified],\n            use subs p_nsubs in \\<open>auto simp: strictly_subsume_def\\<close>)"], ["proof (state)\nthis:\n  {#(E, k) \\<in># image_mset (apfst mset) (mset P).\n   E \\<noteq> mset (fst (hd P'))#} =\n  image_mset (apfst mset) (mset P)\n\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "have \"{#(E, k) \\<in># image_mset (apfst mset) (mset P'). E \\<noteq> mset (fst ?Dj)#} =\n        {#(E, k) \\<in># image_mset (apfst mset) (mset ?P''). E \\<noteq> mset (fst ?Dj)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#(E, k) \\<in># image_mset (apfst mset) (mset P').\n     E \\<noteq> mset (fst (hd P'))#} =\n    {#(E, k) \\<in># image_mset (apfst mset) (mset (tl P')).\n     E \\<noteq> mset (fst (hd P'))#}", "by (subst (2) p') (simp add: case_prod_beta)"], ["proof (state)\nthis:\n  {#(E, k) \\<in># image_mset (apfst mset) (mset P').\n   E \\<noteq> mset (fst (hd P'))#} =\n  {#(E, k) \\<in># image_mset (apfst mset) (mset (tl P')).\n   E \\<noteq> mset (fst (hd P'))#}\n\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "also"], ["proof (state)\nthis:\n  {#(E, k) \\<in># image_mset (apfst mset) (mset P').\n   E \\<noteq> mset (fst (hd P'))#} =\n  {#(E, k) \\<in># image_mset (apfst mset) (mset (tl P')).\n   E \\<noteq> mset (fst (hd P'))#}\n\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "have \"\\<dots> =\n        image_mset (apfst mset) (mset (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst ?Dj)) ?P''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#(E, k) \\<in># image_mset (apfst mset) (mset (tl P')).\n     E \\<noteq> mset (fst (hd P'))#} =\n    image_mset (apfst mset)\n     (mset\n       (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P')))\n         (tl P')))", "by (auto simp: image_mset_filter_swap[symmetric] case_prod_beta)"], ["proof (state)\nthis:\n  {#(E, k) \\<in># image_mset (apfst mset) (mset (tl P')).\n   E \\<noteq> mset (fst (hd P'))#} =\n  image_mset (apfst mset)\n   (mset\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P')))\n\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "finally"], ["proof (chain)\npicking this:\n  {#(E, k) \\<in># image_mset (apfst mset) (mset P').\n   E \\<noteq> mset (fst (hd P'))#} =\n  image_mset (apfst mset)\n   (mset\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P')))", "have p'_filtered:\n        \"{#(E, k) \\<in># image_mset (apfst mset) (mset P'). E \\<noteq> mset (fst ?Dj)#} =\n        image_mset (apfst mset) (mset (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst ?Dj)) ?P''))\""], ["proof (prove)\nusing this:\n  {#(E, k) \\<in># image_mset (apfst mset) (mset P').\n   E \\<noteq> mset (fst (hd P'))#} =\n  image_mset (apfst mset)\n   (mset\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P')))\n\ngoal (1 subgoal):\n 1. {#(E, k) \\<in># image_mset (apfst mset) (mset P').\n     E \\<noteq> mset (fst (hd P'))#} =\n    image_mset (apfst mset)\n     (mset\n       (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P')))\n         (tl P')))", "."], ["proof (state)\nthis:\n  {#(E, k) \\<in># image_mset (apfst mset) (mset P').\n   E \\<noteq> mset (fst (hd P'))#} =\n  image_mset (apfst mset)\n   (mset\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P')))\n\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "have \"wstate_of_dstate (N, P @ P', Q, n)\n        \\<leadsto>\\<^sub>w wstate_of_dstate (N, P @ filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst ?Dj)) ?P'', Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate\n     (N, P @\n         filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P')))\n          (tl P'),\n      Q, n)", "by (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w)\", OF _ _\n              wrp.backward_subsumption_P[of \"mset C\" \"mset (map (apfst mset) N)\" \"mset (fst ?Dj)\"\n                \"mset (map (apfst mset) (P @ P'))\" \"mset (map (apfst mset) Q)\" n]],\n          use c_in subs in \\<open>auto simp add: p_filtered p'_filtered arg_cong[OF p', of set]\n            strictly_subsume_def\\<close>)"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate\n   (N, P @\n       filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'),\n    Q, n)\n\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "also"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate\n   (N, P @\n       filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'),\n    Q, n)\n\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "have \"\\<dots>\n        \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P @\n         filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P')))\n          (tl P'),\n      Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "apply (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w\\<^sup>*)\", OF _ _\n              ih[of \"filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst ?Dj)) ?P''\" P]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. wstate_of_dstate\n     (N, P @\n         filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P')))\n          (tl P'),\n      Q, n) =\n    wstate_of_dstate\n     (N, P @\n         filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P')))\n          (tl P'),\n      Q, n)\n 2. wstate_of_dstate\n     (N, P @\n         filter (Not \\<circ> strictly_subsume [C] \\<circ> fst)\n          (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P')))\n            (tl P')),\n      Q, n) =\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 3. length\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'))\n    < length P'\n 4. \\<forall>D\\<in>fst ` set P. \\<not> strictly_subsume [C] D", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. image_mset (apfst mset)\n     {#x \\<in># mset (tl P').\n      (case x of\n       (E, l) \\<Rightarrow> mset E \\<noteq> mset (fst (hd P'))) \\<and>\n      \\<not> strictly_subsume [C] (fst x)#} =\n    image_mset (apfst mset)\n     {#x \\<in># mset P'. \\<not> strictly_subsume [C] (fst x)#}\n 2. length\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'))\n    < length P'\n 3. \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)", "apply (subst (3) p')"], ["proof (prove)\ngoal (3 subgoals):\n 1. image_mset (apfst mset)\n     {#x \\<in># mset (tl P').\n      (case x of\n       (E, l) \\<Rightarrow> mset E \\<noteq> mset (fst (hd P'))) \\<and>\n      \\<not> strictly_subsume [C] (fst x)#} =\n    image_mset (apfst mset)\n     {#x \\<in># mset (hd P' # tl P'). \\<not> strictly_subsume [C] (fst x)#}\n 2. length\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'))\n    < length P'\n 3. \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)", "using subs"], ["proof (prove)\nusing this:\n  strictly_subsume [C] (fst (hd P'))\n\ngoal (3 subgoals):\n 1. image_mset (apfst mset)\n     {#x \\<in># mset (tl P').\n      (case x of\n       (E, l) \\<Rightarrow> mset E \\<noteq> mset (fst (hd P'))) \\<and>\n      \\<not> strictly_subsume [C] (fst x)#} =\n    image_mset (apfst mset)\n     {#x \\<in># mset (hd P' # tl P'). \\<not> strictly_subsume [C] (fst x)#}\n 2. length\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'))\n    < length P'\n 3. \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)", "apply (simp add: case_prod_beta)"], ["proof (prove)\ngoal (3 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    image_mset (apfst mset)\n     {#x \\<in># mset (tl P').\n      mset (fst x) \\<noteq> mset (fst (hd P')) \\<and>\n      \\<not> strictly_subsume [C] (fst x)#} =\n    image_mset (apfst mset)\n     {#x \\<in># mset (tl P'). \\<not> strictly_subsume [C] (fst x)#}\n 2. length\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'))\n    < length P'\n 3. \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)", "apply (rule arg_cong[of _ _ \"\\<lambda>x. image_mset (apfst mset) x\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    {#x \\<in># mset (tl P').\n     mset (fst x) \\<noteq> mset (fst (hd P')) \\<and>\n     \\<not> strictly_subsume [C] (fst x)#} =\n    {#x \\<in># mset (tl P'). \\<not> strictly_subsume [C] (fst x)#}\n 2. length\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'))\n    < length P'\n 3. \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)", "apply (metis (no_types, hide_lams) strictly_subsume_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'))\n    < length P'\n 2. \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)", "apply (subst (3) p')"], ["proof (prove)\ngoal (2 subgoals):\n 1. length\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'))\n    < length (hd P' # tl P')\n 2. \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)", "apply (subst list.size)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length\n     (filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'))\n    < length (tl P') + Suc 0\n 2. \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)", "apply (metis (no_types, lifting) less_Suc0 less_add_same_cancel1 linorder_neqE_nat\n            not_add_less1 sum_length_filter_compl trans_less_add1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)", "using p_nsubs"], ["proof (prove)\nusing this:\n  \\<forall>D\\<in>fst ` set P. \\<not> strictly_subsume [C] D\n\ngoal (1 subgoal):\n 1. \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)", "by fast"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (N, P @\n       filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'),\n    Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 2. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "ultimately"], ["proof (chain)\npicking this:\n  wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate\n   (N, P @\n       filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'),\n    Q, n)\n  wstate_of_dstate\n   (N, P @\n       filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'),\n    Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "show ?thesis"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate\n   (N, P @\n       filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'),\n    Q, n)\n  wstate_of_dstate\n   (N, P @\n       filter (\\<lambda>(E, l). mset E \\<noteq> mset (fst (hd P'))) (tl P'),\n    Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "by (rule converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n\ngoal (1 subgoal):\n 1. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "case nsubs: False"], ["proof (state)\nthis:\n  \\<not> strictly_subsume [C] (fst (hd P'))\n\ngoal (1 subgoal):\n 1. \\<not> strictly_subsume [C] (fst (hd P')) \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "apply (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w\\<^sup>*)\", OF _ _\n              ih[of ?P'' \"P @ [?Dj]\"]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. wstate_of_dstate (N, (P @ [hd P']) @ tl P', Q, n) =\n    wstate_of_dstate (N, P @ P', Q, n)\n 2. wstate_of_dstate\n     (N, (P @ [hd P']) @\n         filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) (tl P'),\n      Q, n) =\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 3. length (tl P') < length P'\n 4. \\<forall>D\\<in>fst ` set (P @ [hd P']). \\<not> strictly_subsume [C] D", "using nsubs p_nsubs"], ["proof (prove)\nusing this:\n  \\<not> strictly_subsume [C] (fst (hd P'))\n  \\<forall>D\\<in>fst ` set P. \\<not> strictly_subsume [C] D\n\ngoal (4 subgoals):\n 1. wstate_of_dstate (N, (P @ [hd P']) @ tl P', Q, n) =\n    wstate_of_dstate (N, P @ P', Q, n)\n 2. wstate_of_dstate\n     (N, (P @ [hd P']) @\n         filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) (tl P'),\n      Q, n) =\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n 3. length (tl P') < length P'\n 4. \\<forall>D\\<in>fst ` set (P @ [hd P']). \\<not> strictly_subsume [C] D", "apply (simp_all add: arg_cong[OF p', of mset] arg_cong[OF p', of \"filter f\" for f])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> strictly_subsume [C] (fst (hd P'));\n     \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)\\<rbrakk>\n    \\<Longrightarrow> length P' - Suc 0 < length P'", "apply (subst (1 2) p')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> strictly_subsume [C] (fst (hd P'));\n     \\<forall>D\\<in>set P. \\<not> strictly_subsume [C] (fst D)\\<rbrakk>\n    \\<Longrightarrow> length (hd P' # tl P') - Suc 0\n                      < length (hd P' # tl P')", "by simp"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n\ngoal (1 subgoal):\n 1. length P' = 0 \\<Longrightarrow>\n    wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)", "qed simp"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) P', Q, n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_strictly_subsumed_clauses_in_Q:\n  assumes c_in: \"C \\<in> fst ` set N\"\n  shows \"wstate_of_dstate (N, P, Q @ Q', n)\n    \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, P, Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) Q', n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P, Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) Q', n)", "proof (induct Q' arbitrary: Q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q.\n       wstate_of_dstate (N, P, Q @ [], n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P, Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [],\n         n)\n 2. \\<And>a Q' Q.\n       (\\<And>Q.\n           wstate_of_dstate (N, P, Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n           wstate_of_dstate\n            (N, P,\n             Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) Q',\n             n)) \\<Longrightarrow>\n       wstate_of_dstate (N, P, Q @ a # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P,\n         Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) (a # Q'),\n         n)", "case ih: (Cons Dj Q')"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, ?Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P, ?Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) Q', n)\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       wstate_of_dstate (N, P, Q @ [], n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P, Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [],\n         n)\n 2. \\<And>a Q' Q.\n       (\\<And>Q.\n           wstate_of_dstate (N, P, Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n           wstate_of_dstate\n            (N, P,\n             Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) Q',\n             n)) \\<Longrightarrow>\n       wstate_of_dstate (N, P, Q @ a # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P,\n         Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) (a # Q'),\n         n)", "have \"wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P, Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q', n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P,\n      Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q',\n      n)", "proof (cases \"strictly_subsume [C] (fst Dj)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst Dj) \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P,\n      Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q',\n      n)\n 2. \\<not> strictly_subsume [C] (fst Dj) \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P,\n      Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q',\n      n)", "case subs: True"], ["proof (state)\nthis:\n  strictly_subsume [C] (fst Dj)\n\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst Dj) \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P,\n      Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q',\n      n)\n 2. \\<not> strictly_subsume [C] (fst Dj) \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P,\n      Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q',\n      n)", "have \"wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w wstate_of_dstate (N, P, Q @ Q', n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N, P, Q @ Q', n)", "by (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w)\", OF _ _\n            wrp.backward_subsumption_Q[of \"mset C\" \"mset (map (apfst mset) N)\" \"mset (fst Dj)\"\n              \"mset (map (apfst mset) P)\" \"mset (map (apfst mset) (Q @ Q'))\" \"snd Dj\" n]])\n        (use c_in subs in \\<open>auto simp: apfst_fst_snd strictly_subsume_def\\<close>)"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, P, Q @ Q', n)\n\ngoal (2 subgoals):\n 1. strictly_subsume [C] (fst Dj) \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P,\n      Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q',\n      n)\n 2. \\<not> strictly_subsume [C] (fst Dj) \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P,\n      Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q',\n      n)", "then"], ["proof (chain)\npicking this:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, P, Q @ Q', n)", "show ?thesis"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, P, Q @ Q', n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P,\n      Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q',\n      n)", "by auto"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P,\n    Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q', n)\n\ngoal (1 subgoal):\n 1. \\<not> strictly_subsume [C] (fst Dj) \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P,\n      Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q',\n      n)", "qed simp"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P,\n    Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q', n)\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       wstate_of_dstate (N, P, Q @ [], n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P, Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [],\n         n)\n 2. \\<And>a Q' Q.\n       (\\<And>Q.\n           wstate_of_dstate (N, P, Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n           wstate_of_dstate\n            (N, P,\n             Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) Q',\n             n)) \\<Longrightarrow>\n       wstate_of_dstate (N, P, Q @ a # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P,\n         Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) (a # Q'),\n         n)", "then"], ["proof (chain)\npicking this:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P,\n    Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q', n)", "show ?case"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P,\n    Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q', n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P,\n      Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) (Dj # Q'),\n      n)", "using ih[of \"Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj]\"]"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P,\n    Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj] @ Q', n)\n  wstate_of_dstate\n   (N, P,\n    (Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj]) @ Q',\n    n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P,\n    (Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [Dj]) @\n    filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) Q',\n    n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P,\n      Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) (Dj # Q'),\n      n)", "by force"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P,\n    Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) (Dj # Q'), n)\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       wstate_of_dstate (N, P, Q @ [], n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, P, Q @ filter (Not \\<circ> strictly_subsume [C] \\<circ> fst) [],\n         n)", "qed simp"], ["", "lemma reduce_clause_in_P:\n  assumes\n    c_in: \"C \\<in> fst ` set N\" and\n    p_irred: \"\\<forall>(E, k) \\<in> set (P @ P'). k > j \\<longrightarrow> is_irreducible [C] E\"\n  shows \"wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)\n    \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, P @ (D @ reduce [C] D D', j) # P', Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P @ (D @ D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D D', j) # P', Q, n)", "proof (induct D' arbitrary: D)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D.\n       wstate_of_dstate\n        (N, P @ (D @ [], j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate (N, P @ (D @ reduce [C] D [], j) # P', Q, n)\n 2. \\<And>a D' D.\n       (\\<And>D.\n           wstate_of_dstate\n            (N, P @ (D @ D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n           wstate_of_dstate\n            (N, P @ (D @ reduce [C] D D', j) # P', Q, n)) \\<Longrightarrow>\n       wstate_of_dstate\n        (N, P @ (D @ a # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate (N, P @ (D @ reduce [C] D (a # D'), j) # P', Q, n)", "case ih: (Cons L D')"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (N, P @ (?D @ D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, P @ (?D @ reduce [C] ?D D', j) # P', Q, n)\n\ngoal (2 subgoals):\n 1. \\<And>D.\n       wstate_of_dstate\n        (N, P @ (D @ [], j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate (N, P @ (D @ reduce [C] D [], j) # P', Q, n)\n 2. \\<And>a D' D.\n       (\\<And>D.\n           wstate_of_dstate\n            (N, P @ (D @ D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n           wstate_of_dstate\n            (N, P @ (D @ reduce [C] D D', j) # P', Q, n)) \\<Longrightarrow>\n       wstate_of_dstate\n        (N, P @ (D @ a # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate (N, P @ (D @ reduce [C] D (a # D'), j) # P', Q, n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "proof (cases \"is_reducible_lit [C] (D @ D') L\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)\n 2. \\<not> is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "case l_red: True"], ["proof (state)\nthis:\n  is_reducible_lit [C] (D @ D') L\n\ngoal (2 subgoals):\n 1. is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)\n 2. \\<not> is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "then"], ["proof (chain)\npicking this:\n  is_reducible_lit [C] (D @ D') L", "obtain L' :: \"'a literal\" and \\<sigma> :: 's where\n      l'_in: \"L' \\<in> set C\" and\n      not_l: \"- L = L' \\<cdot>l \\<sigma>\" and\n      subs: \"mset (remove1 L' C) \\<cdot> \\<sigma> \\<subseteq># mset (D @ D')\""], ["proof (prove)\nusing this:\n  is_reducible_lit [C] (D @ D') L\n\ngoal (1 subgoal):\n 1. (\\<And>L' \\<sigma>.\n        \\<lbrakk>L' \\<in> set C; - L = L' \\<cdot>l \\<sigma>;\n         mset (remove1 L' C) \\<cdot> \\<sigma> \\<subseteq>#\n         mset (D @ D')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_reducible_lit_def"], ["proof (prove)\nusing this:\n  \\<exists>D\\<in>set [C].\n     \\<exists>L'\\<in>set D.\n        \\<exists>\\<sigma>.\n           - L = L' \\<cdot>l \\<sigma> \\<and>\n           mset (remove1 L' D) \\<cdot> \\<sigma> \\<subseteq># mset (D @ D')\n\ngoal (1 subgoal):\n 1. (\\<And>L' \\<sigma>.\n        \\<lbrakk>L' \\<in> set C; - L = L' \\<cdot>l \\<sigma>;\n         mset (remove1 L' C) \\<cdot> \\<sigma> \\<subseteq>#\n         mset (D @ D')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  L' \\<in> set C\n  - L = L' \\<cdot>l \\<sigma>\n  mset (remove1 L' C) \\<cdot> \\<sigma> \\<subseteq># mset (D @ D')\n\ngoal (2 subgoals):\n 1. is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)\n 2. \\<not> is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "have ldd'_red: \"is_reducible [C] (L # D @ D')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reduce [C] [] (L # D @ D') \\<noteq> L # D @ D'", "apply (rule is_reducible_lit_imp_is_reducible)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?L \\<in> set (L # D @ D')\n 2. is_reducible_lit [C] ([] @ remove1 ?L (L # D @ D')) ?L", "using l_red"], ["proof (prove)\nusing this:\n  is_reducible_lit [C] (D @ D') L\n\ngoal (2 subgoals):\n 1. ?L \\<in> set (L # D @ D')\n 2. is_reducible_lit [C] ([] @ remove1 ?L (L # D @ D')) ?L", "by auto"], ["proof (state)\nthis:\n  reduce [C] [] (L # D @ D') \\<noteq> L # D @ D'\n\ngoal (2 subgoals):\n 1. is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)\n 2. \\<not> is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "have lt_imp_neq: \"\\<forall>(E, k) \\<in> set (P @ P'). j < k \\<longrightarrow> mset E \\<noteq> mset (L # D @ D')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(E, k)\\<in>set (P @ P').\n       j < k \\<longrightarrow> mset E \\<noteq> mset (L # D @ D')", "using p_irred ldd'_red is_irreducible_mset_iff"], ["proof (prove)\nusing this:\n  \\<forall>(E, k)\\<in>set (P @ P').\n     j < k \\<longrightarrow> is_irreducible [C] E\n  reduce [C] [] (L # D @ D') \\<noteq> L # D @ D'\n  mset ?E = mset ?E' \\<Longrightarrow>\n  (reduce ?Ds ?C ?E = ?E) = (reduce ?Ds ?C ?E' = ?E')\n\ngoal (1 subgoal):\n 1. \\<forall>(E, k)\\<in>set (P @ P').\n       j < k \\<longrightarrow> mset E \\<noteq> mset (L # D @ D')", "by fast"], ["proof (state)\nthis:\n  \\<forall>(E, k)\\<in>set (P @ P').\n     j < k \\<longrightarrow> mset E \\<noteq> mset (L # D @ D')\n\ngoal (2 subgoals):\n 1. is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)\n 2. \\<not> is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "have \"wstate_of_dstate (N, P @ (D @ L # D', j) # P', Q, n)\n      \\<leadsto>\\<^sub>w wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)", "apply (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w)\", OF _ _\n            wrp.backward_reduction_P[of \"mset C - {#L'#}\" L' \"mset (map (apfst mset) N)\" L \\<sigma>\n              \"mset (D @ D')\" \"mset (map (apfst mset) (P @ P'))\" j \"mset (map (apfst mset) Q)\" n]])"], ["proof (prove)\ngoal (6 subgoals):\n 1. (mset (map (apfst mset) N),\n     mset (map (apfst mset) (P @ P')) + {#(mset (D @ D') + {#L#}, j)#},\n     mset (map (apfst mset) Q), n) =\n    wstate_of_dstate (N, P @ (D @ L # D', j) # P', Q, n)\n 2. (mset (map (apfst mset) N),\n     mset (map (apfst mset) (P @ P')) + {#(mset (D @ D'), j)#},\n     mset (map (apfst mset) Q), n) =\n    wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)\n 3. remove1_mset L' (mset C) + {#L'#}\n    \\<in># image_mset fst (mset (map (apfst mset) N))\n 4. - L = L' \\<cdot>l \\<sigma>\n 5. remove1_mset L' (mset C) \\<cdot> \\<sigma> \\<subseteq># mset (D @ D')\n 6. \\<forall>ja.\n       (mset (D @ D') + {#L#}, ja)\n       \\<in># mset (map (apfst mset) (P @ P')) \\<longrightarrow>\n       ja \\<le> j", "using l'_in not_l subs c_in lt_imp_neq"], ["proof (prove)\nusing this:\n  L' \\<in> set C\n  - L = L' \\<cdot>l \\<sigma>\n  mset (remove1 L' C) \\<cdot> \\<sigma> \\<subseteq># mset (D @ D')\n  C \\<in> fst ` set N\n  \\<forall>(E, k)\\<in>set (P @ P').\n     j < k \\<longrightarrow> mset E \\<noteq> mset (L # D @ D')\n\ngoal (6 subgoals):\n 1. (mset (map (apfst mset) N),\n     mset (map (apfst mset) (P @ P')) + {#(mset (D @ D') + {#L#}, j)#},\n     mset (map (apfst mset) Q), n) =\n    wstate_of_dstate (N, P @ (D @ L # D', j) # P', Q, n)\n 2. (mset (map (apfst mset) N),\n     mset (map (apfst mset) (P @ P')) + {#(mset (D @ D'), j)#},\n     mset (map (apfst mset) Q), n) =\n    wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)\n 3. remove1_mset L' (mset C) + {#L'#}\n    \\<in># image_mset fst (mset (map (apfst mset) N))\n 4. - L = L' \\<cdot>l \\<sigma>\n 5. remove1_mset L' (mset C) \\<cdot> \\<sigma> \\<subseteq># mset (D @ D')\n 6. \\<forall>ja.\n       (mset (D @ D') + {#L#}, ja)\n       \\<in># mset (map (apfst mset) (P @ P')) \\<longrightarrow>\n       ja \\<le> j", "by (simp_all add: case_prod_beta) force+"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)\n\ngoal (2 subgoals):\n 1. is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)\n 2. \\<not> is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "then"], ["proof (chain)\npicking this:\n  wstate_of_dstate (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)", "show ?thesis"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "using ih[of D] l_red"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)\n  wstate_of_dstate\n   (N, P @ (D @ D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, P @ (D @ reduce [C] D D', j) # P', Q, n)\n  is_reducible_lit [C] (D @ D') L\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "by simp"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)\n\ngoal (1 subgoal):\n 1. \\<not> is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "case False"], ["proof (state)\nthis:\n  \\<not> is_reducible_lit [C] (D @ D') L\n\ngoal (1 subgoal):\n 1. \\<not> is_reducible_lit [C] (D @ D') L \\<Longrightarrow>\n    wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_reducible_lit [C] (D @ D') L", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_reducible_lit [C] (D @ D') L\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "using ih[of \"D @ [L]\"]"], ["proof (prove)\nusing this:\n  \\<not> is_reducible_lit [C] (D @ D') L\n  wstate_of_dstate\n   (N, P @ ((D @ [L]) @ D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ ((D @ [L]) @ reduce [C] (D @ [L]) D', j) # P', Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)", "by simp"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (N, P @ (D @ L # D', j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, P @ (D @ reduce [C] D (L # D'), j) # P', Q, n)\n\ngoal (1 subgoal):\n 1. \\<And>D.\n       wstate_of_dstate\n        (N, P @ (D @ [], j) # P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate (N, P @ (D @ reduce [C] D [], j) # P', Q, n)", "qed simp"], ["", "lemma reduce_clause_in_Q:\n  assumes\n    c_in: \"C \\<in> fst ` set N\" and\n    p_irred: \"\\<forall>(E, k) \\<in> set P. k > j \\<longrightarrow> is_irreducible [C] E\" and\n    d'_red: \"reduce [C] D D' \\<noteq> D'\"\n  shows \"wstate_of_dstate (N, P, Q @ (D @ D', j) # Q', n)\n    \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, (D @ reduce [C] D D', j) # P, Q @ Q', n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, (D @ reduce [C] D D', j) # P, Q @ Q', n)", "using d'_red"], ["proof (prove)\nusing this:\n  reduce [C] D D' \\<noteq> D'\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, (D @ reduce [C] D D', j) # P, Q @ Q', n)", "proof (induct D' arbitrary: D)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>D.\n       reduce [C] D [] \\<noteq> [] \\<Longrightarrow>\n       wstate_of_dstate\n        (N, P, Q @ (D @ [], j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate (N, (D @ reduce [C] D [], j) # P, Q @ Q', n)\n 2. \\<And>a D' D.\n       \\<lbrakk>\\<And>D.\n                   reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                   wstate_of_dstate\n                    (N, P, Q @ (D @ D', j) # Q',\n                     n) \\<leadsto>\\<^sub>w\\<^sup>*\n                   wstate_of_dstate\n                    (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n        reduce [C] D (a # D') \\<noteq> a # D'\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q @ (D @ a # D', j) # Q',\n                           n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, (D @ reduce [C] D (a # D'), j) # P, Q @ Q', n)", "case (Cons L D')"], ["proof (state)\nthis:\n  reduce [C] ?D D' \\<noteq> D' \\<Longrightarrow>\n  wstate_of_dstate\n   (N, P, Q @ (?D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, (?D @ reduce [C] ?D D', j) # P, Q @ Q', n)\n  reduce [C] D (L # D') \\<noteq> L # D'\n\ngoal (2 subgoals):\n 1. \\<And>D.\n       reduce [C] D [] \\<noteq> [] \\<Longrightarrow>\n       wstate_of_dstate\n        (N, P, Q @ (D @ [], j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate (N, (D @ reduce [C] D [], j) # P, Q @ Q', n)\n 2. \\<And>a D' D.\n       \\<lbrakk>\\<And>D.\n                   reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                   wstate_of_dstate\n                    (N, P, Q @ (D @ D', j) # Q',\n                     n) \\<leadsto>\\<^sub>w\\<^sup>*\n                   wstate_of_dstate\n                    (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n        reduce [C] D (a # D') \\<noteq> a # D'\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q @ (D @ a # D', j) # Q',\n                           n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, (D @ reduce [C] D (a # D'), j) # P, Q @ Q', n)", "note ih = this(1) and ld'_red = this(2)"], ["proof (state)\nthis:\n  reduce [C] ?D D' \\<noteq> D' \\<Longrightarrow>\n  wstate_of_dstate\n   (N, P, Q @ (?D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, (?D @ reduce [C] ?D D', j) # P, Q @ Q', n)\n  reduce [C] D (L # D') \\<noteq> L # D'\n\ngoal (2 subgoals):\n 1. \\<And>D.\n       reduce [C] D [] \\<noteq> [] \\<Longrightarrow>\n       wstate_of_dstate\n        (N, P, Q @ (D @ [], j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate (N, (D @ reduce [C] D [], j) # P, Q @ Q', n)\n 2. \\<And>a D' D.\n       \\<lbrakk>\\<And>D.\n                   reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                   wstate_of_dstate\n                    (N, P, Q @ (D @ D', j) # Q',\n                     n) \\<leadsto>\\<^sub>w\\<^sup>*\n                   wstate_of_dstate\n                    (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n        reduce [C] D (a # D') \\<noteq> a # D'\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q @ (D @ a # D', j) # Q',\n                           n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, (D @ reduce [C] D (a # D'), j) # P, Q @ Q', n)", "then"], ["proof (chain)\npicking this:\n  reduce [C] ?D D' \\<noteq> D' \\<Longrightarrow>\n  wstate_of_dstate\n   (N, P, Q @ (?D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, (?D @ reduce [C] ?D D', j) # P, Q @ Q', n)\n  reduce [C] D (L # D') \\<noteq> L # D'", "show ?case"], ["proof (prove)\nusing this:\n  reduce [C] ?D D' \\<noteq> D' \\<Longrightarrow>\n  wstate_of_dstate\n   (N, P, Q @ (?D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, (?D @ reduce [C] ?D D', j) # P, Q @ Q', n)\n  reduce [C] D (L # D') \\<noteq> L # D'\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "proof (cases \"is_reducible_lit [C] (D @ D') L\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)\n 2. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     \\<not> is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "case l_red: True"], ["proof (state)\nthis:\n  is_reducible_lit [C] (D @ D') L\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)\n 2. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     \\<not> is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "then"], ["proof (chain)\npicking this:\n  is_reducible_lit [C] (D @ D') L", "obtain L' :: \"'a literal\" and \\<sigma> :: 's where\n      l'_in: \"L' \\<in> set C\" and\n      not_l: \"- L = L' \\<cdot>l \\<sigma>\" and\n      subs: \"mset (remove1 L' C) \\<cdot> \\<sigma> \\<subseteq># mset (D @ D')\""], ["proof (prove)\nusing this:\n  is_reducible_lit [C] (D @ D') L\n\ngoal (1 subgoal):\n 1. (\\<And>L' \\<sigma>.\n        \\<lbrakk>L' \\<in> set C; - L = L' \\<cdot>l \\<sigma>;\n         mset (remove1 L' C) \\<cdot> \\<sigma> \\<subseteq>#\n         mset (D @ D')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_reducible_lit_def"], ["proof (prove)\nusing this:\n  \\<exists>D\\<in>set [C].\n     \\<exists>L'\\<in>set D.\n        \\<exists>\\<sigma>.\n           - L = L' \\<cdot>l \\<sigma> \\<and>\n           mset (remove1 L' D) \\<cdot> \\<sigma> \\<subseteq># mset (D @ D')\n\ngoal (1 subgoal):\n 1. (\\<And>L' \\<sigma>.\n        \\<lbrakk>L' \\<in> set C; - L = L' \\<cdot>l \\<sigma>;\n         mset (remove1 L' C) \\<cdot> \\<sigma> \\<subseteq>#\n         mset (D @ D')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  L' \\<in> set C\n  - L = L' \\<cdot>l \\<sigma>\n  mset (remove1 L' C) \\<cdot> \\<sigma> \\<subseteq># mset (D @ D')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)\n 2. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     \\<not> is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "have \"wstate_of_dstate (N, P, Q @ (D @ L # D', j) # Q', n)\n      \\<leadsto>\\<^sub>w wstate_of_dstate (N, (D @ D', j) # P, Q @ Q', n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N, (D @ D', j) # P, Q @ Q', n)", "by (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w)\", OF _ _\n            wrp.backward_reduction_Q[of \"mset C - {#L'#}\" L' \"mset (map (apfst mset) N)\" L \\<sigma>\n              \"mset (D @ D')\" \"mset (map (apfst mset) P)\" \"mset (map (apfst mset) (Q @ Q'))\" j n]],\n          use l'_in not_l subs c_in in auto)"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, (D @ D', j) # P, Q @ Q', n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)\n 2. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     \\<not> is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "then"], ["proof (chain)\npicking this:\n  wstate_of_dstate (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, (D @ D', j) # P, Q @ Q', n)", "show ?thesis"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, (D @ D', j) # P, Q @ Q', n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "using l_red p_irred reduce_clause_in_P[OF c_in, of \"[]\" P j D D' \"Q @ Q'\" n]"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N, (D @ D', j) # P, Q @ Q', n)\n  is_reducible_lit [C] (D @ D') L\n  \\<forall>(E, k)\\<in>set P. j < k \\<longrightarrow> is_irreducible [C] E\n  \\<forall>(E, k)\\<in>set ([] @ P).\n     j < k \\<longrightarrow> is_irreducible [C] E \\<Longrightarrow>\n  wstate_of_dstate\n   (N, [] @ (D @ D', j) # P, Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, [] @ (D @ reduce [C] D D', j) # P, Q @ Q', n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "by simp"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     \\<not> is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     \\<not> is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "case l_nred: False"], ["proof (state)\nthis:\n  \\<not> is_reducible_lit [C] (D @ D') L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     \\<not> is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_reducible_lit [C] (D @ D') L", "have d'_red: \"reduce [C] (D @ [L]) D' \\<noteq> D'\""], ["proof (prove)\nusing this:\n  \\<not> is_reducible_lit [C] (D @ D') L\n\ngoal (1 subgoal):\n 1. reduce [C] (D @ [L]) D' \\<noteq> D'", "using ld'_red"], ["proof (prove)\nusing this:\n  \\<not> is_reducible_lit [C] (D @ D') L\n  reduce [C] D (L # D') \\<noteq> L # D'\n\ngoal (1 subgoal):\n 1. reduce [C] (D @ [L]) D' \\<noteq> D'", "by simp"], ["proof (state)\nthis:\n  reduce [C] (D @ [L]) D' \\<noteq> D'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>D.\n                reduce [C] D D' \\<noteq> D' \\<Longrightarrow>\n                wstate_of_dstate\n                 (N, P, Q @ (D @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                wstate_of_dstate\n                 (N, (D @ reduce [C] D D', j) # P, Q @ Q', n);\n     reduce [C] D (L # D') \\<noteq> L # D';\n     \\<not> is_reducible_lit [C] (D @ D') L\\<rbrakk>\n    \\<Longrightarrow> wstate_of_dstate\n                       (N, P, Q @ (D @ L # D', j) # Q',\n                        n) \\<leadsto>\\<^sub>w\\<^sup>*\n                      wstate_of_dstate\n                       (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "using ih[OF d'_red] l_nred"], ["proof (prove)\nusing this:\n  wstate_of_dstate\n   (N, P, Q @ ((D @ [L]) @ D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, ((D @ [L]) @ reduce [C] (D @ [L]) D', j) # P, Q @ Q', n)\n  \\<not> is_reducible_lit [C] (D @ D') L\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)", "by simp"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (N, P, Q @ (D @ L # D', j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, (D @ reduce [C] D (L # D'), j) # P, Q @ Q', n)\n\ngoal (1 subgoal):\n 1. \\<And>D.\n       reduce [C] D [] \\<noteq> [] \\<Longrightarrow>\n       wstate_of_dstate\n        (N, P, Q @ (D @ [], j) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate (N, (D @ reduce [C] D [], j) # P, Q @ Q', n)", "qed simp"], ["", "lemma reduce_clauses_in_P:\n  assumes\n    c_in: \"C \\<in> fst ` set N\" and\n    p_irred: \"\\<forall>(E, k) \\<in> set P. is_irreducible [C] E\"\n  shows \"wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, P @ reduce_all C P', Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ reduce_all C P', Q, n)", "unfolding reduce_all_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "using p_irred"], ["proof (prove)\nusing this:\n  \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "proof (induct \"length P'\" arbitrary: P P')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "case (Suc l)"], ["proof (state)\nthis:\n  \\<lbrakk>l = length ?P';\n   \\<forall>(E, k)\\<in>set ?P. is_irreducible [C] E\\<rbrakk>\n  \\<Longrightarrow> wstate_of_dstate\n                     (N, ?P @ ?P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                    wstate_of_dstate\n                     (N, ?P @ map (apfst (reduce [C] [])) ?P', Q, n)\n  Suc l = length P'\n  \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\n\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "note ih = this(1) and suc_l = this(2) and p_irred = this(3)"], ["proof (state)\nthis:\n  \\<lbrakk>l = length ?P';\n   \\<forall>(E, k)\\<in>set ?P. is_irreducible [C] E\\<rbrakk>\n  \\<Longrightarrow> wstate_of_dstate\n                     (N, ?P @ ?P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                    wstate_of_dstate\n                     (N, ?P @ map (apfst (reduce [C] [])) ?P', Q, n)\n  Suc l = length P'\n  \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\n\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "have p'_nnil: \"P' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<noteq> []", "using suc_l"], ["proof (prove)\nusing this:\n  Suc l = length P'\n\ngoal (1 subgoal):\n 1. P' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  P' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "define j :: nat where\n    \"j = Max (snd ` set P')\""], ["proof (state)\nthis:\n  j = Max (snd ` set P')\n\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "obtain Dj :: \"'a dclause\" where\n    dj_in: \"Dj \\<in> set P'\" and\n    snd_dj: \"snd Dj = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Dj.\n        \\<lbrakk>Dj \\<in> set P'; snd Dj = j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Max_in[of \"snd ` set P'\", unfolded image_def, simplified]"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<exists>xa\\<in>set P'. x = snd xa \\<Longrightarrow>\n  \\<exists>x\\<in>set P'. Max {y. \\<exists>x\\<in>set P'. y = snd x} = snd x\n\ngoal (1 subgoal):\n 1. (\\<And>Dj.\n        \\<lbrakk>Dj \\<in> set P'; snd Dj = j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis image_def j_def length_Suc_conv list.set_intros(1) suc_l)"], ["proof (state)\nthis:\n  Dj \\<in> set P'\n  snd Dj = j\n\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "have \"\\<forall>k \\<in> snd ` set P'. k \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>snd ` set P'. k \\<le> j", "unfolding j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>snd ` set P'. k \\<le> Max (snd ` set P')", "using p'_nnil"], ["proof (prove)\nusing this:\n  P' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>snd ` set P'. k \\<le> Max (snd ` set P')", "by simp"], ["proof (state)\nthis:\n  \\<forall>k\\<in>snd ` set P'. k \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "then"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>snd ` set P'. k \\<le> j", "have j_max: \"\\<forall>(E, k) \\<in> set P'. j \\<ge> k\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>snd ` set P'. k \\<le> j\n\ngoal (1 subgoal):\n 1. \\<forall>(E, k)\\<in>set P'. k \\<le> j", "unfolding image_def"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>{y. \\<exists>x\\<in>set P'. y = snd x}. k \\<le> j\n\ngoal (1 subgoal):\n 1. \\<forall>(E, k)\\<in>set P'. k \\<le> j", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(E, k)\\<in>set P'. k \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "obtain P1' P2' :: \"'a dclause list\"  where\n    p': \"P' = P1' @ Dj # P2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P1' P2'.\n        P' = P1' @ Dj # P2' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_list[OF dj_in]"], ["proof (prove)\nusing this:\n  \\<exists>ys zs. P' = ys @ Dj # zs\n\ngoal (1 subgoal):\n 1. (\\<And>P1' P2'.\n        P' = P1' @ Dj # P2' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P' = P1' @ Dj # P2'\n\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "have \"wstate_of_dstate (N, P @ P1' @ Dj # P2', Q, n)\n     \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P @ P1' @ Dj # P2', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)", "unfolding append_assoc[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, (P @ P1') @ Dj # P2', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, (P @ P1') @ apfst (reduce [C] []) Dj # P2', Q, n)", "apply (subst (1 2) surjective_pairing[of Dj, unfolded snd_dj])"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, (P @ P1') @ (fst Dj, j) # P2', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, (P @ P1') @ apfst (reduce [C] []) (fst Dj, j) # P2', Q, n)", "apply (simp only: apfst_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, (P @ P1') @ (fst Dj, j) # P2', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, (P @ P1') @ (reduce [C] [] (fst Dj), j) # P2', Q, n)", "apply (rule reduce_clause_in_P[of _ _ _ _ _ \"[]\", unfolded append_Nil, OF c_in])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(E, k)\\<in>set ((P @ P1') @ P2').\n       j < k \\<longrightarrow> is_irreducible [C] E", "using p_irred j_max[unfolded p']"], ["proof (prove)\nusing this:\n  \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\n  \\<forall>(E, k)\\<in>set (P1' @ Dj # P2'). k \\<le> j\n\ngoal (1 subgoal):\n 1. \\<forall>(E, k)\\<in>set ((P @ P1') @ P2').\n       j < k \\<longrightarrow> is_irreducible [C] E", "by (force simp: case_prod_beta)"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P @ P1' @ Dj # P2', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)\n\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "moreover"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P @ P1' @ Dj # P2', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)\n\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "have \"wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)\n     \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, P @ map (apfst (reduce [C] [])) (P1' @ Dj # P2'), Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q,\n      n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ map (apfst (reduce [C] [])) (P1' @ Dj # P2'), Q, n)", "apply (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w\\<^sup>*)\", OF _ _\n          ih[of \"P1' @ P2'\" \"apfst (reduce [C] []) Dj # P\"]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. wstate_of_dstate (N, (apfst (reduce [C] []) Dj # P) @ P1' @ P2', Q, n) =\n    wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)\n 2. wstate_of_dstate\n     (N, (apfst (reduce [C] []) Dj # P) @\n         map (apfst (reduce [C] [])) (P1' @ P2'),\n      Q, n) =\n    wstate_of_dstate\n     (N, P @ map (apfst (reduce [C] [])) (P1' @ Dj # P2'), Q, n)\n 3. l = length (P1' @ P2')\n 4. \\<forall>(E, k)\\<in>set (apfst (reduce [C] []) Dj # P).\n       is_irreducible [C] E", "using suc_l reduce_idem p_irred"], ["proof (prove)\nusing this:\n  Suc l = length P'\n  reduce ?Ds ?C (reduce ?Ds ?C ?E) = reduce ?Ds ?C ?E\n  \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\n\ngoal (4 subgoals):\n 1. wstate_of_dstate (N, (apfst (reduce [C] []) Dj # P) @ P1' @ P2', Q, n) =\n    wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)\n 2. wstate_of_dstate\n     (N, (apfst (reduce [C] []) Dj # P) @\n         map (apfst (reduce [C] [])) (P1' @ P2'),\n      Q, n) =\n    wstate_of_dstate\n     (N, P @ map (apfst (reduce [C] [])) (P1' @ Dj # P2'), Q, n)\n 3. l = length (P1' @ P2')\n 4. \\<forall>(E, k)\\<in>set (apfst (reduce [C] []) Dj # P).\n       is_irreducible [C] E", "unfolding p'"], ["proof (prove)\nusing this:\n  Suc l = length (P1' @ Dj # P2')\n  reduce ?Ds ?C (reduce ?Ds ?C ?E) = reduce ?Ds ?C ?E\n  \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\n\ngoal (4 subgoals):\n 1. wstate_of_dstate (N, (apfst (reduce [C] []) Dj # P) @ P1' @ P2', Q, n) =\n    wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)\n 2. wstate_of_dstate\n     (N, (apfst (reduce [C] []) Dj # P) @\n         map (apfst (reduce [C] [])) (P1' @ P2'),\n      Q, n) =\n    wstate_of_dstate\n     (N, P @ map (apfst (reduce [C] [])) (P1' @ Dj # P2'), Q, n)\n 3. l = length (P1' @ P2')\n 4. \\<forall>(E, k)\\<in>set (apfst (reduce [C] []) Dj # P).\n       is_irreducible [C] E", "by (auto simp: case_prod_beta)"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q,\n    n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ map (apfst (reduce [C] [])) (P1' @ Dj # P2'), Q, n)\n\ngoal (2 subgoals):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n 2. \\<And>x P' P.\n       \\<lbrakk>\\<And>P' P.\n                   \\<lbrakk>x = length P';\n                    \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n(N, P @ map (apfst (reduce [C] [])) P', Q, n);\n        Suc x = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "ultimately"], ["proof (chain)\npicking this:\n  wstate_of_dstate (N, P @ P1' @ Dj # P2', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)\n  wstate_of_dstate\n   (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q,\n    n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ map (apfst (reduce [C] [])) (P1' @ Dj # P2'), Q, n)", "show ?case"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P @ P1' @ Dj # P2', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)\n  wstate_of_dstate\n   (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q,\n    n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ map (apfst (reduce [C] [])) (P1' @ Dj # P2'), Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "unfolding p'"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P @ P1' @ Dj # P2', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)\n  wstate_of_dstate\n   (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q,\n    n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, P @ map (apfst (reduce [C] [])) (P1' @ Dj # P2'), Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N, P @ P1' @ Dj # P2', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, P @ map (apfst (reduce [C] [])) (P1' @ Dj # P2'), Q, n)", "by simp"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, P @ map (apfst (reduce [C] [])) P', Q, n)\n\ngoal (1 subgoal):\n 1. \\<And>P' P.\n       \\<lbrakk>0 = length P';\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P @ P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, P @ map (apfst (reduce [C] [])) P', Q, n)", "qed simp"], ["", "lemma reduce_clauses_in_Q:\n  assumes\n    c_in: \"C \\<in> fst ` set N\" and\n    p_irred: \"\\<forall>(E, k) \\<in> set P. is_irreducible [C] E\"\n  shows \"wstate_of_dstate (N, P, Q @ Q', n)\n    \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, fst (reduce_all2 C Q') @ P, Q @ snd (reduce_all2 C Q'), n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C Q') @ P, Q @ snd (reduce_all2 C Q'), n)", "using p_irred"], ["proof (prove)\nusing this:\n  \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C Q') @ P, Q @ snd (reduce_all2 C Q'), n)", "proof (induct Q' arbitrary: P Q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P Q.\n       \\<forall>(E, k)\\<in>set P. is_irreducible [C] E \\<Longrightarrow>\n       wstate_of_dstate (N, P, Q @ [], n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, fst (reduce_all2 C []) @ P, Q @ snd (reduce_all2 C []), n)\n 2. \\<And>a Q' P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<forall>(E, k)\\<in>set P.\n                      is_irreducible [C] E \\<Longrightarrow>\n                   wstate_of_dstate\n                    (N, P, Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                   wstate_of_dstate\n                    (N, fst (reduce_all2 C Q') @ P,\n                     Q @ snd (reduce_all2 C Q'), n);\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q @ a # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, fst (reduce_all2 C (a # Q')) @ P,\n                           Q @ snd (reduce_all2 C (a # Q')), n)", "case (Cons Dj Q')"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ?P.\n     case a of (E, k) \\<Rightarrow> is_irreducible [C] E \\<Longrightarrow>\n  wstate_of_dstate (N, ?P, ?Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, fst (reduce_all2 C Q') @ ?P, ?Q @ snd (reduce_all2 C Q'), n)\n  \\<forall>a\\<in>set P. case a of (E, k) \\<Rightarrow> is_irreducible [C] E\n\ngoal (2 subgoals):\n 1. \\<And>P Q.\n       \\<forall>(E, k)\\<in>set P. is_irreducible [C] E \\<Longrightarrow>\n       wstate_of_dstate (N, P, Q @ [], n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, fst (reduce_all2 C []) @ P, Q @ snd (reduce_all2 C []), n)\n 2. \\<And>a Q' P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<forall>(E, k)\\<in>set P.\n                      is_irreducible [C] E \\<Longrightarrow>\n                   wstate_of_dstate\n                    (N, P, Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                   wstate_of_dstate\n                    (N, fst (reduce_all2 C Q') @ P,\n                     Q @ snd (reduce_all2 C Q'), n);\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q @ a # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, fst (reduce_all2 C (a # Q')) @ P,\n                           Q @ snd (reduce_all2 C (a # Q')), n)", "note ih = this(1) and p_irred = this(2)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set ?P.\n     case a of (E, k) \\<Rightarrow> is_irreducible [C] E \\<Longrightarrow>\n  wstate_of_dstate (N, ?P, ?Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, fst (reduce_all2 C Q') @ ?P, ?Q @ snd (reduce_all2 C Q'), n)\n  \\<forall>a\\<in>set P. case a of (E, k) \\<Rightarrow> is_irreducible [C] E\n\ngoal (2 subgoals):\n 1. \\<And>P Q.\n       \\<forall>(E, k)\\<in>set P. is_irreducible [C] E \\<Longrightarrow>\n       wstate_of_dstate (N, P, Q @ [], n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, fst (reduce_all2 C []) @ P, Q @ snd (reduce_all2 C []), n)\n 2. \\<And>a Q' P Q.\n       \\<lbrakk>\\<And>P Q.\n                   \\<forall>(E, k)\\<in>set P.\n                      is_irreducible [C] E \\<Longrightarrow>\n                   wstate_of_dstate\n                    (N, P, Q @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                   wstate_of_dstate\n                    (N, fst (reduce_all2 C Q') @ P,\n                     Q @ snd (reduce_all2 C Q'), n);\n        \\<forall>(E, k)\\<in>set P. is_irreducible [C] E\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q @ a # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          (N, fst (reduce_all2 C (a # Q')) @ P,\n                           Q @ snd (reduce_all2 C (a # Q')), n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)", "proof (cases \"is_irreducible [C] (fst Dj)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_irreducible [C] (fst Dj) \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)\n 2. reduce [C] [] (fst Dj) \\<noteq> fst Dj \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)", "case True"], ["proof (state)\nthis:\n  is_irreducible [C] (fst Dj)\n\ngoal (2 subgoals):\n 1. is_irreducible [C] (fst Dj) \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)\n 2. reduce [C] [] (fst Dj) \\<noteq> fst Dj \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)", "then"], ["proof (chain)\npicking this:\n  is_irreducible [C] (fst Dj)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_irreducible [C] (fst Dj)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)", "using ih[of _ \"Q @ [Dj]\"] p_irred"], ["proof (prove)\nusing this:\n  is_irreducible [C] (fst Dj)\n  \\<forall>a\\<in>set ?P.\n     case a of (E, k) \\<Rightarrow> is_irreducible [C] E \\<Longrightarrow>\n  wstate_of_dstate (N, ?P, (Q @ [Dj]) @ Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, fst (reduce_all2 C Q') @ ?P, (Q @ [Dj]) @ snd (reduce_all2 C Q'), n)\n  \\<forall>a\\<in>set P. case a of (E, k) \\<Rightarrow> is_irreducible [C] E\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)", "by (simp add: case_prod_beta)"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, fst (reduce_all2 C (Dj # Q')) @ P, Q @ snd (reduce_all2 C (Dj # Q')),\n    n)\n\ngoal (1 subgoal):\n 1. reduce [C] [] (fst Dj) \\<noteq> fst Dj \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. reduce [C] [] (fst Dj) \\<noteq> fst Dj \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)", "case d_red: False"], ["proof (state)\nthis:\n  reduce [C] [] (fst Dj) \\<noteq> fst Dj\n\ngoal (1 subgoal):\n 1. reduce [C] [] (fst Dj) \\<noteq> fst Dj \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)", "have \"wstate_of_dstate (N, P, Q @ Dj # Q', n)\n      \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (N, (reduce [C] [] (fst Dj), snd Dj) # P, Q @ Q', n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, (reduce [C] [] (fst Dj), snd Dj) # P, Q @ Q', n)", "using p_irred reduce_clause_in_Q[of _ _ P \"snd Dj\" \"[]\" _ Q Q' n, OF c_in _ d_red]"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set P. case a of (E, k) \\<Rightarrow> is_irreducible [C] E\n  \\<forall>(E, k)\\<in>set P.\n     snd Dj < k \\<longrightarrow> is_irreducible [C] E \\<Longrightarrow>\n  wstate_of_dstate\n   (N, P, Q @ ([] @ fst Dj, snd Dj) # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, ([] @ reduce [C] [] (fst Dj), snd Dj) # P, Q @ Q', n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (N, (reduce [C] [] (fst Dj), snd Dj) # P, Q @ Q', n)", "by (cases Dj) force"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, (reduce [C] [] (fst Dj), snd Dj) # P, Q @ Q', n)\n\ngoal (1 subgoal):\n 1. reduce [C] [] (fst Dj) \\<noteq> fst Dj \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)", "then"], ["proof (chain)\npicking this:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, (reduce [C] [] (fst Dj), snd Dj) # P, Q @ Q', n)", "show ?thesis"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, (reduce [C] [] (fst Dj), snd Dj) # P, Q @ Q', n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)", "using ih[of \"(reduce [C] [] (fst Dj), snd Dj) # P\" Q] d_red p_irred reduce_idem"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (N, (reduce [C] [] (fst Dj), snd Dj) # P, Q @ Q', n)\n  \\<forall>a\\<in>set ((reduce [C] [] (fst Dj), snd Dj) # P).\n     case a of (E, k) \\<Rightarrow> is_irreducible [C] E \\<Longrightarrow>\n  wstate_of_dstate\n   (N, (reduce [C] [] (fst Dj), snd Dj) # P, Q @ Q',\n    n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, fst (reduce_all2 C Q') @ (reduce [C] [] (fst Dj), snd Dj) # P,\n    Q @ snd (reduce_all2 C Q'), n)\n  reduce [C] [] (fst Dj) \\<noteq> fst Dj\n  \\<forall>a\\<in>set P. case a of (E, k) \\<Rightarrow> is_irreducible [C] E\n  reduce ?Ds ?C (reduce ?Ds ?C ?E) = reduce ?Ds ?C ?E\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     (N, fst (reduce_all2 C (Dj # Q')) @ P,\n      Q @ snd (reduce_all2 C (Dj # Q')), n)", "by (force simp: case_prod_beta)"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, fst (reduce_all2 C (Dj # Q')) @ P, Q @ snd (reduce_all2 C (Dj # Q')),\n    n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q @ Dj # Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (N, fst (reduce_all2 C (Dj # Q')) @ P, Q @ snd (reduce_all2 C (Dj # Q')),\n    n)\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       \\<forall>(E, k)\\<in>set P. is_irreducible [C] E \\<Longrightarrow>\n       wstate_of_dstate (N, P, Q @ [], n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        (N, fst (reduce_all2 C []) @ P, Q @ snd (reduce_all2 C []), n)", "qed simp"], ["", "lemma eligible_iff:\n  \"eligible S \\<sigma> As DA \\<longleftrightarrow> As = [] \\<or> length As = 1 \\<and> maximal_wrt (hd As \\<cdot>a \\<sigma>) (DA \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eligible S \\<sigma> As DA =\n    (As = [] \\<or>\n     length As = 1 \\<and>\n     maximal_wrt (hd As \\<cdot>a \\<sigma>) (DA \\<cdot> \\<sigma>))", "unfolding eligible.simps S_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>DAa Asa \\<sigma>'.\n        \\<sigma> = \\<sigma>' \\<and>\n        As = Asa \\<and>\n        DA = DAa \\<and>\n        ({#} = negs (mset Asa) \\<or>\n         {#} = {#} \\<and>\n         length Asa = 1 \\<and>\n         maximal_wrt (Asa ! 0 \\<cdot>a \\<sigma>')\n          (DAa \\<cdot> \\<sigma>'))) =\n    (As = [] \\<or>\n     length As = 1 \\<and>\n     maximal_wrt (hd As \\<cdot>a \\<sigma>) (DA \\<cdot> \\<sigma>))", "by (fastforce dest: hd_conv_nth)"], ["", "lemma ord_resolve_one_side_prem:\n  \"ord_resolve S CAs DA AAs As \\<sigma> E \\<Longrightarrow> length CAs = 1 \\<and> length AAs = 1 \\<and> length As = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve S CAs DA AAs As \\<sigma> E \\<Longrightarrow>\n    length CAs = 1 \\<and> length AAs = 1 \\<and> length As = 1", "by (force elim!: ord_resolve.cases simp: eligible_iff)"], ["", "lemma ord_resolve_rename_one_side_prem:\n  \"ord_resolve_rename S CAs DA AAs As \\<sigma> E \\<Longrightarrow> length CAs = 1 \\<and> length AAs = 1 \\<and> length As = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve_rename S CAs DA AAs As \\<sigma> E \\<Longrightarrow>\n    length CAs = 1 \\<and> length AAs = 1 \\<and> length As = 1", "by (force elim!: ord_resolve_rename.cases dest: ord_resolve_one_side_prem)"], ["", "abbreviation Bin_ord_resolve :: \"'a clause \\<Rightarrow> 'a clause \\<Rightarrow> 'a clause set\" where\n  \"Bin_ord_resolve C D \\<equiv> {E. \\<exists>AA A \\<sigma>. ord_resolve S [C] D [AA] [A] \\<sigma> E}\""], ["", "abbreviation Bin_ord_resolve_rename :: \"'a clause \\<Rightarrow> 'a clause \\<Rightarrow> 'a clause set\" where\n  \"Bin_ord_resolve_rename C D \\<equiv> {E. \\<exists>AA A \\<sigma>. ord_resolve_rename S [C] D [AA] [A] \\<sigma> E}\""], ["", "lemma resolve_on_eq_UNION_Bin_ord_resolve:\n  \"mset ` set (resolve_on A D CA) =\n   {E. \\<exists>AA \\<sigma>. ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` set (resolve_on A D CA) =\n    {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "fix E :: \"'a literal list\""], ["proof (state)\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "assume \"E \\<in> set (resolve_on A D CA)\""], ["proof (state)\nthis:\n  E \\<in> set (resolve_on A D CA)\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  E \\<in> set (resolve_on A D CA)", "have \"E \\<in> resolvent D A CA ` {Ls. subseq Ls CA \\<and> resolvable A D CA Ls}\""], ["proof (prove)\nusing this:\n  E \\<in> set (resolve_on A D CA)\n\ngoal (1 subgoal):\n 1. E \\<in> resolvent D A CA `\n            {Ls. subseq Ls CA \\<and> resolvable A D CA Ls}", "unfolding resolve_on_def"], ["proof (prove)\nusing this:\n  E \\<in> set (map (resolvent D A CA)\n                (filter (resolvable A D CA) (subseqs CA)))\n\ngoal (1 subgoal):\n 1. E \\<in> resolvent D A CA `\n            {Ls. subseq Ls CA \\<and> resolvable A D CA Ls}", "by simp"], ["proof (state)\nthis:\n  E \\<in> resolvent D A CA ` {Ls. subseq Ls CA \\<and> resolvable A D CA Ls}\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  E \\<in> resolvent D A CA ` {Ls. subseq Ls CA \\<and> resolvable A D CA Ls}", "obtain Ls where Ls_p: \"resolvent D A CA Ls = E\" \"subseq Ls CA \\<and> resolvable A D CA Ls\""], ["proof (prove)\nusing this:\n  E \\<in> resolvent D A CA ` {Ls. subseq Ls CA \\<and> resolvable A D CA Ls}\n\ngoal (1 subgoal):\n 1. (\\<And>Ls.\n        \\<lbrakk>resolvent D A CA Ls = E;\n         subseq Ls CA \\<and> resolvable A D CA Ls\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  resolvent D A CA Ls = E\n  subseq Ls CA \\<and> resolvable A D CA Ls\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "define \\<sigma> where \"\\<sigma> = the (mgu {insert A (atms_of (mset Ls))})\""], ["proof (state)\nthis:\n  \\<sigma> = the (mgu {insert A (atms_of (mset Ls))})\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  \\<sigma> = the (mgu {insert A (atms_of (mset Ls))})", "have \\<sigma>_p:\n      \"mgu {insert A (atms_of (mset Ls))} = Some \\<sigma>\"\n      \"Ls \\<noteq> []\"\n      \"eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\"\n      \"strictly_maximal_wrt (A \\<cdot>a \\<sigma>) ((mset CA - mset Ls) \\<cdot> \\<sigma>)\"\n      \"\\<forall>L \\<in> set Ls. is_pos L\""], ["proof (prove)\nusing this:\n  \\<sigma> = the (mgu {insert A (atms_of (mset Ls))})\n\ngoal (1 subgoal):\n 1. (mgu {insert A (atms_of (mset Ls))} = Some \\<sigma> &&&\n     Ls \\<noteq> []) &&&\n    eligible S \\<sigma> [A] (add_mset (Neg A) (mset D)) &&&\n    strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n     ((mset CA - mset Ls) \\<cdot> \\<sigma>) &&&\n    \\<forall>L\\<in>set Ls. is_pos L", "using Ls_p"], ["proof (prove)\nusing this:\n  \\<sigma> = the (mgu {insert A (atms_of (mset Ls))})\n  resolvent D A CA Ls = E\n  subseq Ls CA \\<and> resolvable A D CA Ls\n\ngoal (1 subgoal):\n 1. (mgu {insert A (atms_of (mset Ls))} = Some \\<sigma> &&&\n     Ls \\<noteq> []) &&&\n    eligible S \\<sigma> [A] (add_mset (Neg A) (mset D)) &&&\n    strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n     ((mset CA - mset Ls) \\<cdot> \\<sigma>) &&&\n    \\<forall>L\\<in>set Ls. is_pos L", "unfolding resolvable_def"], ["proof (prove)\nusing this:\n  \\<sigma> = the (mgu {insert A (atms_of (mset Ls))})\n  resolvent D A CA Ls = E\n  subseq Ls CA \\<and>\n  (let \\<sigma> = mgu {insert A (atms_of (mset Ls))}\n   in \\<sigma> \\<noteq> None \\<and>\n      Ls \\<noteq> [] \\<and>\n      maximal_wrt (A \\<cdot>a the \\<sigma>)\n       (add_mset (Neg A) (mset D) \\<cdot> the \\<sigma>) \\<and>\n      strictly_maximal_wrt (A \\<cdot>a the \\<sigma>)\n       ((mset CA - mset Ls) \\<cdot> the \\<sigma>) \\<and>\n      Ball (set Ls) is_pos)\n\ngoal (1 subgoal):\n 1. (mgu {insert A (atms_of (mset Ls))} = Some \\<sigma> &&&\n     Ls \\<noteq> []) &&&\n    eligible S \\<sigma> [A] (add_mset (Neg A) (mset D)) &&&\n    strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n     ((mset CA - mset Ls) \\<cdot> \\<sigma>) &&&\n    \\<forall>L\\<in>set Ls. is_pos L", "unfolding Let_def eligible.simps"], ["proof (prove)\nusing this:\n  \\<sigma> = the (mgu {insert A (atms_of (mset Ls))})\n  resolvent D A CA Ls = E\n  subseq Ls CA \\<and>\n  mgu {insert A (atms_of (mset Ls))} \\<noteq> None \\<and>\n  Ls \\<noteq> [] \\<and>\n  maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n   (add_mset (Neg A) (mset D) \\<cdot>\n    the (mgu {insert A (atms_of (mset Ls))})) \\<and>\n  strictly_maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n   ((mset CA - mset Ls) \\<cdot>\n    the (mgu {insert A (atms_of (mset Ls))})) \\<and>\n  Ball (set Ls) is_pos\n\ngoal (1 subgoal):\n 1. (mgu {insert A (atms_of (mset Ls))} = Some \\<sigma> &&&\n     Ls \\<noteq> []) &&&\n    \\<exists>DA As \\<sigma>'.\n       \\<sigma> = \\<sigma>' \\<and>\n       [A] = As \\<and>\n       add_mset (Neg A) (mset D) = DA \\<and>\n       (S DA = negs (mset As) \\<or>\n        S DA = {#} \\<and>\n        length As = 1 \\<and>\n        maximal_wrt (As ! 0 \\<cdot>a \\<sigma>') (DA \\<cdot> \\<sigma>')) &&&\n    strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n     ((mset CA - mset Ls) \\<cdot> \\<sigma>) &&&\n    \\<forall>L\\<in>set Ls. is_pos L", "using S_empty"], ["proof (prove)\nusing this:\n  \\<sigma> = the (mgu {insert A (atms_of (mset Ls))})\n  resolvent D A CA Ls = E\n  subseq Ls CA \\<and>\n  mgu {insert A (atms_of (mset Ls))} \\<noteq> None \\<and>\n  Ls \\<noteq> [] \\<and>\n  maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n   (add_mset (Neg A) (mset D) \\<cdot>\n    the (mgu {insert A (atms_of (mset Ls))})) \\<and>\n  strictly_maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n   ((mset CA - mset Ls) \\<cdot>\n    the (mgu {insert A (atms_of (mset Ls))})) \\<and>\n  Ball (set Ls) is_pos\n  S ?C = {#}\n\ngoal (1 subgoal):\n 1. (mgu {insert A (atms_of (mset Ls))} = Some \\<sigma> &&&\n     Ls \\<noteq> []) &&&\n    \\<exists>DA As \\<sigma>'.\n       \\<sigma> = \\<sigma>' \\<and>\n       [A] = As \\<and>\n       add_mset (Neg A) (mset D) = DA \\<and>\n       (S DA = negs (mset As) \\<or>\n        S DA = {#} \\<and>\n        length As = 1 \\<and>\n        maximal_wrt (As ! 0 \\<cdot>a \\<sigma>') (DA \\<cdot> \\<sigma>')) &&&\n    strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n     ((mset CA - mset Ls) \\<cdot> \\<sigma>) &&&\n    \\<forall>L\\<in>set Ls. is_pos L", "by auto"], ["proof (state)\nthis:\n  mgu {insert A (atms_of (mset Ls))} = Some \\<sigma>\n  Ls \\<noteq> []\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ((mset CA - mset Ls) \\<cdot> \\<sigma>)\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "from \\<sigma>_p"], ["proof (chain)\npicking this:\n  mgu {insert A (atms_of (mset Ls))} = Some \\<sigma>\n  Ls \\<noteq> []\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ((mset CA - mset Ls) \\<cdot> \\<sigma>)\n  \\<forall>L\\<in>set Ls. is_pos L", "have \\<sigma>_p2: \"the (mgu {insert A (atms_of (mset Ls))}) = \\<sigma>\""], ["proof (prove)\nusing this:\n  mgu {insert A (atms_of (mset Ls))} = Some \\<sigma>\n  Ls \\<noteq> []\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ((mset CA - mset Ls) \\<cdot> \\<sigma>)\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (1 subgoal):\n 1. the (mgu {insert A (atms_of (mset Ls))}) = \\<sigma>", "by auto"], ["proof (state)\nthis:\n  the (mgu {insert A (atms_of (mset Ls))}) = \\<sigma>\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have Ls_sub_CA: \"mset Ls \\<subseteq># mset CA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset Ls \\<subseteq># mset CA", "using subseq_mset_subseteq_mset Ls_p"], ["proof (prove)\nusing this:\n  subseq ?xs ?ys \\<Longrightarrow> mset ?xs \\<subseteq># mset ?ys\n  resolvent D A CA Ls = E\n  subseq Ls CA \\<and> resolvable A D CA Ls\n\ngoal (1 subgoal):\n 1. mset Ls \\<subseteq># mset CA", "by auto"], ["proof (state)\nthis:\n  mset Ls \\<subseteq># mset CA\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  mset Ls \\<subseteq># mset CA", "have \"mset (resolvent D A CA Ls) = sum_list [mset CA - mset Ls] \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\""], ["proof (prove)\nusing this:\n  mset Ls \\<subseteq># mset CA\n\ngoal (1 subgoal):\n 1. mset (resolvent D A CA Ls) =\n    sum_list [mset CA - mset Ls] \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>", "unfolding resolvent_def \\<sigma>_p2 subst_cls_def"], ["proof (prove)\nusing this:\n  mset Ls \\<subseteq># mset CA\n\ngoal (1 subgoal):\n 1. mset (map (\\<lambda>M. M \\<cdot>l \\<sigma>) (remove_all CA Ls @ D)) =\n    {#A \\<cdot>l \\<sigma>. A \\<in># sum_list [mset CA - mset Ls]#} +\n    {#A \\<cdot>l \\<sigma>. A \\<in># mset D#}", "using remove_all_mset_minus[of Ls CA]"], ["proof (prove)\nusing this:\n  mset Ls \\<subseteq># mset CA\n  mset Ls \\<subseteq># mset CA \\<Longrightarrow>\n  mset (remove_all CA Ls) = mset CA - mset Ls\n\ngoal (1 subgoal):\n 1. mset (map (\\<lambda>M. M \\<cdot>l \\<sigma>) (remove_all CA Ls @ D)) =\n    {#A \\<cdot>l \\<sigma>. A \\<in># sum_list [mset CA - mset Ls]#} +\n    {#A \\<cdot>l \\<sigma>. A \\<in># mset D#}", "by auto"], ["proof (state)\nthis:\n  mset (resolvent D A CA Ls) =\n  sum_list [mset CA - mset Ls] \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  mset (resolvent D A CA Ls) =\n  sum_list [mset CA - mset Ls] \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"length [mset CA - mset Ls] = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [mset CA - mset Ls] = Suc 0", "by auto"], ["proof (state)\nthis:\n  length [mset CA - mset Ls] = Suc 0\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  length [mset CA - mset Ls] = Suc 0\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"\\<forall>L \\<in> set Ls. is_pos L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>set Ls. is_pos L", "using \\<sigma>_p(5) list_all_iff[of is_pos]"], ["proof (prove)\nusing this:\n  \\<forall>L\\<in>set Ls. is_pos L\n  list_all is_pos ?x = Ball (set ?x) is_pos\n\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>set Ls. is_pos L", "by auto"], ["proof (state)\nthis:\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  \\<forall>L\\<in>set Ls. is_pos L", "have \"{#Pos (atm_of x). x \\<in># mset Ls#} = mset Ls\""], ["proof (prove)\nusing this:\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (1 subgoal):\n 1. {#Pos (atm_of x). x \\<in># mset Ls#} = mset Ls", "by (induction Ls) auto"], ["proof (state)\nthis:\n  {#Pos (atm_of x). x \\<in># mset Ls#} = mset Ls\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  {#Pos (atm_of x). x \\<in># mset Ls#} = mset Ls", "have \"mset CA = [mset CA - mset Ls] ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#}\""], ["proof (prove)\nusing this:\n  {#Pos (atm_of x). x \\<in># mset Ls#} = mset Ls\n\ngoal (1 subgoal):\n 1. mset CA = [mset CA - mset Ls] ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#}", "using Ls_sub_CA"], ["proof (prove)\nusing this:\n  {#Pos (atm_of x). x \\<in># mset Ls#} = mset Ls\n  mset Ls \\<subseteq># mset CA\n\ngoal (1 subgoal):\n 1. mset CA = [mset CA - mset Ls] ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#}", "by auto"], ["proof (state)\nthis:\n  mset CA = [mset CA - mset Ls] ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#}\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  mset CA = [mset CA - mset Ls] ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#}\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"Ls \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ls \\<noteq> []", "using \\<sigma>_p"], ["proof (prove)\nusing this:\n  mgu {insert A (atms_of (mset Ls))} = Some \\<sigma>\n  Ls \\<noteq> []\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ((mset CA - mset Ls) \\<cdot> \\<sigma>)\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (1 subgoal):\n 1. Ls \\<noteq> []", "by -"], ["proof (state)\nthis:\n  Ls \\<noteq> []\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  Ls \\<noteq> []\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"Some \\<sigma> = mgu {insert A (atm_of ` set Ls)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some \\<sigma> = mgu {insert A (atm_of ` set Ls)}", "using \\<sigma>_p"], ["proof (prove)\nusing this:\n  mgu {insert A (atms_of (mset Ls))} = Some \\<sigma>\n  Ls \\<noteq> []\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ((mset CA - mset Ls) \\<cdot> \\<sigma>)\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (1 subgoal):\n 1. Some \\<sigma> = mgu {insert A (atm_of ` set Ls)}", "unfolding atms_of_def"], ["proof (prove)\nusing this:\n  mgu {insert A (atm_of ` set_mset (mset Ls))} = Some \\<sigma>\n  Ls \\<noteq> []\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ((mset CA - mset Ls) \\<cdot> \\<sigma>)\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (1 subgoal):\n 1. Some \\<sigma> = mgu {insert A (atm_of ` set Ls)}", "by auto"], ["proof (state)\nthis:\n  Some \\<sigma> = mgu {insert A (atm_of ` set Ls)}\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  Some \\<sigma> = mgu {insert A (atm_of ` set Ls)}\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))", "using \\<sigma>_p"], ["proof (prove)\nusing this:\n  mgu {insert A (atms_of (mset Ls))} = Some \\<sigma>\n  Ls \\<noteq> []\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ((mset CA - mset Ls) \\<cdot> \\<sigma>)\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (1 subgoal):\n 1. eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))", "by -"], ["proof (state)\nthis:\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"strictly_maximal_wrt (A \\<cdot>a \\<sigma>) ([mset CA - mset Ls] ! 0 \\<cdot> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n     ([mset CA - mset Ls] ! 0 \\<cdot> \\<sigma>)", "using \\<sigma>_p(4)"], ["proof (prove)\nusing this:\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ((mset CA - mset Ls) \\<cdot> \\<sigma>)\n\ngoal (1 subgoal):\n 1. strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n     ([mset CA - mset Ls] ! 0 \\<cdot> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ([mset CA - mset Ls] ! 0 \\<cdot> \\<sigma>)\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ([mset CA - mset Ls] ! 0 \\<cdot> \\<sigma>)\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"S (mset CA) = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S (mset CA) = {#}", "by (simp add: S_empty)"], ["proof (state)\nthis:\n  S (mset CA) = {#}\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "ultimately"], ["proof (chain)\npicking this:\n  mset (resolvent D A CA Ls) =\n  sum_list [mset CA - mset Ls] \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  length [mset CA - mset Ls] = Suc 0\n  mset CA = [mset CA - mset Ls] ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#}\n  Ls \\<noteq> []\n  Some \\<sigma> = mgu {insert A (atm_of ` set Ls)}\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ([mset CA - mset Ls] ! 0 \\<cdot> \\<sigma>)\n  S (mset CA) = {#}", "have \"\\<exists>Cs. mset (resolvent D A CA Ls) = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n        \\<and> length Cs = Suc 0 \\<and> mset CA = Cs ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#}\n        \\<and> Ls \\<noteq> [] \\<and> Some \\<sigma> = mgu {insert A (atm_of ` set Ls)}\n        \\<and> eligible S \\<sigma> [A] (add_mset (Neg A) (mset D)) \\<and> strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (Cs ! 0 \\<cdot> \\<sigma>)\n        \\<and> S (mset CA) = {#}\""], ["proof (prove)\nusing this:\n  mset (resolvent D A CA Ls) =\n  sum_list [mset CA - mset Ls] \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  length [mset CA - mset Ls] = Suc 0\n  mset CA = [mset CA - mset Ls] ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#}\n  Ls \\<noteq> []\n  Some \\<sigma> = mgu {insert A (atm_of ` set Ls)}\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n   ([mset CA - mset Ls] ! 0 \\<cdot> \\<sigma>)\n  S (mset CA) = {#}\n\ngoal (1 subgoal):\n 1. \\<exists>Cs.\n       mset (resolvent D A CA Ls) =\n       sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma> \\<and>\n       length Cs = Suc 0 \\<and>\n       mset CA = Cs ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#} \\<and>\n       Ls \\<noteq> [] \\<and>\n       Some \\<sigma> = mgu {insert A (atm_of ` set Ls)} \\<and>\n       eligible S \\<sigma> [A] (add_mset (Neg A) (mset D)) \\<and>\n       strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n        (Cs ! 0 \\<cdot> \\<sigma>) \\<and>\n       S (mset CA) = {#}", "by blast"], ["proof (state)\nthis:\n  \\<exists>Cs.\n     mset (resolvent D A CA Ls) =\n     sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma> \\<and>\n     length Cs = Suc 0 \\<and>\n     mset CA = Cs ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#} \\<and>\n     Ls \\<noteq> [] \\<and>\n     Some \\<sigma> = mgu {insert A (atm_of ` set Ls)} \\<and>\n     eligible S \\<sigma> [A] (add_mset (Neg A) (mset D)) \\<and>\n     strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n      (Cs ! 0 \\<cdot> \\<sigma>) \\<and>\n     S (mset CA) = {#}\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  \\<exists>Cs.\n     mset (resolvent D A CA Ls) =\n     sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma> \\<and>\n     length Cs = Suc 0 \\<and>\n     mset CA = Cs ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#} \\<and>\n     Ls \\<noteq> [] \\<and>\n     Some \\<sigma> = mgu {insert A (atm_of ` set Ls)} \\<and>\n     eligible S \\<sigma> [A] (add_mset (Neg A) (mset D)) \\<and>\n     strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n      (Cs ! 0 \\<cdot> \\<sigma>) \\<and>\n     S (mset CA) = {#}", "have \"ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [image_mset atm_of (mset Ls)] [A]\n      \\<sigma> (mset (resolvent D A CA Ls))\""], ["proof (prove)\nusing this:\n  \\<exists>Cs.\n     mset (resolvent D A CA Ls) =\n     sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma> \\<and>\n     length Cs = Suc 0 \\<and>\n     mset CA = Cs ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#} \\<and>\n     Ls \\<noteq> [] \\<and>\n     Some \\<sigma> = mgu {insert A (atm_of ` set Ls)} \\<and>\n     eligible S \\<sigma> [A] (add_mset (Neg A) (mset D)) \\<and>\n     strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n      (Cs ! 0 \\<cdot> \\<sigma>) \\<and>\n     S (mset CA) = {#}\n\ngoal (1 subgoal):\n 1. ord_resolve S [mset CA] (add_mset (Neg A) (mset D))\n     [image_mset atm_of (mset Ls)] [A] \\<sigma> (mset (resolvent D A CA Ls))", "unfolding ord_resolve.simps"], ["proof (prove)\nusing this:\n  \\<exists>Cs.\n     mset (resolvent D A CA Ls) =\n     sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma> \\<and>\n     length Cs = Suc 0 \\<and>\n     mset CA = Cs ! 0 + {#Pos (atm_of x). x \\<in># mset Ls#} \\<and>\n     Ls \\<noteq> [] \\<and>\n     Some \\<sigma> = mgu {insert A (atm_of ` set Ls)} \\<and>\n     eligible S \\<sigma> [A] (add_mset (Neg A) (mset D)) \\<and>\n     strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n      (Cs ! 0 \\<cdot> \\<sigma>) \\<and>\n     S (mset CA) = {#}\n\ngoal (1 subgoal):\n 1. \\<exists>CAs n Cs AAs As \\<sigma>' Da.\n       [mset CA] = CAs \\<and>\n       add_mset (Neg A) (mset D) = Da + negs (mset As) \\<and>\n       [image_mset atm_of (mset Ls)] = AAs \\<and>\n       [A] = As \\<and>\n       \\<sigma> = \\<sigma>' \\<and>\n       mset (resolvent D A CA Ls) =\n       (\\<Sum>\\<^sub># (mset Cs) + Da) \\<cdot> \\<sigma>' \\<and>\n       length CAs = n \\<and>\n       length Cs = n \\<and>\n       length AAs = n \\<and>\n       length As = n \\<and>\n       n \\<noteq> 0 \\<and>\n       (\\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)) \\<and>\n       (\\<forall>i<n. AAs ! i \\<noteq> {#}) \\<and>\n       Some \\<sigma>' =\n       mgu (set_mset ` set (Map2.map2 add_mset As AAs)) \\<and>\n       eligible S \\<sigma>' As (Da + negs (mset As)) \\<and>\n       (\\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>')\n            (Cs ! i \\<cdot> \\<sigma>')) \\<and>\n       (\\<forall>i<n. S (CAs ! i) = {#})", "by auto"], ["proof (state)\nthis:\n  ord_resolve S [mset CA] (add_mset (Neg A) (mset D))\n   [image_mset atm_of (mset Ls)] [A] \\<sigma> (mset (resolvent D A CA Ls))\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  ord_resolve S [mset CA] (add_mset (Neg A) (mset D))\n   [image_mset atm_of (mset Ls)] [A] \\<sigma> (mset (resolvent D A CA Ls))", "have \"\\<exists>AA \\<sigma>. ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] \\<sigma> (mset E)\""], ["proof (prove)\nusing this:\n  ord_resolve S [mset CA] (add_mset (Neg A) (mset D))\n   [image_mset atm_of (mset Ls)] [A] \\<sigma> (mset (resolvent D A CA Ls))\n\ngoal (1 subgoal):\n 1. \\<exists>AA \\<sigma>.\n       ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] \\<sigma>\n        (mset E)", "using Ls_p"], ["proof (prove)\nusing this:\n  ord_resolve S [mset CA] (add_mset (Neg A) (mset D))\n   [image_mset atm_of (mset Ls)] [A] \\<sigma> (mset (resolvent D A CA Ls))\n  resolvent D A CA Ls = E\n  subseq Ls CA \\<and> resolvable A D CA Ls\n\ngoal (1 subgoal):\n 1. \\<exists>AA \\<sigma>.\n       ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] \\<sigma>\n        (mset E)", "by auto"], ["proof (state)\nthis:\n  \\<exists>AA \\<sigma>.\n     ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] \\<sigma>\n      (mset E)\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "}"], ["proof (state)\nthis:\n  ?E2 \\<in> set (resolve_on A D CA) \\<Longrightarrow>\n  \\<exists>AA \\<sigma>.\n     ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] \\<sigma>\n      (mset ?E2)\n\ngoal (2 subgoals):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}\n 2. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  ?E2 \\<in> set (resolve_on A D CA) \\<Longrightarrow>\n  \\<exists>AA \\<sigma>.\n     ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] \\<sigma>\n      (mset ?E2)", "show \"mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>. ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\""], ["proof (prove)\nusing this:\n  ?E2 \\<in> set (resolve_on A D CA) \\<Longrightarrow>\n  \\<exists>AA \\<sigma>.\n     ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] \\<sigma>\n      (mset ?E2)\n\ngoal (1 subgoal):\n 1. mset ` set (resolve_on A D CA)\n    \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                       ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                        \\<sigma> E}", "by auto"], ["proof (state)\nthis:\n  mset ` set (resolve_on A D CA)\n  \\<subseteq> {E. \\<exists>AA \\<sigma>.\n                     ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A]\n                      \\<sigma> E}\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "fix E AA \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "assume \"ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] \\<sigma> E\""], ["proof (state)\nthis:\n  ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] \\<sigma> E\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] \\<sigma> E", "obtain Cs where res': \"E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\"\n      \"length Cs = Suc 0\"\n      \"mset CA = Cs ! 0 + poss AA\"\n      \"AA \\<noteq> {#}\"\n      \"Some \\<sigma> = mgu {insert A (set_mset AA)}\"\n      \"eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\"\n      \"strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (Cs ! 0 \\<cdot> \\<sigma>)\"\n      \"S (Cs ! 0 + poss AA) = {#}\""], ["proof (prove)\nusing this:\n  ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] \\<sigma> E\n\ngoal (1 subgoal):\n 1. (\\<And>Cs.\n        \\<lbrakk>E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>;\n         length Cs = Suc 0; mset CA = Cs ! 0 + poss AA; AA \\<noteq> {#};\n         Some \\<sigma> = mgu {insert A (set_mset AA)};\n         eligible S \\<sigma> [A] (add_mset (Neg A) (mset D));\n         strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n          (Cs ! 0 \\<cdot> \\<sigma>);\n         S (Cs ! 0 + poss AA) = {#}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ord_resolve.simps"], ["proof (prove)\nusing this:\n  \\<exists>CAs n Cs AAs As \\<sigma>' Da.\n     [mset CA] = CAs \\<and>\n     add_mset (Neg A) (mset D) = Da + negs (mset As) \\<and>\n     [AA] = AAs \\<and>\n     [A] = As \\<and>\n     \\<sigma> = \\<sigma>' \\<and>\n     E = (\\<Sum>\\<^sub># (mset Cs) + Da) \\<cdot> \\<sigma>' \\<and>\n     length CAs = n \\<and>\n     length Cs = n \\<and>\n     length AAs = n \\<and>\n     length As = n \\<and>\n     n \\<noteq> 0 \\<and>\n     (\\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)) \\<and>\n     (\\<forall>i<n. AAs ! i \\<noteq> {#}) \\<and>\n     Some \\<sigma>' =\n     mgu (set_mset ` set (Map2.map2 add_mset As AAs)) \\<and>\n     eligible S \\<sigma>' As (Da + negs (mset As)) \\<and>\n     (\\<forall>i<n.\n         strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>')\n          (Cs ! i \\<cdot> \\<sigma>')) \\<and>\n     (\\<forall>i<n. S (CAs ! i) = {#})\n\ngoal (1 subgoal):\n 1. (\\<And>Cs.\n        \\<lbrakk>E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>;\n         length Cs = Suc 0; mset CA = Cs ! 0 + poss AA; AA \\<noteq> {#};\n         Some \\<sigma> = mgu {insert A (set_mset AA)};\n         eligible S \\<sigma> [A] (add_mset (Neg A) (mset D));\n         strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n          (Cs ! 0 \\<cdot> \\<sigma>);\n         S (Cs ! 0 + poss AA) = {#}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  length Cs = Suc 0\n  mset CA = Cs ! 0 + poss AA\n  AA \\<noteq> {#}\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (Cs ! 0 \\<cdot> \\<sigma>)\n  S (Cs ! 0 + poss AA) = {#}\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  length Cs = Suc 0\n  mset CA = Cs ! 0 + poss AA\n  AA \\<noteq> {#}\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (Cs ! 0 \\<cdot> \\<sigma>)\n  S (Cs ! 0 + poss AA) = {#}\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "define C where \"C = Cs ! 0\""], ["proof (state)\nthis:\n  C = Cs ! 0\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "ultimately"], ["proof (chain)\npicking this:\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  length Cs = Suc 0\n  mset CA = Cs ! 0 + poss AA\n  AA \\<noteq> {#}\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (Cs ! 0 \\<cdot> \\<sigma>)\n  S (Cs ! 0 + poss AA) = {#}\n  C = Cs ! 0", "have res:\n      \"E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\"\n      \"mset CA = C + poss AA\"\n      \"AA \\<noteq> {#}\"\n      \"Some \\<sigma> = mgu {insert A (set_mset AA)}\"\n      \"eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\"\n      \"strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>)\"\n      \"S (C + poss AA) = {#}\""], ["proof (prove)\nusing this:\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  length Cs = Suc 0\n  mset CA = Cs ! 0 + poss AA\n  AA \\<noteq> {#}\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (Cs ! 0 \\<cdot> \\<sigma>)\n  S (Cs ! 0 + poss AA) = {#}\n  C = Cs ! 0\n\ngoal (1 subgoal):\n 1. (E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma> &&&\n     mset CA = C + poss AA &&& AA \\<noteq> {#}) &&&\n    (Some \\<sigma> = mgu {insert A (set_mset AA)} &&&\n     eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))) &&&\n    strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>) &&&\n    S (C + poss AA) = {#}", "unfolding ord_resolve.simps"], ["proof (prove)\nusing this:\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  length Cs = Suc 0\n  mset CA = Cs ! 0 + poss AA\n  AA \\<noteq> {#}\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (Cs ! 0 \\<cdot> \\<sigma>)\n  S (Cs ! 0 + poss AA) = {#}\n  C = Cs ! 0\n\ngoal (1 subgoal):\n 1. (E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma> &&&\n     mset CA = C + poss AA &&& AA \\<noteq> {#}) &&&\n    (Some \\<sigma> = mgu {insert A (set_mset AA)} &&&\n     eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))) &&&\n    strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>) &&&\n    S (C + poss AA) = {#}", "by auto"], ["proof (state)\nthis:\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  mset CA = C + poss AA\n  AA \\<noteq> {#}\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>)\n  S (C + poss AA) = {#}\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "from this(1)"], ["proof (chain)\npicking this:\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>", "have\n      \"E = C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\""], ["proof (prove)\nusing this:\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. E = C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>", "unfolding C_def"], ["proof (prove)\nusing this:\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. E = Cs ! 0 \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>", "using res'(2)"], ["proof (prove)\nusing this:\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  length Cs = Suc 0\n\ngoal (1 subgoal):\n 1. E = Cs ! 0 \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>", "by (cases Cs) auto"], ["proof (state)\nthis:\n  E = C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "note res' = this res(2-7)"], ["proof (state)\nthis:\n  E = C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  mset CA = C + poss AA\n  AA \\<noteq> {#}\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>)\n  S (C + poss AA) = {#}\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"\\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA", "using res(2)"], ["proof (prove)\nusing this:\n  mset CA = C + poss AA\n\ngoal (1 subgoal):\n 1. \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA", "proof (induction CA arbitrary: AA C)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>AA C.\n       mset [] = C + poss AA \\<Longrightarrow>\n       \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) []\n 2. \\<And>a CA AA C.\n       \\<lbrakk>\\<And>AA C.\n                   mset CA = C + poss AA \\<Longrightarrow>\n                   \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n        mset (a # CA) = C + poss AA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Al.\n                            mset Al = AA \\<and> subseq (map Pos Al) (a # CA)", "case Nil"], ["proof (state)\nthis:\n  mset [] = C + poss AA\n\ngoal (2 subgoals):\n 1. \\<And>AA C.\n       mset [] = C + poss AA \\<Longrightarrow>\n       \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) []\n 2. \\<And>a CA AA C.\n       \\<lbrakk>\\<And>AA C.\n                   mset CA = C + poss AA \\<Longrightarrow>\n                   \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n        mset (a # CA) = C + poss AA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Al.\n                            mset Al = AA \\<and> subseq (map Pos Al) (a # CA)", "then"], ["proof (chain)\npicking this:\n  mset [] = C + poss AA", "show ?case"], ["proof (prove)\nusing this:\n  mset [] = C + poss AA\n\ngoal (1 subgoal):\n 1. \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) []", "by auto"], ["proof (state)\nthis:\n  \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) []\n\ngoal (1 subgoal):\n 1. \\<And>a CA AA C.\n       \\<lbrakk>\\<And>AA C.\n                   mset CA = C + poss AA \\<Longrightarrow>\n                   \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n        mset (a # CA) = C + poss AA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Al.\n                            mset Al = AA \\<and> subseq (map Pos Al) (a # CA)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a CA AA C.\n       \\<lbrakk>\\<And>AA C.\n                   mset CA = C + poss AA \\<Longrightarrow>\n                   \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n        mset (a # CA) = C + poss AA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Al.\n                            mset Al = AA \\<and> subseq (map Pos Al) (a # CA)", "case (Cons L CA)"], ["proof (state)\nthis:\n  mset CA = ?C + poss ?AA \\<Longrightarrow>\n  \\<exists>Al. mset Al = ?AA \\<and> subseq (map Pos Al) CA\n  mset (L # CA) = C + poss AA\n\ngoal (1 subgoal):\n 1. \\<And>a CA AA C.\n       \\<lbrakk>\\<And>AA C.\n                   mset CA = C + poss AA \\<Longrightarrow>\n                   \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n        mset (a # CA) = C + poss AA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Al.\n                            mset Al = AA \\<and> subseq (map Pos Al) (a # CA)", "then"], ["proof (chain)\npicking this:\n  mset CA = ?C + poss ?AA \\<Longrightarrow>\n  \\<exists>Al. mset Al = ?AA \\<and> subseq (map Pos Al) CA\n  mset (L # CA) = C + poss AA", "show ?case"], ["proof (prove)\nusing this:\n  mset CA = ?C + poss ?AA \\<Longrightarrow>\n  \\<exists>Al. mset Al = ?AA \\<and> subseq (map Pos Al) CA\n  mset (L # CA) = C + poss AA\n\ngoal (1 subgoal):\n 1. \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "proof (cases \"L \\<in># poss AA \")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<in># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)\n 2. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "case True"], ["proof (state)\nthis:\n  L \\<in># poss AA\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<in># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)\n 2. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "then"], ["proof (chain)\npicking this:\n  L \\<in># poss AA", "have pos_L: \"is_pos L\""], ["proof (prove)\nusing this:\n  L \\<in># poss AA\n\ngoal (1 subgoal):\n 1. is_pos L", "by auto"], ["proof (state)\nthis:\n  is_pos L\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<in># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)\n 2. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "have rem: \"\\<And>A'. Pos A' \\<in># poss AA \\<Longrightarrow>\n          remove1_mset (Pos A') (C + poss AA) = C + poss (remove1_mset A' AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A'.\n       Pos A' \\<in># poss AA \\<Longrightarrow>\n       remove1_mset (Pos A') (C + poss AA) = C + poss (remove1_mset A' AA)", "by (induct AA) auto"], ["proof (state)\nthis:\n  Pos ?A' \\<in># poss AA \\<Longrightarrow>\n  remove1_mset (Pos ?A') (C + poss AA) = C + poss (remove1_mset ?A' AA)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<in># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)\n 2. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "have \"mset CA = C + (poss (AA - {#atm_of L#}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset CA = C + poss (remove1_mset (atm_of L) AA)", "using True Cons(2)"], ["proof (prove)\nusing this:\n  L \\<in># poss AA\n  mset (L # CA) = C + poss AA\n\ngoal (1 subgoal):\n 1. mset CA = C + poss (remove1_mset (atm_of L) AA)", "by (metis add_mset_remove_trivial rem literal.collapse(1) mset.simps(2) pos_L)"], ["proof (state)\nthis:\n  mset CA = C + poss (remove1_mset (atm_of L) AA)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<in># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)\n 2. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "then"], ["proof (chain)\npicking this:\n  mset CA = C + poss (remove1_mset (atm_of L) AA)", "have \"\\<exists>Al. mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA\""], ["proof (prove)\nusing this:\n  mset CA = C + poss (remove1_mset (atm_of L) AA)\n\ngoal (1 subgoal):\n 1. \\<exists>Al.\n       mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA", "using Cons(1)[of _ \"((AA - {#atm_of L#}))\"]"], ["proof (prove)\nusing this:\n  mset CA = C + poss (remove1_mset (atm_of L) AA)\n  mset CA = ?C + poss (remove1_mset (atm_of L) AA) \\<Longrightarrow>\n  \\<exists>Al.\n     mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA\n\ngoal (1 subgoal):\n 1. \\<exists>Al.\n       mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA", "by metis"], ["proof (state)\nthis:\n  \\<exists>Al.\n     mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<in># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)\n 2. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "then"], ["proof (chain)\npicking this:\n  \\<exists>Al.\n     mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA", "obtain Al where\n          \"mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA\""], ["proof (prove)\nusing this:\n  \\<exists>Al.\n     mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA\n\ngoal (1 subgoal):\n 1. (\\<And>Al.\n        mset Al = remove1_mset (atm_of L) AA \\<and>\n        subseq (map Pos Al) CA \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<in># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)\n 2. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "then"], ["proof (chain)\npicking this:\n  mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA", "have\n          \"mset (atm_of L # Al) = AA\" and\n          \"subseq (map Pos (atm_of L # Al)) (L # CA)\""], ["proof (prove)\nusing this:\n  mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA\n\ngoal (1 subgoal):\n 1. mset (atm_of L # Al) = AA &&& subseq (map Pos (atm_of L # Al)) (L # CA)", "using True"], ["proof (prove)\nusing this:\n  mset Al = remove1_mset (atm_of L) AA \\<and> subseq (map Pos Al) CA\n  L \\<in># poss AA\n\ngoal (1 subgoal):\n 1. mset (atm_of L # Al) = AA &&& subseq (map Pos (atm_of L # Al)) (L # CA)", "by (auto simp add: pos_L)"], ["proof (state)\nthis:\n  mset (atm_of L # Al) = AA\n  subseq (map Pos (atm_of L # Al)) (L # CA)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<in># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)\n 2. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "then"], ["proof (chain)\npicking this:\n  mset (atm_of L # Al) = AA\n  subseq (map Pos (atm_of L # Al)) (L # CA)", "show ?thesis"], ["proof (prove)\nusing this:\n  mset (atm_of L # Al) = AA\n  subseq (map Pos (atm_of L # Al)) (L # CA)\n\ngoal (1 subgoal):\n 1. \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) (L # CA)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "case False"], ["proof (state)\nthis:\n  L \\<notin># poss AA\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "then"], ["proof (chain)\npicking this:\n  L \\<notin># poss AA", "have \"mset CA = remove1_mset L C + poss AA\""], ["proof (prove)\nusing this:\n  L \\<notin># poss AA\n\ngoal (1 subgoal):\n 1. mset CA = remove1_mset L C + poss AA", "using Cons(2)"], ["proof (prove)\nusing this:\n  L \\<notin># poss AA\n  mset (L # CA) = C + poss AA\n\ngoal (1 subgoal):\n 1. mset CA = remove1_mset L C + poss AA", "by (metis Un_iff add_mset_remove_trivial mset.simps(2) set_mset_union single_subset_iff\n              subset_mset.add_diff_assoc2 union_single_eq_member)"], ["proof (state)\nthis:\n  mset CA = remove1_mset L C + poss AA\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "then"], ["proof (chain)\npicking this:\n  mset CA = remove1_mset L C + poss AA", "have \"\\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA\""], ["proof (prove)\nusing this:\n  mset CA = remove1_mset L C + poss AA\n\ngoal (1 subgoal):\n 1. \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA", "using Cons(1)[of \"C - {#L#}\" AA] Cons(2)"], ["proof (prove)\nusing this:\n  mset CA = remove1_mset L C + poss AA\n  mset CA = remove1_mset L C + poss AA \\<Longrightarrow>\n  \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA\n  mset (L # CA) = C + poss AA\n\ngoal (1 subgoal):\n 1. \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA", "by auto"], ["proof (state)\nthis:\n  \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>C AA.\n                mset CA = C + poss AA \\<Longrightarrow>\n                \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA;\n     mset (L # CA) = C + poss AA; L \\<notin># poss AA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Al.\n                         mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "then"], ["proof (chain)\npicking this:\n  \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA\n\ngoal (1 subgoal):\n 1. \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) (L # CA)", "by auto"], ["proof (state)\nthis:\n  \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) (L # CA)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) (L # CA)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA", "obtain Al where Al_p: \"mset Al = AA\" \"subseq (map Pos Al) CA\""], ["proof (prove)\nusing this:\n  \\<exists>Al. mset Al = AA \\<and> subseq (map Pos Al) CA\n\ngoal (1 subgoal):\n 1. (\\<And>Al.\n        \\<lbrakk>mset Al = AA; subseq (map Pos Al) CA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset Al = AA\n  subseq (map Pos Al) CA\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "define Ls :: \"'a lclause\" where \"Ls = map Pos Al\""], ["proof (state)\nthis:\n  Ls = map Pos Al\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have diff: \"mset CA - mset Ls = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset CA - mset Ls = C", "unfolding Ls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset CA - mset (map Pos Al) = C", "using res(2) Al_p(1)"], ["proof (prove)\nusing this:\n  mset CA = C + poss AA\n  mset Al = AA\n\ngoal (1 subgoal):\n 1. mset CA - mset (map Pos Al) = C", "by auto"], ["proof (state)\nthis:\n  mset CA - mset Ls = C\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have ls_subq_ca: \"subseq Ls CA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq Ls CA", "unfolding Ls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq (map Pos Al) CA", "using Al_p"], ["proof (prove)\nusing this:\n  mset Al = AA\n  subseq (map Pos Al) CA\n\ngoal (1 subgoal):\n 1. subseq (map Pos Al) CA", "by -"], ["proof (state)\nthis:\n  subseq Ls CA\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  subseq Ls CA\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "{"], ["proof (state)\nthis:\n  subseq Ls CA\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"\\<exists>y. mgu {insert A (atms_of (mset Ls))} = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. mgu {insert A (atms_of (mset Ls))} = Some y", "unfolding Ls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. mgu {insert A (atms_of (mset (map Pos Al)))} = Some y", "using res(4) Al_p"], ["proof (prove)\nusing this:\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n  mset Al = AA\n  subseq (map Pos Al) CA\n\ngoal (1 subgoal):\n 1. \\<exists>y. mgu {insert A (atms_of (mset (map Pos Al)))} = Some y", "by (metis atms_of_poss mset_map)"], ["proof (state)\nthis:\n  \\<exists>y. mgu {insert A (atms_of (mset Ls))} = Some y\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  \\<exists>y. mgu {insert A (atms_of (mset Ls))} = Some y\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"Ls \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ls \\<noteq> []", "using Al_p(1) Ls_def res'(3)"], ["proof (prove)\nusing this:\n  mset Al = AA\n  Ls = map Pos Al\n  AA \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. Ls \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  Ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  Ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \\<sigma>_p: \"the (mgu {insert A (set Al)}) = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (mgu {insert A (set Al)}) = \\<sigma>", "using res'(4) Al_p(1)"], ["proof (prove)\nusing this:\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n  mset Al = AA\n\ngoal (1 subgoal):\n 1. the (mgu {insert A (set Al)}) = \\<sigma>", "by (metis option.sel  set_mset_mset)"], ["proof (state)\nthis:\n  the (mgu {insert A (set Al)}) = \\<sigma>\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  the (mgu {insert A (set Al)}) = \\<sigma>", "have \"eligible S (the (mgu {insert A (atms_of (mset Ls))})) [A]\n        (add_mset (Neg A) (mset D))\""], ["proof (prove)\nusing this:\n  the (mgu {insert A (set Al)}) = \\<sigma>\n\ngoal (1 subgoal):\n 1. eligible S (the (mgu {insert A (atms_of (mset Ls))})) [A]\n     (add_mset (Neg A) (mset D))", "unfolding Ls_def"], ["proof (prove)\nusing this:\n  the (mgu {insert A (set Al)}) = \\<sigma>\n\ngoal (1 subgoal):\n 1. eligible S (the (mgu {insert A (atms_of (mset (map Pos Al)))})) [A]\n     (add_mset (Neg A) (mset D))", "using res"], ["proof (prove)\nusing this:\n  the (mgu {insert A (set Al)}) = \\<sigma>\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  mset CA = C + poss AA\n  AA \\<noteq> {#}\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>)\n  S (C + poss AA) = {#}\n\ngoal (1 subgoal):\n 1. eligible S (the (mgu {insert A (atms_of (mset (map Pos Al)))})) [A]\n     (add_mset (Neg A) (mset D))", "by auto"], ["proof (state)\nthis:\n  eligible S (the (mgu {insert A (atms_of (mset Ls))})) [A]\n   (add_mset (Neg A) (mset D))\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  eligible S (the (mgu {insert A (atms_of (mset Ls))})) [A]\n   (add_mset (Neg A) (mset D))\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"strictly_maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n        ((mset CA - mset Ls) \\<cdot> the (mgu {insert A (atms_of (mset Ls))}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_maximal_wrt\n     (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n     ((mset CA - mset Ls) \\<cdot> the (mgu {insert A (atms_of (mset Ls))}))", "unfolding Ls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_maximal_wrt\n     (A \\<cdot>a the (mgu {insert A (atms_of (mset (map Pos Al)))}))\n     ((mset CA - mset (map Pos Al)) \\<cdot>\n      the (mgu {insert A (atms_of (mset (map Pos Al)))}))", "using res \\<sigma>_p Al_p"], ["proof (prove)\nusing this:\n  E = sum_list Cs \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  mset CA = C + poss AA\n  AA \\<noteq> {#}\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n  eligible S \\<sigma> [A] (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a \\<sigma>) (C \\<cdot> \\<sigma>)\n  S (C + poss AA) = {#}\n  the (mgu {insert A (set Al)}) = \\<sigma>\n  mset Al = AA\n  subseq (map Pos Al) CA\n\ngoal (1 subgoal):\n 1. strictly_maximal_wrt\n     (A \\<cdot>a the (mgu {insert A (atms_of (mset (map Pos Al)))}))\n     ((mset CA - mset (map Pos Al)) \\<cdot>\n      the (mgu {insert A (atms_of (mset (map Pos Al)))}))", "by auto"], ["proof (state)\nthis:\n  strictly_maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n   ((mset CA - mset Ls) \\<cdot> the (mgu {insert A (atms_of (mset Ls))}))\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  strictly_maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n   ((mset CA - mset Ls) \\<cdot> the (mgu {insert A (atms_of (mset Ls))}))\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"\\<forall>L \\<in> set Ls. is_pos L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>set Ls. is_pos L", "by (simp add: Ls_def)"], ["proof (state)\nthis:\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>y. mgu {insert A (atms_of (mset Ls))} = Some y\n  Ls \\<noteq> []\n  eligible S (the (mgu {insert A (atms_of (mset Ls))})) [A]\n   (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n   ((mset CA - mset Ls) \\<cdot> the (mgu {insert A (atms_of (mset Ls))}))\n  \\<forall>L\\<in>set Ls. is_pos L", "have \"resolvable A D CA Ls\""], ["proof (prove)\nusing this:\n  \\<exists>y. mgu {insert A (atms_of (mset Ls))} = Some y\n  Ls \\<noteq> []\n  eligible S (the (mgu {insert A (atms_of (mset Ls))})) [A]\n   (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n   ((mset CA - mset Ls) \\<cdot> the (mgu {insert A (atms_of (mset Ls))}))\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (1 subgoal):\n 1. resolvable A D CA Ls", "unfolding resolvable_def"], ["proof (prove)\nusing this:\n  \\<exists>y. mgu {insert A (atms_of (mset Ls))} = Some y\n  Ls \\<noteq> []\n  eligible S (the (mgu {insert A (atms_of (mset Ls))})) [A]\n   (add_mset (Neg A) (mset D))\n  strictly_maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n   ((mset CA - mset Ls) \\<cdot> the (mgu {insert A (atms_of (mset Ls))}))\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (1 subgoal):\n 1. let \\<sigma> = mgu {insert A (atms_of (mset Ls))}\n    in \\<sigma> \\<noteq> None \\<and>\n       Ls \\<noteq> [] \\<and>\n       maximal_wrt (A \\<cdot>a the \\<sigma>)\n        (add_mset (Neg A) (mset D) \\<cdot> the \\<sigma>) \\<and>\n       strictly_maximal_wrt (A \\<cdot>a the \\<sigma>)\n        ((mset CA - mset Ls) \\<cdot> the \\<sigma>) \\<and>\n       Ball (set Ls) is_pos", "unfolding eligible.simps"], ["proof (prove)\nusing this:\n  \\<exists>y. mgu {insert A (atms_of (mset Ls))} = Some y\n  Ls \\<noteq> []\n  \\<exists>DA As \\<sigma>.\n     the (mgu {insert A (atms_of (mset Ls))}) = \\<sigma> \\<and>\n     [A] = As \\<and>\n     add_mset (Neg A) (mset D) = DA \\<and>\n     (S DA = negs (mset As) \\<or>\n      S DA = {#} \\<and>\n      length As = 1 \\<and>\n      maximal_wrt (As ! 0 \\<cdot>a \\<sigma>) (DA \\<cdot> \\<sigma>))\n  strictly_maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n   ((mset CA - mset Ls) \\<cdot> the (mgu {insert A (atms_of (mset Ls))}))\n  \\<forall>L\\<in>set Ls. is_pos L\n\ngoal (1 subgoal):\n 1. let \\<sigma> = mgu {insert A (atms_of (mset Ls))}\n    in \\<sigma> \\<noteq> None \\<and>\n       Ls \\<noteq> [] \\<and>\n       maximal_wrt (A \\<cdot>a the \\<sigma>)\n        (add_mset (Neg A) (mset D) \\<cdot> the \\<sigma>) \\<and>\n       strictly_maximal_wrt (A \\<cdot>a the \\<sigma>)\n        ((mset CA - mset Ls) \\<cdot> the \\<sigma>) \\<and>\n       Ball (set Ls) is_pos", "using S_empty"], ["proof (prove)\nusing this:\n  \\<exists>y. mgu {insert A (atms_of (mset Ls))} = Some y\n  Ls \\<noteq> []\n  \\<exists>DA As \\<sigma>.\n     the (mgu {insert A (atms_of (mset Ls))}) = \\<sigma> \\<and>\n     [A] = As \\<and>\n     add_mset (Neg A) (mset D) = DA \\<and>\n     (S DA = negs (mset As) \\<or>\n      S DA = {#} \\<and>\n      length As = 1 \\<and>\n      maximal_wrt (As ! 0 \\<cdot>a \\<sigma>) (DA \\<cdot> \\<sigma>))\n  strictly_maximal_wrt (A \\<cdot>a the (mgu {insert A (atms_of (mset Ls))}))\n   ((mset CA - mset Ls) \\<cdot> the (mgu {insert A (atms_of (mset Ls))}))\n  \\<forall>L\\<in>set Ls. is_pos L\n  S ?C = {#}\n\ngoal (1 subgoal):\n 1. let \\<sigma> = mgu {insert A (atms_of (mset Ls))}\n    in \\<sigma> \\<noteq> None \\<and>\n       Ls \\<noteq> [] \\<and>\n       maximal_wrt (A \\<cdot>a the \\<sigma>)\n        (add_mset (Neg A) (mset D) \\<cdot> the \\<sigma>) \\<and>\n       strictly_maximal_wrt (A \\<cdot>a the \\<sigma>)\n        ((mset CA - mset Ls) \\<cdot> the \\<sigma>) \\<and>\n       Ball (set Ls) is_pos", "by simp"], ["proof (state)\nthis:\n  resolvable A D CA Ls\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "}"], ["proof (state)\nthis:\n  resolvable A D CA Ls\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "moreover"], ["proof (state)\nthis:\n  resolvable A D CA Ls\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have ls_sub_ca: \"mset Ls \\<subseteq># mset CA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset Ls \\<subseteq># mset CA", "using ls_subq_ca subseq_mset_subseteq_mset[of Ls CA]"], ["proof (prove)\nusing this:\n  subseq Ls CA\n  subseq Ls CA \\<Longrightarrow> mset Ls \\<subseteq># mset CA\n\ngoal (1 subgoal):\n 1. mset Ls \\<subseteq># mset CA", "by simp"], ["proof (state)\nthis:\n  mset Ls \\<subseteq># mset CA\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "have \"{#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} + {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} = C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n    {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n    C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>", "using diff"], ["proof (prove)\nusing this:\n  mset CA - mset Ls = C\n\ngoal (1 subgoal):\n 1. {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n    {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n    C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>", "unfolding subst_cls_def"], ["proof (prove)\nusing this:\n  mset CA - mset Ls = C\n\ngoal (1 subgoal):\n 1. {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n    {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n    {#A \\<cdot>l \\<sigma>. A \\<in># C#} +\n    {#A \\<cdot>l \\<sigma>. A \\<in># mset D#}", "by simp"], ["proof (state)\nthis:\n  {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>", "have \"{#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} + {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} = E\""], ["proof (prove)\nusing this:\n  {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n    {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n    E", "using res'(1)"], ["proof (prove)\nusing this:\n  {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n  E = C \\<cdot> \\<sigma> + mset D \\<cdot> \\<sigma>\n\ngoal (1 subgoal):\n 1. {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n    {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n    E", "by auto"], ["proof (state)\nthis:\n  {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  E\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  E", "have \"{#M \\<cdot>l \\<sigma>. M \\<in># mset (remove_all CA Ls)#} + {#M \\<cdot>l \\<sigma> . M \\<in># mset D#} = E\""], ["proof (prove)\nusing this:\n  {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  E\n\ngoal (1 subgoal):\n 1. {#M \\<cdot>l \\<sigma>. M \\<in># mset (remove_all CA Ls)#} +\n    {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n    E", "using remove_all_mset_minus[of Ls CA] ls_sub_ca"], ["proof (prove)\nusing this:\n  {#x \\<cdot>l \\<sigma>. x \\<in># mset CA - mset Ls#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  E\n  mset Ls \\<subseteq># mset CA \\<Longrightarrow>\n  mset (remove_all CA Ls) = mset CA - mset Ls\n  mset Ls \\<subseteq># mset CA\n\ngoal (1 subgoal):\n 1. {#M \\<cdot>l \\<sigma>. M \\<in># mset (remove_all CA Ls)#} +\n    {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n    E", "by auto"], ["proof (state)\nthis:\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset (remove_all CA Ls)#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  E\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset (remove_all CA Ls)#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  E", "have \"mset (resolvent D A CA Ls) = E\""], ["proof (prove)\nusing this:\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset (remove_all CA Ls)#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  E\n\ngoal (1 subgoal):\n 1. mset (resolvent D A CA Ls) = E", "unfolding resolvable_def Let_def resolvent_def"], ["proof (prove)\nusing this:\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset (remove_all CA Ls)#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  E\n\ngoal (1 subgoal):\n 1. mset\n     (map (\\<lambda>M. M \\<cdot>l the (mgu {insert A (atms_of (mset Ls))}))\n       (remove_all CA Ls @ D)) =\n    E", "using Al_p(1) Ls_def atms_of_poss res'(4)"], ["proof (prove)\nusing this:\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset (remove_all CA Ls)#} +\n  {#M \\<cdot>l \\<sigma>. M \\<in># mset D#} =\n  E\n  mset Al = AA\n  Ls = map Pos Al\n  atms_of (poss ?AA) = set_mset ?AA\n  Some \\<sigma> = mgu {insert A (set_mset AA)}\n\ngoal (1 subgoal):\n 1. mset\n     (map (\\<lambda>M. M \\<cdot>l the (mgu {insert A (atms_of (mset Ls))}))\n       (remove_all CA Ls @ D)) =\n    E", "by (metis image_mset_union mset_append mset_map option.sel)"], ["proof (state)\nthis:\n  mset (resolvent D A CA Ls) = E\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "ultimately"], ["proof (chain)\npicking this:\n  subseq Ls CA\n  resolvable A D CA Ls\n  mset (resolvent D A CA Ls) = E", "have \"E \\<in> mset ` set (resolve_on A D CA)\""], ["proof (prove)\nusing this:\n  subseq Ls CA\n  resolvable A D CA Ls\n  mset (resolvent D A CA Ls) = E\n\ngoal (1 subgoal):\n 1. E \\<in> mset ` set (resolve_on A D CA)", "unfolding resolve_on_def"], ["proof (prove)\nusing this:\n  subseq Ls CA\n  resolvable A D CA Ls\n  mset (resolvent D A CA Ls) = E\n\ngoal (1 subgoal):\n 1. E \\<in> mset `\n            set (map (resolvent D A CA)\n                  (filter (resolvable A D CA) (subseqs CA)))", "by auto"], ["proof (state)\nthis:\n  E \\<in> mset ` set (resolve_on A D CA)\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "}"], ["proof (state)\nthis:\n  ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [?AA2] [A] ?\\<sigma>2\n   ?E2 \\<Longrightarrow>\n  ?E2 \\<in> mset ` set (resolve_on A D CA)\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "then"], ["proof (chain)\npicking this:\n  ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [?AA2] [A] ?\\<sigma>2\n   ?E2 \\<Longrightarrow>\n  ?E2 \\<in> mset ` set (resolve_on A D CA)", "show \"{E. \\<exists>AA \\<sigma>. ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)\""], ["proof (prove)\nusing this:\n  ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [?AA2] [A] ?\\<sigma>2\n   ?E2 \\<Longrightarrow>\n  ?E2 \\<in> mset ` set (resolve_on A D CA)\n\ngoal (1 subgoal):\n 1. {E. \\<exists>AA \\<sigma>.\n           ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n    \\<subseteq> mset ` set (resolve_on A D CA)", "by auto"], ["proof (state)\nthis:\n  {E. \\<exists>AA \\<sigma>.\n         ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] \\<sigma> E}\n  \\<subseteq> mset ` set (resolve_on A D CA)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_resolve_eq_UNION_set_resolve_on:\n  \"set (resolve C D) =\n   (\\<Union>L \\<in> set D.\n      (case L of\n         Pos _ \\<Rightarrow> {}\n       | Neg A \\<Rightarrow> if maximal_wrt A (mset D) then set (resolve_on A (remove1 L D) C) else {}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (resolve C D) =\n    (\\<Union>L\\<in>set D.\n        case L of Pos x \\<Rightarrow> {}\n        | Neg A \\<Rightarrow>\n            if maximal_wrt A (mset D)\n            then set (resolve_on A (remove1 L D) C) else {})", "unfolding resolve_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>L.\n                   case L of Pos A \\<Rightarrow> []\n                   | Neg A \\<Rightarrow>\n                       if maximal_wrt A (mset D)\n                       then resolve_on A (remove1 L D) C else [])\n            D)) =\n    (\\<Union>L\\<in>set D.\n        case L of Pos x \\<Rightarrow> {}\n        | Neg A \\<Rightarrow>\n            if maximal_wrt A (mset D)\n            then set (resolve_on A (remove1 L D) C) else {})", "by (fastforce split: literal.splits if_splits)"], ["", "lemma resolve_eq_Bin_ord_resolve: \"mset ` set (resolve C D) = Bin_ord_resolve (mset C) (mset D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` set (resolve C D) = Bin_ord_resolve (mset C) (mset D)", "unfolding set_resolve_eq_UNION_set_resolve_on"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset `\n    (\\<Union>L\\<in>set D.\n        case L of Pos x \\<Rightarrow> {}\n        | Neg A \\<Rightarrow>\n            if maximal_wrt A (mset D)\n            then set (resolve_on A (remove1 L D) C) else {}) =\n    Bin_ord_resolve (mset C) (mset D)", "apply (unfold image_UN literal.case_distrib if_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>set D.\n        case x of Pos x \\<Rightarrow> mset ` {}\n        | Neg xa \\<Rightarrow>\n            if maximal_wrt xa (mset D)\n            then mset ` set (resolve_on xa (remove1 x D) C)\n            else mset ` {}) =\n    Bin_ord_resolve (mset C) (mset D)", "apply (subst resolve_on_eq_UNION_Bin_ord_resolve)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>set D.\n        case x of Pos x \\<Rightarrow> mset ` {}\n        | Neg xa \\<Rightarrow>\n            if maximal_wrt xa (mset D)\n            then {E. \\<exists>AA \\<sigma>.\n                        ord_resolve S [mset C]\n                         ({#Neg xa#} + mset (remove1 x D)) [AA] [xa]\n                         \\<sigma> E}\n            else mset ` {}) =\n    Bin_ord_resolve (mset C) (mset D)", "apply (rule order_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Union>x\\<in>set D.\n        case x of Pos x \\<Rightarrow> mset ` {}\n        | Neg xa \\<Rightarrow>\n            if maximal_wrt xa (mset D)\n            then {E. \\<exists>AA \\<sigma>.\n                        ord_resolve S [mset C]\n                         ({#Neg xa#} + mset (remove1 x D)) [AA] [xa]\n                         \\<sigma> E}\n            else mset ` {})\n    \\<subseteq> Bin_ord_resolve (mset C) (mset D)\n 2. Bin_ord_resolve (mset C) (mset D)\n    \\<subseteq> (\\<Union>x\\<in>set D.\n                    case x of Pos x \\<Rightarrow> mset ` {}\n                    | Neg xa \\<Rightarrow>\n                        if maximal_wrt xa (mset D)\n                        then {E. \\<exists>AA \\<sigma>.\n                                    ord_resolve S [mset C]\n                                     ({#Neg xa#} + mset (remove1 x D)) [AA]\n                                     [xa] \\<sigma> E}\n                        else mset ` {})", "apply (force split: literal.splits if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bin_ord_resolve (mset C) (mset D)\n    \\<subseteq> (\\<Union>x\\<in>set D.\n                    case x of Pos x \\<Rightarrow> mset ` {}\n                    | Neg xa \\<Rightarrow>\n                        if maximal_wrt xa (mset D)\n                        then {E. \\<exists>AA \\<sigma>.\n                                    ord_resolve S [mset C]\n                                     ({#Neg xa#} + mset (remove1 x D)) [AA]\n                                     [xa] \\<sigma> E}\n                        else mset ` {})", "apply (clarsimp split: literal.splits if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       \\<exists>xa\\<in>set D.\n          (\\<forall>x1. xa \\<noteq> Pos x1) \\<and>\n          (\\<forall>x2.\n              (maximal_wrt x2 (mset D) \\<longrightarrow>\n               xa = Neg x2 \\<longrightarrow>\n               (\\<exists>AA \\<sigma>.\n                   ord_resolve S [mset C]\n                    (add_mset (Neg x2) (remove1_mset (Neg x2) (mset D)))\n                    [AA] [x2] \\<sigma> x)) \\<and>\n              (\\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n               xa \\<noteq> Neg x2))", "apply (rule_tac x = \"Neg A\" in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       (\\<forall>x1. Neg A \\<noteq> Pos x1) \\<and>\n       (\\<forall>x2.\n           (maximal_wrt x2 (mset D) \\<longrightarrow>\n            Neg A = Neg x2 \\<longrightarrow>\n            (\\<exists>AA \\<sigma>.\n                ord_resolve S [mset C]\n                 (add_mset (Neg x2) (remove1_mset (Neg x2) (mset D))) [AA]\n                 [x2] \\<sigma> x)) \\<and>\n           (\\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n            Neg A \\<noteq> Neg x2))\n 2. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       \\<forall>x1. Neg A \\<noteq> Pos x1\n 2. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       \\<forall>x2.\n          (maximal_wrt x2 (mset D) \\<longrightarrow>\n           Neg A = Neg x2 \\<longrightarrow>\n           (\\<exists>AA \\<sigma>.\n               ord_resolve S [mset C]\n                (add_mset (Neg x2) (remove1_mset (Neg x2) (mset D))) [AA]\n                [x2] \\<sigma> x)) \\<and>\n          (\\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n           Neg A \\<noteq> Neg x2)\n 3. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       \\<forall>x2.\n          (maximal_wrt x2 (mset D) \\<longrightarrow>\n           Neg A = Neg x2 \\<longrightarrow>\n           (\\<exists>AA \\<sigma>.\n               ord_resolve S [mset C]\n                (add_mset (Neg x2) (remove1_mset (Neg x2) (mset D))) [AA]\n                [x2] \\<sigma> x)) \\<and>\n          (\\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n           Neg A \\<noteq> Neg x2)\n 2. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x AA A \\<sigma> x2.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       (maximal_wrt x2 (mset D) \\<longrightarrow>\n        Neg A = Neg x2 \\<longrightarrow>\n        (\\<exists>AA \\<sigma>.\n            ord_resolve S [mset C]\n             (add_mset (Neg x2) (remove1_mset (Neg x2) (mset D))) [AA] [x2]\n             \\<sigma> x)) \\<and>\n       (\\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n        Neg A \\<noteq> Neg x2)\n 2. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x AA A \\<sigma> x2.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       maximal_wrt x2 (mset D) \\<longrightarrow>\n       Neg A = Neg x2 \\<longrightarrow>\n       (\\<exists>AA \\<sigma>.\n           ord_resolve S [mset C]\n            (add_mset (Neg x2) (remove1_mset (Neg x2) (mset D))) [AA] [x2]\n            \\<sigma> x)\n 2. \\<And>x AA A \\<sigma> x2.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       \\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n       Neg A \\<noteq> Neg x2\n 3. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x AA A \\<sigma> x2.\n       \\<lbrakk>ord_resolve S [mset C] (mset D) [AA] [x2] \\<sigma> x;\n        maximal_wrt x2 (mset D)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA \\<sigma>.\n                            ord_resolve S [mset C]\n                             (add_mset (Neg x2)\n                               (remove1_mset (Neg x2) (mset D)))\n                             [AA] [x2] \\<sigma> x\n 2. \\<And>x AA A \\<sigma> x2.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       \\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n       Neg A \\<noteq> Neg x2\n 3. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply (rule_tac x = AA in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x AA A \\<sigma> x2.\n       \\<lbrakk>ord_resolve S [mset C] (mset D) [AA] [x2] \\<sigma> x;\n        maximal_wrt x2 (mset D)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S [mset C]\n                             (add_mset (Neg x2)\n                               (remove1_mset (Neg x2) (mset D)))\n                             [AA] [x2] \\<sigma> x\n 2. \\<And>x AA A \\<sigma> x2.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       \\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n       Neg A \\<noteq> Neg x2\n 3. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply (rule_tac x = \\<sigma> in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x AA A \\<sigma> x2.\n       \\<lbrakk>ord_resolve S [mset C] (mset D) [AA] [x2] \\<sigma> x;\n        maximal_wrt x2 (mset D)\\<rbrakk>\n       \\<Longrightarrow> ord_resolve S [mset C]\n                          (add_mset (Neg x2)\n                            (remove1_mset (Neg x2) (mset D)))\n                          [AA] [x2] \\<sigma> x\n 2. \\<And>x AA A \\<sigma> x2.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       \\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n       Neg A \\<noteq> Neg x2\n 3. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply (frule ord_resolve.simps[THEN iffD1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x AA A \\<sigma> x2.\n       \\<lbrakk>ord_resolve S [mset C] (mset D) [AA] [x2] \\<sigma> x;\n        maximal_wrt x2 (mset D);\n        \\<exists>CAs n Cs AAs As \\<sigma>' Da.\n           [mset C] = CAs \\<and>\n           mset D = Da + negs (mset As) \\<and>\n           [AA] = AAs \\<and>\n           [x2] = As \\<and>\n           \\<sigma> = \\<sigma>' \\<and>\n           x = (\\<Sum>\\<^sub># (mset Cs) + Da) \\<cdot> \\<sigma>' \\<and>\n           length CAs = n \\<and>\n           length Cs = n \\<and>\n           length AAs = n \\<and>\n           length As = n \\<and>\n           n \\<noteq> 0 \\<and>\n           (\\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)) \\<and>\n           (\\<forall>i<n. AAs ! i \\<noteq> {#}) \\<and>\n           Some \\<sigma>' =\n           mgu (set_mset ` set (Map2.map2 add_mset As AAs)) \\<and>\n           eligible S \\<sigma>' As (Da + negs (mset As)) \\<and>\n           (\\<forall>i<n.\n               strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>')\n                (Cs ! i \\<cdot> \\<sigma>')) \\<and>\n           (\\<forall>i<n. S (CAs ! i) = {#})\\<rbrakk>\n       \\<Longrightarrow> ord_resolve S [mset C]\n                          (add_mset (Neg x2)\n                            (remove1_mset (Neg x2) (mset D)))\n                          [AA] [x2] \\<sigma> x\n 2. \\<And>x AA A \\<sigma> x2.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       \\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n       Neg A \\<noteq> Neg x2\n 3. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x AA A \\<sigma> x2.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       \\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n       Neg A \\<noteq> Neg x2\n 2. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply (drule ord_resolve.simps[THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x AA A \\<sigma> x2.\n       \\<exists>CAs n Cs AAs As \\<sigma>' Da.\n          [mset C] = CAs \\<and>\n          mset D = Da + negs (mset As) \\<and>\n          [AA] = AAs \\<and>\n          [A] = As \\<and>\n          \\<sigma> = \\<sigma>' \\<and>\n          x = (\\<Sum>\\<^sub># (mset Cs) + Da) \\<cdot> \\<sigma>' \\<and>\n          length CAs = n \\<and>\n          length Cs = n \\<and>\n          length AAs = n \\<and>\n          length As = n \\<and>\n          n \\<noteq> 0 \\<and>\n          (\\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)) \\<and>\n          (\\<forall>i<n. AAs ! i \\<noteq> {#}) \\<and>\n          Some \\<sigma>' =\n          mgu (set_mset ` set (Map2.map2 add_mset As AAs)) \\<and>\n          eligible S \\<sigma>' As (Da + negs (mset As)) \\<and>\n          (\\<forall>i<n.\n              strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>')\n               (Cs ! i \\<cdot> \\<sigma>')) \\<and>\n          (\\<forall>i<n. S (CAs ! i) = {#}) \\<Longrightarrow>\n       \\<not> maximal_wrt x2 (mset D) \\<longrightarrow>\n       Neg A \\<noteq> Neg x2\n 2. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply (clarsimp simp: eligible_iff simp del: subst_cls_add_mset subst_cls_union)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>AA \\<sigma> x2 Cs Da.\n       \\<lbrakk>mset D = add_mset (Neg x2) Da; length Cs = Suc 0;\n        mset C = Cs ! 0 + poss AA; AA \\<noteq> {#};\n        Some \\<sigma> = mgu {insert x2 (set_mset AA)};\n        maximal_wrt (x2 \\<cdot>a \\<sigma>)\n         (add_mset (Neg x2) Da \\<cdot> \\<sigma>);\n        strictly_maximal_wrt (x2 \\<cdot>a \\<sigma>)\n         (Cs ! 0 \\<cdot> \\<sigma>);\n        S (Cs ! 0 + poss AA) = {#};\n        \\<not> maximal_wrt x2 (add_mset (Neg x2) Da)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply (drule maximal_wrt_subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>AA \\<sigma> x2 Cs Da.\n       \\<lbrakk>mset D = add_mset (Neg x2) Da; length Cs = Suc 0;\n        mset C = Cs ! 0 + poss AA; AA \\<noteq> {#};\n        Some \\<sigma> = mgu {insert x2 (set_mset AA)};\n        strictly_maximal_wrt (x2 \\<cdot>a \\<sigma>)\n         (Cs ! 0 \\<cdot> \\<sigma>);\n        S (Cs ! 0 + poss AA) = {#};\n        \\<not> maximal_wrt x2 (add_mset (Neg x2) Da);\n        maximal_wrt x2 (add_mset (Neg x2) Da)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply sat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x AA A \\<sigma>.\n       ord_resolve S [mset C] (mset D) [AA] [A] \\<sigma> x \\<Longrightarrow>\n       Neg A \\<in> set D", "apply (drule ord_resolve.simps[THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x AA A \\<sigma>.\n       \\<exists>CAs n Cs AAs As \\<sigma>' Da.\n          [mset C] = CAs \\<and>\n          mset D = Da + negs (mset As) \\<and>\n          [AA] = AAs \\<and>\n          [A] = As \\<and>\n          \\<sigma> = \\<sigma>' \\<and>\n          x = (\\<Sum>\\<^sub># (mset Cs) + Da) \\<cdot> \\<sigma>' \\<and>\n          length CAs = n \\<and>\n          length Cs = n \\<and>\n          length AAs = n \\<and>\n          length As = n \\<and>\n          n \\<noteq> 0 \\<and>\n          (\\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)) \\<and>\n          (\\<forall>i<n. AAs ! i \\<noteq> {#}) \\<and>\n          Some \\<sigma>' =\n          mgu (set_mset ` set (Map2.map2 add_mset As AAs)) \\<and>\n          eligible S \\<sigma>' As (Da + negs (mset As)) \\<and>\n          (\\<forall>i<n.\n              strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>')\n               (Cs ! i \\<cdot> \\<sigma>')) \\<and>\n          (\\<forall>i<n. S (CAs ! i) = {#}) \\<Longrightarrow>\n       Neg A \\<in> set D", "using set_mset_mset"], ["proof (prove)\nusing this:\n  set_mset (mset ?xs) = set ?xs\n\ngoal (1 subgoal):\n 1. \\<And>x AA A \\<sigma>.\n       \\<exists>CAs n Cs AAs As \\<sigma>' Da.\n          [mset C] = CAs \\<and>\n          mset D = Da + negs (mset As) \\<and>\n          [AA] = AAs \\<and>\n          [A] = As \\<and>\n          \\<sigma> = \\<sigma>' \\<and>\n          x = (\\<Sum>\\<^sub># (mset Cs) + Da) \\<cdot> \\<sigma>' \\<and>\n          length CAs = n \\<and>\n          length Cs = n \\<and>\n          length AAs = n \\<and>\n          length As = n \\<and>\n          n \\<noteq> 0 \\<and>\n          (\\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)) \\<and>\n          (\\<forall>i<n. AAs ! i \\<noteq> {#}) \\<and>\n          Some \\<sigma>' =\n          mgu (set_mset ` set (Map2.map2 add_mset As AAs)) \\<and>\n          eligible S \\<sigma>' As (Da + negs (mset As)) \\<and>\n          (\\<forall>i<n.\n              strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>')\n               (Cs ! i \\<cdot> \\<sigma>')) \\<and>\n          (\\<forall>i<n. S (CAs ! i) = {#}) \\<Longrightarrow>\n       Neg A \\<in> set D", "by fastforce"], ["", "lemma poss_in_map_clauseD:\n  \"poss AA \\<subseteq># map_clause f C \\<Longrightarrow> \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> AA = {#f A. A \\<in># AA0#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poss AA \\<subseteq># map_clause f C \\<Longrightarrow>\n    \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> AA = image_mset f AA0", "proof (induct AA arbitrary: C)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       poss {#} \\<subseteq># map_clause f C \\<Longrightarrow>\n       \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> {#} = image_mset f AA0\n 2. \\<And>x AA C.\n       \\<lbrakk>\\<And>C.\n                   poss AA \\<subseteq># map_clause f C \\<Longrightarrow>\n                   \\<exists>AA0.\n                      poss AA0 \\<subseteq># C \\<and> AA = image_mset f AA0;\n        poss (add_mset x AA) \\<subseteq># map_clause f C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA0.\n                            poss AA0 \\<subseteq># C \\<and>\n                            add_mset x AA = image_mset f AA0", "case (add A AA)"], ["proof (state)\nthis:\n  poss AA \\<subseteq># map_clause f ?C \\<Longrightarrow>\n  \\<exists>AA0. poss AA0 \\<subseteq># ?C \\<and> AA = image_mset f AA0\n  poss (add_mset A AA) \\<subseteq># map_clause f C\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       poss {#} \\<subseteq># map_clause f C \\<Longrightarrow>\n       \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> {#} = image_mset f AA0\n 2. \\<And>x AA C.\n       \\<lbrakk>\\<And>C.\n                   poss AA \\<subseteq># map_clause f C \\<Longrightarrow>\n                   \\<exists>AA0.\n                      poss AA0 \\<subseteq># C \\<and> AA = image_mset f AA0;\n        poss (add_mset x AA) \\<subseteq># map_clause f C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA0.\n                            poss AA0 \\<subseteq># C \\<and>\n                            add_mset x AA = image_mset f AA0", "note ih = this(1) and aaa_sub = this(2)"], ["proof (state)\nthis:\n  poss AA \\<subseteq># map_clause f ?C \\<Longrightarrow>\n  \\<exists>AA0. poss AA0 \\<subseteq># ?C \\<and> AA = image_mset f AA0\n  poss (add_mset A AA) \\<subseteq># map_clause f C\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       poss {#} \\<subseteq># map_clause f C \\<Longrightarrow>\n       \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> {#} = image_mset f AA0\n 2. \\<And>x AA C.\n       \\<lbrakk>\\<And>C.\n                   poss AA \\<subseteq># map_clause f C \\<Longrightarrow>\n                   \\<exists>AA0.\n                      poss AA0 \\<subseteq># C \\<and> AA = image_mset f AA0;\n        poss (add_mset x AA) \\<subseteq># map_clause f C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA0.\n                            poss AA0 \\<subseteq># C \\<and>\n                            add_mset x AA = image_mset f AA0", "have \"Pos A \\<in># map_clause f C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pos A \\<in># map_clause f C", "using aaa_sub"], ["proof (prove)\nusing this:\n  poss (add_mset A AA) \\<subseteq># map_clause f C\n\ngoal (1 subgoal):\n 1. Pos A \\<in># map_clause f C", "by auto"], ["proof (state)\nthis:\n  Pos A \\<in># map_clause f C\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       poss {#} \\<subseteq># map_clause f C \\<Longrightarrow>\n       \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> {#} = image_mset f AA0\n 2. \\<And>x AA C.\n       \\<lbrakk>\\<And>C.\n                   poss AA \\<subseteq># map_clause f C \\<Longrightarrow>\n                   \\<exists>AA0.\n                      poss AA0 \\<subseteq># C \\<and> AA = image_mset f AA0;\n        poss (add_mset x AA) \\<subseteq># map_clause f C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA0.\n                            poss AA0 \\<subseteq># C \\<and>\n                            add_mset x AA = image_mset f AA0", "then"], ["proof (chain)\npicking this:\n  Pos A \\<in># map_clause f C", "obtain A0 where\n    pa0_in: \"Pos A0 \\<in># C\" and\n    a: \"A = f A0\""], ["proof (prove)\nusing this:\n  Pos A \\<in># map_clause f C\n\ngoal (1 subgoal):\n 1. (\\<And>A0.\n        \\<lbrakk>Pos A0 \\<in># C; A = f A0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarify (metis literal.distinct(1) literal.exhaust literal.inject(1) literal.simps(9,10))"], ["proof (state)\nthis:\n  Pos A0 \\<in># C\n  A = f A0\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       poss {#} \\<subseteq># map_clause f C \\<Longrightarrow>\n       \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> {#} = image_mset f AA0\n 2. \\<And>x AA C.\n       \\<lbrakk>\\<And>C.\n                   poss AA \\<subseteq># map_clause f C \\<Longrightarrow>\n                   \\<exists>AA0.\n                      poss AA0 \\<subseteq># C \\<and> AA = image_mset f AA0;\n        poss (add_mset x AA) \\<subseteq># map_clause f C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA0.\n                            poss AA0 \\<subseteq># C \\<and>\n                            add_mset x AA = image_mset f AA0", "have \"poss AA \\<subseteq># map_clause f (C - {#Pos A0#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poss AA \\<subseteq># map_clause f (remove1_mset (Pos A0) C)", "using pa0_in aaa_sub[unfolded a]"], ["proof (prove)\nusing this:\n  Pos A0 \\<in># C\n  poss (add_mset (f A0) AA) \\<subseteq># map_clause f C\n\ngoal (1 subgoal):\n 1. poss AA \\<subseteq># map_clause f (remove1_mset (Pos A0) C)", "by (simp add: image_mset_remove1_mset_if insert_subset_eq_iff)"], ["proof (state)\nthis:\n  poss AA \\<subseteq># map_clause f (remove1_mset (Pos A0) C)\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       poss {#} \\<subseteq># map_clause f C \\<Longrightarrow>\n       \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> {#} = image_mset f AA0\n 2. \\<And>x AA C.\n       \\<lbrakk>\\<And>C.\n                   poss AA \\<subseteq># map_clause f C \\<Longrightarrow>\n                   \\<exists>AA0.\n                      poss AA0 \\<subseteq># C \\<and> AA = image_mset f AA0;\n        poss (add_mset x AA) \\<subseteq># map_clause f C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA0.\n                            poss AA0 \\<subseteq># C \\<and>\n                            add_mset x AA = image_mset f AA0", "then"], ["proof (chain)\npicking this:\n  poss AA \\<subseteq># map_clause f (remove1_mset (Pos A0) C)", "obtain AA0 where\n    paa0_sub: \"poss AA0 \\<subseteq># C - {#Pos A0#}\" and\n    aa: \"AA = image_mset f AA0\""], ["proof (prove)\nusing this:\n  poss AA \\<subseteq># map_clause f (remove1_mset (Pos A0) C)\n\ngoal (1 subgoal):\n 1. (\\<And>AA0.\n        \\<lbrakk>poss AA0 \\<subseteq># remove1_mset (Pos A0) C;\n         AA = image_mset f AA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ih"], ["proof (prove)\nusing this:\n  poss AA \\<subseteq># map_clause f (remove1_mset (Pos A0) C)\n  poss AA \\<subseteq># map_clause f ?C \\<Longrightarrow>\n  \\<exists>AA0. poss AA0 \\<subseteq># ?C \\<and> AA = image_mset f AA0\n\ngoal (1 subgoal):\n 1. (\\<And>AA0.\n        \\<lbrakk>poss AA0 \\<subseteq># remove1_mset (Pos A0) C;\n         AA = image_mset f AA0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  poss AA0 \\<subseteq># remove1_mset (Pos A0) C\n  AA = image_mset f AA0\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       poss {#} \\<subseteq># map_clause f C \\<Longrightarrow>\n       \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> {#} = image_mset f AA0\n 2. \\<And>x AA C.\n       \\<lbrakk>\\<And>C.\n                   poss AA \\<subseteq># map_clause f C \\<Longrightarrow>\n                   \\<exists>AA0.\n                      poss AA0 \\<subseteq># C \\<and> AA = image_mset f AA0;\n        poss (add_mset x AA) \\<subseteq># map_clause f C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA0.\n                            poss AA0 \\<subseteq># C \\<and>\n                            add_mset x AA = image_mset f AA0", "have \"poss (add_mset A0 AA0) \\<subseteq># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poss (add_mset A0 AA0) \\<subseteq># C", "using pa0_in paa0_sub"], ["proof (prove)\nusing this:\n  Pos A0 \\<in># C\n  poss AA0 \\<subseteq># remove1_mset (Pos A0) C\n\ngoal (1 subgoal):\n 1. poss (add_mset A0 AA0) \\<subseteq># C", "by (simp add: insert_subset_eq_iff)"], ["proof (state)\nthis:\n  poss (add_mset A0 AA0) \\<subseteq># C\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       poss {#} \\<subseteq># map_clause f C \\<Longrightarrow>\n       \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> {#} = image_mset f AA0\n 2. \\<And>x AA C.\n       \\<lbrakk>\\<And>C.\n                   poss AA \\<subseteq># map_clause f C \\<Longrightarrow>\n                   \\<exists>AA0.\n                      poss AA0 \\<subseteq># C \\<and> AA = image_mset f AA0;\n        poss (add_mset x AA) \\<subseteq># map_clause f C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA0.\n                            poss AA0 \\<subseteq># C \\<and>\n                            add_mset x AA = image_mset f AA0", "moreover"], ["proof (state)\nthis:\n  poss (add_mset A0 AA0) \\<subseteq># C\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       poss {#} \\<subseteq># map_clause f C \\<Longrightarrow>\n       \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> {#} = image_mset f AA0\n 2. \\<And>x AA C.\n       \\<lbrakk>\\<And>C.\n                   poss AA \\<subseteq># map_clause f C \\<Longrightarrow>\n                   \\<exists>AA0.\n                      poss AA0 \\<subseteq># C \\<and> AA = image_mset f AA0;\n        poss (add_mset x AA) \\<subseteq># map_clause f C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA0.\n                            poss AA0 \\<subseteq># C \\<and>\n                            add_mset x AA = image_mset f AA0", "have \"add_mset A AA = image_mset f (add_mset A0 AA0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset A AA = image_mset f (add_mset A0 AA0)", "unfolding a aa"], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset (f A0) (image_mset f AA0) = image_mset f (add_mset A0 AA0)", "by simp"], ["proof (state)\nthis:\n  add_mset A AA = image_mset f (add_mset A0 AA0)\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       poss {#} \\<subseteq># map_clause f C \\<Longrightarrow>\n       \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> {#} = image_mset f AA0\n 2. \\<And>x AA C.\n       \\<lbrakk>\\<And>C.\n                   poss AA \\<subseteq># map_clause f C \\<Longrightarrow>\n                   \\<exists>AA0.\n                      poss AA0 \\<subseteq># C \\<and> AA = image_mset f AA0;\n        poss (add_mset x AA) \\<subseteq># map_clause f C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA0.\n                            poss AA0 \\<subseteq># C \\<and>\n                            add_mset x AA = image_mset f AA0", "ultimately"], ["proof (chain)\npicking this:\n  poss (add_mset A0 AA0) \\<subseteq># C\n  add_mset A AA = image_mset f (add_mset A0 AA0)", "show ?case"], ["proof (prove)\nusing this:\n  poss (add_mset A0 AA0) \\<subseteq># C\n  add_mset A AA = image_mset f (add_mset A0 AA0)\n\ngoal (1 subgoal):\n 1. \\<exists>AA0.\n       poss AA0 \\<subseteq># C \\<and> add_mset A AA = image_mset f AA0", "by blast"], ["proof (state)\nthis:\n  \\<exists>AA0.\n     poss AA0 \\<subseteq># C \\<and> add_mset A AA = image_mset f AA0\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       poss {#} \\<subseteq># map_clause f C \\<Longrightarrow>\n       \\<exists>AA0. poss AA0 \\<subseteq># C \\<and> {#} = image_mset f AA0", "qed simp"], ["", "lemma poss_subset_filterD:\n  \"poss AA \\<subseteq># {#L \\<cdot>l \\<rho>. L \\<in># mset C#} \\<Longrightarrow> \\<exists>AA0. poss AA0 \\<subseteq># mset C \\<and> AA = AA0 \\<cdot>am \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poss AA \\<subseteq>#\n    {#L \\<cdot>l \\<rho>. L \\<in># mset C#} \\<Longrightarrow>\n    \\<exists>AA0.\n       poss AA0 \\<subseteq># mset C \\<and> AA = AA0 \\<cdot>am \\<rho>", "unfolding subst_atm_mset_def subst_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poss AA \\<subseteq>#\n    map_clause (\\<lambda>A. A \\<cdot>a \\<rho>) (mset C) \\<Longrightarrow>\n    \\<exists>AA0.\n       poss AA0 \\<subseteq># mset C \\<and>\n       AA = {#A \\<cdot>a \\<rho>. A \\<in># AA0#}", "by (rule poss_in_map_clauseD)"], ["", "lemma neg_in_map_literalD: \"Neg A \\<in> map_literal f ` D \\<Longrightarrow> \\<exists>A0. Neg A0 \\<in> D \\<and> A = f A0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg A \\<in> map_literal f ` D \\<Longrightarrow>\n    \\<exists>A0. Neg A0 \\<in> D \\<and> A = f A0", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg A \\<in> {y. \\<exists>x\\<in>D. y = map_literal f x} \\<Longrightarrow>\n    \\<exists>A0. Neg A0 \\<in> D \\<and> A = f A0", "by (clarify, case_tac x, auto)"], ["", "lemma neg_in_filterD: \"Neg A \\<in># {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} \\<Longrightarrow> \\<exists>A0. Neg A0 \\<in># mset D \\<and> A = A0 \\<cdot>a \\<rho>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg A \\<in># {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} \\<Longrightarrow>\n    \\<exists>A0. Neg A0 \\<in># mset D \\<and> A = A0 \\<cdot>a \\<rho>'", "unfolding subst_lit_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg A\n    \\<in># map_clause (\\<lambda>A. A \\<cdot>a \\<rho>')\n            (mset D) \\<Longrightarrow>\n    \\<exists>A0. Neg A0 \\<in># mset D \\<and> A = A0 \\<cdot>a \\<rho>'", "by (rule neg_in_map_literalD) simp"], ["", "lemma resolve_rename_eq_Bin_ord_resolve_rename:\n  \"mset ` set (resolve_rename C D) = Bin_ord_resolve_rename (mset C) (mset D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` set (resolve_rename C D) =\n    Bin_ord_resolve_rename (mset C) (mset D)", "proof (intro order_antisym subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "let ?\\<rho>s = \"renamings_apart [mset D, mset C]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "define \\<rho>' :: 's where\n    \"\\<rho>' = hd ?\\<rho>s\""], ["proof (state)\nthis:\n  \\<rho>' = hd (renamings_apart [mset D, mset C])\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "define \\<rho> :: 's where\n    \"\\<rho> = last ?\\<rho>s\""], ["proof (state)\nthis:\n  \\<rho> = last (renamings_apart [mset D, mset C])\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "have tl_\\<rho>s: \"tl ?\\<rho>s = [\\<rho>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (renamings_apart [mset D, mset C]) = [\\<rho>]", "unfolding \\<rho>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (renamings_apart [mset D, mset C]) =\n    [last (renamings_apart [mset D, mset C])]", "using renamings_apart_length Nitpick.size_list_simp(2) Suc_length_conv last.simps"], ["proof (prove)\nusing this:\n  length (renamings_apart ?Cs) = length ?Cs\n  length ?xs = (if ?xs = [] then 0 else Suc (length (tl ?xs)))\n  (Suc ?n = length ?xs) =\n  (\\<exists>y ys. ?xs = y # ys \\<and> length ys = ?n)\n  last (?x # ?xs) = (if ?xs = [] then ?x else last ?xs)\n\ngoal (1 subgoal):\n 1. tl (renamings_apart [mset D, mset C]) =\n    [last (renamings_apart [mset D, mset C])]", "by (smt length_greater_0_conv list.sel(3))"], ["proof (state)\nthis:\n  tl (renamings_apart [mset D, mset C]) = [\\<rho>]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "{"], ["proof (state)\nthis:\n  tl (renamings_apart [mset D, mset C]) = [\\<rho>]\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "fix E"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "assume e_in: \"E \\<in> mset ` set (resolve_rename C D)\""], ["proof (state)\nthis:\n  E \\<in> mset ` set (resolve_rename C D)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "from e_in"], ["proof (chain)\npicking this:\n  E \\<in> mset ` set (resolve_rename C D)", "obtain AA :: \"'a multiset\" and A :: 'a and \\<sigma> :: 's where\n      aa_sub: \"poss AA \\<subseteq># mset C \\<cdot> \\<rho>\" and\n      a_in: \"Neg A \\<in># mset D \\<cdot> \\<rho>'\" and\n      res_e: \"ord_resolve S [mset C \\<cdot> \\<rho>] {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma> E\""], ["proof (prove)\nusing this:\n  E \\<in> mset ` set (resolve_rename C D)\n\ngoal (1 subgoal):\n 1. (\\<And>AA A \\<sigma>.\n        \\<lbrakk>poss AA \\<subseteq># mset C \\<cdot> \\<rho>;\n         Neg A \\<in># mset D \\<cdot> \\<rho>';\n         ord_resolve S [mset C \\<cdot> \\<rho>]\n          {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma>\n          E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<rho>'_def \\<rho>_def"], ["proof (prove)\nusing this:\n  E \\<in> mset ` set (resolve_rename C D)\n\ngoal (1 subgoal):\n 1. (\\<And>AA A \\<sigma>.\n        \\<lbrakk>poss AA \\<subseteq>#\n                 mset C \\<cdot> last (renamings_apart [mset D, mset C]);\n         Neg A \\<in># mset D \\<cdot> hd (renamings_apart [mset D, mset C]);\n         ord_resolve S\n          [mset C \\<cdot> last (renamings_apart [mset D, mset C])]\n          {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n          . L \\<in># mset D#}\n          [AA] [A] \\<sigma> E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n    \\<exists>AA A \\<sigma>.\n       poss AA \\<subseteq>#\n       mset C \\<cdot> last (renamings_apart [mset D, mset C]) \\<and>\n       Neg A\n       \\<in># mset D \\<cdot> hd (renamings_apart [mset D, mset C]) \\<and>\n       ord_resolve S\n        [mset C \\<cdot> last (renamings_apart [mset D, mset C])]\n        {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n        . L \\<in># mset D#}\n        [AA] [A] \\<sigma> E", "using e_in"], ["proof (prove)\nusing this:\n  E \\<in> mset ` set (resolve_rename C D)\n\ngoal (1 subgoal):\n 1. E \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n    \\<exists>AA A \\<sigma>.\n       poss AA \\<subseteq>#\n       mset C \\<cdot> last (renamings_apart [mset D, mset C]) \\<and>\n       Neg A\n       \\<in># mset D \\<cdot> hd (renamings_apart [mset D, mset C]) \\<and>\n       ord_resolve S\n        [mset C \\<cdot> last (renamings_apart [mset D, mset C])]\n        {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n        . L \\<in># mset D#}\n        [AA] [A] \\<sigma> E", "unfolding resolve_rename_def Let_def resolve_eq_Bin_ord_resolve"], ["proof (prove)\nusing this:\n  E \\<in> Bin_ord_resolve\n           (mset\n             (map (\\<lambda>L.\n                      L \\<cdot>l last (renamings_apart [mset D, mset C]))\n               C))\n           (mset\n             (map (\\<lambda>L.\n                      L \\<cdot>l hd (renamings_apart [mset D, mset C]))\n               D))\n\ngoal (1 subgoal):\n 1. E \\<in> Bin_ord_resolve\n             (mset\n               (map (\\<lambda>L.\n                        L \\<cdot>l last (renamings_apart [mset D, mset C]))\n                 C))\n             (mset\n               (map (\\<lambda>L.\n                        L \\<cdot>l hd (renamings_apart [mset D, mset C]))\n                 D)) \\<Longrightarrow>\n    \\<exists>AA A \\<sigma>.\n       poss AA \\<subseteq>#\n       mset C \\<cdot> last (renamings_apart [mset D, mset C]) \\<and>\n       Neg A\n       \\<in># mset D \\<cdot> hd (renamings_apart [mset D, mset C]) \\<and>\n       ord_resolve S\n        [mset C \\<cdot> last (renamings_apart [mset D, mset C])]\n        {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n        . L \\<in># mset D#}\n        [AA] [A] \\<sigma> E", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA A \\<sigma>.\n       ord_resolve S\n        [{#L \\<cdot>l last (renamings_apart [mset D, mset C])\n         . L \\<in># mset C#}]\n        {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n        . L \\<in># mset D#}\n        [AA] [A] \\<sigma> E \\<Longrightarrow>\n       \\<exists>AA.\n          poss AA \\<subseteq>#\n          mset C \\<cdot> last (renamings_apart [mset D, mset C]) \\<and>\n          (\\<exists>A.\n              (\\<exists>M.\n                  M \\<in> set D \\<and>\n                  Neg A =\n                  M \\<cdot>l hd (renamings_apart [mset D, mset C])) \\<and>\n              (\\<exists>\\<sigma>.\n                  ord_resolve S\n                   [mset C \\<cdot> last (renamings_apart [mset D, mset C])]\n                   {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n                   . L \\<in># mset D#}\n                   [AA] [A] \\<sigma> E))", "apply (frule ord_resolve_one_side_prem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA A \\<sigma>.\n       \\<lbrakk>ord_resolve S\n                 [{#L \\<cdot>l last (renamings_apart [mset D, mset C])\n                  . L \\<in># mset C#}]\n                 {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n                 . L \\<in># mset D#}\n                 [AA] [A] \\<sigma> E;\n        length\n         [{#L \\<cdot>l last (renamings_apart [mset D, mset C])\n          . L \\<in># mset C#}] =\n        1 \\<and>\n        length [AA] = 1 \\<and> length [A] = 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA.\n                            poss AA \\<subseteq>#\n                            mset C \\<cdot>\n                            last (renamings_apart [mset D, mset C]) \\<and>\n                            (\\<exists>A.\n                                (\\<exists>M.\n                                    M \\<in> set D \\<and>\n                                    Neg A =\n                                    M \\<cdot>l\n                                    hd (renamings_apart\n   [mset D, mset C])) \\<and>\n                                (\\<exists>\\<sigma>.\n                                    ord_resolve S\n                                     [mset C \\<cdot>\nlast (renamings_apart [mset D, mset C])]\n                                     {#L \\<cdot>l\n hd (renamings_apart [mset D, mset C])\n                                     . L \\<in># mset D#}\n                                     [AA] [A] \\<sigma> E))", "apply (frule ord_resolve.simps[THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA A \\<sigma>.\n       \\<lbrakk>ord_resolve S\n                 [{#L \\<cdot>l last (renamings_apart [mset D, mset C])\n                  . L \\<in># mset C#}]\n                 {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n                 . L \\<in># mset D#}\n                 [AA] [A] \\<sigma> E;\n        length\n         [{#L \\<cdot>l last (renamings_apart [mset D, mset C])\n          . L \\<in># mset C#}] =\n        1 \\<and>\n        length [AA] = 1 \\<and> length [A] = 1;\n        \\<exists>CAs n Cs AAs As \\<sigma>' Da.\n           [{#L \\<cdot>l last (renamings_apart [mset D, mset C])\n            . L \\<in># mset C#}] =\n           CAs \\<and>\n           {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n           . L \\<in># mset D#} =\n           Da + negs (mset As) \\<and>\n           [AA] = AAs \\<and>\n           [A] = As \\<and>\n           \\<sigma> = \\<sigma>' \\<and>\n           E = (\\<Sum>\\<^sub># (mset Cs) + Da) \\<cdot> \\<sigma>' \\<and>\n           length CAs = n \\<and>\n           length Cs = n \\<and>\n           length AAs = n \\<and>\n           length As = n \\<and>\n           n \\<noteq> 0 \\<and>\n           (\\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)) \\<and>\n           (\\<forall>i<n. AAs ! i \\<noteq> {#}) \\<and>\n           Some \\<sigma>' =\n           mgu (set_mset ` set (Map2.map2 add_mset As AAs)) \\<and>\n           eligible S \\<sigma>' As (Da + negs (mset As)) \\<and>\n           (\\<forall>i<n.\n               strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>')\n                (Cs ! i \\<cdot> \\<sigma>')) \\<and>\n           (\\<forall>i<n. S (CAs ! i) = {#})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA.\n                            poss AA \\<subseteq>#\n                            mset C \\<cdot>\n                            last (renamings_apart [mset D, mset C]) \\<and>\n                            (\\<exists>A.\n                                (\\<exists>M.\n                                    M \\<in> set D \\<and>\n                                    Neg A =\n                                    M \\<cdot>l\n                                    hd (renamings_apart\n   [mset D, mset C])) \\<and>\n                                (\\<exists>\\<sigma>.\n                                    ord_resolve S\n                                     [mset C \\<cdot>\nlast (renamings_apart [mset D, mset C])]\n                                     {#L \\<cdot>l\n hd (renamings_apart [mset D, mset C])\n                                     . L \\<in># mset D#}\n                                     [AA] [A] \\<sigma> E))", "apply (rule_tac x = AA in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA A \\<sigma>.\n       \\<lbrakk>ord_resolve S\n                 [{#L \\<cdot>l last (renamings_apart [mset D, mset C])\n                  . L \\<in># mset C#}]\n                 {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n                 . L \\<in># mset D#}\n                 [AA] [A] \\<sigma> E;\n        length\n         [{#L \\<cdot>l last (renamings_apart [mset D, mset C])\n          . L \\<in># mset C#}] =\n        1 \\<and>\n        length [AA] = 1 \\<and> length [A] = 1;\n        \\<exists>CAs n Cs AAs As \\<sigma>' Da.\n           [{#L \\<cdot>l last (renamings_apart [mset D, mset C])\n            . L \\<in># mset C#}] =\n           CAs \\<and>\n           {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n           . L \\<in># mset D#} =\n           Da + negs (mset As) \\<and>\n           [AA] = AAs \\<and>\n           [A] = As \\<and>\n           \\<sigma> = \\<sigma>' \\<and>\n           E = (\\<Sum>\\<^sub># (mset Cs) + Da) \\<cdot> \\<sigma>' \\<and>\n           length CAs = n \\<and>\n           length Cs = n \\<and>\n           length AAs = n \\<and>\n           length As = n \\<and>\n           n \\<noteq> 0 \\<and>\n           (\\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i)) \\<and>\n           (\\<forall>i<n. AAs ! i \\<noteq> {#}) \\<and>\n           Some \\<sigma>' =\n           mgu (set_mset ` set (Map2.map2 add_mset As AAs)) \\<and>\n           eligible S \\<sigma>' As (Da + negs (mset As)) \\<and>\n           (\\<forall>i<n.\n               strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>')\n                (Cs ! i \\<cdot> \\<sigma>')) \\<and>\n           (\\<forall>i<n. S (CAs ! i) = {#})\\<rbrakk>\n       \\<Longrightarrow> poss AA \\<subseteq>#\n                         mset C \\<cdot>\n                         last (renamings_apart [mset D, mset C]) \\<and>\n                         (\\<exists>A.\n                             (\\<exists>M.\n                                 M \\<in> set D \\<and>\n                                 Neg A =\n                                 M \\<cdot>l\n                                 hd (renamings_apart\n[mset D, mset C])) \\<and>\n                             (\\<exists>\\<sigma>.\n                                 ord_resolve S\n                                  [mset C \\<cdot>\n                                   last (renamings_apart [mset D, mset C])]\n                                  {#L \\<cdot>l\n                                    hd (renamings_apart [mset D, mset C])\n                                  . L \\<in># mset D#}\n                                  [AA] [A] \\<sigma> E))", "apply (clarsimp simp: subst_cls_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA A \\<sigma> Cs Da.\n       \\<lbrakk>ord_resolve S [Cs ! 0 + poss AA] (add_mset (Neg A) Da) [AA]\n                 [A] \\<sigma>\n                 ({#A \\<cdot>l \\<sigma>. A \\<in># sum_list Cs#} +\n                  {#A \\<cdot>l \\<sigma>. A \\<in># Da#});\n        {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n        . L \\<in># mset D#} =\n        add_mset (Neg A) Da;\n        E =\n        {#A \\<cdot>l \\<sigma>. A \\<in># sum_list Cs#} +\n        {#A \\<cdot>l \\<sigma>. A \\<in># Da#};\n        length Cs = Suc 0;\n        {#L \\<cdot>l last (renamings_apart [mset D, mset C])\n        . L \\<in># mset C#} =\n        Cs ! 0 + poss AA;\n        AA \\<noteq> {#}; Some \\<sigma> = mgu {insert A (set_mset AA)};\n        eligible S \\<sigma> [A] (add_mset (Neg A) Da);\n        strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n         {#x \\<cdot>l \\<sigma>. x \\<in># Cs ! 0#};\n        S (Cs ! 0 + poss AA) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            (\\<exists>M.\n                                M \\<in> set D \\<and>\n                                Neg Aa =\n                                M \\<cdot>l\n                                hd (renamings_apart\n                                     [mset D, mset C])) \\<and>\n                            (\\<exists>\\<sigma>'.\n                                ord_resolve S [Cs ! 0 + poss AA]\n                                 (add_mset (Neg A) Da) [AA] [Aa] \\<sigma>'\n                                 ({#A \\<cdot>l \\<sigma>\n                                  . A \\<in># sum_list Cs#} +\n                                  {#A \\<cdot>l \\<sigma>. A \\<in># Da#}))", "apply (rule_tac x = A in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA A \\<sigma> Cs Da.\n       \\<lbrakk>ord_resolve S [Cs ! 0 + poss AA] (add_mset (Neg A) Da) [AA]\n                 [A] \\<sigma>\n                 ({#A \\<cdot>l \\<sigma>. A \\<in># sum_list Cs#} +\n                  {#A \\<cdot>l \\<sigma>. A \\<in># Da#});\n        {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n        . L \\<in># mset D#} =\n        add_mset (Neg A) Da;\n        E =\n        {#A \\<cdot>l \\<sigma>. A \\<in># sum_list Cs#} +\n        {#A \\<cdot>l \\<sigma>. A \\<in># Da#};\n        length Cs = Suc 0;\n        {#L \\<cdot>l last (renamings_apart [mset D, mset C])\n        . L \\<in># mset C#} =\n        Cs ! 0 + poss AA;\n        AA \\<noteq> {#}; Some \\<sigma> = mgu {insert A (set_mset AA)};\n        eligible S \\<sigma> [A] (add_mset (Neg A) Da);\n        strictly_maximal_wrt (A \\<cdot>a \\<sigma>)\n         {#x \\<cdot>l \\<sigma>. x \\<in># Cs ! 0#};\n        S (Cs ! 0 + poss AA) = {#}\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>M.\n                             M \\<in> set D \\<and>\n                             Neg A =\n                             M \\<cdot>l\n                             hd (renamings_apart [mset D, mset C])) \\<and>\n                         (\\<exists>\\<sigma>'.\n                             ord_resolve S [Cs ! 0 + poss AA]\n                              (add_mset (Neg A) Da) [AA] [A] \\<sigma>'\n                              ({#A \\<cdot>l \\<sigma>\n                               . A \\<in># sum_list Cs#} +\n                               {#A \\<cdot>l \\<sigma>. A \\<in># Da#}))", "by (metis (full_types) Melem_subst_cls set_mset_mset subst_cls_def union_single_eq_member)"], ["proof (state)\nthis:\n  poss AA \\<subseteq># mset C \\<cdot> \\<rho>\n  Neg A \\<in># mset D \\<cdot> \\<rho>'\n  ord_resolve S [mset C \\<cdot> \\<rho>]\n   {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma> E\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "obtain AA0 :: \"'a multiset\" where\n      aa0_sub: \"poss AA0 \\<subseteq># mset C\" and\n      aa: \"AA = AA0 \\<cdot>am \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>AA0.\n        \\<lbrakk>poss AA0 \\<subseteq># mset C;\n         AA = AA0 \\<cdot>am \\<rho>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using aa_sub"], ["proof (prove)\nusing this:\n  poss AA \\<subseteq># mset C \\<cdot> \\<rho>\n\ngoal (1 subgoal):\n 1. (\\<And>AA0.\n        \\<lbrakk>poss AA0 \\<subseteq># mset C;\n         AA = AA0 \\<cdot>am \\<rho>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. poss AA \\<subseteq># mset C \\<cdot> \\<rho> \\<Longrightarrow>\n    \\<exists>AA0.\n       poss AA0 \\<subseteq># mset C \\<and> AA = AA0 \\<cdot>am \\<rho>", "apply (rule ord_resolve.cases[OF res_e])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>CAs n Cs AAs As \\<sigma>' Da.\n       \\<lbrakk>poss AA \\<subseteq># mset C \\<cdot> \\<rho>;\n        [mset C \\<cdot> \\<rho>] = CAs;\n        {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} = Da + negs (mset As);\n        [AA] = AAs; [A] = As; \\<sigma> = \\<sigma>';\n        E = (\\<Sum>\\<^sub># (mset Cs) + Da) \\<cdot> \\<sigma>';\n        length CAs = n; length Cs = n; length AAs = n; length As = n;\n        n \\<noteq> 0; \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma>' = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma>' As (Da + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>')\n            (Cs ! i \\<cdot> \\<sigma>');\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA0.\n                            poss AA0 \\<subseteq># mset C \\<and>\n                            AA = AA0 \\<cdot>am \\<rho>", "by (rule poss_subset_filterD[OF aa_sub[unfolded subst_cls_def]])"], ["proof (state)\nthis:\n  poss AA0 \\<subseteq># mset C\n  AA = AA0 \\<cdot>am \\<rho>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "obtain A0 :: 'a where\n      a0_in: \"Neg A0 \\<in> set D\" and\n      a: \"A = A0 \\<cdot>a \\<rho>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A0.\n        \\<lbrakk>Neg A0 \\<in> set D; A = A0 \\<cdot>a \\<rho>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A0. Neg A0 \\<in> set D \\<and> A = A0 \\<cdot>a \\<rho>'", "apply (rule ord_resolve.cases[OF res_e])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>CAs n Cs AAs As \\<sigma>' Da.\n       \\<lbrakk>[mset C \\<cdot> \\<rho>] = CAs;\n        {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} = Da + negs (mset As);\n        [AA] = AAs; [A] = As; \\<sigma> = \\<sigma>';\n        E = (\\<Sum>\\<^sub># (mset Cs) + Da) \\<cdot> \\<sigma>';\n        length CAs = n; length Cs = n; length AAs = n; length As = n;\n        n \\<noteq> 0; \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma>' = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma>' As (Da + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>')\n            (Cs ! i \\<cdot> \\<sigma>');\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A0.\n                            Neg A0 \\<in> set D \\<and>\n                            A = A0 \\<cdot>a \\<rho>'", "using neg_in_filterD[OF a_in[unfolded subst_cls_def]]"], ["proof (prove)\nusing this:\n  \\<exists>A0. Neg A0 \\<in># mset D \\<and> A = A0 \\<cdot>a \\<rho>'\n\ngoal (1 subgoal):\n 1. \\<And>CAs n Cs AAs As \\<sigma>' Da.\n       \\<lbrakk>[mset C \\<cdot> \\<rho>] = CAs;\n        {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} = Da + negs (mset As);\n        [AA] = AAs; [A] = As; \\<sigma> = \\<sigma>';\n        E = (\\<Sum>\\<^sub># (mset Cs) + Da) \\<cdot> \\<sigma>';\n        length CAs = n; length Cs = n; length AAs = n; length As = n;\n        n \\<noteq> 0; \\<forall>i<n. CAs ! i = Cs ! i + poss (AAs ! i);\n        \\<forall>i<n. AAs ! i \\<noteq> {#};\n        Some \\<sigma>' = mgu (set_mset ` set (Map2.map2 add_mset As AAs));\n        eligible S \\<sigma>' As (Da + negs (mset As));\n        \\<forall>i<n.\n           strictly_maximal_wrt (As ! i \\<cdot>a \\<sigma>')\n            (Cs ! i \\<cdot> \\<sigma>');\n        \\<forall>i<n. S (CAs ! i) = {#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A0.\n                            Neg A0 \\<in> set D \\<and>\n                            A = A0 \\<cdot>a \\<rho>'", "by simp"], ["proof (state)\nthis:\n  Neg A0 \\<in> set D\n  A = A0 \\<cdot>a \\<rho>'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "show \"E \\<in> Bin_ord_resolve_rename (mset C) (mset D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<in> Bin_ord_resolve_rename (mset C) (mset D)", "unfolding ord_resolve_rename.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<in> {E. \\<exists>AA A \\<sigma> CAs n AAs As DA \\<rho> \\<rho>s\n                   \\<sigma>' Ea.\n                   [mset C] = CAs \\<and>\n                   mset D = DA \\<and>\n                   [AA] = AAs \\<and>\n                   [A] = As \\<and>\n                   \\<sigma> = \\<sigma>' \\<and>\n                   E = Ea \\<and>\n                   length CAs = n \\<and>\n                   length AAs = n \\<and>\n                   length As = n \\<and>\n                   (\\<forall>i<n.\n                       poss (AAs ! i) \\<subseteq># CAs ! i) \\<and>\n                   negs (mset As) \\<subseteq># DA \\<and>\n                   \\<rho> = hd (renamings_apart (DA # CAs)) \\<and>\n                   \\<rho>s = tl (renamings_apart (DA # CAs)) \\<and>\n                   ord_resolve S (CAs \\<cdot>\\<cdot>cl \\<rho>s)\n                    (DA \\<cdot> \\<rho>) (AAs \\<cdot>\\<cdot>aml \\<rho>s)\n                    (As \\<cdot>al \\<rho>) \\<sigma>' Ea}", "using res_e"], ["proof (prove)\nusing this:\n  ord_resolve S [mset C \\<cdot> \\<rho>]\n   {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma> E\n\ngoal (1 subgoal):\n 1. E \\<in> {E. \\<exists>AA A \\<sigma> CAs n AAs As DA \\<rho> \\<rho>s\n                   \\<sigma>' Ea.\n                   [mset C] = CAs \\<and>\n                   mset D = DA \\<and>\n                   [AA] = AAs \\<and>\n                   [A] = As \\<and>\n                   \\<sigma> = \\<sigma>' \\<and>\n                   E = Ea \\<and>\n                   length CAs = n \\<and>\n                   length AAs = n \\<and>\n                   length As = n \\<and>\n                   (\\<forall>i<n.\n                       poss (AAs ! i) \\<subseteq># CAs ! i) \\<and>\n                   negs (mset As) \\<subseteq># DA \\<and>\n                   \\<rho> = hd (renamings_apart (DA # CAs)) \\<and>\n                   \\<rho>s = tl (renamings_apart (DA # CAs)) \\<and>\n                   ord_resolve S (CAs \\<cdot>\\<cdot>cl \\<rho>s)\n                    (DA \\<cdot> \\<rho>) (AAs \\<cdot>\\<cdot>aml \\<rho>s)\n                    (As \\<cdot>al \\<rho>) \\<sigma>' Ea}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve S [mset C \\<cdot> \\<rho>]\n     {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma>\n     E \\<Longrightarrow>\n    \\<exists>AA.\n       poss AA \\<subseteq># mset C \\<and>\n       (\\<exists>A.\n           Neg A \\<in> set D \\<and>\n           (\\<exists>\\<sigma>.\n               ord_resolve S\n                ([mset C] \\<cdot>\\<cdot>cl\n                 tl (renamings_apart [mset D, mset C]))\n                (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n                ([AA] \\<cdot>\\<cdot>aml\n                 tl (renamings_apart [mset D, mset C]))\n                [A \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma>\n                E))", "apply (rule_tac x = AA0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve S [mset C \\<cdot> \\<rho>]\n     {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma>\n     E \\<Longrightarrow>\n    poss AA0 \\<subseteq># mset C \\<and>\n    (\\<exists>A.\n        Neg A \\<in> set D \\<and>\n        (\\<exists>\\<sigma>.\n            ord_resolve S\n             ([mset C] \\<cdot>\\<cdot>cl\n              tl (renamings_apart [mset D, mset C]))\n             (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n             ([AA0] \\<cdot>\\<cdot>aml tl (renamings_apart [mset D, mset C]))\n             [A \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma> E))", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ord_resolve S [mset C \\<cdot> \\<rho>]\n     {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma>\n     E \\<Longrightarrow>\n    poss AA0 \\<subseteq># mset C\n 2. ord_resolve S [mset C \\<cdot> \\<rho>]\n     {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma>\n     E \\<Longrightarrow>\n    \\<exists>A.\n       Neg A \\<in> set D \\<and>\n       (\\<exists>\\<sigma>.\n           ord_resolve S\n            ([mset C] \\<cdot>\\<cdot>cl\n             tl (renamings_apart [mset D, mset C]))\n            (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n            ([AA0] \\<cdot>\\<cdot>aml tl (renamings_apart [mset D, mset C]))\n            [A \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma> E)", "apply (rule aa0_sub)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve S [mset C \\<cdot> \\<rho>]\n     {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma>\n     E \\<Longrightarrow>\n    \\<exists>A.\n       Neg A \\<in> set D \\<and>\n       (\\<exists>\\<sigma>.\n           ord_resolve S\n            ([mset C] \\<cdot>\\<cdot>cl\n             tl (renamings_apart [mset D, mset C]))\n            (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n            ([AA0] \\<cdot>\\<cdot>aml tl (renamings_apart [mset D, mset C]))\n            [A \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma> E)", "apply (rule_tac x = A0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve S [mset C \\<cdot> \\<rho>]\n     {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma>\n     E \\<Longrightarrow>\n    Neg A0 \\<in> set D \\<and>\n    (\\<exists>\\<sigma>.\n        ord_resolve S\n         ([mset C] \\<cdot>\\<cdot>cl tl (renamings_apart [mset D, mset C]))\n         (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n         ([AA0] \\<cdot>\\<cdot>aml tl (renamings_apart [mset D, mset C]))\n         [A0 \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma> E)", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ord_resolve S [mset C \\<cdot> \\<rho>]\n     {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma>\n     E \\<Longrightarrow>\n    Neg A0 \\<in> set D\n 2. ord_resolve S [mset C \\<cdot> \\<rho>]\n     {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma>\n     E \\<Longrightarrow>\n    \\<exists>\\<sigma>.\n       ord_resolve S\n        ([mset C] \\<cdot>\\<cdot>cl tl (renamings_apart [mset D, mset C]))\n        (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n        ([AA0] \\<cdot>\\<cdot>aml tl (renamings_apart [mset D, mset C]))\n        [A0 \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma> E", "apply (rule a0_in)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve S [mset C \\<cdot> \\<rho>]\n     {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma>\n     E \\<Longrightarrow>\n    \\<exists>\\<sigma>.\n       ord_resolve S\n        ([mset C] \\<cdot>\\<cdot>cl tl (renamings_apart [mset D, mset C]))\n        (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n        ([AA0] \\<cdot>\\<cdot>aml tl (renamings_apart [mset D, mset C]))\n        [A0 \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma> E", "apply (rule_tac x = \\<sigma> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve S [mset C \\<cdot> \\<rho>]\n     {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA] [A] \\<sigma>\n     E \\<Longrightarrow>\n    ord_resolve S\n     ([mset C] \\<cdot>\\<cdot>cl tl (renamings_apart [mset D, mset C]))\n     (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n     ([AA0] \\<cdot>\\<cdot>aml tl (renamings_apart [mset D, mset C]))\n     [A0 \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma> E", "unfolding aa a \\<rho>'_def[symmetric] \\<rho>_def[symmetric] tl_\\<rho>s"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_resolve S [mset C \\<cdot> \\<rho>]\n     {#L \\<cdot>l \\<rho>'. L \\<in># mset D#} [AA0 \\<cdot>am \\<rho>]\n     [A0 \\<cdot>a \\<rho>'] \\<sigma> E \\<Longrightarrow>\n    ord_resolve S ([mset C] \\<cdot>\\<cdot>cl [\\<rho>])\n     (mset D \\<cdot> \\<rho>') ([AA0] \\<cdot>\\<cdot>aml [\\<rho>])\n     [A0 \\<cdot>a \\<rho>'] \\<sigma> E", "by (simp add: subst_cls_def)"], ["proof (state)\nthis:\n  E \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "}"], ["proof (state)\nthis:\n  ?E2 \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n  ?E2 \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "{"], ["proof (state)\nthis:\n  ?E2 \\<in> mset ` set (resolve_rename C D) \\<Longrightarrow>\n  ?E2 \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "fix E"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "assume e_in: \"E \\<in> Bin_ord_resolve_rename (mset C) (mset D)\""], ["proof (state)\nthis:\n  E \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n       x \\<in> mset ` set (resolve_rename C D)", "show \"E \\<in> mset ` set (resolve_rename C D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<in> mset ` set (resolve_rename C D)", "using e_in"], ["proof (prove)\nusing this:\n  E \\<in> Bin_ord_resolve_rename (mset C) (mset D)\n\ngoal (1 subgoal):\n 1. E \\<in> mset ` set (resolve_rename C D)", "unfolding resolve_rename_def Let_def resolve_eq_Bin_ord_resolve ord_resolve_rename.simps"], ["proof (prove)\nusing this:\n  E \\<in> {E. \\<exists>AA A \\<sigma> CAs n AAs As DA \\<rho> \\<rho>s\n                 \\<sigma>' Ea.\n                 [mset C] = CAs \\<and>\n                 mset D = DA \\<and>\n                 [AA] = AAs \\<and>\n                 [A] = As \\<and>\n                 \\<sigma> = \\<sigma>' \\<and>\n                 E = Ea \\<and>\n                 length CAs = n \\<and>\n                 length AAs = n \\<and>\n                 length As = n \\<and>\n                 (\\<forall>i<n. poss (AAs ! i) \\<subseteq># CAs ! i) \\<and>\n                 negs (mset As) \\<subseteq># DA \\<and>\n                 \\<rho> = hd (renamings_apart (DA # CAs)) \\<and>\n                 \\<rho>s = tl (renamings_apart (DA # CAs)) \\<and>\n                 ord_resolve S (CAs \\<cdot>\\<cdot>cl \\<rho>s)\n                  (DA \\<cdot> \\<rho>) (AAs \\<cdot>\\<cdot>aml \\<rho>s)\n                  (As \\<cdot>al \\<rho>) \\<sigma>' Ea}\n\ngoal (1 subgoal):\n 1. E \\<in> Bin_ord_resolve\n             (mset\n               (map (\\<lambda>L.\n                        L \\<cdot>l last (renamings_apart [mset D, mset C]))\n                 C))\n             (mset\n               (map (\\<lambda>L.\n                        L \\<cdot>l hd (renamings_apart [mset D, mset C]))\n                 D))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA A \\<sigma>.\n       \\<lbrakk>poss AA \\<subseteq># mset C; Neg A \\<in> set D;\n        ord_resolve S\n         ([mset C] \\<cdot>\\<cdot>cl tl (renamings_apart [mset D, mset C]))\n         (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n         ([AA] \\<cdot>\\<cdot>aml tl (renamings_apart [mset D, mset C]))\n         [A \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>AA A \\<sigma>.\n                            ord_resolve S\n                             [{#L \\<cdot>l\n                                last (renamings_apart [mset D, mset C])\n                              . L \\<in># mset C#}]\n                             {#L \\<cdot>l\n                               hd (renamings_apart [mset D, mset C])\n                             . L \\<in># mset D#}\n                             [AA] [A] \\<sigma> E", "apply (rule_tac x = \"AA \\<cdot>am \\<rho>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA A \\<sigma>.\n       \\<lbrakk>poss AA \\<subseteq># mset C; Neg A \\<in> set D;\n        ord_resolve S\n         ([mset C] \\<cdot>\\<cdot>cl tl (renamings_apart [mset D, mset C]))\n         (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n         ([AA] \\<cdot>\\<cdot>aml tl (renamings_apart [mset D, mset C]))\n         [A \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A \\<sigma>.\n                            ord_resolve S\n                             [{#L \\<cdot>l\n                                last (renamings_apart [mset D, mset C])\n                              . L \\<in># mset C#}]\n                             {#L \\<cdot>l\n                               hd (renamings_apart [mset D, mset C])\n                             . L \\<in># mset D#}\n                             [AA \\<cdot>am \\<rho>] [A] \\<sigma> E", "apply (rule_tac x = \"A \\<cdot>a \\<rho>'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA A \\<sigma>.\n       \\<lbrakk>poss AA \\<subseteq># mset C; Neg A \\<in> set D;\n        ord_resolve S\n         ([mset C] \\<cdot>\\<cdot>cl tl (renamings_apart [mset D, mset C]))\n         (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n         ([AA] \\<cdot>\\<cdot>aml tl (renamings_apart [mset D, mset C]))\n         [A \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>.\n                            ord_resolve S\n                             [{#L \\<cdot>l\n                                last (renamings_apart [mset D, mset C])\n                              . L \\<in># mset C#}]\n                             {#L \\<cdot>l\n                               hd (renamings_apart [mset D, mset C])\n                             . L \\<in># mset D#}\n                             [AA \\<cdot>am \\<rho>] [A \\<cdot>a \\<rho>']\n                             \\<sigma> E", "apply (rule_tac x = \\<sigma> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA A \\<sigma>.\n       \\<lbrakk>poss AA \\<subseteq># mset C; Neg A \\<in> set D;\n        ord_resolve S\n         ([mset C] \\<cdot>\\<cdot>cl tl (renamings_apart [mset D, mset C]))\n         (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n         ([AA] \\<cdot>\\<cdot>aml tl (renamings_apart [mset D, mset C]))\n         [A \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> ord_resolve S\n                          [{#L \\<cdot>l\n                             last (renamings_apart [mset D, mset C])\n                           . L \\<in># mset C#}]\n                          {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n                          . L \\<in># mset D#}\n                          [AA \\<cdot>am \\<rho>] [A \\<cdot>a \\<rho>']\n                          \\<sigma> E", "unfolding tl_\\<rho>s \\<rho>'_def \\<rho>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>AA A \\<sigma>.\n       \\<lbrakk>poss AA \\<subseteq># mset C; Neg A \\<in> set D;\n        ord_resolve S\n         ([mset C] \\<cdot>\\<cdot>cl\n          [last (renamings_apart [mset D, mset C])])\n         (mset D \\<cdot> hd (renamings_apart [mset D, mset C]))\n         ([AA] \\<cdot>\\<cdot>aml [last (renamings_apart [mset D, mset C])])\n         [A \\<cdot>a hd (renamings_apart [mset D, mset C])] \\<sigma>\n         E\\<rbrakk>\n       \\<Longrightarrow> ord_resolve S\n                          [{#L \\<cdot>l\n                             last (renamings_apart [mset D, mset C])\n                           . L \\<in># mset C#}]\n                          {#L \\<cdot>l hd (renamings_apart [mset D, mset C])\n                          . L \\<in># mset D#}\n                          [AA \\<cdot>am\n                           last (renamings_apart [mset D, mset C])]\n                          [A \\<cdot>a hd (renamings_apart [mset D, mset C])]\n                          \\<sigma> E", "by (simp add: subst_cls_def subst_cls_lists_def)"], ["proof (state)\nthis:\n  E \\<in> mset ` set (resolve_rename C D)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ?E2 \\<in> Bin_ord_resolve_rename (mset C) (mset D) \\<Longrightarrow>\n  ?E2 \\<in> mset ` set (resolve_rename C D)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bin_ord_FO_\\<Gamma>_def:\n  \"ord_FO_\\<Gamma> S = {Infer {#CA#} DA E | CA DA AA A \\<sigma> E. ord_resolve_rename S [CA] DA [AA] [A] \\<sigma> E}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_FO_\\<Gamma> S =\n    {uu_.\n     \\<exists>CA DA AA A \\<sigma> E.\n        uu_ = Infer {#CA#} DA E \\<and>\n        ord_resolve_rename S [CA] DA [AA] [A] \\<sigma> E}", "unfolding ord_FO_\\<Gamma>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>CAs DA AAs As \\<sigma> E.\n        uu_ = Infer (mset CAs) DA E \\<and>\n        ord_resolve_rename S CAs DA AAs As \\<sigma> E} =\n    {uu_.\n     \\<exists>CA DA AA A \\<sigma> E.\n        uu_ = Infer {#CA#} DA E \\<and>\n        ord_resolve_rename S [CA] DA [AA] [A] \\<sigma> E}", "apply (rule order.antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {uu_.\n     \\<exists>CAs DA AAs As \\<sigma> E.\n        uu_ = Infer (mset CAs) DA E \\<and>\n        ord_resolve_rename S CAs DA AAs As \\<sigma> E}\n    \\<subseteq> {uu_.\n                 \\<exists>CA DA AA A \\<sigma> E.\n                    uu_ = Infer {#CA#} DA E \\<and>\n                    ord_resolve_rename S [CA] DA [AA] [A] \\<sigma> E}\n 2. {uu_.\n     \\<exists>CA DA AA A \\<sigma> E.\n        uu_ = Infer {#CA#} DA E \\<and>\n        ord_resolve_rename S [CA] DA [AA] [A] \\<sigma> E}\n    \\<subseteq> {uu_.\n                 \\<exists>CAs DA AAs As \\<sigma> E.\n                    uu_ = Infer (mset CAs) DA E \\<and>\n                    ord_resolve_rename S CAs DA AAs As \\<sigma> E}", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x CAs DA AAs As \\<sigma> E.\n       ord_resolve_rename S CAs DA AAs As \\<sigma> E \\<Longrightarrow>\n       \\<exists>CA DAa AA A \\<sigma> Ea.\n          Infer (mset CAs) DA E = Infer {#CA#} DAa Ea \\<and>\n          ord_resolve_rename S [CA] DAa [AA] [A] \\<sigma> Ea\n 2. {uu_.\n     \\<exists>CA DA AA A \\<sigma> E.\n        uu_ = Infer {#CA#} DA E \\<and>\n        ord_resolve_rename S [CA] DA [AA] [A] \\<sigma> E}\n    \\<subseteq> {uu_.\n                 \\<exists>CAs DA AAs As \\<sigma> E.\n                    uu_ = Infer (mset CAs) DA E \\<and>\n                    ord_resolve_rename S CAs DA AAs As \\<sigma> E}", "apply (frule ord_resolve_rename_one_side_prem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x CAs DA AAs As \\<sigma> E.\n       \\<lbrakk>ord_resolve_rename S CAs DA AAs As \\<sigma> E;\n        length CAs = 1 \\<and> length AAs = 1 \\<and> length As = 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>CA DAa AA A \\<sigma> Ea.\n                            Infer (mset CAs) DA E =\n                            Infer {#CA#} DAa Ea \\<and>\n                            ord_resolve_rename S [CA] DAa [AA] [A] \\<sigma>\n                             Ea\n 2. {uu_.\n     \\<exists>CA DA AA A \\<sigma> E.\n        uu_ = Infer {#CA#} DA E \\<and>\n        ord_resolve_rename S [CA] DA [AA] [A] \\<sigma> E}\n    \\<subseteq> {uu_.\n                 \\<exists>CAs DA AAs As \\<sigma> E.\n                    uu_ = Infer (mset CAs) DA E \\<and>\n                    ord_resolve_rename S CAs DA AAs As \\<sigma> E}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>CAs DA AAs As \\<sigma> E.\n       \\<lbrakk>ord_resolve_rename S CAs DA AAs As \\<sigma> E;\n        length CAs = Suc 0 \\<and>\n        length AAs = Suc 0 \\<and> length As = Suc 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>CA.\n                            CAs = [CA] \\<and>\n                            (\\<exists>AA A \\<sigma>.\n                                ord_resolve_rename S [CA] DA [AA] [A]\n                                 \\<sigma> E)\n 2. {uu_.\n     \\<exists>CA DA AA A \\<sigma> E.\n        uu_ = Infer {#CA#} DA E \\<and>\n        ord_resolve_rename S [CA] DA [AA] [A] \\<sigma> E}\n    \\<subseteq> {uu_.\n                 \\<exists>CAs DA AAs As \\<sigma> E.\n                    uu_ = Infer (mset CAs) DA E \\<and>\n                    ord_resolve_rename S CAs DA AAs As \\<sigma> E}", "apply (metis Suc_length_conv length_0_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>CA DA AA A \\<sigma> E.\n        uu_ = Infer {#CA#} DA E \\<and>\n        ord_resolve_rename S [CA] DA [AA] [A] \\<sigma> E}\n    \\<subseteq> {uu_.\n                 \\<exists>CAs DA AAs As \\<sigma> E.\n                    uu_ = Infer (mset CAs) DA E \\<and>\n                    ord_resolve_rename S CAs DA AAs As \\<sigma> E}", "by blast"], ["", "lemma ord_FO_\\<Gamma>_side_prem: \"\\<gamma> \\<in> ord_FO_\\<Gamma> S \\<Longrightarrow> side_prems_of \\<gamma> = {#THE D. D \\<in># side_prems_of \\<gamma>#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> \\<in> ord_FO_\\<Gamma> S \\<Longrightarrow>\n    side_prems_of \\<gamma> = {#THE D. D \\<in># side_prems_of \\<gamma>#}", "unfolding bin_ord_FO_\\<Gamma>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma>\n    \\<in> {uu_.\n           \\<exists>CA DA AA A \\<sigma> E.\n              uu_ = Infer {#CA#} DA E \\<and>\n              ord_resolve_rename S [CA] DA [AA] [A] \\<sigma>\n               E} \\<Longrightarrow>\n    side_prems_of \\<gamma> = {#THE D. D \\<in># side_prems_of \\<gamma>#}", "by clarsimp"], ["", "lemma ord_FO_\\<Gamma>_infer_from_Collect_eq:\n  \"{\\<gamma> \\<in> ord_FO_\\<Gamma> S. infer_from (DD \\<union> {C}) \\<gamma> \\<and> C \\<in># prems_of \\<gamma>} =\n   {\\<gamma> \\<in> ord_FO_\\<Gamma> S. \\<exists>D \\<in> DD \\<union> {C}. prems_of \\<gamma> = {#C, D#}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     infer_from (DD \\<union> {C}) \\<gamma> \\<and>\n     C \\<in># prems_of \\<gamma>} =\n    {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     \\<exists>D\\<in>DD \\<union> {C}. prems_of \\<gamma> = {#C, D#}}", "unfolding infer_from_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     set_mset (prems_of \\<gamma>) \\<subseteq> DD \\<union> {C} \\<and>\n     C \\<in># prems_of \\<gamma>} =\n    {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     \\<exists>D\\<in>DD \\<union> {C}. prems_of \\<gamma> = {#C, D#}}", "apply (rule set_eq_subset[THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     set_mset (prems_of \\<gamma>) \\<subseteq> DD \\<union> {C} \\<and>\n     C \\<in># prems_of \\<gamma>}\n    \\<subseteq> {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n                 \\<exists>D\\<in>DD \\<union> {C}.\n                    prems_of \\<gamma> = {#C, D#}} \\<and>\n    {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     \\<exists>D\\<in>DD \\<union> {C}. prems_of \\<gamma> = {#C, D#}}\n    \\<subseteq> {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n                 set_mset (prems_of \\<gamma>)\n                 \\<subseteq> DD \\<union> {C} \\<and>\n                 C \\<in># prems_of \\<gamma>}", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     set_mset (prems_of \\<gamma>) \\<subseteq> DD \\<union> {C} \\<and>\n     C \\<in># prems_of \\<gamma>}\n    \\<subseteq> {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n                 \\<exists>D\\<in>DD \\<union> {C}.\n                    prems_of \\<gamma> = {#C, D#}}\n 2. {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     \\<exists>D\\<in>DD \\<union> {C}. prems_of \\<gamma> = {#C, D#}}\n    \\<subseteq> {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n                 set_mset (prems_of \\<gamma>)\n                 \\<subseteq> DD \\<union> {C} \\<and>\n                 C \\<in># prems_of \\<gamma>}", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ord_FO_\\<Gamma> S;\n        set_mset (prems_of x) \\<subseteq> DD \\<union> {C};\n        C \\<in># prems_of x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D\\<in>DD \\<union> {C}.\n                            prems_of x = {#C, D#}\n 2. {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     \\<exists>D\\<in>DD \\<union> {C}. prems_of \\<gamma> = {#C, D#}}\n    \\<subseteq> {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n                 set_mset (prems_of \\<gamma>)\n                 \\<subseteq> DD \\<union> {C} \\<and>\n                 C \\<in># prems_of \\<gamma>}", "apply (subst (asm) (1 2) ord_FO_\\<Gamma>_side_prem, assumption, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ord_FO_\\<Gamma> S;\n        set_mset ({#THE D. D \\<in># side_prems_of x#} + {#main_prem_of x#})\n        \\<subseteq> DD \\<union> {C};\n        C \\<in># {#THE D. D \\<in># side_prems_of x#} +\n                 {#main_prem_of x#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D\\<in>DD \\<union> {C}.\n                            prems_of x = {#C, D#}\n 2. {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     \\<exists>D\\<in>DD \\<union> {C}. prems_of \\<gamma> = {#C, D#}}\n    \\<subseteq> {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n                 set_mset (prems_of \\<gamma>)\n                 \\<subseteq> DD \\<union> {C} \\<and>\n                 C \\<in># prems_of \\<gamma>}", "apply (subst (1) ord_FO_\\<Gamma>_side_prem, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ord_FO_\\<Gamma> S;\n        set_mset ({#THE D. D \\<in># side_prems_of x#} + {#main_prem_of x#})\n        \\<subseteq> DD \\<union> {C};\n        C \\<in># {#THE D. D \\<in># side_prems_of x#} +\n                 {#main_prem_of x#}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D\\<in>DD \\<union> {C}.\n                            {#THE D. D \\<in># side_prems_of x#} +\n                            {#main_prem_of x#} =\n                            {#C, D#}\n 2. {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     \\<exists>D\\<in>DD \\<union> {C}. prems_of \\<gamma> = {#C, D#}}\n    \\<subseteq> {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n                 set_mset (prems_of \\<gamma>)\n                 \\<subseteq> DD \\<union> {C} \\<and>\n                 C \\<in># prems_of \\<gamma>}", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     \\<exists>D\\<in>DD \\<union> {C}. prems_of \\<gamma> = {#C, D#}}\n    \\<subseteq> {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n                 set_mset (prems_of \\<gamma>)\n                 \\<subseteq> DD \\<union> {C} \\<and>\n                 C \\<in># prems_of \\<gamma>}", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x D.\n       \\<lbrakk>x \\<in> ord_FO_\\<Gamma> S; D \\<in> DD \\<union> {C};\n        prems_of x = {#C, D#}\\<rbrakk>\n       \\<Longrightarrow> set_mset (prems_of x)\n                         \\<subseteq> DD \\<union> {C} \\<and>\n                         C \\<in># prems_of x", "apply (subst (asm) (1) ord_FO_\\<Gamma>_side_prem, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x D.\n       \\<lbrakk>x \\<in> ord_FO_\\<Gamma> S; D \\<in> DD \\<union> {C};\n        {#THE D. D \\<in># side_prems_of x#} + {#main_prem_of x#} =\n        {#C, D#}\\<rbrakk>\n       \\<Longrightarrow> set_mset (prems_of x)\n                         \\<subseteq> DD \\<union> {C} \\<and>\n                         C \\<in># prems_of x", "apply (subst (1 2) ord_FO_\\<Gamma>_side_prem, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x D.\n       \\<lbrakk>x \\<in> ord_FO_\\<Gamma> S; D \\<in> DD \\<union> {C};\n        {#THE D. D \\<in># side_prems_of x#} + {#main_prem_of x#} =\n        {#C, D#}\\<rbrakk>\n       \\<Longrightarrow> set_mset\n                          ({#THE D. D \\<in># side_prems_of x#} +\n                           {#main_prem_of x#})\n                         \\<subseteq> DD \\<union> {C} \\<and>\n                         C \\<in># {#THE D. D \\<in># side_prems_of x#} +\n                                  {#main_prem_of x#}", "by force"], ["", "lemma inferences_between_eq_UNION: \"inference_system.inferences_between (ord_FO_\\<Gamma> S) Q C =\n  inference_system.inferences_between (ord_FO_\\<Gamma> S) {C} C\n  \\<union> (\\<Union>D \\<in> Q. inference_system.inferences_between (ord_FO_\\<Gamma> S) {D} C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inference_system.inferences_between (ord_FO_\\<Gamma> S) Q C =\n    inference_system.inferences_between (ord_FO_\\<Gamma> S) {C} C \\<union>\n    (\\<Union>D\\<in>Q.\n        inference_system.inferences_between (ord_FO_\\<Gamma> S) {D} C)", "unfolding ord_FO_\\<Gamma>_infer_from_Collect_eq inference_system.inferences_between_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     \\<exists>D\\<in>Q \\<union> {C}. prems_of \\<gamma> = {#C, D#}} =\n    {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n     \\<exists>D\\<in>{C} \\<union> {C}. prems_of \\<gamma> = {#C, D#}} \\<union>\n    (\\<Union>D\\<in>Q.\n        {\\<gamma> \\<in> ord_FO_\\<Gamma> S.\n         \\<exists>D\\<in>{D} \\<union> {C}. prems_of \\<gamma> = {#C, D#}})", "by auto"], ["", "lemma concls_of_inferences_between_singleton_eq_Bin_ord_resolve_rename:\n  \"concls_of (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D} C) =\n   Bin_ord_resolve_rename C C \\<union> Bin_ord_resolve_rename C D \\<union> Bin_ord_resolve_rename D C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concls_of\n     (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D} C) =\n    Bin_ord_resolve_rename C C \\<union> Bin_ord_resolve_rename C D \\<union>\n    Bin_ord_resolve_rename D C", "proof (intro order_antisym subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> concls_of\n                (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D}\n                  C) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename C C \\<union>\n               Bin_ord_resolve_rename C D \\<union>\n               Bin_ord_resolve_rename D C\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename C C \\<union>\n               Bin_ord_resolve_rename C D \\<union>\n               Bin_ord_resolve_rename D C \\<Longrightarrow>\n       x \\<in> concls_of\n                (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D}\n                  C)", "fix E"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> concls_of\n                (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D}\n                  C) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename C C \\<union>\n               Bin_ord_resolve_rename C D \\<union>\n               Bin_ord_resolve_rename D C\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename C C \\<union>\n               Bin_ord_resolve_rename C D \\<union>\n               Bin_ord_resolve_rename D C \\<Longrightarrow>\n       x \\<in> concls_of\n                (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D}\n                  C)", "assume e_in: \"E \\<in> concls_of (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D} C)\""], ["proof (state)\nthis:\n  E \\<in> concls_of\n           (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D} C)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> concls_of\n                (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D}\n                  C) \\<Longrightarrow>\n       x \\<in> Bin_ord_resolve_rename C C \\<union>\n               Bin_ord_resolve_rename C D \\<union>\n               Bin_ord_resolve_rename D C\n 2. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename C C \\<union>\n               Bin_ord_resolve_rename C D \\<union>\n               Bin_ord_resolve_rename D C \\<Longrightarrow>\n       x \\<in> concls_of\n                (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D}\n                  C)", "then"], ["proof (chain)\npicking this:\n  E \\<in> concls_of\n           (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D} C)", "show \"E \\<in> Bin_ord_resolve_rename C C \\<union> Bin_ord_resolve_rename C D\n    \\<union> Bin_ord_resolve_rename D C\""], ["proof (prove)\nusing this:\n  E \\<in> concls_of\n           (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D} C)\n\ngoal (1 subgoal):\n 1. E \\<in> Bin_ord_resolve_rename C C \\<union>\n            Bin_ord_resolve_rename C D \\<union>\n            Bin_ord_resolve_rename D C", "unfolding inference_system.inferences_between_def ord_FO_\\<Gamma>_infer_from_Collect_eq\n      bin_ord_FO_\\<Gamma>_def infer_from_def"], ["proof (prove)\nusing this:\n  E \\<in> concls_of\n           {\\<gamma>\n            \\<in> {uu_.\n                   \\<exists>CA DA AA A \\<sigma> E.\n                      uu_ = Infer {#CA#} DA E \\<and>\n                      ord_resolve_rename S [CA] DA [AA] [A] \\<sigma> E}.\n            set_mset (prems_of \\<gamma>) \\<subseteq> {D} \\<union> {C} \\<and>\n            C \\<in># prems_of \\<gamma>}\n\ngoal (1 subgoal):\n 1. E \\<in> Bin_ord_resolve_rename C C \\<union>\n            Bin_ord_resolve_rename C D \\<union>\n            Bin_ord_resolve_rename D C", "by (fastforce simp: add_mset_eq_add_mset)"], ["proof (state)\nthis:\n  E \\<in> Bin_ord_resolve_rename C C \\<union>\n          Bin_ord_resolve_rename C D \\<union>\n          Bin_ord_resolve_rename D C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bin_ord_resolve_rename C C \\<union>\n               Bin_ord_resolve_rename C D \\<union>\n               Bin_ord_resolve_rename D C \\<Longrightarrow>\n       x \\<in> concls_of\n                (inference_system.inferences_between (ord_FO_\\<Gamma> S) {D}\n                  C)", "qed (force simp: inference_system.inferences_between_def infer_from_def ord_FO_\\<Gamma>_def)"], ["", "lemma concls_of_inferences_between_eq_Bin_ord_resolve_rename:\n  \"concls_of (inference_system.inferences_between (ord_FO_\\<Gamma> S) Q C) =\n   Bin_ord_resolve_rename C C \\<union> (\\<Union>D \\<in> Q. Bin_ord_resolve_rename C D \\<union> Bin_ord_resolve_rename D C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concls_of\n     (inference_system.inferences_between (ord_FO_\\<Gamma> S) Q C) =\n    Bin_ord_resolve_rename C C \\<union>\n    (\\<Union>D\\<in>Q.\n        Bin_ord_resolve_rename C D \\<union> Bin_ord_resolve_rename D C)", "by (subst inferences_between_eq_UNION)\n    (auto simp: image_Un image_UN concls_of_inferences_between_singleton_eq_Bin_ord_resolve_rename)"], ["", "lemma resolve_rename_either_way_eq_congls_of_inferences_between:\n  \"mset ` set (resolve_rename C C) \\<union> (\\<Union>D \\<in> Q. mset ` set (resolve_rename_either_way C D)) =\n   concls_of (inference_system.inferences_between (ord_FO_\\<Gamma> S) (mset ` Q) (mset C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ` set (resolve_rename C C) \\<union>\n    (\\<Union>D\\<in>Q. mset ` set (resolve_rename_either_way C D)) =\n    concls_of\n     (inference_system.inferences_between (ord_FO_\\<Gamma> S) (mset ` Q)\n       (mset C))", "by (simp add: resolve_rename_either_way_def image_Un resolve_rename_eq_Bin_ord_resolve_rename\n      concls_of_inferences_between_eq_Bin_ord_resolve_rename UN_Un_distrib)"], ["", "lemma compute_inferences:\n  assumes\n    ci_in: \"(C, i) \\<in> set P\" and\n    ci_min: \"\\<forall>(D, j) \\<in># mset (map (apfst mset) P). weight (mset C, i) \\<le> weight (D, j)\"\n  shows\n    \"wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\n     wstate_of_dstate (map (\\<lambda>D. (D, n)) (remdups_gen mset (resolve_rename C C @\n         concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n       filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q, Suc n)\"\n    (is \"_ \\<leadsto>\\<^sub>w wstate_of_dstate (?N, _)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate\n     (map (\\<lambda>D. (D, n))\n       (remdups_gen mset\n         (resolve_rename C C @\n          concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n      filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q, Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate\n     (map (\\<lambda>D. (D, n))\n       (remdups_gen mset\n         (resolve_rename C C @\n          concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n      filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q, Suc n)", "have ms_ci_in: \"(mset C, i) \\<in># image_mset (apfst mset) (mset P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset C, i) \\<in># image_mset (apfst mset) (mset P)", "using ci_in"], ["proof (prove)\nusing this:\n  (C, i) \\<in> set P\n\ngoal (1 subgoal):\n 1. (mset C, i) \\<in># image_mset (apfst mset) (mset P)", "by force"], ["proof (state)\nthis:\n  (mset C, i) \\<in># image_mset (apfst mset) (mset P)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate\n     (map (\\<lambda>D. (D, n))\n       (remdups_gen mset\n         (resolve_rename C C @\n          concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n      filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q, Suc n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate\n     (map (\\<lambda>D. (D, n))\n       (remdups_gen mset\n         (resolve_rename C C @\n          concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n      filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q, Suc n)", "apply (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w)\", OF _ _\n          wrp.inference_computation[of \"mset (map (apfst mset) P) - {#(mset C, i)#}\" \"mset C\" i\n            \"mset (map (apfst mset) ?N)\" n \"mset (map (apfst mset) Q)\"]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. ({#},\n     remove1_mset (mset C, i) (mset (map (apfst mset) P)) + {#(mset C, i)#},\n     mset (map (apfst mset) Q), n) =\n    wstate_of_dstate ([], P, Q, n)\n 2. (mset\n      (map (apfst mset)\n        (map (\\<lambda>D. (D, n))\n          (remdups_gen mset\n            (resolve_rename C C @\n             concat (map (resolve_rename_either_way C \\<circ> fst) Q))))),\n     {#(D, j) \\<in># remove1_mset (mset C, i) (mset (map (apfst mset) P)).\n      D \\<noteq> mset C#},\n     mset (map (apfst mset) Q) + {#(mset C, i)#}, Suc n) =\n    wstate_of_dstate\n     (map (\\<lambda>D. (D, n))\n       (remdups_gen mset\n         (resolve_rename C C @\n          concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n      filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q, Suc n)\n 3. \\<forall>(D,\n       j)\\<in>#remove1_mset (mset C, i) (mset (map (apfst mset) P)).\n       weight (mset C, i) \\<le> weight (D, j)\n 4. mset\n     (map (apfst mset)\n       (map (\\<lambda>D. (D, n))\n         (remdups_gen mset\n           (resolve_rename C C @\n            concat (map (resolve_rename_either_way C \\<circ> fst) Q))))) =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "apply (simp add: add_mset_remove_trivial_eq[THEN iffD2, OF ms_ci_in, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (mset\n      (map (apfst mset)\n        (map (\\<lambda>D. (D, n))\n          (remdups_gen mset\n            (resolve_rename C C @\n             concat (map (resolve_rename_either_way C \\<circ> fst) Q))))),\n     {#(D, j) \\<in># remove1_mset (mset C, i) (mset (map (apfst mset) P)).\n      D \\<noteq> mset C#},\n     mset (map (apfst mset) Q) + {#(mset C, i)#}, Suc n) =\n    wstate_of_dstate\n     (map (\\<lambda>D. (D, n))\n       (remdups_gen mset\n         (resolve_rename C C @\n          concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n      filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q, Suc n)\n 2. \\<forall>(D,\n       j)\\<in>#remove1_mset (mset C, i) (mset (map (apfst mset) P)).\n       weight (mset C, i) \\<le> weight (D, j)\n 3. mset\n     (map (apfst mset)\n       (map (\\<lambda>D. (D, n))\n         (remdups_gen mset\n           (resolve_rename C C @\n            concat (map (resolve_rename_either_way C \\<circ> fst) Q))))) =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "using ms_ci_in"], ["proof (prove)\nusing this:\n  (mset C, i) \\<in># image_mset (apfst mset) (mset P)\n\ngoal (3 subgoals):\n 1. (mset\n      (map (apfst mset)\n        (map (\\<lambda>D. (D, n))\n          (remdups_gen mset\n            (resolve_rename C C @\n             concat (map (resolve_rename_either_way C \\<circ> fst) Q))))),\n     {#(D, j) \\<in># remove1_mset (mset C, i) (mset (map (apfst mset) P)).\n      D \\<noteq> mset C#},\n     mset (map (apfst mset) Q) + {#(mset C, i)#}, Suc n) =\n    wstate_of_dstate\n     (map (\\<lambda>D. (D, n))\n       (remdups_gen mset\n         (resolve_rename C C @\n          concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n      filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q, Suc n)\n 2. \\<forall>(D,\n       j)\\<in>#remove1_mset (mset C, i) (mset (map (apfst mset) P)).\n       weight (mset C, i) \\<le> weight (D, j)\n 3. mset\n     (map (apfst mset)\n       (map (\\<lambda>D. (D, n))\n         (remdups_gen mset\n           (resolve_rename C C @\n            concat (map (resolve_rename_either_way C \\<circ> fst) Q))))) =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "apply (simp add: ci_in image_mset_remove1_mset_if)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (mset C, i) \\<in> apfst mset ` set P \\<Longrightarrow>\n    {#(D, j) \\<in># image_mset (apfst mset) (mset P). D \\<noteq> mset C#} =\n    image_mset (apfst mset) {#(D, j) \\<in># mset P. mset D \\<noteq> mset C#}\n 2. \\<forall>(D,\n       j)\\<in>#remove1_mset (mset C, i) (mset (map (apfst mset) P)).\n       weight (mset C, i) \\<le> weight (D, j)\n 3. mset\n     (map (apfst mset)\n       (map (\\<lambda>D. (D, n))\n         (remdups_gen mset\n           (resolve_rename C C @\n            concat (map (resolve_rename_either_way C \\<circ> fst) Q))))) =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "apply (smt apfst_conv case_prodE case_prodI2 case_prod_conv filter_mset_cong\n        image_mset_filter_swap mset_filter)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>(D,\n       j)\\<in>#remove1_mset (mset C, i) (mset (map (apfst mset) P)).\n       weight (mset C, i) \\<le> weight (D, j)\n 2. mset\n     (map (apfst mset)\n       (map (\\<lambda>D. (D, n))\n         (remdups_gen mset\n           (resolve_rename C C @\n            concat (map (resolve_rename_either_way C \\<circ> fst) Q))))) =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "apply (metis ci_min in_diffD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (map (apfst mset)\n       (map (\\<lambda>D. (D, n))\n         (remdups_gen mset\n           (resolve_rename C C @\n            concat (map (resolve_rename_either_way C \\<circ> fst) Q))))) =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "apply (simp only: list.map_comp apfst_comp_rpair_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (map ((\\<lambda>D. (D, n)) \\<circ> mset)\n       (remdups_gen mset\n         (resolve_rename C C @\n          concat (map (resolve_rename_either_way C \\<circ> fst) Q)))) =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "apply (simp only: list.map_comp[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (map (\\<lambda>D. (D, n))\n       (map mset\n         (remdups_gen mset\n           (resolve_rename C C @\n            concat (map (resolve_rename_either_way C) (map fst Q)))))) =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "apply (subst mset_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#(D, n)\n    . D \\<in># mset\n                (map mset\n                  (remdups_gen mset\n                    (resolve_rename C C @\n                     concat\n                      (map (resolve_rename_either_way C) (map fst Q)))))#} =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "apply (unfold mset_map_remdups_gen mset_remdups_gen_ident)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#(D, n)\n    . D \\<in># mset_set\n                (set (map mset\n                       (resolve_rename C C @\n                        concat\n                         (map (resolve_rename_either_way C)\n                           (map fst Q)))))#} =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "apply (subst image_mset_mset_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>D. (D, n))\n     (set (map mset\n            (resolve_rename C C @\n             concat (map (resolve_rename_either_way C) (map fst Q)))))\n 2. mset_set\n     ((\\<lambda>D. (D, n)) `\n      set (map mset\n            (resolve_rename C C @\n             concat (map (resolve_rename_either_way C) (map fst Q))))) =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "apply (simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_set\n     ((\\<lambda>D. (D, n)) `\n      set (map mset\n            (resolve_rename C C @\n             concat (map (resolve_rename_either_way C) (map fst Q))))) =\n    mset_set\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))", "apply (subst mset_set_eq_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite\n     ((\\<lambda>D. (D, n)) `\n      set (map mset\n            (resolve_rename C C @\n             concat (map (resolve_rename_either_way C) (map fst Q)))))\n 2. finite\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))\n 3. (\\<lambda>D. (D, n)) `\n    set (map mset\n          (resolve_rename C C @\n           concat (map (resolve_rename_either_way C) (map fst Q)))) =\n    (\\<lambda>D. (D, n)) `\n    concls_of\n     (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n       (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     ((\\<lambda>D. (D, n)) `\n      concls_of\n       (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n         (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C)))\n 2. (\\<lambda>D. (D, n)) `\n    set (map mset\n          (resolve_rename C C @\n           concat (map (resolve_rename_either_way C) (map fst Q)))) =\n    (\\<lambda>D. (D, n)) `\n    concls_of\n     (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n       (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C))", "apply (simp add: finite_ord_FO_resolution_inferences_between)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>D. (D, n)) `\n    set (map mset\n          (resolve_rename C C @\n           concat (map (resolve_rename_either_way C) (map fst Q)))) =\n    (\\<lambda>D. (D, n)) `\n    concls_of\n     (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n       (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C))", "apply (rule arg_cong[of _ _ \"\\<lambda>N. (\\<lambda>D. (D, n)) ` N\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map mset\n          (resolve_rename C C @\n           concat (map (resolve_rename_either_way C) (map fst Q)))) =\n    concls_of\n     (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n       (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C))", "apply (simp only: map_concat list.map_comp image_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map mset\n          (resolve_rename C C @\n           concat (map (resolve_rename_either_way C \\<circ> fst) Q))) =\n    concls_of\n     (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n       (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C))", "using resolve_rename_either_way_eq_congls_of_inferences_between[of C \"fst ` set Q\", symmetric]"], ["proof (prove)\nusing this:\n  concls_of\n   (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n     (mset ` fst ` set Q) (mset C)) =\n  mset ` set (resolve_rename C C) \\<union>\n  (\\<Union>D\\<in>fst ` set Q. mset ` set (resolve_rename_either_way C D))\n\ngoal (1 subgoal):\n 1. set (map mset\n          (resolve_rename C C @\n           concat (map (resolve_rename_either_way C \\<circ> fst) Q))) =\n    concls_of\n     (inference_system.inferences_between (ord_FO_\\<Gamma> S)\n       (set_mset (image_mset fst (mset (map (apfst mset) Q)))) (mset C))", "by (simp add: image_comp comp_def image_UN)"], ["proof (state)\nthis:\n  wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate\n   (map (\\<lambda>D. (D, n))\n     (remdups_gen mset\n       (resolve_rename C C @\n        concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n    filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q, Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonfinal_deterministic_RP_step:\n  assumes\n    nonfinal: \"\\<not> is_final_dstate St\" and\n    step: \"St' = deterministic_RP_step St\"\n  shows \"wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "obtain N P Q :: \"'a dclause list\" and n :: nat where\n    st: \"St = (N, P, Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N P Q n.\n        St = (N, P, Q, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases St) blast"], ["proof (state)\nthis:\n  St = (N, P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[unfolded st deterministic_RP_step.simps, simplified]"], ["proof (state)\nthis:\n  St' =\n  (if \\<exists>Ci\\<in>set P \\<union> set Q. fst Ci = []\n   then ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\n   else case N of\n        [] \\<Rightarrow>\n          case P of [] \\<Rightarrow> (N, P, Q, n)\n          | P0 # P' \\<Rightarrow>\n              let (C, i) = select_min_weight_clause P0 P';\n                  N = map (\\<lambda>D. (D, n))\n                       (remdups_gen mset\n                         (resolve_rename C C @\n                          concat\n                           (map (resolve_rename_either_way C \\<circ> fst)\n                             Q)));\n                  P = filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P;\n                  Q = (C, i) # Q; n = Suc n\n              in (N, P, Q, n)\n        | (C, i) # N \\<Rightarrow>\n            let C = reduce (map fst (P @ Q)) [] C\n            in if C = [] then ([], [], [([], i)], Suc n)\n               else if is_tautology C \\<or> subsume (map fst (P @ Q)) C\n                    then (N, P, Q, n)\n                    else let P = reduce_all C P;\n                             (back_to_P, Q) = reduce_all2 C Q;\n                             P = back_to_P @ P;\n                             Q = filter\n                                  (Not \\<circ> strictly_subsume [C] \\<circ>\n                                   fst)\n                                  Q;\n                             P = filter\n                                  (Not \\<circ> strictly_subsume [C] \\<circ>\n                                   fst)\n                                  P;\n                             P = (C, i) # P\n                         in (N, P, Q, n))\n\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "proof (cases \"\\<exists>Ci \\<in> set P \\<union> set Q. fst Ci = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>Ci\\<in>set P \\<union> set Q. fst Ci = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q.\n               fst Ci = []) \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "case nil_in: True"], ["proof (state)\nthis:\n  \\<exists>Ci\\<in>set P \\<union> set Q. fst Ci = []\n\ngoal (2 subgoals):\n 1. \\<exists>Ci\\<in>set P \\<union> set Q. fst Ci = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q.\n               fst Ci = []) \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[simplified nil_in, simplified]"], ["proof (state)\nthis:\n  St' = ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\n\ngoal (2 subgoals):\n 1. \\<exists>Ci\\<in>set P \\<union> set Q. fst Ci = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q.\n               fst Ci = []) \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have nil_in': \"[] \\<in> fst ` set (P @ Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> fst ` set (P @ Q)", "using nil_in"], ["proof (prove)\nusing this:\n  \\<exists>Ci\\<in>set P \\<union> set Q. fst Ci = []\n\ngoal (1 subgoal):\n 1. [] \\<in> fst ` set (P @ Q)", "by (force simp: image_def)"], ["proof (state)\nthis:\n  [] \\<in> fst ` set (P @ Q)\n\ngoal (2 subgoals):\n 1. \\<exists>Ci\\<in>set P \\<union> set Q. fst Ci = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q.\n               fst Ci = []) \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have star: \"[] \\<in> fst ` set (P @ Q) \\<Longrightarrow>\n      wstate_of_dstate (N, P, Q, n)\n      \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> fst ` set (P @ Q) \\<Longrightarrow>\n    wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ([], [], remdups_clss P @ Q, n + length (remdups_clss P))", "proof (induct \"length (remdups_clss P)\" arbitrary: N P Q n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P N Q n.\n       \\<lbrakk>0 = length (remdups_clss P);\n        [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))\n 2. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "case 0"], ["proof (state)\nthis:\n  0 = length (remdups_clss P)\n  [] \\<in> fst ` set (P @ Q)\n\ngoal (2 subgoals):\n 1. \\<And>P N Q n.\n       \\<lbrakk>0 = length (remdups_clss P);\n        [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))\n 2. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "note len_p = this(1) and nil_in' = this(2)"], ["proof (state)\nthis:\n  0 = length (remdups_clss P)\n  [] \\<in> fst ` set (P @ Q)\n\ngoal (2 subgoals):\n 1. \\<And>P N Q n.\n       \\<lbrakk>0 = length (remdups_clss P);\n        [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))\n 2. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "have p_nil: \"P = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = []", "using len_p remdups_clss_Nil_iff"], ["proof (prove)\nusing this:\n  0 = length (remdups_clss P)\n  (remdups_clss ?Cs = []) = (?Cs = [])\n\ngoal (1 subgoal):\n 1. P = []", "by simp"], ["proof (state)\nthis:\n  P = []\n\ngoal (2 subgoals):\n 1. \\<And>P N Q n.\n       \\<lbrakk>0 = length (remdups_clss P);\n        [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))\n 2. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "have \"wstate_of_dstate (N, [], Q, n) \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ([], [], Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, [], Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ([], [], Q, n)", "by (rule empty_N_if_Nil_in_P_or_Q[OF nil_in'[unfolded p_nil]])"], ["proof (state)\nthis:\n  wstate_of_dstate (N, [], Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [], Q, n)\n\ngoal (2 subgoals):\n 1. \\<And>P N Q n.\n       \\<lbrakk>0 = length (remdups_clss P);\n        [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))\n 2. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "then"], ["proof (chain)\npicking this:\n  wstate_of_dstate (N, [], Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [], Q, n)", "show ?case"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, [], Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [], Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ([], [], remdups_clss P @ Q, n + length (remdups_clss P))", "unfolding p_nil"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, [], Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [], Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, [], Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ([], [], remdups_clss [] @ Q, n + length (remdups_clss []))", "by simp"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>k = length (remdups_clss ?P);\n   [] \\<in> fst ` set (?P @ ?Q)\\<rbrakk>\n  \\<Longrightarrow> wstate_of_dstate\n                     (?N, ?P, ?Q, ?n) \\<leadsto>\\<^sub>w\\<^sup>*\n                    wstate_of_dstate\n                     ([], [], remdups_clss ?P @ ?Q,\n                      ?n + length (remdups_clss ?P))\n  Suc k = length (remdups_clss P)\n  [] \\<in> fst ` set (P @ Q)\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "note ih = this(1) and suc_k = this(2) and nil_in' = this(3)"], ["proof (state)\nthis:\n  \\<lbrakk>k = length (remdups_clss ?P);\n   [] \\<in> fst ` set (?P @ ?Q)\\<rbrakk>\n  \\<Longrightarrow> wstate_of_dstate\n                     (?N, ?P, ?Q, ?n) \\<leadsto>\\<^sub>w\\<^sup>*\n                    wstate_of_dstate\n                     ([], [], remdups_clss ?P @ ?Q,\n                      ?n + length (remdups_clss ?P))\n  Suc k = length (remdups_clss P)\n  [] \\<in> fst ` set (P @ Q)\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "have \"P \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<noteq> []", "using suc_k remdups_clss_Nil_iff"], ["proof (prove)\nusing this:\n  Suc k = length (remdups_clss P)\n  (remdups_clss ?Cs = []) = (?Cs = [])\n\ngoal (1 subgoal):\n 1. P \\<noteq> []", "by force"], ["proof (state)\nthis:\n  P \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "hence p_cons: \"P = hd P # tl P\""], ["proof (prove)\nusing this:\n  P \\<noteq> []\n\ngoal (1 subgoal):\n 1. P = hd P # tl P", "by simp"], ["proof (state)\nthis:\n  P = hd P # tl P\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "obtain C :: \"'a lclause\" and i :: nat where\n        ci: \"(C, i) = select_min_weight_clause (hd P) (tl P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C i.\n        (C, i) = select_min_weight_clause (hd P) (tl P) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  (C, i) = select_min_weight_clause (hd P) (tl P)\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "have ci_in: \"(C, i) \\<in> set P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C, i) \\<in> set P", "unfolding ci"], ["proof (prove)\ngoal (1 subgoal):\n 1. select_min_weight_clause (hd P) (tl P) \\<in> set P", "using p_cons select_min_weight_clause_in[of \"hd P\" \"tl P\"]"], ["proof (prove)\nusing this:\n  P = hd P # tl P\n  select_min_weight_clause (hd P) (tl P) \\<in> set (hd P # tl P)\n\ngoal (1 subgoal):\n 1. select_min_weight_clause (hd P) (tl P) \\<in> set P", "by simp"], ["proof (state)\nthis:\n  (C, i) \\<in> set P\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "have ci_min: \"\\<forall>(D, j) \\<in># mset (map (apfst mset) P). weight (mset C, i) \\<le> weight (D, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(D, j)\\<in>#mset (map (apfst mset) P).\n       weight (mset C, i) \\<le> weight (D, j)", "by (subst p_cons) (simp add: select_min_weight_clause_min_weight[OF ci, simplified])"], ["proof (state)\nthis:\n  \\<forall>(D, j)\\<in>#mset (map (apfst mset) P).\n     weight (mset C, i) \\<le> weight (D, j)\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "let ?P' = \"filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "have ms_p'_ci_q_eq: \"mset (remdups_clss ?P' @ (C, i) # Q) = mset (remdups_clss P @ Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P) @\n      (C, i) # Q) =\n    mset (remdups_clss P @ Q)", "apply (subst (2) p_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P) @\n      (C, i) # Q) =\n    mset (remdups_clss (hd P # tl P) @ Q)", "apply (subst remdups_clss.simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P) @\n      (C, i) # Q) =\n    mset\n     ((let Ci' = select_min_weight_clause (hd P) (tl P)\n       in Ci' #\n          remdups_clss\n           (filter (\\<lambda>(D, uu_). mset D \\<noteq> mset (fst Ci'))\n             (hd P # tl P))) @\n      Q)", "by (auto simp: Let_def case_prod_beta p_cons[symmetric] ci[symmetric])"], ["proof (state)\nthis:\n  mset\n   (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P) @\n    (C, i) # Q) =\n  mset (remdups_clss P @ Q)\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "then"], ["proof (chain)\npicking this:\n  mset\n   (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P) @\n    (C, i) # Q) =\n  mset (remdups_clss P @ Q)", "have len_p: \"length (remdups_clss P) = length (remdups_clss ?P') + 1\""], ["proof (prove)\nusing this:\n  mset\n   (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P) @\n    (C, i) # Q) =\n  mset (remdups_clss P @ Q)\n\ngoal (1 subgoal):\n 1. length (remdups_clss P) =\n    length\n     (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P)) +\n    1", "by (smt Suc_eq_plus1_left add.assoc add_right_cancel length_Cons length_append\n            mset_eq_length)"], ["proof (state)\nthis:\n  length (remdups_clss P) =\n  length\n   (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P)) +\n  1\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "have \"wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ([], P, Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ([], P, Q, n)", "by (rule empty_N_if_Nil_in_P_or_Q[OF nil_in'])"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], P, Q, n)\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "also"], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], P, Q, n)\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "obtain N' :: \"'a dclause list\" where\n        \"\\<dots> \\<leadsto>\\<^sub>w wstate_of_dstate (N', ?P', (C, i) # Q, Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N'.\n        wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\n        wstate_of_dstate\n         (N', filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P,\n          (C, i) # Q, Suc n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim, rule exI, rule compute_inferences[OF ci_in], use ci_min in fastforce)"], ["proof (state)\nthis:\n  wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate\n   (N', filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q,\n    Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "also"], ["proof (state)\nthis:\n  wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate\n   (N', filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q,\n    Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "have \"\\<dots> \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     (N', filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q,\n      Suc n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ([], [], remdups_clss P @ Q, n + length (remdups_clss P))", "apply (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w\\<^sup>*)\", OF _ _\n            ih[of ?P' \"(C, i) # Q\" N' \"Suc n\"], OF refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. wstate_of_dstate\n     ([], [],\n      remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P) @\n      (C, i) # Q,\n      Suc n +\n      length\n       (remdups_clss\n         (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P))) =\n    wstate_of_dstate\n     ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\n 2. k =\n    length\n     (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P))\n 3. [] \\<in> fst `\n             set (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P @\n                  (C, i) # Q)", "using ms_p'_ci_q_eq suc_k nil_in' ci_in"], ["proof (prove)\nusing this:\n  mset\n   (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P) @\n    (C, i) # Q) =\n  mset (remdups_clss P @ Q)\n  Suc k = length (remdups_clss P)\n  [] \\<in> fst ` set (P @ Q)\n  (C, i) \\<in> set P\n\ngoal (3 subgoals):\n 1. wstate_of_dstate\n     ([], [],\n      remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P) @\n      (C, i) # Q,\n      Suc n +\n      length\n       (remdups_clss\n         (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P))) =\n    wstate_of_dstate\n     ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\n 2. k =\n    length\n     (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P))\n 3. [] \\<in> fst `\n             set (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P @\n                  (C, i) # Q)", "apply (simp_all add: len_p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>add_mset (C, i)\n              (mset\n                (remdups_clss\n                  (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P))) =\n             mset (remdups_clss P);\n     k =\n     length\n      (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P));\n     [] \\<in> fst ` (set P \\<union> set Q); (C, i) \\<in> set P\\<rbrakk>\n    \\<Longrightarrow> add_mset (mset C, i)\n                       (image_mset (apfst mset)\n                         (mset\n                           (remdups_clss\n                             (filter\n                               (\\<lambda>(D, j). mset D \\<noteq> mset C)\n                               P)))) =\n                      image_mset (apfst mset) (mset (remdups_clss P))\n 2. \\<lbrakk>add_mset (C, i)\n              (mset\n                (remdups_clss\n                  (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P))) =\n             mset (remdups_clss P);\n     k =\n     length\n      (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P));\n     [] \\<in> fst ` (set P \\<union> set Q); (C, i) \\<in> set P\\<rbrakk>\n    \\<Longrightarrow> [] = C \\<or>\n                      [] \\<in> fst `\n                               ({x \\<in> set P.\n                                 case x of\n                                 (D, j) \\<Rightarrow>\n                                   mset D \\<noteq> mset C} \\<union>\n                                set Q)", "apply (metis (no_types) apfst_conv image_mset_add_mset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>add_mset (C, i)\n              (mset\n                (remdups_clss\n                  (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P))) =\n             mset (remdups_clss P);\n     k =\n     length\n      (remdups_clss (filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P));\n     [] \\<in> fst ` (set P \\<union> set Q); (C, i) \\<in> set P\\<rbrakk>\n    \\<Longrightarrow> [] = C \\<or>\n                      [] \\<in> fst `\n                               ({x \\<in> set P.\n                                 case x of\n                                 (D, j) \\<Rightarrow>\n                                   mset D \\<noteq> mset C} \\<union>\n                                set Q)", "by force"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (N', filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q,\n    Suc n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\n\ngoal (1 subgoal):\n 1. \\<And>x P N Q n.\n       \\<lbrakk>\\<And>P N Q n.\n                   \\<lbrakk>x = length (remdups_clss P);\n                    [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n                   \\<Longrightarrow> wstate_of_dstate\n(N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                                     wstate_of_dstate\n([], [], remdups_clss P @ Q, n + length (remdups_clss P));\n        Suc x = length (remdups_clss P); [] \\<in> fst ` set (P @ Q)\\<rbrakk>\n       \\<Longrightarrow> wstate_of_dstate\n                          (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n                         wstate_of_dstate\n                          ([], [], remdups_clss P @ Q,\n                           n + length (remdups_clss P))", "finally"], ["proof (chain)\npicking this:\n  wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [], remdups_clss P @ Q, n + length (remdups_clss P))", "show ?case"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ([], [], remdups_clss P @ Q, n + length (remdups_clss P))", "."], ["proof (state)\nthis:\n  wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [] \\<in> fst ` set (P @ Q) \\<Longrightarrow>\n  wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\n\ngoal (2 subgoals):\n 1. \\<exists>Ci\\<in>set P \\<union> set Q. fst Ci = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q.\n               fst Ci = []) \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "unfolding st step"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n    wstate_of_dstate\n     ([], [], remdups_clss P @ Q, n + length (remdups_clss P))", "using star[OF nil_in'] nonfinal[unfolded st is_final_dstate.simps]"], ["proof (prove)\nusing this:\n  wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [], remdups_clss P @ Q, n + length (remdups_clss P))\n  \\<not> (N = [] \\<and> P = [])\n\ngoal (1 subgoal):\n 1. wstate_of_dstate (N, P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n    wstate_of_dstate\n     ([], [], remdups_clss P @ Q, n + length (remdups_clss P))", "by cases simp_all"], ["proof (state)\nthis:\n  wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q.\n               fst Ci = []) \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q.\n               fst Ci = []) \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "case nil_ni: False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q. fst Ci = [])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q.\n               fst Ci = []) \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[simplified nil_ni, simplified]"], ["proof (state)\nthis:\n  St' =\n  (case N of\n   [] \\<Rightarrow>\n     case P of [] \\<Rightarrow> (N, P, Q, n)\n     | P0 # P' \\<Rightarrow>\n         let (C, i) = select_min_weight_clause P0 P';\n             N = map (\\<lambda>D. (D, n))\n                  (remdups_gen mset\n                    (resolve_rename C C @\n                     concat\n                      (map (resolve_rename_either_way C \\<circ> fst) Q)));\n             P = filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P;\n             Q = (C, i) # Q; n = Suc n\n         in (N, P, Q, n)\n   | (C, i) # N \\<Rightarrow>\n       let C = reduce (map fst (P @ Q)) [] C\n       in if C = [] then ([], [], [([], i)], Suc n)\n          else if is_tautology C \\<or> subsume (map fst (P @ Q)) C\n               then (N, P, Q, n)\n               else let P = reduce_all C P;\n                        (back_to_P, Q) = reduce_all2 C Q; P = back_to_P @ P;\n                        Q = filter\n                             (Not \\<circ> strictly_subsume [C] \\<circ> fst)\n                             Q;\n                        P = filter\n                             (Not \\<circ> strictly_subsume [C] \\<circ> fst)\n                             P;\n                        P = (C, i) # P\n                    in (N, P, Q, n))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q.\n               fst Ci = []) \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "proof (cases N)"], ["proof (state)\ngoal (2 subgoals):\n 1. N = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "case n_nil: Nil"], ["proof (state)\nthis:\n  N = []\n\ngoal (2 subgoals):\n 1. N = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[unfolded n_nil, simplified]"], ["proof (state)\nthis:\n  St' =\n  (case P of [] \\<Rightarrow> ([], P, Q, n)\n   | P0 # P' \\<Rightarrow>\n       let (C, i) = select_min_weight_clause P0 P';\n           N = map (\\<lambda>D. (D, n))\n                (remdups_gen mset\n                  (resolve_rename C C @\n                   concat\n                    (map (resolve_rename_either_way C \\<circ> fst) Q)));\n           P = filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P;\n           Q = (C, i) # Q; n = Suc n\n       in (N, P, Q, n))\n\ngoal (2 subgoals):\n 1. N = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "proof (cases P)"], ["proof (state)\ngoal (2 subgoals):\n 1. P = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<And>a list.\n       P = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "case Nil"], ["proof (state)\nthis:\n  P = []\n\ngoal (2 subgoals):\n 1. P = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<And>a list.\n       P = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "then"], ["proof (chain)\npicking this:\n  P = []", "have False"], ["proof (prove)\nusing this:\n  P = []\n\ngoal (1 subgoal):\n 1. False", "using n_nil nonfinal[unfolded st]"], ["proof (prove)\nusing this:\n  P = []\n  N = []\n  \\<not> is_final_dstate (N, P, Q, n)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: is_final_dstate.simps)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. P = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<And>a list.\n       P = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "using step"], ["proof (prove)\nusing this:\n  False\n  St' =\n  (case P of [] \\<Rightarrow> ([], P, Q, n)\n   | P0 # P' \\<Rightarrow>\n       let (C, i) = select_min_weight_clause P0 P';\n           N = map (\\<lambda>D. (D, n))\n                (remdups_gen mset\n                  (resolve_rename C C @\n                   concat\n                    (map (resolve_rename_either_way C \\<circ> fst) Q)));\n           P = filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P;\n           Q = (C, i) # Q; n = Suc n\n       in (N, P, Q, n))\n\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "by simp"], ["proof (state)\nthis:\n  wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       P = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       P = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "case p_cons: (Cons P0 P')"], ["proof (state)\nthis:\n  P = P0 # P'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       P = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[unfolded p_cons list.case, folded p_cons]"], ["proof (state)\nthis:\n  St' =\n  (let (C, i) = select_min_weight_clause P0 P';\n       N = map (\\<lambda>D. (D, n))\n            (remdups_gen mset\n              (resolve_rename C C @\n               concat (map (resolve_rename_either_way C \\<circ> fst) Q)));\n       P = filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P;\n       Q = (C, i) # Q; n = Suc n\n   in (N, P, Q, n))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       P = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "obtain C :: \"'a lclause\" and i :: nat where\n          ci: \"(C, i) = select_min_weight_clause P0 P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C i.\n        (C, i) = select_min_weight_clause P0 P' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  (C, i) = select_min_weight_clause P0 P'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       P = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[unfolded select, simplified]"], ["proof (state)\nthis:\n  St' =\n  (case select_min_weight_clause P0 P' of\n   (C, i) \\<Rightarrow>\n     (map (\\<lambda>D. (D, n))\n       (remdups_gen mset\n         (resolve_rename C C @\n          concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n      filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q,\n      Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       P = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have ci_in: \"(C, i) \\<in> set P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C, i) \\<in> set P", "by (rule select_min_weight_clause_in[of P0 P', folded ci p_cons])"], ["proof (state)\nthis:\n  (C, i) \\<in> set P\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       P = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "unfolding st n_nil step p_cons[symmetric] ci[symmetric] prod.case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ([], P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n    wstate_of_dstate\n     (map (\\<lambda>D. (D, n))\n       (remdups_gen mset\n         (resolve_rename C C @\n          concat (map (resolve_rename_either_way C \\<circ> fst) Q))),\n      filter (\\<lambda>(D, j). mset D \\<noteq> mset C) P, (C, i) # Q, Suc n)", "by (rule tranclp.r_into_trancl, rule compute_inferences[OF ci_in])\n            (simp add: select_min_weight_clause_min_weight[OF ci, simplified] p_cons)"], ["proof (state)\nthis:\n  wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "case n_cons: (Cons Ci N')"], ["proof (state)\nthis:\n  N = Ci # N'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[unfolded n_cons, simplified]"], ["proof (state)\nthis:\n  St' =\n  (case Ci of\n   (C, i) \\<Rightarrow>\n     let C = reduce (map fst P @ map fst Q) [] C\n     in if C = [] then ([], [], [([], i)], Suc n)\n        else if is_tautology C \\<or> subsume (map fst (P @ Q)) C\n             then (N', P, Q, n)\n             else let P = reduce_all C P; (back_to_P, Q) = reduce_all2 C Q;\n                      P = back_to_P @ P;\n                      Q = filter\n                           (Not \\<circ> strictly_subsume [C] \\<circ> fst) Q;\n                      P = filter\n                           (Not \\<circ> strictly_subsume [C] \\<circ> fst) P;\n                      P = (C, i) # P\n                  in (N', P, Q, n))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "obtain C :: \"'a lclause\" and i :: nat where\n        ci: \"Ci = (C, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C i. Ci = (C, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases Ci) simp"], ["proof (state)\nthis:\n  Ci = (C, i)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[unfolded ci, simplified]"], ["proof (state)\nthis:\n  St' =\n  (let C = reduce (map fst P @ map fst Q) [] C\n   in if C = [] then ([], [], [([], i)], Suc n)\n      else if is_tautology C \\<or> subsume (map fst (P @ Q)) C\n           then (N', P, Q, n)\n           else let P = reduce_all C P; (back_to_P, Q) = reduce_all2 C Q;\n                    P = back_to_P @ P;\n                    Q = filter\n                         (Not \\<circ> strictly_subsume [C] \\<circ> fst) Q;\n                    P = filter\n                         (Not \\<circ> strictly_subsume [C] \\<circ> fst) P;\n                    P = (C, i) # P\n                in (N', P, Q, n))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "define C' :: \"'a lclause\" where\n        \"C' = reduce (map fst P @ map fst Q) [] C\""], ["proof (state)\nthis:\n  C' = reduce (map fst P @ map fst Q) [] C\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[unfolded ci C'_def[symmetric], simplified]"], ["proof (state)\nthis:\n  St' =\n  (if C' = [] then ([], [], [([], i)], Suc n)\n   else if is_tautology C' \\<or> subsume (map fst (P @ Q)) C'\n        then (N', P, Q, n)\n        else let P = reduce_all C' P; (back_to_P, Q) = reduce_all2 C' Q;\n                 P = back_to_P @ P;\n                 Q = filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst)\n                      Q;\n                 P = filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst)\n                      P;\n                 P = (C', i) # P\n             in (N', P, Q, n))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have \"wstate_of_dstate ((E @ C, i) # N', P, Q, n)\n           \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ((E @ reduce (map fst P @ map fst Q) E C, i) # N', P, Q, n)\" for E"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ((E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E C, i) # N', P, Q, n)", "unfolding C'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ((E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E C, i) # N', P, Q, n)", "proof (induct C arbitrary: E)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>E.\n       wstate_of_dstate\n        ((E @ [], i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        ((E @ reduce (map fst P @ map fst Q) E [], i) # N', P, Q, n)\n 2. \\<And>a C E.\n       (\\<And>E.\n           wstate_of_dstate\n            ((E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n           wstate_of_dstate\n            ((E @ reduce (map fst P @ map fst Q) E C, i) # N', P, Q,\n             n)) \\<Longrightarrow>\n       wstate_of_dstate\n        ((E @ a # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        ((E @ reduce (map fst P @ map fst Q) E (a # C), i) # N', P, Q, n)", "case (Cons L C)"], ["proof (state)\nthis:\n  wstate_of_dstate ((?E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   ((?E @ reduce (map fst P @ map fst Q) ?E C, i) # N', P, Q, n)\n\ngoal (2 subgoals):\n 1. \\<And>E.\n       wstate_of_dstate\n        ((E @ [], i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        ((E @ reduce (map fst P @ map fst Q) E [], i) # N', P, Q, n)\n 2. \\<And>a C E.\n       (\\<And>E.\n           wstate_of_dstate\n            ((E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n           wstate_of_dstate\n            ((E @ reduce (map fst P @ map fst Q) E C, i) # N', P, Q,\n             n)) \\<Longrightarrow>\n       wstate_of_dstate\n        ((E @ a # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        ((E @ reduce (map fst P @ map fst Q) E (a # C), i) # N', P, Q, n)", "note ih = this(1)"], ["proof (state)\nthis:\n  wstate_of_dstate ((?E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   ((?E @ reduce (map fst P @ map fst Q) ?E C, i) # N', P, Q, n)\n\ngoal (2 subgoals):\n 1. \\<And>E.\n       wstate_of_dstate\n        ((E @ [], i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        ((E @ reduce (map fst P @ map fst Q) E [], i) # N', P, Q, n)\n 2. \\<And>a C E.\n       (\\<And>E.\n           wstate_of_dstate\n            ((E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n           wstate_of_dstate\n            ((E @ reduce (map fst P @ map fst Q) E C, i) # N', P, Q,\n             n)) \\<Longrightarrow>\n       wstate_of_dstate\n        ((E @ a # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        ((E @ reduce (map fst P @ map fst Q) E (a # C), i) # N', P, Q, n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "proof (cases \"is_reducible_lit (map fst P @ map fst Q) (E @ C) L\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_reducible_lit (map fst P @ map fst Q) (E @ C) L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)\n 2. \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C)\n            L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "case l_red: True"], ["proof (state)\nthis:\n  is_reducible_lit (map fst P @ map fst Q) (E @ C) L\n\ngoal (2 subgoals):\n 1. is_reducible_lit (map fst P @ map fst Q) (E @ C) L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)\n 2. \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C)\n            L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "then"], ["proof (chain)\npicking this:\n  is_reducible_lit (map fst P @ map fst Q) (E @ C) L", "have red_lc:\n            \"reduce (map fst P @ map fst Q) E (L # C) = reduce (map fst P @ map fst Q) E C\""], ["proof (prove)\nusing this:\n  is_reducible_lit (map fst P @ map fst Q) (E @ C) L\n\ngoal (1 subgoal):\n 1. reduce (map fst P @ map fst Q) E (L # C) =\n    reduce (map fst P @ map fst Q) E C", "by simp"], ["proof (state)\nthis:\n  reduce (map fst P @ map fst Q) E (L # C) =\n  reduce (map fst P @ map fst Q) E C\n\ngoal (2 subgoals):\n 1. is_reducible_lit (map fst P @ map fst Q) (E @ C) L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)\n 2. \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C)\n            L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "obtain D D' :: \"'a literal list\" and L' :: \"'a literal\" and \\<sigma> :: 's where\n            \"D \\<in> set (map fst P @ map fst Q)\" and\n            \"D' = remove1 L' D\" and\n            \"L' \\<in> set D\" and\n            \"- L = L' \\<cdot>l \\<sigma>\" and\n            \"mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D D' L' \\<sigma>.\n        \\<lbrakk>D \\<in> set (map fst P @ map fst Q); D' = remove1 L' D;\n         L' \\<in> set D; - L = L' \\<cdot>l \\<sigma>;\n         mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using l_red"], ["proof (prove)\nusing this:\n  is_reducible_lit (map fst P @ map fst Q) (E @ C) L\n\ngoal (1 subgoal):\n 1. (\\<And>D D' L' \\<sigma>.\n        \\<lbrakk>D \\<in> set (map fst P @ map fst Q); D' = remove1 L' D;\n         L' \\<in> set D; - L = L' \\<cdot>l \\<sigma>;\n         mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_reducible_lit_def comp_def"], ["proof (prove)\nusing this:\n  \\<exists>D\\<in>set (map fst P @ map fst Q).\n     \\<exists>L'\\<in>set D.\n        \\<exists>\\<sigma>.\n           - L = L' \\<cdot>l \\<sigma> \\<and>\n           mset (remove1 L' D) \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)\n\ngoal (1 subgoal):\n 1. (\\<And>D D' L' \\<sigma>.\n        \\<lbrakk>D \\<in> set (map fst P @ map fst Q); D' = remove1 L' D;\n         L' \\<in> set D; - L = L' \\<cdot>l \\<sigma>;\n         mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D \\<in> set (map fst P @ map fst Q)\n  D' = remove1 L' D\n  L' \\<in> set D\n  - L = L' \\<cdot>l \\<sigma>\n  mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)\n\ngoal (2 subgoals):\n 1. is_reducible_lit (map fst P @ map fst Q) (E @ C) L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)\n 2. \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C)\n            L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "then"], ["proof (chain)\npicking this:\n  D \\<in> set (map fst P @ map fst Q)\n  D' = remove1 L' D\n  L' \\<in> set D\n  - L = L' \\<cdot>l \\<sigma>\n  mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)", "have \\<sigma>:\n            \"mset D' + {#L'#} \\<in> set (map (mset \\<circ> fst) (P @ Q))\"\n            \"- L = L' \\<cdot>l \\<sigma> \\<and> mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)\""], ["proof (prove)\nusing this:\n  D \\<in> set (map fst P @ map fst Q)\n  D' = remove1 L' D\n  L' \\<in> set D\n  - L = L' \\<cdot>l \\<sigma>\n  mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)\n\ngoal (1 subgoal):\n 1. mset D' + {#L'#} \\<in> set (map (mset \\<circ> fst) (P @ Q)) &&&\n    - L = L' \\<cdot>l \\<sigma> \\<and>\n    mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)", "unfolding is_reducible_lit_def"], ["proof (prove)\nusing this:\n  D \\<in> set (map fst P @ map fst Q)\n  D' = remove1 L' D\n  L' \\<in> set D\n  - L = L' \\<cdot>l \\<sigma>\n  mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)\n\ngoal (1 subgoal):\n 1. mset D' + {#L'#} \\<in> set (map (mset \\<circ> fst) (P @ Q)) &&&\n    - L = L' \\<cdot>l \\<sigma> \\<and>\n    mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)", "by (auto simp: comp_def)"], ["proof (state)\nthis:\n  mset D' + {#L'#} \\<in> set (map (mset \\<circ> fst) (P @ Q))\n  - L = L' \\<cdot>l \\<sigma> \\<and>\n  mset D' \\<cdot> \\<sigma> \\<subseteq># mset (E @ C)\n\ngoal (2 subgoals):\n 1. is_reducible_lit (map fst P @ map fst Q) (E @ C) L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)\n 2. \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C)\n            L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "have \"wstate_of_dstate ((E @ L # C, i) # N', P, Q, n)\n              \\<leadsto>\\<^sub>w wstate_of_dstate ((E @ C, i) # N', P, Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate ((E @ C, i) # N', P, Q, n)", "by (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w)\", OF _ _\n                  wrp.forward_reduction[of \"mset D'\" L' \"mset (map (apfst mset) P)\"\n                    \"mset (map (apfst mset) Q)\" L \\<sigma> \"mset (E @ C)\" \"mset (map (apfst mset) N')\"\n                    i n]])\n              (use \\<sigma> in \\<open>auto simp: comp_def\\<close>)"], ["proof (state)\nthis:\n  wstate_of_dstate ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate ((E @ C, i) # N', P, Q, n)\n\ngoal (2 subgoals):\n 1. is_reducible_lit (map fst P @ map fst Q) (E @ C) L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)\n 2. \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C)\n            L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "then"], ["proof (chain)\npicking this:\n  wstate_of_dstate ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate ((E @ C, i) # N', P, Q, n)", "show ?thesis"], ["proof (prove)\nusing this:\n  wstate_of_dstate ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate ((E @ C, i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "unfolding red_lc"], ["proof (prove)\nusing this:\n  wstate_of_dstate ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate ((E @ C, i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E C, i) # N', P, Q, n)", "using ih[of E]"], ["proof (prove)\nusing this:\n  wstate_of_dstate ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate ((E @ C, i) # N', P, Q, n)\n  wstate_of_dstate ((E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   ((E @ reduce (map fst P @ map fst Q) E C, i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E C, i) # N', P, Q, n)", "by (rule converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  wstate_of_dstate ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C)\n            L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C)\n            L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "case False"], ["proof (state)\nthis:\n  \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C) L\n\ngoal (1 subgoal):\n 1. \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C)\n            L \\<Longrightarrow>\n    wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C) L", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C) L\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "using ih[of \"L # E\"]"], ["proof (prove)\nusing this:\n  \\<not> is_reducible_lit (map fst P @ map fst Q) (E @ C) L\n  wstate_of_dstate\n   (((L # E) @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   (((L # E) @ reduce (map fst P @ map fst Q) (L # E) C, i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)", "by simp"], ["proof (state)\nthis:\n  wstate_of_dstate ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wstate_of_dstate ((E @ L # C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   ((E @ reduce (map fst P @ map fst Q) E (L # C), i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. \\<And>E.\n       wstate_of_dstate\n        ((E @ [], i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n       wstate_of_dstate\n        ((E @ reduce (map fst P @ map fst Q) E [], i) # N', P, Q, n)", "qed simp"], ["proof (state)\nthis:\n  wstate_of_dstate ((?E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   ((?E @ reduce (map fst P @ map fst Q) ?E C, i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "then"], ["proof (chain)\npicking this:\n  wstate_of_dstate ((?E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   ((?E @ reduce (map fst P @ map fst Q) ?E C, i) # N', P, Q, n)", "have red_C:\n        \"wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ((C', i) # N', P, Q, n)\""], ["proof (prove)\nusing this:\n  wstate_of_dstate ((?E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   ((?E @ reduce (map fst P @ map fst Q) ?E C, i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ((C', i) # N', P, Q, n)", "unfolding C'_def"], ["proof (prove)\nusing this:\n  wstate_of_dstate ((?E @ C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate\n   ((?E @ reduce (map fst P @ map fst Q) ?E C, i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((reduce (map fst P @ map fst Q) [] C, i) # N', P, Q, n)", "by (metis self_append_conv2)"], ["proof (state)\nthis:\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have proc_C: \"wstate_of_dstate ((C', i) # N', P', Q', n')\n          \\<leadsto>\\<^sub>w wstate_of_dstate (N', (C', i) # P', Q', n')\" for P' Q' n'"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C', i) # N', P', Q', n') \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', (C', i) # P', Q', n')", "by (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w)\", OF _ _\n              wrp.clause_processing[of \"mset (map (apfst mset) N')\" \"mset C'\" i\n                \"mset (map (apfst mset) P')\" \"mset (map (apfst mset) Q')\" n']],\n            simp+)"], ["proof (state)\nthis:\n  wstate_of_dstate ((C', i) # N', ?P', ?Q', ?n') \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N', (C', i) # ?P', ?Q', ?n')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       N = a # list \\<Longrightarrow>\n       wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "proof (cases \"C' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "case True"], ["proof (state)\nthis:\n  C' = []\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note c'_nil = this"], ["proof (state)\nthis:\n  C' = []\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[simplified c'_nil, simplified]"], ["proof (state)\nthis:\n  St' = ([], [], [([], i)], Suc n)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have\n          filter_p: \"filter (Not \\<circ> strictly_subsume [[]] \\<circ> fst) P = []\" and\n          filter_q: \"filter (Not \\<circ> strictly_subsume [[]] \\<circ> fst) Q = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (Not \\<circ> strictly_subsume [[]] \\<circ> fst) P = [] &&&\n    filter (Not \\<circ> strictly_subsume [[]] \\<circ> fst) Q = []", "using nil_ni"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q. fst Ci = [])\n\ngoal (1 subgoal):\n 1. filter (Not \\<circ> strictly_subsume [[]] \\<circ> fst) P = [] &&&\n    filter (Not \\<circ> strictly_subsume [[]] \\<circ> fst) Q = []", "unfolding strictly_subsume_def filter_empty_conv find_None_iff"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>Ci\\<in>set P \\<union> set Q. fst Ci = [])\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set P.\n       \\<not> (Not \\<circ>\n               (\\<lambda>C.\n                   \\<exists>D\\<in>set [[]].\n                      strictly_subsumes (mset D) (mset C)) \\<circ>\n               fst)\n               x &&&\n    \\<forall>x\\<in>set Q.\n       \\<not> (Not \\<circ>\n               (\\<lambda>C.\n                   \\<exists>D\\<in>set [[]].\n                      strictly_subsumes (mset D) (mset C)) \\<circ>\n               fst)\n               x", "by force+"], ["proof (state)\nthis:\n  filter (Not \\<circ> strictly_subsume [[]] \\<circ> fst) P = []\n  filter (Not \\<circ> strictly_subsume [[]] \\<circ> fst) Q = []\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note red_C[unfolded c'_nil]"], ["proof (state)\nthis:\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (([], i) # N', P, Q, n)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "also"], ["proof (state)\nthis:\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (([], i) # N', P, Q, n)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have \"wstate_of_dstate (([], i) # N', P, Q, n)\n            \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (([], i) # N', [], Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (([], i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (([], i) # N', [], Q, n)", "by (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w\\<^sup>*)\", OF _ _\n                remove_strictly_subsumed_clauses_in_P[of \"[]\" _ \"[]\", unfolded append_Nil],\n                OF refl])\n            (auto simp: filter_p)"], ["proof (state)\nthis:\n  wstate_of_dstate (([], i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (([], i) # N', [], Q, n)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "also"], ["proof (state)\nthis:\n  wstate_of_dstate (([], i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (([], i) # N', [], Q, n)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have \"\\<dots> \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (([], i) # N', [], [], n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (([], i) # N', [], Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (([], i) # N', [], [], n)", "by (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w\\<^sup>*)\", OF _ _\n                remove_strictly_subsumed_clauses_in_Q[of \"[]\" _ _ \"[]\", unfolded append_Nil],\n                OF refl])\n            (auto simp: filter_q)"], ["proof (state)\nthis:\n  wstate_of_dstate (([], i) # N', [], Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (([], i) # N', [], [], n)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "also"], ["proof (state)\nthis:\n  wstate_of_dstate (([], i) # N', [], Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (([], i) # N', [], [], n)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note proc_C[unfolded c'_nil, THEN tranclp.r_into_trancl[of \"(\\<leadsto>\\<^sub>w)\"]]"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (([], i) # N', ?P'1, ?Q'1, ?n'1) \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate (N', ([], i) # ?P'1, ?Q'1, ?n'1)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "also"], ["proof (state)\nthis:\n  wstate_of_dstate\n   (([], i) # N', ?P'1, ?Q'1, ?n'1) \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate (N', ([], i) # ?P'1, ?Q'1, ?n'1)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have \"wstate_of_dstate (N', [([], i)], [], n)\n            \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ([], [([], i)], [], n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate (N', [([], i)], [], n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ([], [([], i)], [], n)", "by (rule empty_N_if_Nil_in_P_or_Q) simp"], ["proof (state)\nthis:\n  wstate_of_dstate (N', [([], i)], [], n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [([], i)], [], n)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "also"], ["proof (state)\nthis:\n  wstate_of_dstate (N', [([], i)], [], n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ([], [([], i)], [], n)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have \"\\<dots> \\<leadsto>\\<^sub>w wstate_of_dstate ([], [], [([], i)], Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ([], [([], i)], [], n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate ([], [], [([], i)], Suc n)", "by (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w)\", OF _ _\n                wrp.inference_computation[of \"{#}\" \"{#}\" i \"{#}\" n \"{#}\"]])\n            (auto simp: ord_FO_resolution_inferences_between_empty_empty)"], ["proof (state)\nthis:\n  wstate_of_dstate ([], [([], i)], [], n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate ([], [], [([], i)], Suc n)\n\ngoal (2 subgoals):\n 1. C' = [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "finally"], ["proof (chain)\npicking this:\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate ([], [], [([], i)], Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate ([], [], [([], i)], Suc n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "unfolding step st n_cons ci"], ["proof (prove)\nusing this:\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate ([], [], [([], i)], Suc n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n    wstate_of_dstate ([], [], [([], i)], Suc n)", "."], ["proof (state)\nthis:\n  wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n\ngoal (1 subgoal):\n 1. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "case c'_nnil: False"], ["proof (state)\nthis:\n  C' \\<noteq> []\n\ngoal (1 subgoal):\n 1. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[simplified c'_nnil, simplified]"], ["proof (state)\nthis:\n  St' =\n  (if is_tautology C' \\<or> subsume (map fst P @ map fst Q) C'\n   then (N', P, Q, n)\n   else let P = reduce_all C' P; (back_to_P, Q) = reduce_all2 C' Q;\n            P = back_to_P @ P;\n            Q = filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) Q;\n            P = filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) P;\n            P = (C', i) # P\n        in (N', P, Q, n))\n\ngoal (1 subgoal):\n 1. C' \\<noteq> [] \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "proof (cases \"is_tautology C' \\<or> subsume (map fst P @ map fst Q) C'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_tautology C' \\<or>\n    subsume (map fst P @ map fst Q) C' \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "case taut_or_subs: True"], ["proof (state)\nthis:\n  is_tautology C' \\<or> subsume (map fst P @ map fst Q) C'\n\ngoal (2 subgoals):\n 1. is_tautology C' \\<or>\n    subsume (map fst P @ map fst Q) C' \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[simplified taut_or_subs, simplified]"], ["proof (state)\nthis:\n  St' = (N', P, Q, n)\n\ngoal (2 subgoals):\n 1. is_tautology C' \\<or>\n    subsume (map fst P @ map fst Q) C' \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have \"wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w wstate_of_dstate (N', P, Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)", "proof (cases \"is_tautology C'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_tautology C' \\<Longrightarrow>\n    wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)\n 2. \\<not> is_tautology C' \\<Longrightarrow>\n    wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)", "case True"], ["proof (state)\nthis:\n  is_tautology C'\n\ngoal (2 subgoals):\n 1. is_tautology C' \\<Longrightarrow>\n    wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)\n 2. \\<not> is_tautology C' \\<Longrightarrow>\n    wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)", "then"], ["proof (chain)\npicking this:\n  is_tautology C'", "obtain A :: 'a where\n              neg_a: \"Neg A \\<in> set C'\" and pos_a: \"Pos A \\<in> set C'\""], ["proof (prove)\nusing this:\n  is_tautology C'\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>Neg A \\<in> set C'; Pos A \\<in> set C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_tautology_def"], ["proof (prove)\nusing this:\n  \\<exists>A\\<in>set (map atm_of C').\n     Pos A \\<in> set C' \\<and> Neg A \\<in> set C'\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>Neg A \\<in> set C'; Pos A \\<in> set C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Neg A \\<in> set C'\n  Pos A \\<in> set C'\n\ngoal (2 subgoals):\n 1. is_tautology C' \\<Longrightarrow>\n    wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)\n 2. \\<not> is_tautology C' \\<Longrightarrow>\n    wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)", "by (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w)\", OF _ _\n                    wrp.tautology_deletion[of A \"mset C'\" \"mset (map (apfst mset) N')\" i\n                      \"mset (map (apfst mset) P)\" \"mset (map (apfst mset) Q)\" n]])\n                (use neg_a pos_a in simp_all)"], ["proof (state)\nthis:\n  wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N', P, Q, n)\n\ngoal (1 subgoal):\n 1. \\<not> is_tautology C' \\<Longrightarrow>\n    wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_tautology C' \\<Longrightarrow>\n    wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)", "case False"], ["proof (state)\nthis:\n  \\<not> is_tautology C'\n\ngoal (1 subgoal):\n 1. \\<not> is_tautology C' \\<Longrightarrow>\n    wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_tautology C'", "have \"subsume (map fst P @ map fst Q) C'\""], ["proof (prove)\nusing this:\n  \\<not> is_tautology C'\n\ngoal (1 subgoal):\n 1. subsume (map fst P @ map fst Q) C'", "using taut_or_subs"], ["proof (prove)\nusing this:\n  \\<not> is_tautology C'\n  is_tautology C' \\<or> subsume (map fst P @ map fst Q) C'\n\ngoal (1 subgoal):\n 1. subsume (map fst P @ map fst Q) C'", "by blast"], ["proof (state)\nthis:\n  subsume (map fst P @ map fst Q) C'\n\ngoal (1 subgoal):\n 1. \\<not> is_tautology C' \\<Longrightarrow>\n    wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)", "then"], ["proof (chain)\npicking this:\n  subsume (map fst P @ map fst Q) C'", "obtain D :: \"'a lclause\" where\n              d_in: \"D \\<in> set (map fst P @ map fst Q)\" and\n              subs: \"subsumes (mset D) (mset C')\""], ["proof (prove)\nusing this:\n  subsume (map fst P @ map fst Q) C'\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> set (map fst P @ map fst Q);\n         subsumes (mset D) (mset C')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding subsume_def"], ["proof (prove)\nusing this:\n  \\<exists>D\\<in>set (map fst P @ map fst Q). subsumes (mset D) (mset C')\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> set (map fst P @ map fst Q);\n         subsumes (mset D) (mset C')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D \\<in> set (map fst P @ map fst Q)\n  subsumes (mset D) (mset C')\n\ngoal (1 subgoal):\n 1. \\<not> is_tautology C' \\<Longrightarrow>\n    wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n    wstate_of_dstate (N', P, Q, n)", "by (rule arg_cong2[THEN iffD1, of _ _ _ _ \"(\\<leadsto>\\<^sub>w)\", OF _ _\n                    wrp.forward_subsumption[of \"mset D\" \"mset (map (apfst mset) P)\"\n                      \"mset (map (apfst mset) Q)\" \"mset C'\" \"mset (map (apfst mset) N')\" i n]],\n                  use d_in subs in \\<open>auto simp: subsume_def\\<close>)"], ["proof (state)\nthis:\n  wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N', P, Q, n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N', P, Q, n)\n\ngoal (2 subgoals):\n 1. is_tautology C' \\<or>\n    subsume (map fst P @ map fst Q) C' \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n 2. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "then"], ["proof (chain)\npicking this:\n  wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N', P, Q, n)", "show ?thesis"], ["proof (prove)\nusing this:\n  wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N', P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "unfolding step st n_cons ci"], ["proof (prove)\nusing this:\n  wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N', P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n    wstate_of_dstate (N', P, Q, n)", "using red_C"], ["proof (prove)\nusing this:\n  wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\n  wstate_of_dstate (N', P, Q, n)\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n    wstate_of_dstate (N', P, Q, n)", "by (rule rtranclp_into_tranclp1[rotated])"], ["proof (state)\nthis:\n  wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "case not_taut_or_subs: False"], ["proof (state)\nthis:\n  \\<not> (is_tautology C' \\<or> subsume (map fst P @ map fst Q) C')\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[simplified not_taut_or_subs, simplified]"], ["proof (state)\nthis:\n  St' =\n  (case reduce_all2 C' Q of\n   (back_to_P, Q) \\<Rightarrow>\n     (N',\n      (C', i) #\n      filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) back_to_P @\n      filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst)\n       (reduce_all C' P),\n      filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) Q, n))\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "define P' :: \"('a literal list \\<times> nat) list\" where\n            \"P' = reduce_all C' P\""], ["proof (state)\nthis:\n  P' = reduce_all C' P\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "obtain back_to_P Q' :: \"'a dclause list\" where\n            red_Q: \"(back_to_P, Q') = reduce_all2 C' Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>back_to_P Q'.\n        (back_to_P, Q') = reduce_all2 C' Q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  (back_to_P, Q') = reduce_all2 C' Q\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[unfolded red_Q[symmetric], simplified]"], ["proof (state)\nthis:\n  St' =\n  (N',\n   (C', i) #\n   filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) back_to_P @\n   filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) (reduce_all C' P),\n   filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) Q', n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "define Q'' :: \"('a literal list \\<times> nat) list\" where\n            \"Q'' = filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) Q'\""], ["proof (state)\nthis:\n  Q'' = filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) Q'\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "define P'' :: \"('a literal list \\<times> nat) list\" where\n            \"P'' = filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) (back_to_P @ P')\""], ["proof (state)\nthis:\n  P'' =\n  filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) (back_to_P @ P')\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note step = step[unfolded P'_def[symmetric] Q''_def[symmetric] P''_def[symmetric],\n              simplified]"], ["proof (state)\nthis:\n  St' =\n  (N',\n   (C', i) #\n   filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) back_to_P @\n   filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) P',\n   Q'', n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note red_C"], ["proof (state)\nthis:\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "also"], ["proof (state)\nthis:\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', P, Q, n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have \"wstate_of_dstate ((C', i) # N', P, Q, n)\n              \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ((C', i) # N', P', Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ((C', i) # N', P', Q, n)", "unfolding P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ((C', i) # N', reduce_all C' P, Q, n)", "by (rule reduce_clauses_in_P[of _ _ \"[]\", unfolded append_Nil]) simp+"], ["proof (state)\nthis:\n  wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', P', Q, n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "also"], ["proof (state)\nthis:\n  wstate_of_dstate ((C', i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', P', Q, n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have \"\\<dots> \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ((C', i) # N', back_to_P @ P', Q', n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C', i) # N', P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ((C', i) # N', back_to_P @ P', Q', n)", "unfolding P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     ((C', i) # N', reduce_all C' P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ((C', i) # N', back_to_P @ reduce_all C' P, Q', n)", "by (rule reduce_clauses_in_Q[of C' _ _ \"[]\" Q, folded red_Q,\n                  unfolded append_Nil prod.sel])\n              (auto intro: reduce_idem simp: reduce_all_def)"], ["proof (state)\nthis:\n  wstate_of_dstate ((C', i) # N', P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', back_to_P @ P', Q', n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "also"], ["proof (state)\nthis:\n  wstate_of_dstate ((C', i) # N', P', Q, n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', back_to_P @ P', Q', n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have \"\\<dots> \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ((C', i) # N', back_to_P @ P', Q'', n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     ((C', i) # N', back_to_P @ P', Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ((C', i) # N', back_to_P @ P', Q'', n)", "unfolding Q''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     ((C', i) # N', back_to_P @ P', Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((C', i) # N', back_to_P @ P',\n      filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) Q', n)", "by (rule remove_strictly_subsumed_clauses_in_Q[of _ _ _ \"[]\", unfolded append_Nil])\n              simp"], ["proof (state)\nthis:\n  wstate_of_dstate\n   ((C', i) # N', back_to_P @ P', Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', back_to_P @ P', Q'', n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "also"], ["proof (state)\nthis:\n  wstate_of_dstate\n   ((C', i) # N', back_to_P @ P', Q', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', back_to_P @ P', Q'', n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "have \"\\<dots> \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate ((C', i) # N', P'', Q'', n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     ((C', i) # N', back_to_P @ P', Q'', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate ((C', i) # N', P'', Q'', n)", "unfolding P''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate\n     ((C', i) # N', back_to_P @ P', Q'', n) \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate\n     ((C', i) # N',\n      filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst)\n       (back_to_P @ P'),\n      Q'', n)", "by (rule remove_strictly_subsumed_clauses_in_P[of _ _ \"[]\", unfolded append_Nil]) auto"], ["proof (state)\nthis:\n  wstate_of_dstate\n   ((C', i) # N', back_to_P @ P', Q'', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', P'', Q'', n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "also"], ["proof (state)\nthis:\n  wstate_of_dstate\n   ((C', i) # N', back_to_P @ P', Q'', n) \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate ((C', i) # N', P'', Q'', n)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "note proc_C[THEN tranclp.r_into_trancl[of \"(\\<leadsto>\\<^sub>w)\"]]"], ["proof (state)\nthis:\n  wstate_of_dstate\n   ((C', i) # N', ?P'1, ?Q'1, ?n'1) \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate (N', (C', i) # ?P'1, ?Q'1, ?n'1)\n\ngoal (1 subgoal):\n 1. \\<not> (is_tautology C' \\<or>\n            subsume (map fst P @ map fst Q) C') \\<Longrightarrow>\n    wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "finally"], ["proof (chain)\npicking this:\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate (N', (C', i) # P'', Q'', n)", "show ?thesis"], ["proof (prove)\nusing this:\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate (N', (C', i) # P'', Q'', n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'", "unfolding step st n_cons ci P''_def"], ["proof (prove)\nusing this:\n  wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate\n   (N',\n    (C', i) #\n    filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) (back_to_P @ P'),\n    Q'', n)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate ((C, i) # N', P, Q, n) \\<leadsto>\\<^sub>w\\<^sup>+\n    wstate_of_dstate\n     (N',\n      (C', i) #\n      filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) back_to_P @\n      filter (Not \\<circ> strictly_subsume [C'] \\<circ> fst) P',\n      Q'', n)", "by simp"], ["proof (state)\nthis:\n  wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wstate_of_dstate St \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate St'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma final_deterministic_RP_step: \"is_final_dstate St \\<Longrightarrow> deterministic_RP_step St = St\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_final_dstate St \\<Longrightarrow> deterministic_RP_step St = St", "by (cases St) (auto simp: deterministic_RP_step.simps is_final_dstate.simps)"], ["", "lemma deterministic_RP_SomeD:\n  assumes \"deterministic_RP (N, P, Q, n) = Some R\"\n  shows \"\\<exists>N' P' Q' n'. (\\<exists>k. (deterministic_RP_step ^^ k) (N, P, Q, n) = (N', P', Q', n'))\n    \\<and> is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) (N, P, Q, n) =\n           (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "proof (induct rule: deterministic_RP.raw_induct[OF _ assms])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>deterministic_RP St Sta.\n       \\<lbrakk>\\<And>x y.\n                   deterministic_RP x = Some y \\<Longrightarrow>\n                   \\<exists>N' P' Q' n'.\n                      (\\<exists>k.\n                          (deterministic_RP_step ^^ k) x =\n                          (N', P', Q', n')) \\<and>\n                      is_final_dstate (N', P', Q', n') \\<and>\n                      y = map fst Q';\n        (if is_final_dstate St\n         then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n         else deterministic_RP (deterministic_RP_step St)) =\n        Some Sta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N' P' Q' n'.\n                            (\\<exists>k.\n                                (deterministic_RP_step ^^ k) St =\n                                (N', P', Q', n')) \\<and>\n                            is_final_dstate (N', P', Q', n') \\<and>\n                            Sta = map fst Q'", "case (1 self_call St R)"], ["proof (state)\nthis:\n  self_call ?x = Some ?y \\<Longrightarrow>\n  \\<exists>N' P' Q' n'.\n     (\\<exists>k. (deterministic_RP_step ^^ k) ?x = (N', P', Q', n')) \\<and>\n     is_final_dstate (N', P', Q', n') \\<and> ?y = map fst Q'\n  (if is_final_dstate St\n   then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n   else self_call (deterministic_RP_step St)) =\n  Some R\n\ngoal (1 subgoal):\n 1. \\<And>deterministic_RP St Sta.\n       \\<lbrakk>\\<And>x y.\n                   deterministic_RP x = Some y \\<Longrightarrow>\n                   \\<exists>N' P' Q' n'.\n                      (\\<exists>k.\n                          (deterministic_RP_step ^^ k) x =\n                          (N', P', Q', n')) \\<and>\n                      is_final_dstate (N', P', Q', n') \\<and>\n                      y = map fst Q';\n        (if is_final_dstate St\n         then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n         else deterministic_RP (deterministic_RP_step St)) =\n        Some Sta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N' P' Q' n'.\n                            (\\<exists>k.\n                                (deterministic_RP_step ^^ k) St =\n                                (N', P', Q', n')) \\<and>\n                            is_final_dstate (N', P', Q', n') \\<and>\n                            Sta = map fst Q'", "note ih = this(1) and step = this(2)"], ["proof (state)\nthis:\n  self_call ?x = Some ?y \\<Longrightarrow>\n  \\<exists>N' P' Q' n'.\n     (\\<exists>k. (deterministic_RP_step ^^ k) ?x = (N', P', Q', n')) \\<and>\n     is_final_dstate (N', P', Q', n') \\<and> ?y = map fst Q'\n  (if is_final_dstate St\n   then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n   else self_call (deterministic_RP_step St)) =\n  Some R\n\ngoal (1 subgoal):\n 1. \\<And>deterministic_RP St Sta.\n       \\<lbrakk>\\<And>x y.\n                   deterministic_RP x = Some y \\<Longrightarrow>\n                   \\<exists>N' P' Q' n'.\n                      (\\<exists>k.\n                          (deterministic_RP_step ^^ k) x =\n                          (N', P', Q', n')) \\<and>\n                      is_final_dstate (N', P', Q', n') \\<and>\n                      y = map fst Q';\n        (if is_final_dstate St\n         then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n         else deterministic_RP (deterministic_RP_step St)) =\n        Some Sta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N' P' Q' n'.\n                            (\\<exists>k.\n                                (deterministic_RP_step ^^ k) St =\n                                (N', P', Q', n')) \\<and>\n                            is_final_dstate (N', P', Q', n') \\<and>\n                            Sta = map fst Q'", "obtain N P Q :: \"'a dclause list\" and n :: nat where\n    st: \"St = (N, P, Q, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N P Q n.\n        St = (N, P, Q, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases St) blast"], ["proof (state)\nthis:\n  St = (N, P, Q, n)\n\ngoal (1 subgoal):\n 1. \\<And>deterministic_RP St Sta.\n       \\<lbrakk>\\<And>x y.\n                   deterministic_RP x = Some y \\<Longrightarrow>\n                   \\<exists>N' P' Q' n'.\n                      (\\<exists>k.\n                          (deterministic_RP_step ^^ k) x =\n                          (N', P', Q', n')) \\<and>\n                      is_final_dstate (N', P', Q', n') \\<and>\n                      y = map fst Q';\n        (if is_final_dstate St\n         then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n         else deterministic_RP (deterministic_RP_step St)) =\n        Some Sta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N' P' Q' n'.\n                            (\\<exists>k.\n                                (deterministic_RP_step ^^ k) St =\n                                (N', P', Q', n')) \\<and>\n                            is_final_dstate (N', P', Q', n') \\<and>\n                            Sta = map fst Q'", "note step = step[unfolded st, simplified]"], ["proof (state)\nthis:\n  (if is_final_dstate (N, P, Q, n)\n   then let (uu_, uu_, Q, uu_) = (N, P, Q, n) in Some (map fst Q)\n   else self_call (deterministic_RP_step (N, P, Q, n))) =\n  Some R\n\ngoal (1 subgoal):\n 1. \\<And>deterministic_RP St Sta.\n       \\<lbrakk>\\<And>x y.\n                   deterministic_RP x = Some y \\<Longrightarrow>\n                   \\<exists>N' P' Q' n'.\n                      (\\<exists>k.\n                          (deterministic_RP_step ^^ k) x =\n                          (N', P', Q', n')) \\<and>\n                      is_final_dstate (N', P', Q', n') \\<and>\n                      y = map fst Q';\n        (if is_final_dstate St\n         then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n         else deterministic_RP (deterministic_RP_step St)) =\n        Some Sta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N' P' Q' n'.\n                            (\\<exists>k.\n                                (deterministic_RP_step ^^ k) St =\n                                (N', P', Q', n')) \\<and>\n                            is_final_dstate (N', P', Q', n') \\<and>\n                            Sta = map fst Q'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "proof (cases \"is_final_dstate (N, P, Q, n)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_final_dstate (N, P, Q, n) \\<Longrightarrow>\n    \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'\n 2. \\<not> is_final_dstate (N, P, Q, n) \\<Longrightarrow>\n    \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "case True"], ["proof (state)\nthis:\n  is_final_dstate (N, P, Q, n)\n\ngoal (2 subgoals):\n 1. is_final_dstate (N, P, Q, n) \\<Longrightarrow>\n    \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'\n 2. \\<not> is_final_dstate (N, P, Q, n) \\<Longrightarrow>\n    \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "then"], ["proof (chain)\npicking this:\n  is_final_dstate (N, P, Q, n)", "have \"(deterministic_RP_step ^^ 0) (N, P, Q, n) = (N, P, Q, n)\n      \\<and> is_final_dstate (N, P, Q, n) \\<and> R = map fst Q\""], ["proof (prove)\nusing this:\n  is_final_dstate (N, P, Q, n)\n\ngoal (1 subgoal):\n 1. (deterministic_RP_step ^^ 0) (N, P, Q, n) = (N, P, Q, n) \\<and>\n    is_final_dstate (N, P, Q, n) \\<and> R = map fst Q", "using step"], ["proof (prove)\nusing this:\n  is_final_dstate (N, P, Q, n)\n  (if is_final_dstate (N, P, Q, n)\n   then let (uu_, uu_, Q, uu_) = (N, P, Q, n) in Some (map fst Q)\n   else self_call (deterministic_RP_step (N, P, Q, n))) =\n  Some R\n\ngoal (1 subgoal):\n 1. (deterministic_RP_step ^^ 0) (N, P, Q, n) = (N, P, Q, n) \\<and>\n    is_final_dstate (N, P, Q, n) \\<and> R = map fst Q", "by simp"], ["proof (state)\nthis:\n  (deterministic_RP_step ^^ 0) (N, P, Q, n) = (N, P, Q, n) \\<and>\n  is_final_dstate (N, P, Q, n) \\<and> R = map fst Q\n\ngoal (2 subgoals):\n 1. is_final_dstate (N, P, Q, n) \\<Longrightarrow>\n    \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'\n 2. \\<not> is_final_dstate (N, P, Q, n) \\<Longrightarrow>\n    \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "then"], ["proof (chain)\npicking this:\n  (deterministic_RP_step ^^ 0) (N, P, Q, n) = (N, P, Q, n) \\<and>\n  is_final_dstate (N, P, Q, n) \\<and> R = map fst Q", "show ?thesis"], ["proof (prove)\nusing this:\n  (deterministic_RP_step ^^ 0) (N, P, Q, n) = (N, P, Q, n) \\<and>\n  is_final_dstate (N, P, Q, n) \\<and> R = map fst Q\n\ngoal (1 subgoal):\n 1. \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "unfolding st"], ["proof (prove)\nusing this:\n  (deterministic_RP_step ^^ 0) (N, P, Q, n) = (N, P, Q, n) \\<and>\n  is_final_dstate (N, P, Q, n) \\<and> R = map fst Q\n\ngoal (1 subgoal):\n 1. \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) (N, P, Q, n) =\n           (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "by blast"], ["proof (state)\nthis:\n  \\<exists>N' P' Q' n'.\n     (\\<exists>k. (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n     is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate (N, P, Q, n) \\<Longrightarrow>\n    \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate (N, P, Q, n) \\<Longrightarrow>\n    \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "case nonfinal: False"], ["proof (state)\nthis:\n  \\<not> is_final_dstate (N, P, Q, n)\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate (N, P, Q, n) \\<Longrightarrow>\n    \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "note step = step[simplified nonfinal, simplified]"], ["proof (state)\nthis:\n  self_call (deterministic_RP_step (N, P, Q, n)) = Some R\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate (N, P, Q, n) \\<Longrightarrow>\n    \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "obtain N' P' Q' :: \"'a dclause list\" and n' k :: nat where\n      \"(deterministic_RP_step ^^ k) (deterministic_RP_step (N, P, Q, n)) = (N', P', Q', n')\" and\n      \"is_final_dstate (N', P', Q', n')\"\n      \"R = map fst Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k N' P' Q' n'.\n        \\<lbrakk>(deterministic_RP_step ^^ k)\n                  (deterministic_RP_step (N, P, Q, n)) =\n                 (N', P', Q', n');\n         is_final_dstate (N', P', Q', n'); R = map fst Q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ih[OF step]"], ["proof (prove)\nusing this:\n  \\<exists>N' P' Q' n'.\n     (\\<exists>k.\n         (deterministic_RP_step ^^ k) (deterministic_RP_step (N, P, Q, n)) =\n         (N', P', Q', n')) \\<and>\n     is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'\n\ngoal (1 subgoal):\n 1. (\\<And>k N' P' Q' n'.\n        \\<lbrakk>(deterministic_RP_step ^^ k)\n                  (deterministic_RP_step (N, P, Q, n)) =\n                 (N', P', Q', n');\n         is_final_dstate (N', P', Q', n'); R = map fst Q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (deterministic_RP_step ^^ k) (deterministic_RP_step (N, P, Q, n)) =\n  (N', P', Q', n')\n  is_final_dstate (N', P', Q', n')\n  R = map fst Q'\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate (N, P, Q, n) \\<Longrightarrow>\n    \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "then"], ["proof (chain)\npicking this:\n  (deterministic_RP_step ^^ k) (deterministic_RP_step (N, P, Q, n)) =\n  (N', P', Q', n')\n  is_final_dstate (N', P', Q', n')\n  R = map fst Q'", "show ?thesis"], ["proof (prove)\nusing this:\n  (deterministic_RP_step ^^ k) (deterministic_RP_step (N, P, Q, n)) =\n  (N', P', Q', n')\n  is_final_dstate (N', P', Q', n')\n  R = map fst Q'\n\ngoal (1 subgoal):\n 1. \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "unfolding st funpow_Suc_right[symmetric, THEN fun_cong, unfolded comp_apply]"], ["proof (prove)\nusing this:\n  (deterministic_RP_step ^^ Suc k) (N, P, Q, n) = (N', P', Q', n')\n  is_final_dstate (N', P', Q', n')\n  R = map fst Q'\n\ngoal (1 subgoal):\n 1. \\<exists>N' P' Q' n'.\n       (\\<exists>k.\n           (deterministic_RP_step ^^ k) (N, P, Q, n) =\n           (N', P', Q', n')) \\<and>\n       is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'", "by blast"], ["proof (state)\nthis:\n  \\<exists>N' P' Q' n'.\n     (\\<exists>k. (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n     is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>N' P' Q' n'.\n     (\\<exists>k. (deterministic_RP_step ^^ k) St = (N', P', Q', n')) \\<and>\n     is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes\n    N0 :: \"'a dclause list\" and\n    n0 :: nat and\n    R :: \"'a lclause list\"\nbegin"], ["", "abbreviation St0 :: \"'a dstate\" where\n  \"St0 \\<equiv> (N0, [], [], n0)\""], ["", "abbreviation grounded_N0 where\n  \"grounded_N0 \\<equiv> grounding_of_clss (set (map (mset \\<circ> fst) N0))\""], ["", "abbreviation grounded_R :: \"'a clause set\" where\n  \"grounded_R \\<equiv> grounding_of_clss (set (map mset R))\""], ["", "primcorec derivation_from :: \"'a dstate \\<Rightarrow> 'a dstate llist\" where\n  \"derivation_from St =\n   LCons St (if is_final_dstate St then LNil else derivation_from (deterministic_RP_step St))\""], ["", "abbreviation Sts :: \"'a dstate llist\" where\n  \"Sts \\<equiv> derivation_from St0\""], ["", "abbreviation wSts :: \"'a wstate llist\" where\n  \"wSts \\<equiv> lmap wstate_of_dstate Sts\""], ["", "lemma full_deriv_wSts_trancl_weighted_RP: \"full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) wSts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) wSts", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) wSts", "have \"Sts' = derivation_from St0' \\<Longrightarrow> full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) (lmap wstate_of_dstate Sts')\"\n    for St0' Sts'"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sts' = derivation_from St0' \\<Longrightarrow>\n    full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) (lmap wstate_of_dstate Sts')", "proof (coinduction arbitrary: St0' Sts' rule: full_chain.coinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>St0' Sts'.\n       Sts' = derivation_from St0' \\<Longrightarrow>\n       (\\<exists>x.\n           lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n           (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n       (\\<exists>xs x.\n           lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n           ((\\<exists>St0' Sts'.\n                xs = lmap wstate_of_dstate Sts' \\<and>\n                Sts' = derivation_from St0') \\<or>\n            full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n           x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "case sts': full_chain"], ["proof (state)\nthis:\n  Sts' = derivation_from St0'\n\ngoal (1 subgoal):\n 1. \\<And>St0' Sts'.\n       Sts' = derivation_from St0' \\<Longrightarrow>\n       (\\<exists>x.\n           lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n           (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n       (\\<exists>xs x.\n           lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n           ((\\<exists>St0' Sts'.\n                xs = lmap wstate_of_dstate Sts' \\<and>\n                Sts' = derivation_from St0') \\<or>\n            full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n           x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "proof (cases \"is_final_dstate St0'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)\n 2. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "case True"], ["proof (state)\nthis:\n  is_final_dstate St0'\n\ngoal (2 subgoals):\n 1. is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)\n 2. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "then"], ["proof (chain)\npicking this:\n  is_final_dstate St0'", "have \"ltl (lmap wstate_of_dstate Sts') = LNil\""], ["proof (prove)\nusing this:\n  is_final_dstate St0'\n\ngoal (1 subgoal):\n 1. ltl (lmap wstate_of_dstate Sts') = LNil", "unfolding sts'"], ["proof (prove)\nusing this:\n  is_final_dstate St0'\n\ngoal (1 subgoal):\n 1. ltl (lmap wstate_of_dstate (derivation_from St0')) = LNil", "by simp"], ["proof (state)\nthis:\n  ltl (lmap wstate_of_dstate Sts') = LNil\n\ngoal (2 subgoals):\n 1. is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)\n 2. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "then"], ["proof (chain)\npicking this:\n  ltl (lmap wstate_of_dstate Sts') = LNil", "have \"lmap wstate_of_dstate Sts' = LCons (wstate_of_dstate St0') LNil\""], ["proof (prove)\nusing this:\n  ltl (lmap wstate_of_dstate Sts') = LNil\n\ngoal (1 subgoal):\n 1. lmap wstate_of_dstate Sts' = LCons (wstate_of_dstate St0') LNil", "unfolding sts'"], ["proof (prove)\nusing this:\n  ltl (lmap wstate_of_dstate (derivation_from St0')) = LNil\n\ngoal (1 subgoal):\n 1. lmap wstate_of_dstate (derivation_from St0') =\n    LCons (wstate_of_dstate St0') LNil", "by (subst derivation_from.code, subst (asm) derivation_from.code, auto)"], ["proof (state)\nthis:\n  lmap wstate_of_dstate Sts' = LCons (wstate_of_dstate St0') LNil\n\ngoal (2 subgoals):\n 1. is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)\n 2. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "moreover"], ["proof (state)\nthis:\n  lmap wstate_of_dstate Sts' = LCons (wstate_of_dstate St0') LNil\n\ngoal (2 subgoals):\n 1. is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)\n 2. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "have \"\\<And>St''. \\<not> wstate_of_dstate St0' \\<leadsto>\\<^sub>w St''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>St''. \\<not> wstate_of_dstate St0' \\<leadsto>\\<^sub>w St''", "using True"], ["proof (prove)\nusing this:\n  is_final_dstate St0'\n\ngoal (1 subgoal):\n 1. \\<And>St''. \\<not> wstate_of_dstate St0' \\<leadsto>\\<^sub>w St''", "by (rule is_final_dstate_imp_not_weighted_RP)"], ["proof (state)\nthis:\n  \\<not> wstate_of_dstate St0' \\<leadsto>\\<^sub>w ?St''\n\ngoal (2 subgoals):\n 1. is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)\n 2. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "ultimately"], ["proof (chain)\npicking this:\n  lmap wstate_of_dstate Sts' = LCons (wstate_of_dstate St0') LNil\n  \\<not> wstate_of_dstate St0' \\<leadsto>\\<^sub>w ?St''", "show ?thesis"], ["proof (prove)\nusing this:\n  lmap wstate_of_dstate Sts' = LCons (wstate_of_dstate St0') LNil\n  \\<not> wstate_of_dstate St0' \\<leadsto>\\<^sub>w ?St''\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "by (meson tranclpD)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n      (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n  (\\<exists>xs x.\n      lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n      ((\\<exists>St0' Sts'.\n           xs = lmap wstate_of_dstate Sts' \\<and>\n           Sts' = derivation_from St0') \\<or>\n       full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n      x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "case nfinal: False"], ["proof (state)\nthis:\n  \\<not> is_final_dstate St0'\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "have \"lmap wstate_of_dstate Sts' =\n        LCons (wstate_of_dstate St0') (lmap wstate_of_dstate (ltl Sts'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap wstate_of_dstate Sts' =\n    LCons (wstate_of_dstate St0') (lmap wstate_of_dstate (ltl Sts'))", "unfolding sts'"], ["proof (prove)\ngoal (1 subgoal):\n 1. lmap wstate_of_dstate (derivation_from St0') =\n    LCons (wstate_of_dstate St0')\n     (lmap wstate_of_dstate (ltl (derivation_from St0')))", "by (subst derivation_from.code) simp"], ["proof (state)\nthis:\n  lmap wstate_of_dstate Sts' =\n  LCons (wstate_of_dstate St0') (lmap wstate_of_dstate (ltl Sts'))\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "moreover"], ["proof (state)\nthis:\n  lmap wstate_of_dstate Sts' =\n  LCons (wstate_of_dstate St0') (lmap wstate_of_dstate (ltl Sts'))\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "have \"ltl Sts' = derivation_from (deterministic_RP_step St0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl Sts' = derivation_from (deterministic_RP_step St0')", "unfolding sts'"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (derivation_from St0') =\n    derivation_from (deterministic_RP_step St0')", "using nfinal"], ["proof (prove)\nusing this:\n  \\<not> is_final_dstate St0'\n\ngoal (1 subgoal):\n 1. ltl (derivation_from St0') =\n    derivation_from (deterministic_RP_step St0')", "by (subst derivation_from.code) simp"], ["proof (state)\nthis:\n  ltl Sts' = derivation_from (deterministic_RP_step St0')\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "moreover"], ["proof (state)\nthis:\n  ltl Sts' = derivation_from (deterministic_RP_step St0')\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "have \"wstate_of_dstate St0' \\<leadsto>\\<^sub>w\\<^sup>+ wstate_of_dstate (lhd (ltl Sts'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate St0' \\<leadsto>\\<^sub>w\\<^sup>+\n    wstate_of_dstate (lhd (ltl Sts'))", "unfolding sts'"], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate St0' \\<leadsto>\\<^sub>w\\<^sup>+\n    wstate_of_dstate (lhd (ltl (derivation_from St0')))", "using nonfinal_deterministic_RP_step[OF nfinal refl] nfinal"], ["proof (prove)\nusing this:\n  wstate_of_dstate St0' \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate (deterministic_RP_step St0')\n  \\<not> is_final_dstate St0'\n\ngoal (1 subgoal):\n 1. wstate_of_dstate St0' \\<leadsto>\\<^sub>w\\<^sup>+\n    wstate_of_dstate (lhd (ltl (derivation_from St0')))", "by (subst derivation_from.code) simp"], ["proof (state)\nthis:\n  wstate_of_dstate St0' \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate (lhd (ltl Sts'))\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "ultimately"], ["proof (chain)\npicking this:\n  lmap wstate_of_dstate Sts' =\n  LCons (wstate_of_dstate St0') (lmap wstate_of_dstate (ltl Sts'))\n  ltl Sts' = derivation_from (deterministic_RP_step St0')\n  wstate_of_dstate St0' \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate (lhd (ltl Sts'))", "show ?thesis"], ["proof (prove)\nusing this:\n  lmap wstate_of_dstate Sts' =\n  LCons (wstate_of_dstate St0') (lmap wstate_of_dstate (ltl Sts'))\n  ltl Sts' = derivation_from (deterministic_RP_step St0')\n  wstate_of_dstate St0' \\<leadsto>\\<^sub>w\\<^sup>+\n  wstate_of_dstate (lhd (ltl Sts'))\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n        (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n    (\\<exists>xs x.\n        lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n        ((\\<exists>St0' Sts'.\n             xs = lmap wstate_of_dstate Sts' \\<and>\n             Sts' = derivation_from St0') \\<or>\n         full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n        x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>x.\n      lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n      (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n  (\\<exists>xs x.\n      lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n      ((\\<exists>St0' Sts'.\n           xs = lmap wstate_of_dstate Sts' \\<and>\n           Sts' = derivation_from St0') \\<or>\n       full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n      x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>x.\n      lmap wstate_of_dstate Sts' = LCons x LNil \\<and>\n      (\\<forall>y. \\<not> x \\<leadsto>\\<^sub>w\\<^sup>+ y)) \\<or>\n  (\\<exists>xs x.\n      lmap wstate_of_dstate Sts' = LCons x xs \\<and>\n      ((\\<exists>St0' Sts'.\n           xs = lmap wstate_of_dstate Sts' \\<and>\n           Sts' = derivation_from St0') \\<or>\n       full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) xs) \\<and>\n      x \\<leadsto>\\<^sub>w\\<^sup>+ lhd xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?Sts' = derivation_from ?St0' \\<Longrightarrow>\n  full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) (lmap wstate_of_dstate ?Sts')\n\ngoal (1 subgoal):\n 1. full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) wSts", "then"], ["proof (chain)\npicking this:\n  ?Sts' = derivation_from ?St0' \\<Longrightarrow>\n  full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) (lmap wstate_of_dstate ?Sts')", "show ?thesis"], ["proof (prove)\nusing this:\n  ?Sts' = derivation_from ?St0' \\<Longrightarrow>\n  full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) (lmap wstate_of_dstate ?Sts')\n\ngoal (1 subgoal):\n 1. full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) wSts", "by blast"], ["proof (state)\nthis:\n  full_chain (\\<leadsto>\\<^sub>w\\<^sup>+) wSts\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas deriv_wSts_trancl_weighted_RP = full_chain_imp_chain[OF full_deriv_wSts_trancl_weighted_RP]"], ["", "definition sswSts :: \"'a wstate llist\" where\n  \"sswSts = (SOME wSts'.\n     full_chain (\\<leadsto>\\<^sub>w) wSts' \\<and> emb wSts wSts' \\<and> lhd wSts' = lhd wSts \\<and> llast wSts' = llast wSts)\""], ["", "lemma sswSts:\n  \"full_chain (\\<leadsto>\\<^sub>w) sswSts \\<and> emb wSts sswSts \\<and> lhd sswSts = lhd wSts \\<and> llast sswSts = llast wSts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_chain (\\<leadsto>\\<^sub>w) sswSts \\<and>\n    emb wSts sswSts \\<and>\n    lhd sswSts = lhd wSts \\<and> llast sswSts = llast wSts", "unfolding sswSts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. full_chain (\\<leadsto>\\<^sub>w)\n     (SOME wSts'.\n         full_chain (\\<leadsto>\\<^sub>w) wSts' \\<and>\n         emb wSts wSts' \\<and>\n         lhd wSts' = lhd wSts \\<and> llast wSts' = llast wSts) \\<and>\n    emb wSts\n     (SOME wSts'.\n         full_chain (\\<leadsto>\\<^sub>w) wSts' \\<and>\n         emb wSts wSts' \\<and>\n         lhd wSts' = lhd wSts \\<and> llast wSts' = llast wSts) \\<and>\n    lhd (SOME wSts'.\n            full_chain (\\<leadsto>\\<^sub>w) wSts' \\<and>\n            emb wSts wSts' \\<and>\n            lhd wSts' = lhd wSts \\<and> llast wSts' = llast wSts) =\n    lhd wSts \\<and>\n    llast\n     (SOME wSts'.\n         full_chain (\\<leadsto>\\<^sub>w) wSts' \\<and>\n         emb wSts wSts' \\<and>\n         lhd wSts' = lhd wSts \\<and> llast wSts' = llast wSts) =\n    llast wSts", "by (rule someI_ex[OF full_chain_tranclp_imp_exists_full_chain[OF\n          full_deriv_wSts_trancl_weighted_RP]])"], ["", "lemmas full_deriv_sswSts_weighted_RP = sswSts[THEN conjunct1]"], ["", "lemmas emb_sswSts = sswSts[THEN conjunct2, THEN conjunct1]"], ["", "lemmas lfinite_sswSts_iff = emb_lfinite[OF emb_sswSts]"], ["", "lemmas lhd_sswSts = sswSts[THEN conjunct2, THEN conjunct2, THEN conjunct1]"], ["", "lemmas llast_sswSts = sswSts[THEN conjunct2, THEN conjunct2, THEN conjunct2]"], ["", "lemmas deriv_sswSts_weighted_RP = full_chain_imp_chain[OF full_deriv_sswSts_weighted_RP]"], ["", "lemma not_lnull_sswSts: \"\\<not> lnull sswSts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lnull sswSts", "using deriv_sswSts_weighted_RP"], ["proof (prove)\nusing this:\n  chain (\\<leadsto>\\<^sub>w) sswSts\n\ngoal (1 subgoal):\n 1. \\<not> lnull sswSts", "by (cases rule: chain.cases) auto"], ["", "lemma empty_ssgP0: \"wrp.P_of_wstate (lhd sswSts) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrp.P_of_wstate (lhd sswSts) = {}", "unfolding lhd_sswSts"], ["proof (prove)\ngoal (1 subgoal):\n 1. wrp.P_of_wstate (lhd wSts) = {}", "by (subst derivation_from.code) simp"], ["", "lemma empty_ssgQ0: \"wrp.Q_of_wstate (lhd sswSts) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrp.Q_of_wstate (lhd sswSts) = {}", "unfolding lhd_sswSts"], ["proof (prove)\ngoal (1 subgoal):\n 1. wrp.Q_of_wstate (lhd wSts) = {}", "by (subst derivation_from.code) simp"], ["", "lemmas sswSts_thms = full_deriv_sswSts_weighted_RP empty_ssgP0 empty_ssgQ0"], ["", "abbreviation S_ssgQ :: \"'a clause \\<Rightarrow> 'a clause\" where\n  \"S_ssgQ \\<equiv> wrp.S_gQ sswSts\""], ["", "abbreviation ord_\\<Gamma> :: \"'a inference set\" where\n  \"ord_\\<Gamma> \\<equiv> ground_resolution_with_selection.ord_\\<Gamma> S_ssgQ\""], ["", "abbreviation Rf :: \"'a clause set \\<Rightarrow> 'a clause set\" where\n  \"Rf \\<equiv> standard_redundancy_criterion.Rf\""], ["", "abbreviation Ri :: \"'a clause set \\<Rightarrow> 'a inference set\" where\n  \"Ri \\<equiv> standard_redundancy_criterion.Ri ord_\\<Gamma>\""], ["", "abbreviation saturated_upto :: \"'a clause set \\<Rightarrow> bool\" where\n  \"saturated_upto \\<equiv> redundancy_criterion.saturated_upto ord_\\<Gamma> Rf Ri\""], ["", "context\n  assumes drp_some: \"deterministic_RP St0 = Some R\"\nbegin"], ["", "lemma lfinite_Sts: \"lfinite Sts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite Sts", "proof (induct rule: deterministic_RP.raw_induct[OF _ drp_some])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>deterministic_RP St Sta.\n       \\<lbrakk>\\<And>x y.\n                   deterministic_RP x = Some y \\<Longrightarrow>\n                   lfinite (derivation_from x);\n        (if is_final_dstate St\n         then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n         else deterministic_RP (deterministic_RP_step St)) =\n        Some Sta\\<rbrakk>\n       \\<Longrightarrow> lfinite (derivation_from St)", "case (1 self_call St St')"], ["proof (state)\nthis:\n  self_call ?x = Some ?y \\<Longrightarrow> lfinite (derivation_from ?x)\n  (if is_final_dstate St\n   then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n   else self_call (deterministic_RP_step St)) =\n  Some St'\n\ngoal (1 subgoal):\n 1. \\<And>deterministic_RP St Sta.\n       \\<lbrakk>\\<And>x y.\n                   deterministic_RP x = Some y \\<Longrightarrow>\n                   lfinite (derivation_from x);\n        (if is_final_dstate St\n         then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n         else deterministic_RP (deterministic_RP_step St)) =\n        Some Sta\\<rbrakk>\n       \\<Longrightarrow> lfinite (derivation_from St)", "note ih = this(1) and step = this(2)"], ["proof (state)\nthis:\n  self_call ?x = Some ?y \\<Longrightarrow> lfinite (derivation_from ?x)\n  (if is_final_dstate St\n   then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n   else self_call (deterministic_RP_step St)) =\n  Some St'\n\ngoal (1 subgoal):\n 1. \\<And>deterministic_RP St Sta.\n       \\<lbrakk>\\<And>x y.\n                   deterministic_RP x = Some y \\<Longrightarrow>\n                   lfinite (derivation_from x);\n        (if is_final_dstate St\n         then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n         else deterministic_RP (deterministic_RP_step St)) =\n        Some Sta\\<rbrakk>\n       \\<Longrightarrow> lfinite (derivation_from St)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (derivation_from St)", "using step"], ["proof (prove)\nusing this:\n  (if is_final_dstate St\n   then let (uu_, uu_, Q, uu_) = St in Some (map fst Q)\n   else self_call (deterministic_RP_step St)) =\n  Some St'\n\ngoal (1 subgoal):\n 1. lfinite (derivation_from St)", "by (subst derivation_from.code, auto intro: ih)"], ["proof (state)\nthis:\n  lfinite (derivation_from St)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfinite_wSts: \"lfinite wSts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite wSts", "by (rule lfinite_lmap[THEN iffD2, OF lfinite_Sts])"], ["", "lemmas lfinite_sswSts = lfinite_sswSts_iff[THEN iffD2, OF lfinite_wSts]"], ["", "theorem\n  deterministic_RP_saturated: \"saturated_upto grounded_R\" (is ?saturated) and\n  deterministic_RP_model: \"I \\<Turnstile>s grounded_N0 \\<longleftrightarrow> I \\<Turnstile>s grounded_R\" (is ?model)"], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_upto grounded_R &&&\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. saturated_upto grounded_R\n 2. (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "obtain N' P' Q' :: \"'a dclause list\" and n' k :: nat where\n    k_steps: \"(deterministic_RP_step ^^ k) St0 = (N', P', Q', n')\" (is \"_ = ?Stk\") and\n    final: \"is_final_dstate (N', P', Q', n')\" and\n    r: \"R = map fst Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k N' P' Q' n'.\n        \\<lbrakk>(deterministic_RP_step ^^ k) St0 = (N', P', Q', n');\n         is_final_dstate (N', P', Q', n'); R = map fst Q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using deterministic_RP_SomeD[OF drp_some]"], ["proof (prove)\nusing this:\n  \\<exists>N' P' Q' n'.\n     (\\<exists>k.\n         (deterministic_RP_step ^^ k) St0 = (N', P', Q', n')) \\<and>\n     is_final_dstate (N', P', Q', n') \\<and> R = map fst Q'\n\ngoal (1 subgoal):\n 1. (\\<And>k N' P' Q' n'.\n        \\<lbrakk>(deterministic_RP_step ^^ k) St0 = (N', P', Q', n');\n         is_final_dstate (N', P', Q', n'); R = map fst Q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (deterministic_RP_step ^^ k) St0 = (N', P', Q', n')\n  is_final_dstate (N', P', Q', n')\n  R = map fst Q'\n\ngoal (2 subgoals):\n 1. saturated_upto grounded_R\n 2. (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have wrp: \"wstate_of_dstate St0 \\<leadsto>\\<^sub>w\\<^sup>* wstate_of_dstate (llast Sts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wstate_of_dstate St0 \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (llast Sts)", "using lfinite_chain_imp_rtranclp_lhd_llast"], ["proof (prove)\nusing this:\n  \\<lbrakk>lfinite ?xs; chain ?R ?xs\\<rbrakk>\n  \\<Longrightarrow> ?R\\<^sup>*\\<^sup>* (lhd ?xs) (llast ?xs)\n\ngoal (1 subgoal):\n 1. wstate_of_dstate St0 \\<leadsto>\\<^sub>w\\<^sup>*\n    wstate_of_dstate (llast Sts)", "by (metis (no_types) deriv_sswSts_weighted_RP derivation_from.disc_iff derivation_from.simps(2)\n        lfinite_Sts lfinite_sswSts llast_lmap llist.map_sel(1) sswSts)"], ["proof (state)\nthis:\n  wstate_of_dstate St0 \\<leadsto>\\<^sub>w\\<^sup>*\n  wstate_of_dstate (llast Sts)\n\ngoal (2 subgoals):\n 1. saturated_upto grounded_R\n 2. (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have last_sts: \"llast Sts = ?Stk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llast Sts = (N', P', Q', n')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. llast Sts = (N', P', Q', n')", "have \"(deterministic_RP_step ^^ k') St0' = ?Stk \\<Longrightarrow> llast (derivation_from St0') = ?Stk\"\n      for St0' k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (deterministic_RP_step ^^ k') St0' = (N', P', Q', n') \\<Longrightarrow>\n    llast (derivation_from St0') = (N', P', Q', n')", "proof (induct k' arbitrary: St0')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>St0'.\n       (deterministic_RP_step ^^ 0) St0' =\n       (N', P', Q', n') \\<Longrightarrow>\n       llast (derivation_from St0') = (N', P', Q', n')\n 2. \\<And>k' St0'.\n       \\<lbrakk>\\<And>St0'.\n                   (deterministic_RP_step ^^ k') St0' =\n                   (N', P', Q', n') \\<Longrightarrow>\n                   llast (derivation_from St0') = (N', P', Q', n');\n        (deterministic_RP_step ^^ Suc k') St0' = (N', P', Q', n')\\<rbrakk>\n       \\<Longrightarrow> llast (derivation_from St0') = (N', P', Q', n')", "case 0"], ["proof (state)\nthis:\n  (deterministic_RP_step ^^ 0) St0' = (N', P', Q', n')\n\ngoal (2 subgoals):\n 1. \\<And>St0'.\n       (deterministic_RP_step ^^ 0) St0' =\n       (N', P', Q', n') \\<Longrightarrow>\n       llast (derivation_from St0') = (N', P', Q', n')\n 2. \\<And>k' St0'.\n       \\<lbrakk>\\<And>St0'.\n                   (deterministic_RP_step ^^ k') St0' =\n                   (N', P', Q', n') \\<Longrightarrow>\n                   llast (derivation_from St0') = (N', P', Q', n');\n        (deterministic_RP_step ^^ Suc k') St0' = (N', P', Q', n')\\<rbrakk>\n       \\<Longrightarrow> llast (derivation_from St0') = (N', P', Q', n')", "then"], ["proof (chain)\npicking this:\n  (deterministic_RP_step ^^ 0) St0' = (N', P', Q', n')", "show ?case"], ["proof (prove)\nusing this:\n  (deterministic_RP_step ^^ 0) St0' = (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. llast (derivation_from St0') = (N', P', Q', n')", "using final"], ["proof (prove)\nusing this:\n  (deterministic_RP_step ^^ 0) St0' = (N', P', Q', n')\n  is_final_dstate (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. llast (derivation_from St0') = (N', P', Q', n')", "by (subst derivation_from.code) simp"], ["proof (state)\nthis:\n  llast (derivation_from St0') = (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. \\<And>k' St0'.\n       \\<lbrakk>\\<And>St0'.\n                   (deterministic_RP_step ^^ k') St0' =\n                   (N', P', Q', n') \\<Longrightarrow>\n                   llast (derivation_from St0') = (N', P', Q', n');\n        (deterministic_RP_step ^^ Suc k') St0' = (N', P', Q', n')\\<rbrakk>\n       \\<Longrightarrow> llast (derivation_from St0') = (N', P', Q', n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k' St0'.\n       \\<lbrakk>\\<And>St0'.\n                   (deterministic_RP_step ^^ k') St0' =\n                   (N', P', Q', n') \\<Longrightarrow>\n                   llast (derivation_from St0') = (N', P', Q', n');\n        (deterministic_RP_step ^^ Suc k') St0' = (N', P', Q', n')\\<rbrakk>\n       \\<Longrightarrow> llast (derivation_from St0') = (N', P', Q', n')", "case (Suc k')"], ["proof (state)\nthis:\n  (deterministic_RP_step ^^ k') ?St0' = (N', P', Q', n') \\<Longrightarrow>\n  llast (derivation_from ?St0') = (N', P', Q', n')\n  (deterministic_RP_step ^^ Suc k') St0' = (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. \\<And>k' St0'.\n       \\<lbrakk>\\<And>St0'.\n                   (deterministic_RP_step ^^ k') St0' =\n                   (N', P', Q', n') \\<Longrightarrow>\n                   llast (derivation_from St0') = (N', P', Q', n');\n        (deterministic_RP_step ^^ Suc k') St0' = (N', P', Q', n')\\<rbrakk>\n       \\<Longrightarrow> llast (derivation_from St0') = (N', P', Q', n')", "note ih = this(1) and suc_k'_steps = this(2)"], ["proof (state)\nthis:\n  (deterministic_RP_step ^^ k') ?St0' = (N', P', Q', n') \\<Longrightarrow>\n  llast (derivation_from ?St0') = (N', P', Q', n')\n  (deterministic_RP_step ^^ Suc k') St0' = (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. \\<And>k' St0'.\n       \\<lbrakk>\\<And>St0'.\n                   (deterministic_RP_step ^^ k') St0' =\n                   (N', P', Q', n') \\<Longrightarrow>\n                   llast (derivation_from St0') = (N', P', Q', n');\n        (deterministic_RP_step ^^ Suc k') St0' = (N', P', Q', n')\\<rbrakk>\n       \\<Longrightarrow> llast (derivation_from St0') = (N', P', Q', n')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. llast (derivation_from St0') = (N', P', Q', n')", "proof (cases \"is_final_dstate St0'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_final_dstate St0' \\<Longrightarrow>\n    llast (derivation_from St0') = (N', P', Q', n')\n 2. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    llast (derivation_from St0') = (N', P', Q', n')", "case True"], ["proof (state)\nthis:\n  is_final_dstate St0'\n\ngoal (2 subgoals):\n 1. is_final_dstate St0' \\<Longrightarrow>\n    llast (derivation_from St0') = (N', P', Q', n')\n 2. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    llast (derivation_from St0') = (N', P', Q', n')", "then"], ["proof (chain)\npicking this:\n  is_final_dstate St0'", "show ?thesis"], ["proof (prove)\nusing this:\n  is_final_dstate St0'\n\ngoal (1 subgoal):\n 1. llast (derivation_from St0') = (N', P', Q', n')", "using ih[of \"deterministic_RP_step St0'\"] suc_k'_steps final_deterministic_RP_step\n            funpow_fixpoint[of deterministic_RP_step]"], ["proof (prove)\nusing this:\n  is_final_dstate St0'\n  (deterministic_RP_step ^^ k') (deterministic_RP_step St0') =\n  (N', P', Q', n') \\<Longrightarrow>\n  llast (derivation_from (deterministic_RP_step St0')) = (N', P', Q', n')\n  (deterministic_RP_step ^^ Suc k') St0' = (N', P', Q', n')\n  is_final_dstate ?St \\<Longrightarrow> deterministic_RP_step ?St = ?St\n  deterministic_RP_step ?x = ?x \\<Longrightarrow>\n  (deterministic_RP_step ^^ ?n) ?x = ?x\n\ngoal (1 subgoal):\n 1. llast (derivation_from St0') = (N', P', Q', n')", "by auto"], ["proof (state)\nthis:\n  llast (derivation_from St0') = (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    llast (derivation_from St0') = (N', P', Q', n')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    llast (derivation_from St0') = (N', P', Q', n')", "case False"], ["proof (state)\nthis:\n  \\<not> is_final_dstate St0'\n\ngoal (1 subgoal):\n 1. \\<not> is_final_dstate St0' \\<Longrightarrow>\n    llast (derivation_from St0') = (N', P', Q', n')", "then"], ["proof (chain)\npicking this:\n  \\<not> is_final_dstate St0'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_final_dstate St0'\n\ngoal (1 subgoal):\n 1. llast (derivation_from St0') = (N', P', Q', n')", "using ih[of \"deterministic_RP_step St0'\"] suc_k'_steps"], ["proof (prove)\nusing this:\n  \\<not> is_final_dstate St0'\n  (deterministic_RP_step ^^ k') (deterministic_RP_step St0') =\n  (N', P', Q', n') \\<Longrightarrow>\n  llast (derivation_from (deterministic_RP_step St0')) = (N', P', Q', n')\n  (deterministic_RP_step ^^ Suc k') St0' = (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. llast (derivation_from St0') = (N', P', Q', n')", "by (subst derivation_from.code) (simp add: llast_LCons funpow_swap1[symmetric])"], ["proof (state)\nthis:\n  llast (derivation_from St0') = (N', P', Q', n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llast (derivation_from St0') = (N', P', Q', n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (deterministic_RP_step ^^ ?k') ?St0' = (N', P', Q', n') \\<Longrightarrow>\n  llast (derivation_from ?St0') = (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. llast Sts = (N', P', Q', n')", "then"], ["proof (chain)\npicking this:\n  (deterministic_RP_step ^^ ?k') ?St0' = (N', P', Q', n') \\<Longrightarrow>\n  llast (derivation_from ?St0') = (N', P', Q', n')", "show ?thesis"], ["proof (prove)\nusing this:\n  (deterministic_RP_step ^^ ?k') ?St0' = (N', P', Q', n') \\<Longrightarrow>\n  llast (derivation_from ?St0') = (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. llast Sts = (N', P', Q', n')", "using k_steps"], ["proof (prove)\nusing this:\n  (deterministic_RP_step ^^ ?k') ?St0' = (N', P', Q', n') \\<Longrightarrow>\n  llast (derivation_from ?St0') = (N', P', Q', n')\n  (deterministic_RP_step ^^ k) St0 = (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. llast Sts = (N', P', Q', n')", "by blast"], ["proof (state)\nthis:\n  llast Sts = (N', P', Q', n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  llast Sts = (N', P', Q', n')\n\ngoal (2 subgoals):\n 1. saturated_upto grounded_R\n 2. (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have fin_gr_fgsts: \"lfinite (lmap wrp.grounding_of_wstate sswSts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite\n     (lmap\n       (\\<lambda>St.\n           grounding_of_clss\n            (wrp.N_of_wstate St \\<union> wrp.P_of_wstate St \\<union>\n             wrp.Q_of_wstate St))\n       sswSts)", "by (rule lfinite_lmap[THEN iffD2, OF lfinite_sswSts])"], ["proof (state)\nthis:\n  lfinite\n   (lmap\n     (\\<lambda>St.\n         grounding_of_clss\n          (wrp.N_of_wstate St \\<union> wrp.P_of_wstate St \\<union>\n           wrp.Q_of_wstate St))\n     sswSts)\n\ngoal (2 subgoals):\n 1. saturated_upto grounded_R\n 2. (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have lim_last: \"Liminf_llist (lmap wrp.grounding_of_wstate sswSts) =\n    wrp.grounding_of_wstate (llast sswSts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Liminf_llist\n     (lmap\n       (\\<lambda>St.\n           grounding_of_clss\n            (wrp.N_of_wstate St \\<union> wrp.P_of_wstate St \\<union>\n             wrp.Q_of_wstate St))\n       sswSts) =\n    grounding_of_clss\n     (wrp.N_of_wstate (llast sswSts) \\<union>\n      wrp.P_of_wstate (llast sswSts) \\<union>\n      wrp.Q_of_wstate (llast sswSts))", "unfolding lfinite_Liminf_llist[OF fin_gr_fgsts] llast_lmap[OF lfinite_sswSts not_lnull_sswSts]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if lnull\n         (lmap\n           (\\<lambda>St.\n               grounding_of_clss\n                (wrp.N_of_wstate St \\<union> wrp.P_of_wstate St \\<union>\n                 wrp.Q_of_wstate St))\n           sswSts)\n     then {}\n     else grounding_of_clss\n           (wrp.N_of_wstate (llast sswSts) \\<union>\n            wrp.P_of_wstate (llast sswSts) \\<union>\n            wrp.Q_of_wstate (llast sswSts))) =\n    grounding_of_clss\n     (wrp.N_of_wstate (llast sswSts) \\<union>\n      wrp.P_of_wstate (llast sswSts) \\<union>\n      wrp.Q_of_wstate (llast sswSts))", "using not_lnull_sswSts"], ["proof (prove)\nusing this:\n  \\<not> lnull sswSts\n\ngoal (1 subgoal):\n 1. (if lnull\n         (lmap\n           (\\<lambda>St.\n               grounding_of_clss\n                (wrp.N_of_wstate St \\<union> wrp.P_of_wstate St \\<union>\n                 wrp.Q_of_wstate St))\n           sswSts)\n     then {}\n     else grounding_of_clss\n           (wrp.N_of_wstate (llast sswSts) \\<union>\n            wrp.P_of_wstate (llast sswSts) \\<union>\n            wrp.Q_of_wstate (llast sswSts))) =\n    grounding_of_clss\n     (wrp.N_of_wstate (llast sswSts) \\<union>\n      wrp.P_of_wstate (llast sswSts) \\<union>\n      wrp.Q_of_wstate (llast sswSts))", "by simp"], ["proof (state)\nthis:\n  Liminf_llist\n   (lmap\n     (\\<lambda>St.\n         grounding_of_clss\n          (wrp.N_of_wstate St \\<union> wrp.P_of_wstate St \\<union>\n           wrp.Q_of_wstate St))\n     sswSts) =\n  grounding_of_clss\n   (wrp.N_of_wstate (llast sswSts) \\<union>\n    wrp.P_of_wstate (llast sswSts) \\<union>\n    wrp.Q_of_wstate (llast sswSts))\n\ngoal (2 subgoals):\n 1. saturated_upto grounded_R\n 2. (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have gr_st0: \"wrp.grounding_of_wstate (wstate_of_dstate St0) = grounded_N0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grounding_of_clss\n     (wrp.N_of_wstate (wstate_of_dstate St0) \\<union>\n      wrp.P_of_wstate (wstate_of_dstate St0) \\<union>\n      wrp.Q_of_wstate (wstate_of_dstate St0)) =\n    grounded_N0", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. grounding_of_clss\n     (wrp.N_of_wstate (wstate_of_dstate St0) \\<union>\n      wrp.P_of_wstate (wstate_of_dstate St0) \\<union>\n      wrp.Q_of_wstate (wstate_of_dstate St0)) =\n    grounding_of_clss (set (map (\\<lambda>x. mset (fst x)) N0))", "by simp"], ["proof (state)\nthis:\n  grounding_of_clss\n   (wrp.N_of_wstate (wstate_of_dstate St0) \\<union>\n    wrp.P_of_wstate (wstate_of_dstate St0) \\<union>\n    wrp.Q_of_wstate (wstate_of_dstate St0)) =\n  grounded_N0\n\ngoal (2 subgoals):\n 1. saturated_upto grounded_R\n 2. (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have \"?saturated \\<and> ?model\""], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "proof (cases \"[] \\<in> set R\")"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<in> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n 2. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "case True"], ["proof (state)\nthis:\n  [] \\<in> set R\n\ngoal (2 subgoals):\n 1. [] \\<in> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n 2. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "then"], ["proof (chain)\npicking this:\n  [] \\<in> set R", "have emp_in: \"{#} \\<in> grounded_R\""], ["proof (prove)\nusing this:\n  [] \\<in> set R\n\ngoal (1 subgoal):\n 1. {#} \\<in> grounded_R", "unfolding grounding_of_clss_def grounding_of_cls_def"], ["proof (prove)\nusing this:\n  [] \\<in> set R\n\ngoal (1 subgoal):\n 1. {#}\n    \\<in> (\\<Union>C\\<in>set (map mset R).\n              {C \\<cdot> \\<sigma> |\\<sigma>. is_ground_subst \\<sigma>})", "by (auto intro: ex_ground_subst)"], ["proof (state)\nthis:\n  {#} \\<in> grounded_R\n\ngoal (2 subgoals):\n 1. [] \\<in> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n 2. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have \"grounded_R \\<subseteq> wrp.grounding_of_wstate (llast sswSts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grounded_R\n    \\<subseteq> grounding_of_clss\n                 (wrp.N_of_wstate (llast sswSts) \\<union>\n                  wrp.P_of_wstate (llast sswSts) \\<union>\n                  wrp.Q_of_wstate (llast sswSts))", "unfolding r llast_sswSts"], ["proof (prove)\ngoal (1 subgoal):\n 1. grounding_of_clss (set (map mset (map fst Q')))\n    \\<subseteq> grounding_of_clss\n                 (wrp.N_of_wstate (llast wSts) \\<union>\n                  wrp.P_of_wstate (llast wSts) \\<union>\n                  wrp.Q_of_wstate (llast wSts))", "by (simp add: last_sts llast_lmap[OF lfinite_Sts] grounding_of_clss_def)"], ["proof (state)\nthis:\n  grounded_R\n  \\<subseteq> grounding_of_clss\n               (wrp.N_of_wstate (llast sswSts) \\<union>\n                wrp.P_of_wstate (llast sswSts) \\<union>\n                wrp.Q_of_wstate (llast sswSts))\n\ngoal (2 subgoals):\n 1. [] \\<in> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n 2. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "then"], ["proof (chain)\npicking this:\n  grounded_R\n  \\<subseteq> grounding_of_clss\n               (wrp.N_of_wstate (llast sswSts) \\<union>\n                wrp.P_of_wstate (llast sswSts) \\<union>\n                wrp.Q_of_wstate (llast sswSts))", "have gr_last_st: \"grounded_R \\<subseteq> wrp.grounding_of_wstate (wstate_of_dstate (llast Sts))\""], ["proof (prove)\nusing this:\n  grounded_R\n  \\<subseteq> grounding_of_clss\n               (wrp.N_of_wstate (llast sswSts) \\<union>\n                wrp.P_of_wstate (llast sswSts) \\<union>\n                wrp.Q_of_wstate (llast sswSts))\n\ngoal (1 subgoal):\n 1. grounded_R\n    \\<subseteq> grounding_of_clss\n                 (wrp.N_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n                  wrp.P_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n                  wrp.Q_of_wstate (wstate_of_dstate (llast Sts)))", "by (simp add: lfinite_Sts llast_lmap llast_sswSts)"], ["proof (state)\nthis:\n  grounded_R\n  \\<subseteq> grounding_of_clss\n               (wrp.N_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n                wrp.P_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n                wrp.Q_of_wstate (wstate_of_dstate (llast Sts)))\n\ngoal (2 subgoals):\n 1. [] \\<in> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n 2. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have gr_r_fls: \"\\<not> I \\<Turnstile>s grounded_R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> I \\<Turnstile>s grounded_R", "using emp_in"], ["proof (prove)\nusing this:\n  {#} \\<in> grounded_R\n\ngoal (1 subgoal):\n 1. \\<not> I \\<Turnstile>s grounded_R", "unfolding true_clss_def"], ["proof (prove)\nusing this:\n  {#} \\<in> grounded_R\n\ngoal (1 subgoal):\n 1. \\<not> Ball grounded_R ((\\<Turnstile>) I)", "by force"], ["proof (state)\nthis:\n  \\<not> I \\<Turnstile>s grounded_R\n\ngoal (2 subgoals):\n 1. [] \\<in> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n 2. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "then"], ["proof (chain)\npicking this:\n  \\<not> I \\<Turnstile>s grounded_R", "have gr_last_fls: \"\\<not> I \\<Turnstile>s wrp.grounding_of_wstate (wstate_of_dstate (llast Sts))\""], ["proof (prove)\nusing this:\n  \\<not> I \\<Turnstile>s grounded_R\n\ngoal (1 subgoal):\n 1. \\<not> I \\<Turnstile>s\n           grounding_of_clss\n            (wrp.N_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n             wrp.P_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n             wrp.Q_of_wstate (wstate_of_dstate (llast Sts)))", "using gr_last_st"], ["proof (prove)\nusing this:\n  \\<not> I \\<Turnstile>s grounded_R\n  grounded_R\n  \\<subseteq> grounding_of_clss\n               (wrp.N_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n                wrp.P_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n                wrp.Q_of_wstate (wstate_of_dstate (llast Sts)))\n\ngoal (1 subgoal):\n 1. \\<not> I \\<Turnstile>s\n           grounding_of_clss\n            (wrp.N_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n             wrp.P_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n             wrp.Q_of_wstate (wstate_of_dstate (llast Sts)))", "unfolding true_clss_def"], ["proof (prove)\nusing this:\n  \\<not> Ball grounded_R ((\\<Turnstile>) I)\n  grounded_R\n  \\<subseteq> grounding_of_clss\n               (wrp.N_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n                wrp.P_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n                wrp.Q_of_wstate (wstate_of_dstate (llast Sts)))\n\ngoal (1 subgoal):\n 1. \\<not> Ball\n            (grounding_of_clss\n              (wrp.N_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n               wrp.P_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n               wrp.Q_of_wstate (wstate_of_dstate (llast Sts))))\n            ((\\<Turnstile>) I)", "by auto"], ["proof (state)\nthis:\n  \\<not> I \\<Turnstile>s\n         grounding_of_clss\n          (wrp.N_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n           wrp.P_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n           wrp.Q_of_wstate (wstate_of_dstate (llast Sts)))\n\ngoal (2 subgoals):\n 1. [] \\<in> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n 2. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have ?saturated"], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_upto grounded_R", "unfolding wrp.ord_\\<Gamma>_saturated_upto_def[OF sswSts_thms]\n        wrp.ord_\\<Gamma>_contradiction_Rf[OF sswSts_thms emp_in] inference_system.inferences_from_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<gamma> \\<in> ord_\\<Gamma>.\n     infer_from (grounded_R - Rf grounded_R) \\<gamma>}\n    \\<subseteq> ord_\\<Gamma>", "by auto"], ["proof (state)\nthis:\n  saturated_upto grounded_R\n\ngoal (2 subgoals):\n 1. [] \\<in> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n 2. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "moreover"], ["proof (state)\nthis:\n  saturated_upto grounded_R\n\ngoal (2 subgoals):\n 1. [] \\<in> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n 2. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have ?model"], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "unfolding gr_r_fls[THEN eq_False[THEN iffD2]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>s grounded_N0) = False", "by (rule rtranclp_imp_eq_image[of \"(\\<leadsto>\\<^sub>w)\" \"\\<lambda>St. I \\<Turnstile>s wrp.grounding_of_wstate St\", OF _ wrp,\n            unfolded gr_st0 gr_last_fls[THEN eq_False[THEN iffD2]]])\n        (use wrp.weighted_RP_model[OF sswSts_thms] in blast)"], ["proof (state)\nthis:\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n\ngoal (2 subgoals):\n 1. [] \\<in> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n 2. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "ultimately"], ["proof (chain)\npicking this:\n  saturated_upto grounded_R\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "show ?thesis"], ["proof (prove)\nusing this:\n  saturated_upto grounded_R\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n\ngoal (1 subgoal):\n 1. saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "by blast"], ["proof (state)\nthis:\n  saturated_upto grounded_R \\<and>\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n\ngoal (1 subgoal):\n 1. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "case False"], ["proof (state)\nthis:\n  [] \\<notin> set R\n\ngoal (1 subgoal):\n 1. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "then"], ["proof (chain)\npicking this:\n  [] \\<notin> set R", "have gr_last: \"wrp.grounding_of_wstate (llast sswSts) = grounded_R\""], ["proof (prove)\nusing this:\n  [] \\<notin> set R\n\ngoal (1 subgoal):\n 1. grounding_of_clss\n     (wrp.N_of_wstate (llast sswSts) \\<union>\n      wrp.P_of_wstate (llast sswSts) \\<union>\n      wrp.Q_of_wstate (llast sswSts)) =\n    grounded_R", "using final"], ["proof (prove)\nusing this:\n  [] \\<notin> set R\n  is_final_dstate (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. grounding_of_clss\n     (wrp.N_of_wstate (llast sswSts) \\<union>\n      wrp.P_of_wstate (llast sswSts) \\<union>\n      wrp.Q_of_wstate (llast sswSts)) =\n    grounded_R", "unfolding r llast_sswSts"], ["proof (prove)\nusing this:\n  [] \\<notin> set (map fst Q')\n  is_final_dstate (N', P', Q', n')\n\ngoal (1 subgoal):\n 1. grounding_of_clss\n     (wrp.N_of_wstate (llast wSts) \\<union>\n      wrp.P_of_wstate (llast wSts) \\<union>\n      wrp.Q_of_wstate (llast wSts)) =\n    grounding_of_clss (set (map mset (map fst Q')))", "by (simp add: last_sts llast_lmap[OF lfinite_Sts] comp_def is_final_dstate.simps)"], ["proof (state)\nthis:\n  grounding_of_clss\n   (wrp.N_of_wstate (llast sswSts) \\<union>\n    wrp.P_of_wstate (llast sswSts) \\<union>\n    wrp.Q_of_wstate (llast sswSts)) =\n  grounded_R\n\ngoal (1 subgoal):\n 1. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "then"], ["proof (chain)\npicking this:\n  grounding_of_clss\n   (wrp.N_of_wstate (llast sswSts) \\<union>\n    wrp.P_of_wstate (llast sswSts) \\<union>\n    wrp.Q_of_wstate (llast sswSts)) =\n  grounded_R", "have gr_last_st: \"wrp.grounding_of_wstate (wstate_of_dstate (llast Sts)) = grounded_R\""], ["proof (prove)\nusing this:\n  grounding_of_clss\n   (wrp.N_of_wstate (llast sswSts) \\<union>\n    wrp.P_of_wstate (llast sswSts) \\<union>\n    wrp.Q_of_wstate (llast sswSts)) =\n  grounded_R\n\ngoal (1 subgoal):\n 1. grounding_of_clss\n     (wrp.N_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n      wrp.P_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n      wrp.Q_of_wstate (wstate_of_dstate (llast Sts))) =\n    grounded_R", "by (simp add: lfinite_Sts llast_lmap llast_sswSts)"], ["proof (state)\nthis:\n  grounding_of_clss\n   (wrp.N_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n    wrp.P_of_wstate (wstate_of_dstate (llast Sts)) \\<union>\n    wrp.Q_of_wstate (wstate_of_dstate (llast Sts))) =\n  grounded_R\n\ngoal (1 subgoal):\n 1. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have ?saturated"], ["proof (prove)\ngoal (1 subgoal):\n 1. saturated_upto grounded_R", "using wrp.weighted_RP_saturated[OF sswSts_thms, unfolded gr_last lim_last]"], ["proof (prove)\nusing this:\n  saturated_upto grounded_R\n\ngoal (1 subgoal):\n 1. saturated_upto grounded_R", "by auto"], ["proof (state)\nthis:\n  saturated_upto grounded_R\n\ngoal (1 subgoal):\n 1. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "moreover"], ["proof (state)\nthis:\n  saturated_upto grounded_R\n\ngoal (1 subgoal):\n 1. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "have ?model"], ["proof (prove)\ngoal (1 subgoal):\n 1. (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "by (rule rtranclp_imp_eq_image[of \"(\\<leadsto>\\<^sub>w)\" \"\\<lambda>St. I \\<Turnstile>s wrp.grounding_of_wstate St\", OF _ wrp,\n            unfolded gr_st0 gr_last_st])\n        (use wrp.weighted_RP_model[OF sswSts_thms] in blast)"], ["proof (state)\nthis:\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n\ngoal (1 subgoal):\n 1. [] \\<notin> set R \\<Longrightarrow>\n    saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "ultimately"], ["proof (chain)\npicking this:\n  saturated_upto grounded_R\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "show ?thesis"], ["proof (prove)\nusing this:\n  saturated_upto grounded_R\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n\ngoal (1 subgoal):\n 1. saturated_upto grounded_R \\<and>\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "by blast"], ["proof (state)\nthis:\n  saturated_upto grounded_R \\<and>\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  saturated_upto grounded_R \\<and>\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n\ngoal (2 subgoals):\n 1. saturated_upto grounded_R\n 2. (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "then"], ["proof (chain)\npicking this:\n  saturated_upto grounded_R \\<and>\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "show ?saturated and ?model"], ["proof (prove)\nusing this:\n  saturated_upto grounded_R \\<and>\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n\ngoal (1 subgoal):\n 1. saturated_upto grounded_R &&&\n    (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)", "by blast+"], ["proof (state)\nthis:\n  saturated_upto grounded_R\n  (I \\<Turnstile>s grounded_N0) = (I \\<Turnstile>s grounded_R)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary deterministic_RP_refutation:\n  \"\\<not> satisfiable grounded_N0 \\<longleftrightarrow> {#} \\<in> grounded_R\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> satisfiable grounded_N0) = ({#} \\<in> grounded_R)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> {#} \\<in> grounded_R\n 2. {#} \\<in> grounded_R \\<Longrightarrow> \\<not> satisfiable grounded_N0", "assume ?rhs"], ["proof (state)\nthis:\n  {#} \\<in> grounded_R\n\ngoal (2 subgoals):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> {#} \\<in> grounded_R\n 2. {#} \\<in> grounded_R \\<Longrightarrow> \\<not> satisfiable grounded_N0", "then"], ["proof (chain)\npicking this:\n  {#} \\<in> grounded_R", "have \"\\<not> satisfiable grounded_R\""], ["proof (prove)\nusing this:\n  {#} \\<in> grounded_R\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_R", "unfolding true_clss_def true_cls_def"], ["proof (prove)\nusing this:\n  {#} \\<in> grounded_R\n\ngoal (1 subgoal):\n 1. \\<nexists>I.\n       \\<forall>C\\<in>grounded_R. Multiset.Bex C ((\\<Turnstile>l) I)", "by force"], ["proof (state)\nthis:\n  \\<not> satisfiable grounded_R\n\ngoal (2 subgoals):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> {#} \\<in> grounded_R\n 2. {#} \\<in> grounded_R \\<Longrightarrow> \\<not> satisfiable grounded_N0", "then"], ["proof (chain)\npicking this:\n  \\<not> satisfiable grounded_R", "show ?lhs"], ["proof (prove)\nusing this:\n  \\<not> satisfiable grounded_R\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0", "using deterministic_RP_model[THEN iffD1]"], ["proof (prove)\nusing this:\n  \\<not> satisfiable grounded_R\n  ?I1 \\<Turnstile>s grounded_N0 \\<Longrightarrow>\n  ?I1 \\<Turnstile>s grounded_R\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0", "by blast"], ["proof (state)\nthis:\n  \\<not> satisfiable grounded_N0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> {#} \\<in> grounded_R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> {#} \\<in> grounded_R", "assume ?lhs"], ["proof (state)\nthis:\n  \\<not> satisfiable grounded_N0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> {#} \\<in> grounded_R", "then"], ["proof (chain)\npicking this:\n  \\<not> satisfiable grounded_N0", "have \"\\<not> satisfiable grounded_R\""], ["proof (prove)\nusing this:\n  \\<not> satisfiable grounded_N0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_R", "using deterministic_RP_model[THEN iffD2]"], ["proof (prove)\nusing this:\n  \\<not> satisfiable grounded_N0\n  ?I1 \\<Turnstile>s grounded_R \\<Longrightarrow>\n  ?I1 \\<Turnstile>s grounded_N0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_R", "by blast"], ["proof (state)\nthis:\n  \\<not> satisfiable grounded_R\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> {#} \\<in> grounded_R", "then"], ["proof (chain)\npicking this:\n  \\<not> satisfiable grounded_R", "show ?rhs"], ["proof (prove)\nusing this:\n  \\<not> satisfiable grounded_R\n\ngoal (1 subgoal):\n 1. {#} \\<in> grounded_R", "unfolding wrp.ord_\\<Gamma>_saturated_upto_complete[OF sswSts_thms deterministic_RP_saturated]"], ["proof (prove)\nusing this:\n  {#} \\<in> grounded_R\n\ngoal (1 subgoal):\n 1. {#} \\<in> grounded_R", "."], ["proof (state)\nthis:\n  {#} \\<in> grounded_R\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context\n  assumes drp_none: \"deterministic_RP St0 = None\"\nbegin"], ["", "theorem deterministic_RP_complete: \"satisfiable grounded_N0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. satisfiable grounded_N0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> False", "assume unsat: \"\\<not> satisfiable grounded_N0\""], ["proof (state)\nthis:\n  \\<not> satisfiable grounded_N0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> False", "have unsat_wSts0: \"\\<not> satisfiable (wrp.grounding_of_wstate (lhd wSts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable\n            (grounding_of_clss\n              (wrp.N_of_wstate (lhd wSts) \\<union>\n               wrp.P_of_wstate (lhd wSts) \\<union>\n               wrp.Q_of_wstate (lhd wSts)))", "using unsat"], ["proof (prove)\nusing this:\n  \\<not> satisfiable grounded_N0\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable\n            (grounding_of_clss\n              (wrp.N_of_wstate (lhd wSts) \\<union>\n               wrp.P_of_wstate (lhd wSts) \\<union>\n               wrp.Q_of_wstate (lhd wSts)))", "by (subst derivation_from.code) (simp add: comp_def)"], ["proof (state)\nthis:\n  \\<not> satisfiable\n          (grounding_of_clss\n            (wrp.N_of_wstate (lhd wSts) \\<union>\n             wrp.P_of_wstate (lhd wSts) \\<union>\n             wrp.Q_of_wstate (lhd wSts)))\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> False", "have bot_in_ss: \"{#} \\<in> Q_of_state (wrp.Liminf_wstate sswSts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#} \\<in> Q_of_state (wrp.Liminf_wstate sswSts)", "by (rule wrp.weighted_RP_complete[OF sswSts_thms unsat_wSts0[folded lhd_sswSts]])"], ["proof (state)\nthis:\n  {#} \\<in> Q_of_state (wrp.Liminf_wstate sswSts)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> False", "have bot_in_lim: \"{#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "proof (cases \"lfinite Sts\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite Sts \\<Longrightarrow>\n    {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)\n 2. \\<not> lfinite Sts \\<Longrightarrow>\n    {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "case fin: True"], ["proof (state)\nthis:\n  lfinite Sts\n\ngoal (2 subgoals):\n 1. lfinite Sts \\<Longrightarrow>\n    {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)\n 2. \\<not> lfinite Sts \\<Longrightarrow>\n    {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "have \"wrp.Liminf_wstate sswSts = wrp.Liminf_wstate wSts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrp.Liminf_wstate sswSts = wrp.Liminf_wstate wSts", "by (rule Liminf_state_fin, simp_all add: fin lfinite_sswSts_iff not_lnull_sswSts,\n          subst (1 2) llast_lmap,\n          simp_all add: lfinite_sswSts_iff fin not_lnull_sswSts llast_sswSts)"], ["proof (state)\nthis:\n  wrp.Liminf_wstate sswSts = wrp.Liminf_wstate wSts\n\ngoal (2 subgoals):\n 1. lfinite Sts \\<Longrightarrow>\n    {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)\n 2. \\<not> lfinite Sts \\<Longrightarrow>\n    {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "then"], ["proof (chain)\npicking this:\n  wrp.Liminf_wstate sswSts = wrp.Liminf_wstate wSts", "show ?thesis"], ["proof (prove)\nusing this:\n  wrp.Liminf_wstate sswSts = wrp.Liminf_wstate wSts\n\ngoal (1 subgoal):\n 1. {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "using bot_in_ss"], ["proof (prove)\nusing this:\n  wrp.Liminf_wstate sswSts = wrp.Liminf_wstate wSts\n  {#} \\<in> Q_of_state (wrp.Liminf_wstate sswSts)\n\ngoal (1 subgoal):\n 1. {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "by simp"], ["proof (state)\nthis:\n  {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite Sts \\<Longrightarrow>\n    {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite Sts \\<Longrightarrow>\n    {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite Sts\n\ngoal (1 subgoal):\n 1. \\<not> lfinite Sts \\<Longrightarrow>\n    {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "then"], ["proof (chain)\npicking this:\n  \\<not> lfinite Sts", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite Sts\n\ngoal (1 subgoal):\n 1. {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "using bot_in_ss Q_of_Liminf_state_inf[OF _ emb_lmap[OF emb_sswSts]]"], ["proof (prove)\nusing this:\n  \\<not> lfinite Sts\n  {#} \\<in> Q_of_state (wrp.Liminf_wstate sswSts)\n  \\<not> lfinite (lmap ?f1 wSts) \\<Longrightarrow>\n  Q_of_state (Liminf_state (lmap ?f1 sswSts))\n  \\<subseteq> Q_of_state (Liminf_state (lmap ?f1 wSts))\n\ngoal (1 subgoal):\n 1. {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "by auto"], ["proof (state)\nthis:\n  {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)", "obtain k :: nat where\n    k_lt: \"enat k < llength Sts\" and\n    emp_in: \"{#} \\<in> wrp.Q_of_wstate (lnth wSts k)\""], ["proof (prove)\nusing this:\n  {#} \\<in> Q_of_state (wrp.Liminf_wstate wSts)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>enat k < llength Sts;\n         {#} \\<in> wrp.Q_of_wstate (lnth wSts k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Liminf_state_def Liminf_llist_def"], ["proof (prove)\nusing this:\n  {#}\n  \\<in> Q_of_state\n         (\\<Union>i\\<in>{i. enat i\n                            < llength\n                               (lmap N_of_state\n                                 (lmap state_of_wstate wSts))}.\n             \\<Inter>\n              (lnth (lmap N_of_state (lmap state_of_wstate wSts)) `\n               {j. i \\<le> j \\<and>\n                   enat j\n                   < llength\n                      (lmap N_of_state (lmap state_of_wstate wSts))}),\n          \\<Union>i\\<in>{i. enat i\n                            < llength\n                               (lmap P_of_state\n                                 (lmap state_of_wstate wSts))}.\n             \\<Inter>\n              (lnth (lmap P_of_state (lmap state_of_wstate wSts)) `\n               {j. i \\<le> j \\<and>\n                   enat j\n                   < llength\n                      (lmap P_of_state (lmap state_of_wstate wSts))}),\n          \\<Union>i\\<in>{i. enat i\n                            < llength\n                               (lmap Q_of_state\n                                 (lmap state_of_wstate wSts))}.\n             \\<Inter>\n              (lnth (lmap Q_of_state (lmap state_of_wstate wSts)) `\n               {j. i \\<le> j \\<and>\n                   enat j\n                   < llength\n                      (lmap Q_of_state (lmap state_of_wstate wSts))}))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>enat k < llength Sts;\n         {#} \\<in> wrp.Q_of_wstate (lnth wSts k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  enat k < llength Sts\n  {#} \\<in> wrp.Q_of_wstate (lnth wSts k)\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> False", "have emp_in: \"{#} \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ k) St0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#}\n    \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ k) St0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {#}\n    \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ k) St0))", "have \"enat k < llength Sts' \\<Longrightarrow> Sts' = derivation_from St0' \\<Longrightarrow>\n      {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate Sts') k) \\<Longrightarrow>\n      {#} \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ k) St0'))\" for St0' Sts' k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enat k < llength Sts'; Sts' = derivation_from St0';\n     {#}\n     \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n    \\<Longrightarrow> {#}\n                      \\<in> Q_of_state\n                             (state_of_dstate\n                               ((deterministic_RP_step ^^ k) St0'))", "proof (induction k arbitrary: St0' Sts')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>St0' Sts'.\n       \\<lbrakk>enat 0 < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate Sts') 0)\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ 0) St0'))\n 2. \\<And>k St0' Sts'.\n       \\<lbrakk>\\<And>St0' Sts'.\n                   \\<lbrakk>enat k < llength Sts';\n                    Sts' = derivation_from St0';\n                    {#}\n                    \\<in> wrp.Q_of_wstate\n                           (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n                   \\<Longrightarrow> {#}\n                                     \\<in> Q_of_state\n      (state_of_dstate ((deterministic_RP_step ^^ k) St0'));\n        enat (Suc k) < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate\n               (lnth (lmap wstate_of_dstate Sts') (Suc k))\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ Suc k) St0'))", "case 0"], ["proof (state)\nthis:\n  enat 0 < llength Sts'\n  Sts' = derivation_from St0'\n  {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate Sts') 0)\n\ngoal (2 subgoals):\n 1. \\<And>St0' Sts'.\n       \\<lbrakk>enat 0 < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate Sts') 0)\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ 0) St0'))\n 2. \\<And>k St0' Sts'.\n       \\<lbrakk>\\<And>St0' Sts'.\n                   \\<lbrakk>enat k < llength Sts';\n                    Sts' = derivation_from St0';\n                    {#}\n                    \\<in> wrp.Q_of_wstate\n                           (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n                   \\<Longrightarrow> {#}\n                                     \\<in> Q_of_state\n      (state_of_dstate ((deterministic_RP_step ^^ k) St0'));\n        enat (Suc k) < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate\n               (lnth (lmap wstate_of_dstate Sts') (Suc k))\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ Suc k) St0'))", "then"], ["proof (chain)\npicking this:\n  enat 0 < llength Sts'\n  Sts' = derivation_from St0'\n  {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate Sts') 0)", "show ?case"], ["proof (prove)\nusing this:\n  enat 0 < llength Sts'\n  Sts' = derivation_from St0'\n  {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate Sts') 0)\n\ngoal (1 subgoal):\n 1. {#}\n    \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ 0) St0'))", "by (subst (asm) derivation_from.code, cases St0', auto simp: comp_def)"], ["proof (state)\nthis:\n  {#} \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ 0) St0'))\n\ngoal (1 subgoal):\n 1. \\<And>k St0' Sts'.\n       \\<lbrakk>\\<And>St0' Sts'.\n                   \\<lbrakk>enat k < llength Sts';\n                    Sts' = derivation_from St0';\n                    {#}\n                    \\<in> wrp.Q_of_wstate\n                           (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n                   \\<Longrightarrow> {#}\n                                     \\<in> Q_of_state\n      (state_of_dstate ((deterministic_RP_step ^^ k) St0'));\n        enat (Suc k) < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate\n               (lnth (lmap wstate_of_dstate Sts') (Suc k))\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ Suc k) St0'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k St0' Sts'.\n       \\<lbrakk>\\<And>St0' Sts'.\n                   \\<lbrakk>enat k < llength Sts';\n                    Sts' = derivation_from St0';\n                    {#}\n                    \\<in> wrp.Q_of_wstate\n                           (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n                   \\<Longrightarrow> {#}\n                                     \\<in> Q_of_state\n      (state_of_dstate ((deterministic_RP_step ^^ k) St0'));\n        enat (Suc k) < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate\n               (lnth (lmap wstate_of_dstate Sts') (Suc k))\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ Suc k) St0'))", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>enat k < llength ?Sts'; ?Sts' = derivation_from ?St0';\n   {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate ?Sts') k)\\<rbrakk>\n  \\<Longrightarrow> {#}\n                    \\<in> Q_of_state\n                           (state_of_dstate\n                             ((deterministic_RP_step ^^ k) ?St0'))\n  enat (Suc k) < llength Sts'\n  Sts' = derivation_from St0'\n  {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate Sts') (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k St0' Sts'.\n       \\<lbrakk>\\<And>St0' Sts'.\n                   \\<lbrakk>enat k < llength Sts';\n                    Sts' = derivation_from St0';\n                    {#}\n                    \\<in> wrp.Q_of_wstate\n                           (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n                   \\<Longrightarrow> {#}\n                                     \\<in> Q_of_state\n      (state_of_dstate ((deterministic_RP_step ^^ k) St0'));\n        enat (Suc k) < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate\n               (lnth (lmap wstate_of_dstate Sts') (Suc k))\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ Suc k) St0'))", "note ih = this(1) and sk_lt = this(2) and sts' = this(3) and emp_in_sk = this(4)"], ["proof (state)\nthis:\n  \\<lbrakk>enat k < llength ?Sts'; ?Sts' = derivation_from ?St0';\n   {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate ?Sts') k)\\<rbrakk>\n  \\<Longrightarrow> {#}\n                    \\<in> Q_of_state\n                           (state_of_dstate\n                             ((deterministic_RP_step ^^ k) ?St0'))\n  enat (Suc k) < llength Sts'\n  Sts' = derivation_from St0'\n  {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate Sts') (Suc k))\n\ngoal (1 subgoal):\n 1. \\<And>k St0' Sts'.\n       \\<lbrakk>\\<And>St0' Sts'.\n                   \\<lbrakk>enat k < llength Sts';\n                    Sts' = derivation_from St0';\n                    {#}\n                    \\<in> wrp.Q_of_wstate\n                           (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n                   \\<Longrightarrow> {#}\n                                     \\<in> Q_of_state\n      (state_of_dstate ((deterministic_RP_step ^^ k) St0'));\n        enat (Suc k) < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate\n               (lnth (lmap wstate_of_dstate Sts') (Suc k))\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ Suc k) St0'))", "have k_lt: \"enat k < llength (ltl Sts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat k < llength (ltl Sts')", "using sk_lt"], ["proof (prove)\nusing this:\n  enat (Suc k) < llength Sts'\n\ngoal (1 subgoal):\n 1. enat k < llength (ltl Sts')", "by (cases Sts') (auto simp: Suc_ile_eq)"], ["proof (state)\nthis:\n  enat k < llength (ltl Sts')\n\ngoal (1 subgoal):\n 1. \\<And>k St0' Sts'.\n       \\<lbrakk>\\<And>St0' Sts'.\n                   \\<lbrakk>enat k < llength Sts';\n                    Sts' = derivation_from St0';\n                    {#}\n                    \\<in> wrp.Q_of_wstate\n                           (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n                   \\<Longrightarrow> {#}\n                                     \\<in> Q_of_state\n      (state_of_dstate ((deterministic_RP_step ^^ k) St0'));\n        enat (Suc k) < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate\n               (lnth (lmap wstate_of_dstate Sts') (Suc k))\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ Suc k) St0'))", "moreover"], ["proof (state)\nthis:\n  enat k < llength (ltl Sts')\n\ngoal (1 subgoal):\n 1. \\<And>k St0' Sts'.\n       \\<lbrakk>\\<And>St0' Sts'.\n                   \\<lbrakk>enat k < llength Sts';\n                    Sts' = derivation_from St0';\n                    {#}\n                    \\<in> wrp.Q_of_wstate\n                           (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n                   \\<Longrightarrow> {#}\n                                     \\<in> Q_of_state\n      (state_of_dstate ((deterministic_RP_step ^^ k) St0'));\n        enat (Suc k) < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate\n               (lnth (lmap wstate_of_dstate Sts') (Suc k))\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ Suc k) St0'))", "have \"ltl Sts' = derivation_from (deterministic_RP_step St0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl Sts' = derivation_from (deterministic_RP_step St0')", "using sts' k_lt"], ["proof (prove)\nusing this:\n  Sts' = derivation_from St0'\n  enat k < llength (ltl Sts')\n\ngoal (1 subgoal):\n 1. ltl Sts' = derivation_from (deterministic_RP_step St0')", "by (cases Sts') auto"], ["proof (state)\nthis:\n  ltl Sts' = derivation_from (deterministic_RP_step St0')\n\ngoal (1 subgoal):\n 1. \\<And>k St0' Sts'.\n       \\<lbrakk>\\<And>St0' Sts'.\n                   \\<lbrakk>enat k < llength Sts';\n                    Sts' = derivation_from St0';\n                    {#}\n                    \\<in> wrp.Q_of_wstate\n                           (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n                   \\<Longrightarrow> {#}\n                                     \\<in> Q_of_state\n      (state_of_dstate ((deterministic_RP_step ^^ k) St0'));\n        enat (Suc k) < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate\n               (lnth (lmap wstate_of_dstate Sts') (Suc k))\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ Suc k) St0'))", "moreover"], ["proof (state)\nthis:\n  ltl Sts' = derivation_from (deterministic_RP_step St0')\n\ngoal (1 subgoal):\n 1. \\<And>k St0' Sts'.\n       \\<lbrakk>\\<And>St0' Sts'.\n                   \\<lbrakk>enat k < llength Sts';\n                    Sts' = derivation_from St0';\n                    {#}\n                    \\<in> wrp.Q_of_wstate\n                           (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n                   \\<Longrightarrow> {#}\n                                     \\<in> Q_of_state\n      (state_of_dstate ((deterministic_RP_step ^^ k) St0'));\n        enat (Suc k) < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate\n               (lnth (lmap wstate_of_dstate Sts') (Suc k))\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ Suc k) St0'))", "have \"{#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate (ltl Sts')) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate (ltl Sts')) k)", "using emp_in_sk k_lt"], ["proof (prove)\nusing this:\n  {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate Sts') (Suc k))\n  enat k < llength (ltl Sts')\n\ngoal (1 subgoal):\n 1. {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate (ltl Sts')) k)", "by (cases Sts') auto"], ["proof (state)\nthis:\n  {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate (ltl Sts')) k)\n\ngoal (1 subgoal):\n 1. \\<And>k St0' Sts'.\n       \\<lbrakk>\\<And>St0' Sts'.\n                   \\<lbrakk>enat k < llength Sts';\n                    Sts' = derivation_from St0';\n                    {#}\n                    \\<in> wrp.Q_of_wstate\n                           (lnth (lmap wstate_of_dstate Sts') k)\\<rbrakk>\n                   \\<Longrightarrow> {#}\n                                     \\<in> Q_of_state\n      (state_of_dstate ((deterministic_RP_step ^^ k) St0'));\n        enat (Suc k) < llength Sts'; Sts' = derivation_from St0';\n        {#}\n        \\<in> wrp.Q_of_wstate\n               (lnth (lmap wstate_of_dstate Sts') (Suc k))\\<rbrakk>\n       \\<Longrightarrow> {#}\n                         \\<in> Q_of_state\n                                (state_of_dstate\n                                  ((deterministic_RP_step ^^ Suc k) St0'))", "ultimately"], ["proof (chain)\npicking this:\n  enat k < llength (ltl Sts')\n  ltl Sts' = derivation_from (deterministic_RP_step St0')\n  {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate (ltl Sts')) k)", "show ?case"], ["proof (prove)\nusing this:\n  enat k < llength (ltl Sts')\n  ltl Sts' = derivation_from (deterministic_RP_step St0')\n  {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate (ltl Sts')) k)\n\ngoal (1 subgoal):\n 1. {#}\n    \\<in> Q_of_state\n           (state_of_dstate ((deterministic_RP_step ^^ Suc k) St0'))", "using ih[of \"ltl Sts'\" \"deterministic_RP_step St0'\"]"], ["proof (prove)\nusing this:\n  enat k < llength (ltl Sts')\n  ltl Sts' = derivation_from (deterministic_RP_step St0')\n  {#} \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate (ltl Sts')) k)\n  \\<lbrakk>enat k < llength (ltl Sts');\n   ltl Sts' = derivation_from (deterministic_RP_step St0');\n   {#}\n   \\<in> wrp.Q_of_wstate\n          (lnth (lmap wstate_of_dstate (ltl Sts')) k)\\<rbrakk>\n  \\<Longrightarrow> {#}\n                    \\<in> Q_of_state\n                           (state_of_dstate\n                             ((deterministic_RP_step ^^ k)\n                               (deterministic_RP_step St0')))\n\ngoal (1 subgoal):\n 1. {#}\n    \\<in> Q_of_state\n           (state_of_dstate ((deterministic_RP_step ^^ Suc k) St0'))", "by (simp add: funpow_swap1)"], ["proof (state)\nthis:\n  {#}\n  \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ Suc k) St0'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>enat ?k < llength ?Sts'; ?Sts' = derivation_from ?St0';\n   {#}\n   \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate ?Sts') ?k)\\<rbrakk>\n  \\<Longrightarrow> {#}\n                    \\<in> Q_of_state\n                           (state_of_dstate\n                             ((deterministic_RP_step ^^ ?k) ?St0'))\n\ngoal (1 subgoal):\n 1. {#}\n    \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ k) St0))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>enat ?k < llength ?Sts'; ?Sts' = derivation_from ?St0';\n   {#}\n   \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate ?Sts') ?k)\\<rbrakk>\n  \\<Longrightarrow> {#}\n                    \\<in> Q_of_state\n                           (state_of_dstate\n                             ((deterministic_RP_step ^^ ?k) ?St0'))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>enat ?k < llength ?Sts'; ?Sts' = derivation_from ?St0';\n   {#}\n   \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate ?Sts') ?k)\\<rbrakk>\n  \\<Longrightarrow> {#}\n                    \\<in> Q_of_state\n                           (state_of_dstate\n                             ((deterministic_RP_step ^^ ?k) ?St0'))\n\ngoal (1 subgoal):\n 1. {#}\n    \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ k) St0))", "using k_lt emp_in"], ["proof (prove)\nusing this:\n  \\<lbrakk>enat ?k < llength ?Sts'; ?Sts' = derivation_from ?St0';\n   {#}\n   \\<in> wrp.Q_of_wstate (lnth (lmap wstate_of_dstate ?Sts') ?k)\\<rbrakk>\n  \\<Longrightarrow> {#}\n                    \\<in> Q_of_state\n                           (state_of_dstate\n                             ((deterministic_RP_step ^^ ?k) ?St0'))\n  enat k < llength Sts\n  {#} \\<in> wrp.Q_of_wstate (lnth wSts k)\n\ngoal (1 subgoal):\n 1. {#}\n    \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ k) St0))", "by blast"], ["proof (state)\nthis:\n  {#} \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ k) St0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {#} \\<in> Q_of_state (state_of_dstate ((deterministic_RP_step ^^ k) St0))\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> False", "have \"deterministic_RP St0 \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic_RP St0 \\<noteq> None", "by (rule is_final_dstate_funpow_imp_deterministic_RP_neq_None[of \"Suc k\"],\n        cases \"(deterministic_RP_step ^^ k) St0\",\n        use emp_in in \\<open>force simp: deterministic_RP_step.simps is_final_dstate.simps\\<close>)"], ["proof (state)\nthis:\n  deterministic_RP St0 \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<not> satisfiable grounded_N0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  deterministic_RP St0 \\<noteq> None", "show False"], ["proof (prove)\nusing this:\n  deterministic_RP St0 \\<noteq> None\n\ngoal (1 subgoal):\n 1. False", "using drp_none"], ["proof (prove)\nusing this:\n  deterministic_RP St0 \\<noteq> None\n  deterministic_RP St0 = None\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"], ["", "end"]]}