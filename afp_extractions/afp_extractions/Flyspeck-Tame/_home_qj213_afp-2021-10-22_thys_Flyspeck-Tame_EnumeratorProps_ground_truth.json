{"file_name": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame/EnumeratorProps.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame", "problem_names": ["lemma length_hideDupsRec[simp]: \"\\<And>x. length(hideDupsRec x xs) = length xs\"", "lemma length_hideDups[simp]: \"length(hideDups xs) = length xs\"", "lemma length_indexToVertexList[simp]:\n \"length(indexToVertexList x y xs) = length xs\"", "lemma increasing1: \"\\<And> as x. increasing ls \\<Longrightarrow> ls = as @ x # cs @ y # bs \\<Longrightarrow> x \\<le> y\"", "lemma increasing2: \"increasing (as@bs) \\<Longrightarrow> x \\<in> set as \\<Longrightarrow> y \\<in> set bs \\<Longrightarrow> x \\<le> y\"", "lemma increasing3: \"\\<forall> as bs. (ls = as @ bs \\<longrightarrow> (\\<forall> x \\<in> set as. \\<forall> y \\<in> set bs. x \\<le> y)) \\<Longrightarrow> increasing (ls)\"", "lemma increasing4: \"increasing (as@bs) \\<Longrightarrow> increasing as\"", "lemma increasing5: \"increasing (as@bs) \\<Longrightarrow> increasing bs\"", "lemma enumBase_length: \"ls \\<in> set (enumBase nmax) \\<Longrightarrow> length ls = 1\"", "lemma enumBase_bound: \"\\<forall>y \\<in> set (enumBase nmax). \\<forall>z \\<in> set y. z \\<le> nmax\"", "lemmas enumBase_simps = enumBase_length enumBase_bound", "lemma enumAppend_bound: \"ls \\<in> set ((enumAppend nmax) lss) \\<Longrightarrow>\n \\<forall> y \\<in> set lss. \\<forall> z \\<in> set y. z \\<le> nmax \\<Longrightarrow> x \\<in> set ls \\<Longrightarrow> x \\<le>  nmax\"", "lemma enumAppend_bound_rec: \"ls \\<in> set (((enumAppend nmax) ^^ n) lss) \\<Longrightarrow>\n  \\<forall> y \\<in> set lss. \\<forall> z \\<in> set y. z \\<le> nmax \\<Longrightarrow> x \\<in> set ls \\<Longrightarrow> x \\<le>  nmax\"", "lemma enumAppend_increase_rec:\n  \"\\<And> m as bs. ls \\<in> set (((enumAppend nmax) ^^ m) (enumBase nmax)) \\<Longrightarrow>\n  as @ bs = ls \\<Longrightarrow>  \\<forall> x \\<in> set as. \\<forall> y \\<in> set bs. x \\<le> y\"", "lemma enumAppend_length1: \"\\<And>ls. ls \\<in> set ((enumAppend nmax ^^ n) lss) \\<Longrightarrow>\n (\\<forall>l \\<in> set lss. |l| = k) \\<Longrightarrow> |ls| = k + n\"", "lemma enumAppend_length2: \"\\<And>ls. ls \\<in> set ((enumAppend nmax ^^ n) lss) \\<Longrightarrow>\n (\\<And>l. l \\<in> set lss \\<Longrightarrow> |l| = k) \\<Longrightarrow> K = k + n \\<Longrightarrow> |ls| = K\"", "lemma enum_enumerator:\n \"enum i j = enumerator i j\"", "lemma enumerator_hd: \"ls \\<in> set (enumerator m n) \\<Longrightarrow> hd ls = 0\"", "lemma enumerator_last: \"ls \\<in> set (enumerator m n) \\<Longrightarrow> last ls = (n - 1)\"", "lemma enumerator_length: \"ls \\<in> set (enumerator m n) \\<Longrightarrow> 2 \\<le> length ls\"", "lemmas set_enumerator_simps = enumerator_hd enumerator_last enumerator_length", "lemma enumerator_not_empty[dest]: \"ls \\<in> set (enumerator m n) \\<Longrightarrow> ls \\<noteq>  []\"", "lemma enumerator_length2: \"ls \\<in> set (enumerator m n) \\<Longrightarrow> 2 < m \\<Longrightarrow> length ls = m\"", "lemma enumerator_bound: \"ls \\<in> set (enumerator m nmax) \\<Longrightarrow>\n 0 < nmax \\<Longrightarrow> x \\<in> set ls \\<Longrightarrow> x < nmax\"", "lemma enumerator_bound2: \"ls \\<in> set (enumerator m nmax) \\<Longrightarrow> 1 < nmax \\<Longrightarrow> x \\<in> set (butlast ls) \\<Longrightarrow> x < nmax - Suc 0\"", "lemma enumerator_bound3: \"ls \\<in> set (enumerator m nmax) \\<Longrightarrow> 1 < nmax \\<Longrightarrow> last (butlast ls) < nmax - Suc 0\"", "lemma enumerator_increase: \"\\<And> as bs. ls \\<in> set (enumerator m nmax) \\<Longrightarrow>  as @ bs = ls \\<Longrightarrow> \\<forall> x \\<in> set as. \\<forall> y \\<in> set bs. x \\<le> y\"", "lemma enumerator_increasing: \"ls \\<in> set (enumerator m nmax) \\<Longrightarrow> increasing ls\"", "lemma incrIndexList_1lem[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> Suc 0 < m\"", "lemma incrIndexList_1len[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> Suc 0 < nmax\"", "lemma incrIndexList_help2[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> hd ls = 0\"", "lemma incrIndexList_help21[simp]: \"incrIndexList (l # ls) m nmax \\<Longrightarrow> l = 0\"", "lemma incrIndexList_help3[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> last ls = (nmax - (Suc 0))\"", "lemma incrIndexList_help4[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> length ls = m \"", "lemma incrIndexList_help5[intro]: \"incrIndexList ls m nmax \\<Longrightarrow>  last (butlast ls) < nmax - Suc 0\"", "lemma incrIndexList_help6[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> increasing ls\"", "lemma incrIndexList_help7[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> ls \\<noteq> []\"", "lemma incrIndexList_help71[simp]: \"\\<not> incrIndexList [] m nmax\"", "lemma incrIndexList_help8[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> butlast ls \\<noteq> []\"", "lemma incrIndexList_help81[simp]: \"\\<not> incrIndexList [l] m nmax\"", "lemma incrIndexList_help9[intro]: \"(incrIndexList ls m nmax)  \\<Longrightarrow>\n  x \\<in> set (butlast ls) \\<Longrightarrow> x \\<le> nmax - 2\"", "lemma incrIndexList_help10[intro]: \"(incrIndexList ls m nmax)  \\<Longrightarrow>\n  x \\<in> set ls \\<Longrightarrow> x < nmax\"", "lemma enumerator_correctness: \"2 < m \\<Longrightarrow> 1 < nmax \\<Longrightarrow>\n  ls \\<in> set (enumerator m nmax) \\<Longrightarrow>\n  incrIndexList ls m nmax\"", "lemma enumerator_completeness_help: \"\\<And> ls. increasing ls \\<Longrightarrow> ls \\<noteq> [] \\<Longrightarrow> length ls = Suc ks \\<Longrightarrow> list_all (\\<lambda>x. x < Suc nmax) ls \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ ks) (enumBase nmax))\"", "lemma enumerator_completeness: \"2 < m \\<Longrightarrow> incrIndexList ls m nmax \\<Longrightarrow>\n  ls \\<in> set (enumerator m nmax)\"", "lemma enumerator_equiv[simp]:\n \"2 < n \\<Longrightarrow> 1 < m \\<Longrightarrow> is \\<in> set(enumerator n m) = incrIndexList is n m\""], "translations": [["", "lemma length_hideDupsRec[simp]: \"\\<And>x. length(hideDupsRec x xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. |hideDupsRec x xs| = |xs|", "by(induct xs) auto"], ["", "lemma length_hideDups[simp]: \"length(hideDups xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |hideDups xs| = |xs|", "by(cases xs) simp_all"], ["", "lemma length_indexToVertexList[simp]:\n \"length(indexToVertexList x y xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |indexToVertexList x y xs| = |xs|", "by(simp add:indexToVertexList_def)"], ["", "(***************************** List not decreasing ***************************)"], ["", "definition increasing :: \"('a::linorder) list \\<Rightarrow> bool\" where\n \"increasing ls \\<equiv> \\<forall> x y as bs. ls = as @ x # y # bs \\<longrightarrow> x \\<le> y\""], ["", "lemma increasing1: \"\\<And> as x. increasing ls \\<Longrightarrow> ls = as @ x # cs @ y # bs \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as x.\n       \\<lbrakk>increasing ls; ls = as @ x # cs @ y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "proof (induct cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as x.\n       \\<lbrakk>increasing ls; ls = as @ x # [] @ y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<And>a cs as x.\n       \\<lbrakk>\\<And>as x.\n                   \\<lbrakk>increasing ls;\n                    ls = as @ x # cs @ y # bs\\<rbrakk>\n                   \\<Longrightarrow> x \\<le> y;\n        increasing ls; ls = as @ x # (a # cs) @ y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "case Nil"], ["proof (state)\nthis:\n  increasing ls\n  ls = as @ x # [] @ y # bs\n\ngoal (2 subgoals):\n 1. \\<And>as x.\n       \\<lbrakk>increasing ls; ls = as @ x # [] @ y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<And>a cs as x.\n       \\<lbrakk>\\<And>as x.\n                   \\<lbrakk>increasing ls;\n                    ls = as @ x # cs @ y # bs\\<rbrakk>\n                   \\<Longrightarrow> x \\<le> y;\n        increasing ls; ls = as @ x # (a # cs) @ y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "then"], ["proof (chain)\npicking this:\n  increasing ls\n  ls = as @ x # [] @ y # bs", "show ?case"], ["proof (prove)\nusing this:\n  increasing ls\n  ls = as @ x # [] @ y # bs\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (auto simp: increasing_def)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>a cs as x.\n       \\<lbrakk>\\<And>as x.\n                   \\<lbrakk>increasing ls;\n                    ls = as @ x # cs @ y # bs\\<rbrakk>\n                   \\<Longrightarrow> x \\<le> y;\n        increasing ls; ls = as @ x # (a # cs) @ y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a cs as x.\n       \\<lbrakk>\\<And>as x.\n                   \\<lbrakk>increasing ls;\n                    ls = as @ x # cs @ y # bs\\<rbrakk>\n                   \\<Longrightarrow> x \\<le> y;\n        increasing ls; ls = as @ x # (a # cs) @ y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "case (Cons c cs)"], ["proof (state)\nthis:\n  \\<lbrakk>increasing ls; ls = ?as @ ?x # cs @ y # bs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> y\n  increasing ls\n  ls = as @ x # (c # cs) @ y # bs\n\ngoal (1 subgoal):\n 1. \\<And>a cs as x.\n       \\<lbrakk>\\<And>as x.\n                   \\<lbrakk>increasing ls;\n                    ls = as @ x # cs @ y # bs\\<rbrakk>\n                   \\<Longrightarrow> x \\<le> y;\n        increasing ls; ls = as @ x # (a # cs) @ y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>increasing ls; ls = ?as @ ?x # cs @ y # bs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> y\n  increasing ls\n  ls = as @ x # (c # cs) @ y # bs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>increasing ls; ls = ?as @ ?x # cs @ y # bs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> y\n  increasing ls\n  ls = as @ x # (c # cs) @ y # bs\n\ngoal (1 subgoal):\n 1. x \\<le> y", "apply (subgoal_tac \"c \\<le> y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>as x.\n                \\<lbrakk>increasing ls; ls = as @ x # cs @ y # bs\\<rbrakk>\n                \\<Longrightarrow> x \\<le> y;\n     increasing ls; ls = as @ x # (c # cs) @ y # bs; c \\<le> y\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y\n 2. \\<lbrakk>\\<And>as x.\n                \\<lbrakk>increasing ls; ls = as @ x # cs @ y # bs\\<rbrakk>\n                \\<Longrightarrow> x \\<le> y;\n     increasing ls; ls = as @ x # (c # cs) @ y # bs\\<rbrakk>\n    \\<Longrightarrow> c \\<le> y", "apply (force simp: increasing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>as x.\n                \\<lbrakk>increasing ls; ls = as @ x # cs @ y # bs\\<rbrakk>\n                \\<Longrightarrow> x \\<le> y;\n     increasing ls; ls = as @ x # (c # cs) @ y # bs\\<rbrakk>\n    \\<Longrightarrow> c \\<le> y", "apply (rule_tac Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>as x.\n                \\<lbrakk>increasing ls; ls = as @ x # cs @ y # bs\\<rbrakk>\n                \\<Longrightarrow> x \\<le> y;\n     increasing ls; ls = as @ x # (c # cs) @ y # bs\\<rbrakk>\n    \\<Longrightarrow> increasing ls\n 2. \\<lbrakk>\\<And>as x.\n                \\<lbrakk>increasing ls; ls = as @ x # cs @ y # bs\\<rbrakk>\n                \\<Longrightarrow> x \\<le> y;\n     increasing ls; ls = as @ x # (c # cs) @ y # bs\\<rbrakk>\n    \\<Longrightarrow> ls = ?as17 @ c # cs @ y # bs", "by simp_all"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma increasing2: \"increasing (as@bs) \\<Longrightarrow> x \\<in> set as \\<Longrightarrow> y \\<in> set bs \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>increasing (as @ bs); x \\<in> set as; y \\<in> set bs\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>increasing (as @ bs); x \\<in> set as; y \\<in> set bs\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y", "assume n:\"increasing (as@bs)\" and x:\"x \\<in> set as\" and y: \"y \\<in> set bs\""], ["proof (state)\nthis:\n  increasing (as @ bs)\n  x \\<in> set as\n  y \\<in> set bs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>increasing (as @ bs); x \\<in> set as; y \\<in> set bs\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y", "from x"], ["proof (chain)\npicking this:\n  x \\<in> set as", "obtain as' as'' where as: \"as = as' @ x # as''\""], ["proof (prove)\nusing this:\n  x \\<in> set as\n\ngoal (1 subgoal):\n 1. (\\<And>as' as''.\n        as = as' @ x # as'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  as = as' @ x # as''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>increasing (as @ bs); x \\<in> set as; y \\<in> set bs\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y", "from y"], ["proof (chain)\npicking this:\n  y \\<in> set bs", "obtain bs' bs'' where bs: \"bs = bs' @ y # bs''\""], ["proof (prove)\nusing this:\n  y \\<in> set bs\n\ngoal (1 subgoal):\n 1. (\\<And>bs' bs''.\n        bs = bs' @ y # bs'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  bs = bs' @ y # bs''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>increasing (as @ bs); x \\<in> set as; y \\<in> set bs\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y", "from n as bs"], ["proof (chain)\npicking this:\n  increasing (as @ bs)\n  as = as' @ x # as''\n  bs = bs' @ y # bs''", "show ?thesis"], ["proof (prove)\nusing this:\n  increasing (as @ bs)\n  as = as' @ x # as''\n  bs = bs' @ y # bs''\n\ngoal (1 subgoal):\n 1. x \\<le> y", "apply (auto intro!: increasing1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>increasing (as' @ x # as'' @ bs' @ y # bs'');\n     as = as' @ x # as''; bs = bs' @ y # bs''\\<rbrakk>\n    \\<Longrightarrow> as' @ x # as'' @ bs' @ y # bs'' =\n                      ?as3 @ x # ?cs3 @ y # ?bs3", "apply (subgoal_tac \"as' @ x # as'' @ bs' @ y # bs'' = as' @ x # (as'' @ bs') @ y # bs''\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>increasing (as' @ x # as'' @ bs' @ y # bs'');\n     as = as' @ x # as''; bs = bs' @ y # bs'';\n     as' @ x # as'' @ bs' @ y # bs'' =\n     as' @ x # (as'' @ bs') @ y # bs''\\<rbrakk>\n    \\<Longrightarrow> as' @ x # as'' @ bs' @ y # bs'' =\n                      ?as3 @ x # ?cs3 @ y # ?bs3\n 2. \\<lbrakk>increasing (as' @ x # as'' @ bs' @ y # bs'');\n     as = as' @ x # as''; bs = bs' @ y # bs''\\<rbrakk>\n    \\<Longrightarrow> as' @ x # as'' @ bs' @ y # bs'' =\n                      as' @ x # (as'' @ bs') @ y # bs''", "by (assumption) auto"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma increasing3: \"\\<forall> as bs. (ls = as @ bs \\<longrightarrow> (\\<forall> x \\<in> set as. \\<forall> y \\<in> set bs. x \\<le> y)) \\<Longrightarrow> increasing (ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>as bs.\n       ls = as @ bs \\<longrightarrow>\n       (\\<forall>x\\<in>set as.\n           \\<forall>y\\<in>set bs. x \\<le> y) \\<Longrightarrow>\n    increasing ls", "apply (simp add: increasing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>as bs.\n       ls = as @ bs \\<longrightarrow>\n       (\\<forall>x\\<in>set as.\n           \\<forall>y\\<in>set bs. x \\<le> y) \\<Longrightarrow>\n    \\<forall>x y.\n       (\\<exists>as bs. ls = as @ x # y # bs) \\<longrightarrow> x \\<le> y", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y as bs.\n       \\<lbrakk>\\<forall>asa bsa.\n                   as @ x # y # bs = asa @ bsa \\<longrightarrow>\n                   (\\<forall>x\\<in>set asa.\n                       \\<forall>y\\<in>set bsa. x \\<le> y);\n        ls = as @ x # y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y as bs.\n       \\<lbrakk>\\<forall>asa bsa.\n                   as @ x # y # bs = asa @ bsa \\<longrightarrow>\n                   (\\<forall>x\\<in>set asa.\n                       \\<forall>y\\<in>set bsa. x \\<le> y);\n        ls = as @ x # y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "fix as bs x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y as bs.\n       \\<lbrakk>\\<forall>asa bsa.\n                   as @ x # y # bs = asa @ bsa \\<longrightarrow>\n                   (\\<forall>x\\<in>set asa.\n                       \\<forall>y\\<in>set bsa. x \\<le> y);\n        ls = as @ x # y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "assume p: \"\\<forall>asa bsa. as @ x # y # bs = asa @ bsa \\<longrightarrow> (\\<forall>x\\<in>set asa. \\<forall>y\\<in>set bsa. x \\<le> y)\""], ["proof (state)\nthis:\n  \\<forall>asa bsa.\n     as @ x # y # bs = asa @ bsa \\<longrightarrow>\n     (\\<forall>x\\<in>set asa. \\<forall>y\\<in>set bsa. x \\<le> y)\n\ngoal (1 subgoal):\n 1. \\<And>x y as bs.\n       \\<lbrakk>\\<forall>asa bsa.\n                   as @ x # y # bs = asa @ bsa \\<longrightarrow>\n                   (\\<forall>x\\<in>set asa.\n                       \\<forall>y\\<in>set bsa. x \\<le> y);\n        ls = as @ x # y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "then"], ["proof (chain)\npicking this:\n  \\<forall>asa bsa.\n     as @ x # y # bs = asa @ bsa \\<longrightarrow>\n     (\\<forall>x\\<in>set asa. \\<forall>y\\<in>set bsa. x \\<le> y)", "have p': \"\\<And> asa bsa. as @ x # y # bs = asa @ bsa \\<Longrightarrow> (\\<forall>x\\<in>set asa. \\<forall>y\\<in>set bsa. x \\<le> y)\""], ["proof (prove)\nusing this:\n  \\<forall>asa bsa.\n     as @ x # y # bs = asa @ bsa \\<longrightarrow>\n     (\\<forall>x\\<in>set asa. \\<forall>y\\<in>set bsa. x \\<le> y)\n\ngoal (1 subgoal):\n 1. \\<And>asa bsa.\n       as @ x # y # bs = asa @ bsa \\<Longrightarrow>\n       \\<forall>x\\<in>set asa. \\<forall>y\\<in>set bsa. x \\<le> y", "by auto"], ["proof (state)\nthis:\n  as @ x # y # bs = ?asa @ ?bsa \\<Longrightarrow>\n  \\<forall>x\\<in>set ?asa. \\<forall>y\\<in>set ?bsa. x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y as bs.\n       \\<lbrakk>\\<forall>asa bsa.\n                   as @ x # y # bs = asa @ bsa \\<longrightarrow>\n                   (\\<forall>x\\<in>set asa.\n                       \\<forall>y\\<in>set bsa. x \\<le> y);\n        ls = as @ x # y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "then"], ["proof (chain)\npicking this:\n  as @ x # y # bs = ?asa @ ?bsa \\<Longrightarrow>\n  \\<forall>x\\<in>set ?asa. \\<forall>y\\<in>set ?bsa. x \\<le> y", "have \"(\\<forall>x\\<in>set (as @ [x]). \\<forall>y\\<in>set (y # bs). x \\<le> y)\""], ["proof (prove)\nusing this:\n  as @ x # y # bs = ?asa @ ?bsa \\<Longrightarrow>\n  \\<forall>x\\<in>set ?asa. \\<forall>y\\<in>set ?bsa. x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (as @ [x]). \\<forall>y\\<in>set (y # bs). x \\<le> y", "by (rule_tac p') auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (as @ [x]). \\<forall>y\\<in>set (y # bs). x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y as bs.\n       \\<lbrakk>\\<forall>asa bsa.\n                   as @ x # y # bs = asa @ bsa \\<longrightarrow>\n                   (\\<forall>x\\<in>set asa.\n                       \\<forall>y\\<in>set bsa. x \\<le> y);\n        ls = as @ x # y # bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (as @ [x]). \\<forall>y\\<in>set (y # bs). x \\<le> y", "show \"x \\<le> y\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (as @ [x]). \\<forall>y\\<in>set (y # bs). x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (auto simp: increasing_def)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma increasing4: \"increasing (as@bs) \\<Longrightarrow> increasing as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. increasing (as @ bs) \\<Longrightarrow> increasing as", "apply (simp add: increasing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>asa bsa. as @ bs = asa @ x # y # bsa) \\<longrightarrow>\n       x \\<le> y \\<Longrightarrow>\n    \\<forall>x y.\n       (\\<exists>asa bs. as = asa @ x # y # bs) \\<longrightarrow> x \\<le> y", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y asa bsa.\n       \\<lbrakk>\\<forall>xa ya.\n                   (\\<exists>as bsb.\n                       (asa @ x # y # bsa) @ bs =\n                       as @ xa # ya # bsb) \\<longrightarrow>\n                   xa \\<le> ya;\n        as = asa @ x # y # bsa\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "by auto"], ["", "lemma increasing5: \"increasing (as@bs) \\<Longrightarrow> increasing bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. increasing (as @ bs) \\<Longrightarrow> increasing bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. increasing (as @ bs) \\<Longrightarrow> increasing bs", "assume nd: \"increasing (as@bs)\""], ["proof (state)\nthis:\n  increasing (as @ bs)\n\ngoal (1 subgoal):\n 1. increasing (as @ bs) \\<Longrightarrow> increasing bs", "then"], ["proof (chain)\npicking this:\n  increasing (as @ bs)", "have r: \"\\<And> x y asa bsa. (\\<exists>asa bsa. as @ bs = asa @ x # y # bsa) \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\nusing this:\n  increasing (as @ bs)\n\ngoal (1 subgoal):\n 1. \\<And>x y asa bsa.\n       \\<exists>asa bsa. as @ bs = asa @ x # y # bsa \\<Longrightarrow>\n       x \\<le> y", "by (auto simp: increasing_def)"], ["proof (state)\nthis:\n  \\<exists>asa bsa. as @ bs = asa @ ?x # ?y # bsa \\<Longrightarrow>\n  ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. increasing (as @ bs) \\<Longrightarrow> increasing bs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. increasing bs", "apply (clarsimp simp add: increasing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y as bsa. bs = as @ x # y # bsa \\<Longrightarrow> x \\<le> y", "apply (rule_tac r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y asa bsa.\n       bs = asa @ x # y # bsa \\<Longrightarrow>\n       \\<exists>asa bsa. as @ bs = asa @ x # y # bsa", "apply (rule_tac x=\"as @ _\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y asa bsa.\n       bs = asa @ x # y # bsa \\<Longrightarrow>\n       \\<exists>bsaa. as @ bs = (as @ ?uu15 x y asa bsa) @ x # y # bsaa", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  increasing bs\n\ngoal:\nNo subgoals!", "qed"], ["", "(*********************************** EnumeratorProps *************************************)\n\n(********** enumBase ***********)"], ["", "lemma enumBase_length: \"ls \\<in> set (enumBase nmax) \\<Longrightarrow> length ls = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumBase nmax) \\<Longrightarrow> |ls| = 1", "by (auto simp: enumBase_def)"], ["", "lemma enumBase_bound: \"\\<forall>y \\<in> set (enumBase nmax). \\<forall>z \\<in> set y. z \\<le> nmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (enumBase nmax). \\<forall>z\\<in>set y. z \\<le> nmax", "by (auto simp: enumBase_def)"], ["", "lemmas enumBase_simps = enumBase_length enumBase_bound"], ["", "(********** enumAppend ************)"], ["", "lemma enumAppend_bound: \"ls \\<in> set ((enumAppend nmax) lss) \\<Longrightarrow>\n \\<forall> y \\<in> set lss. \\<forall> z \\<in> set y. z \\<le> nmax \\<Longrightarrow> x \\<in> set ls \\<Longrightarrow> x \\<le>  nmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (enumAppend nmax lss);\n     \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax;\n     x \\<in> set ls\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax", "by (auto simp add: enumAppend_def split: if_split_asm)"], ["", "lemma enumAppend_bound_rec: \"ls \\<in> set (((enumAppend nmax) ^^ n) lss) \\<Longrightarrow>\n  \\<forall> y \\<in> set lss. \\<forall> z \\<in> set y. z \\<le> nmax \\<Longrightarrow> x \\<in> set ls \\<Longrightarrow> x \\<le>  nmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set ((enumAppend nmax ^^ n) lss);\n     \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax;\n     x \\<in> set ls\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set ((enumAppend nmax ^^ n) lss);\n     \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax;\n     x \\<in> set ls\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax", "assume ls: \"ls \\<in> set ((enumAppend nmax ^^ n) lss)\" and lss: \"\\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\" and x: \"x \\<in> set ls\""], ["proof (state)\nthis:\n  ls \\<in> set ((enumAppend nmax ^^ n) lss)\n  \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\n  x \\<in> set ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set ((enumAppend nmax ^^ n) lss);\n     \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax;\n     x \\<in> set ls\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax", "have ind:\"\\<And> lss. \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow> \\<forall> y \\<in> set (((enumAppend nmax) ^^ n) lss). \\<forall> z \\<in> set y. z \\<le> nmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lss.\n       \\<forall>y\\<in>set lss.\n          \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n       \\<forall>y\\<in>set ((enumAppend nmax ^^ n) lss).\n          \\<forall>z\\<in>set y. z \\<le> nmax", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lss.\n       \\<forall>y\\<in>set lss.\n          \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n       \\<forall>y\\<in>set ((enumAppend nmax ^^ 0) lss).\n          \\<forall>z\\<in>set y. z \\<le> nmax\n 2. \\<And>n lss.\n       \\<lbrakk>\\<And>lss.\n                   \\<forall>y\\<in>set lss.\n                      \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n                   \\<forall>y\\<in>set ((enumAppend nmax ^^ n) lss).\n                      \\<forall>z\\<in>set y. z \\<le> nmax;\n        \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set\n   ((enumAppend nmax ^^ Suc n) lss).\n                            \\<forall>z\\<in>set y. z \\<le> nmax", "case 0"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\n\ngoal (2 subgoals):\n 1. \\<And>lss.\n       \\<forall>y\\<in>set lss.\n          \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n       \\<forall>y\\<in>set ((enumAppend nmax ^^ 0) lss).\n          \\<forall>z\\<in>set y. z \\<le> nmax\n 2. \\<And>n lss.\n       \\<lbrakk>\\<And>lss.\n                   \\<forall>y\\<in>set lss.\n                      \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n                   \\<forall>y\\<in>set ((enumAppend nmax ^^ n) lss).\n                      \\<forall>z\\<in>set y. z \\<le> nmax;\n        \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set\n   ((enumAppend nmax ^^ Suc n) lss).\n                            \\<forall>z\\<in>set y. z \\<le> nmax", "then"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ((enumAppend nmax ^^ 0) lss).\n       \\<forall>z\\<in>set y. z \\<le> nmax", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ((enumAppend nmax ^^ 0) lss).\n     \\<forall>z\\<in>set y. z \\<le> nmax\n\ngoal (1 subgoal):\n 1. \\<And>n lss.\n       \\<lbrakk>\\<And>lss.\n                   \\<forall>y\\<in>set lss.\n                      \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n                   \\<forall>y\\<in>set ((enumAppend nmax ^^ n) lss).\n                      \\<forall>z\\<in>set y. z \\<le> nmax;\n        \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set\n   ((enumAppend nmax ^^ Suc n) lss).\n                            \\<forall>z\\<in>set y. z \\<le> nmax", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n lss.\n       \\<lbrakk>\\<And>lss.\n                   \\<forall>y\\<in>set lss.\n                      \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n                   \\<forall>y\\<in>set ((enumAppend nmax ^^ n) lss).\n                      \\<forall>z\\<in>set y. z \\<le> nmax;\n        \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set\n   ((enumAppend nmax ^^ Suc n) lss).\n                            \\<forall>z\\<in>set y. z \\<le> nmax", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ?lss.\n     \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n  \\<forall>y\\<in>set ((enumAppend nmax ^^ n) ?lss).\n     \\<forall>z\\<in>set y. z \\<le> nmax\n  \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\n\ngoal (1 subgoal):\n 1. \\<And>n lss.\n       \\<lbrakk>\\<And>lss.\n                   \\<forall>y\\<in>set lss.\n                      \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n                   \\<forall>y\\<in>set ((enumAppend nmax ^^ n) lss).\n                      \\<forall>z\\<in>set y. z \\<le> nmax;\n        \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set\n   ((enumAppend nmax ^^ Suc n) lss).\n                            \\<forall>z\\<in>set y. z \\<le> nmax", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ((enumAppend nmax ^^ Suc n) lss).\n       \\<forall>z\\<in>set y. z \\<le> nmax", "apply (intro ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<in> set ((enumAppend nmax ^^ Suc n) lss);\n        z \\<in> set y\\<rbrakk>\n       \\<Longrightarrow> z \\<le> nmax", "apply (rule enumAppend_bound)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<in> set ((enumAppend nmax ^^ Suc n) lss);\n        z \\<in> set y\\<rbrakk>\n       \\<Longrightarrow> ?ls2 y z \\<in> set (enumAppend nmax (?lss2 y z))\n 2. \\<And>y z.\n       \\<lbrakk>y \\<in> set ((enumAppend nmax ^^ Suc n) lss);\n        z \\<in> set y\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set (?lss2 y z).\n                            \\<forall>z\\<in>set y. z \\<le> nmax\n 3. \\<And>y z.\n       \\<lbrakk>y \\<in> set ((enumAppend nmax ^^ Suc n) lss);\n        z \\<in> set y\\<rbrakk>\n       \\<Longrightarrow> z \\<in> set (?ls2 y z)", "by (auto intro!: Suc)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ((enumAppend nmax ^^ Suc n) lss).\n     \\<forall>z\\<in>set y. z \\<le> nmax\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ?lss.\n     \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n  \\<forall>y\\<in>set ((enumAppend nmax ^^ n) ?lss).\n     \\<forall>z\\<in>set y. z \\<le> nmax\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set ((enumAppend nmax ^^ n) lss);\n     \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax;\n     x \\<in> set ls\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax", "with lss"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\n  \\<forall>y\\<in>set ?lss.\n     \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n  \\<forall>y\\<in>set ((enumAppend nmax ^^ n) ?lss).\n     \\<forall>z\\<in>set y. z \\<le> nmax", "have \"\\<forall> y \\<in> set (((enumAppend nmax) ^^ n) lss). \\<forall> z \\<in> set y. z \\<le> nmax\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax\n  \\<forall>y\\<in>set ?lss.\n     \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n  \\<forall>y\\<in>set ((enumAppend nmax ^^ n) ?lss).\n     \\<forall>z\\<in>set y. z \\<le> nmax\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ((enumAppend nmax ^^ n) lss).\n       \\<forall>z\\<in>set y. z \\<le> nmax", "apply (rule_tac ind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax;\n     \\<And>lss.\n        \\<forall>y\\<in>set lss.\n           \\<forall>z\\<in>set y. z \\<le> nmax \\<Longrightarrow>\n        \\<forall>y\\<in>set ((enumAppend nmax ^^ n) lss).\n           \\<forall>z\\<in>set y. z \\<le> nmax\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>set lss.\n                         \\<forall>z\\<in>set y. z \\<le> nmax", "."], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ((enumAppend nmax ^^ n) lss).\n     \\<forall>z\\<in>set y. z \\<le> nmax\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set ((enumAppend nmax ^^ n) lss);\n     \\<forall>y\\<in>set lss. \\<forall>z\\<in>set y. z \\<le> nmax;\n     x \\<in> set ls\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax", "with ls x"], ["proof (chain)\npicking this:\n  ls \\<in> set ((enumAppend nmax ^^ n) lss)\n  x \\<in> set ls\n  \\<forall>y\\<in>set ((enumAppend nmax ^^ n) lss).\n     \\<forall>z\\<in>set y. z \\<le> nmax", "show ?thesis"], ["proof (prove)\nusing this:\n  ls \\<in> set ((enumAppend nmax ^^ n) lss)\n  x \\<in> set ls\n  \\<forall>y\\<in>set ((enumAppend nmax ^^ n) lss).\n     \\<forall>z\\<in>set y. z \\<le> nmax\n\ngoal (1 subgoal):\n 1. x \\<le> nmax", "by auto"], ["proof (state)\nthis:\n  x \\<le> nmax\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enumAppend_increase_rec:\n  \"\\<And> m as bs. ls \\<in> set (((enumAppend nmax) ^^ m) (enumBase nmax)) \\<Longrightarrow>\n  as @ bs = ls \\<Longrightarrow>  \\<forall> x \\<in> set as. \\<forall> y \\<in> set bs. x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m as bs.\n       \\<lbrakk>ls \\<in> set ((enumAppend nmax ^^ m) (enumBase nmax));\n        as @ bs = ls\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set as.\n                            \\<forall>y\\<in>set bs. x \\<le> y", "apply (induct ls rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m as bs.\n       \\<lbrakk>[] \\<in> set ((enumAppend nmax ^^ m) (enumBase nmax));\n        as @ bs = []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set as. Ball (set bs) ((\\<le>) x)\n 2. \\<And>x xs m as bs.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  Ball (set bs) ((\\<le>) x);\n        xs @ [x] \\<in> set ((enumAppend nmax ^^ m) (enumBase nmax));\n        as @ bs = xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set as. Ball (set bs) ((\\<le>) x)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  Ball (set bs) ((\\<le>) x);\n        xs @ [x] \\<in> set ((enumAppend nmax ^^ m) (enumBase nmax));\n        as @ bs = xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set as. Ball (set bs) ((\\<le>) x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs xa xb.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x] \\<in> set ((enumAppend nmax ^^ m) (enumBase nmax));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "apply (case_tac \"m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs m as bs xa xb.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x] \\<in> set ((enumAppend nmax ^^ m) (enumBase nmax));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs; m = 0\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb\n 2. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x] \\<in> set ((enumAppend nmax ^^ m) (enumBase nmax));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs m as bs xa xb.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x] \\<in> set (enumBase nmax); as @ bs = xs @ [x];\n        xa \\<in> set as; xb \\<in> set bs; m = 0\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb\n 2. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x] \\<in> set ((enumAppend nmax ^^ m) (enumBase nmax));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "apply (drule_tac enumBase_length)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs m as bs xa xb.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs; m = 0;\n        |xs @ [x]| = 1\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb\n 2. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x] \\<in> set ((enumAppend nmax ^^ m) (enumBase nmax));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "apply (case_tac as)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs m as bs xa xb.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs; m = 0;\n        |xs @ [x]| = 1; as = []\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb\n 2. \\<And>x xs m as bs xa xb a list.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs; m = 0;\n        |xs @ [x]| = 1; as = a # list\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb\n 3. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x] \\<in> set ((enumAppend nmax ^^ m) (enumBase nmax));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x]\n        \\<in> set (enumAppend nmax\n                    ((enumAppend nmax ^^ nat) (enumBase nmax)));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x]\n        \\<in> set (enumAppend nmax\n                    ((enumAppend nmax ^^ nat) (enumBase nmax)));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "fix x xs m as bs xa xb n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x]\n        \\<in> set (enumAppend nmax\n                    ((enumAppend nmax ^^ nat) (enumBase nmax)));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "assume ih: \"\\<And>m as bs.\n           \\<lbrakk>xs \\<in> set ((enumAppend nmax ^^ m) (enumBase nmax)); as @ bs = xs\\<rbrakk>\n           \\<Longrightarrow> \\<forall>x\\<in>set as. \\<forall>xa\\<in>set bs. x \\<le> xa\"\n    and xs:\"xs @ [x] \\<in> set (enumAppend nmax ((enumAppend nmax ^^ n) (enumBase nmax)))\"\n    and asbs: \"as @ bs = xs @ [x]\" and xa:\"xa \\<in> set as\" and xb: \"xb \\<in> set bs\" and m: \"m = Suc n\""], ["proof (state)\nthis:\n  \\<lbrakk>xs \\<in> set ((enumAppend nmax ^^ ?m) (enumBase nmax));\n   ?as @ ?bs = xs\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?as.\n                       \\<forall>xa\\<in>set ?bs. x \\<le> xa\n  xs @ [x]\n  \\<in> set (enumAppend nmax ((enumAppend nmax ^^ n) (enumBase nmax)))\n  as @ bs = xs @ [x]\n  xa \\<in> set as\n  xb \\<in> set bs\n  m = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x]\n        \\<in> set (enumAppend nmax\n                    ((enumAppend nmax ^^ nat) (enumBase nmax)));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "from ih"], ["proof (chain)\npicking this:\n  \\<lbrakk>xs \\<in> set ((enumAppend nmax ^^ ?m) (enumBase nmax));\n   ?as @ ?bs = xs\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?as.\n                       \\<forall>xa\\<in>set ?bs. x \\<le> xa", "have ih2: \"\\<And> as bs x y. \\<lbrakk>xs \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax)); as @ bs = xs; x \\<in> set as; y \\<in> set bs\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>xs \\<in> set ((enumAppend nmax ^^ ?m) (enumBase nmax));\n   ?as @ ?bs = xs\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ?as.\n                       \\<forall>xa\\<in>set ?bs. x \\<le> xa\n\ngoal (1 subgoal):\n 1. \\<And>as bs x y.\n       \\<lbrakk>xs \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax));\n        as @ bs = xs; x \\<in> set as; y \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>xs \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax));\n   ?as @ ?bs = xs; ?x \\<in> set ?as; ?y \\<in> set ?bs\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x]\n        \\<in> set (enumAppend nmax\n                    ((enumAppend nmax ^^ nat) (enumBase nmax)));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "from xb"], ["proof (chain)\npicking this:\n  xb \\<in> set bs", "have \"bs \\<noteq> []\""], ["proof (prove)\nusing this:\n  xb \\<in> set bs\n\ngoal (1 subgoal):\n 1. bs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  bs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x]\n        \\<in> set (enumAppend nmax\n                    ((enumAppend nmax ^^ nat) (enumBase nmax)));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "then"], ["proof (chain)\npicking this:\n  bs \\<noteq> []", "obtain bs' b where bs': \"bs = bs' @ [b]\""], ["proof (prove)\nusing this:\n  bs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>bs' b. bs = bs' @ [b] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases rule: rev_exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>bs' b. bs = bs' @ [b] \\<Longrightarrow> thesis;\n     bs \\<noteq> []; ?xs3 = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>ys y.\n       \\<lbrakk>\\<And>bs' b. bs = bs' @ [b] \\<Longrightarrow> thesis;\n        bs \\<noteq> []; ?xs3 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  bs = bs' @ [b]\n\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x]\n        \\<in> set (enumAppend nmax\n                    ((enumAppend nmax ^^ nat) (enumBase nmax)));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "with asbs"], ["proof (chain)\npicking this:\n  as @ bs = xs @ [x]\n  bs = bs' @ [b]", "have beq:\"b = x\""], ["proof (prove)\nusing this:\n  as @ bs = xs @ [x]\n  bs = bs' @ [b]\n\ngoal (1 subgoal):\n 1. b = x", "by auto"], ["proof (state)\nthis:\n  b = x\n\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x]\n        \\<in> set (enumAppend nmax\n                    ((enumAppend nmax ^^ nat) (enumBase nmax)));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "from bs' asbs"], ["proof (chain)\npicking this:\n  bs = bs' @ [b]\n  as @ bs = xs @ [x]", "have xs': \"as @ bs' = xs\""], ["proof (prove)\nusing this:\n  bs = bs' @ [b]\n  as @ bs = xs @ [x]\n\ngoal (1 subgoal):\n 1. as @ bs' = xs", "by auto"], ["proof (state)\nthis:\n  as @ bs' = xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x]\n        \\<in> set (enumAppend nmax\n                    ((enumAppend nmax ^^ nat) (enumBase nmax)));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "with xs"], ["proof (chain)\npicking this:\n  xs @ [x]\n  \\<in> set (enumAppend nmax ((enumAppend nmax ^^ n) (enumBase nmax)))\n  as @ bs' = xs", "have \"xa \\<le> x\""], ["proof (prove)\nusing this:\n  xs @ [x]\n  \\<in> set (enumAppend nmax ((enumAppend nmax ^^ n) (enumBase nmax)))\n  as @ bs' = xs\n\ngoal (1 subgoal):\n 1. xa \\<le> x", "proof (cases \"xs\" rule: rev_exhaust)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs @ [x]\n             \\<in> set (enumAppend nmax\n                         ((enumAppend nmax ^^ n) (enumBase nmax)));\n     as @ bs' = xs; xs = []\\<rbrakk>\n    \\<Longrightarrow> xa \\<le> x\n 2. \\<And>ys y.\n       \\<lbrakk>xs @ [x]\n                \\<in> set (enumAppend nmax\n                            ((enumAppend nmax ^^ n) (enumBase nmax)));\n        as @ bs' = xs; xs = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> x", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs @ [x]\n             \\<in> set (enumAppend nmax\n                         ((enumAppend nmax ^^ n) (enumBase nmax)));\n     as @ bs' = xs; xs = []\\<rbrakk>\n    \\<Longrightarrow> xa \\<le> x\n 2. \\<And>ys y.\n       \\<lbrakk>xs @ [x]\n                \\<in> set (enumAppend nmax\n                            ((enumAppend nmax ^^ n) (enumBase nmax)));\n        as @ bs' = xs; xs = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> x", "with xa xs'"], ["proof (chain)\npicking this:\n  xa \\<in> set as\n  as @ bs' = xs\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xa \\<in> set as\n  as @ bs' = xs\n  xs = []\n\ngoal (1 subgoal):\n 1. xa \\<le> x", "by auto"], ["proof (state)\nthis:\n  xa \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>xs @ [x]\n                \\<in> set (enumAppend nmax\n                            ((enumAppend nmax ^^ n) (enumBase nmax)));\n        as @ bs' = xs; xs = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>xs @ [x]\n                \\<in> set (enumAppend nmax\n                            ((enumAppend nmax ^^ n) (enumBase nmax)));\n        as @ bs' = xs; xs = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> x", "case (snoc ys y)"], ["proof (state)\nthis:\n  xs = ys @ [y]\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>xs @ [x]\n                \\<in> set (enumAppend nmax\n                            ((enumAppend nmax ^^ n) (enumBase nmax)));\n        as @ bs' = xs; xs = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> x", "have \"xa \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa \\<le> y", "proof (cases \"xa = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xa = y \\<Longrightarrow> xa \\<le> y\n 2. xa \\<noteq> y \\<Longrightarrow> xa \\<le> y", "case True"], ["proof (state)\nthis:\n  xa = y\n\ngoal (2 subgoals):\n 1. xa = y \\<Longrightarrow> xa \\<le> y\n 2. xa \\<noteq> y \\<Longrightarrow> xa \\<le> y", "then"], ["proof (chain)\npicking this:\n  xa = y", "show ?thesis"], ["proof (prove)\nusing this:\n  xa = y\n\ngoal (1 subgoal):\n 1. xa \\<le> y", "by auto"], ["proof (state)\nthis:\n  xa \\<le> y\n\ngoal (1 subgoal):\n 1. xa \\<noteq> y \\<Longrightarrow> xa \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xa \\<noteq> y \\<Longrightarrow> xa \\<le> y", "case False"], ["proof (state)\nthis:\n  xa \\<noteq> y\n\ngoal (1 subgoal):\n 1. xa \\<noteq> y \\<Longrightarrow> xa \\<le> y", "from xa xs'"], ["proof (chain)\npicking this:\n  xa \\<in> set as\n  as @ bs' = xs", "have \"xa \\<in> set xs\""], ["proof (prove)\nusing this:\n  xa \\<in> set as\n  as @ bs' = xs\n\ngoal (1 subgoal):\n 1. xa \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  xa \\<in> set xs\n\ngoal (1 subgoal):\n 1. xa \\<noteq> y \\<Longrightarrow> xa \\<le> y", "with False snoc"], ["proof (chain)\npicking this:\n  xa \\<noteq> y\n  xs = ys @ [y]\n  xa \\<in> set xs", "have \"xa \\<in> set ys\""], ["proof (prove)\nusing this:\n  xa \\<noteq> y\n  xs = ys @ [y]\n  xa \\<in> set xs\n\ngoal (1 subgoal):\n 1. xa \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  xa \\<in> set ys\n\ngoal (1 subgoal):\n 1. xa \\<noteq> y \\<Longrightarrow> xa \\<le> y", "with xs snoc"], ["proof (chain)\npicking this:\n  xs @ [x]\n  \\<in> set (enumAppend nmax ((enumAppend nmax ^^ n) (enumBase nmax)))\n  xs = ys @ [y]\n  xa \\<in> set ys", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [x]\n  \\<in> set (enumAppend nmax ((enumAppend nmax ^^ n) (enumBase nmax)))\n  xs = ys @ [y]\n  xa \\<in> set ys\n\ngoal (1 subgoal):\n 1. xa \\<le> y", "apply (rule_tac ih2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>xs @ [x]\n             \\<in> set (enumAppend nmax\n                         ((enumAppend nmax ^^ n) (enumBase nmax)));\n     xs = ys @ [y]; xa \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n 2. \\<lbrakk>xs @ [x]\n             \\<in> set (enumAppend nmax\n                         ((enumAppend nmax ^^ n) (enumBase nmax)));\n     xs = ys @ [y]; xa \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> ?as3 @ ?bs3 = xs\n 3. \\<lbrakk>xs @ [x]\n             \\<in> set (enumAppend nmax\n                         ((enumAppend nmax ^^ n) (enumBase nmax)));\n     xs = ys @ [y]; xa \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> xa \\<in> set ?as3\n 4. \\<lbrakk>xs @ [x]\n             \\<in> set (enumAppend nmax\n                         ((enumAppend nmax ^^ n) (enumBase nmax)));\n     xs = ys @ [y]; xa \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set ?bs3", "by (auto simp: enumAppend_def)"], ["proof (state)\nthis:\n  xa \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xa \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>xs @ [x]\n                \\<in> set (enumAppend nmax\n                            ((enumAppend nmax ^^ n) (enumBase nmax)));\n        as @ bs' = xs; xs = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> x", "with xs snoc"], ["proof (chain)\npicking this:\n  xs @ [x]\n  \\<in> set (enumAppend nmax ((enumAppend nmax ^^ n) (enumBase nmax)))\n  xs = ys @ [y]\n  xa \\<le> y", "show \"xa \\<le> x\""], ["proof (prove)\nusing this:\n  xs @ [x]\n  \\<in> set (enumAppend nmax ((enumAppend nmax ^^ n) (enumBase nmax)))\n  xs = ys @ [y]\n  xa \\<le> y\n\ngoal (1 subgoal):\n 1. xa \\<le> x", "by (auto simp: enumAppend_def split:if_split_asm)"], ["proof (state)\nthis:\n  xa \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xa \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x xs m as bs xa xb nat.\n       \\<lbrakk>\\<And>m as bs.\n                   \\<lbrakk>xs \\<in> set\n((enumAppend nmax ^^ m) (enumBase nmax));\n                    as @ bs = xs\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set as.\n  \\<forall>xa\\<in>set bs. x \\<le> xa;\n        xs @ [x]\n        \\<in> set (enumAppend nmax\n                    ((enumAppend nmax ^^ nat) (enumBase nmax)));\n        as @ bs = xs @ [x]; xa \\<in> set as; xb \\<in> set bs;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> xb", "then"], ["proof (chain)\npicking this:\n  xa \\<le> x", "show \"xa \\<le> xb\""], ["proof (prove)\nusing this:\n  xa \\<le> x\n\ngoal (1 subgoal):\n 1. xa \\<le> xb", "apply (cases \"xb = b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xa \\<le> x; xb = b\\<rbrakk> \\<Longrightarrow> xa \\<le> xb\n 2. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xa \\<le> xb", "apply (simp add: beq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xa \\<le> xb", "proof (rule_tac ih2)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xs \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n 2. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> ?as2 @ ?bs2 = xs\n 3. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xa \\<in> set ?as2\n 4. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xb \\<in> set ?bs2", "from xs"], ["proof (chain)\npicking this:\n  xs @ [x]\n  \\<in> set (enumAppend nmax ((enumAppend nmax ^^ n) (enumBase nmax)))", "show \"xs \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\""], ["proof (prove)\nusing this:\n  xs @ [x]\n  \\<in> set (enumAppend nmax ((enumAppend nmax ^^ n) (enumBase nmax)))\n\ngoal (1 subgoal):\n 1. xs \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))", "by (auto simp: enumAppend_def)"], ["proof (state)\nthis:\n  xs \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> ?as2 @ ?bs2 = xs\n 2. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xa \\<in> set ?as2\n 3. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xb \\<in> set ?bs2", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> ?as2 @ ?bs2 = xs\n 2. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xa \\<in> set ?as2\n 3. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xb \\<in> set ?bs2", "from xs'"], ["proof (chain)\npicking this:\n  as @ bs' = xs", "show \"as @ bs' = xs\""], ["proof (prove)\nusing this:\n  as @ bs' = xs\n\ngoal (1 subgoal):\n 1. as @ bs' = xs", "by auto"], ["proof (state)\nthis:\n  as @ bs' = xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xa \\<in> set as\n 2. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xb \\<in> set bs'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xa \\<in> set as\n 2. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xb \\<in> set bs'", "from xa"], ["proof (chain)\npicking this:\n  xa \\<in> set as", "show \"xa \\<in> set as\""], ["proof (prove)\nusing this:\n  xa \\<in> set as\n\ngoal (1 subgoal):\n 1. xa \\<in> set as", "by auto"], ["proof (state)\nthis:\n  xa \\<in> set as\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xb \\<in> set bs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xb \\<in> set bs'", "assume \"xb \\<noteq> b\""], ["proof (state)\nthis:\n  xb \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xa \\<le> x; xb \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> xb \\<in> set bs'", "with xb bs'"], ["proof (chain)\npicking this:\n  xb \\<in> set bs\n  bs = bs' @ [b]\n  xb \\<noteq> b", "show \"xb \\<in> set bs'\""], ["proof (prove)\nusing this:\n  xb \\<in> set bs\n  bs = bs' @ [b]\n  xb \\<noteq> b\n\ngoal (1 subgoal):\n 1. xb \\<in> set bs'", "by auto"], ["proof (state)\nthis:\n  xb \\<in> set bs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xa \\<le> xb\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enumAppend_length1: \"\\<And>ls. ls \\<in> set ((enumAppend nmax ^^ n) lss) \\<Longrightarrow>\n (\\<forall>l \\<in> set lss. |l| = k) \\<Longrightarrow> |ls| = k + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set ((enumAppend nmax ^^ n) lss);\n        \\<forall>l\\<in>set lss. |l| = k\\<rbrakk>\n       \\<Longrightarrow> |ls| = k + n", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set ((enumAppend nmax ^^ 0) lss);\n        \\<forall>l\\<in>set lss. |l| = k\\<rbrakk>\n       \\<Longrightarrow> |ls| = k + 0\n 2. \\<And>n ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>ls \\<in> set ((enumAppend nmax ^^ n) lss);\n                    \\<forall>l\\<in>set lss. |l| = k\\<rbrakk>\n                   \\<Longrightarrow> |ls| = k + n;\n        ls \\<in> set ((enumAppend nmax ^^ Suc n) lss);\n        \\<forall>l\\<in>set lss. |l| = k\\<rbrakk>\n       \\<Longrightarrow> |ls| = k + Suc n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>ls \\<in> set ((enumAppend nmax ^^ n) lss);\n                    \\<forall>l\\<in>set lss. |l| = k\\<rbrakk>\n                   \\<Longrightarrow> |ls| = k + n;\n        ls \\<in> set ((enumAppend nmax ^^ Suc n) lss);\n        \\<forall>l\\<in>set lss. |l| = k\\<rbrakk>\n       \\<Longrightarrow> |ls| = k + Suc n", "by (auto simp add:enumAppend_def split: if_split_asm)"], ["", "lemma enumAppend_length2: \"\\<And>ls. ls \\<in> set ((enumAppend nmax ^^ n) lss) \\<Longrightarrow>\n (\\<And>l. l \\<in> set lss \\<Longrightarrow> |l| = k) \\<Longrightarrow> K = k + n \\<Longrightarrow> |ls| = K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>ls \\<in> set ((enumAppend nmax ^^ n) lss);\n        \\<And>l. l \\<in> set lss \\<Longrightarrow> |l| = k;\n        K = k + n\\<rbrakk>\n       \\<Longrightarrow> |ls| = K", "by (auto simp add: enumAppend_length1)"], ["", "(*********** enum *********)"], ["", "lemma enum_enumerator:\n \"enum i j = enumerator i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Enumerator.enum i j = enumerator i j", "by(simp add: enum_def enumTab_def tabulate2_def tabulate_def)"], ["", "(*********** enumerator *********)"], ["", "lemma enumerator_hd: \"ls \\<in> set (enumerator m n) \\<Longrightarrow> hd ls = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m n) \\<Longrightarrow> hd ls = 0", "by (auto simp: enumerator_def split: if_split_asm)"], ["", "lemma enumerator_last: \"ls \\<in> set (enumerator m n) \\<Longrightarrow> last ls = (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m n) \\<Longrightarrow> last ls = n - 1", "by (auto simp: enumerator_def split: if_split_asm)"], ["", "lemma enumerator_length: \"ls \\<in> set (enumerator m n) \\<Longrightarrow> 2 \\<le> length ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m n) \\<Longrightarrow> 2 \\<le> |ls|", "by (auto simp: enumerator_def split: if_split_asm)"], ["", "lemmas set_enumerator_simps = enumerator_hd enumerator_last enumerator_length"], ["", "lemma enumerator_not_empty[dest]: \"ls \\<in> set (enumerator m n) \\<Longrightarrow> ls \\<noteq>  []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m n) \\<Longrightarrow> ls \\<noteq> []", "apply (subgoal_tac \"2 \\<le> length ls\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<in> set (enumerator m n); 2 \\<le> |ls|\\<rbrakk>\n    \\<Longrightarrow> ls \\<noteq> []\n 2. ls \\<in> set (enumerator m n) \\<Longrightarrow> 2 \\<le> |ls|", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m n) \\<Longrightarrow> 2 \\<le> |ls|", "by (rule enumerator_length)"], ["", "lemma enumerator_length2: \"ls \\<in> set (enumerator m n) \\<Longrightarrow> 2 < m \\<Longrightarrow> length ls = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (enumerator m n); 2 < m\\<rbrakk>\n    \\<Longrightarrow> |ls| = m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (enumerator m n); 2 < m\\<rbrakk>\n    \\<Longrightarrow> |ls| = m", "assume ls:\"ls \\<in> set (enumerator m n)\" and m: \"2 < m\""], ["proof (state)\nthis:\n  ls \\<in> set (enumerator m n)\n  2 < m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (enumerator m n); 2 < m\\<rbrakk>\n    \\<Longrightarrow> |ls| = m", "define k where \"k = m - 3\""], ["proof (state)\nthis:\n  k = m - 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (enumerator m n); 2 < m\\<rbrakk>\n    \\<Longrightarrow> |ls| = m", "with m"], ["proof (chain)\npicking this:\n  2 < m\n  k = m - 3", "have k: \"m = k + 3\""], ["proof (prove)\nusing this:\n  2 < m\n  k = m - 3\n\ngoal (1 subgoal):\n 1. m = k + 3", "by arith"], ["proof (state)\nthis:\n  m = k + 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (enumerator m n); 2 < m\\<rbrakk>\n    \\<Longrightarrow> |ls| = m", "with ls"], ["proof (chain)\npicking this:\n  ls \\<in> set (enumerator m n)\n  m = k + 3", "have \"ls \\<in> set (enumerator (k+3) n)\""], ["proof (prove)\nusing this:\n  ls \\<in> set (enumerator m n)\n  m = k + 3\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator (k + 3) n)", "by auto"], ["proof (state)\nthis:\n  ls \\<in> set (enumerator (k + 3) n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (enumerator m n); 2 < m\\<rbrakk>\n    \\<Longrightarrow> |ls| = m", "then"], ["proof (chain)\npicking this:\n  ls \\<in> set (enumerator (k + 3) n)", "have \"length ls = k + 3\""], ["proof (prove)\nusing this:\n  ls \\<in> set (enumerator (k + 3) n)\n\ngoal (1 subgoal):\n 1. |ls| = k + 3", "apply (auto simp: enumerator_def enumBase_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       \\<lbrakk>is \\<in> set ((enumAppend (n - 2) ^^ k)\n                               (map (\\<lambda>i. [i]) [0..<n - 2] @\n                                [[n - 2]]));\n        ls = 0 # is @ [n - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> |is| = Suc k", "apply (erule enumAppend_length2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is l.\n       \\<lbrakk>ls = 0 # is @ [n - Suc 0];\n        l \\<in> set (map (\\<lambda>i. [i]) [0..<n - 2] @ [[n - 2]])\\<rbrakk>\n       \\<Longrightarrow> |l| = ?k5 is\n 2. \\<And>is. ls = 0 # is @ [n - Suc 0] \\<Longrightarrow> Suc k = ?k5 is + k", "by auto"], ["proof (state)\nthis:\n  |ls| = k + 3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (enumerator m n); 2 < m\\<rbrakk>\n    \\<Longrightarrow> |ls| = m", "with k"], ["proof (chain)\npicking this:\n  m = k + 3\n  |ls| = k + 3", "show ?thesis"], ["proof (prove)\nusing this:\n  m = k + 3\n  |ls| = k + 3\n\ngoal (1 subgoal):\n 1. |ls| = m", "by simp"], ["proof (state)\nthis:\n  |ls| = m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enumerator_bound: \"ls \\<in> set (enumerator m nmax) \\<Longrightarrow>\n 0 < nmax \\<Longrightarrow> x \\<in> set ls \\<Longrightarrow> x < nmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (enumerator m nmax); 0 < nmax;\n     x \\<in> set ls\\<rbrakk>\n    \\<Longrightarrow> x < nmax", "apply (auto simp: enumerator_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       \\<lbrakk>0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> x < nmax", "apply (subgoal_tac \"x \\<le> nmax - 2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is.\n       \\<lbrakk>0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is;\n        x \\<le> nmax - 2\\<rbrakk>\n       \\<Longrightarrow> x < nmax\n 2. \\<And>is.\n       \\<lbrakk>0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> x \\<le> nmax - 2", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       \\<lbrakk>0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> x \\<le> nmax - 2", "apply (rule_tac enumAppend_bound_rec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>is.\n       \\<lbrakk>0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> ?ls33 is\n                         \\<in> set ((enumAppend (nmax - 2) ^^ ?n33 is)\n                                     (?lss33 is))\n 2. \\<And>is.\n       \\<lbrakk>0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set (?lss33 is).\n                            \\<forall>z\\<in>set y. z \\<le> nmax - 2\n 3. \\<And>is.\n       \\<lbrakk>0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (?ls33 is)", "by(auto simp:enumBase_simps)"], ["", "lemma enumerator_bound2: \"ls \\<in> set (enumerator m nmax) \\<Longrightarrow> 1 < nmax \\<Longrightarrow> x \\<in> set (butlast ls) \\<Longrightarrow> x < nmax - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (enumerator m nmax); 1 < nmax;\n     x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x < nmax - Suc 0", "apply (auto simp: enumerator_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       \\<lbrakk>Suc 0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> x < nmax - Suc 0", "apply (subgoal_tac \"x \\<le>  (nmax - 2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is.\n       \\<lbrakk>Suc 0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is;\n        x \\<le> nmax - 2\\<rbrakk>\n       \\<Longrightarrow> x < nmax - Suc 0\n 2. \\<And>is.\n       \\<lbrakk>Suc 0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> x \\<le> nmax - 2", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       \\<lbrakk>Suc 0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> x \\<le> nmax - 2", "apply (rule_tac enumAppend_bound_rec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>is.\n       \\<lbrakk>Suc 0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> ?ls78 is\n                         \\<in> set ((enumAppend (nmax - 2) ^^ ?n78 is)\n                                     (?lss78 is))\n 2. \\<And>is.\n       \\<lbrakk>Suc 0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set (?lss78 is).\n                            \\<forall>z\\<in>set y. z \\<le> nmax - 2\n 3. \\<And>is.\n       \\<lbrakk>Suc 0 < nmax;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        ls = 0 # is @ [nmax - Suc 0]; x \\<in> set is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (?ls78 is)", "by(auto simp:enumBase_simps)"], ["", "lemma enumerator_bound3: \"ls \\<in> set (enumerator m nmax) \\<Longrightarrow> 1 < nmax \\<Longrightarrow> last (butlast ls) < nmax - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls \\<in> set (enumerator m nmax); 1 < nmax\\<rbrakk>\n    \\<Longrightarrow> last (butlast ls) < nmax - Suc 0", "apply (case_tac \"ls\" rule: rev_exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<in> set (enumerator m nmax); 1 < nmax; ls = []\\<rbrakk>\n    \\<Longrightarrow> last (butlast ls) < nmax - Suc 0\n 2. \\<And>ys y.\n       \\<lbrakk>ls \\<in> set (enumerator m nmax); 1 < nmax;\n        ls = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> last (butlast ls) < nmax - Suc 0", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ls \\<in> set (enumerator m nmax); 1 < nmax;\n        ls = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> last (butlast ls) < nmax - Suc 0", "apply (rule_tac enumerator_bound2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>ls \\<in> set (enumerator m nmax); 1 < nmax;\n        ls = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> ?ls8 ys y \\<in> set (enumerator (?m8 ys y) nmax)\n 2. \\<And>ys y.\n       \\<lbrakk>ls \\<in> set (enumerator m nmax); 1 < nmax;\n        ls = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> 1 < nmax\n 3. \\<And>ys y.\n       \\<lbrakk>ls \\<in> set (enumerator m nmax); 1 < nmax;\n        ls = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> last (butlast ls) \\<in> set (butlast (?ls8 ys y))", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>ls \\<in> set (enumerator m nmax); 1 < nmax;\n        ls = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> 1 < nmax\n 2. \\<And>ys y.\n       \\<lbrakk>ls \\<in> set (enumerator m nmax); 1 < nmax;\n        ls = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> last (butlast ls) \\<in> set (butlast ls)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ys @ [y] \\<in> set (enumerator m nmax); Suc 0 < nmax;\n        ls = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> last ys \\<in> set ys", "apply (case_tac \"ys\" rule: rev_exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>ys @ [y] \\<in> set (enumerator m nmax); Suc 0 < nmax;\n        ls = ys @ [y]; ys = []\\<rbrakk>\n       \\<Longrightarrow> last ys \\<in> set ys\n 2. \\<And>ys y ysa ya.\n       \\<lbrakk>ys @ [y] \\<in> set (enumerator m nmax); Suc 0 < nmax;\n        ls = ys @ [y]; ys = ysa @ [ya]\\<rbrakk>\n       \\<Longrightarrow> last ys \\<in> set ys", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>[y] \\<in> set (enumerator m nmax); Suc 0 < nmax; ls = [y];\n        ys = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ys y ysa ya.\n       \\<lbrakk>ys @ [y] \\<in> set (enumerator m nmax); Suc 0 < nmax;\n        ls = ys @ [y]; ys = ysa @ [ya]\\<rbrakk>\n       \\<Longrightarrow> last ys \\<in> set ys", "apply (subgoal_tac \"2 \\<le> length (ys @ [y])\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>[y] \\<in> set (enumerator m nmax); Suc 0 < nmax; ls = [y];\n        ys = []; 2 \\<le> |ys @ [y]|\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ys y.\n       \\<lbrakk>[y] \\<in> set (enumerator m nmax); Suc 0 < nmax; ls = [y];\n        ys = []\\<rbrakk>\n       \\<Longrightarrow> 2 \\<le> |ys @ [y]|\n 3. \\<And>ys y ysa ya.\n       \\<lbrakk>ys @ [y] \\<in> set (enumerator m nmax); Suc 0 < nmax;\n        ls = ys @ [y]; ys = ysa @ [ya]\\<rbrakk>\n       \\<Longrightarrow> last ys \\<in> set ys", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>[y] \\<in> set (enumerator m nmax); Suc 0 < nmax; ls = [y];\n        ys = []\\<rbrakk>\n       \\<Longrightarrow> 2 \\<le> |ys @ [y]|\n 2. \\<And>ys y ysa ya.\n       \\<lbrakk>ys @ [y] \\<in> set (enumerator m nmax); Suc 0 < nmax;\n        ls = ys @ [y]; ys = ysa @ [ya]\\<rbrakk>\n       \\<Longrightarrow> last ys \\<in> set ys", "apply (rule_tac enumerator_length)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>[y] \\<in> set (enumerator m nmax); Suc 0 < nmax; ls = [y];\n        ys = []\\<rbrakk>\n       \\<Longrightarrow> ys @ [y]\n                         \\<in> set (enumerator (?m11 ys y) (?n11 ys y))\n 2. \\<And>ys y ysa ya.\n       \\<lbrakk>ys @ [y] \\<in> set (enumerator m nmax); Suc 0 < nmax;\n        ls = ys @ [y]; ys = ysa @ [ya]\\<rbrakk>\n       \\<Longrightarrow> last ys \\<in> set ys", "by auto"], ["", "lemma enumerator_increase: \"\\<And> as bs. ls \\<in> set (enumerator m nmax) \\<Longrightarrow>  as @ bs = ls \\<Longrightarrow> \\<forall> x \\<in> set as. \\<forall> y \\<in> set bs. x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       \\<lbrakk>ls \\<in> set (enumerator m nmax); as @ bs = ls\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set as.\n                            \\<forall>y\\<in>set bs. x \\<le> y", "apply (auto simp: enumerator_def del: Nat.diff_is_0_eq' split: if_split_asm intro: enumAppend_increase_rec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as bs is x y.\n       \\<lbrakk>ls = 0 # is @ [nmax - Suc 0];\n        as @ bs = 0 # is @ [nmax - Suc 0];\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        x \\<in> set as; y \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "apply (case_tac as)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as bs is x y.\n       \\<lbrakk>ls = 0 # is @ [nmax - Suc 0];\n        as @ bs = 0 # is @ [nmax - Suc 0];\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        x \\<in> set as; y \\<in> set bs; as = []\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<And>as bs is x y a list.\n       \\<lbrakk>ls = 0 # is @ [nmax - Suc 0];\n        as @ bs = 0 # is @ [nmax - Suc 0];\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        x \\<in> set as; y \\<in> set bs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as bs is x y a list.\n       \\<lbrakk>ls = 0 # is @ [nmax - Suc 0];\n        as @ bs = 0 # is @ [nmax - Suc 0];\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        x \\<in> set as; y \\<in> set bs; as = a # list\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as bs is x y list.\n       \\<lbrakk>ls = 0 # is @ [nmax - Suc 0];\n        list @ bs = is @ [nmax - Suc 0];\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        x = 0 \\<or> x \\<in> set list; y \\<in> set bs; as = 0 # list\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "apply (case_tac bs rule: rev_exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as bs is x y list.\n       \\<lbrakk>ls = 0 # is @ [nmax - Suc 0];\n        list @ bs = is @ [nmax - Suc 0];\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        x = 0 \\<or> x \\<in> set list; y \\<in> set bs; as = 0 # list;\n        bs = []\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<And>as bs is x y list ys ya.\n       \\<lbrakk>ls = 0 # is @ [nmax - Suc 0];\n        list @ bs = is @ [nmax - Suc 0];\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        x = 0 \\<or> x \\<in> set list; y \\<in> set bs; as = 0 # list;\n        bs = ys @ [ya]\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as bs is x y list ys ya.\n       \\<lbrakk>ls = 0 # is @ [nmax - Suc 0];\n        list @ bs = is @ [nmax - Suc 0];\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        x = 0 \\<or> x \\<in> set list; y \\<in> set bs; as = 0 # list;\n        bs = ys @ [ya]\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as bs is x y list ys.\n       \\<lbrakk>ls = 0 # is @ [nmax - Suc 0]; list @ ys = is;\n        is \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                       (enumBase (nmax - 2)));\n        x = 0 \\<or> x \\<in> set list; y = nmax - Suc 0 \\<or> y \\<in> set ys;\n        as = 0 # list; bs = ys @ [nmax - Suc 0]\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x list ys.\n       \\<lbrakk>ls = 0 # list @ ys @ [nmax - Suc 0];\n        list @ ys\n        \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                    (enumBase (nmax - 2)));\n        x \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> x \\<le> nmax - Suc 0\n 2. \\<And>x y list ys.\n       \\<lbrakk>ls = 0 # list @ ys @ [nmax - Suc 0];\n        list @ ys\n        \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                    (enumBase (nmax - 2)));\n        x \\<in> set list; y \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "apply (drule_tac enumAppend_bound_rec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x list ys.\n       \\<lbrakk>ls = 0 # list @ ys @ [nmax - Suc 0];\n        x \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set (enumBase (nmax - 2)).\n                            \\<forall>z\\<in>set y. z \\<le> nmax - 2\n 2. \\<And>x list ys.\n       \\<lbrakk>ls = 0 # list @ ys @ [nmax - Suc 0];\n        x \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> ?x17 x list ys \\<in> set (list @ ys)\n 3. \\<And>x list ys.\n       \\<lbrakk>ls = 0 # list @ ys @ [nmax - Suc 0]; x \\<in> set list;\n        ?x17 x list ys \\<le> nmax - 2\\<rbrakk>\n       \\<Longrightarrow> x \\<le> nmax - Suc 0\n 4. \\<And>x y list ys.\n       \\<lbrakk>ls = 0 # list @ ys @ [nmax - Suc 0];\n        list @ ys\n        \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                    (enumBase (nmax - 2)));\n        x \\<in> set list; y \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "apply (auto simp:enumBase_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y list ys.\n       \\<lbrakk>ls = 0 # list @ ys @ [nmax - Suc 0];\n        list @ ys\n        \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3))\n                    (enumBase (nmax - 2)));\n        x \\<in> set list; y \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "by (auto dest!: enumAppend_increase_rec)"], ["", "lemma enumerator_increasing: \"ls \\<in> set (enumerator m nmax) \\<Longrightarrow> increasing ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax) \\<Longrightarrow> increasing ls", "apply (rule increasing3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax) \\<Longrightarrow>\n    \\<forall>as bs.\n       ls = as @ bs \\<longrightarrow>\n       (\\<forall>x\\<in>set as. \\<forall>y\\<in>set bs. x \\<le> y)", "by (auto dest: enumerator_increase)"], ["", "definition incrIndexList :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n \"incrIndexList ls m nmax \\<equiv>\n  1 < m \\<and> 1 < nmax \\<and>\n  hd ls = 0 \\<and> last ls = (nmax - 1) \\<and> length ls = m\n \\<and> last (butlast ls) < last ls \\<and> increasing ls\""], ["", "lemma incrIndexList_1lem[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> Suc 0 < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow> Suc 0 < m", "by (unfold incrIndexList_def) simp"], ["", "lemma incrIndexList_1len[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> Suc 0 < nmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow> Suc 0 < nmax", "by (unfold incrIndexList_def) simp"], ["", "lemma incrIndexList_help2[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> hd ls = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow> hd ls = 0", "by (unfold incrIndexList_def) simp"], ["", "lemma incrIndexList_help21[simp]: \"incrIndexList (l # ls) m nmax \\<Longrightarrow> l = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList (l # ls) m nmax \\<Longrightarrow> l = 0", "by (auto dest: incrIndexList_help2)"], ["", "lemma incrIndexList_help3[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> last ls = (nmax - (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow> last ls = nmax - Suc 0", "by (unfold incrIndexList_def)  simp"], ["", "lemma incrIndexList_help4[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> length ls = m \""], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow> |ls| = m", "by (unfold incrIndexList_def)  simp"], ["", "lemma incrIndexList_help5[intro]: \"incrIndexList ls m nmax \\<Longrightarrow>  last (butlast ls) < nmax - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow>\n    last (butlast ls) < nmax - Suc 0", "by (unfold incrIndexList_def) auto"], ["", "lemma incrIndexList_help6[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> increasing ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow> increasing ls", "by (unfold incrIndexList_def) simp"], ["", "lemma incrIndexList_help7[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> ls \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow> ls \\<noteq> []", "apply (subgoal_tac \"length ls \\<noteq>  0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>incrIndexList ls m nmax; |ls| \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ls \\<noteq> []\n 2. incrIndexList ls m nmax \\<Longrightarrow> |ls| \\<noteq> 0", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow> |ls| \\<noteq> 0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow> 0 < m", "apply (subgoal_tac \"1 < m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>incrIndexList ls m nmax; 1 < m\\<rbrakk> \\<Longrightarrow> 0 < m\n 2. incrIndexList ls m nmax \\<Longrightarrow> 1 < m", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow> 1 < m", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma incrIndexList_help71[simp]: \"\\<not> incrIndexList [] m nmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> incrIndexList [] m nmax", "by (auto dest: incrIndexList_help7)"], ["", "lemma incrIndexList_help8[simp]: \"incrIndexList ls m nmax \\<Longrightarrow> butlast ls \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax \\<Longrightarrow> butlast ls \\<noteq> []", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; \\<not> butlast ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "assume props: \"incrIndexList ls m nmax\" and butl: \"\\<not> butlast ls \\<noteq> []\""], ["proof (state)\nthis:\n  incrIndexList ls m nmax\n  \\<not> butlast ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; \\<not> butlast ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  incrIndexList ls m nmax\n  \\<not> butlast ls \\<noteq> []", "have \"ls \\<noteq> []\""], ["proof (prove)\nusing this:\n  incrIndexList ls m nmax\n  \\<not> butlast ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. ls \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; \\<not> butlast ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ls \\<noteq> []", "have ls': \"ls = (butlast ls) @ [last ls]\""], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. ls = butlast ls @ [last ls]", "by auto"], ["proof (state)\nthis:\n  ls = butlast ls @ [last ls]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; \\<not> butlast ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "define l where \"l = last ls\""], ["proof (state)\nthis:\n  l = last ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; \\<not> butlast ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "with butl ls'"], ["proof (chain)\npicking this:\n  \\<not> butlast ls \\<noteq> []\n  ls = butlast ls @ [last ls]\n  l = last ls", "have \"ls = [l]\""], ["proof (prove)\nusing this:\n  \\<not> butlast ls \\<noteq> []\n  ls = butlast ls @ [last ls]\n  l = last ls\n\ngoal (1 subgoal):\n 1. ls = [l]", "by auto"], ["proof (state)\nthis:\n  ls = [l]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; \\<not> butlast ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ls = [l]", "have \"length ls = 1\""], ["proof (prove)\nusing this:\n  ls = [l]\n\ngoal (1 subgoal):\n 1. |ls| = 1", "by auto"], ["proof (state)\nthis:\n  |ls| = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; \\<not> butlast ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "with props"], ["proof (chain)\npicking this:\n  incrIndexList ls m nmax\n  |ls| = 1", "have \"m = 1\""], ["proof (prove)\nusing this:\n  incrIndexList ls m nmax\n  |ls| = 1\n\ngoal (1 subgoal):\n 1. m = 1", "by auto"], ["proof (state)\nthis:\n  m = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; \\<not> butlast ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> False", "with props"], ["proof (chain)\npicking this:\n  incrIndexList ls m nmax\n  m = 1", "show \"False\""], ["proof (prove)\nusing this:\n  incrIndexList ls m nmax\n  m = 1\n\ngoal (1 subgoal):\n 1. False", "by (auto dest: incrIndexList_1lem)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma incrIndexList_help81[simp]: \"\\<not> incrIndexList [l] m nmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> incrIndexList [l] m nmax", "by (auto dest: incrIndexList_help8)"], ["", "lemma incrIndexList_help9[intro]: \"(incrIndexList ls m nmax)  \\<Longrightarrow>\n  x \\<in> set (butlast ls) \\<Longrightarrow> x \\<le> nmax - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "assume props: \"(incrIndexList ls m nmax)\"  and x: \"x \\<in> set (butlast ls)\""], ["proof (state)\nthis:\n  incrIndexList ls m nmax\n  x \\<in> set (butlast ls)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "then"], ["proof (chain)\npicking this:\n  incrIndexList ls m nmax\n  x \\<in> set (butlast ls)", "have \"last (butlast ls) < last ls\""], ["proof (prove)\nusing this:\n  incrIndexList ls m nmax\n  x \\<in> set (butlast ls)\n\ngoal (1 subgoal):\n 1. last (butlast ls) < last ls", "by auto"], ["proof (state)\nthis:\n  last (butlast ls) < last ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "with props"], ["proof (chain)\npicking this:\n  incrIndexList ls m nmax\n  last (butlast ls) < last ls", "have \"last (butlast ls) < nmax - 1\""], ["proof (prove)\nusing this:\n  incrIndexList ls m nmax\n  last (butlast ls) < last ls\n\ngoal (1 subgoal):\n 1. last (butlast ls) < nmax - 1", "by auto"], ["proof (state)\nthis:\n  last (butlast ls) < nmax - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "then"], ["proof (chain)\npicking this:\n  last (butlast ls) < nmax - 1", "have leq: \"last (butlast ls) \\<le>  nmax - 2\""], ["proof (prove)\nusing this:\n  last (butlast ls) < nmax - 1\n\ngoal (1 subgoal):\n 1. last (butlast ls) \\<le> nmax - 2", "by arith"], ["proof (state)\nthis:\n  last (butlast ls) \\<le> nmax - 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "from props"], ["proof (chain)\npicking this:\n  incrIndexList ls m nmax", "have \"ls \\<noteq> []\""], ["proof (prove)\nusing this:\n  incrIndexList ls m nmax\n\ngoal (1 subgoal):\n 1. ls \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "then"], ["proof (chain)\npicking this:\n  ls \\<noteq> []", "have ls1: \"ls = butlast ls @ [last ls]\""], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. ls = butlast ls @ [last ls]", "by auto"], ["proof (state)\nthis:\n  ls = butlast ls @ [last ls]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "define ls' where \"ls' = butlast (butlast ls)\""], ["proof (state)\nthis:\n  ls' = butlast (butlast ls)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "define last2 where \"last2 = last (butlast ls)\""], ["proof (state)\nthis:\n  last2 = last (butlast ls)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "define last1 where \"last1 = last ls\""], ["proof (state)\nthis:\n  last1 = last ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "from props"], ["proof (chain)\npicking this:\n  incrIndexList ls m nmax", "have \"butlast ls \\<noteq> []\""], ["proof (prove)\nusing this:\n  incrIndexList ls m nmax\n\ngoal (1 subgoal):\n 1. butlast ls \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  butlast ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "with ls'_def last2_def"], ["proof (chain)\npicking this:\n  ls' = butlast (butlast ls)\n  last2 = last (butlast ls)\n  butlast ls \\<noteq> []", "have bls: \"butlast ls = ls' @ [last2]\""], ["proof (prove)\nusing this:\n  ls' = butlast (butlast ls)\n  last2 = last (butlast ls)\n  butlast ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. butlast ls = ls' @ [last2]", "by auto"], ["proof (state)\nthis:\n  butlast ls = ls' @ [last2]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "with last1_def ls1 props"], ["proof (chain)\npicking this:\n  last1 = last ls\n  ls = butlast ls @ [last ls]\n  incrIndexList ls m nmax\n  butlast ls = ls' @ [last2]", "have ls3: \"ls = ls' @ [last2] @ [last1]\""], ["proof (prove)\nusing this:\n  last1 = last ls\n  ls = butlast ls @ [last ls]\n  incrIndexList ls m nmax\n  butlast ls = ls' @ [last2]\n\ngoal (1 subgoal):\n 1. ls = ls' @ [last2] @ [last1]", "by auto"], ["proof (state)\nthis:\n  ls = ls' @ [last2] @ [last1]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "from props"], ["proof (chain)\npicking this:\n  incrIndexList ls m nmax", "have \"increasing ls\""], ["proof (prove)\nusing this:\n  incrIndexList ls m nmax\n\ngoal (1 subgoal):\n 1. increasing ls", "by auto"], ["proof (state)\nthis:\n  increasing ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "with ls3"], ["proof (chain)\npicking this:\n  ls = ls' @ [last2] @ [last1]\n  increasing ls", "have increasing: \"increasing (ls' @ ([last2] @ [last1]))\""], ["proof (prove)\nusing this:\n  ls = ls' @ [last2] @ [last1]\n  increasing ls\n\ngoal (1 subgoal):\n 1. increasing (ls' @ [last2] @ [last1])", "by auto"], ["proof (state)\nthis:\n  increasing (ls' @ [last2] @ [last1])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "then"], ["proof (chain)\npicking this:\n  increasing (ls' @ [last2] @ [last1])", "have \"x \\<in> set ls' \\<Longrightarrow> x \\<le> last2\""], ["proof (prove)\nusing this:\n  increasing (ls' @ [last2] @ [last1])\n\ngoal (1 subgoal):\n 1. x \\<in> set ls' \\<Longrightarrow> x \\<le> last2", "by (auto intro: increasing2)"], ["proof (state)\nthis:\n  x \\<in> set ls' \\<Longrightarrow> x \\<le> last2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "then"], ["proof (chain)\npicking this:\n  x \\<in> set ls' \\<Longrightarrow> x \\<le> last2", "have \"x \\<in> set (ls' @ [last2]) \\<Longrightarrow> x \\<le> last2\""], ["proof (prove)\nusing this:\n  x \\<in> set ls' \\<Longrightarrow> x \\<le> last2\n\ngoal (1 subgoal):\n 1. x \\<in> set (ls' @ [last2]) \\<Longrightarrow> x \\<le> last2", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (ls' @ [last2]) \\<Longrightarrow> x \\<le> last2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "with bls x"], ["proof (chain)\npicking this:\n  butlast ls = ls' @ [last2]\n  x \\<in> set (butlast ls)\n  x \\<in> set (ls' @ [last2]) \\<Longrightarrow> x \\<le> last2", "have \"x \\<le> last2\""], ["proof (prove)\nusing this:\n  butlast ls = ls' @ [last2]\n  x \\<in> set (butlast ls)\n  x \\<in> set (ls' @ [last2]) \\<Longrightarrow> x \\<le> last2\n\ngoal (1 subgoal):\n 1. x \\<le> last2", "by auto"], ["proof (state)\nthis:\n  x \\<le> last2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set (butlast ls)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> nmax - 2", "with leq last2_def"], ["proof (chain)\npicking this:\n  last (butlast ls) \\<le> nmax - 2\n  last2 = last (butlast ls)\n  x \\<le> last2", "show ?thesis"], ["proof (prove)\nusing this:\n  last (butlast ls) \\<le> nmax - 2\n  last2 = last (butlast ls)\n  x \\<le> last2\n\ngoal (1 subgoal):\n 1. x \\<le> nmax - 2", "by auto"], ["proof (state)\nthis:\n  x \\<le> nmax - 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma incrIndexList_help10[intro]: \"(incrIndexList ls m nmax)  \\<Longrightarrow>\n  x \\<in> set ls \\<Longrightarrow> x < nmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set ls\\<rbrakk>\n    \\<Longrightarrow> x < nmax", "apply (cases ls rule: rev_exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>incrIndexList ls m nmax; x \\<in> set ls; ls = []\\<rbrakk>\n    \\<Longrightarrow> x < nmax\n 2. \\<And>ys y.\n       \\<lbrakk>incrIndexList ls m nmax; x \\<in> set ls;\n        ls = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> x < nmax", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>incrIndexList (ys @ [x]) m nmax; ls = ys @ [x]\\<rbrakk>\n       \\<Longrightarrow> x < nmax\n 2. \\<And>ys y.\n       \\<lbrakk>incrIndexList (ys @ [y]) m nmax; ls = ys @ [y];\n        x \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> x < nmax", "apply (frule incrIndexList_help3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>incrIndexList (ys @ [x]) m nmax; ls = ys @ [x];\n        last (ys @ [x]) = nmax - Suc 0\\<rbrakk>\n       \\<Longrightarrow> x < nmax\n 2. \\<And>ys y.\n       \\<lbrakk>incrIndexList (ys @ [y]) m nmax; ls = ys @ [y];\n        x \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> x < nmax", "apply (auto dest: incrIndexList_1len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>incrIndexList (ys @ [y]) m nmax; ls = ys @ [y];\n        x \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> x < nmax", "apply (frule incrIndexList_help9)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>incrIndexList (ys @ [y]) m nmax; ls = ys @ [y];\n        x \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> ?x9 ys y \\<in> set (butlast (ys @ [y]))\n 2. \\<And>ys y.\n       \\<lbrakk>incrIndexList (ys @ [y]) m nmax; ls = ys @ [y];\n        x \\<in> set ys; ?x9 ys y \\<le> nmax - 2\\<rbrakk>\n       \\<Longrightarrow> x < nmax", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>incrIndexList (ys @ [y]) m nmax; ls = ys @ [y];\n        x \\<in> set ys; x \\<le> nmax - 2\\<rbrakk>\n       \\<Longrightarrow> x < nmax", "apply (drule incrIndexList_1len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>ls = ys @ [y]; x \\<in> set ys; x \\<le> nmax - 2;\n        Suc 0 < nmax\\<rbrakk>\n       \\<Longrightarrow> x < nmax", "by arith"], ["", "lemma enumerator_correctness: \"2 < m \\<Longrightarrow> 1 < nmax \\<Longrightarrow>\n  ls \\<in> set (enumerator m nmax) \\<Longrightarrow>\n  incrIndexList ls m nmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 < m; 1 < nmax; ls \\<in> set (enumerator m nmax)\\<rbrakk>\n    \\<Longrightarrow> incrIndexList ls m nmax", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 < m; 1 < nmax; ls \\<in> set (enumerator m nmax)\\<rbrakk>\n    \\<Longrightarrow> incrIndexList ls m nmax", "assume m: \"2 < m\" and nmax: \"1 < nmax\" and enum: \"ls \\<in> set (enumerator m nmax)\""], ["proof (state)\nthis:\n  2 < m\n  1 < nmax\n  ls \\<in> set (enumerator m nmax)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 < m; 1 < nmax; ls \\<in> set (enumerator m nmax)\\<rbrakk>\n    \\<Longrightarrow> incrIndexList ls m nmax", "then"], ["proof (chain)\npicking this:\n  2 < m\n  1 < nmax\n  ls \\<in> set (enumerator m nmax)", "have \"(hd ls = 0 \\<and> last ls = (nmax - 1) \\<and> length ls = m \\<and> last (butlast ls) < last ls \\<and>  increasing ls)\""], ["proof (prove)\nusing this:\n  2 < m\n  1 < nmax\n  ls \\<in> set (enumerator m nmax)\n\ngoal (1 subgoal):\n 1. hd ls = 0 \\<and>\n    last ls = nmax - 1 \\<and>\n    |ls| = m \\<and> last (butlast ls) < last ls \\<and> increasing ls", "by (auto intro: enumerator_increasing enumerator_hd enumerator_last enumerator_length2 enumerator_bound3 simp: set_enumerator_simps)"], ["proof (state)\nthis:\n  hd ls = 0 \\<and>\n  last ls = nmax - 1 \\<and>\n  |ls| = m \\<and> last (butlast ls) < last ls \\<and> increasing ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 < m; 1 < nmax; ls \\<in> set (enumerator m nmax)\\<rbrakk>\n    \\<Longrightarrow> incrIndexList ls m nmax", "with m nmax"], ["proof (chain)\npicking this:\n  2 < m\n  1 < nmax\n  hd ls = 0 \\<and>\n  last ls = nmax - 1 \\<and>\n  |ls| = m \\<and> last (butlast ls) < last ls \\<and> increasing ls", "show ?thesis"], ["proof (prove)\nusing this:\n  2 < m\n  1 < nmax\n  hd ls = 0 \\<and>\n  last ls = nmax - 1 \\<and>\n  |ls| = m \\<and> last (butlast ls) < last ls \\<and> increasing ls\n\ngoal (1 subgoal):\n 1. incrIndexList ls m nmax", "by (unfold incrIndexList_def) auto"], ["proof (state)\nthis:\n  incrIndexList ls m nmax\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enumerator_completeness_help: \"\\<And> ls. increasing ls \\<Longrightarrow> ls \\<noteq> [] \\<Longrightarrow> length ls = Suc ks \\<Longrightarrow> list_all (\\<lambda>x. x < Suc nmax) ls \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ ks) (enumBase nmax))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ ks)\n  (enumBase nmax))", "proof (induct ks)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ls.\n       \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc 0;\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ 0)\n  (enumBase nmax))\n 2. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "case 0"], ["proof (state)\nthis:\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc 0\n  list_all (\\<lambda>x. x < Suc nmax) ls\n\ngoal (2 subgoals):\n 1. \\<And>ls.\n       \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc 0;\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ 0)\n  (enumBase nmax))\n 2. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "assume \"increasing ls\" \"ls \\<noteq> []\" \"length ls = Suc 0\" \"list_all (\\<lambda>x. x < Suc nmax) ls\""], ["proof (state)\nthis:\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc 0\n  list_all (\\<lambda>x. x < Suc nmax) ls\n\ngoal (2 subgoals):\n 1. \\<And>ls.\n       \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc 0;\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ 0)\n  (enumBase nmax))\n 2. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "then"], ["proof (chain)\npicking this:\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc 0\n  list_all (\\<lambda>x. x < Suc nmax) ls", "have \"\\<exists> x. ls = [x]\""], ["proof (prove)\nusing this:\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc 0\n  list_all (\\<lambda>x. x < Suc nmax) ls\n\ngoal (1 subgoal):\n 1. \\<exists>x. ls = [x]", "apply (case_tac \"ls::nat list\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc 0;\n     list_all (\\<lambda>x. x < Suc nmax) ls; ls = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. ls = [x]\n 2. \\<And>a list.\n       \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc 0;\n        list_all (\\<lambda>x. x < Suc nmax) ls; ls = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. ls = [x]", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. ls = [x]\n\ngoal (2 subgoals):\n 1. \\<And>ls.\n       \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc 0;\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ 0)\n  (enumBase nmax))\n 2. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. ls = [x]", "obtain x where ls1: \"ls = [x]\""], ["proof (prove)\nusing this:\n  \\<exists>x. ls = [x]\n\ngoal (1 subgoal):\n 1. (\\<And>x. ls = [x] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  ls = [x]\n\ngoal (2 subgoals):\n 1. \\<And>ls.\n       \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc 0;\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ 0)\n  (enumBase nmax))\n 2. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "with 0"], ["proof (chain)\npicking this:\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc 0\n  list_all (\\<lambda>x. x < Suc nmax) ls\n  ls = [x]", "have \"x < Suc nmax\""], ["proof (prove)\nusing this:\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc 0\n  list_all (\\<lambda>x. x < Suc nmax) ls\n  ls = [x]\n\ngoal (1 subgoal):\n 1. x < Suc nmax", "by auto"], ["proof (state)\nthis:\n  x < Suc nmax\n\ngoal (2 subgoals):\n 1. \\<And>ls.\n       \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc 0;\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ 0)\n  (enumBase nmax))\n 2. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "with ls1"], ["proof (chain)\npicking this:\n  ls = [x]\n  x < Suc nmax", "show ?case"], ["proof (prove)\nusing this:\n  ls = [x]\n  x < Suc nmax\n\ngoal (1 subgoal):\n 1. ls \\<in> set ((enumAppend nmax ^^ 0) (enumBase nmax))", "apply (simp add: enumBase_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ls = [x]; x < Suc nmax\\<rbrakk>\n    \\<Longrightarrow> x = nmax \\<or>\n                      [x] \\<in> (\\<lambda>x. [x]) ` {0..<nmax}", "by auto"], ["proof (state)\nthis:\n  ls \\<in> set ((enumAppend nmax ^^ 0) (enumBase nmax))\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "define ls' where \"ls' = butlast ls\""], ["proof (state)\nthis:\n  ls' = butlast ls\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "define l where \"l = last ls\""], ["proof (state)\nthis:\n  l = last ls\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "define ll where \"ll = last ls'\""], ["proof (state)\nthis:\n  ll = last ls'\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "define bl where \"bl = butlast ls'\""], ["proof (state)\nthis:\n  bl = butlast ls'\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "define ls'list where \"ls'list = (enumAppend nmax ^^ n) (enumBase nmax)\""], ["proof (state)\nthis:\n  ls'list = (enumAppend nmax ^^ n) (enumBase nmax)\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "then"], ["proof (chain)\npicking this:\n  ls'list = (enumAppend nmax ^^ n) (enumBase nmax)", "have short: \"(enumAppend nmax ^^ n) (enumBase nmax) = ls'list\""], ["proof (prove)\nusing this:\n  ls'list = (enumAppend nmax ^^ n) (enumBase nmax)\n\ngoal (1 subgoal):\n 1. (enumAppend nmax ^^ n) (enumBase nmax) = ls'list", "by simp"], ["proof (state)\nthis:\n  (enumAppend nmax ^^ n) (enumBase nmax) = ls'list\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls", "have \"ls \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls\n\ngoal (1 subgoal):\n 1. ls \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "then"], ["proof (chain)\npicking this:\n  ls \\<noteq> []", "have \"ls = butlast ls @ [last ls]\""], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. ls = butlast ls @ [last ls]", "by auto"], ["proof (state)\nthis:\n  ls = butlast ls @ [last ls]\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "with ls'_def l_def"], ["proof (chain)\npicking this:\n  ls' = butlast ls\n  l = last ls\n  ls = butlast ls @ [last ls]", "have ls1: \"ls = ls' @ [l]\""], ["proof (prove)\nusing this:\n  ls' = butlast ls\n  l = last ls\n  ls = butlast ls @ [last ls]\n\ngoal (1 subgoal):\n 1. ls = ls' @ [l]", "by auto"], ["proof (state)\nthis:\n  ls = ls' @ [l]\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls\n  ls = ls' @ [l]", "have \"length ls' = Suc n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls\n  ls = ls' @ [l]\n\ngoal (1 subgoal):\n 1. |ls'| = Suc n", "by auto"], ["proof (state)\nthis:\n  |ls'| = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "then"], ["proof (chain)\npicking this:\n  |ls'| = Suc n", "have ls'ne: \"ls' \\<noteq> []\""], ["proof (prove)\nusing this:\n  |ls'| = Suc n\n\ngoal (1 subgoal):\n 1. ls' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ls' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "with ll_def bl_def"], ["proof (chain)\npicking this:\n  ll = last ls'\n  bl = butlast ls'\n  ls' \\<noteq> []", "have ls'1: \"ls' = bl @ [ll]\""], ["proof (prove)\nusing this:\n  ll = last ls'\n  bl = butlast ls'\n  ls' \\<noteq> []\n\ngoal (1 subgoal):\n 1. ls' = bl @ [ll]", "by auto"], ["proof (state)\nthis:\n  ls' = bl @ [ll]\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "then"], ["proof (chain)\npicking this:\n  ls' = bl @ [ll]", "have ll_in_ls': \"ll \\<in> set ls'\""], ["proof (prove)\nusing this:\n  ls' = bl @ [ll]\n\ngoal (1 subgoal):\n 1. ll \\<in> set ls'", "by simp"], ["proof (state)\nthis:\n  ll \\<in> set ls'\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "from Suc ls1"], ["proof (chain)\npicking this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls\n  ls = ls' @ [l]", "have \"list_all (\\<lambda>x. x < Suc nmax) ls'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls\n  ls = ls' @ [l]\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x < Suc nmax) ls'", "by auto"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x < Suc nmax) ls'\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "with ll_in_ls'"], ["proof (chain)\npicking this:\n  ll \\<in> set ls'\n  list_all (\\<lambda>x. x < Suc nmax) ls'", "have \"ll < Suc nmax\""], ["proof (prove)\nusing this:\n  ll \\<in> set ls'\n  list_all (\\<lambda>x. x < Suc nmax) ls'\n\ngoal (1 subgoal):\n 1. ll < Suc nmax", "by (induct ls') auto"], ["proof (state)\nthis:\n  ll < Suc nmax\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "with ll_def"], ["proof (chain)\npicking this:\n  ll = last ls'\n  ll < Suc nmax", "have llsmall: \"last ls' \\<le> nmax\""], ["proof (prove)\nusing this:\n  ll = last ls'\n  ll < Suc nmax\n\ngoal (1 subgoal):\n 1. last ls' \\<le> nmax", "by auto"], ["proof (state)\nthis:\n  last ls' \\<le> nmax\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "from ls1"], ["proof (chain)\npicking this:\n  ls = ls' @ [l]", "have l_in_ls: \"l \\<in> set ls\""], ["proof (prove)\nusing this:\n  ls = ls' @ [l]\n\ngoal (1 subgoal):\n 1. l \\<in> set ls", "by auto"], ["proof (state)\nthis:\n  l \\<in> set ls\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls", "have \"list_all (\\<lambda>x. x < Suc nmax) ls\""], ["proof (prove)\nusing this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x < Suc nmax) ls", "by auto"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x < Suc nmax) ls\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "with l_in_ls"], ["proof (chain)\npicking this:\n  l \\<in> set ls\n  list_all (\\<lambda>x. x < Suc nmax) ls", "have \"l < Suc nmax\""], ["proof (prove)\nusing this:\n  l \\<in> set ls\n  list_all (\\<lambda>x. x < Suc nmax) ls\n\ngoal (1 subgoal):\n 1. l < Suc nmax", "by (induct ls) auto"], ["proof (state)\nthis:\n  l < Suc nmax\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "then"], ["proof (chain)\npicking this:\n  l < Suc nmax", "have lo: \"l \\<le> nmax\""], ["proof (prove)\nusing this:\n  l < Suc nmax\n\ngoal (1 subgoal):\n 1. l \\<le> nmax", "by auto"], ["proof (state)\nthis:\n  l \\<le> nmax\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "from Suc ls1 ls'1"], ["proof (chain)\npicking this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls\n  ls = ls' @ [l]\n  ls' = bl @ [ll]", "have \"increasing ((bl @ [ll]) @ [l])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls\n  ls = ls' @ [l]\n  ls' = bl @ [ll]\n\ngoal (1 subgoal):\n 1. increasing ((bl @ [ll]) @ [l])", "by auto"], ["proof (state)\nthis:\n  increasing ((bl @ [ll]) @ [l])\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "then"], ["proof (chain)\npicking this:\n  increasing ((bl @ [ll]) @ [l])", "have \"ll \\<le>  l\""], ["proof (prove)\nusing this:\n  increasing ((bl @ [ll]) @ [l])\n\ngoal (1 subgoal):\n 1. ll \\<le> l", "by (rule increasing2) auto"], ["proof (state)\nthis:\n  ll \\<le> l\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "with ll_def"], ["proof (chain)\npicking this:\n  ll = last ls'\n  ll \\<le> l", "have lu: \"last ls' \\<le> l\""], ["proof (prove)\nusing this:\n  ll = last ls'\n  ll \\<le> l\n\ngoal (1 subgoal):\n 1. last ls' \\<le> l", "by simp"], ["proof (state)\nthis:\n  last ls' \\<le> l\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "from Suc ls1"], ["proof (chain)\npicking this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls\n  ls = ls' @ [l]", "have vors: \"ls' \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>increasing ?ls; ?ls \\<noteq> []; |?ls| = Suc n;\n   list_all (\\<lambda>x. x < Suc nmax) ?ls\\<rbrakk>\n  \\<Longrightarrow> ?ls \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n  increasing ls\n  ls \\<noteq> []\n  |ls| = Suc (Suc n)\n  list_all (\\<lambda>x. x < Suc nmax) ls\n  ls = ls' @ [l]\n\ngoal (1 subgoal):\n 1. ls' \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))", "by (rule_tac Suc) (auto intro: increasing4)"], ["proof (state)\nthis:\n  ls' \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "with short"], ["proof (chain)\npicking this:\n  (enumAppend nmax ^^ n) (enumBase nmax) = ls'list\n  ls' \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))", "have \"ls' \\<in> set ls'list\""], ["proof (prove)\nusing this:\n  (enumAppend nmax ^^ n) (enumBase nmax) = ls'list\n  ls' \\<in> set ((enumAppend nmax ^^ n) (enumBase nmax))\n\ngoal (1 subgoal):\n 1. ls' \\<in> set ls'list", "by  auto"], ["proof (state)\nthis:\n  ls' \\<in> set ls'list\n\ngoal (1 subgoal):\n 1. \\<And>ks ls.\n       \\<lbrakk>\\<And>ls.\n                   \\<lbrakk>increasing ls; ls \\<noteq> []; |ls| = Suc ks;\n                    list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n                   \\<Longrightarrow> ls \\<in> set\n         ((enumAppend nmax ^^ ks) (enumBase nmax));\n        increasing ls; ls \\<noteq> []; |ls| = Suc (Suc ks);\n        list_all (\\<lambda>x. x < Suc nmax) ls\\<rbrakk>\n       \\<Longrightarrow> ls \\<in> set ((enumAppend nmax ^^ Suc ks)\n  (enumBase nmax))", "with short llsmall ls1 lo lu"], ["proof (chain)\npicking this:\n  (enumAppend nmax ^^ n) (enumBase nmax) = ls'list\n  last ls' \\<le> nmax\n  ls = ls' @ [l]\n  l \\<le> nmax\n  last ls' \\<le> l\n  ls' \\<in> set ls'list", "show ?case"], ["proof (prove)\nusing this:\n  (enumAppend nmax ^^ n) (enumBase nmax) = ls'list\n  last ls' \\<le> nmax\n  ls = ls' @ [l]\n  l \\<le> nmax\n  last ls' \\<le> l\n  ls' \\<in> set ls'list\n\ngoal (1 subgoal):\n 1. ls \\<in> set ((enumAppend nmax ^^ Suc n) (enumBase nmax))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(enumAppend nmax ^^ n) (enumBase nmax) = ls'list;\n     ls = ls' @ [l]; l \\<le> nmax; last ls' \\<le> l;\n     ls' \\<in> set ls'list\\<rbrakk>\n    \\<Longrightarrow> ls' @ [l] \\<in> set (enumAppend nmax ls'list)", "apply (simp add: enumAppend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(enumAppend nmax ^^ n) (enumBase nmax) = ls'list;\n     ls = ls' @ [l]; l \\<le> nmax; last ls' \\<le> l;\n     ls' \\<in> set ls'list\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>set ls'list.\n                         ls' @ [l]\n                         \\<in> (\\<lambda>xa. x @ [xa]) `\n                               {xa.\n                                last x \\<le> nmax \\<and>\n                                (xa = nmax \\<or>\n                                 last x \\<le> xa \\<and> xa < nmax)}", "apply (intro bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(enumAppend nmax ^^ n) (enumBase nmax) = ls'list;\n     ls = ls' @ [l]; l \\<le> nmax; last ls' \\<le> l;\n     ls' \\<in> set ls'list\\<rbrakk>\n    \\<Longrightarrow> ls' @ [l]\n                      \\<in> (\\<lambda>x. ?x14 @ [x]) `\n                            {x. last ?x14 \\<le> nmax \\<and>\n                                (x = nmax \\<or>\n                                 last ?x14 \\<le> x \\<and> x < nmax)}\n 2. \\<lbrakk>(enumAppend nmax ^^ n) (enumBase nmax) = ls'list;\n     ls = ls' @ [l]; l \\<le> nmax; last ls' \\<le> l;\n     ls' \\<in> set ls'list\\<rbrakk>\n    \\<Longrightarrow> ?x14 \\<in> set ls'list", "by auto"], ["proof (state)\nthis:\n  ls \\<in> set ((enumAppend nmax ^^ Suc n) (enumBase nmax))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enumerator_completeness: \"2 < m \\<Longrightarrow> incrIndexList ls m nmax \\<Longrightarrow>\n  ls \\<in> set (enumerator m nmax)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 < m; incrIndexList ls m nmax\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (enumerator m nmax)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 < m; incrIndexList ls m nmax\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (enumerator m nmax)", "assume m: \"2 < m\" and props: \"incrIndexList ls m nmax\""], ["proof (state)\nthis:\n  2 < m\n  incrIndexList ls m nmax\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 < m; incrIndexList ls m nmax\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (enumerator m nmax)", "then"], ["proof (chain)\npicking this:\n  2 < m\n  incrIndexList ls m nmax", "have props': \"(hd ls = 0 \\<and> last ls = (nmax - 1)\n   \\<and> length ls = m \\<and> last (butlast ls) < last ls \\<and>  increasing ls)\""], ["proof (prove)\nusing this:\n  2 < m\n  incrIndexList ls m nmax\n\ngoal (1 subgoal):\n 1. hd ls = 0 \\<and>\n    last ls = nmax - 1 \\<and>\n    |ls| = m \\<and> last (butlast ls) < last ls \\<and> increasing ls", "by (unfold incrIndexList_def) auto"], ["proof (state)\nthis:\n  hd ls = 0 \\<and>\n  last ls = nmax - 1 \\<and>\n  |ls| = m \\<and> last (butlast ls) < last ls \\<and> increasing ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 < m; incrIndexList ls m nmax\\<rbrakk>\n    \\<Longrightarrow> ls \\<in> set (enumerator m nmax)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "have props'': \"hd ls = 0 \\<and> last ls = (nmax - 1) \\<and> length ls = m \\<and>\n       increasing ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls", "by (auto simp: props')"], ["proof (state)\nthis:\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "show \"ls \\<in> set (enumerator m nmax)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "from m props''"], ["proof (chain)\npicking this:\n  2 < m\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls", "have l_ls: \"2 < length ls\""], ["proof (prove)\nusing this:\n  2 < m\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls\n\ngoal (1 subgoal):\n 1. 2 < |ls|", "by auto"], ["proof (state)\nthis:\n  2 < |ls|\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "then"], ["proof (chain)\npicking this:\n  2 < |ls|", "have \"\\<exists> x y ks. ls = x # ks @ [y]\""], ["proof (prove)\nusing this:\n  2 < |ls|\n\ngoal (1 subgoal):\n 1. \\<exists>x y ks. ls = x # ks @ [y]", "apply (case_tac \"ls::(nat list)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 < |ls|; ls = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y ks. ls = x # ks @ [y]\n 2. \\<And>a list.\n       \\<lbrakk>2 < |ls|; ls = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y ks. ls = x # ks @ [y]", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Suc 0 < |list|; ls = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y ks. list = ks @ [y]", "apply (case_tac \"list\" rule: rev_exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>Suc 0 < |list|; ls = a # list; list = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y ks. list = ks @ [y]\n 2. \\<And>a list ys y.\n       \\<lbrakk>Suc 0 < |list|; ls = a # list; list = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y ks. list = ks @ [y]", "by auto"], ["proof (state)\nthis:\n  \\<exists>x y ks. ls = x # ks @ [y]\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x y ks. ls = x # ks @ [y]", "obtain x y ks where \"ls = x # ks @ [y]\""], ["proof (prove)\nusing this:\n  \\<exists>x y ks. ls = x # ks @ [y]\n\ngoal (1 subgoal):\n 1. (\\<And>x ks y.\n        ls = x # ks @ [y] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ls = x # ks @ [y]\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "with props''"], ["proof (chain)\npicking this:\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls\n  ls = x # ks @ [y]", "have ls': \"ls = 0 # ks @ [nmax - 1]\""], ["proof (prove)\nusing this:\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls\n  ls = x # ks @ [y]\n\ngoal (1 subgoal):\n 1. ls = 0 # ks @ [nmax - 1]", "by auto"], ["proof (state)\nthis:\n  ls = 0 # ks @ [nmax - 1]\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "with l_ls"], ["proof (chain)\npicking this:\n  2 < |ls|\n  ls = 0 # ks @ [nmax - 1]", "have l_ms: \"0 < length ks\""], ["proof (prove)\nusing this:\n  2 < |ls|\n  ls = 0 # ks @ [nmax - 1]\n\ngoal (1 subgoal):\n 1. 0 < |ks|", "by auto"], ["proof (state)\nthis:\n  0 < |ks|\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "then"], ["proof (chain)\npicking this:\n  0 < |ks|", "have ms_ne: \"ks \\<noteq> []\""], ["proof (prove)\nusing this:\n  0 < |ks|\n\ngoal (1 subgoal):\n 1. ks \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ks \\<noteq> []\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "from ls'"], ["proof (chain)\npicking this:\n  ls = 0 # ks @ [nmax - 1]", "have lks: \"length ks = length ls - 2\""], ["proof (prove)\nusing this:\n  ls = 0 # ks @ [nmax - 1]\n\ngoal (1 subgoal):\n 1. |ks| = |ls| - 2", "by auto"], ["proof (state)\nthis:\n  |ks| = |ls| - 2\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "from props''"], ["proof (chain)\npicking this:\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls", "have nd: \"increasing ls\""], ["proof (prove)\nusing this:\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls\n\ngoal (1 subgoal):\n 1. increasing ls", "by auto"], ["proof (state)\nthis:\n  increasing ls\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "from props''"], ["proof (chain)\npicking this:\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls", "have \"\\<And> z. z \\<in> set ks \\<Longrightarrow> 0 \\<le> z\""], ["proof (prove)\nusing this:\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set ks \\<Longrightarrow> 0 \\<le> z", "by auto"], ["proof (state)\nthis:\n  ?z \\<in> set ks \\<Longrightarrow> 0 \\<le> ?z\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "from props'' ls'"], ["proof (chain)\npicking this:\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls\n  ls = 0 # ks @ [nmax - 1]", "have \"increasing ((0 # ks) @ [nmax - 1])\""], ["proof (prove)\nusing this:\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls\n  ls = 0 # ks @ [nmax - 1]\n\ngoal (1 subgoal):\n 1. increasing ((0 # ks) @ [nmax - 1])", "by auto"], ["proof (state)\nthis:\n  increasing ((0 # ks) @ [nmax - 1])\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "then"], ["proof (chain)\npicking this:\n  increasing ((0 # ks) @ [nmax - 1])", "have z: \"\\<And> z. z \\<in> set ks \\<Longrightarrow> z \\<le> (nmax - 1)\""], ["proof (prove)\nusing this:\n  increasing ((0 # ks) @ [nmax - 1])\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set ks \\<Longrightarrow> z \\<le> nmax - 1", "by (drule_tac increasing2) auto"], ["proof (state)\nthis:\n  ?z \\<in> set ks \\<Longrightarrow> ?z \\<le> nmax - 1\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "from props  ls'"], ["proof (chain)\npicking this:\n  incrIndexList ls m nmax\n  ls = 0 # ks @ [nmax - 1]", "have z': \"\\<And> z. z \\<in> set ks \\<Longrightarrow> z \\<le> (nmax - 2)\""], ["proof (prove)\nusing this:\n  incrIndexList ls m nmax\n  ls = 0 # ks @ [nmax - 1]\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set ks \\<Longrightarrow> z \\<le> nmax - 2", "by auto"], ["proof (state)\nthis:\n  ?z \\<in> set ks \\<Longrightarrow> ?z \\<le> nmax - 2\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "have \"ks \\<in> set ((enumAppend (nmax - 2)\n         ^^ (length ks - Suc 0)) (enumBase (nmax - 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "proof (cases \"ks = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ks = [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))\n 2. ks \\<noteq> [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "case True"], ["proof (state)\nthis:\n  ks = []\n\ngoal (2 subgoals):\n 1. ks = [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))\n 2. ks \\<noteq> [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "with ms_ne"], ["proof (chain)\npicking this:\n  ks \\<noteq> []\n  ks = []", "show ?thesis"], ["proof (prove)\nusing this:\n  ks \\<noteq> []\n  ks = []\n\ngoal (1 subgoal):\n 1. ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "by simp"], ["proof (state)\nthis:\n  ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                 (enumBase (nmax - 2)))\n\ngoal (1 subgoal):\n 1. ks \\<noteq> [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ks \\<noteq> [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "case False"], ["proof (state)\nthis:\n  ks \\<noteq> []\n\ngoal (1 subgoal):\n 1. ks \\<noteq> [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "from props''"], ["proof (chain)\npicking this:\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls", "have \"increasing ls\""], ["proof (prove)\nusing this:\n  hd ls = 0 \\<and> last ls = nmax - 1 \\<and> |ls| = m \\<and> increasing ls\n\ngoal (1 subgoal):\n 1. increasing ls", "by auto"], ["proof (state)\nthis:\n  increasing ls\n\ngoal (1 subgoal):\n 1. ks \\<noteq> [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "with ls'"], ["proof (chain)\npicking this:\n  ls = 0 # ks @ [nmax - 1]\n  increasing ls", "have \"increasing (0 # ks)\""], ["proof (prove)\nusing this:\n  ls = 0 # ks @ [nmax - 1]\n  increasing ls\n\ngoal (1 subgoal):\n 1. increasing (0 # ks)", "by (auto intro: increasing4)"], ["proof (state)\nthis:\n  increasing (0 # ks)\n\ngoal (1 subgoal):\n 1. ks \\<noteq> [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "then"], ["proof (chain)\npicking this:\n  increasing (0 # ks)", "have \"increasing ([0] @ ks)\""], ["proof (prove)\nusing this:\n  increasing (0 # ks)\n\ngoal (1 subgoal):\n 1. increasing ([0] @ ks)", "by auto"], ["proof (state)\nthis:\n  increasing ([0] @ ks)\n\ngoal (1 subgoal):\n 1. ks \\<noteq> [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "then"], ["proof (chain)\npicking this:\n  increasing ([0] @ ks)", "have ndks: \"increasing ks\""], ["proof (prove)\nusing this:\n  increasing ([0] @ ks)\n\ngoal (1 subgoal):\n 1. increasing ks", "by (rule_tac increasing5)"], ["proof (state)\nthis:\n  increasing ks\n\ngoal (1 subgoal):\n 1. ks \\<noteq> [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "have listall: \"list_all (\\<lambda>x. x < Suc (nmax - 2)) ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x < Suc (nmax - 2)) ks", "apply (simp add: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set ks. x < Suc (nmax - 2)", "by (auto dest: z')"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x < Suc (nmax - 2)) ks\n\ngoal (1 subgoal):\n 1. ks \\<noteq> [] \\<Longrightarrow>\n    ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "with False ndks"], ["proof (chain)\npicking this:\n  ks \\<noteq> []\n  increasing ks\n  list_all (\\<lambda>x. x < Suc (nmax - 2)) ks", "show ?thesis"], ["proof (prove)\nusing this:\n  ks \\<noteq> []\n  increasing ks\n  list_all (\\<lambda>x. x < Suc (nmax - 2)) ks\n\ngoal (1 subgoal):\n 1. ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                   (enumBase (nmax - 2)))", "apply (rule_tac enumerator_completeness_help)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>ks \\<noteq> []; increasing ks;\n     list_all (\\<lambda>x. x < Suc (nmax - 2)) ks\\<rbrakk>\n    \\<Longrightarrow> increasing ks\n 2. \\<lbrakk>ks \\<noteq> []; increasing ks;\n     list_all (\\<lambda>x. x < Suc (nmax - 2)) ks\\<rbrakk>\n    \\<Longrightarrow> ks \\<noteq> []\n 3. \\<lbrakk>ks \\<noteq> []; increasing ks;\n     list_all (\\<lambda>x. x < Suc (nmax - 2)) ks\\<rbrakk>\n    \\<Longrightarrow> |ks| = Suc (|ks| - Suc 0)\n 4. \\<lbrakk>ks \\<noteq> []; increasing ks;\n     list_all (\\<lambda>x. x < Suc (nmax - 2)) ks\\<rbrakk>\n    \\<Longrightarrow> list_all (\\<lambda>x. x < Suc (nmax - 2)) ks", "by auto"], ["proof (state)\nthis:\n  ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                 (enumBase (nmax - 2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                 (enumBase (nmax - 2)))\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "with lks props'"], ["proof (chain)\npicking this:\n  |ks| = |ls| - 2\n  hd ls = 0 \\<and>\n  last ls = nmax - 1 \\<and>\n  |ls| = m \\<and> last (butlast ls) < last ls \\<and> increasing ls\n  ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                 (enumBase (nmax - 2)))", "have\n        \"ks \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3)) (enumBase (nmax - 2)))\""], ["proof (prove)\nusing this:\n  |ks| = |ls| - 2\n  hd ls = 0 \\<and>\n  last ls = nmax - 1 \\<and>\n  |ls| = m \\<and> last (butlast ls) < last ls \\<and> increasing ls\n  ks \\<in> set ((enumAppend (nmax - 2) ^^ (|ks| - Suc 0))\n                 (enumBase (nmax - 2)))\n\ngoal (1 subgoal):\n 1. ks \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3)) (enumBase (nmax - 2)))", "by auto"], ["proof (state)\nthis:\n  ks \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3)) (enumBase (nmax - 2)))\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "with m ls'"], ["proof (chain)\npicking this:\n  2 < m\n  ls = 0 # ks @ [nmax - 1]\n  ks \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3)) (enumBase (nmax - 2)))", "show ?thesis"], ["proof (prove)\nusing this:\n  2 < m\n  ls = 0 # ks @ [nmax - 1]\n  ks \\<in> set ((enumAppend (nmax - 2) ^^ (m - 3)) (enumBase (nmax - 2)))\n\ngoal (1 subgoal):\n 1. ls \\<in> set (enumerator m nmax)", "by (simp add: enumerator_def)"], ["proof (state)\nthis:\n  ls \\<in> set (enumerator m nmax)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ls \\<in> set (enumerator m nmax)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ls \\<in> set (enumerator m nmax)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enumerator_equiv[simp]:\n \"2 < n \\<Longrightarrow> 1 < m \\<Longrightarrow> is \\<in> set(enumerator n m) = incrIndexList is n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 < n; 1 < m\\<rbrakk>\n    \\<Longrightarrow> (is \\<in> set (enumerator n m)) = incrIndexList is n m", "by (auto intro: enumerator_correctness enumerator_completeness)"], ["", "end"]]}