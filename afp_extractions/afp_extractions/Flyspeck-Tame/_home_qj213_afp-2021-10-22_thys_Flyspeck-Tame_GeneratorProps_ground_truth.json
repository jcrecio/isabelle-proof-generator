{"file_name": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame/GeneratorProps.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame", "problem_names": ["lemma genPolyTame_spec:\n \"generatePolygonTame n v f g = [g' \\<leftarrow> generatePolygon n v f g . \\<not> notame g']\"", "lemma genPolyTame_subset_genPoly:\n \"g' \\<in> set(generatePolygonTame i v f g) \\<Longrightarrow>\n  g' \\<in> set(generatePolygon i v f g)\"", "lemma next_tame0_subset_plane:\n \"set(next_tame0 p g) \\<subseteq> set(next_plane p g)\"", "lemma genPoly_new_face:\n \"\\<lbrakk>g' \\<in> set (generatePolygon n v f g); minGraphProps g; f \\<in> set (nonFinals g);\n   v \\<in> \\<V> f; n \\<ge> 3 \\<rbrakk> \\<Longrightarrow>\n  \\<exists>f \\<in> set(finals g') - set(finals g). |vertices f| = n\"", "lemma genPoly_incr_facesquander_lb:\nassumes \"g' \\<in> set (generatePolygon n v f g)\" \"inv g\"\n        \"f \\<in> set(nonFinals g)\" \"v \\<in> \\<V> f\" \"3 \\<le> n\"\nshows \"faceSquanderLowerBound g' \\<ge> faceSquanderLowerBound g + \\<d> n\"", "lemma delAround_def: \"deleteAround g u ps = [p \\<leftarrow> ps. \\<not> close g u (fst p)]\"", "lemma close_sym: assumes mgp: \"minGraphProps g\" and ug: \"u : \\<V> g\" and cl: \"close g u v\"\nshows \"close g v u\"", "lemma sep_conv:\nassumes mgp: \"minGraphProps g\" and \"V \\<subseteq> \\<V> g\"\nshows \"separated g V = (\\<forall>u\\<in>V.\\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v)\" (is \"?P = ?Q\")", "lemma sep_ne: \"\\<exists>P \\<subseteq> M. separated g (fst ` P)\"", "lemma ExcessNotAtRec_conv_Max:\nassumes mgp: \"minGraphProps g\"\nshows \"set(map fst ps) \\<subseteq> \\<V> g \\<Longrightarrow> distinct(map fst ps) \\<Longrightarrow>\n  ExcessNotAtRec ps g =\n  Max{ \\<Sum>p\\<in>P. snd p |P. P \\<subseteq> set ps \\<and> separated g (fst ` P)}\"\n  (is \"_ \\<Longrightarrow> _ \\<Longrightarrow> _ = Max(?M ps)\" is \"_ \\<Longrightarrow> _ \\<Longrightarrow> _ = Max{_ |P. ?S ps P}\")", "lemma dist_ExcessTab: \"distinct (map fst (ExcessTable g (vertices g)))\"", "lemma mono_ExcessTab: \"\\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); inv g \\<rbrakk> \\<Longrightarrow>\n  set(ExcessTable g (vertices g)) \\<subseteq> set(ExcessTable g' (vertices g'))\"", "lemma close_antimono:\n \"\\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); inv g; u \\<in> \\<V> g; finalVertex g u \\<rbrakk> \\<Longrightarrow>\n  close g' u v \\<Longrightarrow> close g u v\"", "lemma ExcessTab_final:\n \"p \\<in> set(ExcessTable g (vertices g)) \\<Longrightarrow> finalVertex g (fst p)\"", "lemma ExcessTab_vertex:\n \"p \\<in> set(ExcessTable g (vertices g)) \\<Longrightarrow> fst p \\<in> \\<V> g\"", "lemma fst_set_ExcessTable_subset:\n \"fst ` set (ExcessTable g (vertices g)) \\<subseteq> \\<V> g\"", "lemma next_plane0_incr_ExcessNotAt:\n \"\\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); inv g \\<rbrakk> \\<Longrightarrow>\n  ExcessNotAt g None \\<le> ExcessNotAt g' None\"", "lemma next_plane0_incr_squander_lb:\n \"\\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); inv g \\<rbrakk> \\<Longrightarrow>\n  squanderLowerBound g \\<le> squanderLowerBound g'\"", "lemma inv_notame:\n \"\\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); inv g; notame7 g\\<rbrakk>\n  \\<Longrightarrow> notame7 g'\"", "lemma inv_inv_notame:\n \"invariant(\\<lambda>g. inv g \\<and> notame7 g) next_plane\\<^bsub>p\\<^esub>\"", "lemma untame_notame:\n \"untame (\\<lambda>g. inv g \\<and> notame7 g)\"", "lemma polysizes_tame:\n \"\\<lbrakk> g' \\<in> set (generatePolygon n v f g); inv g; f \\<in> set(nonFinals g);\n   v \\<in> \\<V> f; 3 \\<le> n; n < 4+p; n \\<notin> set(polysizes p g) \\<rbrakk>\n \\<Longrightarrow> notame7 g'\"", "lemma genPolyTame_notame:\n \"\\<lbrakk> g' \\<in> set (generatePolygon n v f g); g' \\<notin> set (generatePolygonTame n v f g);\n    inv g; 3 \\<le> n \\<rbrakk>\n  \\<Longrightarrow> notame7 g'\"", "lemma excess_notame:\n \"\\<lbrakk> inv g; g' \\<in> set (next_plane\\<^bsub>p\\<^esub> g); g' \\<notin> set (next_tame0 p g) \\<rbrakk>\n       \\<Longrightarrow> notame7 g'\"", "lemma next_tame0_comp: \"\\<lbrakk> Seed\\<^bsub>p\\<^esub> [next_plane p]\\<rightarrow>* g; final g; tame g \\<rbrakk>\n \\<Longrightarrow> Seed\\<^bsub>p\\<^esub> [next_tame0 p]\\<rightarrow>* g\"", "lemma inv_inv_next_tame0: \"invariant inv (next_tame0 p)\"", "lemma inv_inv_next_tame: \"invariant inv next_tame\\<^bsub>p\\<^esub>\"", "lemma mgp_TameEnum: \"g \\<in> TameEnum\\<^bsub>p\\<^esub> \\<Longrightarrow> minGraphProps g\""], "translations": [["", "lemma genPolyTame_spec:\n \"generatePolygonTame n v f g = [g' \\<leftarrow> generatePolygon n v f g . \\<not> notame g']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generatePolygonTame n v f g =\n    filter (\\<lambda>g'. \\<not> notame g') (generatePolygon n v f g)", "by(simp add:generatePolygonTame_def generatePolygon_def enum_enumerator)"], ["", "lemma genPolyTame_subset_genPoly:\n \"g' \\<in> set(generatePolygonTame i v f g) \\<Longrightarrow>\n  g' \\<in> set(generatePolygon i v f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' \\<in> set (generatePolygonTame i v f g) \\<Longrightarrow>\n    g' \\<in> set (generatePolygon i v f g)", "by(auto simp add:generatePolygon_def generatePolygonTame_def enum_enumerator)"], ["", "lemma next_tame0_subset_plane:\n \"set(next_tame0 p g) \\<subseteq> set(next_plane p g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (next_tame0\\<^bsub>p\\<^esub> g)\n    \\<subseteq> set (next_plane\\<^bsub>p\\<^esub> g)", "by(auto simp add:next_tame0_def next_plane_def polysizes_def\n           elim!:genPolyTame_subset_genPoly simp del:upt_Suc)"], ["", "lemma genPoly_new_face:\n \"\\<lbrakk>g' \\<in> set (generatePolygon n v f g); minGraphProps g; f \\<in> set (nonFinals g);\n   v \\<in> \\<V> f; n \\<ge> 3 \\<rbrakk> \\<Longrightarrow>\n  \\<exists>f \\<in> set(finals g') - set(finals g). |vertices f| = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (generatePolygon n v f g); minGraphProps g;\n     f \\<in> set (nonFinals g); v \\<in> \\<V> f; 3 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f\\<in>set (finals g') - set (finals g).\n                         |vertices f| = n", "apply(auto simp add:generatePolygon_def image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; x \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v x;\n        g' = subdivFace g f (indexToVertexList f v x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace g f (indexToVertexList f v x))) -\n  set (finals g).\n                            |vertices f| = n", "apply(rename_tac \"is\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace g f (indexToVertexList f v is))) -\n  set (finals g).\n                            |vertices f| = n", "apply(frule enumerator_length2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is)\\<rbrakk>\n       \\<Longrightarrow> 2 < n\n 2. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace g f (indexToVertexList f v is))) -\n  set (finals g).\n                            |vertices f| = n", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace g f (indexToVertexList f v is))) -\n  set (finals g).\n                            |vertices f| = n", "apply(frule (4) pre_subdivFace_indexToVertexList)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n\\<rbrakk>\n       \\<Longrightarrow> 2 < n\n 2. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n;\n        pre_subdivFace g f v (indexToVertexList f v is)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace g f (indexToVertexList f v is))) -\n  set (finals g).\n                            |vertices f| = n", "apply(arith)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n;\n        pre_subdivFace g f v (indexToVertexList f v is)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace g f (indexToVertexList f v is))) -\n  set (finals g).\n                            |vertices f| = n", "apply(subgoal_tac \"indexToVertexList f v is \\<noteq> []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n;\n        pre_subdivFace g f v (indexToVertexList f v is);\n        indexToVertexList f v is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace g f (indexToVertexList f v is))) -\n  set (finals g).\n                            |vertices f| = n\n 2. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n;\n        pre_subdivFace g f v (indexToVertexList f v is)\\<rbrakk>\n       \\<Longrightarrow> indexToVertexList f v is \\<noteq> []", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n;\n        pre_subdivFace g f v (indexToVertexList f v is)\\<rbrakk>\n       \\<Longrightarrow> indexToVertexList f v is \\<noteq> []\n 2. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n;\n        pre_subdivFace g f v (indexToVertexList f v is);\n        indexToVertexList f v is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace g f (indexToVertexList f v is))) -\n  set (finals g).\n                            |vertices f| = n", "apply(subst length_0_conv[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n;\n        pre_subdivFace g f v (indexToVertexList f v is)\\<rbrakk>\n       \\<Longrightarrow> |indexToVertexList f v is| \\<noteq> 0\n 2. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n;\n        pre_subdivFace g f v (indexToVertexList f v is);\n        indexToVertexList f v is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace g f (indexToVertexList f v is))) -\n  set (finals g).\n                            |vertices f| = n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace g f (indexToVertexList f v is); |is| = n;\n        pre_subdivFace g f v (indexToVertexList f v is);\n        indexToVertexList f v is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace g f (indexToVertexList f v is))) -\n  set (finals g).\n                            |vertices f| = n", "apply(simp add: subdivFace_subdivFace'_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> n; is \\<in> set (enumerator n |vertices f|);\n        \\<not> containsDuplicateEdge g f v is;\n        g' = subdivFace' g f v 0 (tl (indexToVertexList f v is)); |is| = n;\n        pre_subdivFace g f v (indexToVertexList f v is);\n        indexToVertexList f v is \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 (tl (indexToVertexList f v is)))) -\n  set (finals g).\n                            |vertices f| = n", "apply(clarsimp simp:neq_Nil_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is y ys.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> |is|; is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ys;\n        pre_subdivFace g f v (y # ys); n = |is|;\n        indexToVertexList f v is = y # ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 ys)) -\n  set (finals g).\n                            |vertices f| = |is|", "apply(rename_tac \"ovs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is y ovs.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> |is|; is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 ovs)) -\n  set (finals g).\n                            |vertices f| = |is|", "apply(subgoal_tac \"|indexToVertexList f v is| = |ovs| + 1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is y ovs.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> |is|; is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs;\n        |indexToVertexList f v is| = |ovs| + 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 ovs)) -\n  set (finals g).\n                            |vertices f| = |is|\n 2. \\<And>is y ovs.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> |is|; is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs\\<rbrakk>\n       \\<Longrightarrow> |indexToVertexList f v is| = |ovs| + 1", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is y ovs.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> |is|; is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs\\<rbrakk>\n       \\<Longrightarrow> |indexToVertexList f v is| = |ovs| + 1\n 2. \\<And>is y ovs.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> |is|; is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs;\n        |indexToVertexList f v is| = |ovs| + 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 ovs)) -\n  set (finals g).\n                            |vertices f| = |is|", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is y ovs.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); v \\<in> \\<V> f;\n        3 \\<le> |is|; is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs;\n        |indexToVertexList f v is| = |ovs| + 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 ovs)) -\n  set (finals g).\n                            |vertices f| = |is|", "apply(drule (1) pre_subdivFace_pre_subdivFace')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is y ovs.\n       \\<lbrakk>minGraphProps g; f \\<in> set (nonFinals g); 3 \\<le> |is|;\n        is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs;\n        |indexToVertexList f v is| = |ovs| + 1;\n        pre_subdivFace' g f v v 0 ovs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 ovs)) -\n  set (finals g).\n                            |vertices f| = |is|", "apply(drule (1) final_subdivFace')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>is y ovs.\n       \\<lbrakk>f \\<in> set (nonFinals g); 3 \\<le> |is|;\n        is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs;\n        |indexToVertexList f v is| = |ovs| + 1;\n        pre_subdivFace' g f v v 0 ovs\\<rbrakk>\n       \\<Longrightarrow> f \\<in> \\<F> g\n 2. \\<And>is y ovs.\n       \\<lbrakk>f \\<in> set (nonFinals g); 3 \\<le> |is|;\n        is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs;\n        |indexToVertexList f v is| = |ovs| + 1;\n        pre_subdivFace' g f v v 0 ovs\\<rbrakk>\n       \\<Longrightarrow> ovs = [] \\<longrightarrow>\n                         0 = 0 \\<and> v = last (verticesFrom f v)\n 3. \\<And>is y ovs.\n       \\<lbrakk>f \\<in> set (nonFinals g); 3 \\<le> |is|;\n        is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs;\n        |indexToVertexList f v is| = |ovs| + 1;\n        pre_subdivFace' g f v v 0 ovs;\n        \\<exists>f'\\<in>set (finals (subdivFace' g f v 0 ovs)) -\n                        set (finals g).\n           (f\\<^bsup>-1\\<^esup> \\<bullet> v, v) \\<in> \\<E> f' \\<and>\n           |vertices f'| =\n           0 + |ovs| +\n           (if v = v then 1 else |between (vertices f) v v| + 2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 ovs)) -\n  set (finals g).\n                            |vertices f| = |is|", "apply(simp add:nonFinals_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is y ovs.\n       \\<lbrakk>f \\<in> set (nonFinals g); 3 \\<le> |is|;\n        is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs;\n        |indexToVertexList f v is| = |ovs| + 1;\n        pre_subdivFace' g f v v 0 ovs\\<rbrakk>\n       \\<Longrightarrow> ovs = [] \\<longrightarrow>\n                         0 = 0 \\<and> v = last (verticesFrom f v)\n 2. \\<And>is y ovs.\n       \\<lbrakk>f \\<in> set (nonFinals g); 3 \\<le> |is|;\n        is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs;\n        |indexToVertexList f v is| = |ovs| + 1;\n        pre_subdivFace' g f v v 0 ovs;\n        \\<exists>f'\\<in>set (finals (subdivFace' g f v 0 ovs)) -\n                        set (finals g).\n           (f\\<^bsup>-1\\<^esup> \\<bullet> v, v) \\<in> \\<E> f' \\<and>\n           |vertices f'| =\n           0 + |ovs| +\n           (if v = v then 1 else |between (vertices f) v v| + 2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 ovs)) -\n  set (finals g).\n                            |vertices f| = |is|", "apply(simp add:pre_subdivFace'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is y ovs.\n       \\<lbrakk>f \\<in> set (nonFinals g); 3 \\<le> |is|;\n        is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs;\n        |indexToVertexList f v is| = |ovs| + 1;\n        pre_subdivFace' g f v v 0 ovs;\n        \\<exists>f'\\<in>set (finals (subdivFace' g f v 0 ovs)) -\n                        set (finals g).\n           (f\\<^bsup>-1\\<^esup> \\<bullet> v, v) \\<in> \\<E> f' \\<and>\n           |vertices f'| =\n           0 + |ovs| +\n           (if v = v then 1 else |between (vertices f) v v| + 2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 ovs)) -\n  set (finals g).\n                            |vertices f| = |is|", "apply (simp (no_asm_use))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is y ovs.\n       \\<lbrakk>f \\<in> set (nonFinals g); 3 \\<le> |is|;\n        is \\<in> set (enumerator |is| |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = |is|;\n        indexToVertexList f v is = y # ovs; |is| = Suc |ovs|;\n        pre_subdivFace' g f v v 0 ovs;\n        \\<exists>f'\\<in>set (finals (subdivFace' g f v 0 ovs)) -\n                        set (finals g).\n           (f\\<^bsup>-1\\<^esup> \\<bullet> v, v) \\<in> \\<E> f' \\<and>\n           |vertices f'| = Suc |ovs|\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 ovs)) -\n  set (finals g).\n                            |vertices f| = |is|", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is y ovs.\n       \\<lbrakk>f \\<in> set (nonFinals g); 2 \\<le> |ovs|;\n        is \\<in> set (enumerator (Suc |ovs|) |vertices f|);\n        \\<not> containsDuplicateEdge g f v is; g' = subdivFace' g f v 0 ovs;\n        pre_subdivFace g f v (y # ovs); n = Suc |ovs|;\n        indexToVertexList f v is = y # ovs; |is| = Suc |ovs|;\n        pre_subdivFace' g f v v 0 ovs;\n        \\<exists>f'\\<in>set (finals (subdivFace' g f v 0 ovs)) -\n                        set (finals g).\n           (f\\<^bsup>-1\\<^esup> \\<bullet> v, v) \\<in> \\<E> f' \\<and>\n           |vertices f'| = Suc |ovs|\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f\\<in>set\n   (finals (subdivFace' g f v 0 ovs)) -\n  set (finals g).\n                            |vertices f| = Suc |ovs|", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Could prove = instead of \\<ge>, but who needs it? *)"], ["", "lemma genPoly_incr_facesquander_lb:\nassumes \"g' \\<in> set (generatePolygon n v f g)\" \"inv g\"\n        \"f \\<in> set(nonFinals g)\" \"v \\<in> \\<V> f\" \"3 \\<le> n\"\nshows \"faceSquanderLowerBound g' \\<ge> faceSquanderLowerBound g + \\<d> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g'", "from genPoly_new_face[OF assms(1) inv_mgp[OF assms(2)] assms(3-5)]"], ["proof (chain)\npicking this:\n  \\<exists>f\\<in>set (finals g') - set (finals g). |vertices f| = n", "obtain f\n    where f: \"f \\<in> set (finals g') - set(finals g)\"\n    and size: \"|vertices f| = n\""], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>set (finals g') - set (finals g). |vertices f| = n\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> set (finals g') - set (finals g);\n         |vertices f| = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in> set (finals g') - set (finals g)\n  |vertices f| = n\n\ngoal (1 subgoal):\n 1. faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g'", "have g': \"g' \\<in> set(next_plane0 (n - 3) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' \\<in> set (next_plane0\\<^bsub>n - 3\\<^esub> g)", "using assms(5)"], ["proof (prove)\nusing this:\n  3 \\<le> n\n\ngoal (1 subgoal):\n 1. g' \\<in> set (next_plane0\\<^bsub>n - 3\\<^esub> g)", "by(rule_tac in_next_plane0I[OF assms(1,3-5)]) simp"], ["proof (state)\nthis:\n  g' \\<in> set (next_plane0\\<^bsub>n - 3\\<^esub> g)\n\ngoal (1 subgoal):\n 1. faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g'", "note dist = minGraphProps11'[OF inv_mgp[OF assms(2)]]"], ["proof (state)\nthis:\n  distinct (faces g)\n\ngoal (1 subgoal):\n 1. faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g'", "note inv' = invariantE[OF inv_inv_next_plane0, OF g' assms(2)]"], ["proof (state)\nthis:\n  Invariants.inv g'\n\ngoal (1 subgoal):\n 1. faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g'", "note dist' = minGraphProps11'[OF inv_mgp[OF inv']]"], ["proof (state)\nthis:\n  distinct (faces g')\n\ngoal (1 subgoal):\n 1. faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g'", "note subset = next_plane0_finals_subset[OF g']"], ["proof (state)\nthis:\n  set (finals g) \\<subseteq> set (finals g')\n\ngoal (1 subgoal):\n 1. faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g'", "have \"faceSquanderLowerBound g' \\<ge>\n        faceSquanderLowerBound g + \\<d> |vertices f|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. faceSquanderLowerBound g + \\<d> |vertices f|\n    \\<le> faceSquanderLowerBound g'", "proof(unfold faceSquanderLowerBound_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n    \\<d> |vertices f|\n    \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "have \"(\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f| ) + \\<d> |vertices f| =\n          (\\<Sum>f\\<in>set(finals g). \\<d> |vertices f| ) + \\<d> |vertices f|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n    \\<d> |vertices f| =\n    (\\<Sum>f\\<in>set (finals g). \\<d> |vertices f|) + \\<d> |vertices f|", "using dist"], ["proof (prove)\nusing this:\n  distinct (faces g)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n    \\<d> |vertices f| =\n    (\\<Sum>f\\<in>set (finals g). \\<d> |vertices f|) + \\<d> |vertices f|", "by(simp add:finals_def ListSum_conv_sum)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n  \\<d> |vertices f| =\n  (\\<Sum>f\\<in>set (finals g). \\<d> |vertices f|) + \\<d> |vertices f|\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n    \\<d> |vertices f|\n    \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n  \\<d> |vertices f| =\n  (\\<Sum>f\\<in>set (finals g). \\<d> |vertices f|) + \\<d> |vertices f|\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n    \\<d> |vertices f|\n    \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "have \"\\<dots> = (\\<Sum>f\\<in>set(finals g) \\<union> {f}. \\<d> |vertices f| )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>set (finals g). \\<d> |vertices f|) + \\<d> |vertices f| =\n    (\\<Sum>f\\<in>set (finals g) \\<union> {f}. \\<d> |vertices f|)", "using f"], ["proof (prove)\nusing this:\n  f \\<in> set (finals g') - set (finals g)\n\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>set (finals g). \\<d> |vertices f|) + \\<d> |vertices f| =\n    (\\<Sum>f\\<in>set (finals g) \\<union> {f}. \\<d> |vertices f|)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>set (finals g). \\<d> |vertices f|) + \\<d> |vertices f| =\n  (\\<Sum>f\\<in>set (finals g) \\<union> {f}. \\<d> |vertices f|)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n    \\<d> |vertices f|\n    \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>set (finals g). \\<d> |vertices f|) + \\<d> |vertices f| =\n  (\\<Sum>f\\<in>set (finals g) \\<union> {f}. \\<d> |vertices f|)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n    \\<d> |vertices f|\n    \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "have \"\\<dots> \\<le> (\\<Sum>f\\<in>set(finals g'). \\<d> |vertices f| )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>set (finals g) \\<union> {f}. \\<d> |vertices f|)\n    \\<le> (\\<Sum>f\\<in>set (finals g'). \\<d> |vertices f|)", "using f subset"], ["proof (prove)\nusing this:\n  f \\<in> set (finals g') - set (finals g)\n  set (finals g) \\<subseteq> set (finals g')\n\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>set (finals g) \\<union> {f}. \\<d> |vertices f|)\n    \\<le> (\\<Sum>f\\<in>set (finals g'). \\<d> |vertices f|)", "by(fastforce intro!: sum_mono2)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>set (finals g) \\<union> {f}. \\<d> |vertices f|)\n  \\<le> (\\<Sum>f\\<in>set (finals g'). \\<d> |vertices f|)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n    \\<d> |vertices f|\n    \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>set (finals g) \\<union> {f}. \\<d> |vertices f|)\n  \\<le> (\\<Sum>f\\<in>set (finals g'). \\<d> |vertices f|)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n    \\<d> |vertices f|\n    \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "have \"\\<dots> = (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f| )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>set (finals g'). \\<d> |vertices f|) =\n    (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "using dist'"], ["proof (prove)\nusing this:\n  distinct (faces g')\n\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>set (finals g'). \\<d> |vertices f|) =\n    (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "by(simp add:finals_def ListSum_conv_sum)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>set (finals g'). \\<d> |vertices f|) =\n  (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n    \\<d> |vertices f|\n    \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n  \\<d> |vertices f|\n  \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "show \"(\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f| ) + \\<d> |vertices f|\n          \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f| )\""], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n  \\<d> |vertices f|\n  \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n    \\<d> |vertices f|\n    \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)", "."], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>f\\<in>finals g\\<^esub> \\<d> |vertices f|) +\n  \\<d> |vertices f|\n  \\<le> (\\<Sum>\\<^bsub>f\\<in>finals g'\\<^esub> \\<d> |vertices f|)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  faceSquanderLowerBound g + \\<d> |vertices f|\n  \\<le> faceSquanderLowerBound g'\n\ngoal (1 subgoal):\n 1. faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g'", "with size"], ["proof (chain)\npicking this:\n  |vertices f| = n\n  faceSquanderLowerBound g + \\<d> |vertices f|\n  \\<le> faceSquanderLowerBound g'", "show ?thesis"], ["proof (prove)\nusing this:\n  |vertices f| = n\n  faceSquanderLowerBound g + \\<d> |vertices f|\n  \\<le> faceSquanderLowerBound g'\n\ngoal (1 subgoal):\n 1. faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g'", "by blast"], ["proof (state)\nthis:\n  faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition close :: \"graph \\<Rightarrow> vertex \\<Rightarrow> vertex \\<Rightarrow> bool\" where\n\"close g u v \\<equiv>\n \\<exists>f \\<in> set(facesAt g u). if |vertices f| = 4 then v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n                        else v = f \\<bullet> u\""], ["", "(* FIXME This should be the def of delAround *)"], ["", "lemma delAround_def: \"deleteAround g u ps = [p \\<leftarrow> ps. \\<not> close g u (fst p)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deleteAround g u ps = filter (\\<lambda>p. \\<not> close g u (fst p)) ps", "by (induct ps) (auto simp: deleteAroundCons close_def)"], ["", "lemma close_sym: assumes mgp: \"minGraphProps g\" and ug: \"u : \\<V> g\" and cl: \"close g u v\"\nshows \"close g v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close g v u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. close g v u", "obtain f where f: \"f \\<in> set(facesAt g u)\" and\n    \"if\": \"if |vertices f| = 4 then v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u) else v = f \\<bullet> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> set (facesAt g u);\n         if |vertices f| = 4\n         then v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n         else v = f \\<bullet> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cl"], ["proof (prove)\nusing this:\n  close g u v\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> set (facesAt g u);\n         if |vertices f| = 4\n         then v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n         else v = f \\<bullet> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold close_def) blast"], ["proof (state)\nthis:\n  f \\<in> set (facesAt g u)\n  if |vertices f| = 4\n  then v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n  else v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. close g v u", "note uf = minGraphProps6[OF mgp ug f]"], ["proof (state)\nthis:\n  u \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. close g v u", "note distf = minGraphProps3[OF mgp minGraphProps5[OF mgp ug f]]"], ["proof (state)\nthis:\n  distinct (vertices f)\n\ngoal (1 subgoal):\n 1. close g v u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. close g v u", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> close g v u\n 2. \\<not> ?P \\<Longrightarrow> close g v u", "assume 4: \"|vertices f| = 4\""], ["proof (state)\nthis:\n  |vertices f| = 4\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> close g v u\n 2. \\<not> ?P \\<Longrightarrow> close g v u", "hence \"v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\""], ["proof (prove)\nusing this:\n  |vertices f| = 4\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)", "using \"if\""], ["proof (prove)\nusing this:\n  |vertices f| = 4\n  if |vertices f| = 4\n  then v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n  else v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)", "by simp"], ["proof (state)\nthis:\n  v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> close g v u\n 2. \\<not> ?P \\<Longrightarrow> close g v u", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n\ngoal (1 subgoal):\n 1. close g v u", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. v = f \\<bullet> u \\<Longrightarrow> close g v u\n 2. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> close g v u", "assume \"v = f \\<bullet> u\""], ["proof (state)\nthis:\n  v = f \\<bullet> u\n\ngoal (2 subgoals):\n 1. v = f \\<bullet> u \\<Longrightarrow> close g v u\n 2. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> close g v u", "then"], ["proof (chain)\npicking this:\n  v = f \\<bullet> u", "obtain f' where \"f' \\<in> set(facesAt g v)\" \"f' \\<bullet> v = u\""], ["proof (prove)\nusing this:\n  v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g v); f' \\<bullet> v = u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mgp_nextVertex_face_ex2[OF mgp ug f]"], ["proof (prove)\nusing this:\n  v = f \\<bullet> u\n  \\<exists>f'\\<in>set (facesAt g (f \\<bullet> u)).\n     f' \\<bullet> (f \\<bullet> u) = u\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g v); f' \\<bullet> v = u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f' \\<in> set (facesAt g v)\n  f' \\<bullet> v = u\n\ngoal (2 subgoals):\n 1. v = f \\<bullet> u \\<Longrightarrow> close g v u\n 2. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> close g v u", "thus ?thesis"], ["proof (prove)\nusing this:\n  f' \\<in> set (facesAt g v)\n  f' \\<bullet> v = u\n\ngoal (1 subgoal):\n 1. close g v u", "by(auto simp:close_def)"], ["proof (state)\nthis:\n  close g v u\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> close g v u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> close g v u", "assume v: \"v = f \\<bullet> (f \\<bullet> u)\""], ["proof (state)\nthis:\n  v = f \\<bullet> (f \\<bullet> u)\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> close g v u", "hence \"f \\<bullet> (f \\<bullet> v) = u\""], ["proof (prove)\nusing this:\n  v = f \\<bullet> (f \\<bullet> u)\n\ngoal (1 subgoal):\n 1. f \\<bullet> (f \\<bullet> v) = u", "using quad_next4_id[OF 4 distf uf]"], ["proof (prove)\nusing this:\n  v = f \\<bullet> (f \\<bullet> u)\n  f \\<bullet> (f \\<bullet> (f \\<bullet> (f \\<bullet> u))) = u\n\ngoal (1 subgoal):\n 1. f \\<bullet> (f \\<bullet> v) = u", "by simp"], ["proof (state)\nthis:\n  f \\<bullet> (f \\<bullet> v) = u\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> close g v u", "moreover"], ["proof (state)\nthis:\n  f \\<bullet> (f \\<bullet> v) = u\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> close g v u", "have \"f \\<in> set(facesAt g v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set (facesAt g v)", "using v uf"], ["proof (prove)\nusing this:\n  v = f \\<bullet> (f \\<bullet> u)\n  u \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. f \\<in> set (facesAt g v)", "by(simp add: minGraphProps7[OF mgp minGraphProps5[OF mgp ug f]])"], ["proof (state)\nthis:\n  f \\<in> set (facesAt g v)\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> close g v u", "ultimately"], ["proof (chain)\npicking this:\n  f \\<bullet> (f \\<bullet> v) = u\n  f \\<in> set (facesAt g v)", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<bullet> (f \\<bullet> v) = u\n  f \\<in> set (facesAt g v)\n\ngoal (1 subgoal):\n 1. close g v u", "using 4"], ["proof (prove)\nusing this:\n  f \\<bullet> (f \\<bullet> v) = u\n  f \\<in> set (facesAt g v)\n  |vertices f| = 4\n\ngoal (1 subgoal):\n 1. close g v u", "by(auto simp:close_def)"], ["proof (state)\nthis:\n  close g v u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  close g v u\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 4 \\<Longrightarrow> close g v u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 4 \\<Longrightarrow> close g v u", "assume \"|vertices f| \\<noteq> 4\""], ["proof (state)\nthis:\n  |vertices f| \\<noteq> 4\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 4 \\<Longrightarrow> close g v u", "hence \"v = f \\<bullet> u\""], ["proof (prove)\nusing this:\n  |vertices f| \\<noteq> 4\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> u", "using \"if\""], ["proof (prove)\nusing this:\n  |vertices f| \\<noteq> 4\n  if |vertices f| = 4\n  then v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n  else v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> u", "by simp"], ["proof (state)\nthis:\n  v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 4 \\<Longrightarrow> close g v u", "then"], ["proof (chain)\npicking this:\n  v = f \\<bullet> u", "obtain f' where \"f' \\<in> set(facesAt g v)\" \"f' \\<bullet> v = u\""], ["proof (prove)\nusing this:\n  v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g v); f' \\<bullet> v = u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mgp_nextVertex_face_ex2[OF mgp ug f]"], ["proof (prove)\nusing this:\n  v = f \\<bullet> u\n  \\<exists>f'\\<in>set (facesAt g (f \\<bullet> u)).\n     f' \\<bullet> (f \\<bullet> u) = u\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g v); f' \\<bullet> v = u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f' \\<in> set (facesAt g v)\n  f' \\<bullet> v = u\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 4 \\<Longrightarrow> close g v u", "thus ?thesis"], ["proof (prove)\nusing this:\n  f' \\<in> set (facesAt g v)\n  f' \\<bullet> v = u\n\ngoal (1 subgoal):\n 1. close g v u", "by(auto simp:close_def)"], ["proof (state)\nthis:\n  close g v u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  close g v u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sep_conv:\nassumes mgp: \"minGraphProps g\" and \"V \\<subseteq> \\<V> g\"\nshows \"separated g V = (\\<forall>u\\<in>V.\\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v)\" (is \"?P = ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. separated g V =\n    (\\<forall>u\\<in>V.\n        \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. separated g V \\<Longrightarrow>\n    \\<forall>u\\<in>V.\n       \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v\n 2. \\<forall>u\\<in>V.\n       \\<forall>v\\<in>V.\n          u \\<noteq> v \\<longrightarrow>\n          \\<not> close g u v \\<Longrightarrow>\n    separated g V", "assume sep: ?P"], ["proof (state)\nthis:\n  separated g V\n\ngoal (2 subgoals):\n 1. separated g V \\<Longrightarrow>\n    \\<forall>u\\<in>V.\n       \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v\n 2. \\<forall>u\\<in>V.\n       \\<forall>v\\<in>V.\n          u \\<noteq> v \\<longrightarrow>\n          \\<not> close g u v \\<Longrightarrow>\n    separated g V", "show ?Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V.\n       \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> V; v \\<in> V; u \\<noteq> v; close g u v\\<rbrakk>\n       \\<Longrightarrow> False", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> V; v \\<in> V; u \\<noteq> v; close g u v\\<rbrakk>\n       \\<Longrightarrow> False", "assume uv: \"u \\<in> V\" \"v \\<in> V\" \"u \\<noteq> v\" and cl: \"close g u v\""], ["proof (state)\nthis:\n  u \\<in> V\n  v \\<in> V\n  u \\<noteq> v\n  close g u v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> V; v \\<in> V; u \\<noteq> v; close g u v\\<rbrakk>\n       \\<Longrightarrow> False", "from cl"], ["proof (chain)\npicking this:\n  close g u v", "obtain f where f: \"f \\<in> set(facesAt g u)\" and\n      \"if\": \"if |vertices f| = 4 then (v = f \\<bullet> u) \\<or> (v = f \\<bullet> (f \\<bullet> u))\n                               else (v = f \\<bullet> u)\""], ["proof (prove)\nusing this:\n  close g u v\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> set (facesAt g u);\n         if |vertices f| = 4\n         then v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n         else v = f \\<bullet> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold close_def) blast"], ["proof (state)\nthis:\n  f \\<in> set (facesAt g u)\n  if |vertices f| = 4\n  then v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n  else v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> V; v \\<in> V; u \\<noteq> v; close g u v\\<rbrakk>\n       \\<Longrightarrow> False", "have \"u : \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> \\<V> g", "using \\<open>u : V\\<close> \\<open>V \\<subseteq> \\<V> g\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> V\n  V \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. u \\<in> \\<V> g", "by blast"], ["proof (state)\nthis:\n  u \\<in> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> V; v \\<in> V; u \\<noteq> v; close g u v\\<rbrakk>\n       \\<Longrightarrow> False", "note uf = minGraphProps6[OF mgp \\<open>u : \\<V> g\\<close> f]"], ["proof (state)\nthis:\n  u \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> V; v \\<in> V; u \\<noteq> v; close g u v\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume 4: \"|vertices f| = 4\""], ["proof (state)\nthis:\n  |vertices f| = 4\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "hence \"v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\""], ["proof (prove)\nusing this:\n  |vertices f| = 4\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)", "using \"if\""], ["proof (prove)\nusing this:\n  |vertices f| = 4\n  if |vertices f| = 4\n  then v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n  else v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)", "by simp"], ["proof (state)\nthis:\n  v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. v = f \\<bullet> u \\<Longrightarrow> False\n 2. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> False", "assume \"v = f \\<bullet> u\""], ["proof (state)\nthis:\n  v = f \\<bullet> u\n\ngoal (2 subgoals):\n 1. v = f \\<bullet> u \\<Longrightarrow> False\n 2. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. False", "using sep f uv"], ["proof (prove)\nusing this:\n  v = f \\<bullet> u\n  separated g V\n  f \\<in> set (facesAt g u)\n  u \\<in> V\n  v \\<in> V\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. False", "by(simp add:separated_def separated\\<^sub>2_def separated\\<^sub>3_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> False", "assume \"v = f \\<bullet> (f \\<bullet> u)\""], ["proof (state)\nthis:\n  v = f \\<bullet> (f \\<bullet> u)\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  v = f \\<bullet> (f \\<bullet> u)\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> False", "hence \"v \\<in> \\<V> f\""], ["proof (prove)\nusing this:\n  v = f \\<bullet> (f \\<bullet> u)\n\ngoal (1 subgoal):\n 1. v \\<in> \\<V> f", "using \\<open>u \\<in> \\<V> f\\<close>"], ["proof (prove)\nusing this:\n  v = f \\<bullet> (f \\<bullet> u)\n  u \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. v \\<in> \\<V> f", "by simp"], ["proof (state)\nthis:\n  v \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  v \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> False", "have \"|vertices f| \\<le> 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |vertices f| \\<le> 4", "using 4"], ["proof (prove)\nusing this:\n  |vertices f| = 4\n\ngoal (1 subgoal):\n 1. |vertices f| \\<le> 4", "by arith"], ["proof (state)\nthis:\n  |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> (f \\<bullet> u) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  v = f \\<bullet> (f \\<bullet> u)\n  v \\<in> \\<V> f\n  |vertices f| \\<le> 4", "show False"], ["proof (prove)\nusing this:\n  v = f \\<bullet> (f \\<bullet> u)\n  v \\<in> \\<V> f\n  |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. False", "using sep f uv \\<open>u \\<in> \\<V> f\\<close>"], ["proof (prove)\nusing this:\n  v = f \\<bullet> (f \\<bullet> u)\n  v \\<in> \\<V> f\n  |vertices f| \\<le> 4\n  separated g V\n  f \\<in> set (facesAt g u)\n  u \\<in> V\n  v \\<in> V\n  u \\<noteq> v\n  u \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. False", "apply(unfold separated_def separated\\<^sub>2_def separated\\<^sub>3_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = f \\<bullet> (f \\<bullet> u); v \\<in> \\<V> f;\n     |vertices f| \\<le> 4;\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V) \\<and>\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v).\n            |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> V = {v});\n     f \\<in> set (facesAt g u); u \\<in> V; v \\<in> V; u \\<noteq> v;\n     u \\<in> \\<V> f\\<rbrakk>\n    \\<Longrightarrow> False", "(* why does blast get stuck? *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = f \\<bullet> (f \\<bullet> u); v \\<in> \\<V> f;\n     |vertices f| \\<le> 4;\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V) \\<and>\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v).\n            |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> V = {v});\n     f \\<in> set (facesAt g u); u \\<in> V; v \\<in> V; u \\<noteq> v;\n     u \\<in> \\<V> f\\<rbrakk>\n    \\<Longrightarrow> False", "apply(subgoal_tac \"f \\<bullet> (f \\<bullet> u) \\<in> \\<V> f \\<inter> V\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v = f \\<bullet> (f \\<bullet> u); v \\<in> \\<V> f;\n     |vertices f| \\<le> 4;\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V) \\<and>\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v).\n            |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> V = {v});\n     f \\<in> set (facesAt g u); u \\<in> V; v \\<in> V; u \\<noteq> v;\n     u \\<in> \\<V> f;\n     f \\<bullet> (f \\<bullet> u) \\<in> \\<V> f \\<inter> V\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>v = f \\<bullet> (f \\<bullet> u); v \\<in> \\<V> f;\n     |vertices f| \\<le> 4;\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V) \\<and>\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v).\n            |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> V = {v});\n     f \\<in> set (facesAt g u); u \\<in> V; v \\<in> V; u \\<noteq> v;\n     u \\<in> \\<V> f\\<rbrakk>\n    \\<Longrightarrow> f \\<bullet> (f \\<bullet> u) \\<in> \\<V> f \\<inter> V", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v = f \\<bullet> (f \\<bullet> u); v \\<in> \\<V> f;\n     |vertices f| \\<le> 4;\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V) \\<and>\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v).\n            |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> V = {v});\n     f \\<in> set (facesAt g u); u \\<in> V; v \\<in> V; u \\<noteq> v;\n     u \\<in> \\<V> f\\<rbrakk>\n    \\<Longrightarrow> f \\<bullet> (f \\<bullet> u) \\<in> \\<V> f \\<inter> V\n 2. \\<lbrakk>v = f \\<bullet> (f \\<bullet> u); v \\<in> \\<V> f;\n     |vertices f| \\<le> 4;\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V) \\<and>\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v).\n            |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> V = {v});\n     f \\<in> set (facesAt g u); u \\<in> V; v \\<in> V; u \\<noteq> v;\n     u \\<in> \\<V> f;\n     f \\<bullet> (f \\<bullet> u) \\<in> \\<V> f \\<inter> V\\<rbrakk>\n    \\<Longrightarrow> False", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = f \\<bullet> (f \\<bullet> u); v \\<in> \\<V> f;\n     |vertices f| \\<le> 4;\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V) \\<and>\n     (\\<forall>v\\<in>V.\n         \\<forall>f\\<in>set (facesAt g v).\n            |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> V = {v});\n     f \\<in> set (facesAt g u); u \\<in> V; v \\<in> V; u \\<noteq> v;\n     u \\<in> \\<V> f;\n     f \\<bullet> (f \\<bullet> u) \\<in> \\<V> f \\<inter> V\\<rbrakk>\n    \\<Longrightarrow> False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 4 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 4 \\<Longrightarrow> False", "assume 4: \"|vertices f| \\<noteq> 4\""], ["proof (state)\nthis:\n  |vertices f| \\<noteq> 4\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 4 \\<Longrightarrow> False", "hence \"v = f \\<bullet> u\""], ["proof (prove)\nusing this:\n  |vertices f| \\<noteq> 4\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> u", "using \"if\""], ["proof (prove)\nusing this:\n  |vertices f| \\<noteq> 4\n  if |vertices f| = 4\n  then v = f \\<bullet> u \\<or> v = f \\<bullet> (f \\<bullet> u)\n  else v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. v = f \\<bullet> u", "by simp"], ["proof (state)\nthis:\n  v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 4 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v = f \\<bullet> u\n\ngoal (1 subgoal):\n 1. False", "using sep f uv"], ["proof (prove)\nusing this:\n  v = f \\<bullet> u\n  separated g V\n  f \\<in> set (facesAt g u)\n  u \\<in> V\n  v \\<in> V\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. False", "by(simp add:separated_def separated\\<^sub>2_def separated\\<^sub>3_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u\\<in>V.\n     \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V.\n       \\<forall>v\\<in>V.\n          u \\<noteq> v \\<longrightarrow>\n          \\<not> close g u v \\<Longrightarrow>\n    separated g V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V.\n       \\<forall>v\\<in>V.\n          u \\<noteq> v \\<longrightarrow>\n          \\<not> close g u v \\<Longrightarrow>\n    separated g V", "assume not_cl: ?Q"], ["proof (state)\nthis:\n  \\<forall>u\\<in>V.\n     \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V.\n       \\<forall>v\\<in>V.\n          u \\<noteq> v \\<longrightarrow>\n          \\<not> close g u v \\<Longrightarrow>\n    separated g V", "show ?P"], ["proof (prove)\ngoal (1 subgoal):\n 1. separated g V", "proof(simp add:separated_def, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. separated\\<^sub>2 g V\n 2. separated\\<^sub>3 g V", "show \"separated\\<^sub>2 g V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated\\<^sub>2 g V", "proof (clarsimp simp:separated\\<^sub>2_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        f \\<bullet> v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False", "fix v f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        f \\<bullet> v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False", "assume a: \"v \\<in> V\" \"f \\<in> set (facesAt g v)\" \"f \\<bullet> v \\<in> V\""], ["proof (state)\nthis:\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  f \\<bullet> v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        f \\<bullet> v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False", "have \"v : \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> \\<V> g", "using a(1) \\<open>V \\<subseteq> \\<V> g\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> V\n  V \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. v \\<in> \\<V> g", "by blast"], ["proof (state)\nthis:\n  v \\<in> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        f \\<bullet> v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using a not_cl mgp_facesAt_no_loop[OF mgp \\<open>v : \\<V> g\\<close> a(2)]"], ["proof (prove)\nusing this:\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  f \\<bullet> v \\<in> V\n  \\<forall>u\\<in>V.\n     \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v\n  f \\<bullet> v \\<noteq> v\n\ngoal (1 subgoal):\n 1. False", "by(fastforce simp: close_def split:if_split_asm)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separated\\<^sub>2 g V\n\ngoal (1 subgoal):\n 1. separated\\<^sub>3 g V", "show \"separated\\<^sub>3 g V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated\\<^sub>3 g V", "proof (clarsimp simp:separated\\<^sub>3_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V = {v}", "fix v f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V = {v}", "assume \"v \\<in> V\" and f: \"f \\<in> set (facesAt g v)\" and len: \"|vertices f| \\<le> 4\""], ["proof (state)\nthis:\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V = {v}", "have vg: \"v : \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> \\<V> g", "using \\<open>v : V\\<close> \\<open>V \\<subseteq> \\<V> g\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> V\n  V \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. v \\<in> \\<V> g", "by blast"], ["proof (state)\nthis:\n  v \\<in> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V = {v}", "note distf = minGraphProps3[OF mgp minGraphProps5[OF mgp vg f]]"], ["proof (state)\nthis:\n  distinct (vertices f)\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V = {v}", "note vf = minGraphProps6[OF mgp vg f]"], ["proof (state)\nthis:\n  v \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V = {v}", "{"], ["proof (state)\nthis:\n  v \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V = {v}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V = {v}", "assume \"u \\<in> \\<V> f\" and \"u \\<in> V\""], ["proof (state)\nthis:\n  u \\<in> \\<V> f\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V = {v}", "have \"u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "assume 3: \"|vertices f| = 3\""], ["proof (state)\nthis:\n  triangle f\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "hence \"\\<V> f = {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v)}\""], ["proof (prove)\nusing this:\n  triangle f\n\ngoal (1 subgoal):\n 1. \\<V> f = {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v)}", "using vertices_triangle[OF _ vf distf]"], ["proof (prove)\nusing this:\n  triangle f\n  triangle f \\<Longrightarrow>\n  \\<V> f = {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v)}\n\ngoal (1 subgoal):\n 1. \\<V> f = {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v)}", "by simp"], ["proof (state)\nthis:\n  \\<V> f = {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v)}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "moreover"], ["proof (state)\nthis:\n  \\<V> f = {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v)}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "{"], ["proof (state)\nthis:\n  \\<V> f = {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v)}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "assume \"u = f \\<bullet> v\""], ["proof (state)\nthis:\n  u = f \\<bullet> v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "hence \"u = v\""], ["proof (prove)\nusing this:\n  u = f \\<bullet> v\n\ngoal (1 subgoal):\n 1. u = v", "using not_cl f \\<open>u \\<in> V\\<close> \\<open>v \\<in> V\\<close> 3"], ["proof (prove)\nusing this:\n  u = f \\<bullet> v\n  \\<forall>u\\<in>V.\n     \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v\n  f \\<in> set (facesAt g v)\n  u \\<in> V\n  v \\<in> V\n  triangle f\n\ngoal (1 subgoal):\n 1. u = v", "by(force simp:close_def split:if_split_asm)"], ["proof (state)\nthis:\n  u = v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "}"], ["proof (state)\nthis:\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "moreover"], ["proof (state)\nthis:\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "{"], ["proof (state)\nthis:\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "assume \"u = f \\<bullet> (f \\<bullet> v)\""], ["proof (state)\nthis:\n  u = f \\<bullet> (f \\<bullet> v)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "hence fu: \"f \\<bullet> u = v\""], ["proof (prove)\nusing this:\n  u = f \\<bullet> (f \\<bullet> v)\n\ngoal (1 subgoal):\n 1. f \\<bullet> u = v", "by(simp add: tri_next3_id[OF 3 distf \\<open>v \\<in> \\<V> f\\<close>])"], ["proof (state)\nthis:\n  f \\<bullet> u = v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "hence \"(u,v) \\<in> \\<E> f\""], ["proof (prove)\nusing this:\n  f \\<bullet> u = v\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> \\<E> f", "using nextVertex_in_edges[OF \\<open>u \\<in> \\<V> f\\<close>]"], ["proof (prove)\nusing this:\n  f \\<bullet> u = v\n  (u, f \\<bullet> u) \\<in> \\<E> f\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> \\<E> f", "by(simp add:fu)"], ["proof (state)\nthis:\n  (u, v) \\<in> \\<E> f\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "then"], ["proof (chain)\npicking this:\n  (u, v) \\<in> \\<E> f", "obtain f' where \"f' \\<in> set(facesAt g v)\" \"(v,u) \\<in>  \\<E> f'\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> \\<E> f\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g v); (v, u) \\<in> \\<E> f'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mgp_edge_face_ex[OF mgp vg f]"], ["proof (prove)\nusing this:\n  (u, v) \\<in> \\<E> f\n  (?u, v) \\<in> \\<E> f \\<Longrightarrow>\n  \\<exists>f'\\<in>set (facesAt g v). (v, ?u) \\<in> \\<E> f'\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g v); (v, u) \\<in> \\<E> f'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f' \\<in> set (facesAt g v)\n  (v, u) \\<in> \\<E> f'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "hence \"u = v\""], ["proof (prove)\nusing this:\n  f' \\<in> set (facesAt g v)\n  (v, u) \\<in> \\<E> f'\n\ngoal (1 subgoal):\n 1. u = v", "using not_cl \\<open>u \\<in> V\\<close> \\<open>v \\<in> V\\<close> 3"], ["proof (prove)\nusing this:\n  f' \\<in> set (facesAt g v)\n  (v, u) \\<in> \\<E> f'\n  \\<forall>u\\<in>V.\n     \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v\n  u \\<in> V\n  v \\<in> V\n  triangle f\n\ngoal (1 subgoal):\n 1. u = v", "by(force simp:close_def edges_face_eq split:if_split_asm)"], ["proof (state)\nthis:\n  u = v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "}"], ["proof (state)\nthis:\n  u = f \\<bullet> (f \\<bullet> v) \\<Longrightarrow> u = v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = v\n 2. \\<not> ?P \\<Longrightarrow> u = v", "ultimately"], ["proof (chain)\npicking this:\n  \\<V> f = {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v)}\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n  u = f \\<bullet> (f \\<bullet> v) \\<Longrightarrow> u = v", "show \"u=v\""], ["proof (prove)\nusing this:\n  \\<V> f = {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v)}\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n  u = f \\<bullet> (f \\<bullet> v) \\<Longrightarrow> u = v\n\ngoal (1 subgoal):\n 1. u = v", "using \\<open>u \\<in> \\<V> f\\<close>"], ["proof (prove)\nusing this:\n  \\<V> f = {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v)}\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n  u = f \\<bullet> (f \\<bullet> v) \\<Longrightarrow> u = v\n  u \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. u = v", "by blast"], ["proof (state)\nthis:\n  u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "assume 3: \"|vertices f| \\<noteq> 3\""], ["proof (state)\nthis:\n  |vertices f| \\<noteq> 3\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "hence 4: \"|vertices f| = 4\""], ["proof (prove)\nusing this:\n  |vertices f| \\<noteq> 3\n\ngoal (1 subgoal):\n 1. |vertices f| = 4", "using len mgp_vertices3[OF mgp minGraphProps5[OF mgp vg f]]"], ["proof (prove)\nusing this:\n  |vertices f| \\<noteq> 3\n  |vertices f| \\<le> 4\n  3 \\<le> |vertices f|\n\ngoal (1 subgoal):\n 1. |vertices f| = 4", "by arith"], ["proof (state)\nthis:\n  |vertices f| = 4\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "hence \"\\<V> f = {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v), f \\<bullet> (f \\<bullet> (f \\<bullet> v))}\""], ["proof (prove)\nusing this:\n  |vertices f| = 4\n\ngoal (1 subgoal):\n 1. \\<V> f =\n    {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v),\n     f \\<bullet> (f \\<bullet> (f \\<bullet> v))}", "using vertices_quad[OF _ vf distf]"], ["proof (prove)\nusing this:\n  |vertices f| = 4\n  |vertices f| = 4 \\<Longrightarrow>\n  \\<V> f =\n  {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v),\n   f \\<bullet> (f \\<bullet> (f \\<bullet> v))}\n\ngoal (1 subgoal):\n 1. \\<V> f =\n    {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v),\n     f \\<bullet> (f \\<bullet> (f \\<bullet> v))}", "by simp"], ["proof (state)\nthis:\n  \\<V> f =\n  {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v),\n   f \\<bullet> (f \\<bullet> (f \\<bullet> v))}\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "moreover"], ["proof (state)\nthis:\n  \\<V> f =\n  {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v),\n   f \\<bullet> (f \\<bullet> (f \\<bullet> v))}\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "{"], ["proof (state)\nthis:\n  \\<V> f =\n  {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v),\n   f \\<bullet> (f \\<bullet> (f \\<bullet> v))}\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "assume \"u = f \\<bullet> v\""], ["proof (state)\nthis:\n  u = f \\<bullet> v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "hence \"u = v\""], ["proof (prove)\nusing this:\n  u = f \\<bullet> v\n\ngoal (1 subgoal):\n 1. u = v", "using not_cl f \\<open>u \\<in> V\\<close> \\<open>v \\<in> V\\<close> 4"], ["proof (prove)\nusing this:\n  u = f \\<bullet> v\n  \\<forall>u\\<in>V.\n     \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v\n  f \\<in> set (facesAt g v)\n  u \\<in> V\n  v \\<in> V\n  |vertices f| = 4\n\ngoal (1 subgoal):\n 1. u = v", "by(force simp:close_def split:if_split_asm)"], ["proof (state)\nthis:\n  u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "}"], ["proof (state)\nthis:\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "moreover"], ["proof (state)\nthis:\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "{"], ["proof (state)\nthis:\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "assume \"u = f \\<bullet> (f \\<bullet> v)\""], ["proof (state)\nthis:\n  u = f \\<bullet> (f \\<bullet> v)\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "hence \"u = v\""], ["proof (prove)\nusing this:\n  u = f \\<bullet> (f \\<bullet> v)\n\ngoal (1 subgoal):\n 1. u = v", "using not_cl f \\<open>u \\<in> V\\<close> \\<open>v \\<in> V\\<close> 4"], ["proof (prove)\nusing this:\n  u = f \\<bullet> (f \\<bullet> v)\n  \\<forall>u\\<in>V.\n     \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v\n  f \\<in> set (facesAt g v)\n  u \\<in> V\n  v \\<in> V\n  |vertices f| = 4\n\ngoal (1 subgoal):\n 1. u = v", "by(force simp:close_def split:if_split_asm)"], ["proof (state)\nthis:\n  u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "}"], ["proof (state)\nthis:\n  u = f \\<bullet> (f \\<bullet> v) \\<Longrightarrow> u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "moreover"], ["proof (state)\nthis:\n  u = f \\<bullet> (f \\<bullet> v) \\<Longrightarrow> u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "{"], ["proof (state)\nthis:\n  u = f \\<bullet> (f \\<bullet> v) \\<Longrightarrow> u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "assume \"u = f \\<bullet> (f \\<bullet> (f \\<bullet> v))\""], ["proof (state)\nthis:\n  u = f \\<bullet> (f \\<bullet> (f \\<bullet> v))\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "hence fu: \"f \\<bullet> u = v\""], ["proof (prove)\nusing this:\n  u = f \\<bullet> (f \\<bullet> (f \\<bullet> v))\n\ngoal (1 subgoal):\n 1. f \\<bullet> u = v", "by(simp add: quad_next4_id[OF 4 distf \\<open>v \\<in> \\<V> f\\<close>])"], ["proof (state)\nthis:\n  f \\<bullet> u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "hence \"(u,v) \\<in> \\<E> f\""], ["proof (prove)\nusing this:\n  f \\<bullet> u = v\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> \\<E> f", "using nextVertex_in_edges[OF \\<open>u \\<in> \\<V> f\\<close>]"], ["proof (prove)\nusing this:\n  f \\<bullet> u = v\n  (u, f \\<bullet> u) \\<in> \\<E> f\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> \\<E> f", "by(simp add:fu)"], ["proof (state)\nthis:\n  (u, v) \\<in> \\<E> f\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "then"], ["proof (chain)\npicking this:\n  (u, v) \\<in> \\<E> f", "obtain f' where \"f' \\<in> set(facesAt g v)\" \"(v,u) \\<in>  \\<E> f'\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> \\<E> f\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g v); (v, u) \\<in> \\<E> f'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mgp_edge_face_ex[OF mgp vg f]"], ["proof (prove)\nusing this:\n  (u, v) \\<in> \\<E> f\n  (?u, v) \\<in> \\<E> f \\<Longrightarrow>\n  \\<exists>f'\\<in>set (facesAt g v). (v, ?u) \\<in> \\<E> f'\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g v); (v, u) \\<in> \\<E> f'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f' \\<in> set (facesAt g v)\n  (v, u) \\<in> \\<E> f'\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "hence \"u = v\""], ["proof (prove)\nusing this:\n  f' \\<in> set (facesAt g v)\n  (v, u) \\<in> \\<E> f'\n\ngoal (1 subgoal):\n 1. u = v", "using not_cl \\<open>u \\<in> V\\<close> \\<open>v \\<in> V\\<close> 4"], ["proof (prove)\nusing this:\n  f' \\<in> set (facesAt g v)\n  (v, u) \\<in> \\<E> f'\n  \\<forall>u\\<in>V.\n     \\<forall>v\\<in>V. u \\<noteq> v \\<longrightarrow> \\<not> close g u v\n  u \\<in> V\n  v \\<in> V\n  |vertices f| = 4\n\ngoal (1 subgoal):\n 1. u = v", "by(force simp:close_def edges_face_eq split:if_split_asm)"], ["proof (state)\nthis:\n  u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "}"], ["proof (state)\nthis:\n  u = f \\<bullet> (f \\<bullet> (f \\<bullet> v)) \\<Longrightarrow> u = v\n\ngoal (1 subgoal):\n 1. |vertices f| \\<noteq> 3 \\<Longrightarrow> u = v", "ultimately"], ["proof (chain)\npicking this:\n  \\<V> f =\n  {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v),\n   f \\<bullet> (f \\<bullet> (f \\<bullet> v))}\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n  u = f \\<bullet> (f \\<bullet> v) \\<Longrightarrow> u = v\n  u = f \\<bullet> (f \\<bullet> (f \\<bullet> v)) \\<Longrightarrow> u = v", "show \"u=v\""], ["proof (prove)\nusing this:\n  \\<V> f =\n  {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v),\n   f \\<bullet> (f \\<bullet> (f \\<bullet> v))}\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n  u = f \\<bullet> (f \\<bullet> v) \\<Longrightarrow> u = v\n  u = f \\<bullet> (f \\<bullet> (f \\<bullet> v)) \\<Longrightarrow> u = v\n\ngoal (1 subgoal):\n 1. u = v", "using \\<open>u \\<in> \\<V> f\\<close>"], ["proof (prove)\nusing this:\n  \\<V> f =\n  {v, f \\<bullet> v, f \\<bullet> (f \\<bullet> v),\n   f \\<bullet> (f \\<bullet> (f \\<bullet> v))}\n  u = f \\<bullet> v \\<Longrightarrow> u = v\n  u = f \\<bullet> (f \\<bullet> v) \\<Longrightarrow> u = v\n  u = f \\<bullet> (f \\<bullet> (f \\<bullet> v)) \\<Longrightarrow> u = v\n  u \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. u = v", "by blast"], ["proof (state)\nthis:\n  u = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u = v\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V = {v}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 \\<in> \\<V> f; ?u2 \\<in> V\\<rbrakk> \\<Longrightarrow> ?u2 = v\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V = {v}", "thus \"\\<V> f \\<inter> V = {v}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?u2 \\<in> \\<V> f; ?u2 \\<in> V\\<rbrakk> \\<Longrightarrow> ?u2 = v\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> V = {v}", "using \\<open>v \\<in> V\\<close> vf"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u2 \\<in> \\<V> f; ?u2 \\<in> V\\<rbrakk> \\<Longrightarrow> ?u2 = v\n  v \\<in> V\n  v \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> V = {v}", "by blast"], ["proof (state)\nthis:\n  \\<V> f \\<inter> V = {v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separated\\<^sub>3 g V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separated g V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sep_ne: \"\\<exists>P \\<subseteq> M. separated g (fst ` P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P\\<subseteq>M. separated g (fst ` P)", "by(unfold separated_def separated\\<^sub>2_def separated\\<^sub>3_def) blast"], ["", "lemma ExcessNotAtRec_conv_Max:\nassumes mgp: \"minGraphProps g\"\nshows \"set(map fst ps) \\<subseteq> \\<V> g \\<Longrightarrow> distinct(map fst ps) \\<Longrightarrow>\n  ExcessNotAtRec ps g =\n  Max{ \\<Sum>p\\<in>P. snd p |P. P \\<subseteq> set ps \\<and> separated g (fst ` P)}\"\n  (is \"_ \\<Longrightarrow> _ \\<Longrightarrow> _ = Max(?M ps)\" is \"_ \\<Longrightarrow> _ \\<Longrightarrow> _ = Max{_ |P. ?S ps P}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (map fst ps) \\<subseteq> \\<V> g;\n     distinct (map fst ps)\\<rbrakk>\n    \\<Longrightarrow> ExcessNotAtRec ps g =\n                      Max {sum snd P |P.\n                           P \\<subseteq> set ps \\<and>\n                           separated g (fst ` P)}", "proof(induct ps rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   |ys| < |xs| \\<longrightarrow>\n                   set (map fst ys) \\<subseteq> \\<V> g \\<longrightarrow>\n                   distinct (map fst ys) \\<longrightarrow>\n                   ExcessNotAtRec ys g =\n                   Max {sum snd P |P.\n                        P \\<subseteq> set ys \\<and> separated g (fst ` P)};\n        set (map fst xs) \\<subseteq> \\<V> g; distinct (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec xs g =\n                         Max {sum snd P |P.\n                              P \\<subseteq> set xs \\<and>\n                              separated g (fst ` P)}", "case (1 ps0)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     |ys| < |ps0| \\<longrightarrow>\n     set (map fst ys) \\<subseteq> \\<V> g \\<longrightarrow>\n     distinct (map fst ys) \\<longrightarrow>\n     ExcessNotAtRec ys g =\n     Max {sum snd P |P. P \\<subseteq> set ys \\<and> separated g (fst ` P)}\n  set (map fst ps0) \\<subseteq> \\<V> g\n  distinct (map fst ps0)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   |ys| < |xs| \\<longrightarrow>\n                   set (map fst ys) \\<subseteq> \\<V> g \\<longrightarrow>\n                   distinct (map fst ys) \\<longrightarrow>\n                   ExcessNotAtRec ys g =\n                   Max {sum snd P |P.\n                        P \\<subseteq> set ys \\<and> separated g (fst ` P)};\n        set (map fst xs) \\<subseteq> \\<V> g; distinct (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec xs g =\n                         Max {sum snd P |P.\n                              P \\<subseteq> set xs \\<and>\n                              separated g (fst ` P)}", "note IH = 1(1) and subset = 1(2) and dist = 1(3)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     |ys| < |ps0| \\<longrightarrow>\n     set (map fst ys) \\<subseteq> \\<V> g \\<longrightarrow>\n     distinct (map fst ys) \\<longrightarrow>\n     ExcessNotAtRec ys g =\n     Max {sum snd P |P. P \\<subseteq> set ys \\<and> separated g (fst ` P)}\n  set (map fst ps0) \\<subseteq> \\<V> g\n  distinct (map fst ps0)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   |ys| < |xs| \\<longrightarrow>\n                   set (map fst ys) \\<subseteq> \\<V> g \\<longrightarrow>\n                   distinct (map fst ys) \\<longrightarrow>\n                   ExcessNotAtRec ys g =\n                   Max {sum snd P |P.\n                        P \\<subseteq> set ys \\<and> separated g (fst ` P)};\n        set (map fst xs) \\<subseteq> \\<V> g; distinct (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec xs g =\n                         Max {sum snd P |P.\n                              P \\<subseteq> set xs \\<and>\n                              separated g (fst ` P)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ExcessNotAtRec ps0 g =\n    Max {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "proof (cases ps0)"], ["proof (state)\ngoal (2 subgoals):\n 1. ps0 = [] \\<Longrightarrow>\n    ExcessNotAtRec ps0 g =\n    Max {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}\n 2. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "case Nil"], ["proof (state)\nthis:\n  ps0 = []\n\ngoal (2 subgoals):\n 1. ps0 = [] \\<Longrightarrow>\n    ExcessNotAtRec ps0 g =\n    Max {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}\n 2. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ps0 = []\n\ngoal (1 subgoal):\n 1. ExcessNotAtRec ps0 g =\n    Max {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "by simp"], ["proof (state)\nthis:\n  ExcessNotAtRec ps0 g =\n  Max {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "case (Cons p ps)"], ["proof (state)\nthis:\n  ps0 = p # ps\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "let ?ps = \"deleteAround g (fst p) ps\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have le: \"|?ps| \\<le> |ps|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |deleteAround g (fst p) ps| \\<le> |ps|", "by(simp add:delAround_def)"], ["proof (state)\nthis:\n  |deleteAround g (fst p) ps| \\<le> |ps|\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have dist': \"distinct(map fst ?ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (deleteAround g (fst p) ps))", "using dist Cons"], ["proof (prove)\nusing this:\n  distinct (map fst ps0)\n  ps0 = p # ps\n\ngoal (1 subgoal):\n 1. distinct (map fst (deleteAround g (fst p) ps))", "apply (clarsimp simp:delAround_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps0 = p # ps; fst p \\<notin> fst ` set ps;\n     distinct (map fst ps)\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map fst\n                         (filter\n                           (\\<lambda>pa. \\<not> close g (fst p) (fst pa))\n                           ps))", "apply(drule distinct_filter[where P = \"Not \\<circ> close g (fst p)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ps0 = p # ps; fst p \\<notin> fst ` set ps;\n     distinct (filter (Not \\<circ> close g (fst p)) (map fst ps))\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map fst\n                         (filter\n                           (\\<lambda>pa. \\<not> close g (fst p) (fst pa))\n                           ps))", "apply(simp add: filter_map o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (map fst (deleteAround g (fst p) ps))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have \"fst p : \\<V> g\" and \"fst ` set ps \\<subseteq> \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst p \\<in> \\<V> g &&& fst ` set ps \\<subseteq> \\<V> g", "using subset Cons"], ["proof (prove)\nusing this:\n  set (map fst ps0) \\<subseteq> \\<V> g\n  ps0 = p # ps\n\ngoal (1 subgoal):\n 1. fst p \\<in> \\<V> g &&& fst ` set ps \\<subseteq> \\<V> g", "by auto"], ["proof (state)\nthis:\n  fst p \\<in> \\<V> g\n  fst ` set ps \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have sub1: \"\\<And>P Q. P \\<subseteq> {x : set ps. Q x} \\<Longrightarrow> fst ` P \\<subseteq> \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       P \\<subseteq> {x \\<in> set ps. Q x} \\<Longrightarrow>\n       fst ` P \\<subseteq> \\<V> g", "using subset Cons"], ["proof (prove)\nusing this:\n  set (map fst ps0) \\<subseteq> \\<V> g\n  ps0 = p # ps\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       P \\<subseteq> {x \\<in> set ps. Q x} \\<Longrightarrow>\n       fst ` P \\<subseteq> \\<V> g", "by auto"], ["proof (state)\nthis:\n  ?P \\<subseteq> {x \\<in> set ps. ?Q x} \\<Longrightarrow>\n  fst ` ?P \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have sub2: \"\\<And>P Q. P \\<subseteq> insert p {x : set ps. Q x} \\<Longrightarrow> fst ` P \\<subseteq> \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       P \\<subseteq> insert p {x \\<in> set ps. Q x} \\<Longrightarrow>\n       fst ` P \\<subseteq> \\<V> g", "using subset Cons"], ["proof (prove)\nusing this:\n  set (map fst ps0) \\<subseteq> \\<V> g\n  ps0 = p # ps\n\ngoal (1 subgoal):\n 1. \\<And>P Q.\n       P \\<subseteq> insert p {x \\<in> set ps. Q x} \\<Longrightarrow>\n       fst ` P \\<subseteq> \\<V> g", "by auto"], ["proof (state)\nthis:\n  ?P \\<subseteq> insert p {x \\<in> set ps. ?Q x} \\<Longrightarrow>\n  fst ` ?P \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have sub3: \"\\<And>P. P \\<subseteq> insert p (set ps) \\<Longrightarrow> fst ` P \\<subseteq> \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       P \\<subseteq> insert p (set ps) \\<Longrightarrow>\n       fst ` P \\<subseteq> \\<V> g", "using subset Cons"], ["proof (prove)\nusing this:\n  set (map fst ps0) \\<subseteq> \\<V> g\n  ps0 = p # ps\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       P \\<subseteq> insert p (set ps) \\<Longrightarrow>\n       fst ` P \\<subseteq> \\<V> g", "by auto"], ["proof (state)\nthis:\n  ?P \\<subseteq> insert p (set ps) \\<Longrightarrow>\n  fst ` ?P \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have \"\\<And>a. set (map fst (deleteAround g a ps)) \\<subseteq> \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. set (map fst (deleteAround g a ps)) \\<subseteq> \\<V> g", "using deleteAround_subset[of g _ ps] subset Cons"], ["proof (prove)\nusing this:\n  set (deleteAround g ?a ps) \\<subseteq> set ps\n  set (map fst ps0) \\<subseteq> \\<V> g\n  ps0 = p # ps\n\ngoal (1 subgoal):\n 1. \\<And>a. set (map fst (deleteAround g a ps)) \\<subseteq> \\<V> g", "by auto"], ["proof (state)\nthis:\n  set (map fst (deleteAround g ?a ps)) \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "hence \"ExcessNotAtRec ps0 g = max (Max(?M ps)) (Max(?M ?ps) + snd p)\""], ["proof (prove)\nusing this:\n  set (map fst (deleteAround g ?a ps)) \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. ExcessNotAtRec ps0 g =\n    max (Max {sum snd P |P.\n              P \\<subseteq> set ps \\<and> separated g (fst ` P)})\n     (Max {sum snd P |P.\n           P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n           separated g (fst ` P)} +\n      snd p)", "using Cons IH subset le dist dist'"], ["proof (prove)\nusing this:\n  set (map fst (deleteAround g ?a ps)) \\<subseteq> \\<V> g\n  ps0 = p # ps\n  \\<forall>ys.\n     |ys| < |ps0| \\<longrightarrow>\n     set (map fst ys) \\<subseteq> \\<V> g \\<longrightarrow>\n     distinct (map fst ys) \\<longrightarrow>\n     ExcessNotAtRec ys g =\n     Max {sum snd P |P. P \\<subseteq> set ys \\<and> separated g (fst ` P)}\n  set (map fst ps0) \\<subseteq> \\<V> g\n  |deleteAround g (fst p) ps| \\<le> |ps|\n  distinct (map fst ps0)\n  distinct (map fst (deleteAround g (fst p) ps))\n\ngoal (1 subgoal):\n 1. ExcessNotAtRec ps0 g =\n    max (Max {sum snd P |P.\n              P \\<subseteq> set ps \\<and> separated g (fst ` P)})\n     (Max {sum snd P |P.\n           P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n           separated g (fst ` P)} +\n      snd p)", "by (cases p) simp"], ["proof (state)\nthis:\n  ExcessNotAtRec ps0 g =\n  max (Max {sum snd P |P.\n            P \\<subseteq> set ps \\<and> separated g (fst ` P)})\n   (Max {sum snd P |P.\n         P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n         separated g (fst ` P)} +\n    snd p)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "also"], ["proof (state)\nthis:\n  ExcessNotAtRec ps0 g =\n  max (Max {sum snd P |P.\n            P \\<subseteq> set ps \\<and> separated g (fst ` P)})\n   (Max {sum snd P |P.\n         P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n         separated g (fst ` P)} +\n    snd p)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have \"Max (?M ?ps) + snd p =\n      Max {(\\<Sum>p\\<in>P. snd p) + snd p | P. ?S ?ps P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {sum snd P |P.\n         P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n         separated g (fst ` P)} +\n    snd p =\n    Max {sum snd P + snd p |P.\n         P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n         separated g (fst ` P)}", "by (auto simp add:setcompr_eq_image Max_add_commute[symmetric] sep_ne intro!: arg_cong [where f=Max])"], ["proof (state)\nthis:\n  Max {sum snd P |P.\n       P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n       separated g (fst ` P)} +\n  snd p =\n  Max {sum snd P + snd p |P.\n       P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n       separated g (fst ` P)}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "also"], ["proof (state)\nthis:\n  Max {sum snd P |P.\n       P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n       separated g (fst ` P)} +\n  snd p =\n  Max {sum snd P + snd p |P.\n       P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n       separated g (fst ` P)}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have \"{(\\<Sum>p\\<in>P. snd p) + snd p |P. ?S ?ps P} =\n      {sum snd (insert p P) |P. ?S ?ps P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {sum snd P + snd p |P.\n     P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n     separated g (fst ` P)} =\n    {sum snd (insert p P) |P.\n     P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n     separated g (fst ` P)}", "using dist Cons"], ["proof (prove)\nusing this:\n  distinct (map fst ps0)\n  ps0 = p # ps\n\ngoal (1 subgoal):\n 1. {sum snd P + snd p |P.\n     P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n     separated g (fst ` P)} =\n    {sum snd (insert p P) |P.\n     P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n     separated g (fst ` P)}", "apply (auto simp:delAround_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>ps0 = p # ps; fst p \\<notin> fst ` set ps;\n        distinct (map fst ps);\n        P \\<subseteq> {x \\<in> set ps. \\<not> close g (fst p) (fst x)};\n        separated g (fst ` P)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd P + snd p = sum snd (insert p Pa) \\<and>\n                            Pa \\<subseteq> {x \\<in> set ps.\n      \\<not> close g (fst p) (fst x)} \\<and>\n                            separated g (fst ` Pa)\n 2. \\<And>P.\n       \\<lbrakk>ps0 = p # ps; fst p \\<notin> fst ` set ps;\n        distinct (map fst ps);\n        P \\<subseteq> {x \\<in> set ps. \\<not> close g (fst p) (fst x)};\n        separated g (fst ` P)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd (insert p P) = sum snd Pa + snd p \\<and>\n                            Pa \\<subseteq> {x \\<in> set ps.\n      \\<not> close g (fst p) (fst x)} \\<and>\n                            separated g (fst ` Pa)", "apply(rule_tac x=P in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>ps0 = p # ps; fst p \\<notin> fst ` set ps;\n        distinct (map fst ps);\n        P \\<subseteq> {x \\<in> set ps. \\<not> close g (fst p) (fst x)};\n        separated g (fst ` P)\\<rbrakk>\n       \\<Longrightarrow> sum snd P + snd p = sum snd (insert p P) \\<and>\n                         P \\<subseteq> {x \\<in> set ps.\n  \\<not> close g (fst p) (fst x)} \\<and>\n                         separated g (fst ` P)\n 2. \\<And>P.\n       \\<lbrakk>ps0 = p # ps; fst p \\<notin> fst ` set ps;\n        distinct (map fst ps);\n        P \\<subseteq> {x \\<in> set ps. \\<not> close g (fst p) (fst x)};\n        separated g (fst ` P)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd (insert p P) = sum snd Pa + snd p \\<and>\n                            Pa \\<subseteq> {x \\<in> set ps.\n      \\<not> close g (fst p) (fst x)} \\<and>\n                            separated g (fst ` Pa)", "apply(fastforce intro!: sum.insert[THEN trans,symmetric] elim: finite_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>ps0 = p # ps; fst p \\<notin> fst ` set ps;\n        distinct (map fst ps);\n        P \\<subseteq> {x \\<in> set ps. \\<not> close g (fst p) (fst x)};\n        separated g (fst ` P)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd (insert p P) = sum snd Pa + snd p \\<and>\n                            Pa \\<subseteq> {x \\<in> set ps.\n      \\<not> close g (fst p) (fst x)} \\<and>\n                            separated g (fst ` Pa)", "apply(rule_tac x=P in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>ps0 = p # ps; fst p \\<notin> fst ` set ps;\n        distinct (map fst ps);\n        P \\<subseteq> {x \\<in> set ps. \\<not> close g (fst p) (fst x)};\n        separated g (fst ` P)\\<rbrakk>\n       \\<Longrightarrow> sum snd (insert p P) = sum snd P + snd p \\<and>\n                         P \\<subseteq> {x \\<in> set ps.\n  \\<not> close g (fst p) (fst x)} \\<and>\n                         separated g (fst ` P)", "apply(fastforce intro!: sum.insert[THEN trans] elim: finite_subset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {sum snd P + snd p |P.\n   P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n   separated g (fst ` P)} =\n  {sum snd (insert p P) |P.\n   P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n   separated g (fst ` P)}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "also"], ["proof (state)\nthis:\n  {sum snd P + snd p |P.\n   P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n   separated g (fst ` P)} =\n  {sum snd (insert p P) |P.\n   P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n   separated g (fst ` P)}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have \"\\<dots> = {sum snd P |P.\n            P \\<subseteq> insert p (set ?ps) \\<and> p \\<in> P \\<and> separated g (fst ` P)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {sum snd (insert p P) |P.\n     P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n     separated g (fst ` P)} =\n    {sum snd P |P.\n     P \\<subseteq> insert p (set (deleteAround g (fst p) ps)) \\<and>\n     p \\<in> P \\<and> separated g (fst ` P)}", "apply(auto simp add:sep_conv[OF mgp] sub1 sub2 delAround_def cong: conj_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>P \\<subseteq> {x \\<in> set ps.\n                               \\<not> close g (fst p) (fst x)};\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd (insert p P) = sum snd Pa \\<and>\n                            Pa \\<subseteq> insert p\n      {x \\<in> set ps. \\<not> close g (fst p) (fst x)} \\<and>\n                            p \\<in> Pa \\<and>\n                            (\\<forall>u\\<in>Pa.\n                                \\<forall>v\\<in>Pa.\n                                   fst u \\<noteq> fst v \\<longrightarrow>\n                                   \\<not> close g (fst u) (fst v))\n 2. \\<And>P.\n       \\<lbrakk>P \\<subseteq> insert p\n                               {x \\<in> set ps.\n                                \\<not> close g (fst p) (fst x)};\n        p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd P = sum snd (insert p Pa) \\<and>\n                            Pa \\<subseteq> {x \\<in> set ps.\n      \\<not> close g (fst p) (fst x)} \\<and>\n                            (\\<forall>u\\<in>Pa.\n                                \\<forall>v\\<in>Pa.\n                                   fst u \\<noteq> fst v \\<longrightarrow>\n                                   \\<not> close g (fst u) (fst v))", "apply(rule_tac x = \"insert p P\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>P \\<subseteq> {x \\<in> set ps.\n                               \\<not> close g (fst p) (fst x)};\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> sum snd (insert p P) = sum snd (insert p P) \\<and>\n                         insert p P\n                         \\<subseteq> insert p\n{x \\<in> set ps. \\<not> close g (fst p) (fst x)} \\<and>\n                         p \\<in> insert p P \\<and>\n                         (\\<forall>u\\<in>insert p P.\n                             \\<forall>v\\<in>insert p P.\n                                fst u \\<noteq> fst v \\<longrightarrow>\n                                \\<not> close g (fst u) (fst v))\n 2. \\<And>P.\n       \\<lbrakk>P \\<subseteq> insert p\n                               {x \\<in> set ps.\n                                \\<not> close g (fst p) (fst x)};\n        p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd P = sum snd (insert p Pa) \\<and>\n                            Pa \\<subseteq> {x \\<in> set ps.\n      \\<not> close g (fst p) (fst x)} \\<and>\n                            (\\<forall>u\\<in>Pa.\n                                \\<forall>v\\<in>Pa.\n                                   fst u \\<noteq> fst v \\<longrightarrow>\n                                   \\<not> close g (fst u) (fst v))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>P \\<subseteq> {x \\<in> set ps.\n                               \\<not> close g (fst p) (fst x)};\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> P \\<subseteq> insert p\n  {x \\<in> set ps. \\<not> close g (fst p) (fst x)} \\<and>\n                         (\\<forall>v\\<in>P.\n                             fst p \\<noteq> fst v \\<longrightarrow>\n                             \\<not> close g (fst p) (fst v)) \\<and>\n                         (\\<forall>u\\<in>P.\n                             fst u \\<noteq> fst p \\<longrightarrow>\n                             \\<not> close g (fst u) (fst p))\n 2. \\<And>P.\n       \\<lbrakk>P \\<subseteq> insert p\n                               {x \\<in> set ps.\n                                \\<not> close g (fst p) (fst x)};\n        p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd P = sum snd (insert p Pa) \\<and>\n                            Pa \\<subseteq> {x \\<in> set ps.\n      \\<not> close g (fst p) (fst x)} \\<and>\n                            (\\<forall>u\\<in>Pa.\n                                \\<forall>v\\<in>Pa.\n                                   fst u \\<noteq> fst v \\<longrightarrow>\n                                   \\<not> close g (fst u) (fst v))", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>P \\<subseteq> {x \\<in> set ps.\n                               \\<not> close g (fst p) (fst x)};\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> P \\<subseteq> insert p\n  {x \\<in> set ps. \\<not> close g (fst p) (fst x)}\n 2. \\<And>P.\n       \\<lbrakk>P \\<subseteq> {x \\<in> set ps.\n                               \\<not> close g (fst p) (fst x)};\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>v\\<in>P.\n                             fst p \\<noteq> fst v \\<longrightarrow>\n                             \\<not> close g (fst p) (fst v)) \\<and>\n                         (\\<forall>u\\<in>P.\n                             fst u \\<noteq> fst p \\<longrightarrow>\n                             \\<not> close g (fst u) (fst p))\n 3. \\<And>P.\n       \\<lbrakk>P \\<subseteq> insert p\n                               {x \\<in> set ps.\n                                \\<not> close g (fst p) (fst x)};\n        p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd P = sum snd (insert p Pa) \\<and>\n                            Pa \\<subseteq> {x \\<in> set ps.\n      \\<not> close g (fst p) (fst x)} \\<and>\n                            (\\<forall>u\\<in>Pa.\n                                \\<forall>v\\<in>Pa.\n                                   fst u \\<noteq> fst v \\<longrightarrow>\n                                   \\<not> close g (fst u) (fst v))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>P \\<subseteq> {x \\<in> set ps.\n                               \\<not> close g (fst p) (fst x)};\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>v\\<in>P.\n                             fst p \\<noteq> fst v \\<longrightarrow>\n                             \\<not> close g (fst p) (fst v)) \\<and>\n                         (\\<forall>u\\<in>P.\n                             fst u \\<noteq> fst p \\<longrightarrow>\n                             \\<not> close g (fst u) (fst p))\n 2. \\<And>P.\n       \\<lbrakk>P \\<subseteq> insert p\n                               {x \\<in> set ps.\n                                \\<not> close g (fst p) (fst x)};\n        p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd P = sum snd (insert p Pa) \\<and>\n                            Pa \\<subseteq> {x \\<in> set ps.\n      \\<not> close g (fst p) (fst x)} \\<and>\n                            (\\<forall>u\\<in>Pa.\n                                \\<forall>v\\<in>Pa.\n                                   fst u \\<noteq> fst v \\<longrightarrow>\n                                   \\<not> close g (fst u) (fst v))", "using \\<open>image fst (set ps) \\<subseteq> \\<V> g\\<close> \\<open>fst p : \\<V> g\\<close>"], ["proof (prove)\nusing this:\n  fst ` set ps \\<subseteq> \\<V> g\n  fst p \\<in> \\<V> g\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>P \\<subseteq> {x \\<in> set ps.\n                               \\<not> close g (fst p) (fst x)};\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>v\\<in>P.\n                             fst p \\<noteq> fst v \\<longrightarrow>\n                             \\<not> close g (fst p) (fst v)) \\<and>\n                         (\\<forall>u\\<in>P.\n                             fst u \\<noteq> fst p \\<longrightarrow>\n                             \\<not> close g (fst u) (fst p))\n 2. \\<And>P.\n       \\<lbrakk>P \\<subseteq> insert p\n                               {x \\<in> set ps.\n                                \\<not> close g (fst p) (fst x)};\n        p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd P = sum snd (insert p Pa) \\<and>\n                            Pa \\<subseteq> {x \\<in> set ps.\n      \\<not> close g (fst p) (fst x)} \\<and>\n                            (\\<forall>u\\<in>Pa.\n                                \\<forall>v\\<in>Pa.\n                                   fst u \\<noteq> fst v \\<longrightarrow>\n                                   \\<not> close g (fst u) (fst v))", "apply (blast intro:close_sym[OF mgp])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>P \\<subseteq> insert p\n                               {x \\<in> set ps.\n                                \\<not> close g (fst p) (fst x)};\n        p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd P = sum snd (insert p Pa) \\<and>\n                            Pa \\<subseteq> {x \\<in> set ps.\n      \\<not> close g (fst p) (fst x)} \\<and>\n                            (\\<forall>u\\<in>Pa.\n                                \\<forall>v\\<in>Pa.\n                                   fst u \\<noteq> fst v \\<longrightarrow>\n                                   \\<not> close g (fst u) (fst v))", "apply(rule_tac x = \"P-{p}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>P \\<subseteq> insert p\n                               {x \\<in> set ps.\n                                \\<not> close g (fst p) (fst x)};\n        p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> sum snd P = sum snd (insert p (P - {p})) \\<and>\n                         P - {p}\n                         \\<subseteq> {x \\<in> set ps.\n\\<not> close g (fst p) (fst x)} \\<and>\n                         (\\<forall>u\\<in>P - {p}.\n                             \\<forall>v\\<in>P - {p}.\n                                fst u \\<noteq> fst v \\<longrightarrow>\n                                \\<not> close g (fst u) (fst v))", "apply (simp add:insert_absorb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>P \\<subseteq> insert p\n                               {x \\<in> set ps.\n                                \\<not> close g (fst p) (fst x)};\n        p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> P - {p}\n                         \\<subseteq> {x \\<in> set ps.\n\\<not> close g (fst p) (fst x)}", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {sum snd (insert p P) |P.\n   P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n   separated g (fst ` P)} =\n  {sum snd P |P.\n   P \\<subseteq> insert p (set (deleteAround g (fst p) ps)) \\<and>\n   p \\<in> P \\<and> separated g (fst ` P)}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "also"], ["proof (state)\nthis:\n  {sum snd (insert p P) |P.\n   P \\<subseteq> set (deleteAround g (fst p) ps) \\<and>\n   separated g (fst ` P)} =\n  {sum snd P |P.\n   P \\<subseteq> insert p (set (deleteAround g (fst p) ps)) \\<and>\n   p \\<in> P \\<and> separated g (fst ` P)}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have \"\\<dots> = {sum snd P |P.\n            P \\<subseteq> insert p (set ps) \\<and> p \\<in> P \\<and> separated g (fst ` P)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {sum snd P |P.\n     P \\<subseteq> insert p (set (deleteAround g (fst p) ps)) \\<and>\n     p \\<in> P \\<and> separated g (fst ` P)} =\n    {sum snd P |P.\n     P \\<subseteq> insert p (set ps) \\<and>\n     p \\<in> P \\<and> separated g (fst ` P)}", "using Cons dist"], ["proof (prove)\nusing this:\n  ps0 = p # ps\n  distinct (map fst ps0)\n\ngoal (1 subgoal):\n 1. {sum snd P |P.\n     P \\<subseteq> insert p (set (deleteAround g (fst p) ps)) \\<and>\n     p \\<in> P \\<and> separated g (fst ` P)} =\n    {sum snd P |P.\n     P \\<subseteq> insert p (set ps) \\<and>\n     p \\<in> P \\<and> separated g (fst ` P)}", "apply(auto simp add:sep_conv[OF mgp] sub2 sub3 delAround_def cong: conj_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>ps0 = p # ps; fst p \\<notin> fst ` set ps;\n        distinct (map fst ps); P \\<subseteq> insert p (set ps); p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd P = sum snd Pa \\<and>\n                            Pa \\<subseteq> insert p\n      {x \\<in> set ps. \\<not> close g (fst p) (fst x)} \\<and>\n                            p \\<in> Pa \\<and>\n                            (\\<forall>u\\<in>Pa.\n                                \\<forall>v\\<in>Pa.\n                                   fst u \\<noteq> fst v \\<longrightarrow>\n                                   \\<not> close g (fst u) (fst v))", "apply(rule_tac x = \"P\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>ps0 = p # ps; fst p \\<notin> fst ` set ps;\n        distinct (map fst ps); P \\<subseteq> insert p (set ps); p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> sum snd P = sum snd P \\<and>\n                         P \\<subseteq> insert p\n  {x \\<in> set ps. \\<not> close g (fst p) (fst x)} \\<and>\n                         p \\<in> P \\<and>\n                         (\\<forall>u\\<in>P.\n                             \\<forall>v\\<in>P.\n                                fst u \\<noteq> fst v \\<longrightarrow>\n                                \\<not> close g (fst u) (fst v))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>ps0 = p # ps; fst p \\<notin> fst ` set ps;\n        distinct (map fst ps); P \\<subseteq> insert p (set ps); p \\<in> P;\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v)\\<rbrakk>\n       \\<Longrightarrow> P \\<subseteq> insert p\n  {x \\<in> set ps. \\<not> close g (fst p) (fst x)}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {sum snd P |P.\n   P \\<subseteq> insert p (set (deleteAround g (fst p) ps)) \\<and>\n   p \\<in> P \\<and> separated g (fst ` P)} =\n  {sum snd P |P.\n   P \\<subseteq> insert p (set ps) \\<and>\n   p \\<in> P \\<and> separated g (fst ` P)}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "also"], ["proof (state)\nthis:\n  {sum snd P |P.\n   P \\<subseteq> insert p (set (deleteAround g (fst p) ps)) \\<and>\n   p \\<in> P \\<and> separated g (fst ` P)} =\n  {sum snd P |P.\n   P \\<subseteq> insert p (set ps) \\<and>\n   p \\<in> P \\<and> separated g (fst ` P)}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have \"max (Max(?M ps)) (Max \\<dots>) = Max(?M ps \\<union> {sum snd P |P.\n            P \\<subseteq> insert p (set ps) \\<and> p \\<in> P \\<and> separated g (fst ` P)})\"\n      (is \"_ = Max ?U\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. max (Max {sum snd P |P.\n              P \\<subseteq> set ps \\<and> separated g (fst ` P)})\n     (Max {sum snd P |P.\n           P \\<subseteq> insert p (set ps) \\<and>\n           p \\<in> P \\<and> separated g (fst ` P)}) =\n    Max ({sum snd P |P.\n          P \\<subseteq> set ps \\<and> separated g (fst ` P)} \\<union>\n         {sum snd P |P.\n          P \\<subseteq> insert p (set ps) \\<and>\n          p \\<in> P \\<and> separated g (fst ` P)})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. max (Max {sum snd P |P.\n              P \\<subseteq> set ps \\<and> separated g (fst ` P)})\n     (Max {sum snd P |P.\n           P \\<subseteq> insert p (set ps) \\<and>\n           p \\<in> P \\<and> separated g (fst ` P)}) =\n    Max ({sum snd P |P.\n          P \\<subseteq> set ps \\<and> separated g (fst ` P)} \\<union>\n         {sum snd P |P.\n          P \\<subseteq> insert p (set ps) \\<and>\n          p \\<in> P \\<and> separated g (fst ` P)})", "have \"{sum snd P |P.\n            P \\<subseteq> insert p (set ps) \\<and> p \\<in> P \\<and> separated g (fst ` P)} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {sum snd P |P.\n     P \\<subseteq> insert p (set ps) \\<and>\n     p \\<in> P \\<and> separated g (fst ` P)} \\<noteq>\n    {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       p \\<in> P \\<and>\n       P \\<subseteq> insert p (set ps) \\<and> separated g (fst ` P)", "apply(rule_tac x=\"{p}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> {p} \\<and>\n    {p} \\<subseteq> insert p (set ps) \\<and> separated g (fst ` {p})", "using \\<open>fst p : \\<V> g\\<close>"], ["proof (prove)\nusing this:\n  fst p \\<in> \\<V> g\n\ngoal (1 subgoal):\n 1. p \\<in> {p} \\<and>\n    {p} \\<subseteq> insert p (set ps) \\<and> separated g (fst ` {p})", "by(simp add:sep_conv[OF mgp])"], ["proof (state)\nthis:\n  {sum snd P |P.\n   P \\<subseteq> insert p (set ps) \\<and>\n   p \\<in> P \\<and> separated g (fst ` P)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. max (Max {sum snd P |P.\n              P \\<subseteq> set ps \\<and> separated g (fst ` P)})\n     (Max {sum snd P |P.\n           P \\<subseteq> insert p (set ps) \\<and>\n           p \\<in> P \\<and> separated g (fst ` P)}) =\n    Max ({sum snd P |P.\n          P \\<subseteq> set ps \\<and> separated g (fst ` P)} \\<union>\n         {sum snd P |P.\n          P \\<subseteq> insert p (set ps) \\<and>\n          p \\<in> P \\<and> separated g (fst ` P)})", "thus ?thesis"], ["proof (prove)\nusing this:\n  {sum snd P |P.\n   P \\<subseteq> insert p (set ps) \\<and>\n   p \\<in> P \\<and> separated g (fst ` P)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. max (Max {sum snd P |P.\n              P \\<subseteq> set ps \\<and> separated g (fst ` P)})\n     (Max {sum snd P |P.\n           P \\<subseteq> insert p (set ps) \\<and>\n           p \\<in> P \\<and> separated g (fst ` P)}) =\n    Max ({sum snd P |P.\n          P \\<subseteq> set ps \\<and> separated g (fst ` P)} \\<union>\n         {sum snd P |P.\n          P \\<subseteq> insert p (set ps) \\<and>\n          p \\<in> P \\<and> separated g (fst ` P)})", "by(simp add: Max_Un sep_ne)"], ["proof (state)\nthis:\n  max (Max {sum snd P |P.\n            P \\<subseteq> set ps \\<and> separated g (fst ` P)})\n   (Max {sum snd P |P.\n         P \\<subseteq> insert p (set ps) \\<and>\n         p \\<in> P \\<and> separated g (fst ` P)}) =\n  Max ({sum snd P |P.\n        P \\<subseteq> set ps \\<and> separated g (fst ` P)} \\<union>\n       {sum snd P |P.\n        P \\<subseteq> insert p (set ps) \\<and>\n        p \\<in> P \\<and> separated g (fst ` P)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max (Max {sum snd P |P.\n            P \\<subseteq> set ps \\<and> separated g (fst ` P)})\n   (Max {sum snd P |P.\n         P \\<subseteq> insert p (set ps) \\<and>\n         p \\<in> P \\<and> separated g (fst ` P)}) =\n  Max ({sum snd P |P.\n        P \\<subseteq> set ps \\<and> separated g (fst ` P)} \\<union>\n       {sum snd P |P.\n        P \\<subseteq> insert p (set ps) \\<and>\n        p \\<in> P \\<and> separated g (fst ` P)})\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "also"], ["proof (state)\nthis:\n  max (Max {sum snd P |P.\n            P \\<subseteq> set ps \\<and> separated g (fst ` P)})\n   (Max {sum snd P |P.\n         P \\<subseteq> insert p (set ps) \\<and>\n         p \\<in> P \\<and> separated g (fst ` P)}) =\n  Max ({sum snd P |P.\n        P \\<subseteq> set ps \\<and> separated g (fst ` P)} \\<union>\n       {sum snd P |P.\n        P \\<subseteq> insert p (set ps) \\<and>\n        p \\<in> P \\<and> separated g (fst ` P)})\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "have \"?U = ?M ps0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {sum snd P |P.\n     P \\<subseteq> set ps \\<and> separated g (fst ` P)} \\<union>\n    {sum snd P |P.\n     P \\<subseteq> insert p (set ps) \\<and>\n     p \\<in> P \\<and> separated g (fst ` P)} =\n    {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "using Cons"], ["proof (prove)\nusing this:\n  ps0 = p # ps\n\ngoal (1 subgoal):\n 1. {sum snd P |P.\n     P \\<subseteq> set ps \\<and> separated g (fst ` P)} \\<union>\n    {sum snd P |P.\n     P \\<subseteq> insert p (set ps) \\<and>\n     p \\<in> P \\<and> separated g (fst ` P)} =\n    {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "by simp blast"], ["proof (state)\nthis:\n  {sum snd P |P. P \\<subseteq> set ps \\<and> separated g (fst ` P)} \\<union>\n  {sum snd P |P.\n   P \\<subseteq> insert p (set ps) \\<and>\n   p \\<in> P \\<and> separated g (fst ` P)} =\n  {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ps0 = a # list \\<Longrightarrow>\n       ExcessNotAtRec ps0 g =\n       Max {sum snd P |P.\n            P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "finally"], ["proof (chain)\npicking this:\n  ExcessNotAtRec ps0 g =\n  Max {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "show ?thesis"], ["proof (prove)\nusing this:\n  ExcessNotAtRec ps0 g =\n  Max {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}\n\ngoal (1 subgoal):\n 1. ExcessNotAtRec ps0 g =\n    Max {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}", "."], ["proof (state)\nthis:\n  ExcessNotAtRec ps0 g =\n  Max {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ExcessNotAtRec ps0 g =\n  Max {sum snd P |P. P \\<subseteq> set ps0 \\<and> separated g (fst ` P)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dist_ExcessTab: \"distinct (map fst (ExcessTable g (vertices g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (ExcessTable g (vertices g)))", "by(simp add:ExcessTable_def vertices_graph o_def)"], ["", "lemma mono_ExcessTab: \"\\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); inv g \\<rbrakk> \\<Longrightarrow>\n  set(ExcessTable g (vertices g)) \\<subseteq> set(ExcessTable g' (vertices g'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g\\<rbrakk>\n    \\<Longrightarrow> set (ExcessTable g (vertices g))\n                      \\<subseteq> set (ExcessTable g' (vertices g'))", "apply(clarsimp simp:ExcessTable_def image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; x \\<in> \\<V> g; 0 < ExcessAt g x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<V> g' \\<and>\n                         0 < ExcessAt g' x \\<and>\n                         ExcessAt g x = ExcessAt g' x", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; x \\<in> \\<V> g; 0 < ExcessAt g x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<V> g'\n 2. \\<And>x.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; x \\<in> \\<V> g; 0 < ExcessAt g x\\<rbrakk>\n       \\<Longrightarrow> 0 < ExcessAt g' x \\<and>\n                         ExcessAt g x = ExcessAt g' x", "apply(blast dest:next_plane0_vertices_subset inv_mgp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; x \\<in> \\<V> g; 0 < ExcessAt g x\\<rbrakk>\n       \\<Longrightarrow> 0 < ExcessAt g' x \\<and>\n                         ExcessAt g x = ExcessAt g' x", "apply (clarsimp simp:ExcessAt_def split:if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; x \\<in> \\<V> g; finalVertex g x;\n        0 < excessAtType (tri g x) (quad g x) (except g x)\\<rbrakk>\n       \\<Longrightarrow> finalVertex g' x \\<and>\n                         (finalVertex g' x \\<longrightarrow>\n                          0 < excessAtType (tri g' x) (quad g' x)\n                               (except g' x) \\<and>\n                          excessAtType (tri g x) (quad g x) (except g x) =\n                          excessAtType (tri g' x) (quad g' x) (except g' x))", "apply(frule (3) next_plane0_finalVertex_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; x \\<in> \\<V> g; finalVertex g x;\n        0 < excessAtType (tri g x) (quad g x) (except g x);\n        finalVertex g' x\\<rbrakk>\n       \\<Longrightarrow> finalVertex g' x \\<and>\n                         (finalVertex g' x \\<longrightarrow>\n                          0 < excessAtType (tri g' x) (quad g' x)\n                               (except g' x) \\<and>\n                          excessAtType (tri g x) (quad g x) (except g x) =\n                          excessAtType (tri g' x) (quad g' x) (except g' x))", "apply(simp add: next_plane0_len_filter_eq tri_def quad_def except_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma close_antimono:\n \"\\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); inv g; u \\<in> \\<V> g; finalVertex g u \\<rbrakk> \\<Longrightarrow>\n  close g' u v \\<Longrightarrow> close g u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; u \\<in> \\<V> g; finalVertex g u;\n     close g' u v\\<rbrakk>\n    \\<Longrightarrow> close g u v", "by(simp add:close_def next_plane0_finalVertex_facesAt_eq)"], ["", "lemma ExcessTab_final:\n \"p \\<in> set(ExcessTable g (vertices g)) \\<Longrightarrow> finalVertex g (fst p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set (ExcessTable g (vertices g)) \\<Longrightarrow>\n    finalVertex g (fst p)", "by(clarsimp simp:ExcessTable_def image_def ExcessAt_def split:if_split_asm)"], ["", "lemma ExcessTab_vertex:\n \"p \\<in> set(ExcessTable g (vertices g)) \\<Longrightarrow> fst p \\<in> \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set (ExcessTable g (vertices g)) \\<Longrightarrow>\n    fst p \\<in> \\<V> g", "by(clarsimp simp:ExcessTable_def image_def ExcessAt_def split:if_split_asm)"], ["", "lemma fst_set_ExcessTable_subset:\n \"fst ` set (ExcessTable g (vertices g)) \\<subseteq> \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (ExcessTable g (vertices g)) \\<subseteq> \\<V> g", "by(clarsimp simp:ExcessTable_def image_def ExcessAt_def split:if_split_asm)"], ["", "lemma next_plane0_incr_ExcessNotAt:\n \"\\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); inv g \\<rbrakk> \\<Longrightarrow>\n  ExcessNotAt g None \\<le> ExcessNotAt g' None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g\\<rbrakk>\n    \\<Longrightarrow> ExcessNotAt g None \\<le> ExcessNotAt g' None", "apply(frule (1) invariantE[OF inv_inv_next_plane0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g'\\<rbrakk>\n    \\<Longrightarrow> ExcessNotAt g None \\<le> ExcessNotAt g' None", "apply(frule (1) mono_ExcessTab)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> ExcessNotAt g None \\<le> ExcessNotAt g' None", "apply(simp add: ExcessNotAt_def ExcessNotAtRec_conv_Max[OF _ _ dist_ExcessTab]\n  fst_set_ExcessTable_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> Max {sum snd P |P.\n                           P \\<subseteq> set\n    (ExcessTable g (vertices g)) \\<and>\n                           separated g (fst ` P)}\n                      \\<le> Max {sum snd P |P.\n                                 P \\<subseteq> set\n          (ExcessTable g' (vertices g')) \\<and>\n                                 separated g' (fst ` P)}", "apply(rule Max_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> {sum snd P |P.\n                       P \\<subseteq> set (ExcessTable g (vertices g)) \\<and>\n                       separated g (fst ` P)}\n                      \\<subseteq> {sum snd P |P.\n                                   P \\<subseteq> set\n            (ExcessTable g' (vertices g')) \\<and>\n                                   separated g' (fst ` P)}\n 2. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> {sum snd P |P.\n                       P \\<subseteq> set (ExcessTable g (vertices g)) \\<and>\n                       separated g (fst ` P)} \\<noteq>\n                      {}\n 3. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {sum snd P |P.\n                        P \\<subseteq> set\n (ExcessTable g' (vertices g')) \\<and>\n                        separated g' (fst ` P)}", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> {sum snd P |P.\n                       P \\<subseteq> set (ExcessTable g (vertices g)) \\<and>\n                       separated g (fst ` P)} \\<noteq>\n                      {}\n 2. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> {sum snd P |P.\n                       P \\<subseteq> set (ExcessTable g (vertices g)) \\<and>\n                       separated g (fst ` P)}\n                      \\<subseteq> {sum snd P |P.\n                                   P \\<subseteq> set\n            (ExcessTable g' (vertices g')) \\<and>\n                                   separated g' (fst ` P)}\n 3. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {sum snd P |P.\n                        P \\<subseteq> set\n (ExcessTable g' (vertices g')) \\<and>\n                        separated g' (fst ` P)}", "apply (simp add: sep_ne)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> {sum snd P |P.\n                       P \\<subseteq> set (ExcessTable g (vertices g)) \\<and>\n                       separated g (fst ` P)}\n                      \\<subseteq> {sum snd P |P.\n                                   P \\<subseteq> set\n            (ExcessTable g' (vertices g')) \\<and>\n                                   separated g' (fst ` P)}\n 2. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {sum snd P |P.\n                        P \\<subseteq> set\n (ExcessTable g' (vertices g')) \\<and>\n                        separated g' (fst ` P)}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {sum snd P |P.\n                        P \\<subseteq> set\n (ExcessTable g' (vertices g')) \\<and>\n                        separated g' (fst ` P)}\n 2. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> {sum snd P |P.\n                       P \\<subseteq> set (ExcessTable g (vertices g)) \\<and>\n                       separated g (fst ` P)}\n                      \\<subseteq> {sum snd P |P.\n                                   P \\<subseteq> set\n            (ExcessTable g' (vertices g')) \\<and>\n                                   separated g' (fst ` P)}", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; Invariants.inv g';\n     set (ExcessTable g (vertices g))\n     \\<subseteq> set (ExcessTable g' (vertices g'))\\<rbrakk>\n    \\<Longrightarrow> {sum snd P |P.\n                       P \\<subseteq> set (ExcessTable g (vertices g)) \\<and>\n                       separated g (fst ` P)}\n                      \\<subseteq> {sum snd P |P.\n                                   P \\<subseteq> set\n            (ExcessTable g' (vertices g')) \\<and>\n                                   separated g' (fst ` P)}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            sum snd P = sum snd Pa \\<and>\n                            Pa \\<subseteq> set\n      (ExcessTable g' (vertices g')) \\<and>\n                            separated g' (fst ` Pa)", "apply(rule_tac x=P in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P)\\<rbrakk>\n       \\<Longrightarrow> sum snd P = sum snd P \\<and>\n                         P \\<subseteq> set\n  (ExcessTable g' (vertices g')) \\<and>\n                         separated g' (fst ` P)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P)\\<rbrakk>\n       \\<Longrightarrow> separated g' (fst ` P)", "apply(subgoal_tac \"fst ` P \\<subseteq> \\<V> g'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P); fst ` P \\<subseteq> \\<V> g'\\<rbrakk>\n       \\<Longrightarrow> separated g' (fst ` P)\n 2. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P)\\<rbrakk>\n       \\<Longrightarrow> fst ` P \\<subseteq> \\<V> g'", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P)\\<rbrakk>\n       \\<Longrightarrow> fst ` P \\<subseteq> \\<V> g'\n 2. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P); fst ` P \\<subseteq> \\<V> g'\\<rbrakk>\n       \\<Longrightarrow> separated g' (fst ` P)", "apply (blast dest: ExcessTab_vertex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P); fst ` P \\<subseteq> \\<V> g'\\<rbrakk>\n       \\<Longrightarrow> separated g' (fst ` P)", "apply(subgoal_tac \"fst ` P \\<subseteq> \\<V> g\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P); fst ` P \\<subseteq> \\<V> g';\n        fst ` P \\<subseteq> \\<V> g\\<rbrakk>\n       \\<Longrightarrow> separated g' (fst ` P)\n 2. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P); fst ` P \\<subseteq> \\<V> g'\\<rbrakk>\n       \\<Longrightarrow> fst ` P \\<subseteq> \\<V> g", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P); fst ` P \\<subseteq> \\<V> g'\\<rbrakk>\n       \\<Longrightarrow> fst ` P \\<subseteq> \\<V> g\n 2. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P); fst ` P \\<subseteq> \\<V> g';\n        fst ` P \\<subseteq> \\<V> g\\<rbrakk>\n       \\<Longrightarrow> separated g' (fst ` P)", "apply (blast dest: ExcessTab_vertex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        separated g (fst ` P); fst ` P \\<subseteq> \\<V> g';\n        fst ` P \\<subseteq> \\<V> g\\<rbrakk>\n       \\<Longrightarrow> separated g' (fst ` P)", "apply(simp add:sep_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; Invariants.inv g';\n        set (ExcessTable g (vertices g))\n        \\<subseteq> set (ExcessTable g' (vertices g'));\n        P \\<subseteq> set (ExcessTable g (vertices g));\n        \\<forall>u\\<in>P.\n           \\<forall>v\\<in>P.\n              fst u \\<noteq> fst v \\<longrightarrow>\n              \\<not> close g (fst u) (fst v);\n        fst ` P \\<subseteq> \\<V> g'; fst ` P \\<subseteq> \\<V> g\\<rbrakk>\n       \\<Longrightarrow> \\<forall>u\\<in>P.\n                            \\<forall>v\\<in>P.\n                               fst u \\<noteq> fst v \\<longrightarrow>\n                               \\<not> close g' (fst u) (fst v)", "apply (blast intro:close_antimono ExcessTab_final ExcessTab_vertex)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* close -> in neibhood ?? *)"], ["", "lemma next_plane0_incr_squander_lb:\n \"\\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); inv g \\<rbrakk> \\<Longrightarrow>\n  squanderLowerBound g \\<le> squanderLowerBound g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g\\<rbrakk>\n    \\<Longrightarrow> squanderLowerBound g \\<le> squanderLowerBound g'", "apply(simp add:squanderLowerBound_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g\\<rbrakk>\n    \\<Longrightarrow> faceSquanderLowerBound g + ExcessNotAt g None\n                      \\<le> faceSquanderLowerBound g' + ExcessNotAt g' None", "apply(frule (1) next_plane0_incr_ExcessNotAt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; ExcessNotAt g None \\<le> ExcessNotAt g' None\\<rbrakk>\n    \\<Longrightarrow> faceSquanderLowerBound g + ExcessNotAt g None\n                      \\<le> faceSquanderLowerBound g' + ExcessNotAt g' None", "apply(clarsimp simp add:next_plane0_def split:if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>Invariants.inv g;\n        ExcessNotAt g None \\<le> ExcessNotAt g' None; \\<not> final g;\n        x \\<in> set (nonFinals g); xa \\<in> \\<V> x;\n        g' \\<in> set (generatePolygon xb xa x g); 3 \\<le> xb;\n        xb < 4 + p\\<rbrakk>\n       \\<Longrightarrow> faceSquanderLowerBound g + ExcessNotAt g None\n                         \\<le> faceSquanderLowerBound g' +\n                               ExcessNotAt g' None", "apply(drule (4) genPoly_incr_facesquander_lb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>Invariants.inv g;\n        ExcessNotAt g None \\<le> ExcessNotAt g' None; \\<not> final g;\n        x \\<in> set (nonFinals g); xa \\<in> \\<V> x; 3 \\<le> xb; xb < 4 + p;\n        faceSquanderLowerBound g + \\<d> xb\n        \\<le> faceSquanderLowerBound g'\\<rbrakk>\n       \\<Longrightarrow> faceSquanderLowerBound g + ExcessNotAt g None\n                         \\<le> faceSquanderLowerBound g' +\n                               ExcessNotAt g' None", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_notame:\n \"\\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); inv g; notame7 g\\<rbrakk>\n  \\<Longrightarrow> notame7 g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; notame7 g\\<rbrakk>\n    \\<Longrightarrow> notame7 g'", "apply(simp add:notame_def notame7_def tame11b_def is_tame13a_def tame10ub_def del:disj_not1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g;\n     \\<not> countVertices g \\<le> 15 \\<or>\n     (\\<exists>v\\<in>\\<V> g.\n         \\<not> degree g v \\<le> (if except g v = 0 then 7 else 6)) \\<or>\n     \\<not> squanderLowerBound g < squanderTarget\\<rbrakk>\n    \\<Longrightarrow> \\<not> countVertices g' \\<le> 15 \\<or>\n                      (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply(frule inv_mgp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g;\n     \\<not> countVertices g \\<le> 15 \\<or>\n     (\\<exists>v\\<in>\\<V> g.\n         \\<not> degree g v \\<le> (if except g v = 0 then 7 else 6)) \\<or>\n     \\<not> squanderLowerBound g < squanderTarget;\n     minGraphProps g\\<rbrakk>\n    \\<Longrightarrow> \\<not> countVertices g' \\<le> 15 \\<or>\n                      (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply(frule (1) next_plane0_vertices_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g;\n     \\<not> countVertices g \\<le> 15 \\<or>\n     (\\<exists>v\\<in>\\<V> g.\n         \\<not> degree g v \\<le> (if except g v = 0 then 7 else 6)) \\<or>\n     \\<not> squanderLowerBound g < squanderTarget;\n     minGraphProps g; \\<V> g \\<subseteq> \\<V> g'\\<rbrakk>\n    \\<Longrightarrow> \\<not> countVertices g' \\<le> 15 \\<or>\n                      (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n     \\<not> countVertices g \\<le> 15\\<rbrakk>\n    \\<Longrightarrow> \\<not> countVertices g' \\<le> 15 \\<or>\n                      (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget\n 2. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n     (\\<exists>v\\<in>\\<V> g.\n         \\<not> degree g v \\<le> (if except g v = 0 then 7 else 6)) \\<or>\n     \\<not> squanderLowerBound g < squanderTarget\\<rbrakk>\n    \\<Longrightarrow> \\<not> countVertices g' \\<le> 15 \\<or>\n                      (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply(simp add:vertices_graph)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n     (\\<exists>v\\<in>\\<V> g.\n         \\<not> degree g v \\<le> (if except g v = 0 then 7 else 6)) \\<or>\n     \\<not> squanderLowerBound g < squanderTarget\\<rbrakk>\n    \\<Longrightarrow> \\<not> countVertices g' \\<le> 15 \\<or>\n                      (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply(rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n     (\\<exists>v\\<in>\\<V> g.\n         \\<not> degree g v \\<le> (if except g v = 0 then 7 else 6)) \\<or>\n     \\<not> squanderLowerBound g < squanderTarget\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n     \\<exists>v\\<in>\\<V> g.\n        \\<not> degree g v \\<le> (if except g v = 0 then 7 else 6)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget\n 2. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n     \\<not> squanderLowerBound g < squanderTarget\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n        v \\<in> \\<V> g;\n        \\<not> degree g v \\<le> (if except g v = 0 then 7 else 6);\n        \\<not> (\\<exists>v\\<in>\\<V> g'.\n                   (except g' v = 0 \\<longrightarrow>\n                    \\<not> degree g' v \\<le> 7) \\<and>\n                   (0 < except g' v \\<longrightarrow>\n                    \\<not> degree g' v \\<le> 6));\n        squanderLowerBound g' < squanderTarget\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n     \\<not> squanderLowerBound g < squanderTarget\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply(frule (2) next_plane0_incr_degree)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n        v \\<in> \\<V> g;\n        \\<not> degree g v \\<le> (if except g v = 0 then 7 else 6);\n        \\<not> (\\<exists>v\\<in>\\<V> g'.\n                   (except g' v = 0 \\<longrightarrow>\n                    \\<not> degree g' v \\<le> 7) \\<and>\n                   (0 < except g' v \\<longrightarrow>\n                    \\<not> degree g' v \\<le> 6));\n        squanderLowerBound g' < squanderTarget;\n        degree g v \\<le> degree g' v\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n     \\<not> squanderLowerBound g < squanderTarget\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply(frule (2) next_plane0_incr_except)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n        v \\<in> \\<V> g;\n        \\<not> degree g v \\<le> (if except g v = 0 then 7 else 6);\n        \\<not> (\\<exists>v\\<in>\\<V> g'.\n                   (except g' v = 0 \\<longrightarrow>\n                    \\<not> degree g' v \\<le> 7) \\<and>\n                   (0 < except g' v \\<longrightarrow>\n                    \\<not> degree g' v \\<le> 6));\n        squanderLowerBound g' < squanderTarget;\n        degree g v \\<le> degree g' v; except g v \\<le> except g' v\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n     \\<not> squanderLowerBound g < squanderTarget\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply (force split:if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n     \\<not> squanderLowerBound g < squanderTarget\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply(frule (1) next_plane0_incr_squander_lb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     Invariants.inv g; minGraphProps g; \\<V> g \\<subseteq> \\<V> g';\n     \\<not> squanderLowerBound g < squanderTarget;\n     squanderLowerBound g \\<le> squanderLowerBound g'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>v\\<in>\\<V> g'.\n                          (except g' v = 0 \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 7) \\<and>\n                          (0 < except g' v \\<longrightarrow>\n                           \\<not> degree g' v \\<le> 6)) \\<or>\n                      \\<not> squanderLowerBound g' < squanderTarget", "apply(arith)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_inv_notame:\n \"invariant(\\<lambda>g. inv g \\<and> notame7 g) next_plane\\<^bsub>p\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (\\<lambda>g. Invariants.inv g \\<and> notame7 g)\n     next_plane\\<^bsub>p\\<^esub>", "apply(simp add:invariant_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g g'.\n       g' \\<in> set (next_plane\\<^bsub>p\\<^esub> g) \\<longrightarrow>\n       Invariants.inv g \\<and> notame7 g \\<longrightarrow>\n       Invariants.inv g' \\<and> notame7 g'", "apply(blast intro: inv_notame mgp_next_plane0_if_next_plane[OF inv_mgp]\n       invariantE[OF inv_inv_next_plane])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma untame_notame:\n \"untame (\\<lambda>g. inv g \\<and> notame7 g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. untame (\\<lambda>g. Invariants.inv g \\<and> notame7 g)", "proof(clarsimp simp add: notame_def notame7_def untame_def tame11b_def is_tame13a_def tame10ub_def\n                         linorder_not_le linorder_not_less)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>final g; Invariants.inv g;\n        15 < countVertices g \\<or>\n        (\\<exists>v\\<in>\\<V> g.\n            (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n            (0 < except g v \\<longrightarrow> 6 < degree g v)) \\<or>\n        squanderTarget \\<le> squanderLowerBound g;\n        tame g\\<rbrakk>\n       \\<Longrightarrow> False", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>final g; Invariants.inv g;\n        15 < countVertices g \\<or>\n        (\\<exists>v\\<in>\\<V> g.\n            (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n            (0 < except g v \\<longrightarrow> 6 < degree g v)) \\<or>\n        squanderTarget \\<le> squanderLowerBound g;\n        tame g\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"final g\" \"inv g\" \"tame g\"\n    and cases: \"15 < countVertices g \\<or>\n                (\\<exists>v\\<in>\\<V> g. (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n                            (0 < except g v \\<longrightarrow> 6 < degree g v))\n                \\<or> squanderTarget \\<le> squanderLowerBound g\"\n                (is \"?A \\<or> ?B \\<or> ?C\" is \"_ \\<or> (\\<exists>v\\<in>\\<V> g. ?B' v) \\<or> _\")"], ["proof (state)\nthis:\n  final g\n  Invariants.inv g\n  tame g\n  15 < countVertices g \\<or>\n  (\\<exists>v\\<in>\\<V> g.\n      (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n      (0 < except g v \\<longrightarrow> 6 < degree g v)) \\<or>\n  squanderTarget \\<le> squanderLowerBound g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>final g; Invariants.inv g;\n        15 < countVertices g \\<or>\n        (\\<exists>v\\<in>\\<V> g.\n            (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n            (0 < except g v \\<longrightarrow> 6 < degree g v)) \\<or>\n        squanderTarget \\<le> squanderLowerBound g;\n        tame g\\<rbrakk>\n       \\<Longrightarrow> False", "from cases"], ["proof (chain)\npicking this:\n  15 < countVertices g \\<or>\n  (\\<exists>v\\<in>\\<V> g.\n      (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n      (0 < except g v \\<longrightarrow> 6 < degree g v)) \\<or>\n  squanderTarget \\<le> squanderLowerBound g", "show False"], ["proof (prove)\nusing this:\n  15 < countVertices g \\<or>\n  (\\<exists>v\\<in>\\<V> g.\n      (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n      (0 < except g v \\<longrightarrow> 6 < degree g v)) \\<or>\n  squanderTarget \\<le> squanderLowerBound g\n\ngoal (1 subgoal):\n 1. False", "proof(elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. 15 < countVertices g \\<Longrightarrow> False\n 2. \\<exists>v\\<in>\\<V> g.\n       (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n       (0 < except g v \\<longrightarrow> 6 < degree g v) \\<Longrightarrow>\n    False\n 3. squanderTarget \\<le> squanderLowerBound g \\<Longrightarrow> False", "assume ?B"], ["proof (state)\nthis:\n  \\<exists>v\\<in>\\<V> g.\n     (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n     (0 < except g v \\<longrightarrow> 6 < degree g v)\n\ngoal (3 subgoals):\n 1. 15 < countVertices g \\<Longrightarrow> False\n 2. \\<exists>v\\<in>\\<V> g.\n       (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n       (0 < except g v \\<longrightarrow> 6 < degree g v) \\<Longrightarrow>\n    False\n 3. squanderTarget \\<le> squanderLowerBound g \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>\\<V> g.\n     (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n     (0 < except g v \\<longrightarrow> 6 < degree g v)", "obtain v where v: \"v \\<in>\\<V> g\" \"?B' v\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>\\<V> g.\n     (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n     (0 < except g v \\<longrightarrow> 6 < degree g v)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> \\<V> g;\n         (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n         (0 < except g v \\<longrightarrow> 6 < degree g v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> \\<V> g\n  (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n  (0 < except g v \\<longrightarrow> 6 < degree g v)\n\ngoal (3 subgoals):\n 1. 15 < countVertices g \\<Longrightarrow> False\n 2. \\<exists>v\\<in>\\<V> g.\n       (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n       (0 < except g v \\<longrightarrow> 6 < degree g v) \\<Longrightarrow>\n    False\n 3. squanderTarget \\<le> squanderLowerBound g \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"except g v = 0\""], ["proof (state)\nthis:\n  except g v = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  except g v = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>tame g\\<close> v"], ["proof (prove)\nusing this:\n  except g v = 0\n  tame g\n  v \\<in> \\<V> g\n  (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n  (0 < except g v \\<longrightarrow> 6 < degree g v)\n\ngoal (1 subgoal):\n 1. False", "by(auto simp: tame_def tame11b_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. except g v \\<noteq> 0 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. except g v \\<noteq> 0 \\<Longrightarrow> False", "assume \"except g v \\<noteq> 0\""], ["proof (state)\nthis:\n  except g v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. except g v \\<noteq> 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  except g v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>tame g\\<close> v"], ["proof (prove)\nusing this:\n  except g v \\<noteq> 0\n  tame g\n  v \\<in> \\<V> g\n  (except g v = 0 \\<longrightarrow> 7 < degree g v) \\<and>\n  (0 < except g v \\<longrightarrow> 6 < degree g v)\n\ngoal (1 subgoal):\n 1. False", "by(auto simp: except_def filter_empty_conv tame_def tame11b_def\n          minGraphProps_facesAt_eq[OF inv_mgp[OF \\<open>inv g\\<close>]] split:if_split_asm)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. 15 < countVertices g \\<Longrightarrow> False\n 2. squanderTarget \\<le> squanderLowerBound g \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 15 < countVertices g \\<Longrightarrow> False\n 2. squanderTarget \\<le> squanderLowerBound g \\<Longrightarrow> False", "assume ?A"], ["proof (state)\nthis:\n  15 < countVertices g\n\ngoal (2 subgoals):\n 1. 15 < countVertices g \\<Longrightarrow> False\n 2. squanderTarget \\<le> squanderLowerBound g \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  15 < countVertices g\n\ngoal (1 subgoal):\n 1. False", "using \\<open>tame g\\<close>"], ["proof (prove)\nusing this:\n  15 < countVertices g\n  tame g\n\ngoal (1 subgoal):\n 1. False", "by(simp add:tame_def tame10_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. squanderTarget \\<le> squanderLowerBound g \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. squanderTarget \\<le> squanderLowerBound g \\<Longrightarrow> False", "assume ?C"], ["proof (state)\nthis:\n  squanderTarget \\<le> squanderLowerBound g\n\ngoal (1 subgoal):\n 1. squanderTarget \\<le> squanderLowerBound g \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  squanderTarget \\<le> squanderLowerBound g\n\ngoal (1 subgoal):\n 1. False", "using total_weight_lowerbound[OF \\<open>inv g\\<close> \\<open>final g\\<close> \\<open>tame g\\<close>]\n      \\<open>tame g\\<close>"], ["proof (prove)\nusing this:\n  squanderTarget \\<le> squanderLowerBound g\n  \\<lbrakk>admissible ?w g; ListSum (faces g) ?w < squanderTarget\\<rbrakk>\n  \\<Longrightarrow> squanderLowerBound g \\<le> ListSum (faces g) ?w\n  tame g\n\ngoal (1 subgoal):\n 1. False", "by(force simp add:tame_def tame13a_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polysizes_tame:\n \"\\<lbrakk> g' \\<in> set (generatePolygon n v f g); inv g; f \\<in> set(nonFinals g);\n   v \\<in> \\<V> f; 3 \\<le> n; n < 4+p; n \\<notin> set(polysizes p g) \\<rbrakk>\n \\<Longrightarrow> notame7 g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (generatePolygon n v f g); Invariants.inv g;\n     f \\<in> set (nonFinals g); v \\<in> \\<V> f; 3 \\<le> n; n < 4 + p;\n     n \\<notin> set (polysizes p g)\\<rbrakk>\n    \\<Longrightarrow> notame7 g'", "apply(frule (4) in_next_plane0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (generatePolygon n v f g); Invariants.inv g;\n     f \\<in> set (nonFinals g); v \\<in> \\<V> f; 3 \\<le> n; n < 4 + p;\n     n \\<notin> set (polysizes p g);\n     g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g)\\<rbrakk>\n    \\<Longrightarrow> notame7 g'", "apply(frule (4) genPoly_incr_facesquander_lb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (generatePolygon n v f g); Invariants.inv g;\n     f \\<in> set (nonFinals g); v \\<in> \\<V> f; 3 \\<le> n; n < 4 + p;\n     n \\<notin> set (polysizes p g);\n     g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     faceSquanderLowerBound g + \\<d> n\n     \\<le> faceSquanderLowerBound g'\\<rbrakk>\n    \\<Longrightarrow> notame7 g'", "apply(frule (1) next_plane0_incr_ExcessNotAt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (generatePolygon n v f g); Invariants.inv g;\n     f \\<in> set (nonFinals g); v \\<in> \\<V> f; 3 \\<le> n; n < 4 + p;\n     n \\<notin> set (polysizes p g);\n     g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n     faceSquanderLowerBound g + \\<d> n \\<le> faceSquanderLowerBound g';\n     ExcessNotAt g None \\<le> ExcessNotAt g' None\\<rbrakk>\n    \\<Longrightarrow> notame7 g'", "apply(simp add: notame_def notame7_def is_tame13a_def faceSquanderLowerBound_def\n           polysizes_def squanderLowerBound_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma genPolyTame_notame:\n \"\\<lbrakk> g' \\<in> set (generatePolygon n v f g); g' \\<notin> set (generatePolygonTame n v f g);\n    inv g; 3 \\<le> n \\<rbrakk>\n  \\<Longrightarrow> notame7 g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g' \\<in> set (generatePolygon n v f g);\n     g' \\<notin> set (generatePolygonTame n v f g); Invariants.inv g;\n     3 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> notame7 g'", "by(fastforce simp:generatePolygon_def generatePolygonTame_def enum_enumerator\n                 notame_def notame7_def)"], ["", "declare upt_Suc[simp del]"], ["", "(* FIXME global? *)"], ["", "lemma excess_notame:\n \"\\<lbrakk> inv g; g' \\<in> set (next_plane\\<^bsub>p\\<^esub> g); g' \\<notin> set (next_tame0 p g) \\<rbrakk>\n       \\<Longrightarrow> notame7 g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; g' \\<in> set (next_plane\\<^bsub>p\\<^esub> g);\n     g' \\<notin> set (next_tame0\\<^bsub>p\\<^esub> g)\\<rbrakk>\n    \\<Longrightarrow> notame7 g'", "apply(frule (1) mgp_next_plane0_if_next_plane[OF inv_mgp])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; g' \\<in> set (next_plane\\<^bsub>p\\<^esub> g);\n     g' \\<notin> set (next_tame0\\<^bsub>p\\<^esub> g);\n     g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g)\\<rbrakk>\n    \\<Longrightarrow> notame7 g'", "apply(auto simp add:next_tame0_def next_plane_def split:if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon x\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> x; x < 4 + p\\<rbrakk>\n       \\<Longrightarrow> notame7 g'", "apply(rename_tac n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p\\<rbrakk>\n       \\<Longrightarrow> notame7 g'", "apply(case_tac \"n \\<in> set(polysizes p g)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<in> set (polysizes p g)\\<rbrakk>\n       \\<Longrightarrow> notame7 g'\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g)\\<rbrakk>\n       \\<Longrightarrow> notame7 g'", "apply(drule bspec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<in> set (polysizes p g)\\<rbrakk>\n       \\<Longrightarrow> ?x20 n \\<in> set (polysizes p g)\n 2. \\<And>n.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<in> set (polysizes p g);\n        g' \\<notin> set (generatePolygonTame (?x20 n)\n                          (minimalVertex g (minimalFace (nonFinals g)))\n                          (minimalFace (nonFinals g)) g)\\<rbrakk>\n       \\<Longrightarrow> notame7 g'\n 3. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g)\\<rbrakk>\n       \\<Longrightarrow> notame7 g'", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        Invariants.inv g; nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<in> set (polysizes p g);\n        g' \\<notin> set (generatePolygonTame n\n                          (minimalVertex g (minimalFace (nonFinals g)))\n                          (minimalFace (nonFinals g)) g)\\<rbrakk>\n       \\<Longrightarrow> notame7 g'\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g)\\<rbrakk>\n       \\<Longrightarrow> notame7 g'", "apply(simp add:genPolyTame_notame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g)\\<rbrakk>\n       \\<Longrightarrow> notame7 g'", "apply(subgoal_tac \"minimalFace (nonFinals g) \\<in> set(nonFinals g)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g);\n        minimalFace (nonFinals g) \\<in> set (nonFinals g)\\<rbrakk>\n       \\<Longrightarrow> notame7 g'\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g)\\<rbrakk>\n       \\<Longrightarrow> minimalFace (nonFinals g) \\<in> set (nonFinals g)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g)\\<rbrakk>\n       \\<Longrightarrow> minimalFace (nonFinals g) \\<in> set (nonFinals g)\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g);\n        minimalFace (nonFinals g) \\<in> set (nonFinals g)\\<rbrakk>\n       \\<Longrightarrow> notame7 g'", "apply(simp add:minimalFace_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g);\n        minimalFace (nonFinals g) \\<in> set (nonFinals g)\\<rbrakk>\n       \\<Longrightarrow> notame7 g'", "apply(subgoal_tac \"minimalVertex g (minimalFace (nonFinals g)) \\<in> \\<V>(minimalFace (nonFinals g))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g);\n        minimalFace (nonFinals g) \\<in> set (nonFinals g);\n        minimalVertex g (minimalFace (nonFinals g))\n        \\<in> \\<V> (minimalFace (nonFinals g))\\<rbrakk>\n       \\<Longrightarrow> notame7 g'\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g);\n        minimalFace (nonFinals g) \\<in> set (nonFinals g)\\<rbrakk>\n       \\<Longrightarrow> minimalVertex g (minimalFace (nonFinals g))\n                         \\<in> \\<V> (minimalFace (nonFinals g))", "apply(blast intro:polysizes_tame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimalVertex g\n (minimalFace (nonFinals g)))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimalVertex g (minimalFace (nonFinals g)))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g);\n        minimalFace (nonFinals g) \\<in> set (nonFinals g)\\<rbrakk>\n       \\<Longrightarrow> minimalVertex g (minimalFace (nonFinals g))\n                         \\<in> \\<V> (minimalFace (nonFinals g))", "apply(simp add:minimalVertex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimal (height g)\n (vertices (minimalFace (nonFinals g))))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimal (height g)\n                         (vertices (minimalFace (nonFinals g))))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g);\n        minimalFace (nonFinals g) \\<in> set (nonFinals g)\\<rbrakk>\n       \\<Longrightarrow> minimal (height g)\n                          (vertices (minimalFace (nonFinals g)))\n                         \\<in> \\<V> (minimalFace (nonFinals g))", "apply(rule minimal_in_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimal (height g)\n (vertices (minimalFace (nonFinals g))))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g); Invariants.inv g;\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimal (height g)\n                         (vertices (minimalFace (nonFinals g))))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g);\n        minimalFace (nonFinals g) \\<in> set (nonFinals g)\\<rbrakk>\n       \\<Longrightarrow> vertices (minimalFace (nonFinals g)) \\<noteq> []", "apply(erule mgp_vertices_nonempty[OF inv_mgp])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set (polysizes p g).\n                   g' \\<notin> set (generatePolygonTame x\n                                     (minimal (height g)\n (vertices (minimalFace (nonFinals g))))\n                                     (minimalFace (nonFinals g)) g);\n        g' \\<in> set (next_plane0\\<^bsub>p\\<^esub> g);\n        nonFinals g \\<noteq> [];\n        g' \\<in> set (generatePolygon n\n                       (minimal (height g)\n                         (vertices (minimalFace (nonFinals g))))\n                       (minimalFace (nonFinals g)) g);\n        3 \\<le> n; n < 4 + p; n \\<notin> set (polysizes p g);\n        minimalFace (nonFinals g) \\<in> set (nonFinals g)\\<rbrakk>\n       \\<Longrightarrow> minimalFace (nonFinals g) \\<in> \\<F> g", "apply(simp add:nonFinals_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare upt_Suc[simp]"], ["", "lemma next_tame0_comp: \"\\<lbrakk> Seed\\<^bsub>p\\<^esub> [next_plane p]\\<rightarrow>* g; final g; tame g \\<rbrakk>\n \\<Longrightarrow> Seed\\<^bsub>p\\<^esub> [next_tame0 p]\\<rightarrow>* g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> Seed\\<^bsub>p\\<^esub> [next_tame0\\<^bsub>p\\<^esub>]\\<rightarrow>* g", "apply(rule filterout_untame_succs[OF inv_inv_next_plane inv_inv_notame\n  untame_notame])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ga g'.\n       \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n        final g; tame g; Invariants.inv ga;\n        g' \\<in> set (next_plane\\<^bsub>?p1\\<^esub> ga);\n        g' \\<notin> set (next_tame0\\<^bsub>p\\<^esub> ga)\\<rbrakk>\n       \\<Longrightarrow> notame7 g'\n 2. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>?p1\\<^esub>]\\<rightarrow>* g\n 3. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> Invariants.inv Seed\\<^bsub>p\\<^esub>\n 4. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> final g\n 5. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> tame g", "apply(blast intro:excess_notame)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g\n 2. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> Invariants.inv Seed\\<^bsub>p\\<^esub>\n 3. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> final g\n 4. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> tame g", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> Invariants.inv Seed\\<^bsub>p\\<^esub>\n 2. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> final g\n 3. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> tame g", "apply(rule inv_Seed)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> final g\n 2. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> tame g", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Seed\\<^bsub>p\\<^esub> [next_plane\\<^bsub>p\\<^esub>]\\<rightarrow>* g;\n     final g; tame g\\<rbrakk>\n    \\<Longrightarrow> tame g", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_inv_next_tame0: \"invariant inv (next_tame0 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant Invariants.inv next_tame0\\<^bsub>p\\<^esub>", "by(rule inv_subset[OF inv_inv_next_plane next_tame0_subset_plane])"], ["", "lemma inv_inv_next_tame: \"invariant inv next_tame\\<^bsub>p\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant Invariants.inv next_tame\\<^bsub>p\\<^esub>", "apply(simp add:next_tame_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant Invariants.inv\n     (filter (\\<lambda>g. final g \\<longrightarrow> is_tame g) \\<circ>\n      next_tame0\\<^bsub>p\\<^esub>)", "apply(rule inv_subset[OF inv_inv_next_tame0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       Invariants.inv g \\<Longrightarrow>\n       set ((filter\n              (\\<lambda>g. final g \\<longrightarrow> is_tame g) \\<circ>\n             next_tame0\\<^bsub>p\\<^esub>)\n             g)\n       \\<subseteq> set (next_tame0\\<^bsub>?p1\\<^esub> g)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mgp_TameEnum: \"g \\<in> TameEnum\\<^bsub>p\\<^esub> \\<Longrightarrow> minGraphProps g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> TameEnum\\<^bsub>p\\<^esub> \\<Longrightarrow> minGraphProps g", "by (unfold TameEnumP_def)\n   (blast intro: RTranCl_inv[OF inv_inv_next_tame] inv_Seed inv_mgp)"], ["", "end"]]}