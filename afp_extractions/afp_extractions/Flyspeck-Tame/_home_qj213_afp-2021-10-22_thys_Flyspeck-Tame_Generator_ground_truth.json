{"file_name": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame/Generator.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame", "problem_names": ["lemma [code]:\n  \"ExcessTable g =\n   List.map_filter (\\<lambda>v. let e = ExcessAt g v in if 0 < e then Some (v, e) else None)\"", "lemma [code]: \"deleteAround g v ps =\n      (let vs = (\\<lambda>f. let n = f\\<bullet>v\n                     in if |vertices f| = 4 then [n, f\\<bullet>n] else [n])\n       in removeKeyList (concat(map vs (facesAt g v))) ps)\"", "lemma length_deleteAround: \"length (deleteAround g v ps) \\<le> length ps\""], "translations": [["", "lemma [code]:\n  \"ExcessTable g =\n   List.map_filter (\\<lambda>v. let e = ExcessAt g v in if 0 < e then Some (v, e) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ExcessTable g =\n    List.map_filter\n     (\\<lambda>v.\n         let e = ExcessAt g v in if 0 < e then Some (v, e) else None)", "by (rule ext) (simp add: ExcessTable_def map_filter_def)"], ["", "(* FIXME delete stupid removeKeyList *)"], ["", "definition deleteAround :: \"graph \\<Rightarrow> vertex \\<Rightarrow> (vertex \\<times> nat) list \\<Rightarrow> (vertex \\<times> nat) list\" where\n \"deleteAround g v ps \\<equiv>\n      let fs = facesAt g v;\n      ws = \\<Squnion>\\<^bsub>f\\<in>fs\\<^esub> if |vertices f| = 4 then [f\\<bullet>v, f\\<^bsup>2\\<^esup>\\<bullet>v] else [f\\<bullet>v] in\n      removeKeyList ws ps\""], ["", "text\\<open>Implementation:\\<close>"], ["", "lemma [code]: \"deleteAround g v ps =\n      (let vs = (\\<lambda>f. let n = f\\<bullet>v\n                     in if |vertices f| = 4 then [n, f\\<bullet>n] else [n])\n       in removeKeyList (concat(map vs (facesAt g v))) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deleteAround g v ps =\n    (let vs = \\<lambda>f.\n                 let n = f \\<bullet> v\n                 in if |vertices f| = 4 then [n, f \\<bullet> n] else [n]\n     in removeKeyList (concat (map vs (facesAt g v))) ps)", "by (simp only: concat_map_singleton Let_def deleteAround_def nextV2)"], ["", "lemma length_deleteAround: \"length (deleteAround g v ps) \\<le> length ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |deleteAround g v ps| \\<le> |ps|", "by (auto simp only: deleteAround_def length_removeKeyList Let_def)"], ["", "function ExcessNotAtRec :: \"(nat, nat) table \\<Rightarrow> graph \\<Rightarrow> nat\" where\n \"ExcessNotAtRec [] = (\\<lambda>g. 0)\"\n | \"ExcessNotAtRec ((x, y)#ps) = (\\<lambda>g.  max (ExcessNotAtRec ps g)\n         (y + ExcessNotAtRec (deleteAround g x ps) g))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>xa y ps. x = (xa, y) # ps \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. [] = [] \\<Longrightarrow> (\\<lambda>g. 0) = (\\<lambda>g. 0)\n 3. \\<And>x y ps.\n       [] = (x, y) # ps \\<Longrightarrow>\n       (\\<lambda>g. 0) =\n       (\\<lambda>g.\n           max (ExcessNotAtRec_sumC ps g)\n            (y + ExcessNotAtRec_sumC (deleteAround g x ps) g))\n 4. \\<And>x y ps xa ya psa.\n       (x, y) # ps = (xa, ya) # psa \\<Longrightarrow>\n       (\\<lambda>g.\n           max (ExcessNotAtRec_sumC ps g)\n            (y + ExcessNotAtRec_sumC (deleteAround g x ps) g)) =\n       (\\<lambda>g.\n           max (ExcessNotAtRec_sumC psa g)\n            (ya + ExcessNotAtRec_sumC (deleteAround g xa psa) g))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All ExcessNotAtRec_dom", "by (relation \"measure size\") \n  (auto simp add: length_deleteAround less_Suc_eq_le)"], ["", "definition ExcessNotAt :: \"graph \\<Rightarrow> vertex option \\<Rightarrow> nat\" where\n \"ExcessNotAt g v_opt \\<equiv>\n     let ps = ExcessTable g (vertices g) in\n     case v_opt of None \\<Rightarrow>  ExcessNotAtRec ps g\n      | Some v \\<Rightarrow> ExcessNotAtRec (deleteAround g v ps) g\""], ["", "definition squanderLowerBound :: \"graph \\<Rightarrow> nat\" where\n \"squanderLowerBound g \\<equiv>  faceSquanderLowerBound g + ExcessNotAt g None\""], ["", "text\\<open>\\paragraph{Tame graph enumeration}\\<close>"], ["", "definition is_tame13a :: \"graph \\<Rightarrow> bool\" where\n\"is_tame13a g \\<equiv> squanderLowerBound g < squanderTarget\""], ["", "definition notame :: \"graph \\<Rightarrow> bool\" where\n\"notame g \\<equiv> \\<not> (tame10ub g \\<and> tame11b g)\""], ["", "definition notame7 :: \"graph \\<Rightarrow> bool\" where\n\"notame7 g \\<equiv> \\<not> (tame10ub g \\<and> tame11b g \\<and> is_tame13a g)\""], ["", "definition generatePolygonTame :: \"nat \\<Rightarrow> vertex \\<Rightarrow> face \\<Rightarrow> graph \\<Rightarrow> graph list\" where\n\"generatePolygonTame n v f g \\<equiv>\n     let\n     enumeration = enum n |vertices f|;\n     enumeration = [is \\<leftarrow> enumeration. \\<not> containsDuplicateEdge g f v is];\n     vertexLists = [indexToVertexList f v is. is \\<leftarrow> enumeration]\n     in\n     [g' \\<leftarrow> [subdivFace g f vs. vs \\<leftarrow> vertexLists] . \\<not> notame g']\""], ["", "definition polysizes :: \"nat \\<Rightarrow> graph \\<Rightarrow> nat list\" where\n\"polysizes p g \\<equiv>\n    let lb = squanderLowerBound g in\n    [n \\<leftarrow> [3 ..< Suc(maxGon p)]. lb + \\<d> n < squanderTarget]\""], ["", "definition next_tame0 :: \"nat \\<Rightarrow> graph \\<Rightarrow> graph list\" (\"next'_tame0\\<^bsub>_\\<^esub>\") where\n\"next_tame0\\<^bsub>p\\<^esub> g \\<equiv>\n     let fs = nonFinals g in\n     if fs = [] then []\n     else let f = minimalFace fs; v = minimalVertex g f\n          in \\<Squnion>\\<^bsub>i \\<in> polysizes p g\\<^esub> generatePolygonTame i v f g\""], ["", "text\\<open>\\noindent Extensionally, @{const next_tame0} is just\n@{term\"filter P \\<circ> next_plane p\"} for some suitable \\<open>P\\<close>. But\nefficiency suffers considerably if we first create many graphs and\nthen filter out the ones not in @{const polysizes}.\\<close>"], ["", "end"]]}