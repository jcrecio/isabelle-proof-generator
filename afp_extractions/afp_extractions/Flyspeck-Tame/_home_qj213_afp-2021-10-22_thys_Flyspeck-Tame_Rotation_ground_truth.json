{"file_name": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame/Rotation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame", "problem_names": ["lemma cong_rotate_to:\n \"x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x\"", "lemma face_cong_if_norm_eq:\n \"\\<lbrakk> rotate_min xs = rotate_min ys; xs \\<noteq> []; ys \\<noteq> [] \\<rbrakk> \\<Longrightarrow> xs \\<cong> ys\"", "lemma norm_eq_if_face_cong:\n  \"\\<lbrakk> xs \\<cong> ys; distinct xs; xs \\<noteq> [] \\<rbrakk> \\<Longrightarrow> rotate_min xs = rotate_min ys\"", "lemma norm_eq_iff_face_cong:\n \"\\<lbrakk> distinct xs; xs \\<noteq> []; ys \\<noteq> [] \\<rbrakk> \\<Longrightarrow>\n  (rotate_min xs = rotate_min ys) = (xs \\<cong> ys)\"", "lemma inj_on_rotate_min_iff:\nassumes \"\\<forall>vs \\<in> A. distinct vs\"  \"[] \\<notin> A\"\nshows \"inj_on rotate_min A = inj_on (\\<lambda>vs. {vs}//{\\<cong>}) A\""], "translations": [["", "lemma cong_rotate_to:\n \"x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "assume x: \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "hence ls1: \"xs = fst (splitAt x xs) @ x # snd (splitAt x xs)\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. xs = fst (splitAt x xs) @ x # snd (splitAt x xs)", "by (auto dest: splitAt_ram)"], ["proof (state)\nthis:\n  xs = fst (splitAt x xs) @ x # snd (splitAt x xs)\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "define i where \"i = length(fst(splitAt x xs))\""], ["proof (state)\nthis:\n  i = |fst (splitAt x xs)|\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "hence \"i < length((fst(splitAt x xs)) @ [x] @ snd(splitAt x xs))\""], ["proof (prove)\nusing this:\n  i = |fst (splitAt x xs)|\n\ngoal (1 subgoal):\n 1. i < |fst (splitAt x xs) @ [x] @ snd (splitAt x xs)|", "by auto"], ["proof (state)\nthis:\n  i < |fst (splitAt x xs) @ [x] @ snd (splitAt x xs)|\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "with ls1"], ["proof (chain)\npicking this:\n  xs = fst (splitAt x xs) @ x # snd (splitAt x xs)\n  i < |fst (splitAt x xs) @ [x] @ snd (splitAt x xs)|", "have i_len: \"i < length xs\""], ["proof (prove)\nusing this:\n  xs = fst (splitAt x xs) @ x # snd (splitAt x xs)\n  i < |fst (splitAt x xs) @ [x] @ snd (splitAt x xs)|\n\ngoal (1 subgoal):\n 1. i < |xs|", "by auto"], ["proof (state)\nthis:\n  i < |xs|\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "hence ls2: \"xs = take i xs @ xs!i # drop (Suc i) xs\""], ["proof (prove)\nusing this:\n  i < |xs|\n\ngoal (1 subgoal):\n 1. xs = take i xs @ xs ! i # drop (Suc i) xs", "by (auto intro: id_take_nth_drop)"], ["proof (state)\nthis:\n  xs = take i xs @ xs ! i # drop (Suc i) xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "from i_len"], ["proof (chain)\npicking this:\n  i < |xs|", "have \"length (take i xs) = i\""], ["proof (prove)\nusing this:\n  i < |xs|\n\ngoal (1 subgoal):\n 1. |take i xs| = i", "by auto"], ["proof (state)\nthis:\n  |take i xs| = i\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "with i_def"], ["proof (chain)\npicking this:\n  i = |fst (splitAt x xs)|\n  |take i xs| = i", "have len_eq: \"length(take i xs) = length(fst(splitAt x xs))\""], ["proof (prove)\nusing this:\n  i = |fst (splitAt x xs)|\n  |take i xs| = i\n\ngoal (1 subgoal):\n 1. |take i xs| = |fst (splitAt x xs)|", "by auto"], ["proof (state)\nthis:\n  |take i xs| = |fst (splitAt x xs)|\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "moreover"], ["proof (state)\nthis:\n  |take i xs| = |fst (splitAt x xs)|\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "from ls1 ls2"], ["proof (chain)\npicking this:\n  xs = fst (splitAt x xs) @ x # snd (splitAt x xs)\n  xs = take i xs @ xs ! i # drop (Suc i) xs", "have eq: \"take i xs @ xs!i # drop (Suc i) xs = fst(splitAt x xs) @ x # snd(splitAt x xs)\""], ["proof (prove)\nusing this:\n  xs = fst (splitAt x xs) @ x # snd (splitAt x xs)\n  xs = take i xs @ xs ! i # drop (Suc i) xs\n\ngoal (1 subgoal):\n 1. take i xs @ xs ! i # drop (Suc i) xs =\n    fst (splitAt x xs) @ x # snd (splitAt x xs)", "by simp"], ["proof (state)\nthis:\n  take i xs @ xs ! i # drop (Suc i) xs =\n  fst (splitAt x xs) @ x # snd (splitAt x xs)\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "ultimately"], ["proof (chain)\npicking this:\n  |take i xs| = |fst (splitAt x xs)|\n  take i xs @ xs ! i # drop (Suc i) xs =\n  fst (splitAt x xs) @ x # snd (splitAt x xs)", "have\n    v_simp: \"x = xs!i\" and\n    take_i: \"fst(splitAt x xs) = take i xs\" and\n    drop_i': \"snd(splitAt x xs) = drop (Suc i) xs\""], ["proof (prove)\nusing this:\n  |take i xs| = |fst (splitAt x xs)|\n  take i xs @ xs ! i # drop (Suc i) xs =\n  fst (splitAt x xs) @ x # snd (splitAt x xs)\n\ngoal (1 subgoal):\n 1. x = xs ! i &&&\n    fst (splitAt x xs) = take i xs &&& snd (splitAt x xs) = drop (Suc i) xs", "by auto"], ["proof (state)\nthis:\n  x = xs ! i\n  fst (splitAt x xs) = take i xs\n  snd (splitAt x xs) = drop (Suc i) xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "from i_len"], ["proof (chain)\npicking this:\n  i < |xs|", "have ls3: \"xs = take i xs @ drop i xs\""], ["proof (prove)\nusing this:\n  i < |xs|\n\ngoal (1 subgoal):\n 1. xs = take i xs @ drop i xs", "by auto"], ["proof (state)\nthis:\n  xs = take i xs @ drop i xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "with take_i"], ["proof (chain)\npicking this:\n  fst (splitAt x xs) = take i xs\n  xs = take i xs @ drop i xs", "have eq: \"xs = fst(splitAt x xs) @ drop i xs\""], ["proof (prove)\nusing this:\n  fst (splitAt x xs) = take i xs\n  xs = take i xs @ drop i xs\n\ngoal (1 subgoal):\n 1. xs = fst (splitAt x xs) @ drop i xs", "by auto"], ["proof (state)\nthis:\n  xs = fst (splitAt x xs) @ drop i xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "with ls1"], ["proof (chain)\npicking this:\n  xs = fst (splitAt x xs) @ x # snd (splitAt x xs)\n  xs = fst (splitAt x xs) @ drop i xs", "have \"fst(splitAt x xs) @ drop i xs = fst(splitAt x xs) @ x # snd(splitAt x xs)\""], ["proof (prove)\nusing this:\n  xs = fst (splitAt x xs) @ x # snd (splitAt x xs)\n  xs = fst (splitAt x xs) @ drop i xs\n\ngoal (1 subgoal):\n 1. fst (splitAt x xs) @ drop i xs =\n    fst (splitAt x xs) @ x # snd (splitAt x xs)", "by auto"], ["proof (state)\nthis:\n  fst (splitAt x xs) @ drop i xs =\n  fst (splitAt x xs) @ x # snd (splitAt x xs)\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "then"], ["proof (chain)\npicking this:\n  fst (splitAt x xs) @ drop i xs =\n  fst (splitAt x xs) @ x # snd (splitAt x xs)", "have drop_i: \"drop i xs = x # snd(splitAt x xs)\""], ["proof (prove)\nusing this:\n  fst (splitAt x xs) @ drop i xs =\n  fst (splitAt x xs) @ x # snd (splitAt x xs)\n\ngoal (1 subgoal):\n 1. drop i xs = x # snd (splitAt x xs)", "by auto"], ["proof (state)\nthis:\n  drop i xs = x # snd (splitAt x xs)\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "have \"rotate i xs = drop (i mod length xs) xs @ take (i mod length xs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate i xs = drop (i mod |xs|) xs @ take (i mod |xs|) xs", "by (rule rotate_drop_take)"], ["proof (state)\nthis:\n  rotate i xs = drop (i mod |xs|) xs @ take (i mod |xs|) xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "with i_len"], ["proof (chain)\npicking this:\n  i < |xs|\n  rotate i xs = drop (i mod |xs|) xs @ take (i mod |xs|) xs", "have \"rotate i xs = drop i xs @ take i xs\""], ["proof (prove)\nusing this:\n  i < |xs|\n  rotate i xs = drop (i mod |xs|) xs @ take (i mod |xs|) xs\n\ngoal (1 subgoal):\n 1. rotate i xs = drop i xs @ take i xs", "by auto"], ["proof (state)\nthis:\n  rotate i xs = drop i xs @ take i xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "with take_i drop_i"], ["proof (chain)\npicking this:\n  fst (splitAt x xs) = take i xs\n  drop i xs = x # snd (splitAt x xs)\n  rotate i xs = drop i xs @ take i xs", "have \"rotate i xs = (x # snd(splitAt x xs)) @ fst(splitAt x xs)\""], ["proof (prove)\nusing this:\n  fst (splitAt x xs) = take i xs\n  drop i xs = x # snd (splitAt x xs)\n  rotate i xs = drop i xs @ take i xs\n\ngoal (1 subgoal):\n 1. rotate i xs = (x # snd (splitAt x xs)) @ fst (splitAt x xs)", "by auto"], ["proof (state)\nthis:\n  rotate i xs = (x # snd (splitAt x xs)) @ fst (splitAt x xs)\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> xs \\<cong> rotate_to xs x", "thus ?thesis"], ["proof (prove)\nusing this:\n  rotate i xs = (x # snd (splitAt x xs)) @ fst (splitAt x xs)\n\ngoal (1 subgoal):\n 1. xs \\<cong> rotate_to xs x", "apply (auto simp: congs_def rotate_to_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate i xs =\n    x # snd (splitAt x xs) @ fst (splitAt x xs) \\<Longrightarrow>\n    \\<exists>n. x # snd (splitAt x xs) @ fst (splitAt x xs) = rotate n xs", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate i xs =\n    x # snd (splitAt x xs) @ fst (splitAt x xs) \\<Longrightarrow>\n    x # snd (splitAt x xs) @ fst (splitAt x xs) = rotate ?n1 xs", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate i xs =\n    x # snd (splitAt x xs) @ fst (splitAt x xs) \\<Longrightarrow>\n    rotate ?n1 xs = x # snd (splitAt x xs) @ fst (splitAt x xs)", "."], ["proof (state)\nthis:\n  xs \\<cong> rotate_to xs x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma face_cong_if_norm_eq:\n \"\\<lbrakk> rotate_min xs = rotate_min ys; xs \\<noteq> []; ys \\<noteq> [] \\<rbrakk> \\<Longrightarrow> xs \\<cong> ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rotate_min xs = rotate_min ys; xs \\<noteq> [];\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> ys", "apply(simp add:rotate_min_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> ys", "apply(subgoal_tac \"xs \\<cong> rotate_to xs (Min (set xs))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> [];\n     xs \\<cong> rotate_to xs (Min (set xs))\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> ys\n 2. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> rotate_to xs (Min (set xs))", "apply(subgoal_tac \"ys \\<cong> rotate_to ys (Min (set ys))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> []; xs \\<cong> rotate_to xs (Min (set xs));\n     ys \\<cong> rotate_to ys (Min (set ys))\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> ys\n 2. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> [];\n     xs \\<cong> rotate_to xs (Min (set xs))\\<rbrakk>\n    \\<Longrightarrow> ys \\<cong> rotate_to ys (Min (set ys))\n 3. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> rotate_to xs (Min (set xs))", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> []; xs \\<cong> rotate_to ys (Min (set ys));\n     ys \\<cong> rotate_to ys (Min (set ys))\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> ys\n 2. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> [];\n     xs \\<cong> rotate_to xs (Min (set xs))\\<rbrakk>\n    \\<Longrightarrow> ys \\<cong> rotate_to ys (Min (set ys))\n 3. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> rotate_to xs (Min (set xs))", "apply(blast intro:congs_sym congs_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> [];\n     xs \\<cong> rotate_to xs (Min (set xs))\\<rbrakk>\n    \\<Longrightarrow> ys \\<cong> rotate_to ys (Min (set ys))\n 2. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> rotate_to xs (Min (set xs))", "apply(simp add: cong_rotate_to)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rotate_to xs (Min (set xs)) = rotate_to ys (Min (set ys));\n     xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> rotate_to xs (Min (set xs))", "apply(drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n     rotate_to ys (Min (set ys)) = rotate_to xs (Min (set xs))\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> rotate_to xs (Min (set xs))", "apply(simp add: cong_rotate_to)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma norm_eq_if_face_cong:\n  \"\\<lbrakk> xs \\<cong> ys; distinct xs; xs \\<noteq> [] \\<rbrakk> \\<Longrightarrow> rotate_min xs = rotate_min ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<cong> ys; distinct xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate_min xs = rotate_min ys", "by(auto simp:congs_def rotate_min_def rotate_to_def\n  splitAt_rotate_pair_conv insert_absorb)"], ["", "lemma norm_eq_iff_face_cong:\n \"\\<lbrakk> distinct xs; xs \\<noteq> []; ys \\<noteq> [] \\<rbrakk> \\<Longrightarrow>\n  (rotate_min xs = rotate_min ys) = (xs \\<cong> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (rotate_min xs = rotate_min ys) = xs \\<cong> ys", "by(blast intro: face_cong_if_norm_eq norm_eq_if_face_cong)"], ["", "lemma inj_on_rotate_min_iff:\nassumes \"\\<forall>vs \\<in> A. distinct vs\"  \"[] \\<notin> A\"\nshows \"inj_on rotate_min A = inj_on (\\<lambda>vs. {vs}//{\\<cong>}) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on rotate_min A = inj_on (\\<lambda>vs. {vs} // {\\<cong>}) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on rotate_min A = inj_on (\\<lambda>vs. {vs} // {\\<cong>}) A", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on rotate_min A = inj_on (\\<lambda>vs. {vs} // {\\<cong>}) A", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on rotate_min A = inj_on (\\<lambda>vs. {vs} // {\\<cong>}) A", "assume xs: \"xs \\<in> A\" and ys : \"ys \\<in> A\""], ["proof (state)\nthis:\n  xs \\<in> A\n  ys \\<in> A\n\ngoal (1 subgoal):\n 1. inj_on rotate_min A = inj_on (\\<lambda>vs. {vs} // {\\<cong>}) A", "hence \"xs \\<noteq> [] \\<and> ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  xs \\<in> A\n  ys \\<in> A\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and> ys \\<noteq> []", "using assms(2)"], ["proof (prove)\nusing this:\n  xs \\<in> A\n  ys \\<in> A\n  [] \\<notin> A\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<and> ys \\<noteq> []", "by blast"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<and> ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. inj_on rotate_min A = inj_on (\\<lambda>vs. {vs} // {\\<cong>}) A", "hence \"(rotate_min xs = rotate_min ys) = (xs \\<cong> ys)\""], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<and> ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (rotate_min xs = rotate_min ys) = xs \\<cong> ys", "using xs assms(1)"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<and> ys \\<noteq> []\n  xs \\<in> A\n  \\<forall>vs\\<in>A. distinct vs\n\ngoal (1 subgoal):\n 1. (rotate_min xs = rotate_min ys) = xs \\<cong> ys", "by(simp add: singleton_list_cong_eq_iff norm_eq_iff_face_cong)"], ["proof (state)\nthis:\n  (rotate_min xs = rotate_min ys) = xs \\<cong> ys\n\ngoal (1 subgoal):\n 1. inj_on rotate_min A = inj_on (\\<lambda>vs. {vs} // {\\<cong>}) A", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xs2 \\<in> A; ?ys2 \\<in> A\\<rbrakk>\n  \\<Longrightarrow> (rotate_min ?xs2 = rotate_min ?ys2) = ?xs2 \\<cong> ?ys2\n\ngoal (1 subgoal):\n 1. inj_on rotate_min A = inj_on (\\<lambda>vs. {vs} // {\\<cong>}) A", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs2 \\<in> A; ?ys2 \\<in> A\\<rbrakk>\n  \\<Longrightarrow> (rotate_min ?xs2 = rotate_min ?ys2) = ?xs2 \\<cong> ?ys2\n\ngoal (1 subgoal):\n 1. inj_on rotate_min A = inj_on (\\<lambda>vs. {vs} // {\\<cong>}) A", "by(simp add:inj_on_def)"], ["proof (state)\nthis:\n  inj_on rotate_min A = inj_on (\\<lambda>vs. {vs} // {\\<cong>}) A\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}