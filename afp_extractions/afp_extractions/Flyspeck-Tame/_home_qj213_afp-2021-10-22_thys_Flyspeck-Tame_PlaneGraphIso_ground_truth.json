{"file_name": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame/PlaneGraphIso.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame", "problem_names": ["lemma image_image_id_if[simp]: \"(\\<And>x. f(f x) = x) \\<Longrightarrow> f ` f ` M = M\"", "lemma [iff]: \"((x,y) \\<in> {\\<cong>}) = x \\<cong> y\"", "lemma congs_refl[iff]: \"(xs::'a list) \\<cong> xs\"", "lemma congs_sym: assumes A: \"(xs::'a list) \\<cong> ys\" shows \"ys \\<cong> xs\"", "lemma congs_trans: \"(xs::'a list) \\<cong> ys \\<Longrightarrow> ys \\<cong> zs \\<Longrightarrow> xs \\<cong> zs\"", "lemma equiv_EqF: \"equiv (UNIV::'a list set) {\\<cong>}\"", "lemma congs_distinct:\n  \"F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow> distinct F\\<^sub>2 = distinct F\\<^sub>1\"", "lemma congs_length:\n  \"F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>1\"", "lemma congs_pres_nodes: \"F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow> set F\\<^sub>1 = set F\\<^sub>2\"", "lemma congs_map:\n  \"F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow> map f F\\<^sub>1 \\<cong> map f F\\<^sub>2\"", "lemma congs_map_eq_iff:\n \"inj_on f (set xs \\<union> set ys) \\<Longrightarrow> (map f xs \\<cong> map f ys) = (xs \\<cong> ys)\"", "lemma list_cong_rev_iff[simp]:\n  \"(rev xs \\<cong> rev ys) = (xs \\<cong> ys)\"", "lemma singleton_list_cong_eq_iff[simp]:\n  \"({xs::'a list} // {\\<cong>} = {ys} // {\\<cong>}) = (xs \\<cong> ys)\"", "lemma UN_subset_iff: \"((\\<Union>i\\<in>I. f i) \\<subseteq> B) = (\\<forall>i\\<in>I. f i \\<subseteq> B)\"", "lemma pr_Hom_pres_face_nodes:\n \"is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<Longrightarrow> (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` (set F)}) = (\\<Union>F\\<in>Fs\\<^sub>2. {set F})\"", "lemma pr_Hom_pres_nodes:\n  assumes \"is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2\"\n  shows \"\\<phi> ` (\\<Union>F\\<in>Fs\\<^sub>1. set F) = (\\<Union>F\\<in>Fs\\<^sub>2. set F)\"", "lemma pr_Iso_same_no_nodes:\n  \"\\<lbrakk> is_pr_Iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2; finite Fs\\<^sub>1 \\<rbrakk>\n   \\<Longrightarrow> card(\\<Union>F\\<in>Fs\\<^sub>1. set F) = card(\\<Union>F\\<in>Fs\\<^sub>2. set F)\"", "lemma pr_iso_same_no_nodes:\n  \"is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<Longrightarrow> card(\\<Union>F\\<in>set Fs\\<^sub>1. set F) = card(\\<Union>F\\<in>set Fs\\<^sub>2. set F)\"", "lemma pr_iso_same_no_faces:\n  assumes dist1: \"distinct Fs\\<^sub>1\" and dist2: \"distinct Fs\\<^sub>2\"\n  and inj1: \"inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>1)\"\n  and inj2: \"inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2)\" and iso: \"is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2\"\n  shows \"length Fs\\<^sub>1 = length Fs\\<^sub>2\"", "lemma is_Hom_distinct:\n \"\\<lbrakk> is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2; \\<forall>F\\<in>Fs\\<^sub>1. distinct F; \\<forall>F\\<in>Fs\\<^sub>2. distinct F \\<rbrakk>\n  \\<Longrightarrow> \\<forall>F\\<in>Fs\\<^sub>1. distinct(map \\<phi> F)\"", "lemma Collect_congs_eq_iff[simp]:\n  \"Collect ((\\<cong>) x) = Collect ((\\<cong>) y) \\<longleftrightarrow> (x \\<cong> (y::'a list))\"", "lemma is_pr_Hom_trans: assumes f: \"is_pr_Hom f A B\" and g: \"is_pr_Hom g B C\"\nshows \"is_pr_Hom (g \\<circ> f) A C\"", "lemma is_pr_Hom_rev:\n  \"is_pr_Hom \\<phi> A B \\<Longrightarrow> is_pr_Hom \\<phi> (rev ` A) (rev ` B)\"", "lemma is_pr_Iso_rec:\n \"\\<lbrakk> inj_on (\\<lambda>xs. {xs}//{\\<cong>}) Fs\\<^sub>1; inj_on (\\<lambda>xs. {xs}//{\\<cong>}) Fs\\<^sub>2; F\\<^sub>1 \\<in> Fs\\<^sub>1 \\<rbrakk> \\<Longrightarrow>\n is_pr_Iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 =\n (\\<exists>F\\<^sub>2 \\<in> Fs\\<^sub>2. length F\\<^sub>1 = length F\\<^sub>2 \\<and> is_pr_Iso \\<phi> (Fs\\<^sub>1 - {F\\<^sub>1}) (Fs\\<^sub>2 - {F\\<^sub>2})\n    \\<and> (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n    \\<and> inj_on \\<phi> (\\<Union>F\\<in>Fs\\<^sub>1. set F))\"", "lemma is_iso_Cons:\n \"\\<lbrakk> distinct (F\\<^sub>1#Fs\\<^sub>1'); distinct Fs\\<^sub>2;\n    inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set(F\\<^sub>1#Fs\\<^sub>1')); inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2) \\<rbrakk>\n  \\<Longrightarrow>\n is_pr_iso \\<phi> (F\\<^sub>1#Fs\\<^sub>1') Fs\\<^sub>2 =\n (\\<exists>F\\<^sub>2 \\<in> set Fs\\<^sub>2. length F\\<^sub>1 = length F\\<^sub>2 \\<and> is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2)\n    \\<and> (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n    \\<and> inj_on \\<phi> (set F\\<^sub>1 \\<union> (\\<Union>F\\<in>set Fs\\<^sub>1'. set F)))\"", "lemma map_upd_submap:\n  \"x \\<notin> dom m \\<Longrightarrow> (m(x \\<mapsto> y) \\<subseteq>\\<^sub>m m') = (m' x = Some y \\<and> m \\<subseteq>\\<^sub>m m')\"", "lemma map_of_zip_submap: \"\\<lbrakk> length xs = length ys; distinct xs \\<rbrakk> \\<Longrightarrow>\n (map_of (zip xs ys) \\<subseteq>\\<^sub>m Some \\<circ> f) = (map f xs = ys)\"", "lemma map_compatI: \"\\<lbrakk> f \\<subseteq>\\<^sub>m Some \\<circ> h; g \\<subseteq>\\<^sub>m Some \\<circ> h \\<rbrakk> \\<Longrightarrow> f \\<subseteq>\\<^sub>m f++g\"", "lemma inj_on_map_addI1:\n \"\\<lbrakk> inj_on m A; m \\<subseteq>\\<^sub>m m++m'; A \\<subseteq> dom m \\<rbrakk> \\<Longrightarrow> inj_on (m++m') A\"", "lemma map_image_eq: \"\\<lbrakk> A \\<subseteq> dom m; m \\<subseteq>\\<^sub>m m' \\<rbrakk> \\<Longrightarrow> m ` A = m' ` A\"", "lemma inj_on_map_add_Un:\n \"\\<lbrakk> inj_on m (dom m); inj_on m' (dom m'); m \\<subseteq>\\<^sub>m Some \\<circ> f; m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n    inj_on f (dom m' \\<union> dom m); A = dom m'; B = dom m \\<rbrakk>\n  \\<Longrightarrow> inj_on (m ++ m') (A \\<union> B)\"", "lemma map_of_zip_eq_SomeD: \"length xs = length ys \\<Longrightarrow>\n  map_of (zip xs ys) x = Some y \\<Longrightarrow> y \\<in> set ys\"", "lemma inj_on_map_of_zip:\n  \"\\<lbrakk> length xs = length ys; distinct ys \\<rbrakk>\n   \\<Longrightarrow> inj_on (map_of (zip xs ys)) (set xs)\"", "lemma pr_iso_test0_correct: \"\\<And>m Fs\\<^sub>2.\n \\<lbrakk> \\<forall>F\\<in>set Fs\\<^sub>1. distinct F; \\<forall>F\\<in>set Fs\\<^sub>2. distinct F;\n   distinct Fs\\<^sub>1; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>1);\n   distinct Fs\\<^sub>2; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2); inj_on m (dom m) \\<rbrakk> \\<Longrightarrow>\n       pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2 =\n       (\\<exists>\\<phi>. is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n            inj_on \\<phi> (dom m \\<union> (\\<Union>F\\<in>set Fs\\<^sub>1. set F)))\"", "lemma test0_conv_test1:\n \"\\<And>m Fs\\<^sub>2. [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow> pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 = pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2\"", "lemma notin_range_map_of:\n \"y \\<notin> snd ` set xys \\<Longrightarrow> Some y \\<notin> range(map_of xys)\"", "lemma inj_on_map_upd:\n  \"\\<lbrakk> inj_on m (dom m); Some y \\<notin> range m \\<rbrakk> \\<Longrightarrow> inj_on (m(x\\<mapsto>y)) (dom m)\"", "lemma [simp]:\n \"distinct(map snd xys) \\<Longrightarrow> inj_on (map_of xys) (dom(map_of xys))\"", "lemma lem: \"Ball (set xs) P \\<Longrightarrow> Ball (set (remove1 x xs)) P = True\"", "lemma pr_iso_test2_conv_1:\n  \"\\<And>I Fs\\<^sub>2.\n  \\<lbrakk> \\<forall>I I'. oneone I \\<longrightarrow> oneone I' \\<longrightarrow>\n           tst I' I = (let m = map_of I; m' = map_of I'\n                       in m \\<subseteq>\\<^sub>m m ++ m' \\<and> inj_on (m++m') (dom(m++m')));\n   \\<forall>I I'. oneone I \\<longrightarrow> oneone I' \\<longrightarrow> tst I' I\n          \\<longrightarrow> map_of(mrg I' I) = map_of I ++ map_of I';\n   \\<forall>I I'. oneone I \\<and> oneone I' \\<longrightarrow> tst I' I \\<longrightarrow> oneone (mrg I' I);\n   oneone I;\n   \\<forall>F \\<in> set Fs\\<^sub>1. distinct F; \\<forall>F \\<in> set Fs\\<^sub>2. distinct F \\<rbrakk> \\<Longrightarrow>\n  pr_iso_test2 tst mrg I Fs\\<^sub>1 Fs\\<^sub>2 = pr_iso_test1 (map_of I) Fs\\<^sub>1 Fs\\<^sub>2\"", "lemma image_map_upd:\n  \"x \\<notin> dom m \\<Longrightarrow> m(x\\<mapsto>y) ` A = m ` (A-{x}) \\<union> (if x \\<in> A then {Some y} else {})\"", "lemma image_map_of_conv_Image:\n \"\\<And>A. \\<lbrakk> distinct(map fst xys) \\<rbrakk>\n \\<Longrightarrow> map_of xys ` A = Some ` (set xys `` A) \\<union> (if A \\<subseteq> fst ` set xys then {} else {None})\"", "lemma [simp]: \"m++m' ` (dom m' - A) = m' ` (dom m' - A)\"", "lemma compat_correct:\n \"\\<lbrakk> oneone I; oneone I' \\<rbrakk> \\<Longrightarrow>\n  compat I' I = (let m = map_of I; m' = map_of I'\n                 in m \\<subseteq>\\<^sub>m m ++ m' \\<and> inj_on (m++m') (dom(m++m')))\"", "lemma help1:\n\"distinct(map fst xys) \\<Longrightarrow> map_of (filter P xys) =\n map_of xys |` {x. \\<exists>y. (x,y) \\<in> set xys \\<and> P(x,y)}\"", "lemma merge0_correct:\n  \"\\<forall>I I'. oneone I \\<longrightarrow> oneone I' \\<longrightarrow> compat I' I\n  \\<longrightarrow> map_of(merge0 I' I) = map_of I ++ map_of I'\"", "lemma merge0_inv:\n  \"\\<forall>I I'. oneone I \\<and> oneone I' \\<longrightarrow> compat I' I \\<longrightarrow> oneone (merge0 I' I)\"", "lemma merge_conv_merge0: \"merge I' I = merge0 I' I\"", "lemma pr_iso_test_rec_conv_2:\n  \"\\<And>I Fs\\<^sub>2. pr_iso_test_rec I Fs\\<^sub>1 Fs\\<^sub>2 = pr_iso_test2 compat merge0 I Fs\\<^sub>1 Fs\\<^sub>2\"", "lemma iso_fgraph_trans: assumes \"f \\<simeq> (g::'a fgraph)\" and \"g \\<simeq> h\" shows \"f \\<simeq> h\"", "theorem iso_correct:\n \"\\<lbrakk> \\<forall>F\\<in>set Fs\\<^sub>1. distinct F; \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n   distinct Fs\\<^sub>1; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>1);\n   distinct Fs\\<^sub>2; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2) \\<rbrakk> \\<Longrightarrow>\n  iso_test Fs\\<^sub>1 Fs\\<^sub>2 = (Fs\\<^sub>1 \\<simeq> Fs\\<^sub>2)\"", "lemma iso_fgraph_refl[iff]: \"g \\<simeq> g\""], "translations": [["", "lemma image_image_id_if[simp]: \"(\\<And>x. f(f x) = x) \\<Longrightarrow> f ` f ` M = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f (f x) = x) \\<Longrightarrow> f ` f ` M = M", "by (auto simp: image_iff)"], ["", "declare not_None_eq [iff] not_Some_eq [iff]"], ["", "text\\<open>The symbols \\<open>\\<cong>\\<close> and \\<open>\\<simeq>\\<close> are overloaded.  They\ndenote congruence and isomorphism on arbitrary types. On lists\n(representing faces of graphs), \\<open>\\<cong>\\<close> means congruence modulo\nrotation; \\<open>\\<simeq>\\<close> is currently unused. On graphs, \\<open>\\<simeq>\\<close>\nmeans isomorphism and is a weaker version of \\<open>\\<cong>\\<close> (proper\nisomorphism): \\<open>\\<simeq>\\<close> also allows to reverse the orientation of\nall faces.\\<close>"], ["", "consts\n pr_isomorphic  :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<cong>\" 60)"], ["", "(* isomorphic :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<simeq>\" 60)\n*)\n(*\ndefinition \"congs\"  :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\" (infix \"\\<cong>\" 60) where\n \"F\\<^sub>1 \\<cong> (F\\<^sub>2::'a list) \\<equiv> \\<exists>n. F\\<^sub>2 = rotate n F\\<^sub>1\"\n*)"], ["", "definition Iso :: \"('a list * 'a list) set\" (\"{\\<cong>}\") where\n \"{\\<cong>} \\<equiv> {(F\\<^sub>1, F\\<^sub>2). F\\<^sub>1 \\<cong> F\\<^sub>2}\""], ["", "lemma [iff]: \"((x,y) \\<in> {\\<cong>}) = x \\<cong> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> {\\<cong>}) = x \\<cong> y", "by(simp add:Iso_def)"], ["", "text\\<open>A plane graph is a set or list (for executability) of faces\n(hence \\<open>Fgraph\\<close> and \\<open>fgraph\\<close>) and a face is a list of\nnodes:\\<close>"], ["", "type_synonym 'a Fgraph = \"'a list set\""], ["", "type_synonym 'a fgraph = \"'a list list\""], ["", "subsection\\<open>Equivalence of faces\\<close>"], ["", "text\\<open>Two faces are equivalent modulo rotation:\\<close>"], ["", "overloading \"congs\" \\<equiv> \"pr_isomorphic :: 'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\nbegin"], ["", "definition \"F\\<^sub>1 \\<cong> (F\\<^sub>2::'a list) \\<equiv> \\<exists>n. F\\<^sub>2 = rotate n F\\<^sub>1\""], ["", "end"], ["", "lemma congs_refl[iff]: \"(xs::'a list) \\<cong> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<cong> xs", "apply(simp add:congs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. xs = rotate n xs", "apply(rule_tac x = 0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = rotate 0 xs", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma congs_sym: assumes A: \"(xs::'a list) \\<cong> ys\" shows \"ys \\<cong> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<cong> xs", "proof (simp add:congs_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. xs = rotate n ys", "let ?l = \"length xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. xs = rotate n ys", "from A"], ["proof (chain)\npicking this:\n  xs \\<cong> ys", "obtain n where ys: \"ys = rotate n xs\""], ["proof (prove)\nusing this:\n  xs \\<cong> ys\n\ngoal (1 subgoal):\n 1. (\\<And>n. ys = rotate n xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add:congs_def)"], ["proof (state)\nthis:\n  ys = rotate n xs\n\ngoal (1 subgoal):\n 1. \\<exists>n. xs = rotate n ys", "have \"xs = rotate ?l xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = rotate (length xs) xs", "by simp"], ["proof (state)\nthis:\n  xs = rotate (length xs) xs\n\ngoal (1 subgoal):\n 1. \\<exists>n. xs = rotate n ys", "also"], ["proof (state)\nthis:\n  xs = rotate (length xs) xs\n\ngoal (1 subgoal):\n 1. \\<exists>n. xs = rotate n ys", "have \"\\<dots> = rotate (?l - n mod ?l + n mod ?l) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs\n 2. \\<not> ?P \\<Longrightarrow>\n    rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs", "assume \"xs = []\""], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs\n 2. \\<not> ?P \\<Longrightarrow>\n    rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs", "by simp"], ["proof (state)\nthis:\n  rotate (length xs) xs =\n  rotate (length xs - n mod length xs + n mod length xs) xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs", "assume \"xs \\<noteq> []\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs", "hence \"n mod ?l < ?l\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. n mod length xs < length xs", "by simp"], ["proof (state)\nthis:\n  n mod length xs < length xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs", "hence \"?l = ?l - n mod ?l + n mod ?l\""], ["proof (prove)\nusing this:\n  n mod length xs < length xs\n\ngoal (1 subgoal):\n 1. length xs = length xs - n mod length xs + n mod length xs", "by arith"], ["proof (state)\nthis:\n  length xs = length xs - n mod length xs + n mod length xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  length xs = length xs - n mod length xs + n mod length xs\n\ngoal (1 subgoal):\n 1. rotate (length xs) xs =\n    rotate (length xs - n mod length xs + n mod length xs) xs", "by simp"], ["proof (state)\nthis:\n  rotate (length xs) xs =\n  rotate (length xs - n mod length xs + n mod length xs) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rotate (length xs) xs =\n  rotate (length xs - n mod length xs + n mod length xs) xs\n\ngoal (1 subgoal):\n 1. \\<exists>n. xs = rotate n ys", "also"], ["proof (state)\nthis:\n  rotate (length xs) xs =\n  rotate (length xs - n mod length xs + n mod length xs) xs\n\ngoal (1 subgoal):\n 1. \\<exists>n. xs = rotate n ys", "have \"\\<dots> = rotate (?l - n mod ?l) (rotate (n mod ?l) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (length xs - n mod length xs + n mod length xs) xs =\n    rotate (length xs - n mod length xs) (rotate (n mod length xs) xs)", "by(simp add:rotate_rotate)"], ["proof (state)\nthis:\n  rotate (length xs - n mod length xs + n mod length xs) xs =\n  rotate (length xs - n mod length xs) (rotate (n mod length xs) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>n. xs = rotate n ys", "also"], ["proof (state)\nthis:\n  rotate (length xs - n mod length xs + n mod length xs) xs =\n  rotate (length xs - n mod length xs) (rotate (n mod length xs) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>n. xs = rotate n ys", "have \"rotate (n mod ?l) xs = rotate n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (n mod length xs) xs = rotate n xs", "by(rule rotate_conv_mod[symmetric])"], ["proof (state)\nthis:\n  rotate (n mod length xs) xs = rotate n xs\n\ngoal (1 subgoal):\n 1. \\<exists>n. xs = rotate n ys", "finally"], ["proof (chain)\npicking this:\n  xs = rotate (length xs - n mod length xs) (rotate n xs)", "show \"\\<exists>m. xs = rotate m ys\""], ["proof (prove)\nusing this:\n  xs = rotate (length xs - n mod length xs) (rotate n xs)\n\ngoal (1 subgoal):\n 1. \\<exists>m. xs = rotate m ys", "by(fastforce simp add:ys)"], ["proof (state)\nthis:\n  \\<exists>m. xs = rotate m ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma congs_trans: \"(xs::'a list) \\<cong> ys \\<Longrightarrow> ys \\<cong> zs \\<Longrightarrow> xs \\<cong> zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<cong> ys; ys \\<cong> zs\\<rbrakk>\n    \\<Longrightarrow> xs \\<cong> zs", "apply(clarsimp simp:congs_def rotate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       \\<lbrakk>ys = (rotate1 ^^ n) xs;\n        zs = (rotate1 ^^ na) ((rotate1 ^^ n) xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nb.\n                            (rotate1 ^^ na) ((rotate1 ^^ n) xs) =\n                            (rotate1 ^^ nb) xs", "apply(rename_tac m n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>ys = (rotate1 ^^ m) xs;\n        zs = (rotate1 ^^ n) ((rotate1 ^^ m) xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            (rotate1 ^^ n) ((rotate1 ^^ m) xs) =\n                            (rotate1 ^^ na) xs", "apply(rule_tac x = \"n+m\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>ys = (rotate1 ^^ m) xs;\n        zs = (rotate1 ^^ n) ((rotate1 ^^ m) xs)\\<rbrakk>\n       \\<Longrightarrow> (rotate1 ^^ n) ((rotate1 ^^ m) xs) =\n                         (rotate1 ^^ (n + m)) xs", "apply (simp add:funpow_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma equiv_EqF: \"equiv (UNIV::'a list set) {\\<cong>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv UNIV {\\<cong>}", "apply(unfold equiv_def sym_def trans_def refl_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({\\<cong>} \\<subseteq> UNIV \\<times> UNIV \\<and>\n     (\\<forall>x\\<in>UNIV. (x, x) \\<in> {\\<cong>})) \\<and>\n    (\\<forall>x y.\n        (x, y) \\<in> {\\<cong>} \\<longrightarrow>\n        (y, x) \\<in> {\\<cong>}) \\<and>\n    (\\<forall>x y z.\n        (x, y) \\<in> {\\<cong>} \\<longrightarrow>\n        (y, z) \\<in> {\\<cong>} \\<longrightarrow> (x, z) \\<in> {\\<cong>})", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<cong>} \\<subseteq> UNIV \\<times> UNIV \\<and>\n    (\\<forall>x\\<in>UNIV. (x, x) \\<in> {\\<cong>})\n 2. (\\<forall>x y.\n        (x, y) \\<in> {\\<cong>} \\<longrightarrow>\n        (y, x) \\<in> {\\<cong>}) \\<and>\n    (\\<forall>x y z.\n        (x, y) \\<in> {\\<cong>} \\<longrightarrow>\n        (y, z) \\<in> {\\<cong>} \\<longrightarrow> (x, z) \\<in> {\\<cong>})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        (x, y) \\<in> {\\<cong>} \\<longrightarrow>\n        (y, x) \\<in> {\\<cong>}) \\<and>\n    (\\<forall>x y z.\n        (x, y) \\<in> {\\<cong>} \\<longrightarrow>\n        (y, z) \\<in> {\\<cong>} \\<longrightarrow> (x, z) \\<in> {\\<cong>})", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x y.\n       (x, y) \\<in> {\\<cong>} \\<longrightarrow> (y, x) \\<in> {\\<cong>}\n 2. \\<forall>x y z.\n       (x, y) \\<in> {\\<cong>} \\<longrightarrow>\n       (y, z) \\<in> {\\<cong>} \\<longrightarrow> (x, z) \\<in> {\\<cong>}", "apply(fastforce intro:congs_sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> {\\<cong>} \\<longrightarrow>\n       (y, z) \\<in> {\\<cong>} \\<longrightarrow> (x, z) \\<in> {\\<cong>}", "apply(fastforce intro:congs_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma congs_distinct:\n  \"F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow> distinct F\\<^sub>2 = distinct F\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow>\n    distinct F\\<^sub>2 = distinct F\\<^sub>1", "by (auto simp: congs_def)"], ["", "lemma congs_length:\n  \"F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow>\n    length F\\<^sub>2 = length F\\<^sub>1", "by (auto simp: congs_def)"], ["", "lemma congs_pres_nodes: \"F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow> set F\\<^sub>1 = set F\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow>\n    set F\\<^sub>1 = set F\\<^sub>2", "by(clarsimp simp:congs_def)"], ["", "lemma congs_map:\n  \"F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow> map f F\\<^sub>1 \\<cong> map f F\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F\\<^sub>1 \\<cong> F\\<^sub>2 \\<Longrightarrow>\n    map f F\\<^sub>1 \\<cong> map f F\\<^sub>2", "by (auto simp: congs_def rotate_map)"], ["", "lemma congs_map_eq_iff:\n \"inj_on f (set xs \\<union> set ys) \\<Longrightarrow> (map f xs \\<cong> map f ys) = (xs \\<cong> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set xs \\<union> set ys) \\<Longrightarrow>\n    map f xs \\<cong> map f ys = xs \\<cong> ys", "apply(simp add:congs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set xs \\<union> set ys) \\<Longrightarrow>\n    (\\<exists>n. map f ys = rotate n (map f xs)) =\n    (\\<exists>n. ys = rotate n xs)", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on f (set xs \\<union> set ys);\n     \\<exists>n. map f ys = rotate n (map f xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. ys = rotate n xs\n 2. \\<lbrakk>inj_on f (set xs \\<union> set ys);\n     \\<exists>n. ys = rotate n xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. map f ys = rotate n (map f xs)", "apply(clarsimp simp: rotate_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>inj_on f (set xs \\<union> set ys);\n        map f ys = map f (rotate n xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. ys = rotate n xs\n 2. \\<lbrakk>inj_on f (set xs \\<union> set ys);\n     \\<exists>n. ys = rotate n xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. map f ys = rotate n (map f xs)", "apply(drule map_inj_on)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       inj_on f (set xs \\<union> set ys) \\<Longrightarrow>\n       inj_on f (set ys \\<union> set (rotate n xs))\n 2. \\<And>n.\n       \\<lbrakk>inj_on f (set xs \\<union> set ys); ys = rotate n xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. ys = rotate n xs\n 3. \\<lbrakk>inj_on f (set xs \\<union> set ys);\n     \\<exists>n. ys = rotate n xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. map f ys = rotate n (map f xs)", "apply(simp add:Un_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>inj_on f (set xs \\<union> set ys); ys = rotate n xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. ys = rotate n xs\n 2. \\<lbrakk>inj_on f (set xs \\<union> set ys);\n     \\<exists>n. ys = rotate n xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. map f ys = rotate n (map f xs)", "apply (fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on f (set xs \\<union> set ys);\n     \\<exists>n. ys = rotate n xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. map f ys = rotate n (map f xs)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>inj_on f (set xs); ys = rotate n xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            map f (rotate n xs) = rotate na (map f xs)", "apply(fastforce simp: rotate_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_cong_rev_iff[simp]:\n  \"(rev xs \\<cong> rev ys) = (xs \\<cong> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs \\<cong> rev ys = xs \\<cong> ys", "apply(simp add:congs_def rotate_rev)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n. ys = rotate (length xs - n mod length xs) xs) =\n    (\\<exists>n. ys = rotate n xs)", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>n.\n       ys = rotate (length xs - n mod length xs) xs \\<Longrightarrow>\n    \\<exists>n. ys = rotate n xs\n 2. \\<exists>n. ys = rotate n xs \\<Longrightarrow>\n    \\<exists>n. ys = rotate (length xs - n mod length xs) xs", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. ys = rotate n xs \\<Longrightarrow>\n    \\<exists>n. ys = rotate (length xs - n mod length xs) xs", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ys = rotate n xs \\<Longrightarrow>\n       \\<exists>na. rotate n xs = rotate (length xs - na mod length xs) xs", "apply(cases \"length xs = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>ys = rotate n xs; length xs = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            rotate n xs =\n                            rotate (length xs - na mod length xs) xs\n 2. \\<And>n.\n       \\<lbrakk>ys = rotate n xs; length xs \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            rotate n xs =\n                            rotate (length xs - na mod length xs) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>ys = rotate n xs; length xs \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            rotate n xs =\n                            rotate (length xs - na mod length xs) xs", "apply(case_tac \"n mod length xs = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>ys = rotate n xs; length xs \\<noteq> 0;\n        n mod length xs = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            rotate n xs =\n                            rotate (length xs - na mod length xs) xs\n 2. \\<And>n.\n       \\<lbrakk>ys = rotate n xs; length xs \\<noteq> 0;\n        n mod length xs \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            rotate n xs =\n                            rotate (length xs - na mod length xs) xs", "apply(rule_tac x = \"n\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>ys = rotate n xs; length xs \\<noteq> 0;\n        n mod length xs = 0\\<rbrakk>\n       \\<Longrightarrow> rotate n xs =\n                         rotate (length xs - n mod length xs) xs\n 2. \\<And>n.\n       \\<lbrakk>ys = rotate n xs; length xs \\<noteq> 0;\n        n mod length xs \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            rotate n xs =\n                            rotate (length xs - na mod length xs) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>ys = rotate n xs; length xs \\<noteq> 0;\n        n mod length xs \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            rotate n xs =\n                            rotate (length xs - na mod length xs) xs", "apply(subst rotate_conv_mod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>ys = rotate n xs; length xs \\<noteq> 0;\n        n mod length xs \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            rotate (n mod length xs) xs =\n                            rotate (length xs - na mod length xs) xs", "apply(rule_tac x = \"length xs - n mod length xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>ys = rotate n xs; length xs \\<noteq> 0;\n        n mod length xs \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> rotate (n mod length xs) xs =\n                         rotate\n                          (length xs -\n                           (length xs - n mod length xs) mod length xs)\n                          xs", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma singleton_list_cong_eq_iff[simp]:\n  \"({xs::'a list} // {\\<cong>} = {ys} // {\\<cong>}) = (xs \\<cong> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({xs} // {\\<cong>} = {ys} // {\\<cong>}) = xs \\<cong> ys", "by(simp add: eq_equiv_class_iff2[OF equiv_EqF])"], ["", "subsection\\<open>Homomorphism and isomorphism\\<close>"], ["", "definition is_pr_Hom :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a Fgraph \\<Rightarrow> 'b Fgraph \\<Rightarrow> bool\" where\n\"is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<equiv> (map \\<phi> ` Fs\\<^sub>1)//{\\<cong>} = Fs\\<^sub>2 //{\\<cong>}\""], ["", "definition is_pr_Iso :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a Fgraph \\<Rightarrow> 'b Fgraph \\<Rightarrow> bool\" where\n\"is_pr_Iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<equiv> is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and> inj_on \\<phi> (\\<Union>F \\<in> Fs\\<^sub>1. set F)\""], ["", "definition is_pr_iso :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a fgraph \\<Rightarrow> 'b fgraph \\<Rightarrow> bool\" where\n\"is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<equiv> is_pr_Iso \\<phi> (set Fs\\<^sub>1) (set Fs\\<^sub>2)\""], ["", "text\\<open>Homomorphisms preserve the set of nodes.\\<close>"], ["", "lemma UN_subset_iff: \"((\\<Union>i\\<in>I. f i) \\<subseteq> B) = (\\<forall>i\\<in>I. f i \\<subseteq> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union> (f ` I) \\<subseteq> B) = (\\<forall>i\\<in>I. f i \\<subseteq> B)", "by blast"], ["", "declare Image_Collect_case_prod[simp del]"], ["", "lemma pr_Hom_pres_face_nodes:\n \"is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<Longrightarrow> (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` (set F)}) = (\\<Union>F\\<in>Fs\\<^sub>2. {set F})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<Longrightarrow>\n    (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F}) =\n    (\\<Union>F\\<in>Fs\\<^sub>2. {set F})", "supply image_cong_simp [cong del]"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<Longrightarrow>\n    (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F}) =\n    (\\<Union>F\\<in>Fs\\<^sub>2. {set F})", "apply(clarsimp simp:is_pr_Hom_def quotient_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n    (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}}) \\<Longrightarrow>\n    (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F}) =\n    (\\<Union>F\\<in>Fs\\<^sub>2. {set F})", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Fs\\<^sub>2. \\<phi> ` set F = set x\n 2. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Fs\\<^sub>1. set F = \\<phi> ` set x", "apply(subgoal_tac \"\\<exists>F' \\<in> Fs\\<^sub>2. {\\<cong>} `` {map \\<phi> F} = {\\<cong>} `` {F'}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>1;\n        \\<exists>F'\\<in>Fs\\<^sub>2.\n           {\\<cong>} `` {map \\<phi> F} = {\\<cong>} `` {F'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Fs\\<^sub>2. \\<phi> ` set F = set x\n 2. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            {\\<cong>} `` {map \\<phi> F} = {\\<cong>} `` {F'}\n 3. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Fs\\<^sub>1. set F = \\<phi> ` set x", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            {\\<cong>} `` {map \\<phi> F} = {\\<cong>} `` {F'}\n 2. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>1;\n        \\<exists>F'\\<in>Fs\\<^sub>2.\n           {\\<cong>} `` {map \\<phi> F} = {\\<cong>} `` {F'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Fs\\<^sub>2. \\<phi> ` set F = set x\n 3. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Fs\\<^sub>1. set F = \\<phi> ` set x", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>1;\n        \\<exists>F'\\<in>Fs\\<^sub>2.\n           {\\<cong>} `` {map \\<phi> F} = {\\<cong>} `` {F'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Fs\\<^sub>2. \\<phi> ` set F = set x\n 2. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Fs\\<^sub>1. set F = \\<phi> ` set x", "apply (fastforce simp: eq_equiv_class_iff[OF equiv_EqF] dest!:congs_pres_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Fs\\<^sub>1. set F = \\<phi> ` set x", "apply(subgoal_tac \"\\<exists>F' \\<in> Fs\\<^sub>1. {\\<cong>} `` {map \\<phi> F'} = {\\<cong>} `` {F}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>2;\n        \\<exists>F'\\<in>Fs\\<^sub>1.\n           {\\<cong>} `` {map \\<phi> F'} = {\\<cong>} `` {F}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>Fs\\<^sub>1. set F = \\<phi> ` set x\n 2. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>1.\n                            {\\<cong>} `` {map \\<phi> F'} = {\\<cong>} `` {F}", "apply (fastforce simp: eq_equiv_class_iff[OF equiv_EqF] dest!:congs_pres_nodes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>(\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        F \\<in> Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>1.\n                            {\\<cong>} `` {map \\<phi> F'} = {\\<cong>} `` {F}", "apply (erule equalityE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>F \\<in> Fs\\<^sub>2;\n        (\\<Union>a\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> a}})\n        \\<subseteq> (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}})\n        \\<subseteq> (\\<Union>a\\<in>Fs\\<^sub>1.\n                        {{\\<cong>} `` {map \\<phi> a}})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>1.\n                            {\\<cong>} `` {map \\<phi> F'} = {\\<cong>} `` {F}", "apply(fastforce simp:UN_subset_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pr_Hom_pres_nodes:\n  assumes \"is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2\"\n  shows \"\\<phi> ` (\\<Union>F\\<in>Fs\\<^sub>1. set F) = (\\<Union>F\\<in>Fs\\<^sub>2. set F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ` \\<Union> (set ` Fs\\<^sub>1) = \\<Union> (set ` Fs\\<^sub>2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)\n    \\<subseteq> \\<Union> (set ` Fs\\<^sub>2)\n 2. \\<Union> (set ` Fs\\<^sub>2)\n    \\<subseteq> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "from assms"], ["proof (chain)\npicking this:\n  is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2", "have *: \"(\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F}) = (\\<Union>F\\<in>Fs\\<^sub>2. {set F})\""], ["proof (prove)\nusing this:\n  is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F}) =\n    (\\<Union>F\\<in>Fs\\<^sub>2. {set F})", "by (rule pr_Hom_pres_face_nodes)"], ["proof (state)\nthis:\n  (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F}) =\n  (\\<Union>F\\<in>Fs\\<^sub>2. {set F})\n\ngoal (2 subgoals):\n 1. \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)\n    \\<subseteq> \\<Union> (set ` Fs\\<^sub>2)\n 2. \\<Union> (set ` Fs\\<^sub>2)\n    \\<subseteq> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F}) =\n  (\\<Union>F\\<in>Fs\\<^sub>2. {set F})", "show \"\\<phi> ` (\\<Union>F\\<in>Fs\\<^sub>1. set F) \\<subseteq> (\\<Union>F\\<in>Fs\\<^sub>2. set F)\""], ["proof (prove)\nusing this:\n  (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F}) =\n  (\\<Union>F\\<in>Fs\\<^sub>2. {set F})\n\ngoal (1 subgoal):\n 1. \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)\n    \\<subseteq> \\<Union> (set ` Fs\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)\n  \\<subseteq> \\<Union> (set ` Fs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<Union> (set ` Fs\\<^sub>2)\n    \\<subseteq> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "show \"(\\<Union>F\\<in>Fs\\<^sub>2. set F) \\<subseteq> \\<phi> ` (\\<Union>F\\<in>Fs\\<^sub>1. set F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set ` Fs\\<^sub>2)\n    \\<subseteq> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` Fs\\<^sub>2) \\<Longrightarrow>\n       x \\<in> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` Fs\\<^sub>2) \\<Longrightarrow>\n       x \\<in> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "assume \"x \\<in> (\\<Union>F\\<in>Fs\\<^sub>2. set F)\""], ["proof (state)\nthis:\n  x \\<in> \\<Union> (set ` Fs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` Fs\\<^sub>2) \\<Longrightarrow>\n       x \\<in> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<Union> (set ` Fs\\<^sub>2)", "obtain F where \"F \\<in> Fs\\<^sub>2\" and \"x \\<in> set F\""], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (set ` Fs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>F.\n        \\<lbrakk>F \\<in> Fs\\<^sub>2; x \\<in> set F\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  F \\<in> Fs\\<^sub>2\n  x \\<in> set F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` Fs\\<^sub>2) \\<Longrightarrow>\n       x \\<in> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  F \\<in> Fs\\<^sub>2\n  x \\<in> set F", "have \"set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>2. {set F})\""], ["proof (prove)\nusing this:\n  F \\<in> Fs\\<^sub>2\n  x \\<in> set F\n\ngoal (1 subgoal):\n 1. set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>2. {set F})", "by blast"], ["proof (state)\nthis:\n  set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>2. {set F})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` Fs\\<^sub>2) \\<Longrightarrow>\n       x \\<in> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>2. {set F})", "have \"set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F})\""], ["proof (prove)\nusing this:\n  set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>2. {set F})\n\ngoal (1 subgoal):\n 1. set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F})", "using *"], ["proof (prove)\nusing this:\n  set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>2. {set F})\n  (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F}) =\n  (\\<Union>F\\<in>Fs\\<^sub>2. {set F})\n\ngoal (1 subgoal):\n 1. set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F})", "by simp"], ["proof (state)\nthis:\n  set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` Fs\\<^sub>2) \\<Longrightarrow>\n       x \\<in> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F})", "obtain F' where \"F' \\<in> Fs\\<^sub>1\" and \"set F \\<in> {\\<phi> ` set F'}\""], ["proof (prove)\nusing this:\n  set F \\<in> (\\<Union>F\\<in>Fs\\<^sub>1. {\\<phi> ` set F})\n\ngoal (1 subgoal):\n 1. (\\<And>F'.\n        \\<lbrakk>F' \\<in> Fs\\<^sub>1; set F \\<in> {\\<phi> ` set F'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  F' \\<in> Fs\\<^sub>1\n  set F \\<in> {\\<phi> ` set F'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` Fs\\<^sub>2) \\<Longrightarrow>\n       x \\<in> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "with \\<open>x \\<in> set F\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set F\n  F' \\<in> Fs\\<^sub>1\n  set F \\<in> {\\<phi> ` set F'}", "show \"x \\<in> \\<phi> ` (\\<Union>F\\<in>Fs\\<^sub>1. set F)\""], ["proof (prove)\nusing this:\n  x \\<in> set F\n  F' \\<in> Fs\\<^sub>1\n  set F \\<in> {\\<phi> ` set F'}\n\ngoal (1 subgoal):\n 1. x \\<in> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> (set ` Fs\\<^sub>2)\n  \\<subseteq> \\<phi> ` \\<Union> (set ` Fs\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Therefore isomorphisms preserve cardinality of node set.\\<close>"], ["", "lemma pr_Iso_same_no_nodes:\n  \"\\<lbrakk> is_pr_Iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2; finite Fs\\<^sub>1 \\<rbrakk>\n   \\<Longrightarrow> card(\\<Union>F\\<in>Fs\\<^sub>1. set F) = card(\\<Union>F\\<in>Fs\\<^sub>2. set F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_pr_Iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2;\n     finite Fs\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> card (\\<Union> (set ` Fs\\<^sub>1)) =\n                      card (\\<Union> (set ` Fs\\<^sub>2))", "by(clarsimp simp add: is_pr_Iso_def pr_Hom_pres_nodes[symmetric] card_image)"], ["", "lemma pr_iso_same_no_nodes:\n  \"is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<Longrightarrow> card(\\<Union>F\\<in>set Fs\\<^sub>1. set F) = card(\\<Union>F\\<in>set Fs\\<^sub>2. set F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<Longrightarrow>\n    card (\\<Union> (set ` set Fs\\<^sub>1)) =\n    card (\\<Union> (set ` set Fs\\<^sub>2))", "by(simp add: is_pr_iso_def pr_Iso_same_no_nodes)"], ["", "text\\<open>Isomorphisms preserve the number of faces.\\<close>"], ["", "lemma pr_iso_same_no_faces:\n  assumes dist1: \"distinct Fs\\<^sub>1\" and dist2: \"distinct Fs\\<^sub>2\"\n  and inj1: \"inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>1)\"\n  and inj2: \"inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2)\" and iso: \"is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2\"\n  shows \"length Fs\\<^sub>1 = length Fs\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "have injphi: \"\\<forall>F\\<in>set Fs\\<^sub>1. \\<forall>F'\\<in>set Fs\\<^sub>1. inj_on \\<phi> (set F \\<union> set F')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>set Fs\\<^sub>1.\n       \\<forall>F'\\<in>set Fs\\<^sub>1. inj_on \\<phi> (set F \\<union> set F')", "using iso"], ["proof (prove)\nusing this:\n  is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<in>set Fs\\<^sub>1.\n       \\<forall>F'\\<in>set Fs\\<^sub>1. inj_on \\<phi> (set F \\<union> set F')", "by(auto simp:is_pr_iso_def is_pr_Iso_def is_pr_Hom_def inj_on_def)"], ["proof (state)\nthis:\n  \\<forall>F\\<in>set Fs\\<^sub>1.\n     \\<forall>F'\\<in>set Fs\\<^sub>1. inj_on \\<phi> (set F \\<union> set F')\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "have inj1': \"inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (map \\<phi> ` set Fs\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (map \\<phi> ` set Fs\\<^sub>1)", "apply(rule inj_on_imageI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((\\<lambda>xs. {xs} // {\\<cong>}) \\<circ> map \\<phi>)\n     (set Fs\\<^sub>1)", "apply(simp add:inj_on_def quotient_def eq_equiv_class_iff[OF equiv_EqF])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set Fs\\<^sub>1.\n       \\<forall>y\\<in>set Fs\\<^sub>1.\n          map \\<phi> x \\<cong> map \\<phi> y \\<longrightarrow> x = y", "apply(simp add: congs_map_eq_iff injphi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set Fs\\<^sub>1.\n       \\<forall>y\\<in>set Fs\\<^sub>1. x \\<cong> y \\<longrightarrow> x = y", "using inj1"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set Fs\\<^sub>1.\n       \\<forall>y\\<in>set Fs\\<^sub>1. x \\<cong> y \\<longrightarrow> x = y", "apply(simp add:inj_on_def quotient_def eq_equiv_class_iff[OF equiv_EqF])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (map \\<phi> ` set Fs\\<^sub>1)\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "have \"length Fs\\<^sub>1 = card(set Fs\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = card (set Fs\\<^sub>1)", "by(simp add:distinct_card[OF dist1])"], ["proof (state)\nthis:\n  length Fs\\<^sub>1 = card (set Fs\\<^sub>1)\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "also"], ["proof (state)\nthis:\n  length Fs\\<^sub>1 = card (set Fs\\<^sub>1)\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "have \"\\<dots> = card(map \\<phi> ` set Fs\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set Fs\\<^sub>1) = card (map \\<phi> ` set Fs\\<^sub>1)", "using iso"], ["proof (prove)\nusing this:\n  is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2\n\ngoal (1 subgoal):\n 1. card (set Fs\\<^sub>1) = card (map \\<phi> ` set Fs\\<^sub>1)", "by(auto simp:is_pr_iso_def is_pr_Iso_def is_pr_Hom_def inj_on_mapI card_image)"], ["proof (state)\nthis:\n  card (set Fs\\<^sub>1) = card (map \\<phi> ` set Fs\\<^sub>1)\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "also"], ["proof (state)\nthis:\n  card (set Fs\\<^sub>1) = card (map \\<phi> ` set Fs\\<^sub>1)\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "have \"\\<dots> = card((map \\<phi> ` set Fs\\<^sub>1) // {\\<cong>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map \\<phi> ` set Fs\\<^sub>1) =\n    card (map \\<phi> ` set Fs\\<^sub>1 // {\\<cong>})", "by(simp add: card_quotient_disjoint[OF _ inj1'])"], ["proof (state)\nthis:\n  card (map \\<phi> ` set Fs\\<^sub>1) =\n  card (map \\<phi> ` set Fs\\<^sub>1 // {\\<cong>})\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "also"], ["proof (state)\nthis:\n  card (map \\<phi> ` set Fs\\<^sub>1) =\n  card (map \\<phi> ` set Fs\\<^sub>1 // {\\<cong>})\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "have \"(map \\<phi> ` set Fs\\<^sub>1)//{\\<cong>} = set Fs\\<^sub>2 // {\\<cong>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map \\<phi> ` set Fs\\<^sub>1 // {\\<cong>} = set Fs\\<^sub>2 // {\\<cong>}", "using iso"], ["proof (prove)\nusing this:\n  is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2\n\ngoal (1 subgoal):\n 1. map \\<phi> ` set Fs\\<^sub>1 // {\\<cong>} = set Fs\\<^sub>2 // {\\<cong>}", "by(simp add: is_pr_iso_def is_pr_Iso_def is_pr_Hom_def)"], ["proof (state)\nthis:\n  map \\<phi> ` set Fs\\<^sub>1 // {\\<cong>} = set Fs\\<^sub>2 // {\\<cong>}\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "also"], ["proof (state)\nthis:\n  map \\<phi> ` set Fs\\<^sub>1 // {\\<cong>} = set Fs\\<^sub>2 // {\\<cong>}\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "have \"card(\\<dots>) = card(set Fs\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set Fs\\<^sub>2 // {\\<cong>}) = card (set Fs\\<^sub>2)", "by(simp add: card_quotient_disjoint[OF _ inj2])"], ["proof (state)\nthis:\n  card (set Fs\\<^sub>2 // {\\<cong>}) = card (set Fs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "also"], ["proof (state)\nthis:\n  card (set Fs\\<^sub>2 // {\\<cong>}) = card (set Fs\\<^sub>2)\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "have \"\\<dots> = length Fs\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set Fs\\<^sub>2) = length Fs\\<^sub>2", "by(simp add:distinct_card[OF dist2])"], ["proof (state)\nthis:\n  card (set Fs\\<^sub>2) = length Fs\\<^sub>2\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "finally"], ["proof (chain)\npicking this:\n  length Fs\\<^sub>1 = length Fs\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  length Fs\\<^sub>1 = length Fs\\<^sub>2\n\ngoal (1 subgoal):\n 1. length Fs\\<^sub>1 = length Fs\\<^sub>2", "."], ["proof (state)\nthis:\n  length Fs\\<^sub>1 = length Fs\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_Hom_distinct:\n \"\\<lbrakk> is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2; \\<forall>F\\<in>Fs\\<^sub>1. distinct F; \\<forall>F\\<in>Fs\\<^sub>2. distinct F \\<rbrakk>\n  \\<Longrightarrow> \\<forall>F\\<in>Fs\\<^sub>1. distinct(map \\<phi> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_pr_Hom \\<phi> Fs\\<^sub>1 Fs\\<^sub>2;\n     \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>Fs\\<^sub>2. distinct F\\<rbrakk>\n    \\<Longrightarrow> \\<forall>F\\<in>Fs\\<^sub>1. distinct (map \\<phi> F)", "apply(clarsimp simp add:is_pr_Hom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> distinct (map \\<phi> F)", "apply(subgoal_tac \"\\<exists> F' \\<in> Fs\\<^sub>2. (map \\<phi> F, F') : {\\<cong>}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        \\<exists>F'\\<in>Fs\\<^sub>2.\n           (map \\<phi> F, F') \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> distinct (map \\<phi> F)\n 2. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            (map \\<phi> F, F') \\<in> {\\<cong>}", "apply(fastforce simp add: congs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            (map \\<phi> F, F') \\<in> {\\<cong>}", "apply(subgoal_tac \"\\<exists> F' \\<in> Fs\\<^sub>2. {map \\<phi> F}//{\\<cong>} = {F'}//{\\<cong>}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        \\<exists>F'\\<in>Fs\\<^sub>2.\n           {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            (map \\<phi> F, F') \\<in> {\\<cong>}\n 2. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        F' \\<in> Fs\\<^sub>2;\n        {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            (map \\<phi> F, F') \\<in> {\\<cong>}\n 2. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}", "apply(rule_tac x = F' in bexI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        F' \\<in> Fs\\<^sub>2;\n        {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> (map \\<phi> F, F') \\<in> {\\<cong>}\n 2. \\<And>F F'.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        F' \\<in> Fs\\<^sub>2;\n        {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> F' \\<in> Fs\\<^sub>2\n 3. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}", "apply(rule eq_equiv_class[OF _ equiv_EqF])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        F' \\<in> Fs\\<^sub>2;\n        {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> {\\<cong>} `` {map \\<phi> F} = {\\<cong>} `` {F'}\n 2. \\<And>F F'.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        F' \\<in> Fs\\<^sub>2;\n        {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> F' \\<in> UNIV\n 3. \\<And>F F'.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        F' \\<in> Fs\\<^sub>2;\n        {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> F' \\<in> Fs\\<^sub>2\n 4. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}", "apply(simp add:singleton_quotient)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        F' \\<in> Fs\\<^sub>2;\n        {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> F' \\<in> UNIV\n 2. \\<And>F F'.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        F' \\<in> Fs\\<^sub>2;\n        {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> F' \\<in> Fs\\<^sub>2\n 3. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F F'.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        F' \\<in> Fs\\<^sub>2;\n        {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> F' \\<in> Fs\\<^sub>2\n 2. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>map \\<phi> ` Fs\\<^sub>1 // {\\<cong>} =\n                Fs\\<^sub>2 // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            {map \\<phi> F} // {\\<cong>} = {F'} // {\\<cong>}", "apply(simp add:quotient_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>(\\<Union>x\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> x}}) =\n                (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}});\n        \\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            {\\<cong>} `` {map \\<phi> F} = {\\<cong>} `` {F'}", "apply(rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>\\<forall>F\\<in>Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>Fs\\<^sub>2. distinct F; F \\<in> Fs\\<^sub>1;\n        (\\<Union>x\\<in>Fs\\<^sub>1. {{\\<cong>} `` {map \\<phi> x}}) =\n        (\\<Union>x\\<in>Fs\\<^sub>2. {{\\<cong>} `` {x}})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F'\\<in>Fs\\<^sub>2.\n                            {\\<cong>} `` {map \\<phi> F} = {\\<cong>} `` {F'}", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Collect_congs_eq_iff[simp]:\n  \"Collect ((\\<cong>) x) = Collect ((\\<cong>) y) \\<longleftrightarrow> (x \\<cong> (y::'a list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Collect ((\\<cong>) x) = Collect ((\\<cong>) y)) = x \\<cong> y", "using eq_equiv_class_iff2[OF equiv_EqF]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> UNIV; ?y \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> ({?x} // {\\<cong>} = {?y} // {\\<cong>}) =\n                    ((?x, ?y) \\<in> {\\<cong>})\n\ngoal (1 subgoal):\n 1. (Collect ((\\<cong>) x) = Collect ((\\<cong>) y)) = x \\<cong> y", "apply(simp add: quotient_def Iso_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        ({(x, y). x \\<cong> y} `` {x} = {(x, y). x \\<cong> y} `` {y}) =\n        x \\<cong> y) \\<Longrightarrow>\n    (Collect ((\\<cong>) x) = Collect ((\\<cong>) y)) = x \\<cong> y", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_pr_Hom_trans: assumes f: \"is_pr_Hom f A B\" and g: \"is_pr_Hom g B C\"\nshows \"is_pr_Hom (g \\<circ> f) A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pr_Hom (g \\<circ> f) A C", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_pr_Hom (g \\<circ> f) A C", "from f"], ["proof (chain)\npicking this:\n  is_pr_Hom f A B", "have f1: \"\\<forall>a\\<in>A. \\<exists>b\\<in>B. map f a \\<cong> b\""], ["proof (prove)\nusing this:\n  is_pr_Hom f A B\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>A. \\<exists>b\\<in>B. map f a \\<cong> b", "apply(simp add: is_pr_Hom_def quotient_def Iso_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>A. {{(x, y). x \\<cong> y} `` {map f x}}) =\n    (\\<Union>x\\<in>B. {{(x, y). x \\<cong> y} `` {x}}) \\<Longrightarrow>\n    \\<forall>a\\<in>A. \\<exists>b\\<in>B. map f a \\<cong> b", "apply(erule equalityE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Union>x\\<in>A. {{(x, y). x \\<cong> y} `` {map f x}})\n             \\<subseteq> (\\<Union>x\\<in>B. {{(x, y). x \\<cong> y} `` {x}});\n     (\\<Union>x\\<in>B. {{(x, y). x \\<cong> y} `` {x}})\n     \\<subseteq> (\\<Union>x\\<in>A.\n                     {{(x, y). x \\<cong> y} `` {map f x}})\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>A. \\<exists>b\\<in>B. map f a \\<cong> b", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>a\\<in>A. \\<exists>b\\<in>B. map f a \\<cong> b\n\ngoal (1 subgoal):\n 1. is_pr_Hom (g \\<circ> f) A C", "from f"], ["proof (chain)\npicking this:\n  is_pr_Hom f A B", "have f2: \"\\<forall>b\\<in>B. \\<exists>a\\<in>A. map f a \\<cong> b\""], ["proof (prove)\nusing this:\n  is_pr_Hom f A B\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>B. \\<exists>a\\<in>A. map f a \\<cong> b", "apply(simp add: is_pr_Hom_def quotient_def Iso_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>A. {{(x, y). x \\<cong> y} `` {map f x}}) =\n    (\\<Union>x\\<in>B. {{(x, y). x \\<cong> y} `` {x}}) \\<Longrightarrow>\n    \\<forall>b\\<in>B. \\<exists>a\\<in>A. map f a \\<cong> b", "apply(erule equalityE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Union>x\\<in>A. {{(x, y). x \\<cong> y} `` {map f x}})\n             \\<subseteq> (\\<Union>x\\<in>B. {{(x, y). x \\<cong> y} `` {x}});\n     (\\<Union>x\\<in>B. {{(x, y). x \\<cong> y} `` {x}})\n     \\<subseteq> (\\<Union>x\\<in>A.\n                     {{(x, y). x \\<cong> y} `` {map f x}})\\<rbrakk>\n    \\<Longrightarrow> \\<forall>b\\<in>B. \\<exists>a\\<in>A. map f a \\<cong> b", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>b\\<in>B. \\<exists>a\\<in>A. map f a \\<cong> b\n\ngoal (1 subgoal):\n 1. is_pr_Hom (g \\<circ> f) A C", "from g"], ["proof (chain)\npicking this:\n  is_pr_Hom g B C", "have g1: \"\\<forall>b\\<in>B. \\<exists>c\\<in>C. map g b \\<cong> c\""], ["proof (prove)\nusing this:\n  is_pr_Hom g B C\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>B. \\<exists>c\\<in>C. map g b \\<cong> c", "apply(simp add: is_pr_Hom_def quotient_def Iso_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>B. {{(x, y). x \\<cong> y} `` {map g x}}) =\n    (\\<Union>x\\<in>C. {{(x, y). x \\<cong> y} `` {x}}) \\<Longrightarrow>\n    \\<forall>b\\<in>B. \\<exists>c\\<in>C. map g b \\<cong> c", "apply(erule equalityE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Union>x\\<in>B. {{(x, y). x \\<cong> y} `` {map g x}})\n             \\<subseteq> (\\<Union>x\\<in>C. {{(x, y). x \\<cong> y} `` {x}});\n     (\\<Union>x\\<in>C. {{(x, y). x \\<cong> y} `` {x}})\n     \\<subseteq> (\\<Union>x\\<in>B.\n                     {{(x, y). x \\<cong> y} `` {map g x}})\\<rbrakk>\n    \\<Longrightarrow> \\<forall>b\\<in>B. \\<exists>c\\<in>C. map g b \\<cong> c", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>b\\<in>B. \\<exists>c\\<in>C. map g b \\<cong> c\n\ngoal (1 subgoal):\n 1. is_pr_Hom (g \\<circ> f) A C", "from g"], ["proof (chain)\npicking this:\n  is_pr_Hom g B C", "have g2: \"\\<forall>c\\<in>C. \\<exists>b\\<in>B. map g b \\<cong> c\""], ["proof (prove)\nusing this:\n  is_pr_Hom g B C\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>C. \\<exists>b\\<in>B. map g b \\<cong> c", "apply(simp add: is_pr_Hom_def quotient_def Iso_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>B. {{(x, y). x \\<cong> y} `` {map g x}}) =\n    (\\<Union>x\\<in>C. {{(x, y). x \\<cong> y} `` {x}}) \\<Longrightarrow>\n    \\<forall>c\\<in>C. \\<exists>b\\<in>B. map g b \\<cong> c", "apply(erule equalityE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Union>x\\<in>B. {{(x, y). x \\<cong> y} `` {map g x}})\n             \\<subseteq> (\\<Union>x\\<in>C. {{(x, y). x \\<cong> y} `` {x}});\n     (\\<Union>x\\<in>C. {{(x, y). x \\<cong> y} `` {x}})\n     \\<subseteq> (\\<Union>x\\<in>B.\n                     {{(x, y). x \\<cong> y} `` {map g x}})\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c\\<in>C. \\<exists>b\\<in>B. map g b \\<cong> c", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>c\\<in>C. \\<exists>b\\<in>B. map g b \\<cong> c\n\ngoal (1 subgoal):\n 1. is_pr_Hom (g \\<circ> f) A C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pr_Hom (g \\<circ> f) A C", "apply(auto simp add: is_pr_Hom_def quotient_def Iso_def Image_def\n      map_comp_map[symmetric] image_comp simp del: map_map map_comp_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> A \\<Longrightarrow>\n       \\<exists>x\\<in>C. map g (map f xa) \\<cong> x\n 2. \\<And>xa.\n       xa \\<in> C \\<Longrightarrow>\n       \\<exists>x\\<in>A. xa \\<cong> map g (map f x)", "apply (metis congs_map[of _ _ g] congs_trans f1 g1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> C \\<Longrightarrow>\n       \\<exists>x\\<in>A. xa \\<cong> map g (map f x)", "by (metis congs_map[of _ _ g] congs_sym congs_trans f2 g2)"], ["proof (state)\nthis:\n  is_pr_Hom (g \\<circ> f) A C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_pr_Hom_rev:\n  \"is_pr_Hom \\<phi> A B \\<Longrightarrow> is_pr_Hom \\<phi> (rev ` A) (rev ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pr_Hom \\<phi> A B \\<Longrightarrow>\n    is_pr_Hom \\<phi> (rev ` A) (rev ` B)", "apply(auto simp add: is_pr_Hom_def quotient_def Image_def Iso_def rev_map[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>(\\<Union>x\\<in>A. {Collect ((\\<cong>) (map \\<phi> x))}) =\n                (\\<Union>x\\<in>B. {Collect ((\\<cong>) x)});\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>B. map \\<phi> xa \\<cong> x\n 2. \\<And>xa.\n       \\<lbrakk>(\\<Union>x\\<in>A. {Collect ((\\<cong>) (map \\<phi> x))}) =\n                (\\<Union>x\\<in>B. {Collect ((\\<cong>) x)});\n        xa \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A. xa \\<cong> map \\<phi> x", "apply(erule equalityE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> A;\n        (\\<Union>x\\<in>A. {Collect ((\\<cong>) (map \\<phi> x))})\n        \\<subseteq> (\\<Union>x\\<in>B. {Collect ((\\<cong>) x)});\n        (\\<Union>x\\<in>B. {Collect ((\\<cong>) x)})\n        \\<subseteq> (\\<Union>x\\<in>A.\n                        {Collect ((\\<cong>) (map \\<phi> x))})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>B. map \\<phi> xa \\<cong> x\n 2. \\<And>xa.\n       \\<lbrakk>(\\<Union>x\\<in>A. {Collect ((\\<cong>) (map \\<phi> x))}) =\n                (\\<Union>x\\<in>B. {Collect ((\\<cong>) x)});\n        xa \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A. xa \\<cong> map \\<phi> x", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>(\\<Union>x\\<in>A. {Collect ((\\<cong>) (map \\<phi> x))}) =\n                (\\<Union>x\\<in>B. {Collect ((\\<cong>) x)});\n        xa \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A. xa \\<cong> map \\<phi> x", "apply(erule equalityE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> B;\n        (\\<Union>x\\<in>A. {Collect ((\\<cong>) (map \\<phi> x))})\n        \\<subseteq> (\\<Union>x\\<in>B. {Collect ((\\<cong>) x)});\n        (\\<Union>x\\<in>B. {Collect ((\\<cong>) x)})\n        \\<subseteq> (\\<Union>x\\<in>A.\n                        {Collect ((\\<cong>) (map \\<phi> x))})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A. xa \\<cong> map \\<phi> x", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>A kind of recursion rule, a first step towards executability:\\<close>"], ["", "lemma is_pr_Iso_rec:\n \"\\<lbrakk> inj_on (\\<lambda>xs. {xs}//{\\<cong>}) Fs\\<^sub>1; inj_on (\\<lambda>xs. {xs}//{\\<cong>}) Fs\\<^sub>2; F\\<^sub>1 \\<in> Fs\\<^sub>1 \\<rbrakk> \\<Longrightarrow>\n is_pr_Iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 =\n (\\<exists>F\\<^sub>2 \\<in> Fs\\<^sub>2. length F\\<^sub>1 = length F\\<^sub>2 \\<and> is_pr_Iso \\<phi> (Fs\\<^sub>1 - {F\\<^sub>1}) (Fs\\<^sub>2 - {F\\<^sub>2})\n    \\<and> (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n    \\<and> inj_on \\<phi> (\\<Union>F\\<in>Fs\\<^sub>1. set F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n     F\\<^sub>1 \\<in> Fs\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> is_pr_Iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 =\n                      (\\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                          length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                          is_pr_Iso \\<phi> (Fs\\<^sub>1 - {F\\<^sub>1})\n                           (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n                          (\\<exists>n.\n                              map \\<phi> F\\<^sub>1 =\n                              rotate n F\\<^sub>2) \\<and>\n                          inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1)))", "apply(drule mk_disjoint_insert[of F\\<^sub>1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n     \\<exists>B.\n        Fs\\<^sub>1 = insert F\\<^sub>1 B \\<and> F\\<^sub>1 \\<notin> B\\<rbrakk>\n    \\<Longrightarrow> is_pr_Iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 =\n                      (\\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                          length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                          is_pr_Iso \\<phi> (Fs\\<^sub>1 - {F\\<^sub>1})\n                           (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n                          (\\<exists>n.\n                              map \\<phi> F\\<^sub>1 =\n                              rotate n F\\<^sub>2) \\<and>\n                          inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1)))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> B; Fs\\<^sub>1 = insert F\\<^sub>1 B;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) B;\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (B - {F\\<^sub>1})\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 B) Fs\\<^sub>2 =\n                         (\\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                             length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                             is_pr_Iso \\<phi>\n                              (insert F\\<^sub>1 B - {F\\<^sub>1})\n                              (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n                             (\\<exists>n.\n                                 map \\<phi> F\\<^sub>1 =\n                                 rotate n F\\<^sub>2) \\<and>\n                             inj_on \\<phi>\n                              (\\<Union> (set ` insert F\\<^sub>1 B)))", "apply(rename_tac Fs\\<^sub>1')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1})\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2 =\n                         (\\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                             length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                             is_pr_Iso \\<phi>\n                              (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n                              (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n                             (\\<exists>n.\n                                 map \\<phi> F\\<^sub>1 =\n                                 rotate n F\\<^sub>2) \\<and>\n                             inj_on \\<phi>\n                              (\\<Union>\n                                (set ` insert F\\<^sub>1 Fs\\<^sub>1')))", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1') Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            is_pr_Iso \\<phi>\n                             (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n                             (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 =\n                                rotate n F\\<^sub>2) \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply (clarsimp simp add:is_pr_Iso_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        is_pr_Hom \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1') Fs\\<^sub>2;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            is_pr_Hom \\<phi> Fs\\<^sub>1'\n                             (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(clarsimp simp:is_pr_Hom_def quotient_diff1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>};\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                            Fs\\<^sub>2 // {\\<cong>} -\n                            {F\\<^sub>2} // {\\<cong>} \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(drule_tac s=\"a // b\" for a b in sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                            Fs\\<^sub>2 // {\\<cong>} -\n                            {F\\<^sub>2} // {\\<cong>} \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                            insert (map \\<phi> F\\<^sub>1)\n                             (map \\<phi> ` Fs\\<^sub>1') //\n                            {\\<cong>} -\n                            {F\\<^sub>2} // {\\<cong>} \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(subgoal_tac \"{\\<cong>} `` {map \\<phi> F\\<^sub>1} : Fs\\<^sub>2 // {\\<cong>}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1}\n        \\<in> Fs\\<^sub>2 // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                            insert (map \\<phi> F\\<^sub>1)\n                             (map \\<phi> ` Fs\\<^sub>1') //\n                            {\\<cong>} -\n                            {F\\<^sub>2} // {\\<cong>} \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> {\\<cong>} `` {map \\<phi> F\\<^sub>1}\n                         \\<in> Fs\\<^sub>2 // {\\<cong>}\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> {\\<cong>} `` {map \\<phi> F\\<^sub>1}\n                         \\<in> Fs\\<^sub>2 // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1}\n        \\<in> Fs\\<^sub>2 // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                            insert (map \\<phi> F\\<^sub>1)\n                             (map \\<phi> ` Fs\\<^sub>1') //\n                            {\\<cong>} -\n                            {F\\<^sub>2} // {\\<cong>} \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(simp add:quotient_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1}\n        \\<in> Fs\\<^sub>2 // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                            insert (map \\<phi> F\\<^sub>1)\n                             (map \\<phi> ` Fs\\<^sub>1') //\n                            {\\<cong>} -\n                            {F\\<^sub>2} // {\\<cong>} \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(erule quotientE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' x.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1} = {\\<cong>} `` {x};\n        x \\<in> Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                            insert (map \\<phi> F\\<^sub>1)\n                             (map \\<phi> ` Fs\\<^sub>1') //\n                            {\\<cong>} -\n                            {F\\<^sub>2} // {\\<cong>} \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(rename_tac F\\<^sub>2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1} = {\\<cong>} `` {F\\<^sub>2};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                            insert (map \\<phi> F\\<^sub>1)\n                             (map \\<phi> ` Fs\\<^sub>1') //\n                            {\\<cong>} -\n                            {F\\<^sub>2} // {\\<cong>} \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(drule eq_equiv_class[OF _ equiv_EqF])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<in> UNIV\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                            insert (map \\<phi> F\\<^sub>1)\n                             (map \\<phi> ` Fs\\<^sub>1') //\n                            {\\<cong>} -\n                            {F\\<^sub>2} // {\\<cong>} \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                            insert (map \\<phi> F\\<^sub>1)\n                             (map \\<phi> ` Fs\\<^sub>1') //\n                            {\\<cong>} -\n                            {F\\<^sub>2} // {\\<cong>} \\<and>\n                            inj_on \\<phi>\n                             (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(rule_tac x = F\\<^sub>2 in bexI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                         map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>} \\<and>\n                         inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<in> Fs\\<^sub>2\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<in> Fs\\<^sub>2\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                         map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>} \\<and>\n                         inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                         map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>} \\<and>\n                         inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>1 = length F\\<^sub>2\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>} \\<and>\n                         inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(clarsimp simp: congs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>} \\<and>\n                         inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(subgoal_tac \"{\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1}\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} =\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1}\\<rbrakk>\n       \\<Longrightarrow> map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> {\\<cong>} `` {F\\<^sub>2} =\n                         {\\<cong>} `` {map \\<phi> F\\<^sub>1}\n 3. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 4. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> {\\<cong>} `` {F\\<^sub>2} =\n                         {\\<cong>} `` {map \\<phi> F\\<^sub>1}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} =\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1}\\<rbrakk>\n       \\<Longrightarrow> map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>}\n 3. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 4. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(rule equiv_class_eq[OF equiv_EqF])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> (F\\<^sub>2, map \\<phi> F\\<^sub>1) \\<in> {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} =\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1}\\<rbrakk>\n       \\<Longrightarrow> map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>}\n 3. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 4. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(fastforce intro: congs_sym)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} =\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1}\\<rbrakk>\n       \\<Longrightarrow> map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(subgoal_tac \"{F\\<^sub>2}//{\\<cong>} = {map \\<phi> F\\<^sub>1}//{\\<cong>}\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} =\n        {map \\<phi> F\\<^sub>1} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} =\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1}\\<rbrakk>\n       \\<Longrightarrow> {F\\<^sub>2} // {\\<cong>} =\n                         {map \\<phi> F\\<^sub>1} // {\\<cong>}\n 3. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 4. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} =\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1}\\<rbrakk>\n       \\<Longrightarrow> {F\\<^sub>2} // {\\<cong>} =\n                         {map \\<phi> F\\<^sub>1} // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} =\n        {map \\<phi> F\\<^sub>1} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>}\n 3. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 4. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(simp add:singleton_quotient)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} =\n        {map \\<phi> F\\<^sub>1} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(subgoal_tac \"\\<forall>F\\<in>Fs\\<^sub>1'. \\<not> (map \\<phi> F) \\<cong> (map \\<phi> F\\<^sub>1)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} = {map \\<phi> F\\<^sub>1} // {\\<cong>};\n        \\<forall>F\\<in>Fs\\<^sub>1'.\n           \\<not> map \\<phi> F \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n                         insert (map \\<phi> F\\<^sub>1)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} -\n                         {F\\<^sub>2} // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} =\n        {map \\<phi> F\\<^sub>1} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>F\\<in>Fs\\<^sub>1'.\n                            \\<not> map \\<phi> F \\<cong> map \\<phi> F\\<^sub>1\n 3. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 4. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(fastforce simp:Iso_def quotient_def Image_Collect_case_prod simp del: Collect_congs_eq_iff\n                 dest!: eq_equiv_class[OF _ equiv_EqF])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} =\n        {map \\<phi> F\\<^sub>1} // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>F\\<in>Fs\\<^sub>1'.\n                            \\<not> map \\<phi> F \\<cong> map \\<phi> F\\<^sub>1\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} = {map \\<phi> F\\<^sub>1} // {\\<cong>};\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        map \\<phi> F \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(subgoal_tac \"inj_on \\<phi> (set F \\<union> set F\\<^sub>1)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} = {map \\<phi> F\\<^sub>1} // {\\<cong>};\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        map \\<phi> F \\<cong> map \\<phi> F\\<^sub>1;\n        inj_on \\<phi> (set F \\<union> set F\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} = {map \\<phi> F\\<^sub>1} // {\\<cong>};\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        map \\<phi> F \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (set F \\<union> set F\\<^sub>1)\n 3. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 4. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} = {map \\<phi> F\\<^sub>1} // {\\<cong>};\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        map \\<phi> F \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (set F \\<union> set F\\<^sub>1)\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} = {map \\<phi> F\\<^sub>1} // {\\<cong>};\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        map \\<phi> F \\<cong> map \\<phi> F\\<^sub>1;\n        inj_on \\<phi> (set F \\<union> set F\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 4. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(erule subset_inj_on)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} = {map \\<phi> F\\<^sub>1} // {\\<cong>};\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        map \\<phi> F \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> set F \\<union> set F\\<^sub>1\n                         \\<subseteq> set F\\<^sub>1 \\<union>\n                                     \\<Union> (set ` Fs\\<^sub>1')\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} = {map \\<phi> F\\<^sub>1} // {\\<cong>};\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        map \\<phi> F \\<cong> map \\<phi> F\\<^sub>1;\n        inj_on \\<phi> (set F \\<union> set F\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 4. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        {F\\<^sub>2} // {\\<cong>} = {map \\<phi> F\\<^sub>1} // {\\<cong>};\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        map \\<phi> F \\<cong> map \\<phi> F\\<^sub>1;\n        inj_on \\<phi> (set F \\<union> set F\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(clarsimp simp add:congs_map_eq_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        F \\<cong> F\\<^sub>1;\n        inj_on \\<phi> (set F \\<union> set F\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(subgoal_tac \"{\\<cong>} `` {F\\<^sub>1} = {\\<cong>} `` {F}\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        F \\<cong> F\\<^sub>1; inj_on \\<phi> (set F \\<union> set F\\<^sub>1);\n        {\\<cong>} `` {F\\<^sub>1} = {\\<cong>} `` {F}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        F \\<cong> F\\<^sub>1;\n        inj_on \\<phi> (set F \\<union> set F\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> {\\<cong>} `` {F\\<^sub>1} = {\\<cong>} `` {F}\n 3. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 4. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(simp add:singleton_quotient)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        F \\<cong> F\\<^sub>1;\n        inj_on \\<phi> (set F \\<union> set F\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> {\\<cong>} `` {F\\<^sub>1} = {\\<cong>} `` {F}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(rule equiv_class_eq[OF equiv_EqF])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 F.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        {\\<cong>} `` {F\\<^sub>2} = {\\<cong>} `` {map \\<phi> F\\<^sub>1};\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        map \\<phi> F\\<^sub>1 \\<cong> F\\<^sub>2; F \\<in> Fs\\<^sub>1';\n        F \\<cong> F\\<^sub>1;\n        inj_on \\<phi> (set F \\<union> set F\\<^sub>1)\\<rbrakk>\n       \\<Longrightarrow> (F\\<^sub>1, F) \\<in> {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(blast intro:congs_sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(subgoal_tac \"F\\<^sub>2 \\<cong> (map \\<phi> F\\<^sub>1)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>};\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1')) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1\n 3. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply (simp add:congs_def inj_on_Un)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        Fs\\<^sub>2 // {\\<cong>} =\n        insert (map \\<phi> F\\<^sub>1) (map \\<phi> ` Fs\\<^sub>1') //\n        {\\<cong>};\n        F\\<^sub>2 \\<in> Fs\\<^sub>2;\n        (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1\n 2. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(clarsimp intro!:congs_sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fs\\<^sub>1'.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>xs. {xs} // {\\<cong>}) `\n                 (Fs\\<^sub>1' - {F\\<^sub>1});\n        \\<exists>F\\<^sub>2\\<in>Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1' - {F\\<^sub>1})\n            (Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n           (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n           inj_on \\<phi>\n            (\\<Union> (set ` insert F\\<^sub>1 Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 Fs\\<^sub>1')\n                          Fs\\<^sub>2", "apply(clarsimp simp add: is_pr_Iso_def is_pr_Hom_def quotient_diff1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) Fs\\<^sub>1';\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {F\\<^sub>2} // {\\<cong>};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}", "apply (simp add:singleton_quotient)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}", "apply(subgoal_tac \"F\\<^sub>2 \\<cong> (map \\<phi> F\\<^sub>1)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}", "apply(fastforce simp add:congs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}", "apply(subgoal_tac \"{\\<cong>}``{map \\<phi> F\\<^sub>1} = {\\<cong>}``{F\\<^sub>2}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1} =\n        {\\<cong>} `` {F\\<^sub>2}\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> {\\<cong>} `` {map \\<phi> F\\<^sub>1} =\n                         {\\<cong>} `` {F\\<^sub>2}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> {\\<cong>} `` {map \\<phi> F\\<^sub>1} =\n                         {\\<cong>} `` {F\\<^sub>2}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1} =\n        {\\<cong>} `` {F\\<^sub>2}\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}", "apply(rule equiv_class_eq[OF equiv_EqF])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (map \\<phi> F\\<^sub>1, F\\<^sub>2) \\<in> {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1} =\n        {\\<cong>} `` {F\\<^sub>2}\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}", "apply(fastforce intro:congs_sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1} =\n        {\\<cong>} `` {F\\<^sub>2}\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}", "apply(subgoal_tac \"{\\<cong>}``{F\\<^sub>2} \\<in> Fs\\<^sub>2 // {\\<cong>}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1} = {\\<cong>} `` {F\\<^sub>2};\n        {\\<cong>} `` {F\\<^sub>2} \\<in> Fs\\<^sub>2 // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1} =\n        {\\<cong>} `` {F\\<^sub>2}\\<rbrakk>\n       \\<Longrightarrow> {\\<cong>} `` {F\\<^sub>2}\n                         \\<in> Fs\\<^sub>2 // {\\<cong>}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1} =\n        {\\<cong>} `` {F\\<^sub>2}\\<rbrakk>\n       \\<Longrightarrow> {\\<cong>} `` {F\\<^sub>2}\n                         \\<in> Fs\\<^sub>2 // {\\<cong>}\n 2. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1} = {\\<cong>} `` {F\\<^sub>2};\n        {\\<cong>} `` {F\\<^sub>2} \\<in> Fs\\<^sub>2 // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}", "apply(erule quotientI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fs\\<^sub>1' F\\<^sub>2 n.\n       \\<lbrakk>inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>2;\n        F\\<^sub>1 \\<notin> Fs\\<^sub>1';\n        Fs\\<^sub>1 = insert F\\<^sub>1 Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {{\\<cong>} `` {xs}}) Fs\\<^sub>1';\n        {{\\<cong>} `` {F\\<^sub>1}}\n        \\<notin> (\\<lambda>x. {{\\<cong>} `` {x}}) ` Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        map \\<phi> ` Fs\\<^sub>1' // {\\<cong>} =\n        Fs\\<^sub>2 // {\\<cong>} - {{\\<cong>} `` {F\\<^sub>2}};\n        inj_on \\<phi> (\\<Union> (set ` Fs\\<^sub>1'));\n        inj_on \\<phi> (set F\\<^sub>1 \\<union> \\<Union> (set ` Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        F\\<^sub>2 \\<cong> map \\<phi> F\\<^sub>1;\n        {\\<cong>} `` {map \\<phi> F\\<^sub>1} = {\\<cong>} `` {F\\<^sub>2};\n        {\\<cong>} `` {F\\<^sub>2} \\<in> Fs\\<^sub>2 // {\\<cong>}\\<rbrakk>\n       \\<Longrightarrow> insert (rotate n F\\<^sub>2)\n                          (map \\<phi> ` Fs\\<^sub>1') //\n                         {\\<cong>} =\n                         Fs\\<^sub>2 // {\\<cong>}", "apply (simp add:insert_absorb quotient_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_iso_Cons:\n \"\\<lbrakk> distinct (F\\<^sub>1#Fs\\<^sub>1'); distinct Fs\\<^sub>2;\n    inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set(F\\<^sub>1#Fs\\<^sub>1')); inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2) \\<rbrakk>\n  \\<Longrightarrow>\n is_pr_iso \\<phi> (F\\<^sub>1#Fs\\<^sub>1') Fs\\<^sub>2 =\n (\\<exists>F\\<^sub>2 \\<in> set Fs\\<^sub>2. length F\\<^sub>1 = length F\\<^sub>2 \\<and> is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2)\n    \\<and> (\\<exists>n. map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2)\n    \\<and> inj_on \\<phi> (set F\\<^sub>1 \\<union> (\\<Union>F\\<in>set Fs\\<^sub>1'. set F)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (F\\<^sub>1 # Fs\\<^sub>1'); distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n      (set (F\\<^sub>1 # Fs\\<^sub>1'));\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> is_pr_iso \\<phi> (F\\<^sub>1 # Fs\\<^sub>1')\n                       Fs\\<^sub>2 =\n                      (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                          length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                          is_pr_iso \\<phi> Fs\\<^sub>1'\n                           (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                          (\\<exists>n.\n                              map \\<phi> F\\<^sub>1 =\n                              rotate n F\\<^sub>2) \\<and>\n                          inj_on \\<phi>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))", "apply(simp add:is_pr_iso_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F\\<^sub>1 \\<notin> set Fs\\<^sub>1' \\<and> distinct Fs\\<^sub>1';\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1') \\<and>\n     {F\\<^sub>1} // {\\<cong>}\n     \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> is_pr_Iso \\<phi> (insert F\\<^sub>1 (set Fs\\<^sub>1'))\n                       (set Fs\\<^sub>2) =\n                      (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                          length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                          is_pr_Iso \\<phi> (set Fs\\<^sub>1')\n                           (set Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n                          (\\<exists>n.\n                              map \\<phi> F\\<^sub>1 =\n                              rotate n F\\<^sub>2) \\<and>\n                          inj_on \\<phi>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))", "apply(subst is_pr_Iso_rec[where ?F\\<^sub>1.0 = F\\<^sub>1])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>F\\<^sub>1 \\<notin> set Fs\\<^sub>1' \\<and> distinct Fs\\<^sub>1';\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1') \\<and>\n     {F\\<^sub>1} // {\\<cong>}\n     \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (insert F\\<^sub>1 (set Fs\\<^sub>1'))\n 2. \\<lbrakk>F\\<^sub>1 \\<notin> set Fs\\<^sub>1' \\<and> distinct Fs\\<^sub>1';\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1') \\<and>\n     {F\\<^sub>1} // {\\<cong>}\n     \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set Fs\\<^sub>2)\n 3. \\<lbrakk>F\\<^sub>1 \\<notin> set Fs\\<^sub>1' \\<and> distinct Fs\\<^sub>1';\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1') \\<and>\n     {F\\<^sub>1} // {\\<cong>}\n     \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> F\\<^sub>1 \\<in> insert F\\<^sub>1 (set Fs\\<^sub>1')\n 4. \\<lbrakk>F\\<^sub>1 \\<notin> set Fs\\<^sub>1' \\<and> distinct Fs\\<^sub>1';\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1') \\<and>\n     {F\\<^sub>1} // {\\<cong>}\n     \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                          length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                          is_pr_Iso \\<phi>\n                           (insert F\\<^sub>1 (set Fs\\<^sub>1') -\n                            {F\\<^sub>1})\n                           (set Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n                          (\\<exists>n.\n                              map \\<phi> F\\<^sub>1 =\n                              rotate n F\\<^sub>2) \\<and>\n                          inj_on \\<phi>\n                           (\\<Union>\n                             (set ` insert F\\<^sub>1 (set Fs\\<^sub>1')))) =\n                      (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                          length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                          is_pr_Iso \\<phi> (set Fs\\<^sub>1')\n                           (set Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n                          (\\<exists>n.\n                              map \\<phi> F\\<^sub>1 =\n                              rotate n F\\<^sub>2) \\<and>\n                          inj_on \\<phi>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Isomorphism tests\\<close>"], ["", "lemma map_upd_submap:\n  \"x \\<notin> dom m \\<Longrightarrow> (m(x \\<mapsto> y) \\<subseteq>\\<^sub>m m') = (m' x = Some y \\<and> m \\<subseteq>\\<^sub>m m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom m \\<Longrightarrow>\n    (m(x \\<mapsto> y) \\<subseteq>\\<^sub>m m') =\n    (m' x = Some y \\<and> m \\<subseteq>\\<^sub>m m')", "apply(simp add:map_le_def dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m x = None \\<Longrightarrow>\n    (\\<forall>a.\n        (a = x \\<longrightarrow> Some y = m' x) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a)) =\n    (m' x = Some y \\<and>\n     (\\<forall>a. (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a))", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m x = None;\n     \\<forall>a.\n        (a = x \\<longrightarrow> Some y = m' x) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a)\\<rbrakk>\n    \\<Longrightarrow> m' x = Some y \\<and>\n                      (\\<forall>a.\n                          (\\<exists>y. m a = Some y) \\<longrightarrow>\n                          m a = m' a)\n 2. \\<lbrakk>m x = None;\n     m' x = Some y \\<and>\n     (\\<forall>a.\n         (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a.\n                         (a = x \\<longrightarrow> Some y = m' x) \\<and>\n                         (a \\<noteq> x \\<longrightarrow>\n                          (\\<exists>y. m a = Some y) \\<longrightarrow>\n                          m a = m' a)", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>m x = None;\n     \\<forall>a.\n        (a = x \\<longrightarrow> Some y = m' x) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a)\\<rbrakk>\n    \\<Longrightarrow> m' x = Some y\n 2. \\<lbrakk>m x = None;\n     \\<forall>a.\n        (a = x \\<longrightarrow> Some y = m' x) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a.\n                         (\\<exists>y. m a = Some y) \\<longrightarrow>\n                         m a = m' a\n 3. \\<lbrakk>m x = None;\n     m' x = Some y \\<and>\n     (\\<forall>a.\n         (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a.\n                         (a = x \\<longrightarrow> Some y = m' x) \\<and>\n                         (a \\<noteq> x \\<longrightarrow>\n                          (\\<exists>y. m a = Some y) \\<longrightarrow>\n                          m a = m' a)", "apply (blast intro:sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m x = None;\n     \\<forall>a.\n        (a = x \\<longrightarrow> Some y = m' x) \\<and>\n        (a \\<noteq> x \\<longrightarrow>\n         (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a.\n                         (\\<exists>y. m a = Some y) \\<longrightarrow>\n                         m a = m' a\n 2. \\<lbrakk>m x = None;\n     m' x = Some y \\<and>\n     (\\<forall>a.\n         (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a.\n                         (a = x \\<longrightarrow> Some y = m' x) \\<and>\n                         (a \\<noteq> x \\<longrightarrow>\n                          (\\<exists>y. m a = Some y) \\<longrightarrow>\n                          m a = m' a)", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ya.\n       \\<lbrakk>m x = None;\n        \\<forall>a.\n           (a = x \\<longrightarrow> Some y = m' x) \\<and>\n           (a \\<noteq> x \\<longrightarrow>\n            (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a);\n        m a = Some ya\\<rbrakk>\n       \\<Longrightarrow> m a = m' a\n 2. \\<lbrakk>m x = None;\n     m' x = Some y \\<and>\n     (\\<forall>a.\n         (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a.\n                         (a = x \\<longrightarrow> Some y = m' x) \\<and>\n                         (a \\<noteq> x \\<longrightarrow>\n                          (\\<exists>y. m a = Some y) \\<longrightarrow>\n                          m a = m' a)", "apply(case_tac \"a=x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ya.\n       \\<lbrakk>m x = None;\n        \\<forall>a.\n           (a = x \\<longrightarrow> Some y = m' x) \\<and>\n           (a \\<noteq> x \\<longrightarrow>\n            (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a);\n        m a = Some ya; a = x\\<rbrakk>\n       \\<Longrightarrow> m a = m' a\n 2. \\<And>a ya.\n       \\<lbrakk>m x = None;\n        \\<forall>a.\n           (a = x \\<longrightarrow> Some y = m' x) \\<and>\n           (a \\<noteq> x \\<longrightarrow>\n            (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a);\n        m a = Some ya; a \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> m a = m' a\n 3. \\<lbrakk>m x = None;\n     m' x = Some y \\<and>\n     (\\<forall>a.\n         (\\<exists>y. m a = Some y) \\<longrightarrow> m a = m' a)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a.\n                         (a = x \\<longrightarrow> Some y = m' x) \\<and>\n                         (a \\<noteq> x \\<longrightarrow>\n                          (\\<exists>y. m a = Some y) \\<longrightarrow>\n                          m a = m' a)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_zip_submap: \"\\<lbrakk> length xs = length ys; distinct xs \\<rbrakk> \\<Longrightarrow>\n (map_of (zip xs ys) \\<subseteq>\\<^sub>m Some \\<circ> f) = (map f xs = ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; distinct xs\\<rbrakk>\n    \\<Longrightarrow> (map_of (zip xs ys) \\<subseteq>\\<^sub>m\n                       Some \\<circ> f) =\n                      (map f xs = ys)", "apply(induct rule: list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    (map_of (zip [] []) \\<subseteq>\\<^sub>m Some \\<circ> f) =\n    (map f [] = [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        distinct xs \\<Longrightarrow>\n        (map_of (zip xs ys) \\<subseteq>\\<^sub>m Some \\<circ> f) =\n        (map f xs = ys);\n        distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> (map_of (zip (x # xs) (y # ys)) \\<subseteq>\\<^sub>m\n                          Some \\<circ> f) =\n                         (map f (x # xs) = y # ys)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        distinct xs \\<Longrightarrow>\n        (map_of (zip xs ys) \\<subseteq>\\<^sub>m Some \\<circ> f) =\n        (map f xs = ys);\n        distinct (x # xs)\\<rbrakk>\n       \\<Longrightarrow> (map_of (zip (x # xs) (y # ys)) \\<subseteq>\\<^sub>m\n                          Some \\<circ> f) =\n                         (map f (x # xs) = y # ys)", "apply (clarsimp simp: map_upd_submap simp del:o_apply fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        (map_of (zip xs ys) \\<subseteq>\\<^sub>m Some \\<circ> f) =\n        (map f xs = ys);\n        x \\<notin> set xs; distinct xs\\<rbrakk>\n       \\<Longrightarrow> ((Some \\<circ> f) x = Some y \\<and>\n                          map f xs = ys) =\n                         (f x = y \\<and> map f xs = ys)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec pr_iso_test0 :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> 'a fgraph \\<Rightarrow> 'b fgraph \\<Rightarrow> bool\" where\n  \"pr_iso_test0 m [] Fs\\<^sub>2 = (Fs\\<^sub>2 = [])\"\n| \"pr_iso_test0 m (F\\<^sub>1#Fs\\<^sub>1) Fs\\<^sub>2 =\n   (\\<exists>F\\<^sub>2 \\<in> set Fs\\<^sub>2. length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n      (\\<exists>n. let m' = map_of(zip F\\<^sub>1 (rotate n F\\<^sub>2)) in\n          if m \\<subseteq>\\<^sub>m m ++ m' \\<and> inj_on (m++m') (dom(m++m'))\n          then pr_iso_test0 (m ++ m') Fs\\<^sub>1 (remove1 F\\<^sub>2 Fs\\<^sub>2) else False))\""], ["", "lemma map_compatI: \"\\<lbrakk> f \\<subseteq>\\<^sub>m Some \\<circ> h; g \\<subseteq>\\<^sub>m Some \\<circ> h \\<rbrakk> \\<Longrightarrow> f \\<subseteq>\\<^sub>m f++g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<subseteq>\\<^sub>m Some \\<circ> h;\n     g \\<subseteq>\\<^sub>m Some \\<circ> h\\<rbrakk>\n    \\<Longrightarrow> f \\<subseteq>\\<^sub>m f ++ g", "by (fastforce simp add: map_le_def map_add_def dom_def split:option.splits)"], ["", "lemma inj_on_map_addI1:\n \"\\<lbrakk> inj_on m A; m \\<subseteq>\\<^sub>m m++m'; A \\<subseteq> dom m \\<rbrakk> \\<Longrightarrow> inj_on (m++m') A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m A; m \\<subseteq>\\<^sub>m m ++ m';\n     A \\<subseteq> dom m\\<rbrakk>\n    \\<Longrightarrow> inj_on (m ++ m') A", "apply (clarsimp simp add: inj_on_def map_add_def map_le_def dom_def\n                split:option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (m' x = None \\<longrightarrow>\n                          (\\<forall>y\\<in>A.\n                              \\<forall>x2.\n                                 m' y = Some x2 \\<longrightarrow>\n                                 m x = Some x2 \\<longrightarrow>\n                                 x = y)) \\<and>\n                         (\\<forall>x2.\n                             m' x = Some x2 \\<longrightarrow>\n                             (\\<forall>y\\<in>A.\n                                 (m' y = None \\<longrightarrow>\n                                  Some x2 = m y \\<longrightarrow>\n                                  x = y) \\<and>\n                                 (m' y = Some x2 \\<longrightarrow> x = y)))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> m' x = None \\<longrightarrow>\n                         (\\<forall>y\\<in>A.\n                             \\<forall>x2.\n                                m' y = Some x2 \\<longrightarrow>\n                                m x = Some x2 \\<longrightarrow> x = y)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x2.\n                            m' x = Some x2 \\<longrightarrow>\n                            (\\<forall>y\\<in>A.\n                                (m' y = None \\<longrightarrow>\n                                 Some x2 = m y \\<longrightarrow>\n                                 x = y) \\<and>\n                                (m' y = Some x2 \\<longrightarrow> x = y))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x2.\n                            m' x = Some x2 \\<longrightarrow>\n                            (\\<forall>y\\<in>A.\n                                (m' y = None \\<longrightarrow>\n                                 Some x2 = m y \\<longrightarrow>\n                                 x = y) \\<and>\n                                (m' y = Some x2 \\<longrightarrow> x = y))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x2 y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = m y; y \\<in> A; m' y = None;\n        Some x2 = m y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x x2 y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some x2; y \\<in> A; m' y = Some x2\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x2 y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some x2; y \\<in> A; m' y = Some x2\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (rename_tac x a y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(subgoal_tac \"m x = Some a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a;\n        m x = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a\\<rbrakk>\n       \\<Longrightarrow> m x = Some a", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a\\<rbrakk>\n       \\<Longrightarrow> m x = Some a\n 2. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a;\n        m x = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a;\n        m x = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(subgoal_tac \"m y = Some a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a; m x = Some a;\n        m y = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a;\n        m x = Some a\\<rbrakk>\n       \\<Longrightarrow> m y = Some a", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a;\n        m x = Some a\\<rbrakk>\n       \\<Longrightarrow> m y = Some a\n 2. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a; m x = Some a;\n        m y = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a; m x = Some a;\n        m y = Some a\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(subgoal_tac \"m x = m y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a; m x = Some a;\n        m y = Some a; m x = m y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a; m x = Some a;\n        m y = Some a\\<rbrakk>\n       \\<Longrightarrow> m x = m y", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a; m x = Some a;\n        m y = Some a\\<rbrakk>\n       \\<Longrightarrow> m x = m y\n 2. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a; m x = Some a;\n        m y = Some a; m x = m y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a y.\n       \\<lbrakk>\\<forall>a x2.\n                   m' a = Some x2 \\<longrightarrow>\n                   m a = None \\<or> m a = Some x2;\n        A \\<subseteq> {a. \\<exists>y. m a = Some y};\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. m x = m y \\<longrightarrow> x = y;\n        x \\<in> A; m' x = Some a; y \\<in> A; m' y = Some a; m x = Some a;\n        m y = Some a; m x = m y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_image_eq: \"\\<lbrakk> A \\<subseteq> dom m; m \\<subseteq>\\<^sub>m m' \\<rbrakk> \\<Longrightarrow> m ` A = m' ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> dom m; m \\<subseteq>\\<^sub>m m'\\<rbrakk>\n    \\<Longrightarrow> m ` A = m' ` A", "by(force simp:map_le_def dom_def split:option.splits)"], ["", "lemma inj_on_map_add_Un:\n \"\\<lbrakk> inj_on m (dom m); inj_on m' (dom m'); m \\<subseteq>\\<^sub>m Some \\<circ> f; m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n    inj_on f (dom m' \\<union> dom m); A = dom m'; B = dom m \\<rbrakk>\n  \\<Longrightarrow> inj_on (m ++ m') (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     inj_on f (dom m' \\<union> dom m); A = dom m'; B = dom m\\<rbrakk>\n    \\<Longrightarrow> inj_on (m ++ m') (A \\<union> B)", "apply(simp add:inj_on_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     inj_on f (dom m') \\<and>\n     inj_on f (dom m) \\<and>\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     A = dom m'; B = dom m\\<rbrakk>\n    \\<Longrightarrow> inj_on (m ++ m') (dom m) \\<and>\n                      m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     inj_on f (dom m') \\<and>\n     inj_on f (dom m) \\<and>\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     A = dom m'; B = dom m\\<rbrakk>\n    \\<Longrightarrow> inj_on (m ++ m') (dom m)\n 2. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     inj_on f (dom m') \\<and>\n     inj_on f (dom m) \\<and>\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     A = dom m'; B = dom m\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply(fastforce intro!: inj_on_map_addI1 map_compatI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     inj_on f (dom m') \\<and>\n     inj_on f (dom m) \\<and>\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     A = dom m'; B = dom m\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {}\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply(subgoal_tac \"m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}\n 2. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {}\\<rbrakk>\n    \\<Longrightarrow> m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {}\\<rbrakk>\n    \\<Longrightarrow> m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\n 2. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply(fast intro:map_add_le_mapI map_compatI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply(subgoal_tac \"dom m' - dom m \\<subseteq> dom(m++m')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     dom m' - dom m \\<subseteq> dom (m ++ m')\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}\n 2. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n    \\<Longrightarrow> dom m' - dom m \\<subseteq> dom (m ++ m')", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n    \\<Longrightarrow> dom m' - dom m \\<subseteq> dom (m ++ m')\n 2. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     dom m' - dom m \\<subseteq> dom (m ++ m')\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply(fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     dom m' - dom m \\<subseteq> dom (m ++ m')\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply(insert map_image_eq[of \"dom m' - dom m\" \"m++m'\" \"Some \\<circ> f\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     dom m' - dom m \\<subseteq> dom (m ++ m');\n     \\<lbrakk>dom m' - dom m \\<subseteq> dom (m ++ m');\n      m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n     \\<Longrightarrow> m ++ m' ` (dom m' - dom m) =\n                       (Some \\<circ> f) ` (dom m' - dom m)\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply(subgoal_tac \"dom m - dom m' \\<subseteq> dom(m++m')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     dom m' - dom m \\<subseteq> dom (m ++ m');\n     \\<lbrakk>dom m' - dom m \\<subseteq> dom (m ++ m');\n      m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n     \\<Longrightarrow> m ++ m' ` (dom m' - dom m) =\n                       (Some \\<circ> f) ` (dom m' - dom m);\n     dom m - dom m' \\<subseteq> dom (m ++ m')\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}\n 2. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     dom m' - dom m \\<subseteq> dom (m ++ m');\n     \\<lbrakk>dom m' - dom m \\<subseteq> dom (m ++ m');\n      m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n     \\<Longrightarrow> m ++ m' ` (dom m' - dom m) =\n                       (Some \\<circ> f) ` (dom m' - dom m)\\<rbrakk>\n    \\<Longrightarrow> dom m - dom m' \\<subseteq> dom (m ++ m')", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     dom m' - dom m \\<subseteq> dom (m ++ m');\n     \\<lbrakk>dom m' - dom m \\<subseteq> dom (m ++ m');\n      m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n     \\<Longrightarrow> m ++ m' ` (dom m' - dom m) =\n                       (Some \\<circ> f) ` (dom m' - dom m)\\<rbrakk>\n    \\<Longrightarrow> dom m - dom m' \\<subseteq> dom (m ++ m')\n 2. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     dom m' - dom m \\<subseteq> dom (m ++ m');\n     \\<lbrakk>dom m' - dom m \\<subseteq> dom (m ++ m');\n      m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n     \\<Longrightarrow> m ++ m' ` (dom m' - dom m) =\n                       (Some \\<circ> f) ` (dom m' - dom m);\n     dom m - dom m' \\<subseteq> dom (m ++ m')\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply(fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     dom m' - dom m \\<subseteq> dom (m ++ m');\n     \\<lbrakk>dom m' - dom m \\<subseteq> dom (m ++ m');\n      m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n     \\<Longrightarrow> m ++ m' ` (dom m' - dom m) =\n                       (Some \\<circ> f) ` (dom m' - dom m);\n     dom m - dom m' \\<subseteq> dom (m ++ m')\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply(insert map_image_eq[of \"dom m - dom m'\" \"m++m'\" \"Some \\<circ> f\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     dom m' - dom m \\<subseteq> dom (m ++ m');\n     \\<lbrakk>dom m' - dom m \\<subseteq> dom (m ++ m');\n      m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n     \\<Longrightarrow> m ++ m' ` (dom m' - dom m) =\n                       (Some \\<circ> f) ` (dom m' - dom m);\n     dom m - dom m' \\<subseteq> dom (m ++ m');\n     \\<lbrakk>dom m - dom m' \\<subseteq> dom (m ++ m');\n      m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f\\<rbrakk>\n     \\<Longrightarrow> m ++ m' ` (dom m - dom m') =\n                       (Some \\<circ> f) ` (dom m - dom m')\\<rbrakk>\n    \\<Longrightarrow> m ++ m' ` (dom m' - dom m) \\<inter>\n                      m ++ m' ` (dom m - dom m') =\n                      {}", "apply (clarsimp simp add: image_comp [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m (dom m); inj_on m' (dom m');\n     m \\<subseteq>\\<^sub>m Some \\<circ> f;\n     m' \\<subseteq>\\<^sub>m Some \\<circ> f; A = dom m'; B = dom m;\n     inj_on f (dom m'); inj_on f (dom m);\n     f ` (dom m' - dom m) \\<inter> f ` (dom m - dom m') = {};\n     m ++ m' \\<subseteq>\\<^sub>m Some \\<circ> f;\n     dom m' - dom m \\<subseteq> dom m' \\<union> dom m;\n     m ++ m' ` (dom m' - dom m) =\n     (\\<lambda>x. Some (f x)) ` (dom m' - dom m);\n     dom m - dom m' \\<subseteq> dom m' \\<union> dom m;\n     m ++ m' ` (dom m - dom m') =\n     (\\<lambda>x. Some (f x)) ` (dom m - dom m')\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. Some (f x)) ` (dom m' - dom m) \\<inter>\n                      (\\<lambda>x. Some (f x)) ` (dom m - dom m') =\n                      {}", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_zip_eq_SomeD: \"length xs = length ys \\<Longrightarrow>\n  map_of (zip xs ys) x = Some y \\<Longrightarrow> y \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; map_of (zip xs ys) x = Some y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set ys", "apply(induct rule:list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_of (zip [] []) x = Some y \\<Longrightarrow> y \\<in> set []\n 2. \\<And>xa xs ya ys.\n       \\<lbrakk>length xs = length ys;\n        map_of (zip xs ys) x = Some y \\<Longrightarrow> y \\<in> set ys;\n        map_of (zip (xa # xs) (ya # ys)) x = Some y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> set (ya # ys)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xs ya ys.\n       \\<lbrakk>length xs = length ys;\n        map_of (zip xs ys) x = Some y \\<Longrightarrow> y \\<in> set ys;\n        map_of (zip (xa # xs) (ya # ys)) x = Some y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> set (ya # ys)", "apply (auto split:if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inj_on_map_of_zip:\n  \"\\<lbrakk> length xs = length ys; distinct ys \\<rbrakk>\n   \\<Longrightarrow> inj_on (map_of (zip xs ys)) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = length ys; distinct ys\\<rbrakk>\n    \\<Longrightarrow> inj_on (map_of (zip xs ys)) (set xs)", "apply(induct rule:list_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> inj_on (map_of (zip [] [])) (set [])\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        distinct ys \\<Longrightarrow> inj_on (map_of (zip xs ys)) (set xs);\n        distinct (y # ys)\\<rbrakk>\n       \\<Longrightarrow> inj_on (map_of (zip (x # xs) (y # ys)))\n                          (set (x # xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        distinct ys \\<Longrightarrow> inj_on (map_of (zip xs ys)) (set xs);\n        distinct (y # ys)\\<rbrakk>\n       \\<Longrightarrow> inj_on (map_of (zip (x # xs) (y # ys)))\n                          (set (x # xs))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on (map_of (zip xs ys)) (set xs);\n        y \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> inj_on (map_of (zip xs ys)(x \\<mapsto> y))\n                          (set xs) \\<and>\n                         Some y \\<notin> map_of (zip xs ys) ` (set xs - {x})", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on (map_of (zip xs ys)) (set xs);\n        y \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> inj_on (map_of (zip xs ys)(x \\<mapsto> y)) (set xs)\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on (map_of (zip xs ys)) (set xs);\n        y \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> Some y \\<notin> map_of (zip xs ys) ` (set xs - {x})", "apply(erule inj_on_fun_updI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; y \\<notin> set ys;\n        distinct ys\\<rbrakk>\n       \\<Longrightarrow> Some y \\<notin> map_of (zip xs ys) ` set xs\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on (map_of (zip xs ys)) (set xs);\n        y \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> Some y \\<notin> map_of (zip xs ys) ` (set xs - {x})", "apply(simp add:image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs y ys.\n       \\<lbrakk>length xs = length ys; y \\<notin> set ys;\n        distinct ys\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set xs.\n                            Some y \\<noteq> map_of (zip xs ys) x\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on (map_of (zip xs ys)) (set xs);\n        y \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> Some y \\<notin> map_of (zip xs ys) ` (set xs - {x})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs y ys x.\n       \\<lbrakk>length xs = length ys; y \\<notin> set ys; distinct ys;\n        x \\<in> set xs; Some y = map_of (zip xs ys) x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on (map_of (zip xs ys)) (set xs);\n        y \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> Some y \\<notin> map_of (zip xs ys) ` (set xs - {x})", "apply(drule (1) map_of_zip_eq_SomeD[OF _ sym])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs y ys x.\n       \\<lbrakk>y \\<notin> set ys; distinct ys; x \\<in> set xs;\n        Some y = map_of (zip xs ys) x; y \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on (map_of (zip xs ys)) (set xs);\n        y \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> Some y \\<notin> map_of (zip xs ys) ` (set xs - {x})", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys; inj_on (map_of (zip xs ys)) (set xs);\n        y \\<notin> set ys; distinct ys\\<rbrakk>\n       \\<Longrightarrow> Some y \\<notin> map_of (zip xs ys) ` (set xs - {x})", "apply(clarsimp simp add:image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys xa.\n       \\<lbrakk>length xs = length ys; inj_on (map_of (zip xs ys)) (set xs);\n        y \\<notin> set ys; distinct ys; xa \\<in> set xs; xa \\<noteq> x;\n        Some y = map_of (zip xs ys) xa\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule (1) map_of_zip_eq_SomeD[OF _ sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys xa.\n       \\<lbrakk>inj_on (map_of (zip xs ys)) (set xs); y \\<notin> set ys;\n        distinct ys; xa \\<in> set xs; xa \\<noteq> x;\n        Some y = map_of (zip xs ys) xa; y \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> False", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pr_iso_test0_correct: \"\\<And>m Fs\\<^sub>2.\n \\<lbrakk> \\<forall>F\\<in>set Fs\\<^sub>1. distinct F; \\<forall>F\\<in>set Fs\\<^sub>2. distinct F;\n   distinct Fs\\<^sub>1; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>1);\n   distinct Fs\\<^sub>2; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2); inj_on m (dom m) \\<rbrakk> \\<Longrightarrow>\n       pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2 =\n       (\\<exists>\\<phi>. is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n            inj_on \\<phi> (dom m \\<union> (\\<Union>F\\<in>set Fs\\<^sub>1. set F)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m Fs\\<^sub>2.\n       \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m)\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union>\n                               \\<Union> (set ` set Fs\\<^sub>1)))", "apply(induct Fs\\<^sub>1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m Fs\\<^sub>2.\n       \\<lbrakk>Ball (set []) distinct; Ball (set Fs\\<^sub>2) distinct;\n        distinct []; inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set []);\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m)\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test0 m [] Fs\\<^sub>2 =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> [] Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union> \\<Union> (set ` set [])))\n 2. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>Ball (set Fs\\<^sub>1) distinct;\n                    Ball (set Fs\\<^sub>2) distinct; distinct Fs\\<^sub>1;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>1);\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1)));\n        Ball (set (a # Fs\\<^sub>1)) distinct;\n        Ball (set Fs\\<^sub>2) distinct; distinct (a # Fs\\<^sub>1);\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set (a # Fs\\<^sub>1));\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m)\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test0 m (a # Fs\\<^sub>1) Fs\\<^sub>2 =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> (a # Fs\\<^sub>1)\n                              Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union>\n                               \\<Union> (set ` set (a # Fs\\<^sub>1))))", "apply(simp add:inj_on_def dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m Fs\\<^sub>2.\n       \\<lbrakk>\\<forall>x\\<in>set Fs\\<^sub>2. distinct x;\n        distinct Fs\\<^sub>2;\n        \\<forall>x\\<in>set Fs\\<^sub>2.\n           \\<forall>y\\<in>set Fs\\<^sub>2.\n              x \\<cong> y \\<longrightarrow> x = y;\n        \\<forall>x.\n           (\\<exists>y. m x = Some y) \\<longrightarrow>\n           (\\<forall>y.\n               (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n               m x = m y \\<longrightarrow> x = y)\\<rbrakk>\n       \\<Longrightarrow> (Fs\\<^sub>2 = []) =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> [] Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             (\\<forall>x.\n                                 (\\<exists>y.\n                                     m x = Some y) \\<longrightarrow>\n                                 (\\<forall>y.\n                                     (\\<exists>ya.\n   m y = Some ya) \\<longrightarrow>\n                                     \\<phi> x = \\<phi> y \\<longrightarrow>\n                                     x = y)))\n 2. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>Ball (set Fs\\<^sub>1) distinct;\n                    Ball (set Fs\\<^sub>2) distinct; distinct Fs\\<^sub>1;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>1);\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1)));\n        Ball (set (a # Fs\\<^sub>1)) distinct;\n        Ball (set Fs\\<^sub>2) distinct; distinct (a # Fs\\<^sub>1);\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set (a # Fs\\<^sub>1));\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m)\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test0 m (a # Fs\\<^sub>1) Fs\\<^sub>2 =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> (a # Fs\\<^sub>1)\n                              Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union>\n                               \\<Union> (set ` set (a # Fs\\<^sub>1))))", "apply(rule iffI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m Fs\\<^sub>2.\n       \\<lbrakk>\\<forall>x\\<in>set Fs\\<^sub>2. distinct x;\n        distinct Fs\\<^sub>2;\n        \\<forall>x\\<in>set Fs\\<^sub>2.\n           \\<forall>y\\<in>set Fs\\<^sub>2.\n              x \\<cong> y \\<longrightarrow> x = y;\n        \\<forall>x.\n           (\\<exists>y. m x = Some y) \\<longrightarrow>\n           (\\<forall>y.\n               (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n               m x = m y \\<longrightarrow> x = y);\n        Fs\\<^sub>2 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            is_pr_iso \\<phi> [] Fs\\<^sub>2 \\<and>\n                            m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                            (\\<forall>x.\n                                (\\<exists>y. m x = Some y) \\<longrightarrow>\n                                (\\<forall>y.\n                                    (\\<exists>ya.\n  m y = Some ya) \\<longrightarrow>\n                                    \\<phi> x = \\<phi> y \\<longrightarrow>\n                                    x = y))\n 2. \\<And>m Fs\\<^sub>2.\n       \\<lbrakk>\\<forall>x\\<in>set Fs\\<^sub>2. distinct x;\n        distinct Fs\\<^sub>2;\n        \\<forall>x\\<in>set Fs\\<^sub>2.\n           \\<forall>y\\<in>set Fs\\<^sub>2.\n              x \\<cong> y \\<longrightarrow> x = y;\n        \\<forall>x.\n           (\\<exists>y. m x = Some y) \\<longrightarrow>\n           (\\<forall>y.\n               (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n               m x = m y \\<longrightarrow> x = y);\n        \\<exists>\\<phi>.\n           is_pr_iso \\<phi> [] Fs\\<^sub>2 \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           (\\<forall>x.\n               (\\<exists>y. m x = Some y) \\<longrightarrow>\n               (\\<forall>y.\n                   (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n                   \\<phi> x = \\<phi> y \\<longrightarrow> x = y))\\<rbrakk>\n       \\<Longrightarrow> Fs\\<^sub>2 = []\n 3. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>Ball (set Fs\\<^sub>1) distinct;\n                    Ball (set Fs\\<^sub>2) distinct; distinct Fs\\<^sub>1;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>1);\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1)));\n        Ball (set (a # Fs\\<^sub>1)) distinct;\n        Ball (set Fs\\<^sub>2) distinct; distinct (a # Fs\\<^sub>1);\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set (a # Fs\\<^sub>1));\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m)\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test0 m (a # Fs\\<^sub>1) Fs\\<^sub>2 =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> (a # Fs\\<^sub>1)\n                              Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union>\n                               \\<Union> (set ` set (a # Fs\\<^sub>1))))", "apply (simp add:is_pr_iso_def is_pr_Iso_def is_pr_Hom_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m Fs\\<^sub>2.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>y. m x = Some y) \\<longrightarrow>\n                   (\\<forall>y.\n                       (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n                       m x = m y \\<longrightarrow> x = y);\n        Fs\\<^sub>2 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                            (\\<forall>x.\n                                (\\<exists>y. m x = Some y) \\<longrightarrow>\n                                (\\<forall>y.\n                                    (\\<exists>ya.\n  m y = Some ya) \\<longrightarrow>\n                                    \\<phi> x = \\<phi> y \\<longrightarrow>\n                                    x = y))\n 2. \\<And>m Fs\\<^sub>2.\n       \\<lbrakk>\\<forall>x\\<in>set Fs\\<^sub>2. distinct x;\n        distinct Fs\\<^sub>2;\n        \\<forall>x\\<in>set Fs\\<^sub>2.\n           \\<forall>y\\<in>set Fs\\<^sub>2.\n              x \\<cong> y \\<longrightarrow> x = y;\n        \\<forall>x.\n           (\\<exists>y. m x = Some y) \\<longrightarrow>\n           (\\<forall>y.\n               (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n               m x = m y \\<longrightarrow> x = y);\n        \\<exists>\\<phi>.\n           is_pr_iso \\<phi> [] Fs\\<^sub>2 \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           (\\<forall>x.\n               (\\<exists>y. m x = Some y) \\<longrightarrow>\n               (\\<forall>y.\n                   (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n                   \\<phi> x = \\<phi> y \\<longrightarrow> x = y))\\<rbrakk>\n       \\<Longrightarrow> Fs\\<^sub>2 = []\n 3. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>Ball (set Fs\\<^sub>1) distinct;\n                    Ball (set Fs\\<^sub>2) distinct; distinct Fs\\<^sub>1;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>1);\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1)));\n        Ball (set (a # Fs\\<^sub>1)) distinct;\n        Ball (set Fs\\<^sub>2) distinct; distinct (a # Fs\\<^sub>1);\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set (a # Fs\\<^sub>1));\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m)\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test0 m (a # Fs\\<^sub>1) Fs\\<^sub>2 =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> (a # Fs\\<^sub>1)\n                              Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union>\n                               \\<Union> (set ` set (a # Fs\\<^sub>1))))", "apply(rule_tac x = \"the \\<circ> m\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m Fs\\<^sub>2.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>y. m x = Some y) \\<longrightarrow>\n                   (\\<forall>y.\n                       (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n                       m x = m y \\<longrightarrow> x = y);\n        Fs\\<^sub>2 = []\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         Some \\<circ> (the \\<circ> m) \\<and>\n                         (\\<forall>x.\n                             (\\<exists>y. m x = Some y) \\<longrightarrow>\n                             (\\<forall>y.\n                                 (\\<exists>ya.\n                                     m y = Some ya) \\<longrightarrow>\n                                 (the \\<circ> m) x =\n                                 (the \\<circ> m) y \\<longrightarrow>\n                                 x = y))\n 2. \\<And>m Fs\\<^sub>2.\n       \\<lbrakk>\\<forall>x\\<in>set Fs\\<^sub>2. distinct x;\n        distinct Fs\\<^sub>2;\n        \\<forall>x\\<in>set Fs\\<^sub>2.\n           \\<forall>y\\<in>set Fs\\<^sub>2.\n              x \\<cong> y \\<longrightarrow> x = y;\n        \\<forall>x.\n           (\\<exists>y. m x = Some y) \\<longrightarrow>\n           (\\<forall>y.\n               (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n               m x = m y \\<longrightarrow> x = y);\n        \\<exists>\\<phi>.\n           is_pr_iso \\<phi> [] Fs\\<^sub>2 \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           (\\<forall>x.\n               (\\<exists>y. m x = Some y) \\<longrightarrow>\n               (\\<forall>y.\n                   (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n                   \\<phi> x = \\<phi> y \\<longrightarrow> x = y))\\<rbrakk>\n       \\<Longrightarrow> Fs\\<^sub>2 = []\n 3. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>Ball (set Fs\\<^sub>1) distinct;\n                    Ball (set Fs\\<^sub>2) distinct; distinct Fs\\<^sub>1;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>1);\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1)));\n        Ball (set (a # Fs\\<^sub>1)) distinct;\n        Ball (set Fs\\<^sub>2) distinct; distinct (a # Fs\\<^sub>1);\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set (a # Fs\\<^sub>1));\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m)\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test0 m (a # Fs\\<^sub>1) Fs\\<^sub>2 =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> (a # Fs\\<^sub>1)\n                              Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union>\n                               \\<Union> (set ` set (a # Fs\\<^sub>1))))", "apply (fastforce simp: map_le_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m Fs\\<^sub>2.\n       \\<lbrakk>\\<forall>x\\<in>set Fs\\<^sub>2. distinct x;\n        distinct Fs\\<^sub>2;\n        \\<forall>x\\<in>set Fs\\<^sub>2.\n           \\<forall>y\\<in>set Fs\\<^sub>2.\n              x \\<cong> y \\<longrightarrow> x = y;\n        \\<forall>x.\n           (\\<exists>y. m x = Some y) \\<longrightarrow>\n           (\\<forall>y.\n               (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n               m x = m y \\<longrightarrow> x = y);\n        \\<exists>\\<phi>.\n           is_pr_iso \\<phi> [] Fs\\<^sub>2 \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           (\\<forall>x.\n               (\\<exists>y. m x = Some y) \\<longrightarrow>\n               (\\<forall>y.\n                   (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n                   \\<phi> x = \\<phi> y \\<longrightarrow> x = y))\\<rbrakk>\n       \\<Longrightarrow> Fs\\<^sub>2 = []\n 2. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>Ball (set Fs\\<^sub>1) distinct;\n                    Ball (set Fs\\<^sub>2) distinct; distinct Fs\\<^sub>1;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>1);\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1)));\n        Ball (set (a # Fs\\<^sub>1)) distinct;\n        Ball (set Fs\\<^sub>2) distinct; distinct (a # Fs\\<^sub>1);\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set (a # Fs\\<^sub>1));\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m)\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test0 m (a # Fs\\<^sub>1) Fs\\<^sub>2 =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> (a # Fs\\<^sub>1)\n                              Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union>\n                               \\<Union> (set ` set (a # Fs\\<^sub>1))))", "apply (clarsimp simp:is_pr_iso_def is_pr_Iso_def is_pr_Hom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>Ball (set Fs\\<^sub>1) distinct;\n                    Ball (set Fs\\<^sub>2) distinct; distinct Fs\\<^sub>1;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>1);\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1)));\n        Ball (set (a # Fs\\<^sub>1)) distinct;\n        Ball (set Fs\\<^sub>2) distinct; distinct (a # Fs\\<^sub>1);\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set (a # Fs\\<^sub>1));\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m)\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test0 m (a # Fs\\<^sub>1) Fs\\<^sub>2 =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> (a # Fs\\<^sub>1)\n                              Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union>\n                               \\<Union> (set ` set (a # Fs\\<^sub>1))))", "apply(rename_tac F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>Ball (set Fs\\<^sub>1') distinct;\n                    Ball (set Fs\\<^sub>2) distinct; distinct Fs\\<^sub>1';\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>1');\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        Ball (set (F\\<^sub>1 # Fs\\<^sub>1')) distinct;\n        Ball (set Fs\\<^sub>2) distinct; distinct (F\\<^sub>1 # Fs\\<^sub>1');\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n         (set (F\\<^sub>1 # Fs\\<^sub>1'));\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m)\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test0 m (F\\<^sub>1 # Fs\\<^sub>1')\n                          Fs\\<^sub>2 =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> (F\\<^sub>1 # Fs\\<^sub>1')\n                              Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union>\n                               \\<Union>\n                                (set ` set (F\\<^sub>1 # Fs\\<^sub>1'))))", "apply(clarsimp simp:Let_def Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                             length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                             (\\<exists>n.\n                                 (m \\<subseteq>\\<^sub>m\n                                  m ++\n                                  map_of\n                                   (zip F\\<^sub>1\n                                     (rotate n F\\<^sub>2)) \\<and>\n                                  inj_on\n                                   (m ++\n                                    map_of\n                                     (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                   (dom (map_of\n    (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                    dom m) \\<longrightarrow>\n                                  pr_iso_test0\n                                   (m ++\n                                    map_of\n                                     (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                   Fs\\<^sub>1'\n                                   (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                 m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m))) =\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> (F\\<^sub>1 # Fs\\<^sub>1')\n                              Fs\\<^sub>2 \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union>\n                               (set F\\<^sub>1 \\<union>\n                                \\<Union> (set ` set Fs\\<^sub>1'))))", "apply(simp add: is_iso_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                             length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                             (\\<exists>n.\n                                 (m \\<subseteq>\\<^sub>m\n                                  m ++\n                                  map_of\n                                   (zip F\\<^sub>1\n                                     (rotate n F\\<^sub>2)) \\<and>\n                                  inj_on\n                                   (m ++\n                                    map_of\n                                     (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                   (dom (map_of\n    (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                    dom m) \\<longrightarrow>\n                                  pr_iso_test0\n                                   (m ++\n                                    map_of\n                                     (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                   Fs\\<^sub>1'\n                                   (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                 m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m))) =\n                         (\\<exists>\\<phi>.\n                             (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                                 length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                                 is_pr_iso \\<phi> Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                                 (\\<exists>n.\n                                     map \\<phi> F\\<^sub>1 =\n                                     rotate n F\\<^sub>2) \\<and>\n                                 inj_on \\<phi>\n                                  (set F\\<^sub>1 \\<union>\n                                   \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (dom m \\<union>\n                               (set F\\<^sub>1 \\<union>\n                                \\<Union> (set ` set Fs\\<^sub>1'))))", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n           length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n           (\\<exists>n.\n               (m \\<subseteq>\\<^sub>m\n                m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                 (dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                  dom m) \\<longrightarrow>\n                pr_iso_test0\n                 (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                 Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n               m \\<subseteq>\\<^sub>m\n               m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n               inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                (dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                 dom m))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                                length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                                is_pr_iso \\<phi> Fs\\<^sub>1'\n                                 (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                                (\\<exists>n.\n                                    map \\<phi> F\\<^sub>1 =\n                                    rotate n F\\<^sub>2) \\<and>\n                                inj_on \\<phi>\n                                 (set F\\<^sub>1 \\<union>\n                                  \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n                            m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                            inj_on \\<phi>\n                             (dom m \\<union>\n                              (set F\\<^sub>1 \\<union>\n                               \\<Union> (set ` set Fs\\<^sub>1')))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n          dom m) \\<longrightarrow>\n        pr_iso_test0 (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n          dom m)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                                length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                                is_pr_iso \\<phi> Fs\\<^sub>1'\n                                 (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                                (\\<exists>n.\n                                    map \\<phi> F\\<^sub>1 =\n                                    rotate n F\\<^sub>2) \\<and>\n                                inj_on \\<phi>\n                                 (set F\\<^sub>1 \\<union>\n                                  \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n                            m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                            inj_on \\<phi>\n                             (dom m \\<union>\n                              (set F\\<^sub>1 \\<union>\n                               \\<Union> (set ` set Fs\\<^sub>1')))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(clarsimp simp add:map_of_zip_submap inj_on_diff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            (\\<exists>F\\<^sub>2'\\<in>set Fs\\<^sub>2.\n                                length F\\<^sub>2 = length F\\<^sub>2' \\<and>\n                                is_pr_iso \\<phi> Fs\\<^sub>1'\n                                 (remove1 F\\<^sub>2' Fs\\<^sub>2) \\<and>\n                                (\\<exists>n.\n                                    map \\<phi> F\\<^sub>1 =\n                                    rotate n F\\<^sub>2') \\<and>\n                                inj_on \\<phi>\n                                 (set F\\<^sub>1 \\<union>\n                                  \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n                            m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                            inj_on \\<phi>\n                             (dom m \\<union>\n                              (set F\\<^sub>1 \\<union>\n                               \\<Union> (set ` set Fs\\<^sub>1')))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(rule_tac x = \\<phi> in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>F\\<^sub>2'\\<in>set Fs\\<^sub>2.\n                             length F\\<^sub>2 = length F\\<^sub>2' \\<and>\n                             is_pr_iso \\<phi> Fs\\<^sub>1'\n                              (remove1 F\\<^sub>2' Fs\\<^sub>2) \\<and>\n                             (\\<exists>n.\n                                 map \\<phi> F\\<^sub>1 =\n                                 rotate n F\\<^sub>2') \\<and>\n                             inj_on \\<phi>\n                              (set F\\<^sub>1 \\<union>\n                               \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n                         m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2'\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>2 = length F\\<^sub>2' \\<and>\n                            is_pr_iso \\<phi> Fs\\<^sub>1'\n                             (remove1 F\\<^sub>2' Fs\\<^sub>2) \\<and>\n                            (\\<exists>n.\n                                map \\<phi> F\\<^sub>1 =\n                                rotate n F\\<^sub>2') \\<and>\n                            inj_on \\<phi>\n                             (set F\\<^sub>1 \\<union>\n                              \\<Union> (set ` set Fs\\<^sub>1'))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(rule_tac x = F\\<^sub>2 in bexI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>2 \\<and>\n                         is_pr_iso \\<phi> Fs\\<^sub>1'\n                          (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 =\n                             rotate n F\\<^sub>2) \\<and>\n                         inj_on \\<phi>\n                          (set F\\<^sub>1 \\<union>\n                           \\<Union> (set ` set Fs\\<^sub>1'))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<in> set Fs\\<^sub>2\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 4. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<in> set Fs\\<^sub>2\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>2 \\<and>\n                         is_pr_iso \\<phi> Fs\\<^sub>1'\n                          (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 =\n                             rotate n F\\<^sub>2) \\<and>\n                         inj_on \\<phi>\n                          (set F\\<^sub>1 \\<union>\n                           \\<Union> (set ` set Fs\\<^sub>1'))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 4. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>2 \\<and>\n                         is_pr_iso \\<phi> Fs\\<^sub>1'\n                          (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 =\n                             rotate n F\\<^sub>2) \\<and>\n                         inj_on \\<phi>\n                          (set F\\<^sub>1 \\<union>\n                           \\<Union> (set ` set Fs\\<^sub>1'))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(frule map_add_le_mapE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>2 \\<and>\n                         is_pr_iso \\<phi> Fs\\<^sub>1'\n                          (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                         (\\<exists>n.\n                             map \\<phi> F\\<^sub>1 =\n                             rotate n F\\<^sub>2) \\<and>\n                         inj_on \\<phi>\n                          (set F\\<^sub>1 \\<union>\n                           \\<Union> (set ` set Fs\\<^sub>1'))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(simp add:map_of_zip_submap is_pr_iso_def is_pr_Iso_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_Hom \\<phi> (set Fs\\<^sub>1') (set Fs\\<^sub>2) \\<and>\n   inj_on \\<phi> (\\<Union> (set ` set Fs\\<^sub>1')) \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_Hom \\<phi> (set Fs\\<^sub>1')\n         (set Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n        inj_on \\<phi> (\\<Union> (set ` set Fs\\<^sub>1'));\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>na.\n                             rotate n F\\<^sub>2 =\n                             rotate na F\\<^sub>2) \\<and>\n                         inj_on \\<phi>\n                          (set F\\<^sub>1 \\<union>\n                           \\<Union> (set ` set Fs\\<^sub>1'))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(rule conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_Hom \\<phi> (set Fs\\<^sub>1') (set Fs\\<^sub>2) \\<and>\n   inj_on \\<phi> (\\<Union> (set ` set Fs\\<^sub>1')) \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_Hom \\<phi> (set Fs\\<^sub>1')\n         (set Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n        inj_on \\<phi> (\\<Union> (set ` set Fs\\<^sub>1'));\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            rotate n F\\<^sub>2 = rotate na F\\<^sub>2\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_Hom \\<phi> (set Fs\\<^sub>1') (set Fs\\<^sub>2) \\<and>\n   inj_on \\<phi> (\\<Union> (set ` set Fs\\<^sub>1')) \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_Hom \\<phi> (set Fs\\<^sub>1')\n         (set Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n        inj_on \\<phi> (\\<Union> (set ` set Fs\\<^sub>1'));\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi>\n                          (set F\\<^sub>1 \\<union>\n                           \\<Union> (set ` set Fs\\<^sub>1'))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 4. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_Hom \\<phi> (set Fs\\<^sub>1') (set Fs\\<^sub>2) \\<and>\n   inj_on \\<phi> (\\<Union> (set ` set Fs\\<^sub>1')) \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_Hom \\<phi> (set Fs\\<^sub>1')\n         (set Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n        inj_on \\<phi> (\\<Union> (set ` set Fs\\<^sub>1'));\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi>\n                          (set F\\<^sub>1 \\<union>\n                           \\<Union> (set ` set Fs\\<^sub>1'))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(erule subset_inj_on)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_Hom \\<phi> (set Fs\\<^sub>1') (set Fs\\<^sub>2) \\<and>\n   inj_on \\<phi> (\\<Union> (set ` set Fs\\<^sub>1')) \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_Hom \\<phi> (set Fs\\<^sub>1')\n         (set Fs\\<^sub>2 - {F\\<^sub>2}) \\<and>\n        inj_on \\<phi> (\\<Union> (set ` set Fs\\<^sub>1'));\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> set F\\<^sub>1 \\<union>\n                         \\<Union> (set ` set Fs\\<^sub>1')\n                         \\<subseteq> set F\\<^sub>1 \\<union> dom m \\<union>\n                                     \\<Union> (set ` set Fs\\<^sub>1')\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(blast intro: map_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> dom m \\<union>\n          \\<Union> (set ` set Fs\\<^sub>1'))\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi>\n                          (dom m \\<union>\n                           (set F\\<^sub>1 \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1')))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(erule subset_inj_on)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 F\\<^sub>2 n \\<phi>.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2; length F\\<^sub>1 = length F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m);\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> dom m \\<union>\n                         (set F\\<^sub>1 \\<union>\n                          \\<Union> (set ` set Fs\\<^sub>1'))\n                         \\<subseteq> set F\\<^sub>1 \\<union> dom m \\<union>\n                                     \\<Union> (set ` set Fs\\<^sub>1')\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        \\<exists>\\<phi>.\n           (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n               length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n               is_pr_iso \\<phi> Fs\\<^sub>1'\n                (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n               (\\<exists>n.\n                   map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2) \\<and>\n               inj_on \\<phi>\n                (set F\\<^sub>1 \\<union>\n                 \\<Union> (set ` set Fs\\<^sub>1'))) \\<and>\n           m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n           inj_on \\<phi>\n            (dom m \\<union>\n             (set F\\<^sub>1 \\<union>\n              \\<Union> (set ` set Fs\\<^sub>1')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2)) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                  Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                  dom m))", "apply(clarsimp simp: inj_on_diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2'\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>2 = length F\\<^sub>2' \\<and>\n                            (\\<exists>n.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n F\\<^sub>2')) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of\n                                    (zip F\\<^sub>1 (rotate n F\\<^sub>2')))\n                                  (dom (map_of\n   (zip F\\<^sub>1 (rotate n F\\<^sub>2'))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 (\\<exists>\\<phi>.\n                                     is_pr_iso \\<phi> Fs\\<^sub>1'\n(remove1 F\\<^sub>2' Fs\\<^sub>2) \\<and>\n                                     m ++\n                                     map_of\n(zip F\\<^sub>1 (rotate n F\\<^sub>2')) \\<subseteq>\\<^sub>m\n                                     Some \\<circ> \\<phi> \\<and>\n                                     inj_on \\<phi>\n(dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2'))) \\<union> dom m \\<union>\n \\<Union> (set ` set Fs\\<^sub>1')))) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of\n                                 (zip F\\<^sub>1\n                                   (rotate n F\\<^sub>2')) \\<and>\n                                inj_on\n                                 (m ++\n                                  map_of\n                                   (zip F\\<^sub>1 (rotate n F\\<^sub>2')))\n                                 (dom (map_of\n  (zip F\\<^sub>1 (rotate n F\\<^sub>2'))) \\<union>\n                                  dom m))", "apply(rule_tac x = F\\<^sub>2 in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>2 \\<and>\n                         (\\<exists>n.\n                             (m \\<subseteq>\\<^sub>m\n                              m ++\n                              map_of\n                               (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                              inj_on\n                               (m ++\n                                map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                               (dom (map_of\n(zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                dom m) \\<longrightarrow>\n                              (\\<exists>\\<phi>.\n                                  is_pr_iso \\<phi> Fs\\<^sub>1'\n                                   (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                                  m ++\n                                  map_of\n                                   (zip F\\<^sub>1\n                                     (rotate n\n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                                  Some \\<circ> \\<phi> \\<and>\n                                  inj_on \\<phi>\n                                   (dom (map_of\n    (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                    dom m \\<union>\n                                    \\<Union>\n                                     (set ` set Fs\\<^sub>1')))) \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             m ++\n                             map_of\n                              (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                             inj_on\n                              (m ++\n                               map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                              (dom (map_of\n                                     (zip F\\<^sub>1\n (rotate n F\\<^sub>2))) \\<union>\n                               dom m))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<in> set Fs\\<^sub>2", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<in> set Fs\\<^sub>2\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>2 \\<and>\n                         (\\<exists>n.\n                             (m \\<subseteq>\\<^sub>m\n                              m ++\n                              map_of\n                               (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                              inj_on\n                               (m ++\n                                map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                               (dom (map_of\n(zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                dom m) \\<longrightarrow>\n                              (\\<exists>\\<phi>.\n                                  is_pr_iso \\<phi> Fs\\<^sub>1'\n                                   (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                                  m ++\n                                  map_of\n                                   (zip F\\<^sub>1\n                                     (rotate n\n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                                  Some \\<circ> \\<phi> \\<and>\n                                  inj_on \\<phi>\n                                   (dom (map_of\n    (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                    dom m \\<union>\n                                    \\<Union>\n                                     (set ` set Fs\\<^sub>1')))) \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             m ++\n                             map_of\n                              (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                             inj_on\n                              (m ++\n                               map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                              (dom (map_of\n                                     (zip F\\<^sub>1\n (rotate n F\\<^sub>2))) \\<union>\n                               dom m))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>2 \\<and>\n                         (\\<exists>n.\n                             (m \\<subseteq>\\<^sub>m\n                              m ++\n                              map_of\n                               (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                              inj_on\n                               (m ++\n                                map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                               (dom (map_of\n(zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                dom m) \\<longrightarrow>\n                              (\\<exists>\\<phi>.\n                                  is_pr_iso \\<phi> Fs\\<^sub>1'\n                                   (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                                  m ++\n                                  map_of\n                                   (zip F\\<^sub>1\n                                     (rotate n\n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                                  Some \\<circ> \\<phi> \\<and>\n                                  inj_on \\<phi>\n                                   (dom (map_of\n    (zip F\\<^sub>1 (rotate n F\\<^sub>2))) \\<union>\n                                    dom m \\<union>\n                                    \\<Union>\n                                     (set ` set Fs\\<^sub>1')))) \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             m ++\n                             map_of\n                              (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                             inj_on\n                              (m ++\n                               map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                              (dom (map_of\n                                     (zip F\\<^sub>1\n (rotate n F\\<^sub>2))) \\<union>\n                               dom m))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            (m \\<subseteq>\\<^sub>m\n                             m ++\n                             map_of\n                              (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                             inj_on\n                              (m ++\n                               map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                              (set F\\<^sub>1 \\<union>\n                               dom m) \\<longrightarrow>\n                             (\\<exists>\\<phi>.\n                                 is_pr_iso \\<phi> Fs\\<^sub>1'\n                                  (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                                 m ++\n                                 map_of\n                                  (zip F\\<^sub>1\n                                    (rotate n\nF\\<^sub>2)) \\<subseteq>\\<^sub>m\n                                 Some \\<circ> \\<phi> \\<and>\n                                 inj_on \\<phi>\n                                  (set F\\<^sub>1 \\<union> dom m \\<union>\n                                   \\<Union>\n                                    (set ` set Fs\\<^sub>1')))) \\<and>\n                            m \\<subseteq>\\<^sub>m\n                            m ++\n                            map_of\n                             (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                            inj_on\n                             (m ++\n                              map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                             (set F\\<^sub>1 \\<union> dom m)", "apply(rule_tac x = n in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (m \\<subseteq>\\<^sub>m\n                          m ++\n                          map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                          inj_on\n                           (m ++\n                            map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                           (set F\\<^sub>1 \\<union> dom m) \\<longrightarrow>\n                          (\\<exists>\\<phi>.\n                              is_pr_iso \\<phi> Fs\\<^sub>1'\n                               (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                              m ++\n                              map_of\n                               (zip F\\<^sub>1\n                                 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                              Some \\<circ> \\<phi> \\<and>\n                              inj_on \\<phi>\n                               (set F\\<^sub>1 \\<union> dom m \\<union>\n                                \\<Union> (set ` set Fs\\<^sub>1')))) \\<and>\n                         m \\<subseteq>\\<^sub>m\n                         m ++\n                         map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                         inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         m ++\n                         map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                         inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m) \\<longrightarrow>\n                         (\\<exists>\\<phi>.\n                             is_pr_iso \\<phi> Fs\\<^sub>1'\n                              (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                             m ++\n                             map_of\n                              (zip F\\<^sub>1\n                                (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                             Some \\<circ> \\<phi> \\<and>\n                             inj_on \\<phi>\n                              (set F\\<^sub>1 \\<union> dom m \\<union>\n                               \\<Union> (set ` set Fs\\<^sub>1')))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         m ++\n                         map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                         inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            is_pr_iso \\<phi> Fs\\<^sub>1'\n                             (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                            m ++\n                            map_of\n                             (zip F\\<^sub>1\n                               (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                            Some \\<circ> \\<phi> \\<and>\n                            inj_on \\<phi>\n                             (set F\\<^sub>1 \\<union> dom m \\<union>\n                              \\<Union> (set ` set Fs\\<^sub>1'))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         m ++\n                         map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                         inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply(rule_tac x = \\<phi> in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> is_pr_iso \\<phi> Fs\\<^sub>1'\n                          (remove1 F\\<^sub>2 Fs\\<^sub>2) \\<and>\n                         m ++\n                         map_of\n                          (zip F\\<^sub>1\n                            (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                         Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (set F\\<^sub>1 \\<union> dom m \\<union>\n                           \\<Union> (set ` set Fs\\<^sub>1'))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         m ++\n                         map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                         inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> m ++\n                         map_of\n                          (zip F\\<^sub>1\n                            (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                         Some \\<circ> \\<phi> \\<and>\n                         inj_on \\<phi>\n                          (set F\\<^sub>1 \\<union> dom m \\<union>\n                           \\<Union> (set ` set Fs\\<^sub>1'))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         m ++\n                         map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                         inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> m ++\n                         map_of\n                          (zip F\\<^sub>1\n                            (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                         Some \\<circ> \\<phi>\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi>\n                          (set F\\<^sub>1 \\<union> dom m \\<union>\n                           \\<Union> (set ` set Fs\\<^sub>1'))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         m ++\n                         map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                         inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply(fastforce intro!:map_add_le_mapI simp:map_of_zip_submap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n         (set F\\<^sub>1 \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi>\n                          (set F\\<^sub>1 \\<union> dom m \\<union>\n                           \\<Union> (set ` set Fs\\<^sub>1'))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         m ++\n                         map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                         inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply(simp add:Un_ac)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         m ++\n                         map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<and>\n                         inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply(rule context_conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply(simp add:map_of_zip_submap[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply(erule (1) map_compatI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map \\<phi> F\\<^sub>1 = rotate n F\\<^sub>2;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply(simp add:map_of_zip_submap[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        inj_on m (dom m); F\\<^sub>1 \\<notin> set Fs\\<^sub>1';\n        distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (set F\\<^sub>1 \\<union> dom m)", "apply(erule inj_on_map_add_Un)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n                          (dom (map_of\n                                 (zip F\\<^sub>1 (rotate n F\\<^sub>2))))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         Some \\<circ>\n                         ?f152 F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi>\n                          F\\<^sub>2 n\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (zip F\\<^sub>1\n                            (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                         Some \\<circ>\n                         ?f152 F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi>\n                          F\\<^sub>2 n\n 4. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (?f152 F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi>\n                            F\\<^sub>2 n)\n                          (dom (map_of\n                                 (zip F\\<^sub>1\n                                   (rotate n F\\<^sub>2))) \\<union>\n                           dom m)\n 5. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> set F\\<^sub>1 =\n                         dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n 6. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> dom m = dom m", "apply(simp add:inj_on_map_of_zip)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> m \\<subseteq>\\<^sub>m\n                         Some \\<circ>\n                         ?f152 F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi>\n                          F\\<^sub>2 n\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (zip F\\<^sub>1\n                            (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                         Some \\<circ>\n                         ?f152 F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi>\n                          F\\<^sub>2 n\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (?f152 F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi>\n                            F\\<^sub>2 n)\n                          (dom (map_of\n                                 (zip F\\<^sub>1\n                                   (rotate n F\\<^sub>2))) \\<union>\n                           dom m)\n 4. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> set F\\<^sub>1 =\n                         dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n 5. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> dom m = dom m", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (zip F\\<^sub>1\n                            (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n                         Some \\<circ> \\<phi>\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi>\n                          (dom (map_of\n                                 (zip F\\<^sub>1\n                                   (rotate n F\\<^sub>2))) \\<union>\n                           dom m)\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> set F\\<^sub>1 =\n                         dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n 4. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> dom m = dom m", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi>\n                          (dom (map_of\n                                 (zip F\\<^sub>1\n                                   (rotate n F\\<^sub>2))) \\<union>\n                           dom m)\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> set F\\<^sub>1 =\n                         dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> dom m = dom m", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> inj_on \\<phi> (set F\\<^sub>1 \\<union> dom m)\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> set F\\<^sub>1 =\n                         dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> dom m = dom m", "apply(erule subset_inj_on)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> set F\\<^sub>1 \\<union> dom m\n                         \\<subseteq> dom m \\<union>\n                                     (set F\\<^sub>1 \\<union>\n\\<Union> (set ` set Fs\\<^sub>1'))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> set F\\<^sub>1 =\n                         dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n 3. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> dom m = dom m", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> set F\\<^sub>1 =\n                         dom (map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)))\n 2. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> dom m = dom m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F\\<^sub>1 Fs\\<^sub>1' m Fs\\<^sub>2 \\<phi> F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>x.\n                               x \\<in> set Fs\\<^sub>2 \\<longrightarrow>\n                               distinct x;\n                    distinct Fs\\<^sub>2;\n                    inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                     (set Fs\\<^sub>2);\n                    inj_on m (dom m)\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test0 m Fs\\<^sub>1' Fs\\<^sub>2 =\n                                     (\\<exists>\\<phi>.\n   is_pr_iso \\<phi> Fs\\<^sub>1' Fs\\<^sub>2 \\<and>\n   m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi> \\<and>\n   inj_on \\<phi> (dom m \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        \\<forall>x.\n           (x = F\\<^sub>1 \\<longrightarrow> distinct F\\<^sub>1) \\<and>\n           (x \\<in> set Fs\\<^sub>1' \\<longrightarrow> distinct x);\n        \\<forall>x. x \\<in> set Fs\\<^sub>2 \\<longrightarrow> distinct x;\n        distinct Fs\\<^sub>2;\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2);\n        F\\<^sub>1 \\<notin> set Fs\\<^sub>1'; distinct Fs\\<^sub>1';\n        inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1');\n        {F\\<^sub>1} // {\\<cong>}\n        \\<notin> (\\<lambda>x. {x} // {\\<cong>}) ` set Fs\\<^sub>1';\n        F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        m \\<subseteq>\\<^sub>m Some \\<circ> \\<phi>;\n        inj_on \\<phi>\n         (dom m \\<union>\n          (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1')));\n        length F\\<^sub>1 = length F\\<^sub>2;\n        is_pr_iso \\<phi> Fs\\<^sub>1' (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        inj_on \\<phi>\n         (set F\\<^sub>1 \\<union> \\<Union> (set ` set Fs\\<^sub>1'));\n        map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2)) \\<subseteq>\\<^sub>m\n        Some \\<circ> \\<phi>;\n        m \\<subseteq>\\<^sub>m\n        m ++ map_of (zip F\\<^sub>1 (rotate n F\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> dom m = dom m", "apply(rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary pr_iso_test0_corr:\n \"\\<lbrakk> \\<forall>F\\<in>set Fs\\<^sub>1. distinct F; \\<forall>F\\<in>set Fs\\<^sub>2. distinct F;\n   distinct Fs\\<^sub>1; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>1);\n   distinct Fs\\<^sub>2; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2) \\<rbrakk> \\<Longrightarrow>\n       pr_iso_test0 Map.empty Fs\\<^sub>1 Fs\\<^sub>2 = (\\<exists>\\<phi>. is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> pr_iso_test0 Map.empty Fs\\<^sub>1 Fs\\<^sub>2 =\n                      (\\<exists>\\<phi>.\n                          is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply(subst pr_iso_test0_correct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> Ball (set Fs\\<^sub>1) distinct\n 2. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> Ball (set Fs\\<^sub>2) distinct\n 3. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct Fs\\<^sub>1\n 4. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set Fs\\<^sub>1)\n 5. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct Fs\\<^sub>2\n 6. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set Fs\\<^sub>2)\n 7. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on Map.empty (dom Map.empty)\n 8. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>\\<phi>.\n                          is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and>\n                          Map.empty \\<subseteq>\\<^sub>m\n                          Some \\<circ> \\<phi> \\<and>\n                          inj_on \\<phi>\n                           (dom Map.empty \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1))) =\n                      (\\<exists>\\<phi>.\n                          is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply assumption+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on Map.empty (dom Map.empty)\n 2. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>\\<phi>.\n                          is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and>\n                          Map.empty \\<subseteq>\\<^sub>m\n                          Some \\<circ> \\<phi> \\<and>\n                          inj_on \\<phi>\n                           (dom Map.empty \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1))) =\n                      (\\<exists>\\<phi>.\n                          is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>\\<phi>.\n                          is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<and>\n                          Map.empty \\<subseteq>\\<^sub>m\n                          Some \\<circ> \\<phi> \\<and>\n                          inj_on \\<phi>\n                           (dom Map.empty \\<union>\n                            \\<Union> (set ` set Fs\\<^sub>1))) =\n                      (\\<exists>\\<phi>.\n                          is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply (simp add:is_pr_iso_def is_pr_Iso_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Now we bound the number of rotations needed. We have to exclude\nthe empty face @{term\"[]\"} to be able to restrict the search to\n@{prop\"n < length xs\"} (which would otherwise be vacuous).\\<close>"], ["", "primrec pr_iso_test1 :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> 'a fgraph \\<Rightarrow> 'b fgraph \\<Rightarrow> bool\" where\n  \"pr_iso_test1 m [] Fs\\<^sub>2 = (Fs\\<^sub>2 = [])\"\n| \"pr_iso_test1 m (F\\<^sub>1#Fs\\<^sub>1) Fs\\<^sub>2 =\n   (\\<exists>F\\<^sub>2 \\<in> set Fs\\<^sub>2. length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n      (\\<exists>n < length F\\<^sub>2. let m' = map_of(zip F\\<^sub>1 (rotate n F\\<^sub>2)) in\n          if  m \\<subseteq>\\<^sub>m m ++ m' \\<and> inj_on (m++m') (dom(m++m'))\n          then pr_iso_test1 (m ++ m') Fs\\<^sub>1 (remove1 F\\<^sub>2 Fs\\<^sub>2) else False))\""], ["", "lemma test0_conv_test1:\n \"\\<And>m Fs\\<^sub>2. [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow> pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 = pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m Fs\\<^sub>2.\n       [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n       pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n       pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2", "apply(induct Fs\\<^sub>1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m Fs\\<^sub>2.\n       [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n       pr_iso_test1 m [] Fs\\<^sub>2 = pr_iso_test0 m [] Fs\\<^sub>2\n 2. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test1 m (a # Fs\\<^sub>1) Fs\\<^sub>2 =\n                         pr_iso_test0 m (a # Fs\\<^sub>1) Fs\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test1 m (a # Fs\\<^sub>1) Fs\\<^sub>2 =\n                         pr_iso_test0 m (a # Fs\\<^sub>1) Fs\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                             length a = length F\\<^sub>2 \\<and>\n                             (\\<exists>n<length F\\<^sub>2.\n                                 let m' =\n map_of (zip a (rotate n F\\<^sub>2))\n                                 in (m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                     inj_on (m ++ m')\n(dom m' \\<union> dom m) \\<longrightarrow>\n                                     pr_iso_test0 (m ++ m') Fs\\<^sub>1\n(remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                    m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                    inj_on (m ++ m')\n                                     (dom m' \\<union> dom m))) =\n                         (\\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                             length a = length F\\<^sub>2 \\<and>\n                             (\\<exists>n.\n                                 let m' =\n map_of (zip a (rotate n F\\<^sub>2))\n                                 in (m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                     inj_on (m ++ m')\n(dom m' \\<union> dom m) \\<longrightarrow>\n                                     pr_iso_test0 (m ++ m') Fs\\<^sub>1\n(remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                    m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                    inj_on (m ++ m')\n                                     (dom m' \\<union> dom m)))", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2;\n        \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n           length a = length F\\<^sub>2 \\<and>\n           (\\<exists>n<length F\\<^sub>2.\n               let m' = map_of (zip a (rotate n F\\<^sub>2))\n               in (m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                   inj_on (m ++ m')\n                    (dom m' \\<union> dom m) \\<longrightarrow>\n                   pr_iso_test0 (m ++ m') Fs\\<^sub>1\n                    (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                  m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                  inj_on (m ++ m') (dom m' \\<union> dom m))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length a = length F\\<^sub>2 \\<and>\n                            (\\<exists>n.\n                                let m' = map_of (zip a (rotate n F\\<^sub>2))\n                                in (m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                    inj_on (m ++ m')\n                                     (dom m' \\<union>\ndom m) \\<longrightarrow>\n                                    pr_iso_test0 (m ++ m') Fs\\<^sub>1\n                                     (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                   m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                   inj_on (m ++ m') (dom m' \\<union> dom m))\n 2. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2;\n        \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n           length a = length F\\<^sub>2 \\<and>\n           (\\<exists>n.\n               let m' = map_of (zip a (rotate n F\\<^sub>2))\n               in (m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                   inj_on (m ++ m')\n                    (dom m' \\<union> dom m) \\<longrightarrow>\n                   pr_iso_test0 (m ++ m') Fs\\<^sub>1\n                    (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                  m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                  inj_on (m ++ m') (dom m' \\<union> dom m))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length a = length F\\<^sub>2 \\<and>\n                            (\\<exists>n<length F\\<^sub>2.\n                                let m' = map_of (zip a (rotate n F\\<^sub>2))\n                                in (m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                    inj_on (m ++ m')\n                                     (dom m' \\<union>\ndom m) \\<longrightarrow>\n                                    pr_iso_test0 (m ++ m') Fs\\<^sub>1\n                                     (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                   m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                   inj_on (m ++ m') (dom m' \\<union> dom m))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2;\n        \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n           length a = length F\\<^sub>2 \\<and>\n           (\\<exists>n.\n               let m' = map_of (zip a (rotate n F\\<^sub>2))\n               in (m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                   inj_on (m ++ m')\n                    (dom m' \\<union> dom m) \\<longrightarrow>\n                   pr_iso_test0 (m ++ m') Fs\\<^sub>1\n                    (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                  m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                  inj_on (m ++ m') (dom m' \\<union> dom m))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2\\<in>set Fs\\<^sub>2.\n                            length a = length F\\<^sub>2 \\<and>\n                            (\\<exists>n<length F\\<^sub>2.\n                                let m' = map_of (zip a (rotate n F\\<^sub>2))\n                                in (m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                    inj_on (m ++ m')\n                                     (dom m' \\<union>\ndom m) \\<longrightarrow>\n                                    pr_iso_test0 (m ++ m') Fs\\<^sub>1\n                                     (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                                   m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                   inj_on (m ++ m') (dom m' \\<union> dom m))", "apply (clarsimp simp:Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<^sub>2'\\<in>set Fs\\<^sub>2.\n                            length F\\<^sub>2 = length F\\<^sub>2' \\<and>\n                            (\\<exists>n<length F\\<^sub>2'.\n                                (m \\<subseteq>\\<^sub>m\n                                 m ++\n                                 map_of (zip a (rotate n F\\<^sub>2')) \\<and>\n                                 inj_on\n                                  (m ++\n                                   map_of (zip a (rotate n F\\<^sub>2')))\n                                  (dom (map_of\n   (zip a (rotate n F\\<^sub>2'))) \\<union>\n                                   dom m) \\<longrightarrow>\n                                 pr_iso_test0\n                                  (m ++\n                                   map_of (zip a (rotate n F\\<^sub>2')))\n                                  Fs\\<^sub>1\n                                  (remove1 F\\<^sub>2' Fs\\<^sub>2)) \\<and>\n                                m \\<subseteq>\\<^sub>m\n                                m ++\n                                map_of (zip a (rotate n F\\<^sub>2')) \\<and>\n                                inj_on\n                                 (m ++ map_of (zip a (rotate n F\\<^sub>2')))\n                                 (dom (map_of\n  (zip a (rotate n F\\<^sub>2'))) \\<union>\n                                  dom m))", "apply(rule_tac x = F\\<^sub>2 in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>2 \\<and>\n                         (\\<exists>n<length F\\<^sub>2.\n                             (m \\<subseteq>\\<^sub>m\n                              m ++\n                              map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                              inj_on\n                               (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                               (dom (map_of\n(zip a (rotate n F\\<^sub>2))) \\<union>\n                                dom m) \\<longrightarrow>\n                              pr_iso_test0\n                               (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                               Fs\\<^sub>1\n                               (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             m ++ map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                             inj_on\n                              (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                              (dom (map_of\n                                     (zip a (rotate n F\\<^sub>2))) \\<union>\n                               dom m))\n 2. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<in> set Fs\\<^sub>2", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<in> set Fs\\<^sub>2\n 2. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>2 \\<and>\n                         (\\<exists>n<length F\\<^sub>2.\n                             (m \\<subseteq>\\<^sub>m\n                              m ++\n                              map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                              inj_on\n                               (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                               (dom (map_of\n(zip a (rotate n F\\<^sub>2))) \\<union>\n                                dom m) \\<longrightarrow>\n                              pr_iso_test0\n                               (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                               Fs\\<^sub>1\n                               (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             m ++ map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                             inj_on\n                              (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                              (dom (map_of\n                                     (zip a (rotate n F\\<^sub>2))) \\<union>\n                               dom m))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> length F\\<^sub>2 = length F\\<^sub>2 \\<and>\n                         (\\<exists>n<length F\\<^sub>2.\n                             (m \\<subseteq>\\<^sub>m\n                              m ++\n                              map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                              inj_on\n                               (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                               (dom (map_of\n(zip a (rotate n F\\<^sub>2))) \\<union>\n                                dom m) \\<longrightarrow>\n                              pr_iso_test0\n                               (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                               Fs\\<^sub>1\n                               (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                             m \\<subseteq>\\<^sub>m\n                             m ++ map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                             inj_on\n                              (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                              (dom (map_of\n                                     (zip a (rotate n F\\<^sub>2))) \\<union>\n                               dom m))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length F\\<^sub>2.\n                            (m \\<subseteq>\\<^sub>m\n                             m ++ map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                             inj_on\n                              (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                              (set a \\<union> dom m) \\<longrightarrow>\n                             pr_iso_test0\n                              (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                              Fs\\<^sub>1\n                              (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                            m \\<subseteq>\\<^sub>m\n                            m ++ map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                            inj_on\n                             (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                             (set a \\<union> dom m)", "apply(subgoal_tac \"F\\<^sub>2 \\<noteq> []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m);\n        F\\<^sub>2 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length F\\<^sub>2.\n                            (m \\<subseteq>\\<^sub>m\n                             m ++ map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                             inj_on\n                              (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                              (set a \\<union> dom m) \\<longrightarrow>\n                             pr_iso_test0\n                              (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                              Fs\\<^sub>1\n                              (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                            m \\<subseteq>\\<^sub>m\n                            m ++ map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                            inj_on\n                             (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                             (set a \\<union> dom m)\n 2. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<noteq> []", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m)\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>2 \\<noteq> []\n 2. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m);\n        F\\<^sub>2 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length F\\<^sub>2.\n                            (m \\<subseteq>\\<^sub>m\n                             m ++ map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                             inj_on\n                              (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                              (set a \\<union> dom m) \\<longrightarrow>\n                             pr_iso_test0\n                              (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                              Fs\\<^sub>1\n                              (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                            m \\<subseteq>\\<^sub>m\n                            m ++ map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                            inj_on\n                             (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                             (set a \\<union> dom m)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m);\n        F\\<^sub>2 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n<length F\\<^sub>2.\n                            (m \\<subseteq>\\<^sub>m\n                             m ++ map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                             inj_on\n                              (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                              (set a \\<union> dom m) \\<longrightarrow>\n                             pr_iso_test0\n                              (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                              Fs\\<^sub>1\n                              (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                            m \\<subseteq>\\<^sub>m\n                            m ++ map_of (zip a (rotate n F\\<^sub>2)) \\<and>\n                            inj_on\n                             (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n                             (set a \\<union> dom m)", "apply(rule_tac x = \"n mod length F\\<^sub>2\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Fs\\<^sub>1 m Fs\\<^sub>2 F\\<^sub>2 n.\n       \\<lbrakk>\\<And>m Fs\\<^sub>2.\n                   [] \\<notin> set Fs\\<^sub>2 \\<Longrightarrow>\n                   pr_iso_test1 m Fs\\<^sub>1 Fs\\<^sub>2 =\n                   pr_iso_test0 m Fs\\<^sub>1 Fs\\<^sub>2;\n        [] \\<notin> set Fs\\<^sub>2; F\\<^sub>2 \\<in> set Fs\\<^sub>2;\n        length a = length F\\<^sub>2;\n        pr_iso_test0 (m ++ map_of (zip a (rotate n F\\<^sub>2))) Fs\\<^sub>1\n         (remove1 F\\<^sub>2 Fs\\<^sub>2);\n        m \\<subseteq>\\<^sub>m m ++ map_of (zip a (rotate n F\\<^sub>2));\n        inj_on (m ++ map_of (zip a (rotate n F\\<^sub>2)))\n         (set a \\<union> dom m);\n        F\\<^sub>2 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> n mod length F\\<^sub>2 < length F\\<^sub>2 \\<and>\n                         (m \\<subseteq>\\<^sub>m\n                          m ++\n                          map_of\n                           (zip a\n                             (rotate (n mod length F\\<^sub>2)\n                               F\\<^sub>2)) \\<and>\n                          inj_on\n                           (m ++\n                            map_of\n                             (zip a\n                               (rotate (n mod length F\\<^sub>2) F\\<^sub>2)))\n                           (set a \\<union> dom m) \\<longrightarrow>\n                          pr_iso_test0\n                           (m ++\n                            map_of\n                             (zip a\n                               (rotate (n mod length F\\<^sub>2) F\\<^sub>2)))\n                           Fs\\<^sub>1 (remove1 F\\<^sub>2 Fs\\<^sub>2)) \\<and>\n                         m \\<subseteq>\\<^sub>m\n                         m ++\n                         map_of\n                          (zip a\n                            (rotate (n mod length F\\<^sub>2)\n                              F\\<^sub>2)) \\<and>\n                         inj_on\n                          (m ++\n                           map_of\n                            (zip a\n                              (rotate (n mod length F\\<^sub>2) F\\<^sub>2)))\n                          (set a \\<union> dom m)", "apply(simp add:rotate_conv_mod[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Thus correctness carries over to \\<open>pr_iso_test1\\<close>:\\<close>"], ["", "corollary pr_iso_test1_corr:\n \"\\<lbrakk> \\<forall>F\\<in>set Fs\\<^sub>1. distinct F; \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n   distinct Fs\\<^sub>1; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>1);\n   distinct Fs\\<^sub>2; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2) \\<rbrakk> \\<Longrightarrow>\n       pr_iso_test1 Map.empty Fs\\<^sub>1 Fs\\<^sub>2 = (\\<exists>\\<phi>. is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> pr_iso_test1 Map.empty Fs\\<^sub>1 Fs\\<^sub>2 =\n                      (\\<exists>\\<phi>.\n                          is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "by(simp add: test0_conv_test1 pr_iso_test0_corr)"], ["", "subsubsection\\<open>Implementing maps by lists\\<close>"], ["", "text\\<open>The representation are lists of pairs with no repetition in the\nfirst or second component.\\<close>"], ["", "definition oneone :: \"('a * 'b)list \\<Rightarrow> bool\" where\n\"oneone xys  \\<equiv>  distinct(map fst xys) \\<and> distinct(map snd xys)\""], ["", "declare oneone_def[simp]"], ["", "type_synonym\n  ('a,'b)tester = \"('a * 'b)list \\<Rightarrow> ('a * 'b)list \\<Rightarrow> bool\""], ["", "type_synonym\n  ('a,'b)merger = \"('a * 'b)list \\<Rightarrow> ('a * 'b)list \\<Rightarrow> ('a * 'b)list\""], ["", "primrec pr_iso_test2 :: \"('a,'b)tester \\<Rightarrow> ('a,'b)merger \\<Rightarrow>\n                ('a * 'b)list \\<Rightarrow> 'a fgraph \\<Rightarrow> 'b fgraph \\<Rightarrow> bool\" where\n  \"pr_iso_test2 tst mrg I [] Fs\\<^sub>2 = (Fs\\<^sub>2 = [])\"\n| \"pr_iso_test2 tst mrg I (F\\<^sub>1#Fs\\<^sub>1) Fs\\<^sub>2 =\n   (\\<exists>F\\<^sub>2 \\<in> set Fs\\<^sub>2. length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n      (\\<exists>n < length F\\<^sub>2. let I' = zip F\\<^sub>1 (rotate n F\\<^sub>2) in\n          if  tst I' I\n          then pr_iso_test2 tst mrg (mrg I' I) Fs\\<^sub>1 (remove1 F\\<^sub>2 Fs\\<^sub>2) else False))\""], ["", "lemma notin_range_map_of:\n \"y \\<notin> snd ` set xys \\<Longrightarrow> Some y \\<notin> range(map_of xys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<notin> snd ` set xys \\<Longrightarrow>\n    Some y \\<notin> range (map_of xys)", "apply(induct xys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. y \\<notin> snd ` set [] \\<Longrightarrow>\n    Some y \\<notin> range (map_of [])\n 2. \\<And>a xys.\n       \\<lbrakk>y \\<notin> snd ` set xys \\<Longrightarrow>\n                Some y \\<notin> range (map_of xys);\n        y \\<notin> snd ` set (a # xys)\\<rbrakk>\n       \\<Longrightarrow> Some y \\<notin> range (map_of (a # xys))", "apply (simp add:image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xys.\n       \\<lbrakk>y \\<notin> snd ` set xys \\<Longrightarrow>\n                Some y \\<notin> range (map_of xys);\n        y \\<notin> snd ` set (a # xys)\\<rbrakk>\n       \\<Longrightarrow> Some y \\<notin> range (map_of (a # xys))", "apply(clarsimp split:if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inj_on_map_upd:\n  \"\\<lbrakk> inj_on m (dom m); Some y \\<notin> range m \\<rbrakk> \\<Longrightarrow> inj_on (m(x\\<mapsto>y)) (dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj_on m (dom m); Some y \\<notin> range m\\<rbrakk>\n    \\<Longrightarrow> inj_on (m(x \\<mapsto> y)) (dom m)", "apply(simp add:inj_on_def dom_def image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                (\\<exists>y. m x = Some y) \\<longrightarrow>\n                (\\<forall>y.\n                    (\\<exists>ya. m y = Some ya) \\<longrightarrow>\n                    m x = m y \\<longrightarrow> x = y);\n     \\<forall>x. Some y \\<noteq> m x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         xa \\<noteq> x \\<longrightarrow>\n                         (\\<exists>y. m xa = Some y) \\<longrightarrow>\n                         (\\<exists>y. m x = Some y) \\<longrightarrow>\n                         m xa \\<noteq> Some y", "apply (blast intro:sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]:\n \"distinct(map snd xys) \\<Longrightarrow> inj_on (map_of xys) (dom(map_of xys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map snd xys) \\<Longrightarrow>\n    inj_on (map_of xys) (dom (map_of xys))", "apply(induct xys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map snd []) \\<Longrightarrow>\n    inj_on (map_of []) (dom (map_of []))\n 2. \\<And>a xys.\n       \\<lbrakk>distinct (map snd xys) \\<Longrightarrow>\n                inj_on (map_of xys) (dom (map_of xys));\n        distinct (map snd (a # xys))\\<rbrakk>\n       \\<Longrightarrow> inj_on (map_of (a # xys)) (dom (map_of (a # xys)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xys.\n       \\<lbrakk>distinct (map snd xys) \\<Longrightarrow>\n                inj_on (map_of xys) (dom (map_of xys));\n        distinct (map snd (a # xys))\\<rbrakk>\n       \\<Longrightarrow> inj_on (map_of (a # xys)) (dom (map_of (a # xys)))", "apply (simp add: notin_range_map_of inj_on_map_upd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xys.\n       \\<lbrakk>inj_on (map_of xys) (dom (map_of xys));\n        snd a \\<notin> snd ` set xys \\<and> distinct (map snd xys)\\<rbrakk>\n       \\<Longrightarrow> Some (snd a)\n                         \\<notin> map_of xys ` (dom (map_of xys) - {fst a})", "apply(clarsimp simp add:image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xys x y.\n       \\<lbrakk>inj_on (map_of xys) (dom (map_of xys));\n        map_of xys x = Some y; \\<forall>x\\<in>set xys. y \\<noteq> snd x;\n        distinct (map snd xys); x \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule map_of_SomeD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xys x y.\n       \\<lbrakk>inj_on (map_of xys) (dom (map_of xys));\n        \\<forall>x\\<in>set xys. y \\<noteq> snd x; distinct (map snd xys);\n        x \\<noteq> a; (x, y) \\<in> set xys\\<rbrakk>\n       \\<Longrightarrow> False", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lem: \"Ball (set xs) P \\<Longrightarrow> Ball (set (remove1 x xs)) P = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set xs) P \\<Longrightarrow> Ball (set (remove1 x xs)) P = True", "by(induct xs) simp_all"], ["", "lemma pr_iso_test2_conv_1:\n  \"\\<And>I Fs\\<^sub>2.\n  \\<lbrakk> \\<forall>I I'. oneone I \\<longrightarrow> oneone I' \\<longrightarrow>\n           tst I' I = (let m = map_of I; m' = map_of I'\n                       in m \\<subseteq>\\<^sub>m m ++ m' \\<and> inj_on (m++m') (dom(m++m')));\n   \\<forall>I I'. oneone I \\<longrightarrow> oneone I' \\<longrightarrow> tst I' I\n          \\<longrightarrow> map_of(mrg I' I) = map_of I ++ map_of I';\n   \\<forall>I I'. oneone I \\<and> oneone I' \\<longrightarrow> tst I' I \\<longrightarrow> oneone (mrg I' I);\n   oneone I;\n   \\<forall>F \\<in> set Fs\\<^sub>1. distinct F; \\<forall>F \\<in> set Fs\\<^sub>2. distinct F \\<rbrakk> \\<Longrightarrow>\n  pr_iso_test2 tst mrg I Fs\\<^sub>1 Fs\\<^sub>2 = pr_iso_test1 (map_of I) Fs\\<^sub>1 Fs\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I Fs\\<^sub>2.\n       \\<lbrakk>\\<forall>I I'.\n                   oneone I \\<longrightarrow>\n                   oneone I' \\<longrightarrow>\n                   tst I' I =\n                   (let m = map_of I; m' = map_of I'\n                    in m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                       inj_on (m ++ m') (dom (m ++ m')));\n        \\<forall>I I'.\n           oneone I \\<longrightarrow>\n           oneone I' \\<longrightarrow>\n           tst I' I \\<longrightarrow>\n           map_of (mrg I' I) = map_of I ++ map_of I';\n        \\<forall>I I'.\n           oneone I \\<and> oneone I' \\<longrightarrow>\n           tst I' I \\<longrightarrow> oneone (mrg I' I);\n        oneone I; \\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n        \\<forall>F\\<in>set Fs\\<^sub>2. distinct F\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test2 tst mrg I Fs\\<^sub>1 Fs\\<^sub>2 =\n                         pr_iso_test1 (map_of I) Fs\\<^sub>1 Fs\\<^sub>2", "apply(induct Fs\\<^sub>1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I Fs\\<^sub>2.\n       \\<lbrakk>\\<forall>I I'.\n                   oneone I \\<longrightarrow>\n                   oneone I' \\<longrightarrow>\n                   tst I' I =\n                   (let m = map_of I; m' = map_of I'\n                    in m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                       inj_on (m ++ m') (dom (m ++ m')));\n        \\<forall>I I'.\n           oneone I \\<longrightarrow>\n           oneone I' \\<longrightarrow>\n           tst I' I \\<longrightarrow>\n           map_of (mrg I' I) = map_of I ++ map_of I';\n        \\<forall>I I'.\n           oneone I \\<and> oneone I' \\<longrightarrow>\n           tst I' I \\<longrightarrow> oneone (mrg I' I);\n        oneone I; Ball (set []) distinct;\n        Ball (set Fs\\<^sub>2) distinct\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test2 tst mrg I [] Fs\\<^sub>2 =\n                         pr_iso_test1 (map_of I) [] Fs\\<^sub>2\n 2. \\<And>a Fs\\<^sub>1 I Fs\\<^sub>2.\n       \\<lbrakk>\\<And>I Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>I I'.\n                               oneone I \\<longrightarrow>\n                               oneone I' \\<longrightarrow>\n                               tst I' I =\n                               (let m = map_of I; m' = map_of I'\n                                in m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                   inj_on (m ++ m') (dom (m ++ m')));\n                    \\<forall>I I'.\n                       oneone I \\<longrightarrow>\n                       oneone I' \\<longrightarrow>\n                       tst I' I \\<longrightarrow>\n                       map_of (mrg I' I) = map_of I ++ map_of I';\n                    \\<forall>I I'.\n                       oneone I \\<and> oneone I' \\<longrightarrow>\n                       tst I' I \\<longrightarrow> oneone (mrg I' I);\n                    oneone I; Ball (set Fs\\<^sub>1) distinct;\n                    Ball (set Fs\\<^sub>2) distinct\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test2 tst mrg I Fs\\<^sub>1\nFs\\<^sub>2 =\n                                     pr_iso_test1 (map_of I) Fs\\<^sub>1\nFs\\<^sub>2;\n        \\<forall>I I'.\n           oneone I \\<longrightarrow>\n           oneone I' \\<longrightarrow>\n           tst I' I =\n           (let m = map_of I; m' = map_of I'\n            in m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n               inj_on (m ++ m') (dom (m ++ m')));\n        \\<forall>I I'.\n           oneone I \\<longrightarrow>\n           oneone I' \\<longrightarrow>\n           tst I' I \\<longrightarrow>\n           map_of (mrg I' I) = map_of I ++ map_of I';\n        \\<forall>I I'.\n           oneone I \\<and> oneone I' \\<longrightarrow>\n           tst I' I \\<longrightarrow> oneone (mrg I' I);\n        oneone I; Ball (set (a # Fs\\<^sub>1)) distinct;\n        Ball (set Fs\\<^sub>2) distinct\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test2 tst mrg I (a # Fs\\<^sub>1)\n                          Fs\\<^sub>2 =\n                         pr_iso_test1 (map_of I) (a # Fs\\<^sub>1) Fs\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Fs\\<^sub>1 I Fs\\<^sub>2.\n       \\<lbrakk>\\<And>I Fs\\<^sub>2.\n                   \\<lbrakk>\\<forall>I I'.\n                               oneone I \\<longrightarrow>\n                               oneone I' \\<longrightarrow>\n                               tst I' I =\n                               (let m = map_of I; m' = map_of I'\n                                in m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                                   inj_on (m ++ m') (dom (m ++ m')));\n                    \\<forall>I I'.\n                       oneone I \\<longrightarrow>\n                       oneone I' \\<longrightarrow>\n                       tst I' I \\<longrightarrow>\n                       map_of (mrg I' I) = map_of I ++ map_of I';\n                    \\<forall>I I'.\n                       oneone I \\<and> oneone I' \\<longrightarrow>\n                       tst I' I \\<longrightarrow> oneone (mrg I' I);\n                    oneone I; Ball (set Fs\\<^sub>1) distinct;\n                    Ball (set Fs\\<^sub>2) distinct\\<rbrakk>\n                   \\<Longrightarrow> pr_iso_test2 tst mrg I Fs\\<^sub>1\nFs\\<^sub>2 =\n                                     pr_iso_test1 (map_of I) Fs\\<^sub>1\nFs\\<^sub>2;\n        \\<forall>I I'.\n           oneone I \\<longrightarrow>\n           oneone I' \\<longrightarrow>\n           tst I' I =\n           (let m = map_of I; m' = map_of I'\n            in m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n               inj_on (m ++ m') (dom (m ++ m')));\n        \\<forall>I I'.\n           oneone I \\<longrightarrow>\n           oneone I' \\<longrightarrow>\n           tst I' I \\<longrightarrow>\n           map_of (mrg I' I) = map_of I ++ map_of I';\n        \\<forall>I I'.\n           oneone I \\<and> oneone I' \\<longrightarrow>\n           tst I' I \\<longrightarrow> oneone (mrg I' I);\n        oneone I; Ball (set (a # Fs\\<^sub>1)) distinct;\n        Ball (set Fs\\<^sub>2) distinct\\<rbrakk>\n       \\<Longrightarrow> pr_iso_test2 tst mrg I (a # Fs\\<^sub>1)\n                          Fs\\<^sub>2 =\n                         pr_iso_test1 (map_of I) (a # Fs\\<^sub>1) Fs\\<^sub>2", "apply(simp add:Let_def lem inj_on_map_of_zip del: mod_less cong: conj_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>A simple implementation\\<close>"], ["", "definition compat :: \"('a,'b)tester\" where\n \"compat I I' ==\n  \\<forall>(x,y) \\<in> set I. \\<forall>(x',y') \\<in> set I'. (x = x') = (y = y')\""], ["", "lemma image_map_upd:\n  \"x \\<notin> dom m \\<Longrightarrow> m(x\\<mapsto>y) ` A = m ` (A-{x}) \\<union> (if x \\<in> A then {Some y} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom m \\<Longrightarrow>\n    m(x \\<mapsto> y) ` A =\n    m ` (A - {x}) \\<union> (if x \\<in> A then {Some y} else {})", "by(auto simp:image_def dom_def)"], ["", "lemma image_map_of_conv_Image:\n \"\\<And>A. \\<lbrakk> distinct(map fst xys) \\<rbrakk>\n \\<Longrightarrow> map_of xys ` A = Some ` (set xys `` A) \\<union> (if A \\<subseteq> fst ` set xys then {} else {None})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       distinct (map fst xys) \\<Longrightarrow>\n       map_of xys ` A =\n       Some ` set xys `` A \\<union>\n       (if A \\<subseteq> fst ` set xys then {} else {None})", "supply image_cong_simp [cong del]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       distinct (map fst xys) \\<Longrightarrow>\n       map_of xys ` A =\n       Some ` set xys `` A \\<union>\n       (if A \\<subseteq> fst ` set xys then {} else {None})", "apply (induct xys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A.\n       distinct (map fst []) \\<Longrightarrow>\n       map_of [] ` A =\n       Some ` set [] `` A \\<union>\n       (if A \\<subseteq> fst ` set [] then {} else {None})\n 2. \\<And>a xys A.\n       \\<lbrakk>\\<And>A.\n                   distinct (map fst xys) \\<Longrightarrow>\n                   map_of xys ` A =\n                   Some ` set xys `` A \\<union>\n                   (if A \\<subseteq> fst ` set xys then {} else {None});\n        distinct (map fst (a # xys))\\<rbrakk>\n       \\<Longrightarrow> map_of (a # xys) ` A =\n                         Some ` set (a # xys) `` A \\<union>\n                         (if A \\<subseteq> fst ` set (a # xys) then {}\n                          else {None})", "apply (simp add:image_def Image_def Collect_conv_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xys A.\n       \\<lbrakk>\\<And>A.\n                   distinct (map fst xys) \\<Longrightarrow>\n                   map_of xys ` A =\n                   Some ` set xys `` A \\<union>\n                   (if A \\<subseteq> fst ` set xys then {} else {None});\n        distinct (map fst (a # xys))\\<rbrakk>\n       \\<Longrightarrow> map_of (a # xys) ` A =\n                         Some ` set (a # xys) `` A \\<union>\n                         (if A \\<subseteq> fst ` set (a # xys) then {}\n                          else {None})", "apply (simp add:image_map_upd dom_map_of_conv_image_fst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xys A.\n       \\<lbrakk>\\<And>A.\n                   map_of xys ` A =\n                   Some ` set xys `` A \\<union>\n                   (if A \\<subseteq> fst ` set xys then {} else {None});\n        fst a \\<notin> fst ` set xys \\<and> distinct (map fst xys)\\<rbrakk>\n       \\<Longrightarrow> (A - {fst a}\n                          \\<subseteq> fst ` set xys \\<longrightarrow>\n                          (A \\<subseteq> fst ` set xys \\<longrightarrow>\n                           (fst a \\<in> A \\<longrightarrow>\n                            (A \\<subseteq> insert (fst a)\n      (fst ` set xys) \\<longrightarrow>\n                             insert (Some (snd a))\n                              (Some ` set xys `` (A - {fst a})) =\n                             Some ` insert a (set xys) `` A) \\<and>\n                            (\\<not> A \\<subseteq> insert (fst a)\n             (fst ` set xys) \\<longrightarrow>\n                             insert (Some (snd a))\n                              (Some ` set xys `` (A - {fst a})) =\n                             insert None\n                              (Some ` insert a (set xys) `` A))) \\<and>\n                           (fst a \\<notin> A \\<longrightarrow>\n                            (A \\<subseteq> insert (fst a)\n      (fst ` set xys) \\<longrightarrow>\n                             Some ` set xys `` A =\n                             Some ` insert a (set xys) `` A) \\<and>\n                            (\\<not> A \\<subseteq> insert (fst a)\n             (fst ` set xys) \\<longrightarrow>\n                             Some ` set xys `` A =\n                             insert None\n                              (Some ` insert a (set xys) `` A)))) \\<and>\n                          (\\<not> A \\<subseteq> fst `\n          set xys \\<longrightarrow>\n                           (fst a \\<in> A \\<longrightarrow>\n                            (A \\<subseteq> insert (fst a)\n      (fst ` set xys) \\<longrightarrow>\n                             insert (Some (snd a))\n                              (Some ` set xys `` (A - {fst a})) =\n                             Some ` insert a (set xys) `` A) \\<and>\n                            (\\<not> A \\<subseteq> insert (fst a)\n             (fst ` set xys) \\<longrightarrow>\n                             insert (Some (snd a))\n                              (Some ` set xys `` (A - {fst a})) =\n                             insert None\n                              (Some ` insert a (set xys) `` A))) \\<and>\n                           (fst a \\<notin> A \\<longrightarrow>\n                            (A \\<subseteq> insert (fst a)\n      (fst ` set xys) \\<longrightarrow>\n                             insert None (Some ` set xys `` A) =\n                             Some ` insert a (set xys) `` A) \\<and>\n                            (\\<not> A \\<subseteq> insert (fst a)\n             (fst ` set xys) \\<longrightarrow>\n                             insert None (Some ` set xys `` A) =\n                             insert None\n                              (Some ` insert a (set xys) `` A))))) \\<and>\n                         (\\<not> A - {fst a}\n                                 \\<subseteq> fst ` set xys \\<longrightarrow>\n                          (A \\<subseteq> fst ` set xys \\<longrightarrow>\n                           (fst a \\<in> A \\<longrightarrow>\n                            (A \\<subseteq> insert (fst a)\n      (fst ` set xys) \\<longrightarrow>\n                             insert (Some (snd a))\n                              (insert None\n                                (Some ` set xys `` (A - {fst a}))) =\n                             Some ` insert a (set xys) `` A) \\<and>\n                            (\\<not> A \\<subseteq> insert (fst a)\n             (fst ` set xys) \\<longrightarrow>\n                             insert (Some (snd a))\n                              (insert None\n                                (Some ` set xys `` (A - {fst a}))) =\n                             insert None\n                              (Some ` insert a (set xys) `` A))) \\<and>\n                           (fst a \\<notin> A \\<longrightarrow>\n                            (A \\<subseteq> insert (fst a)\n      (fst ` set xys) \\<longrightarrow>\n                             Some ` set xys `` A =\n                             Some ` insert a (set xys) `` A) \\<and>\n                            (\\<not> A \\<subseteq> insert (fst a)\n             (fst ` set xys) \\<longrightarrow>\n                             Some ` set xys `` A =\n                             insert None\n                              (Some ` insert a (set xys) `` A)))) \\<and>\n                          (\\<not> A \\<subseteq> fst `\n          set xys \\<longrightarrow>\n                           (fst a \\<in> A \\<longrightarrow>\n                            (A \\<subseteq> insert (fst a)\n      (fst ` set xys) \\<longrightarrow>\n                             insert (Some (snd a))\n                              (insert None\n                                (Some ` set xys `` (A - {fst a}))) =\n                             Some ` insert a (set xys) `` A) \\<and>\n                            (\\<not> A \\<subseteq> insert (fst a)\n             (fst ` set xys) \\<longrightarrow>\n                             insert (Some (snd a))\n                              (insert None\n                                (Some ` set xys `` (A - {fst a}))) =\n                             insert None\n                              (Some ` insert a (set xys) `` A))) \\<and>\n                           (fst a \\<notin> A \\<longrightarrow>\n                            (A \\<subseteq> insert (fst a)\n      (fst ` set xys) \\<longrightarrow>\n                             insert None (Some ` set xys `` A) =\n                             Some ` insert a (set xys) `` A) \\<and>\n                            (\\<not> A \\<subseteq> insert (fst a)\n             (fst ` set xys) \\<longrightarrow>\n                             insert None (Some ` set xys `` A) =\n                             insert None\n                              (Some ` insert a (set xys) `` A)))))", "apply(erule thin_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xys A.\n       fst a \\<notin> fst ` set xys \\<and>\n       distinct (map fst xys) \\<Longrightarrow>\n       (A - {fst a} \\<subseteq> fst ` set xys \\<longrightarrow>\n        (A \\<subseteq> fst ` set xys \\<longrightarrow>\n         (fst a \\<in> A \\<longrightarrow>\n          (A \\<subseteq> insert (fst a) (fst ` set xys) \\<longrightarrow>\n           insert (Some (snd a)) (Some ` set xys `` (A - {fst a})) =\n           Some ` insert a (set xys) `` A) \\<and>\n          (\\<not> A \\<subseteq> insert (fst a)\n                                 (fst ` set xys) \\<longrightarrow>\n           insert (Some (snd a)) (Some ` set xys `` (A - {fst a})) =\n           insert None (Some ` insert a (set xys) `` A))) \\<and>\n         (fst a \\<notin> A \\<longrightarrow>\n          (A \\<subseteq> insert (fst a) (fst ` set xys) \\<longrightarrow>\n           Some ` set xys `` A = Some ` insert a (set xys) `` A) \\<and>\n          (\\<not> A \\<subseteq> insert (fst a)\n                                 (fst ` set xys) \\<longrightarrow>\n           Some ` set xys `` A =\n           insert None (Some ` insert a (set xys) `` A)))) \\<and>\n        (\\<not> A \\<subseteq> fst ` set xys \\<longrightarrow>\n         (fst a \\<in> A \\<longrightarrow>\n          (A \\<subseteq> insert (fst a) (fst ` set xys) \\<longrightarrow>\n           insert (Some (snd a)) (Some ` set xys `` (A - {fst a})) =\n           Some ` insert a (set xys) `` A) \\<and>\n          (\\<not> A \\<subseteq> insert (fst a)\n                                 (fst ` set xys) \\<longrightarrow>\n           insert (Some (snd a)) (Some ` set xys `` (A - {fst a})) =\n           insert None (Some ` insert a (set xys) `` A))) \\<and>\n         (fst a \\<notin> A \\<longrightarrow>\n          (A \\<subseteq> insert (fst a) (fst ` set xys) \\<longrightarrow>\n           insert None (Some ` set xys `` A) =\n           Some ` insert a (set xys) `` A) \\<and>\n          (\\<not> A \\<subseteq> insert (fst a)\n                                 (fst ` set xys) \\<longrightarrow>\n           insert None (Some ` set xys `` A) =\n           insert None (Some ` insert a (set xys) `` A))))) \\<and>\n       (\\<not> A - {fst a} \\<subseteq> fst ` set xys \\<longrightarrow>\n        (A \\<subseteq> fst ` set xys \\<longrightarrow>\n         (fst a \\<in> A \\<longrightarrow>\n          (A \\<subseteq> insert (fst a) (fst ` set xys) \\<longrightarrow>\n           insert (Some (snd a))\n            (insert None (Some ` set xys `` (A - {fst a}))) =\n           Some ` insert a (set xys) `` A) \\<and>\n          (\\<not> A \\<subseteq> insert (fst a)\n                                 (fst ` set xys) \\<longrightarrow>\n           insert (Some (snd a))\n            (insert None (Some ` set xys `` (A - {fst a}))) =\n           insert None (Some ` insert a (set xys) `` A))) \\<and>\n         (fst a \\<notin> A \\<longrightarrow>\n          (A \\<subseteq> insert (fst a) (fst ` set xys) \\<longrightarrow>\n           Some ` set xys `` A = Some ` insert a (set xys) `` A) \\<and>\n          (\\<not> A \\<subseteq> insert (fst a)\n                                 (fst ` set xys) \\<longrightarrow>\n           Some ` set xys `` A =\n           insert None (Some ` insert a (set xys) `` A)))) \\<and>\n        (\\<not> A \\<subseteq> fst ` set xys \\<longrightarrow>\n         (fst a \\<in> A \\<longrightarrow>\n          (A \\<subseteq> insert (fst a) (fst ` set xys) \\<longrightarrow>\n           insert (Some (snd a))\n            (insert None (Some ` set xys `` (A - {fst a}))) =\n           Some ` insert a (set xys) `` A) \\<and>\n          (\\<not> A \\<subseteq> insert (fst a)\n                                 (fst ` set xys) \\<longrightarrow>\n           insert (Some (snd a))\n            (insert None (Some ` set xys `` (A - {fst a}))) =\n           insert None (Some ` insert a (set xys) `` A))) \\<and>\n         (fst a \\<notin> A \\<longrightarrow>\n          (A \\<subseteq> insert (fst a) (fst ` set xys) \\<longrightarrow>\n           insert None (Some ` set xys `` A) =\n           Some ` insert a (set xys) `` A) \\<and>\n          (\\<not> A \\<subseteq> insert (fst a)\n                                 (fst ` set xys) \\<longrightarrow>\n           insert None (Some ` set xys `` A) =\n           insert None (Some ` insert a (set xys) `` A)))))", "apply (clarsimp simp:image_def Image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys)\\<rbrakk>\n       \\<Longrightarrow> (A - {a}\n                          \\<subseteq> {y.\n \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (A \\<subseteq> {y.\n    \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           (a \\<in> A \\<longrightarrow>\n                            (A \\<subseteq> insert a\n      {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert (Some b)\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A - {a}.\n   (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x} =\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}) \\<and>\n                            (\\<not> A \\<subseteq> insert a\n             {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert (Some b)\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A - {a}.\n   (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x} =\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x})) \\<and>\n                           (a \\<notin> A \\<longrightarrow>\n                            (A \\<subseteq> insert a\n      {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}) \\<and>\n                            (\\<not> A \\<subseteq> insert a\n             {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x}))) \\<and>\n                          (\\<not> A \\<subseteq> {y.\n           \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           (a \\<in> A \\<longrightarrow>\n                            (A \\<subseteq> insert a\n      {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert (Some b)\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A - {a}.\n   (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x} =\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}) \\<and>\n                            (\\<not> A \\<subseteq> insert a\n             {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert (Some b)\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A - {a}.\n   (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x} =\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x})) \\<and>\n                           (a \\<notin> A \\<longrightarrow>\n                            (A \\<subseteq> insert a\n      {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x} =\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}) \\<and>\n                            (\\<not> A \\<subseteq> insert a\n             {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x} =\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x})))) \\<and>\n                         (\\<not> A - {a}\n                                 \\<subseteq> {y.\n        \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (A \\<subseteq> {y.\n    \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           (a \\<in> A \\<longrightarrow>\n                            (A \\<subseteq> insert a\n      {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert (Some b)\n                              (insert None\n                                {y. \\<exists>x.\n (\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}) \\<and>\n                            (\\<not> A \\<subseteq> insert a\n             {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert (Some b)\n                              (insert None\n                                {y. \\<exists>x.\n (\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x})) \\<and>\n                           (a \\<notin> A \\<longrightarrow>\n                            (A \\<subseteq> insert a\n      {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}) \\<and>\n                            (\\<not> A \\<subseteq> insert a\n             {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x}))) \\<and>\n                          (\\<not> A \\<subseteq> {y.\n           \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           (a \\<in> A \\<longrightarrow>\n                            (A \\<subseteq> insert a\n      {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert (Some b)\n                              (insert None\n                                {y. \\<exists>x.\n (\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}) \\<and>\n                            (\\<not> A \\<subseteq> insert a\n             {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert (Some b)\n                              (insert None\n                                {y. \\<exists>x.\n (\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x})) \\<and>\n                           (a \\<notin> A \\<longrightarrow>\n                            (A \\<subseteq> insert a\n      {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x} =\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}) \\<and>\n                            (\\<not> A \\<subseteq> insert a\n             {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x} =\n                             insert None\n                              {y. \\<exists>x.\n                                     (\\<exists>xa\\<in>A.\n   xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                     y = Some x}))))", "apply((rule conjI, clarify)+, fastforce)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys);\n        A - {a} \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x};\n        A \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x};\n        a \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<not> A \\<subseteq> insert a\n         {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         insert (Some b)\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A - {a}.\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x} =\n                         insert None\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A.\n                                     xa = a \\<and> x = b \\<or>\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x}\n 2. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys);\n        A - {a} \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x};\n        A \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x}\\<rbrakk>\n       \\<Longrightarrow> a \\<notin> A \\<longrightarrow>\n                         (A \\<subseteq> insert a\n   {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A.\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x} =\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A.\n                                     xa = a \\<and> x = b \\<or>\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x}) \\<and>\n                         (\\<not> A \\<subseteq> insert a\n          {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A.\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x} =\n                          insert None\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x})\n 3. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys);\n        A - {a} \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x}\\<rbrakk>\n       \\<Longrightarrow> \\<not> A \\<subseteq> {y.\n         \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         (a \\<in> A \\<longrightarrow>\n                          (A \\<subseteq> insert a\n    {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert (Some b)\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A - {a}.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x}) \\<and>\n                          (\\<not> A \\<subseteq> insert a\n           {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert (Some b)\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A - {a}.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x})) \\<and>\n                         (a \\<notin> A \\<longrightarrow>\n                          (A \\<subseteq> insert a\n    {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x}) \\<and>\n                          (\\<not> A \\<subseteq> insert a\n           {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}))\n 4. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> A - {a}\n                                \\<subseteq> {y.\n       \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         (A \\<subseteq> {y.\n   \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}))) \\<and>\n                         (\\<not> A \\<subseteq> {y.\n          \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})))", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys);\n        A - {a} \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x};\n        A \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x}\\<rbrakk>\n       \\<Longrightarrow> a \\<notin> A \\<longrightarrow>\n                         (A \\<subseteq> insert a\n   {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A.\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x} =\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A.\n                                     xa = a \\<and> x = b \\<or>\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x}) \\<and>\n                         (\\<not> A \\<subseteq> insert a\n          {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A.\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x} =\n                          insert None\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x})\n 2. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys);\n        A - {a} \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x}\\<rbrakk>\n       \\<Longrightarrow> \\<not> A \\<subseteq> {y.\n         \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         (a \\<in> A \\<longrightarrow>\n                          (A \\<subseteq> insert a\n    {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert (Some b)\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A - {a}.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x}) \\<and>\n                          (\\<not> A \\<subseteq> insert a\n           {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert (Some b)\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A - {a}.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x})) \\<and>\n                         (a \\<notin> A \\<longrightarrow>\n                          (A \\<subseteq> insert a\n    {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x}) \\<and>\n                          (\\<not> A \\<subseteq> insert a\n           {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}))\n 3. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> A - {a}\n                                \\<subseteq> {y.\n       \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         (A \\<subseteq> {y.\n   \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}))) \\<and>\n                         (\\<not> A \\<subseteq> {y.\n          \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})))", "apply(clarify)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys);\n        A - {a} \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x};\n        A \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x};\n        a \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> (A \\<subseteq> insert a\n   {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A.\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x} =\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A.\n                                     xa = a \\<and> x = b \\<or>\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x}) \\<and>\n                         (\\<not> A \\<subseteq> insert a\n          {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A.\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x} =\n                          insert None\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x})\n 2. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys);\n        A - {a} \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x}\\<rbrakk>\n       \\<Longrightarrow> \\<not> A \\<subseteq> {y.\n         \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         (a \\<in> A \\<longrightarrow>\n                          (A \\<subseteq> insert a\n    {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert (Some b)\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A - {a}.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x}) \\<and>\n                          (\\<not> A \\<subseteq> insert a\n           {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert (Some b)\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A - {a}.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x})) \\<and>\n                         (a \\<notin> A \\<longrightarrow>\n                          (A \\<subseteq> insert a\n    {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x}) \\<and>\n                          (\\<not> A \\<subseteq> insert a\n           {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}))\n 3. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> A - {a}\n                                \\<subseteq> {y.\n       \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         (A \\<subseteq> {y.\n   \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}))) \\<and>\n                         (\\<not> A \\<subseteq> {y.\n          \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})))", "apply((rule conjI, clarify)+, fastforce)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys);\n        A - {a} \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x};\n        A \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x};\n        a \\<notin> A\\<rbrakk>\n       \\<Longrightarrow> \\<not> A \\<subseteq> insert a\n         {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         {y. \\<exists>x.\n                                (\\<exists>xa\\<in>A.\n                                    (xa, x) \\<in> set xys) \\<and>\n                                y = Some x} =\n                         insert None\n                          {y. \\<exists>x.\n                                 (\\<exists>xa\\<in>A.\n                                     xa = a \\<and> x = b \\<or>\n                                     (xa, x) \\<in> set xys) \\<and>\n                                 y = Some x}\n 2. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys);\n        A - {a} \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x}\\<rbrakk>\n       \\<Longrightarrow> \\<not> A \\<subseteq> {y.\n         \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         (a \\<in> A \\<longrightarrow>\n                          (A \\<subseteq> insert a\n    {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert (Some b)\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A - {a}.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x}) \\<and>\n                          (\\<not> A \\<subseteq> insert a\n           {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert (Some b)\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A - {a}.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x})) \\<and>\n                         (a \\<notin> A \\<longrightarrow>\n                          (A \\<subseteq> insert a\n    {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x}) \\<and>\n                          (\\<not> A \\<subseteq> insert a\n           {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}))\n 3. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> A - {a}\n                                \\<subseteq> {y.\n       \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         (A \\<subseteq> {y.\n   \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}))) \\<and>\n                         (\\<not> A \\<subseteq> {y.\n          \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})))", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys);\n        A - {a} \\<subseteq> {y. \\<exists>x\\<in>set xys. y = fst x}\\<rbrakk>\n       \\<Longrightarrow> \\<not> A \\<subseteq> {y.\n         \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         (a \\<in> A \\<longrightarrow>\n                          (A \\<subseteq> insert a\n    {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert (Some b)\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A - {a}.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x}) \\<and>\n                          (\\<not> A \\<subseteq> insert a\n           {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert (Some b)\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A - {a}.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x})) \\<and>\n                         (a \\<notin> A \\<longrightarrow>\n                          (A \\<subseteq> insert a\n    {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           {y. \\<exists>x.\n                                  (\\<exists>xa\\<in>A.\nxa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                  y = Some x}) \\<and>\n                          (\\<not> A \\<subseteq> insert a\n           {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                           insert None\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}))\n 2. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> A - {a}\n                                \\<subseteq> {y.\n       \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         (A \\<subseteq> {y.\n   \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}))) \\<and>\n                         (\\<not> A \\<subseteq> {y.\n          \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b xys A.\n       \\<lbrakk>\\<forall>x\\<in>set xys. a \\<noteq> fst x;\n        distinct (map fst xys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> A - {a}\n                                \\<subseteq> {y.\n       \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                         (A \\<subseteq> {y.\n   \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x}))) \\<and>\n                         (\\<not> A \\<subseteq> {y.\n          \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                          (a \\<in> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert (Some b)\n                             (insert None\n                               {y. \\<exists>x.\n(\\<exists>xa\\<in>A - {a}. (xa, x) \\<in> set xys) \\<and> y = Some x}) =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})) \\<and>\n                          (a \\<notin> A \\<longrightarrow>\n                           (A \\<subseteq> insert a\n     {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            {y. \\<exists>x.\n                                   (\\<exists>xa\\<in>A.\n xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                   y = Some x}) \\<and>\n                           (\\<not> A \\<subseteq> insert a\n            {y. \\<exists>x\\<in>set xys. y = fst x} \\<longrightarrow>\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x} =\n                            insert None\n                             {y. \\<exists>x.\n                                    (\\<exists>xa\\<in>A.\n  xa = a \\<and> x = b \\<or> (xa, x) \\<in> set xys) \\<and>\n                                    y = Some x})))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"m++m' ` (dom m' - A) = m' ` (dom m' - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m ++ m' ` (dom m' - A) = m' ` (dom m' - A)", "apply(clarsimp simp add:map_add_def image_def dom_def inj_on_def split:option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{a. \\<exists>y. m' a = Some y} - A.\n           (m' x = None \\<longrightarrow> y = m x) \\<and>\n           (\\<forall>x2. m' x = Some x2 \\<longrightarrow> y = Some x2)} =\n    {y. \\<exists>x\\<in>{a. \\<exists>y. m' a = Some y} - A. y = m' x}", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> A; m' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{a. \\<exists>y. m' a = Some y} - A.\n                            Some y = m' x\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> A; m' xa = Some y; m xa = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{a. \\<exists>y. m' a = Some y} - A.\n                            Some y = m' x\n 3. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> A; m' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{a. \\<exists>y. m' a = Some y} - A.\n                            (m' x = None \\<longrightarrow>\n                             Some y = m x) \\<and>\n                            (\\<forall>x2.\n                                m' x = Some x2 \\<longrightarrow> y = x2)", "apply (blast intro:sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> A; m' xa = Some y; m xa = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{a. \\<exists>y. m' a = Some y} - A.\n                            Some y = m' x\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> A; m' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{a. \\<exists>y. m' a = Some y} - A.\n                            (m' x = None \\<longrightarrow>\n                             Some y = m x) \\<and>\n                            (\\<forall>x2.\n                                m' x = Some x2 \\<longrightarrow> y = x2)", "apply (blast intro:sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> A; m' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>{a. \\<exists>y. m' a = Some y} - A.\n                            (m' x = None \\<longrightarrow>\n                             Some y = m x) \\<and>\n                            (\\<forall>x2.\n                                m' x = Some x2 \\<longrightarrow> y = x2)", "apply (rule_tac x = xa in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> A; m' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> (m' xa = None \\<longrightarrow>\n                          Some y = m xa) \\<and>\n                         (\\<forall>x2.\n                             m' xa = Some x2 \\<longrightarrow> y = x2)\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> A; m' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {a. \\<exists>y. m' a = Some y} - A", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> A; m' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {a. \\<exists>y. m' a = Some y} - A\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> A; m' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> (m' xa = None \\<longrightarrow>\n                          Some y = m xa) \\<and>\n                         (\\<forall>x2.\n                             m' xa = Some x2 \\<longrightarrow> y = x2)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<notin> A; m' xa = Some y\\<rbrakk>\n       \\<Longrightarrow> (m' xa = None \\<longrightarrow>\n                          Some y = m xa) \\<and>\n                         (\\<forall>x2.\n                             m' xa = Some x2 \\<longrightarrow> y = x2)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare Diff_subset [iff]"], ["", "lemma compat_correct:\n \"\\<lbrakk> oneone I; oneone I' \\<rbrakk> \\<Longrightarrow>\n  compat I' I = (let m = map_of I; m' = map_of I'\n                 in m \\<subseteq>\\<^sub>m m ++ m' \\<and> inj_on (m++m') (dom(m++m')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oneone I; oneone I'\\<rbrakk>\n    \\<Longrightarrow> PlaneGraphIso.compat I' I =\n                      (let m = map_of I; m' = map_of I'\n                       in m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n                          inj_on (m ++ m') (dom (m ++ m')))", "apply(simp add: compat_def Let_def map_le_iff_map_add_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I')\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x\\<in>set I'.\n                          case x of\n                          (x, y) \\<Rightarrow>\n                            \\<forall>xa\\<in>set I.\n                               case xa of\n                               (x', y') \\<Rightarrow> (x = x') = (y = y')) =\n                      (map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n                       inj_on (map_of I ++ map_of I')\n                        (dom (map_of I') \\<union> dom (map_of I)))", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     \\<forall>x\\<in>set I'.\n        case x of\n        (x, y) \\<Rightarrow>\n          \\<forall>xa\\<in>set I.\n             case xa of (x', y') \\<Rightarrow> (x = x') = (y = y')\\<rbrakk>\n    \\<Longrightarrow> map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n                      inj_on (map_of I ++ map_of I')\n                       (dom (map_of I') \\<union> dom (map_of I))\n 2. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n     inj_on (map_of I ++ map_of I')\n      (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set I'.\n                         case x of\n                         (x, y) \\<Rightarrow>\n                           \\<forall>xa\\<in>set I.\n                              case xa of\n                              (x', y') \\<Rightarrow> (x = x') = (y = y')", "apply(rule context_conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     \\<forall>x\\<in>set I'.\n        case x of\n        (x, y) \\<Rightarrow>\n          \\<forall>xa\\<in>set I.\n             case xa of (x', y') \\<Rightarrow> (x = x') = (y = y')\\<rbrakk>\n    \\<Longrightarrow> map_of I ++ map_of I' = map_of I' ++ map_of I\n 2. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     \\<forall>x\\<in>set I'.\n        case x of\n        (x, y) \\<Rightarrow>\n          \\<forall>xa\\<in>set I.\n             case xa of (x', y') \\<Rightarrow> (x = x') = (y = y');\n     map_of I ++ map_of I' = map_of I' ++ map_of I\\<rbrakk>\n    \\<Longrightarrow> inj_on (map_of I ++ map_of I')\n                       (dom (map_of I') \\<union> dom (map_of I))\n 3. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n     inj_on (map_of I ++ map_of I')\n      (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set I'.\n                         case x of\n                         (x, y) \\<Rightarrow>\n                           \\<forall>xa\\<in>set I.\n                              case xa of\n                              (x', y') \\<Rightarrow> (x = x') = (y = y')", "apply(rule ext)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n        distinct (map fst I') \\<and> distinct (map snd I');\n        \\<forall>x\\<in>set I'.\n           case x of\n           (x, y) \\<Rightarrow>\n             \\<forall>xa\\<in>set I.\n                case xa of\n                (x', y') \\<Rightarrow> (x = x') = (y = y')\\<rbrakk>\n       \\<Longrightarrow> (map_of I ++ map_of I') x =\n                         (map_of I' ++ map_of I) x\n 2. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     \\<forall>x\\<in>set I'.\n        case x of\n        (x, y) \\<Rightarrow>\n          \\<forall>xa\\<in>set I.\n             case xa of (x', y') \\<Rightarrow> (x = x') = (y = y');\n     map_of I ++ map_of I' = map_of I' ++ map_of I\\<rbrakk>\n    \\<Longrightarrow> inj_on (map_of I ++ map_of I')\n                       (dom (map_of I') \\<union> dom (map_of I))\n 3. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n     inj_on (map_of I ++ map_of I')\n      (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set I'.\n                         case x of\n                         (x, y) \\<Rightarrow>\n                           \\<forall>xa\\<in>set I.\n                              case xa of\n                              (x', y') \\<Rightarrow> (x = x') = (y = y')", "apply (fastforce simp add:map_add_def split:option.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     \\<forall>x\\<in>set I'.\n        case x of\n        (x, y) \\<Rightarrow>\n          \\<forall>xa\\<in>set I.\n             case xa of (x', y') \\<Rightarrow> (x = x') = (y = y');\n     map_of I ++ map_of I' = map_of I' ++ map_of I\\<rbrakk>\n    \\<Longrightarrow> inj_on (map_of I ++ map_of I')\n                       (dom (map_of I') \\<union> dom (map_of I))\n 2. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n     inj_on (map_of I ++ map_of I')\n      (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set I'.\n                         case x of\n                         (x, y) \\<Rightarrow>\n                           \\<forall>xa\\<in>set I.\n                              case xa of\n                              (x', y') \\<Rightarrow> (x = x') = (y = y')", "apply(simp add:inj_on_Un)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     \\<forall>x\\<in>set I'.\n        case x of\n        (x, y) \\<Rightarrow>\n          \\<forall>xa\\<in>set I.\n             case xa of (x', y') \\<Rightarrow> (x = x') = (y = y');\n     map_of I ++ map_of I' = map_of I' ++ map_of I\\<rbrakk>\n    \\<Longrightarrow> inj_on (map_of I' ++ map_of I)\n                       (dom (map_of I')) \\<and>\n                      map_of I' ++ map_of I `\n                      (dom (map_of I') - dom (map_of I)) \\<inter>\n                      map_of I ` (dom (map_of I) - dom (map_of I')) =\n                      {}\n 2. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n     inj_on (map_of I ++ map_of I')\n      (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set I'.\n                         case x of\n                         (x, y) \\<Rightarrow>\n                           \\<forall>xa\\<in>set I.\n                              case xa of\n                              (x', y') \\<Rightarrow> (x = x') = (y = y')", "apply(drule sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     \\<forall>x\\<in>set I'.\n        case x of\n        (x, y) \\<Rightarrow>\n          \\<forall>xa\\<in>set I.\n             case xa of (x', y') \\<Rightarrow> (x = x') = (y = y');\n     map_of I' ++ map_of I = map_of I ++ map_of I'\\<rbrakk>\n    \\<Longrightarrow> inj_on (map_of I' ++ map_of I)\n                       (dom (map_of I')) \\<and>\n                      map_of I' ++ map_of I `\n                      (dom (map_of I') - dom (map_of I)) \\<inter>\n                      map_of I ` (dom (map_of I) - dom (map_of I')) =\n                      {}\n 2. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n     inj_on (map_of I ++ map_of I')\n      (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set I'.\n                         case x of\n                         (x, y) \\<Rightarrow>\n                           \\<forall>xa\\<in>set I.\n                              case xa of\n                              (x', y') \\<Rightarrow> (x = x') = (y = y')", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     \\<forall>x\\<in>set I'.\n        case x of\n        (x, y) \\<Rightarrow>\n          \\<forall>xa\\<in>set I.\n             case xa of (x', y') \\<Rightarrow> (x = x') = (y = y');\n     map_of I' ++ map_of I = map_of I ++ map_of I'\\<rbrakk>\n    \\<Longrightarrow> map_of I' `\n                      (dom (map_of I') - dom (map_of I)) \\<inter>\n                      map_of I ` (dom (map_of I) - dom (map_of I')) =\n                      {}\n 2. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n     inj_on (map_of I ++ map_of I')\n      (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set I'.\n                         case x of\n                         (x, y) \\<Rightarrow>\n                           \\<forall>xa\\<in>set I.\n                              case xa of\n                              (x', y') \\<Rightarrow> (x = x') = (y = y')", "apply(simp add: dom_map_of_conv_image_fst image_map_of_conv_Image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     \\<forall>x\\<in>set I'.\n        case x of\n        (x, y) \\<Rightarrow>\n          \\<forall>xa\\<in>set I.\n             case xa of (x', y') \\<Rightarrow> (x = x') = (y = y');\n     map_of I' ++ map_of I = map_of I ++ map_of I'\\<rbrakk>\n    \\<Longrightarrow> Some ` set I' `` (fst ` set I' - fst ` set I) \\<inter>\n                      Some ` set I `` (fst ` set I - fst ` set I') =\n                      {}\n 2. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n     inj_on (map_of I ++ map_of I')\n      (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set I'.\n                         case x of\n                         (x, y) \\<Rightarrow>\n                           \\<forall>xa\\<in>set I.\n                              case xa of\n                              (x', y') \\<Rightarrow> (x = x') = (y = y')", "apply(simp add: image_def Image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     \\<forall>x\\<in>set I'.\n        case x of\n        (x, y) \\<Rightarrow>\n          \\<forall>xa\\<in>set I.\n             case xa of (x', y') \\<Rightarrow> (x = x') = (y = y');\n     map_of I' ++ map_of I = map_of I ++ map_of I'\\<rbrakk>\n    \\<Longrightarrow> {y. \\<exists>x.\n                             (\\<exists>xa\n \\<in>{y. \\<exists>x\\<in>set I'. y = fst x} -\n      {y. \\<exists>x\\<in>set I. y = fst x}.\n                                 (xa, x) \\<in> set I') \\<and>\n                             y = Some x} \\<inter>\n                      {y. \\<exists>x.\n                             (\\<exists>xa\n \\<in>{y. \\<exists>x\\<in>set I. y = fst x} -\n      {y. \\<exists>x\\<in>set I'. y = fst x}.\n                                 (xa, x) \\<in> set I) \\<and>\n                             y = Some x} =\n                      {}\n 2. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n     inj_on (map_of I ++ map_of I')\n      (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set I'.\n                         case x of\n                         (x, y) \\<Rightarrow>\n                           \\<forall>xa\\<in>set I.\n                              case xa of\n                              (x', y') \\<Rightarrow> (x = x') = (y = y')", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst I) \\<and> distinct (map snd I);\n     distinct (map fst I') \\<and> distinct (map snd I');\n     map_of I ++ map_of I' = map_of I' ++ map_of I \\<and>\n     inj_on (map_of I ++ map_of I')\n      (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set I'.\n                         case x of\n                         (x, y) \\<Rightarrow>\n                           \\<forall>xa\\<in>set I.\n                              case xa of\n                              (x', y') \\<Rightarrow> (x = x') = (y = y')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        inj_on (map_of I' ++ map_of I)\n         (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n       \\<Longrightarrow> (a = aa) = (b = ba)", "apply(rename_tac a b aa ba)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        inj_on (map_of I' ++ map_of I)\n         (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n       \\<Longrightarrow> (a = aa) = (b = ba)", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        inj_on (map_of I' ++ map_of I)\n         (dom (map_of I') \\<union> dom (map_of I));\n        a = aa\\<rbrakk>\n       \\<Longrightarrow> b = ba\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        inj_on (map_of I' ++ map_of I)\n         (dom (map_of I') \\<union> dom (map_of I));\n        b = ba\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply (clarsimp simp: fun_eq_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b aa ba.\n       \\<lbrakk>(aa, b) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        \\<forall>x. (map_of I ++ map_of I') x = (map_of I' ++ map_of I) x;\n        inj_on (map_of I' ++ map_of I)\n         (dom (map_of I') \\<union> dom (map_of I))\\<rbrakk>\n       \\<Longrightarrow> b = ba\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        inj_on (map_of I' ++ map_of I)\n         (dom (map_of I') \\<union> dom (map_of I));\n        b = ba\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply(erule_tac x = aa in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b aa ba.\n       \\<lbrakk>(aa, b) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        inj_on (map_of I' ++ map_of I)\n         (dom (map_of I') \\<union> dom (map_of I));\n        (map_of I ++ map_of I') aa = (map_of I' ++ map_of I) aa\\<rbrakk>\n       \\<Longrightarrow> b = ba\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        inj_on (map_of I' ++ map_of I)\n         (dom (map_of I') \\<union> dom (map_of I));\n        b = ba\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply (simp add:map_add_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        inj_on (map_of I' ++ map_of I)\n         (dom (map_of I') \\<union> dom (map_of I));\n        b = ba\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply (clarsimp simp:dom_map_of_conv_image_fst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>(a, ba) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        inj_on (map_of I' ++ map_of I)\n         (fst ` set I' \\<union> fst ` set I)\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply(simp (no_asm_use) add:inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>(a, ba) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        \\<forall>x\\<in>fst ` set I' \\<union> fst ` set I.\n           \\<forall>y\\<in>fst ` set I' \\<union> fst ` set I.\n              (map_of I' ++ map_of I) x =\n              (map_of I' ++ map_of I) y \\<longrightarrow>\n              x = y\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply(drule_tac x = a in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ba.\n       \\<lbrakk>(a, ba) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I\\<rbrakk>\n       \\<Longrightarrow> a \\<in> fst ` set I' \\<union> fst ` set I\n 2. \\<And>a aa ba.\n       \\<lbrakk>(a, ba) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        \\<forall>y\\<in>fst ` set I' \\<union> fst ` set I.\n           (map_of I' ++ map_of I) a =\n           (map_of I' ++ map_of I) y \\<longrightarrow>\n           a = y\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>(a, ba) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        \\<forall>y\\<in>fst ` set I' \\<union> fst ` set I.\n           (map_of I' ++ map_of I) a =\n           (map_of I' ++ map_of I) y \\<longrightarrow>\n           a = y\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply(drule_tac x = aa in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ba.\n       \\<lbrakk>(a, ba) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I\\<rbrakk>\n       \\<Longrightarrow> aa \\<in> fst ` set I' \\<union> fst ` set I\n 2. \\<And>a aa ba.\n       \\<lbrakk>(a, ba) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        (map_of I' ++ map_of I) a =\n        (map_of I' ++ map_of I) aa \\<longrightarrow>\n        a = aa\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>(a, ba) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I;\n        (map_of I' ++ map_of I) a =\n        (map_of I' ++ map_of I) aa \\<longrightarrow>\n        a = aa\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply(erule mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>(a, ba) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I\\<rbrakk>\n       \\<Longrightarrow> (map_of I' ++ map_of I) a =\n                         (map_of I' ++ map_of I) aa", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>(a, ba) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I ++ map_of I' = map_of I' ++ map_of I\\<rbrakk>\n       \\<Longrightarrow> (map_of I' ++ map_of I) a = Some ba", "apply(drule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>(a, ba) \\<in> set I'; (aa, ba) \\<in> set I;\n        distinct (map fst I); distinct (map snd I); distinct (map fst I');\n        distinct (map snd I');\n        map_of I' ++ map_of I = map_of I ++ map_of I'\\<rbrakk>\n       \\<Longrightarrow> (map_of I' ++ map_of I) a = Some ba", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary compat_corr:\n \"\\<forall>I I'. oneone I \\<longrightarrow> oneone I' \\<longrightarrow>\n         compat I' I = (let m = map_of I; m' = map_of I'\n                      in m \\<subseteq>\\<^sub>m m ++ m' \\<and> inj_on (m++m') (dom(m++m')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I I'.\n       oneone I \\<longrightarrow>\n       oneone I' \\<longrightarrow>\n       PlaneGraphIso.compat I' I =\n       (let m = map_of I; m' = map_of I'\n        in m \\<subseteq>\\<^sub>m m ++ m' \\<and>\n           inj_on (m ++ m') (dom (m ++ m')))", "by(simp add: compat_correct)"], ["", "definition merge0 :: \"('a,'b)merger\" where\n\"merge0 I' I  \\<equiv>  [xy \\<leftarrow> I'. fst xy \\<notin> fst ` set I] @ I\""], ["", "lemma help1:\n\"distinct(map fst xys) \\<Longrightarrow> map_of (filter P xys) =\n map_of xys |` {x. \\<exists>y. (x,y) \\<in> set xys \\<and> P(x,y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xys) \\<Longrightarrow>\n    map_of (filter P xys) =\n    map_of xys |` {x. \\<exists>y. (x, y) \\<in> set xys \\<and> P (x, y)}", "apply(induct xys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    map_of (filter P []) =\n    map_of [] |` {x. \\<exists>y. (x, y) \\<in> set [] \\<and> P (x, y)}\n 2. \\<And>a xys.\n       \\<lbrakk>distinct (map fst xys) \\<Longrightarrow>\n                map_of (filter P xys) =\n                map_of xys |`\n                {x. \\<exists>y. (x, y) \\<in> set xys \\<and> P (x, y)};\n        distinct (map fst (a # xys))\\<rbrakk>\n       \\<Longrightarrow> map_of (filter P (a # xys)) =\n                         map_of (a # xys) |`\n                         {x. \\<exists>y.\n                                (x, y) \\<in> set (a # xys) \\<and> P (x, y)}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xys.\n       \\<lbrakk>distinct (map fst xys) \\<Longrightarrow>\n                map_of (filter P xys) =\n                map_of xys |`\n                {x. \\<exists>y. (x, y) \\<in> set xys \\<and> P (x, y)};\n        distinct (map fst (a # xys))\\<rbrakk>\n       \\<Longrightarrow> map_of (filter P (a # xys)) =\n                         map_of (a # xys) |`\n                         {x. \\<exists>y.\n                                (x, y) \\<in> set (a # xys) \\<and> P (x, y)}", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xys x.\n       \\<lbrakk>distinct (map fst xys) \\<Longrightarrow>\n                map_of (filter P xys) =\n                map_of xys |`\n                {x. \\<exists>y. (x, y) \\<in> set xys \\<and> P (x, y)};\n        distinct (map fst (a # xys))\\<rbrakk>\n       \\<Longrightarrow> map_of (filter P (a # xys)) x =\n                         (map_of (a # xys) |`\n                          {x. \\<exists>y.\n                                 (x, y) \\<in> set (a # xys) \\<and>\n                                 P (x, y)})\n                          x", "apply (simp add:restrict_map_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xys x.\n       \\<lbrakk>map_of (filter P xys) =\n                (\\<lambda>x.\n                    if \\<exists>y. (x, y) \\<in> set xys \\<and> P (x, y)\n                    then map_of xys x else None);\n        fst a \\<notin> fst ` set xys \\<and> distinct (map fst xys)\\<rbrakk>\n       \\<Longrightarrow> ((\\<exists>y.\n                              (fst a, y) \\<in> set xys \\<and>\n                              P (fst a, y)) \\<longrightarrow>\n                          ((\\<exists>y.\n                               (x, y) \\<in> set xys \\<and>\n                               P (x, y)) \\<longrightarrow>\n                           (P a \\<longrightarrow>\n                            (x = fst a \\<longrightarrow>\n                             (\\<exists>y.\n                                 ((fst a, y) = a \\<or>\n                                  (fst a, y) \\<in> set xys) \\<and>\n                                 P (fst a, y))) \\<and>\n                            (x \\<noteq> fst a \\<longrightarrow>\n                             (\\<forall>y.\n                                 (x, y) \\<noteq> a \\<and>\n                                 (x, y) \\<notin> set xys \\<or>\n                                 \\<not> P (x, y)) \\<longrightarrow>\n                             map_of xys x = None)) \\<and>\n                           (\\<not> P a \\<longrightarrow>\n                            (x = fst a \\<longrightarrow>\n                             ((\\<exists>y.\n                                  ((fst a, y) = a \\<or>\n                                   (fst a, y) \\<in> set xys) \\<and>\n                                  P (fst a, y)) \\<longrightarrow>\n                              a \\<in> set xys) \\<and>\n                             ((\\<forall>y.\n                                  (fst a, y) \\<noteq> a \\<and>\n                                  (fst a, y) \\<notin> set xys \\<or>\n                                  \\<not> P (fst a, y)) \\<longrightarrow>\n                              map_of xys (fst a) = None)) \\<and>\n                            (x \\<noteq> fst a \\<longrightarrow>\n                             (\\<forall>y.\n                                 (x, y) \\<noteq> a \\<and>\n                                 (x, y) \\<notin> set xys \\<or>\n                                 \\<not> P (x, y)) \\<longrightarrow>\n                             map_of xys x = None))) \\<and>\n                          ((\\<forall>y.\n                               (x, y) \\<in> set xys \\<longrightarrow>\n                               \\<not> P (x, y)) \\<longrightarrow>\n                           (P a \\<longrightarrow>\n                            (x = fst a \\<longrightarrow>\n                             (\\<exists>y.\n                                 ((fst a, y) = a \\<or>\n                                  (fst a, y) \\<in> set xys) \\<and>\n                                 P (fst a, y))) \\<and>\n                            (x \\<noteq> fst a \\<longrightarrow>\n                             (\\<exists>y.\n                                 ((x, y) = a \\<or>\n                                  (x, y) \\<in> set xys) \\<and>\n                                 P (x, y)) \\<longrightarrow>\n                             None = map_of xys x)) \\<and>\n                           (\\<not> P a \\<longrightarrow>\n                            (x = fst a \\<longrightarrow>\n                             ((\\<exists>y.\n                                  ((fst a, y) = a \\<or>\n                                   (fst a, y) \\<in> set xys) \\<and>\n                                  P (fst a, y)) \\<longrightarrow>\n                              a \\<in> set xys) \\<and>\n                             ((\\<forall>y.\n                                  (fst a, y) \\<noteq> a \\<and>\n                                  (fst a, y) \\<notin> set xys \\<or>\n                                  \\<not> P (fst a, y)) \\<longrightarrow>\n                              map_of xys (fst a) = None)) \\<and>\n                            (x \\<noteq> fst a \\<longrightarrow>\n                             (\\<exists>y.\n                                 ((x, y) = a \\<or>\n                                  (x, y) \\<in> set xys) \\<and>\n                                 P (x, y)) \\<longrightarrow>\n                             None = map_of xys x)))) \\<and>\n                         ((\\<forall>y.\n                              (fst a, y) \\<in> set xys \\<longrightarrow>\n                              \\<not> P (fst a, y)) \\<longrightarrow>\n                          ((\\<exists>y.\n                               (x, y) \\<in> set xys \\<and>\n                               P (x, y)) \\<longrightarrow>\n                           (P a \\<longrightarrow>\n                            (x = fst a \\<longrightarrow>\n                             (\\<exists>y.\n                                 ((fst a, y) = a \\<or>\n                                  (fst a, y) \\<in> set xys) \\<and>\n                                 P (fst a, y))) \\<and>\n                            (x \\<noteq> fst a \\<longrightarrow>\n                             (\\<forall>y.\n                                 (x, y) \\<noteq> a \\<and>\n                                 (x, y) \\<notin> set xys \\<or>\n                                 \\<not> P (x, y)) \\<longrightarrow>\n                             map_of xys x = None)) \\<and>\n                           (\\<not> P a \\<longrightarrow>\n                            (x = fst a \\<longrightarrow>\n                             (\\<forall>y.\n                                 (fst a, y) \\<noteq> a \\<and>\n                                 (fst a, y) \\<notin> set xys \\<or>\n                                 \\<not> P (fst a, y))) \\<and>\n                            (x \\<noteq> fst a \\<longrightarrow>\n                             (\\<forall>y.\n                                 (x, y) \\<noteq> a \\<and>\n                                 (x, y) \\<notin> set xys \\<or>\n                                 \\<not> P (x, y)) \\<longrightarrow>\n                             map_of xys x = None))) \\<and>\n                          ((\\<forall>y.\n                               (x, y) \\<in> set xys \\<longrightarrow>\n                               \\<not> P (x, y)) \\<longrightarrow>\n                           (P a \\<longrightarrow>\n                            (x = fst a \\<longrightarrow>\n                             (\\<exists>y.\n                                 ((fst a, y) = a \\<or>\n                                  (fst a, y) \\<in> set xys) \\<and>\n                                 P (fst a, y))) \\<and>\n                            (x \\<noteq> fst a \\<longrightarrow>\n                             (\\<exists>y.\n                                 ((x, y) = a \\<or>\n                                  (x, y) \\<in> set xys) \\<and>\n                                 P (x, y)) \\<longrightarrow>\n                             None = map_of xys x)) \\<and>\n                           (\\<not> P a \\<longrightarrow>\n                            (x = fst a \\<longrightarrow>\n                             (\\<forall>y.\n                                 (fst a, y) \\<noteq> a \\<and>\n                                 (fst a, y) \\<notin> set xys \\<or>\n                                 \\<not> P (fst a, y))) \\<and>\n                            (x \\<noteq> fst a \\<longrightarrow>\n                             (\\<exists>y.\n                                 ((x, y) = a \\<or>\n                                  (x, y) \\<in> set xys) \\<and>\n                                 P (x, y)) \\<longrightarrow>\n                             None = map_of xys x))))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma merge0_correct:\n  \"\\<forall>I I'. oneone I \\<longrightarrow> oneone I' \\<longrightarrow> compat I' I\n  \\<longrightarrow> map_of(merge0 I' I) = map_of I ++ map_of I'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I I'.\n       oneone I \\<longrightarrow>\n       oneone I' \\<longrightarrow>\n       PlaneGraphIso.compat I' I \\<longrightarrow>\n       map_of (merge0 I' I) = map_of I ++ map_of I'", "apply(simp add:compat_def merge0_def help1 fun_eq_iff map_add_def restrict_map_def split:option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I.\n       distinct (map fst I) \\<and> distinct (map snd I) \\<longrightarrow>\n       (\\<forall>I'.\n           distinct (map fst I') \\<and>\n           distinct (map snd I') \\<longrightarrow>\n           (\\<forall>x\\<in>set I'.\n               case x of\n               (x, y) \\<Rightarrow>\n                 \\<forall>xa\\<in>set I.\n                    case xa of\n                    (x', y') \\<Rightarrow>\n                      (x = x') = (y = y')) \\<longrightarrow>\n           (\\<forall>x x2.\n               (x, x2) \\<in> set I' \\<longrightarrow>\n               ((\\<forall>y. (x, y) \\<notin> set I') \\<longrightarrow>\n                (x, x2) \\<in> set I) \\<and>\n               (x \\<in> fst ` set I \\<longrightarrow> (x, x2) \\<in> set I)))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma merge0_inv:\n  \"\\<forall>I I'. oneone I \\<and> oneone I' \\<longrightarrow> compat I' I \\<longrightarrow> oneone (merge0 I' I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>I I'.\n       oneone I \\<and> oneone I' \\<longrightarrow>\n       PlaneGraphIso.compat I' I \\<longrightarrow> oneone (merge0 I' I)", "apply(auto simp add:merge0_def distinct_map compat_def split_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I I'.\n       \\<lbrakk>inj_on fst (set I); distinct I; inj_on snd (set I);\n        inj_on fst (set I'); distinct I'; inj_on snd (set I');\n        \\<forall>x\\<in>set I'.\n           \\<forall>xa\\<in>set I.\n              (fst x = fst xa) = (snd x = snd xa)\\<rbrakk>\n       \\<Longrightarrow> inj_on fst\n                          {x \\<in> set I'. fst x \\<notin> fst ` set I}\n 2. \\<And>I I'.\n       \\<lbrakk>inj_on fst (set I); distinct I; inj_on snd (set I);\n        inj_on fst (set I'); distinct I'; inj_on snd (set I');\n        \\<forall>x\\<in>set I'.\n           \\<forall>xa\\<in>set I.\n              (fst x = fst xa) = (snd x = snd xa)\\<rbrakk>\n       \\<Longrightarrow> inj_on snd\n                          {x \\<in> set I'. fst x \\<notin> fst ` set I}", "apply(blast intro:subset_inj_on)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary pr_iso_test2_corr:\n \"\\<lbrakk> \\<forall>F\\<in>set Fs\\<^sub>1. distinct F; \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n   distinct Fs\\<^sub>1; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>1);\n   distinct Fs\\<^sub>2; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2) \\<rbrakk> \\<Longrightarrow>\n       pr_iso_test2 compat merge0 [] Fs\\<^sub>1 Fs\\<^sub>2 = (\\<exists>\\<phi>. is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> pr_iso_test2 PlaneGraphIso.compat merge0 [] Fs\\<^sub>1\n                       Fs\\<^sub>2 =\n                      (\\<exists>\\<phi>.\n                          is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "by(simp add: pr_iso_test2_conv_1[OF compat_corr merge0_correct merge0_inv]\n             pr_iso_test1_corr)"], ["", "text\\<open>Implementing merge as a recursive function:\\<close>"], ["", "primrec merge :: \"('a,'b)merger\" where\n  \"merge [] I = I\"\n| \"merge (xy#xys) I = (let (x,y) = xy in\n    if \\<forall> (x',y') \\<in> set I. x \\<noteq> x' then xy # merge xys I else merge xys I)\""], ["", "lemma merge_conv_merge0: \"merge I' I = merge0 I' I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge I' I = merge0 I' I", "apply(induct I')"], ["proof (prove)\ngoal (2 subgoals):\n 1. merge [] I = merge0 [] I\n 2. \\<And>a I'.\n       merge I' I = merge0 I' I \\<Longrightarrow>\n       merge (a # I') I = merge0 (a # I') I", "apply(simp add:merge0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a I'.\n       merge I' I = merge0 I' I \\<Longrightarrow>\n       merge (a # I') I = merge0 (a # I') I", "apply(force simp add:Let_def list_all_iff merge0_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec pr_iso_test_rec :: \"('a * 'b)list \\<Rightarrow> 'a fgraph \\<Rightarrow> 'b fgraph \\<Rightarrow> bool\" where\n  \"pr_iso_test_rec I [] Fs\\<^sub>2 = (Fs\\<^sub>2 = [])\"\n| \"pr_iso_test_rec I (F\\<^sub>1#Fs\\<^sub>1) Fs\\<^sub>2 =\n   (\\<exists> F\\<^sub>2 \\<in> set Fs\\<^sub>2. length F\\<^sub>1 = length F\\<^sub>2 \\<and>\n      (\\<exists>n < length F\\<^sub>2. let I' = zip F\\<^sub>1 (rotate n F\\<^sub>2) in\n          compat I' I \\<and> pr_iso_test_rec (merge I' I) Fs\\<^sub>1 (remove1 F\\<^sub>2 Fs\\<^sub>2)))\""], ["", "lemma pr_iso_test_rec_conv_2:\n  \"\\<And>I Fs\\<^sub>2. pr_iso_test_rec I Fs\\<^sub>1 Fs\\<^sub>2 = pr_iso_test2 compat merge0 I Fs\\<^sub>1 Fs\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I Fs\\<^sub>2.\n       pr_iso_test_rec I Fs\\<^sub>1 Fs\\<^sub>2 =\n       pr_iso_test2 PlaneGraphIso.compat merge0 I Fs\\<^sub>1 Fs\\<^sub>2", "apply(induct Fs\\<^sub>1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>I Fs\\<^sub>2.\n       pr_iso_test_rec I [] Fs\\<^sub>2 =\n       pr_iso_test2 PlaneGraphIso.compat merge0 I [] Fs\\<^sub>2\n 2. \\<And>a Fs\\<^sub>1 I Fs\\<^sub>2.\n       (\\<And>I Fs\\<^sub>2.\n           pr_iso_test_rec I Fs\\<^sub>1 Fs\\<^sub>2 =\n           pr_iso_test2 PlaneGraphIso.compat merge0 I Fs\\<^sub>1\n            Fs\\<^sub>2) \\<Longrightarrow>\n       pr_iso_test_rec I (a # Fs\\<^sub>1) Fs\\<^sub>2 =\n       pr_iso_test2 PlaneGraphIso.compat merge0 I (a # Fs\\<^sub>1)\n        Fs\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Fs\\<^sub>1 I Fs\\<^sub>2.\n       (\\<And>I Fs\\<^sub>2.\n           pr_iso_test_rec I Fs\\<^sub>1 Fs\\<^sub>2 =\n           pr_iso_test2 PlaneGraphIso.compat merge0 I Fs\\<^sub>1\n            Fs\\<^sub>2) \\<Longrightarrow>\n       pr_iso_test_rec I (a # Fs\\<^sub>1) Fs\\<^sub>2 =\n       pr_iso_test2 PlaneGraphIso.compat merge0 I (a # Fs\\<^sub>1)\n        Fs\\<^sub>2", "apply(auto simp: merge_conv_merge0 list_ex_iff Bex_def Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary pr_iso_test_rec_corr:\n \"\\<lbrakk> \\<forall>F\\<in>set Fs\\<^sub>1. distinct F; \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n   distinct Fs\\<^sub>1; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>1);\n   distinct Fs\\<^sub>2; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2) \\<rbrakk> \\<Longrightarrow>\n       pr_iso_test_rec [] Fs\\<^sub>1 Fs\\<^sub>2 = (\\<exists>\\<phi>. is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> pr_iso_test_rec [] Fs\\<^sub>1 Fs\\<^sub>2 =\n                      (\\<exists>\\<phi>.\n                          is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "by(simp add: pr_iso_test_rec_conv_2 pr_iso_test2_corr)"], ["", "definition pr_iso_test :: \"'a fgraph \\<Rightarrow> 'b fgraph \\<Rightarrow> bool\" where\n\"pr_iso_test Fs\\<^sub>1 Fs\\<^sub>2 = pr_iso_test_rec [] Fs\\<^sub>1 Fs\\<^sub>2\""], ["", "corollary pr_iso_test_correct:\n \"\\<lbrakk> \\<forall>F\\<in>set Fs\\<^sub>1. distinct F; \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n   distinct Fs\\<^sub>1; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>1);\n   distinct Fs\\<^sub>2; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2) \\<rbrakk> \\<Longrightarrow>\n  pr_iso_test Fs\\<^sub>1 Fs\\<^sub>2 = (\\<exists>\\<phi>. is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> pr_iso_test Fs\\<^sub>1 Fs\\<^sub>2 =\n                      (\\<exists>\\<phi>.\n                          is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply(simp add:pr_iso_test_def pr_iso_test_rec_corr)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>`Improper' Isomorphisms\\<close>"], ["", "definition is_Iso :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a Fgraph \\<Rightarrow> 'b Fgraph \\<Rightarrow> bool\" where\n\"is_Iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<equiv> is_pr_Iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<or> is_pr_Iso \\<phi> Fs\\<^sub>1 (rev ` Fs\\<^sub>2)\""], ["", "definition is_iso :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a fgraph \\<Rightarrow> 'b fgraph \\<Rightarrow> bool\" where\n\"is_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2 \\<equiv> is_Iso \\<phi> (set Fs\\<^sub>1) (set Fs\\<^sub>2)\""], ["", "definition iso_fgraph :: \"'a fgraph \\<Rightarrow> 'a fgraph \\<Rightarrow> bool\" (infix \"\\<simeq>\" 60) where\n\"g\\<^sub>1 \\<simeq> g\\<^sub>2  \\<equiv>  \\<exists>\\<phi>. is_iso \\<phi> g\\<^sub>1 g\\<^sub>2\""], ["", "lemma iso_fgraph_trans: assumes \"f \\<simeq> (g::'a fgraph)\" and \"g \\<simeq> h\" shows \"f \\<simeq> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<simeq> h", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<simeq> h", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<simeq> h", "fix \\<phi> \\<phi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<simeq> h", "assume \"is_pr_Hom \\<phi> (set f) (set g)\" \"inj_on \\<phi> (\\<Union>F\\<in>set f. set F)\"\n    \"is_pr_Hom \\<phi>' (set g) (set h)\" \"inj_on \\<phi>' (\\<Union>F\\<in>set g. set F)\""], ["proof (state)\nthis:\n  is_pr_Hom \\<phi> (set f) (set g)\n  inj_on \\<phi> (\\<Union> (set ` set f))\n  is_pr_Hom \\<phi>' (set g) (set h)\n  inj_on \\<phi>' (\\<Union> (set ` set g))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "hence \"is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (set h) \\<and>\n          inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union>F\\<in>set f. set F)\""], ["proof (prove)\nusing this:\n  is_pr_Hom \\<phi> (set f) (set g)\n  inj_on \\<phi> (\\<Union> (set ` set f))\n  is_pr_Hom \\<phi>' (set g) (set h)\n  inj_on \\<phi>' (\\<Union> (set ` set g))\n\ngoal (1 subgoal):\n 1. is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (set h) \\<and>\n    inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union> (set ` set f))", "by(simp add: is_pr_Hom_trans comp_inj_on pr_Hom_pres_nodes)"], ["proof (state)\nthis:\n  is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (set h) \\<and>\n  inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "}"], ["proof (state)\nthis:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "{"], ["proof (state)\nthis:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "fix \\<phi> \\<phi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<simeq> h", "assume \"is_pr_Hom \\<phi> (set f) (set g)\" \"inj_on \\<phi> (\\<Union>F\\<in>set f. set F)\"\n    \"is_pr_Hom \\<phi>' (set g) (rev ` set h)\" \"inj_on \\<phi>' (\\<Union>F\\<in>set g. set F)\""], ["proof (state)\nthis:\n  is_pr_Hom \\<phi> (set f) (set g)\n  inj_on \\<phi> (\\<Union> (set ` set f))\n  is_pr_Hom \\<phi>' (set g) (rev ` set h)\n  inj_on \\<phi>' (\\<Union> (set ` set g))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "hence \"is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (rev ` set h) \\<and>\n          inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union>F\\<in>set f. set F)\""], ["proof (prove)\nusing this:\n  is_pr_Hom \\<phi> (set f) (set g)\n  inj_on \\<phi> (\\<Union> (set ` set f))\n  is_pr_Hom \\<phi>' (set g) (rev ` set h)\n  inj_on \\<phi>' (\\<Union> (set ` set g))\n\ngoal (1 subgoal):\n 1. is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (rev ` set h) \\<and>\n    inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union> (set ` set f))", "by(simp add: is_pr_Hom_trans comp_inj_on pr_Hom_pres_nodes)"], ["proof (state)\nthis:\n  is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (rev ` set h) \\<and>\n  inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "}"], ["proof (state)\nthis:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (rev ` set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (rev ` set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "{"], ["proof (state)\nthis:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (rev ` set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "fix \\<phi> \\<phi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<simeq> h", "assume \"is_pr_Hom \\<phi> (set f) (rev ` set g)\" \"inj_on \\<phi> (\\<Union>F\\<in>set f. set F)\"\n    \"is_pr_Hom \\<phi>' (set g) (set h)\" \"inj_on \\<phi>' (\\<Union>F\\<in>set g. set F)\""], ["proof (state)\nthis:\n  is_pr_Hom \\<phi> (set f) (rev ` set g)\n  inj_on \\<phi> (\\<Union> (set ` set f))\n  is_pr_Hom \\<phi>' (set g) (set h)\n  inj_on \\<phi>' (\\<Union> (set ` set g))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "with this(3)[THEN is_pr_Hom_rev]"], ["proof (chain)\npicking this:\n  is_pr_Hom \\<phi>' (rev ` set g) (rev ` set h)\n  is_pr_Hom \\<phi> (set f) (rev ` set g)\n  inj_on \\<phi> (\\<Union> (set ` set f))\n  is_pr_Hom \\<phi>' (set g) (set h)\n  inj_on \\<phi>' (\\<Union> (set ` set g))", "have \"is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (rev ` set h) \\<and>\n          inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union>F\\<in>set f. set F)\""], ["proof (prove)\nusing this:\n  is_pr_Hom \\<phi>' (rev ` set g) (rev ` set h)\n  is_pr_Hom \\<phi> (set f) (rev ` set g)\n  inj_on \\<phi> (\\<Union> (set ` set f))\n  is_pr_Hom \\<phi>' (set g) (set h)\n  inj_on \\<phi>' (\\<Union> (set ` set g))\n\ngoal (1 subgoal):\n 1. is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (rev ` set h) \\<and>\n    inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union> (set ` set f))", "by(simp add: is_pr_Hom_trans comp_inj_on pr_Hom_pres_nodes)"], ["proof (state)\nthis:\n  is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (rev ` set h) \\<and>\n  inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "}"], ["proof (state)\nthis:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (rev ` set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (rev ` set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "{"], ["proof (state)\nthis:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (rev ` set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "fix \\<phi> \\<phi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<simeq> h", "assume \"is_pr_Hom \\<phi> (set f) (rev ` set g)\" \"inj_on \\<phi> (\\<Union>F\\<in>set f. set F)\"\n    \"is_pr_Hom \\<phi>' (set g) (rev ` set h)\" \"inj_on \\<phi>' (\\<Union>F\\<in>set g. set F)\""], ["proof (state)\nthis:\n  is_pr_Hom \\<phi> (set f) (rev ` set g)\n  inj_on \\<phi> (\\<Union> (set ` set f))\n  is_pr_Hom \\<phi>' (set g) (rev ` set h)\n  inj_on \\<phi>' (\\<Union> (set ` set g))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "with this(3)[THEN is_pr_Hom_rev]"], ["proof (chain)\npicking this:\n  is_pr_Hom \\<phi>' (rev ` set g) (rev ` rev ` set h)\n  is_pr_Hom \\<phi> (set f) (rev ` set g)\n  inj_on \\<phi> (\\<Union> (set ` set f))\n  is_pr_Hom \\<phi>' (set g) (rev ` set h)\n  inj_on \\<phi>' (\\<Union> (set ` set g))", "have \"is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (set h) \\<and>\n          inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union>F\\<in>set f. set F)\""], ["proof (prove)\nusing this:\n  is_pr_Hom \\<phi>' (rev ` set g) (rev ` rev ` set h)\n  is_pr_Hom \\<phi> (set f) (rev ` set g)\n  inj_on \\<phi> (\\<Union> (set ` set f))\n  is_pr_Hom \\<phi>' (set g) (rev ` set h)\n  inj_on \\<phi>' (\\<Union> (set ` set g))\n\ngoal (1 subgoal):\n 1. is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (set h) \\<and>\n    inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union> (set ` set f))", "by(simp add: is_pr_Hom_trans comp_inj_on pr_Hom_pres_nodes)"], ["proof (state)\nthis:\n  is_pr_Hom (\\<phi>' \\<circ> \\<phi>) (set f) (set h) \\<and>\n  inj_on (\\<phi>' \\<circ> \\<phi>) (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "}"], ["proof (state)\nthis:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (rev ` set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (rev ` set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (rev ` set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (rev ` set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (rev ` set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (rev ` set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (rev ` set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (rev ` set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (rev ` set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (rev ` set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (rev ` set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (rev ` set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (rev ` set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n  \\<lbrakk>is_pr_Hom ?\\<phi>2 (set f) (rev ` set g);\n   inj_on ?\\<phi>2 (\\<Union> (set ` set f));\n   is_pr_Hom ?\\<phi>'2 (set g) (rev ` set h);\n   inj_on ?\\<phi>'2 (\\<Union> (set ` set g))\\<rbrakk>\n  \\<Longrightarrow> is_pr_Hom (?\\<phi>'2 \\<circ> ?\\<phi>2) (set f)\n                     (set h) \\<and>\n                    inj_on (?\\<phi>'2 \\<circ> ?\\<phi>2)\n                     (\\<Union> (set ` set f))\n  f \\<simeq> g\n  g \\<simeq> h\n\ngoal (1 subgoal):\n 1. f \\<simeq> h", "by(simp add: iso_fgraph_def is_iso_def is_Iso_def is_pr_Iso_def) blast"], ["proof (state)\nthis:\n  f \\<simeq> h\n\ngoal:\nNo subgoals!", "qed"], ["", "definition iso_test :: \"'a fgraph \\<Rightarrow> 'b fgraph \\<Rightarrow> bool\" where\n\"iso_test g\\<^sub>1 g\\<^sub>2 \\<longleftrightarrow> pr_iso_test g\\<^sub>1 g\\<^sub>2 \\<or> pr_iso_test g\\<^sub>1 (map rev g\\<^sub>2)\""], ["", "theorem iso_correct:\n \"\\<lbrakk> \\<forall>F\\<in>set Fs\\<^sub>1. distinct F; \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n   distinct Fs\\<^sub>1; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>1);\n   distinct Fs\\<^sub>2; inj_on (\\<lambda>xs.{xs}//{\\<cong>}) (set Fs\\<^sub>2) \\<rbrakk> \\<Longrightarrow>\n  iso_test Fs\\<^sub>1 Fs\\<^sub>2 = (Fs\\<^sub>1 \\<simeq> Fs\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> iso_test Fs\\<^sub>1 Fs\\<^sub>2 =\n                      Fs\\<^sub>1 \\<simeq> Fs\\<^sub>2", "apply(simp add:iso_test_def pr_iso_test_correct iso_fgraph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2) \\<or>\n                       pr_iso_test Fs\\<^sub>1 (map rev Fs\\<^sub>2)) =\n                      (\\<exists>\\<phi>. is_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply(subst pr_iso_test_correct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> Ball (set Fs\\<^sub>1) distinct\n 2. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> Ball (set (map rev Fs\\<^sub>2)) distinct\n 3. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> [] \\<notin> set (map rev Fs\\<^sub>2)\n 4. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct Fs\\<^sub>1\n 5. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set Fs\\<^sub>1)\n 6. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct (map rev Fs\\<^sub>2)\n 7. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set (map rev Fs\\<^sub>2))\n 8. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2) \\<or>\n                       (\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1\n                            (map rev Fs\\<^sub>2))) =\n                      (\\<exists>\\<phi>. is_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> Ball (set (map rev Fs\\<^sub>2)) distinct\n 2. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> [] \\<notin> set (map rev Fs\\<^sub>2)\n 3. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct Fs\\<^sub>1\n 4. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set Fs\\<^sub>1)\n 5. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct (map rev Fs\\<^sub>2)\n 6. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set (map rev Fs\\<^sub>2))\n 7. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2) \\<or>\n                       (\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1\n                            (map rev Fs\\<^sub>2))) =\n                      (\\<exists>\\<phi>. is_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> [] \\<notin> set (map rev Fs\\<^sub>2)\n 2. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct Fs\\<^sub>1\n 3. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set Fs\\<^sub>1)\n 4. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct (map rev Fs\\<^sub>2)\n 5. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set (map rev Fs\\<^sub>2))\n 6. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2) \\<or>\n                       (\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1\n                            (map rev Fs\\<^sub>2))) =\n                      (\\<exists>\\<phi>. is_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply (simp add:image_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct Fs\\<^sub>1\n 2. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set Fs\\<^sub>1)\n 3. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct (map rev Fs\\<^sub>2)\n 4. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set (map rev Fs\\<^sub>2))\n 5. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2) \\<or>\n                       (\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1\n                            (map rev Fs\\<^sub>2))) =\n                      (\\<exists>\\<phi>. is_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set Fs\\<^sub>1)\n 2. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct (map rev Fs\\<^sub>2)\n 3. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set (map rev Fs\\<^sub>2))\n 4. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2) \\<or>\n                       (\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1\n                            (map rev Fs\\<^sub>2))) =\n                      (\\<exists>\\<phi>. is_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> distinct (map rev Fs\\<^sub>2)\n 2. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set (map rev Fs\\<^sub>2))\n 3. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2) \\<or>\n                       (\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1\n                            (map rev Fs\\<^sub>2))) =\n                      (\\<exists>\\<phi>. is_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply (simp add:distinct_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>xs. {xs} // {\\<cong>})\n                       (set (map rev Fs\\<^sub>2))\n 2. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2) \\<or>\n                       (\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1\n                            (map rev Fs\\<^sub>2))) =\n                      (\\<exists>\\<phi>. is_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply (simp add:inj_on_image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2) \\<or>\n                       (\\<exists>\\<phi>.\n                           is_pr_iso \\<phi> Fs\\<^sub>1\n                            (map rev Fs\\<^sub>2))) =\n                      (\\<exists>\\<phi>. is_iso \\<phi> Fs\\<^sub>1 Fs\\<^sub>2)", "apply(simp add:is_iso_def is_Iso_def is_pr_iso_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>F\\<in>set Fs\\<^sub>1. distinct F;\n     \\<forall>F\\<in>set Fs\\<^sub>2. distinct F; [] \\<notin> set Fs\\<^sub>2;\n     distinct Fs\\<^sub>1;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>1);\n     distinct Fs\\<^sub>2;\n     inj_on (\\<lambda>xs. {xs} // {\\<cong>}) (set Fs\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> ((\\<exists>\\<phi>.\n                           is_pr_Iso \\<phi> (set Fs\\<^sub>1)\n                            (set Fs\\<^sub>2)) \\<or>\n                       (\\<exists>\\<phi>.\n                           is_pr_Iso \\<phi> (set Fs\\<^sub>1)\n                            (rev ` set Fs\\<^sub>2))) =\n                      (\\<exists>\\<phi>.\n                          is_pr_Iso \\<phi> (set Fs\\<^sub>1)\n                           (set Fs\\<^sub>2) \\<or>\n                          is_pr_Iso \\<phi> (set Fs\\<^sub>1)\n                           (rev ` set Fs\\<^sub>2))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iso_fgraph_refl[iff]: \"g \\<simeq> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<simeq> g", "apply(simp add: iso_fgraph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>. is_iso \\<phi> g g", "apply(rule_tac x = \"id\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_iso id g g", "apply(simp add: is_iso_def is_Iso_def is_pr_Iso_def is_pr_Hom_def id_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Elementhood and containment modulo\\<close>"], ["", "interpretation qle_gr: quasi_order \"(\\<simeq>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasi_order (\\<simeq>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<simeq> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<simeq> y; y \\<simeq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<simeq> z", "qed (auto intro:iso_fgraph_trans)"], ["", "abbreviation qle_gr_in :: \"'a fgraph \\<Rightarrow> 'a fgraph set \\<Rightarrow> bool\"  (infix \"\\<in>\\<^sub>\\<simeq>\" 60)\nwhere \"x \\<in>\\<^sub>\\<simeq> M \\<equiv> qle_gr.in_qle x M\""], ["", "abbreviation qle_gr_sub :: \"'a fgraph set \\<Rightarrow> 'a fgraph set \\<Rightarrow> bool\"  (infix \"\\<subseteq>\\<^sub>\\<simeq>\" 60)\nwhere \"x \\<subseteq>\\<^sub>\\<simeq> M \\<equiv> qle_gr.subseteq_qle x M\""], ["", "abbreviation qle_gr_eq :: \"'a fgraph set \\<Rightarrow> 'a fgraph set \\<Rightarrow> bool\"  (infix \"=\\<^sub>\\<simeq>\" 60)\nwhere \"x =\\<^sub>\\<simeq> M \\<equiv> qle_gr.seteq_qle x M\""], ["", "end"]]}