{"file_name": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame/ListAux.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame", "problem_names": ["lemma pairD:  \"(a,b) = p \\<Longrightarrow> a = fst p \\<and> b = snd p\"", "lemmas conj_aci = conj_comms conj_assoc conj_absorb conj_left_absorb", "lemma [code]:\n  \"enum 0 = {}\"\n  \"enum (Suc n) = insert n (enum n)\"", "lemma length3D: \"|xs| = 3 \\<Longrightarrow> \\<exists>x y z. xs = [x, y, z]\"", "lemma length4D: \"|xs| = 4 \\<Longrightarrow> \\<exists> a b c d. xs = [a, b, c, d]\"", "lemma filter_emptyE[dest]: \"(filter P xs = []) \\<Longrightarrow>  x \\<in> set xs \\<Longrightarrow>  \\<not> P x\"", "lemma filter_comm: \"[x \\<leftarrow> xs. P x \\<and> Q x] = [x \\<leftarrow> xs. Q x \\<and> P x]\"", "lemma filter_prop: \"x \\<in> set [u\\<leftarrow>ys . P u] \\<Longrightarrow> P x\"", "lemma filter_compl1: \n \"([x\\<leftarrow>xs. P x] = []) = ([x\\<leftarrow>xs. \\<not> P x] = xs)\" (is \"?lhs = ?rhs\")", "lemma [simp]: \"Not \\<circ> (Not \\<circ> P) = P\"", "lemma filter_eqI: \n  \"(\\<And>v. v \\<in> set vs \\<Longrightarrow> P v = Q v) \\<Longrightarrow> [v\\<leftarrow>vs . P v] = [v\\<leftarrow>vs . Q v]\"", "lemma filter_simp: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> P x) \\<Longrightarrow> [x\\<leftarrow>xs. P x \\<and> Q x] = [x\\<leftarrow>xs. Q x]\"", "lemma filter_True_eq1: \n  \"(length [y\\<leftarrow>xs. P y] = length xs) \\<Longrightarrow> (\\<And>y. y \\<in> set xs \\<Longrightarrow> P y)\"", "lemma [simp]: \"[f x. x <- xs, P x] = [f x. x <- [x \\<leftarrow> xs. P x]]\"", "lemma(*<*)[simp]: (*>*) \"set (xs \\<times> ys) = (set xs) \\<times> (set ys)\"", "lemma minimal_in_set[simp]: \"xs \\<noteq> [] \\<Longrightarrow> minimal f xs : set xs\"", "lemma min_list_conv_Min[simp]:\n \"xs \\<noteq> [] \\<Longrightarrow> min_list xs = Min (set xs)\"", "lemma max_list_conv_Max[simp]:\n \"xs \\<noteq> [] \\<Longrightarrow> max_list xs = Max (set xs)\"", "lemma length_mapAt[simp]: \"\\<And>xs. length(mapAt vs f xs) = length xs\"", "lemma length_replace1[simp]: \"length(replace x [y] xs) = length xs\"", "lemma replace_id[simp]: \"replace x [x] xs = xs\"", "lemma len_replace_ge_same:\n\"length ys \\<ge> 1 \\<Longrightarrow> length(replace x ys xs) \\<ge> length xs\"", "lemma len_replace_ge[simp]:\n\"\\<lbrakk> length ys \\<ge> 1; length xs \\<ge> length zs \\<rbrakk> \\<Longrightarrow>\n length(replace x ys xs) \\<ge> length zs\"", "lemma replace_append[simp]:\n  \"replace x ys (as @ bs) =\n   (if x \\<in> set as then replace x ys as @ bs else as @ replace x ys bs)\"", "lemma distinct_set_replace: \"distinct xs \\<Longrightarrow>\n set (replace x ys xs) =\n (if x \\<in> set xs then (set xs - {x}) \\<union> set ys else set xs)\"", "lemma replace1:\n \"f \\<in> set (replace f' fs ls ) \\<Longrightarrow> f \\<notin> set ls \\<Longrightarrow> f \\<in> set fs\"", "lemma replace2:\n \"f' \\<notin> set ls \\<Longrightarrow> replace f' fs ls  = ls\"", "lemma replace3[intro]:\n  \"f' \\<in> set ls \\<Longrightarrow> f \\<in> set fs \\<Longrightarrow> f \\<in> set (replace f' fs ls)\"", "lemma replace4:\n  \"f \\<in> set ls \\<Longrightarrow> oldF \\<noteq> f \\<Longrightarrow> f \\<in> set (replace oldF fs ls)\"", "lemma replace5: \"f \\<in> set (replace oldF newfs fs) \\<Longrightarrow> f \\<in> set fs \\<or> f \\<in> set newfs\"", "lemma replace6: \"distinct oldfs \\<Longrightarrow> x \\<in> set (replace oldF newfs oldfs) = \n  ((x \\<noteq> oldF \\<or> oldF \\<in> set newfs) \\<and> ((oldF \\<in> set oldfs \\<and> x \\<in> set newfs) \\<or> x \\<in> set oldfs))\"", "lemma distinct_replace: \n\"distinct fs \\<Longrightarrow> distinct newFs \\<Longrightarrow> set fs \\<inter> set newFs \\<subseteq> {oldF} \\<Longrightarrow>\n distinct (replace oldF newFs fs)\"", "lemma replace_replace[simp]: \"oldf \\<notin> set newfs \\<Longrightarrow> distinct xs \\<Longrightarrow> \n  replace oldf newfs (replace oldf newfs xs) = replace oldf newfs xs\"", "lemma replace_distinct: \"distinct fs \\<Longrightarrow> distinct newfs \\<Longrightarrow> oldf \\<in> set fs \\<longrightarrow> set newfs \\<inter> set fs \\<subseteq> {oldf} \\<Longrightarrow> \n  distinct (replace oldf newfs fs)\"", "lemma filter_replace2:\n \"\\<lbrakk> \\<not> P x; \\<forall>y\\<in> set ys. \\<not> P y \\<rbrakk> \\<Longrightarrow>\n  filter P (replace x ys xs) = filter P xs\"", "lemma length_filter_replace1:\n \"\\<lbrakk> x \\<in> set xs; \\<not> P x \\<rbrakk> \\<Longrightarrow>\n  length(filter P (replace x ys xs)) =\n  length(filter P xs) + length(filter P ys)\"", "lemma length_filter_replace2:\n \"\\<lbrakk> x \\<in> set xs; P x \\<rbrakk> \\<Longrightarrow>\n  length(filter P (replace x ys xs)) =\n  length(filter P xs) + length(filter P ys) - 1\"", "lemma dist_at1: \"\\<And> c vs. distinct vs \\<Longrightarrow> vs = a @ r # b \\<Longrightarrow> vs = c @ r # d \\<Longrightarrow> a = c\"", "lemma dist_at: \"distinct vs \\<Longrightarrow> vs = a @ r # b \\<Longrightarrow> vs = c @ r # d \\<Longrightarrow> a = c \\<and> b = d\"", "lemma dist_at2: \"distinct vs \\<Longrightarrow> vs = a @ r # b \\<Longrightarrow> vs = c @ r # d \\<Longrightarrow> b = d\"", "lemma distinct_split1: \"distinct xs \\<Longrightarrow> xs = y @ [r] @ z  \\<Longrightarrow> r \\<notin> set y\"", "lemma distinct_split2: \"distinct xs \\<Longrightarrow> xs = y @ [r] @ z  \\<Longrightarrow> r \\<notin> set z\"", "lemma distinct_hd_not_cons: \"distinct vs \\<Longrightarrow> \\<exists> as bs. vs = as @ x # hd vs # bs \\<Longrightarrow> False\"", "lemma drop_last_in: \"\\<And>n. n < length ls \\<Longrightarrow> last ls \\<in> set (drop n ls)\"", "lemma nth_last_Suc_n: \"distinct ls \\<Longrightarrow> n < length ls \\<Longrightarrow> last ls = ls ! n \\<Longrightarrow> Suc n = length ls\"", "lemma  plus_length1[simp]: \"rotate (k+(length ls)) ls = rotate k ls \"", "lemma  plus_length2[simp]: \"rotate ((length ls)+k) ls = rotate k ls \"", "lemma rotate_minus1: \"n > 0 \\<Longrightarrow> m > 0 \\<Longrightarrow>\n rotate n ls = rotate m ms \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms\"", "lemma rotate_minus1': \"n > 0 \\<Longrightarrow> rotate n ls = ms \\<Longrightarrow>\n  rotate (n - 1) ls = rotate (length ms - 1) ms\"", "lemma rotate_inv1: \"\\<And> ms. n < length ls \\<Longrightarrow> rotate n ls = ms \\<Longrightarrow>\n  ls = rotate ((length ls) - n) ms\"", "lemma rotate_conv_mod'[simp]: \"rotate (n mod length ls) ls = rotate n ls\"", "lemma rotate_inv2: \"rotate n ls = ms \\<Longrightarrow>\n ls = rotate ((length ls) - (n mod length ls)) ms\"", "lemma rotate_id[simp]: \"rotate ((length ls) - (n mod length ls)) (rotate n ls) = ls\"", "lemma nth_rotate1_Suc: \"Suc n < length ls \\<Longrightarrow> ls!(Suc n) = (rotate1 ls)!n\"", "lemma nth_rotate1_0: \"ls!0 = (rotate1 ls)!(length ls - 1)\"", "lemma nth_rotate1: \"0 < length ls \\<Longrightarrow> ls!((Suc n) mod (length ls)) = (rotate1 ls)!(n mod (length ls))\"", "lemma rotate_Suc2[simp]: \"rotate n (rotate1 xs) = rotate (Suc n) xs\"", "lemma nth_rotate: \"\\<And> ls. 0 < length ls \\<Longrightarrow> ls!((n+m) mod (length ls)) = (rotate m ls)!(n mod (length ls))\"", "lemma splitAtRec_conv: \"\\<And>bs.\n splitAtRec x bs xs =\n (bs @ takeWhile (\\<lambda>y. y\\<noteq>x) xs, tl(dropWhile (\\<lambda>y. y\\<noteq>x) xs))\"", "lemma splitAtRec_distinct_fst: \"\\<And> s. distinct vs \\<Longrightarrow> distinct s \\<Longrightarrow> (set s) \\<inter>  (set vs) = {} \\<Longrightarrow> distinct (fst (splitAtRec ram1 s vs))\"", "lemma splitAtRec_distinct_snd: \"\\<And> s. distinct vs \\<Longrightarrow> distinct s \\<Longrightarrow> (set s) \\<inter>  (set vs) = {} \\<Longrightarrow> distinct (snd (splitAtRec ram1 s vs))\"", "lemma splitAtRec_ram:\n  \"\\<And> us a b. ram \\<in> set vs \\<Longrightarrow> (a, b) = splitAtRec ram us vs \\<Longrightarrow>\n  us @ vs = a @ [ram] @ b\"", "lemma splitAtRec_notRam:\n \"\\<And> us. ram \\<notin>  set vs \\<Longrightarrow> splitAtRec ram us vs = (us @ vs, [])\"", "lemma splitAtRec_distinct: \"\\<And> s. distinct vs \\<Longrightarrow>\n  distinct s \\<Longrightarrow> (set s) \\<inter> (set vs) = {} \\<Longrightarrow>\n  set (fst (splitAtRec ram s vs)) \\<inter> set (snd (splitAtRec ram s vs)) = {}\"", "lemma splitAt_conv:\n \"splitAt x xs = (takeWhile (\\<lambda>y. y\\<noteq>x) xs, tl(dropWhile (\\<lambda>y. y\\<noteq>x) xs))\"", "lemma splitAt_no_ram[simp]:\n  \"ram \\<notin> set vs \\<Longrightarrow> splitAt ram vs = (vs, [])\"", "lemma splitAt_split:\n  \"ram \\<in> set vs \\<Longrightarrow> (a,b) = splitAt ram vs \\<Longrightarrow> vs = a @ ram # b\"", "lemma splitAt_ram:\n  \"ram \\<in> set vs \\<Longrightarrow> vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\"", "lemma fst_splitAt_last:\n \"\\<lbrakk> xs \\<noteq> []; distinct xs \\<rbrakk> \\<Longrightarrow> fst (splitAt (last xs) xs) = butlast xs\"", "lemma splitAtRec_union:\n\"\\<And> a b s. (a,b) = splitAtRec ram s vs \\<Longrightarrow> (set a \\<union> set b) - {ram} = (set vs \\<union> set s) - {ram}\"", "lemma splitAt_subset_ab:\n  \"(a,b) = splitAt ram vs \\<Longrightarrow> set a \\<subseteq> set vs \\<and> set b \\<subseteq> set vs\"", "lemma splitAt_in_fst[dest]: \"v \\<in> set (fst (splitAt ram vs)) \\<Longrightarrow> v \\<in> set vs\"", "lemma splitAt_not1:\n\"v \\<notin> set vs \\<Longrightarrow> v \\<notin> set (fst (splitAt ram vs))\"", "lemma splitAt_in_snd[dest]: \"v \\<in> set (snd (splitAt ram vs)) \\<Longrightarrow> v \\<in> set vs\"", "lemma splitAt_distinct_ab_aux:\n \"distinct vs \\<Longrightarrow> (a,b) = splitAt ram vs \\<Longrightarrow> distinct a \\<and> distinct b\"", "lemma splitAt_distinct_fst_aux[intro]:\n \"distinct vs \\<Longrightarrow> distinct (fst (splitAt ram vs))\"", "lemma splitAt_distinct_snd_aux[intro]:\n \"distinct vs \\<Longrightarrow> distinct (snd (splitAt ram vs))\"", "lemma splitAt_distinct_ab:\n  \"distinct vs \\<Longrightarrow>  (a,b) = splitAt ram vs \\<Longrightarrow> set a \\<inter> set b = {}\"", "lemma splitAt_distinct_fst_snd:\n    \"distinct vs \\<Longrightarrow>  set (fst (splitAt ram vs)) \\<inter> set (snd (splitAt ram vs)) = {}\"", "lemma splitAt_distinct_ram_fst[intro]:\n  \"distinct vs \\<Longrightarrow> ram \\<notin> set (fst (splitAt ram vs))\"", "lemma splitAt_distinct_ram_snd[intro]:\n  \"distinct vs \\<Longrightarrow> ram \\<notin> set (snd (splitAt ram vs))\"", "lemma splitAt_1[simp]:\n  \"splitAt ram [] = ([],[])\"", "lemma splitAt_2:\n  \"v \\<in> set vs \\<Longrightarrow> (a,b) = splitAt ram vs \\<Longrightarrow> v \\<in> set a \\<or> v \\<in> set b \\<or> v = ram \"", "lemma splitAt_distinct_fst: \"distinct vs \\<Longrightarrow> distinct (fst (splitAt ram1 vs))\"", "lemma splitAt_distinct_a: \"distinct vs \\<Longrightarrow> (a,b) = splitAt ram vs \\<Longrightarrow> distinct a\"", "lemma splitAt_distinct_snd: \"distinct vs \\<Longrightarrow> distinct (snd (splitAt ram1 vs))\"", "lemma splitAt_distinct_b: \"distinct vs \\<Longrightarrow> (a,b) = splitAt ram vs \\<Longrightarrow> distinct b\"", "lemma splitAt_distinct: \"distinct vs \\<Longrightarrow> set (fst (splitAt ram vs)) \\<inter> set (snd (splitAt ram vs)) = {}\"", "lemma splitAt_subset: \"(a,b) = splitAt ram vs \\<Longrightarrow> (set a \\<subseteq> set vs) \\<and> (set b \\<subseteq> set vs)\"", "lemma set_help: \"v \\<in> set ( as @ bs) \\<Longrightarrow> v \\<in> set as \\<or> v \\<in> set bs\"", "lemma splitAt_elements: \"ram1 \\<in> set vs \\<Longrightarrow> ram2 \\<in> set vs \\<Longrightarrow> ram2 \\<in> set( fst (splitAt ram1 vs)) \\<or> ram2 \\<in> set [ram1] \\<or>  ram2 \\<in> set( snd (splitAt ram1 vs))\"", "lemma splitAt_ram3: \"ram2 \\<notin>  set (fst (splitAt ram1 vs)) \\<Longrightarrow>\n  ram1 \\<in> set vs \\<Longrightarrow> ram2 \\<in> set vs \\<Longrightarrow> ram1 \\<noteq> ram2 \\<Longrightarrow>\n  ram2 \\<in> set (snd (splitAt ram1 vs))\"", "lemma splitAt_dist_ram: \"distinct vs \\<Longrightarrow>\n vs = a @ ram # b \\<Longrightarrow> (a,b) = splitAt ram vs\"", "lemma distinct_unique1: \"distinct vs \\<Longrightarrow> ram \\<in> set vs \\<Longrightarrow> \\<exists>!s. vs = (fst s) @ ram # (snd s)\"", "lemma splitAt_dist_ram2: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>\n (a @ ram1 # b, c) = splitAt ram2 vs\"", "lemma splitAt_dist_ram20: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>\n  c = snd (splitAt ram2 vs)\"", "lemma splitAt_dist_ram21: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow> (a, b) = splitAt ram1 (fst (splitAt ram2 vs))\"", "lemma splitAt_dist_ram22: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>  (c, []) = splitAt ram1 (snd (splitAt ram2 vs))\"", "lemma splitAt_dist_ram1: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow> (a, b @ ram2 # c) = splitAt ram1 vs\"", "lemma splitAt_dist_ram10: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow> a = fst (splitAt ram1 vs)\"", "lemma splitAt_dist_ram11: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs))\"", "lemma splitAt_dist_ram12: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>  (b, c) = splitAt ram2 (snd (splitAt ram1 vs))\"", "lemma splitAt_dist_ram_all:\n  \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c\n  \\<Longrightarrow> (a, b) = splitAt ram1 (fst (splitAt ram2 vs))\n  \\<and> (c, []) = splitAt ram1 (snd (splitAt ram2 vs))\n  \\<and> (a, []) = splitAt ram2 (fst (splitAt ram1 vs))\n  \\<and> (b, c) = splitAt ram2 (snd (splitAt ram1 vs))\n  \\<and>  c = snd (splitAt ram2 vs)\n  \\<and>  a = fst (splitAt ram1 vs)\"", "lemma fst_splitAt_rev:\n \"distinct xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow>\n  fst(splitAt x (rev xs)) = rev(snd(splitAt x xs))\"", "lemma snd_splitAt_rev:\n \"distinct xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow>\n  snd(splitAt x (rev xs)) = rev(fst(splitAt x xs))\"", "lemma splitAt_take[simp]: \"distinct ls \\<Longrightarrow> i < length ls \\<Longrightarrow> fst (splitAt (ls!i) ls) = take i ls\"", "lemma splitAt_drop[simp]: \"distinct ls \\<Longrightarrow>  i < length ls \\<Longrightarrow> snd (splitAt (ls!i) ls) = drop (Suc i) ls\"", "lemma fst_splitAt_upt:\n \"j \\<le> i \\<Longrightarrow> i < k \\<Longrightarrow> fst(splitAt i [j..<k]) = [j..<i]\"", "lemma snd_splitAt_upt:\n \"j \\<le> i \\<Longrightarrow> i < k \\<Longrightarrow> snd(splitAt i [j..<k]) = [i+1..<k]\"", "lemma local_help1: \"\\<And> a vs. vs = c @ r # d \\<Longrightarrow> vs = a @ r # b \\<Longrightarrow> r \\<notin> set a \\<Longrightarrow> r \\<notin> set b \\<Longrightarrow> a = c\"", "lemma local_help: \"vs = a @ r # b \\<Longrightarrow> vs = c @ r # d \\<Longrightarrow> r \\<notin> set a \\<Longrightarrow> r \\<notin> set b \\<Longrightarrow> a = c \\<and> b = d\"", "lemma local_help': \"a @ r # b = c @ r # d \\<Longrightarrow> r \\<notin> set a \\<Longrightarrow> r \\<notin> set b \\<Longrightarrow> a = c \\<and> b = d\"", "lemma splitAt_simp1: \"ram \\<notin> set a \\<Longrightarrow> ram \\<notin> set b \\<Longrightarrow> fst (splitAt ram (a @ ram # b)) = a \"", "lemma help'''_in: \"\\<And> xs. ram \\<in> set b \\<Longrightarrow> fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)\"", "lemma help'''_notin: \"\\<And> xs. ram \\<notin>  set b \\<Longrightarrow> fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)\"", "lemma help''': \"fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)\"", "lemma splitAt_simpA[simp]: \"fst (splitAt ram (ram # b)) = []\"", "lemma splitAt_simpB[simp]: \"ram \\<noteq> a \\<Longrightarrow> fst (splitAt ram (a # b)) = a # fst (splitAt ram b)\"", "lemma splitAt_simpB'[simp]: \"a \\<noteq> ram \\<Longrightarrow> fst (splitAt ram (a # b)) = a # fst (splitAt ram b)\"", "lemma splitAt_simpC[simp]: \"ram \\<notin> set a  \\<Longrightarrow> fst (splitAt ram (a @ b)) = a @ fst (splitAt ram b)\"", "lemma help'''': \"\\<And> xs ys. snd (splitAtRec ram xs b) = snd (splitAtRec ram ys b)\"", "lemma splitAt_simpD[simp]: \"\\<And> a. ram \\<noteq> a \\<Longrightarrow> snd (splitAt ram (a # b)) = snd (splitAt ram b)\"", "lemma splitAt_simpD'[simp]: \"\\<And> a. a \\<noteq> ram \\<Longrightarrow> snd (splitAt ram (a # b)) = snd (splitAt ram b)\"", "lemma splitAt_simpE[simp]: \"snd (splitAt ram (ram # b)) = b\"", "lemma splitAt_simpF[simp]: \"ram \\<notin> set a  \\<Longrightarrow> snd (splitAt ram (a @ b)) = snd (splitAt ram b) \"", "lemma splitAt_rotate_pair_conv:\n  \"\\<And>xs. \\<lbrakk> distinct xs; x \\<in> set xs \\<rbrakk>\n  \\<Longrightarrow> snd (splitAt x (rotate n xs)) @ fst (splitAt x (rotate n xs)) =\n      snd (splitAt x xs) @ fst (splitAt x xs)\"", "lemma inbetween_inset:\n \"x \\<in> set(between xs a b) \\<Longrightarrow> x \\<in> set xs\"", "lemma notinset_notinbetween:\n \"x \\<notin> set xs \\<Longrightarrow> x \\<notin> set(between xs a b)\"", "lemma set_between_id:\n \"distinct xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow>\n  set(between xs x x) = set xs - {x}\"", "lemma split_between:\n \"\\<lbrakk> distinct vs; r \\<in> set vs; v \\<in> set vs; u \\<in> set(between vs r v) \\<rbrakk> \\<Longrightarrow>\n  between vs r v =\n (if r=u then [] else between vs r u @ [u]) @ between vs u v\"", "lemma isTable_eq: \"isTable E vs ((a,b)#ps) \\<Longrightarrow> b = E a\"", "lemma isTable_subset: \n  \"set qs \\<subseteq> set ps \\<Longrightarrow> isTable E vs ps \\<Longrightarrow> isTable E vs qs\"", "lemma isTable_Cons: \"isTable E vs ((a,b)#ps) \\<Longrightarrow> isTable E vs ps\"", "lemma removeKey_subset[simp]: \"set (removeKey a ps) \\<subseteq> set ps\"", "lemma length_removeKey[simp]: \"|removeKey w ps| \\<le> |ps|\"", "lemma length_removeKeyList: \n  \"length (removeKeyList ws ps) \\<le> length ps\" (is \"?P ws\")", "lemma removeKeyList_subset[simp]: \"set (removeKeyList ws ps) \\<subseteq> set ps\"", "lemma notin_removeKey1: \"(a, b) \\<notin> set (removeKey a ps)\"", "lemma removeKeyList_eq:\n  \"removeKeyList as ps = [p \\<leftarrow> ps. \\<forall>a \\<in> set as. a \\<noteq> fst p]\"", "lemma removeKey_empty[simp]: \"removeKey a [] = []\"", "lemma removeKeyList_empty[simp]: \"removeKeyList ps [] = []\"", "lemma removeKeyList_cons[simp]: \n  \"removeKeyList ws (p#ps) \n  = (if fst p \\<in> set ws then removeKeyList ws ps else p#(removeKeyList ws ps))\""], "translations": [["", "lemma pairD:  \"(a,b) = p \\<Longrightarrow> a = fst p \\<and> b = snd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) = p \\<Longrightarrow> a = fst p \\<and> b = snd p", "by auto"], ["", "lemmas conj_aci = conj_comms conj_assoc conj_absorb conj_left_absorb"], ["", "definition enum :: \"nat \\<Rightarrow> nat set\" where\n  [code_abbrev]: \"enum n = {..<n}\""], ["", "lemma [code]:\n  \"enum 0 = {}\"\n  \"enum (Suc n) = insert n (enum n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum 0 = {} &&& enum (Suc n) = insert n (enum n)", "unfolding enum_def lessThan_0 lessThan_Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} = {} &&& insert n {..<n} = insert n {..<n}", "by rule+"], ["", "subsection \\<open>Lists\\<close>"], ["", "declare List.member_def[simp] list_all_iff[simp] list_ex_iff[simp]"], ["", "subsubsection\\<open>\\<open>length\\<close>\\<close>"], ["", "notation length  (\"|_|\")"], ["", "lemma length3D: \"|xs| = 3 \\<Longrightarrow> \\<exists>x y z. xs = [x, y, z]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |xs| = 3 \\<Longrightarrow> \\<exists>x y z. xs = [x, y, z]", "apply (cases xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>|xs| = 3; xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x y z. xs = [x, y, z]\n 2. \\<And>a list.\n       \\<lbrakk>|xs| = 3; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y z. xs = [x, y, z]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>|xs| = 3; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y z. xs = [x, y, z]", "apply (case_tac list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>|xs| = 3; xs = a # list; list = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y z. xs = [x, y, z]\n 2. \\<And>a list aa lista.\n       \\<lbrakk>|xs| = 3; xs = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y z. xs = [x, y, z]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list aa lista.\n       \\<lbrakk>|xs| = 3; xs = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y z. xs = [x, y, z]", "apply (case_tac lista)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list aa lista.\n       \\<lbrakk>|xs| = 3; xs = a # list; list = aa # lista;\n        lista = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y z. xs = [x, y, z]\n 2. \\<And>a list aa lista ab listb.\n       \\<lbrakk>|xs| = 3; xs = a # list; list = aa # lista;\n        lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y z. xs = [x, y, z]", "by simp_all"], ["", "lemma length4D: \"|xs| = 4 \\<Longrightarrow> \\<exists> a b c d. xs = [a, b, c, d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |xs| = 4 \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]", "apply (case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>|xs| = 4; xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]\n 2. \\<And>a list.\n       \\<lbrakk>|xs| = 4; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>|xs| = 4; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]", "apply (case_tac list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>|xs| = 4; xs = a # list; list = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]\n 2. \\<And>a list aa lista.\n       \\<lbrakk>|xs| = 4; xs = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list aa lista.\n       \\<lbrakk>|xs| = 4; xs = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]", "apply (case_tac lista)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list aa lista.\n       \\<lbrakk>|xs| = 4; xs = a # list; list = aa # lista;\n        lista = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]\n 2. \\<And>a list aa lista ab listb.\n       \\<lbrakk>|xs| = 4; xs = a # list; list = aa # lista;\n        lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list aa lista ab listb.\n       \\<lbrakk>|xs| = 4; xs = a # list; list = aa # lista;\n        lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]", "apply (case_tac listb)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list aa lista ab listb.\n       \\<lbrakk>|xs| = 4; xs = a # list; list = aa # lista;\n        lista = ab # listb; listb = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]\n 2. \\<And>a list aa lista ab listb ac listc.\n       \\<lbrakk>|xs| = 4; xs = a # list; list = aa # lista;\n        lista = ab # listb; listb = ac # listc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b c d. xs = [a, b, c, d]", "by simp_all"], ["", "subsubsection \\<open>@{const filter}\\<close>"], ["", "lemma filter_emptyE[dest]: \"(filter P xs = []) \\<Longrightarrow>  x \\<in> set xs \\<Longrightarrow>  \\<not> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>filter P xs = []; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<not> P x", "by (simp add: filter_empty_conv)"], ["", "lemma filter_comm: \"[x \\<leftarrow> xs. P x \\<and> Q x] = [x \\<leftarrow> xs. Q x \\<and> P x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. P x \\<and> Q x) xs =\n    filter (\\<lambda>x. Q x \\<and> P x) xs", "by (simp add: conj_aci)"], ["", "lemma filter_prop: \"x \\<in> set [u\\<leftarrow>ys . P u] \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (filter P ys) \\<Longrightarrow> P x", "proof (induct ys arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (filter P []) \\<Longrightarrow> P x\n 2. \\<And>a ys x.\n       \\<lbrakk>\\<And>x. x \\<in> set (filter P ys) \\<Longrightarrow> P x;\n        x \\<in> set (filter P (a # ys))\\<rbrakk>\n       \\<Longrightarrow> P x", "case Nil"], ["proof (state)\nthis:\n  x \\<in> set (filter P [])\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set (filter P []) \\<Longrightarrow> P x\n 2. \\<And>a ys x.\n       \\<lbrakk>\\<And>x. x \\<in> set (filter P ys) \\<Longrightarrow> P x;\n        x \\<in> set (filter P (a # ys))\\<rbrakk>\n       \\<Longrightarrow> P x", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (filter P [])", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> set (filter P [])\n\ngoal (1 subgoal):\n 1. P x", "by simp"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>a ys x.\n       \\<lbrakk>\\<And>x. x \\<in> set (filter P ys) \\<Longrightarrow> P x;\n        x \\<in> set (filter P (a # ys))\\<rbrakk>\n       \\<Longrightarrow> P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys x.\n       \\<lbrakk>\\<And>x. x \\<in> set (filter P ys) \\<Longrightarrow> P x;\n        x \\<in> set (filter P (a # ys))\\<rbrakk>\n       \\<Longrightarrow> P x", "case Cons"], ["proof (state)\nthis:\n  ?x \\<in> set (filter P ys_) \\<Longrightarrow> P ?x\n  x \\<in> set (filter P (a_ # ys_))\n\ngoal (1 subgoal):\n 1. \\<And>a ys x.\n       \\<lbrakk>\\<And>x. x \\<in> set (filter P ys) \\<Longrightarrow> P x;\n        x \\<in> set (filter P (a # ys))\\<rbrakk>\n       \\<Longrightarrow> P x", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> set (filter P ys_) \\<Longrightarrow> P ?x\n  x \\<in> set (filter P (a_ # ys_))", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> set (filter P ys_) \\<Longrightarrow> P ?x\n  x \\<in> set (filter P (a_ # ys_))\n\ngoal (1 subgoal):\n 1. P x", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_compl1: \n \"([x\\<leftarrow>xs. P x] = []) = ([x\\<leftarrow>xs. \\<not> P x] = xs)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (filter P xs = []) = (filter (\\<lambda>x. \\<not> P x) xs = xs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. filter P xs = [] \\<Longrightarrow>\n    filter (\\<lambda>x. \\<not> P x) xs = xs\n 2. filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow>\n    filter P xs = []", "show \"?rhs \\<Longrightarrow> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow>\n    filter P xs = []", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. filter (\\<lambda>x. \\<not> P x) [] = [] \\<Longrightarrow>\n    filter P [] = []\n 2. \\<And>a xs.\n       \\<lbrakk>filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow>\n                filter P xs = [];\n        filter (\\<lambda>x. \\<not> P x) (a # xs) = a # xs\\<rbrakk>\n       \\<Longrightarrow> filter P (a # xs) = []", "case Nil"], ["proof (state)\nthis:\n  filter (\\<lambda>x. \\<not> P x) [] = []\n\ngoal (2 subgoals):\n 1. filter (\\<lambda>x. \\<not> P x) [] = [] \\<Longrightarrow>\n    filter P [] = []\n 2. \\<And>a xs.\n       \\<lbrakk>filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow>\n                filter P xs = [];\n        filter (\\<lambda>x. \\<not> P x) (a # xs) = a # xs\\<rbrakk>\n       \\<Longrightarrow> filter P (a # xs) = []", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. \\<not> P x) [] = []", "show ?case"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. \\<not> P x) [] = []\n\ngoal (1 subgoal):\n 1. filter P [] = []", "by simp"], ["proof (state)\nthis:\n  filter P [] = []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow>\n                filter P xs = [];\n        filter (\\<lambda>x. \\<not> P x) (a # xs) = a # xs\\<rbrakk>\n       \\<Longrightarrow> filter P (a # xs) = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow>\n                filter P xs = [];\n        filter (\\<lambda>x. \\<not> P x) (a # xs) = a # xs\\<rbrakk>\n       \\<Longrightarrow> filter P (a # xs) = []", "case (Cons x xs)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow> filter P xs = []\n  filter (\\<lambda>x. \\<not> P x) (x # xs) = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow>\n                filter P xs = [];\n        filter (\\<lambda>x. \\<not> P x) (a # xs) = a # xs\\<rbrakk>\n       \\<Longrightarrow> filter P (a # xs) = []", "have \"[u\\<leftarrow>xs . \\<not> P u] \\<noteq> x # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>u. \\<not> P u) xs \\<noteq> x # xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. filter (\\<lambda>u. \\<not> P u) xs = x # xs \\<Longrightarrow> False", "assume \"[u\\<leftarrow>xs . \\<not> P u] = x # xs\""], ["proof (state)\nthis:\n  filter (\\<lambda>u. \\<not> P u) xs = x # xs\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>u. \\<not> P u) xs = x # xs \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>u. \\<not> P u) xs = x # xs", "have \"|x # xs| = |[u\\<leftarrow>xs . \\<not> P u]|\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>u. \\<not> P u) xs = x # xs\n\ngoal (1 subgoal):\n 1. |x # xs| = |filter (\\<lambda>u. \\<not> P u) xs|", "by simp"], ["proof (state)\nthis:\n  |x # xs| = |filter (\\<lambda>u. \\<not> P u) xs|\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>u. \\<not> P u) xs = x # xs \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  |x # xs| = |filter (\\<lambda>u. \\<not> P u) xs|\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>u. \\<not> P u) xs = x # xs \\<Longrightarrow> False", "have \"... \\<le> |xs|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |filter (\\<lambda>u. \\<not> P u) xs| \\<le> |xs|", "by simp"], ["proof (state)\nthis:\n  |filter (\\<lambda>u. \\<not> P u) xs| \\<le> |xs|\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>u. \\<not> P u) xs = x # xs \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  |x # xs| \\<le> |xs|", "show False"], ["proof (prove)\nusing this:\n  |x # xs| \\<le> |xs|\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter (\\<lambda>u. \\<not> P u) xs \\<noteq> x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow>\n                filter P xs = [];\n        filter (\\<lambda>x. \\<not> P x) (a # xs) = a # xs\\<rbrakk>\n       \\<Longrightarrow> filter P (a # xs) = []", "with Cons"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow> filter P xs = []\n  filter (\\<lambda>x. \\<not> P x) (x # xs) = x # xs\n  filter (\\<lambda>u. \\<not> P u) xs \\<noteq> x # xs", "show ?case"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow> filter P xs = []\n  filter (\\<lambda>x. \\<not> P x) (x # xs) = x # xs\n  filter (\\<lambda>u. \\<not> P u) xs \\<noteq> x # xs\n\ngoal (1 subgoal):\n 1. filter P (x # xs) = []", "by auto"], ["proof (state)\nthis:\n  filter P (x # xs) = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter (\\<lambda>x. \\<not> P x) xs = xs \\<Longrightarrow> filter P xs = []\n\ngoal (1 subgoal):\n 1. filter P xs = [] \\<Longrightarrow>\n    filter (\\<lambda>x. \\<not> P x) xs = xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. filter P xs = [] \\<Longrightarrow>\n    filter (\\<lambda>x. \\<not> P x) xs = xs", "show \"?lhs \\<Longrightarrow> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P xs = [] \\<Longrightarrow>\n    filter (\\<lambda>x. \\<not> P x) xs = xs", "by (induct xs) (simp_all split: if_split_asm)"], ["proof (state)\nthis:\n  filter P xs = [] \\<Longrightarrow> filter (\\<lambda>x. \\<not> P x) xs = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"Not \\<circ> (Not \\<circ> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Not \\<circ> (Not \\<circ> P) = P", "by (rule ext) simp"], ["", "lemma filter_eqI: \n  \"(\\<And>v. v \\<in> set vs \\<Longrightarrow> P v = Q v) \\<Longrightarrow> [v\\<leftarrow>vs . P v] = [v\\<leftarrow>vs . Q v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. v \\<in> set vs \\<Longrightarrow> P v = Q v) \\<Longrightarrow>\n    filter P vs = filter Q vs", "by (induct vs) simp_all"], ["", "lemma filter_simp: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> P x) \\<Longrightarrow> [x\\<leftarrow>xs. P x \\<and> Q x] = [x\\<leftarrow>xs. Q x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> set xs \\<Longrightarrow> P x) \\<Longrightarrow>\n    filter (\\<lambda>x. P x \\<and> Q x) xs = filter Q xs", "by (induct xs) auto"], ["", "lemma filter_True_eq1: \n  \"(length [y\\<leftarrow>xs. P y] = length xs) \\<Longrightarrow> (\\<And>y. y \\<in> set xs \\<Longrightarrow> P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |filter P xs| = |xs| \\<Longrightarrow>\n    (\\<And>y. y \\<in> set xs \\<Longrightarrow> P y)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>|filter P []| = |[]|; y \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> P y\n 2. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "case Nil"], ["proof (state)\nthis:\n  |filter P []| = |[]|\n  y \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>|filter P []| = |[]|; y \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> P y\n 2. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "then"], ["proof (chain)\npicking this:\n  |filter P []| = |[]|\n  y \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  |filter P []| = |[]|\n  y \\<in> set []\n\ngoal (1 subgoal):\n 1. P y", "by simp"], ["proof (state)\nthis:\n  P y\n\ngoal (1 subgoal):\n 1. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>|filter P xs| = |xs|; ?y \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> P ?y\n  |filter P (x # xs)| = |x # xs|\n  y \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "have l: \"length (filter P xs) \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |filter P xs| \\<le> |xs|", "by (simp add: length_filter_le)"], ["proof (state)\nthis:\n  |filter P xs| \\<le> |xs|\n\ngoal (1 subgoal):\n 1. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "have hyp: \"length (filter P (x # xs)) = length (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |filter P (x # xs)| = |x # xs|", "by fact"], ["proof (state)\nthis:\n  |filter P (x # xs)| = |x # xs|\n\ngoal (1 subgoal):\n 1. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "then"], ["proof (chain)\npicking this:\n  |filter P (x # xs)| = |x # xs|", "have \"P x\""], ["proof (prove)\nusing this:\n  |filter P (x # xs)| = |x # xs|\n\ngoal (1 subgoal):\n 1. P x", "by (simp split: if_split_asm) (insert l, arith)"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "moreover"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "with hyp"], ["proof (chain)\npicking this:\n  |filter P (x # xs)| = |x # xs|\n  P x", "have \"length (filter P xs) = length xs\""], ["proof (prove)\nusing this:\n  |filter P (x # xs)| = |x # xs|\n  P x\n\ngoal (1 subgoal):\n 1. |filter P xs| = |xs|", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  |filter P xs| = |xs|\n\ngoal (1 subgoal):\n 1. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "moreover"], ["proof (state)\nthis:\n  |filter P xs| = |xs|\n\ngoal (1 subgoal):\n 1. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "have \"y \\<in> set (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set (x # xs)", "by fact"], ["proof (state)\nthis:\n  y \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>|filter P xs| = |xs|; y \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        |filter P (a # xs)| = |a # xs|; y \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P y", "ultimately"], ["proof (chain)\npicking this:\n  P x\n  |filter P xs| = |xs|\n  y \\<in> set (x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  P x\n  |filter P xs| = |xs|\n  y \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. P y", "by (auto dest: Cons(1))"], ["proof (state)\nthis:\n  P y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"[f x. x <- xs, P x] = [f x. x <- [x \\<leftarrow> xs. P x]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (\\<lambda>x. if P x then [f x] else []) xs) =\n    map f (filter P xs)", "by (induct xs) auto"], ["", "subsubsection \\<open>@{const concat}\\<close>"], ["", "syntax\n  \"_concat\" :: \"idt \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"  (\"\\<Squnion>\\<^bsub>_\\<in> _\\<^esub> _\" 10)"], ["", "translations\n  \"\\<Squnion>\\<^bsub>x\\<in>xs\\<^esub> f\" == \"CONST concat [f. x <- xs]\""], ["", "subsubsection \\<open>List product\\<close>"], ["", "definition listProd1 :: \"'a \\<Rightarrow> 'b list \\<Rightarrow> ('a \\<times> 'b) list\" where\n \"listProd1 a bs \\<equiv> [(a,b). b <- bs]\""], ["", "definition listProd :: \"'a list \\<Rightarrow> 'b list \\<Rightarrow> ('a \\<times> 'b) list\" (infix \"\\<times>\" 50) where\n \"as \\<times> bs \\<equiv> \\<Squnion>\\<^bsub>a \\<in> as\\<^esub> listProd1 a bs\""], ["", "lemma(*<*)[simp]: (*>*) \"set (xs \\<times> ys) = (set xs) \\<times> (set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xs \\<times> ys) = set xs \\<times> set ys", "by (auto simp: listProd_def listProd1_def)"], ["", "subsubsection \\<open>Minimum and maximum\\<close>"], ["", "primrec minimal:: \"('a \\<Rightarrow> nat) \\<Rightarrow> 'a list \\<Rightarrow> 'a\" where\n \"minimal m (x#xs) =\n  (if xs=[] then x else\n   let mxs = minimal m xs in\n   if m x \\<le> m mxs then x else mxs)\""], ["", "lemma minimal_in_set[simp]: \"xs \\<noteq> [] \\<Longrightarrow> minimal f xs : set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> minimal f xs \\<in> set xs", "by(induct xs) auto"], ["", "primrec min_list :: \"nat list \\<Rightarrow> nat\" where\n  \"min_list (x#xs) = (if xs=[] then x else min x (min_list xs))\""], ["", "primrec max_list :: \"nat list \\<Rightarrow> nat\" where\n  \"max_list (x#xs) = (if xs=[] then x else max x (max_list xs))\""], ["", "lemma min_list_conv_Min[simp]:\n \"xs \\<noteq> [] \\<Longrightarrow> min_list xs = Min (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> ListAux.min_list xs = Min (set xs)", "by (induct xs) auto"], ["", "lemma max_list_conv_Max[simp]:\n \"xs \\<noteq> [] \\<Longrightarrow> max_list xs = Max (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> max_list xs = Max (set xs)", "by (induct xs) auto"], ["", "subsubsection \\<open>replace\\<close>"], ["", "primrec replace :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow>  'a list\" where\n  \"replace x ys [] = []\"\n| \"replace x ys (z#zs) = \n     (if z = x then ys @ zs else z # (replace x ys zs))\""], ["", "primrec mapAt :: \"nat list \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> ('a list \\<Rightarrow> 'a list)\" where\n  \"mapAt [] f as = as\"\n| \"mapAt (n#ns) f as = \n     (if n < |as| then mapAt ns f (as[n:= f (as!n)])\n     else mapAt ns f as)\""], ["", "lemma length_mapAt[simp]: \"\\<And>xs. length(mapAt vs f xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. |mapAt vs f xs| = |xs|", "by(induct vs) auto"], ["", "lemma length_replace1[simp]: \"length(replace x [y] xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |replace x [y] xs| = |xs|", "by(induct xs) simp_all"], ["", "lemma replace_id[simp]: \"replace x [x] xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace x [x] xs = xs", "by(induct xs) simp_all"], ["", "lemma len_replace_ge_same:\n\"length ys \\<ge> 1 \\<Longrightarrow> length(replace x ys xs) \\<ge> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> |ys| \\<Longrightarrow> |xs| \\<le> |replace x ys xs|", "by (induct xs) auto"], ["", "lemma len_replace_ge[simp]:\n\"\\<lbrakk> length ys \\<ge> 1; length xs \\<ge> length zs \\<rbrakk> \\<Longrightarrow>\n length(replace x ys xs) \\<ge> length zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> |ys|; |zs| \\<le> |xs|\\<rbrakk>\n    \\<Longrightarrow> |zs| \\<le> |replace x ys xs|", "apply(drule len_replace_ge_same[where x = x and xs = xs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>|zs| \\<le> |xs|; |xs| \\<le> |replace x ys xs|\\<rbrakk>\n    \\<Longrightarrow> |zs| \\<le> |replace x ys xs|", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma replace_append[simp]:\n  \"replace x ys (as @ bs) =\n   (if x \\<in> set as then replace x ys as @ bs else as @ replace x ys bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace x ys (as @ bs) =\n    (if x \\<in> set as then replace x ys as @ bs else as @ replace x ys bs)", "by(induct as) auto"], ["", "lemma distinct_set_replace: \"distinct xs \\<Longrightarrow>\n set (replace x ys xs) =\n (if x \\<in> set xs then (set xs - {x}) \\<union> set ys else set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow>\n    set (replace x ys xs) =\n    (if x \\<in> set xs then set xs - {x} \\<union> set ys else set xs)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    set (replace x ys []) =\n    (if x \\<in> set [] then set [] - {x} \\<union> set ys else set [])\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (replace x ys xs) =\n                (if x \\<in> set xs then set xs - {x} \\<union> set ys\n                 else set xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (replace x ys (a # xs)) =\n                         (if x \\<in> set (a # xs)\n                          then set (a # xs) - {x} \\<union> set ys\n                          else set (a # xs))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow>\n                set (replace x ys xs) =\n                (if x \\<in> set xs then set xs - {x} \\<union> set ys\n                 else set xs);\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (replace x ys (a # xs)) =\n                         (if x \\<in> set (a # xs)\n                          then set (a # xs) - {x} \\<union> set ys\n                          else set (a # xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>set (replace x ys xs) =\n                (if x \\<in> set xs then set xs - {x} \\<union> set ys\n                 else set xs);\n        a \\<notin> set xs \\<and> distinct xs\\<rbrakk>\n       \\<Longrightarrow> (a = x \\<longrightarrow>\n                          set ys \\<union> set xs =\n                          set xs \\<union> set ys \\<and>\n                          (x \\<in> set xs \\<longrightarrow>\n                           set ys \\<union> set xs =\n                           set xs - {x} \\<union> set ys)) \\<and>\n                         (a \\<noteq> x \\<longrightarrow>\n                          x \\<in> set xs \\<longrightarrow>\n                          insert a (set xs - {x} \\<union> set ys) =\n                          insert a (set xs) - {x} \\<union> set ys)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma replace1:\n \"f \\<in> set (replace f' fs ls ) \\<Longrightarrow> f \\<notin> set ls \\<Longrightarrow> f \\<in> set fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> set (replace f' fs ls); f \\<notin> set ls\\<rbrakk>\n    \\<Longrightarrow> f \\<in> set fs", "proof (induct ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> set (replace f' fs []); f \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> f \\<in> set fs\n 2. \\<And>a ls.\n       \\<lbrakk>\\<lbrakk>f \\<in> set (replace f' fs ls);\n                 f \\<notin> set ls\\<rbrakk>\n                \\<Longrightarrow> f \\<in> set fs;\n        f \\<in> set (replace f' fs (a # ls));\n        f \\<notin> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> f \\<in> set fs", "case Nil"], ["proof (state)\nthis:\n  f \\<in> set (replace f' fs [])\n  f \\<notin> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> set (replace f' fs []); f \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> f \\<in> set fs\n 2. \\<And>a ls.\n       \\<lbrakk>\\<lbrakk>f \\<in> set (replace f' fs ls);\n                 f \\<notin> set ls\\<rbrakk>\n                \\<Longrightarrow> f \\<in> set fs;\n        f \\<in> set (replace f' fs (a # ls));\n        f \\<notin> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> f \\<in> set fs", "then"], ["proof (chain)\npicking this:\n  f \\<in> set (replace f' fs [])\n  f \\<notin> set []", "show ?case"], ["proof (prove)\nusing this:\n  f \\<in> set (replace f' fs [])\n  f \\<notin> set []\n\ngoal (1 subgoal):\n 1. f \\<in> set fs", "by simp"], ["proof (state)\nthis:\n  f \\<in> set fs\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>\\<lbrakk>f \\<in> set (replace f' fs ls);\n                 f \\<notin> set ls\\<rbrakk>\n                \\<Longrightarrow> f \\<in> set fs;\n        f \\<in> set (replace f' fs (a # ls));\n        f \\<notin> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> f \\<in> set fs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>\\<lbrakk>f \\<in> set (replace f' fs ls);\n                 f \\<notin> set ls\\<rbrakk>\n                \\<Longrightarrow> f \\<in> set fs;\n        f \\<in> set (replace f' fs (a # ls));\n        f \\<notin> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> f \\<in> set fs", "case (Cons l ls)"], ["proof (state)\nthis:\n  \\<lbrakk>f \\<in> set (replace f' fs ls); f \\<notin> set ls\\<rbrakk>\n  \\<Longrightarrow> f \\<in> set fs\n  f \\<in> set (replace f' fs (l # ls))\n  f \\<notin> set (l # ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>\\<lbrakk>f \\<in> set (replace f' fs ls);\n                 f \\<notin> set ls\\<rbrakk>\n                \\<Longrightarrow> f \\<in> set fs;\n        f \\<in> set (replace f' fs (a # ls));\n        f \\<notin> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> f \\<in> set fs", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>f \\<in> set (replace f' fs ls); f \\<notin> set ls\\<rbrakk>\n  \\<Longrightarrow> f \\<in> set fs\n  f \\<in> set (replace f' fs (l # ls))\n  f \\<notin> set (l # ls)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>f \\<in> set (replace f' fs ls); f \\<notin> set ls\\<rbrakk>\n  \\<Longrightarrow> f \\<in> set fs\n  f \\<in> set (replace f' fs (l # ls))\n  f \\<notin> set (l # ls)\n\ngoal (1 subgoal):\n 1. f \\<in> set fs", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  f \\<in> set fs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replace2:\n \"f' \\<notin> set ls \\<Longrightarrow> replace f' fs ls  = ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' \\<notin> set ls \\<Longrightarrow> replace f' fs ls = ls", "proof (induct ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. f' \\<notin> set [] \\<Longrightarrow> replace f' fs [] = []\n 2. \\<And>a ls.\n       \\<lbrakk>f' \\<notin> set ls \\<Longrightarrow> replace f' fs ls = ls;\n        f' \\<notin> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> replace f' fs (a # ls) = a # ls", "case Nil"], ["proof (state)\nthis:\n  f' \\<notin> set []\n\ngoal (2 subgoals):\n 1. f' \\<notin> set [] \\<Longrightarrow> replace f' fs [] = []\n 2. \\<And>a ls.\n       \\<lbrakk>f' \\<notin> set ls \\<Longrightarrow> replace f' fs ls = ls;\n        f' \\<notin> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> replace f' fs (a # ls) = a # ls", "then"], ["proof (chain)\npicking this:\n  f' \\<notin> set []", "show ?case"], ["proof (prove)\nusing this:\n  f' \\<notin> set []\n\ngoal (1 subgoal):\n 1. replace f' fs [] = []", "by simp"], ["proof (state)\nthis:\n  replace f' fs [] = []\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>f' \\<notin> set ls \\<Longrightarrow> replace f' fs ls = ls;\n        f' \\<notin> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> replace f' fs (a # ls) = a # ls", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>f' \\<notin> set ls \\<Longrightarrow> replace f' fs ls = ls;\n        f' \\<notin> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> replace f' fs (a # ls) = a # ls", "case (Cons l ls)"], ["proof (state)\nthis:\n  f' \\<notin> set ls \\<Longrightarrow> replace f' fs ls = ls\n  f' \\<notin> set (l # ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       \\<lbrakk>f' \\<notin> set ls \\<Longrightarrow> replace f' fs ls = ls;\n        f' \\<notin> set (a # ls)\\<rbrakk>\n       \\<Longrightarrow> replace f' fs (a # ls) = a # ls", "then"], ["proof (chain)\npicking this:\n  f' \\<notin> set ls \\<Longrightarrow> replace f' fs ls = ls\n  f' \\<notin> set (l # ls)", "show ?case"], ["proof (prove)\nusing this:\n  f' \\<notin> set ls \\<Longrightarrow> replace f' fs ls = ls\n  f' \\<notin> set (l # ls)\n\ngoal (1 subgoal):\n 1. replace f' fs (l # ls) = l # ls", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  replace f' fs (l # ls) = l # ls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replace3[intro]:\n  \"f' \\<in> set ls \\<Longrightarrow> f \\<in> set fs \\<Longrightarrow> f \\<in> set (replace f' fs ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f' \\<in> set ls; f \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> f \\<in> set (replace f' fs ls)", "by (induct ls) auto"], ["", "lemma replace4:\n  \"f \\<in> set ls \\<Longrightarrow> oldF \\<noteq> f \\<Longrightarrow> f \\<in> set (replace oldF fs ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> set ls; oldF \\<noteq> f\\<rbrakk>\n    \\<Longrightarrow> f \\<in> set (replace oldF fs ls)", "by (induct ls) auto"], ["", "lemma replace5: \"f \\<in> set (replace oldF newfs fs) \\<Longrightarrow> f \\<in> set fs \\<or> f \\<in> set newfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set (replace oldF newfs fs) \\<Longrightarrow>\n    f \\<in> set fs \\<or> f \\<in> set newfs", "by (induct fs) (auto split: if_split_asm)"], ["", "lemma replace6: \"distinct oldfs \\<Longrightarrow> x \\<in> set (replace oldF newfs oldfs) = \n  ((x \\<noteq> oldF \\<or> oldF \\<in> set newfs) \\<and> ((oldF \\<in> set oldfs \\<and> x \\<in> set newfs) \\<or> x \\<in> set oldfs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct oldfs \\<Longrightarrow>\n    (x \\<in> set (replace oldF newfs oldfs)) =\n    ((x \\<noteq> oldF \\<or> oldF \\<in> set newfs) \\<and>\n     (oldF \\<in> set oldfs \\<and> x \\<in> set newfs \\<or>\n      x \\<in> set oldfs))", "by (induct oldfs) auto"], ["", "lemma distinct_replace: \n\"distinct fs \\<Longrightarrow> distinct newFs \\<Longrightarrow> set fs \\<inter> set newFs \\<subseteq> {oldF} \\<Longrightarrow>\n distinct (replace oldF newFs fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct fs; distinct newFs;\n     set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs fs)", "proof (induct fs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; distinct newFs;\n     set [] \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs [])\n 2. \\<And>a fs.\n       \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n                 set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n                \\<Longrightarrow> distinct (replace oldF newFs fs);\n        distinct (a # fs); distinct newFs;\n        set (a # fs) \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n       \\<Longrightarrow> distinct (replace oldF newFs (a # fs))", "case Nil"], ["proof (state)\nthis:\n  distinct []\n  distinct newFs\n  set [] \\<inter> set newFs \\<subseteq> {oldF}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; distinct newFs;\n     set [] \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs [])\n 2. \\<And>a fs.\n       \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n                 set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n                \\<Longrightarrow> distinct (replace oldF newFs fs);\n        distinct (a # fs); distinct newFs;\n        set (a # fs) \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n       \\<Longrightarrow> distinct (replace oldF newFs (a # fs))", "then"], ["proof (chain)\npicking this:\n  distinct []\n  distinct newFs\n  set [] \\<inter> set newFs \\<subseteq> {oldF}", "show ?case"], ["proof (prove)\nusing this:\n  distinct []\n  distinct newFs\n  set [] \\<inter> set newFs \\<subseteq> {oldF}\n\ngoal (1 subgoal):\n 1. distinct (replace oldF newFs [])", "by simp"], ["proof (state)\nthis:\n  distinct (replace oldF newFs [])\n\ngoal (1 subgoal):\n 1. \\<And>a fs.\n       \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n                 set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n                \\<Longrightarrow> distinct (replace oldF newFs fs);\n        distinct (a # fs); distinct newFs;\n        set (a # fs) \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n       \\<Longrightarrow> distinct (replace oldF newFs (a # fs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a fs.\n       \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n                 set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n                \\<Longrightarrow> distinct (replace oldF newFs fs);\n        distinct (a # fs); distinct newFs;\n        set (a # fs) \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n       \\<Longrightarrow> distinct (replace oldF newFs (a # fs))", "case (Cons f fs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct fs; distinct newFs;\n   set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n  \\<Longrightarrow> distinct (replace oldF newFs fs)\n  distinct (f # fs)\n  distinct newFs\n  set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}\n\ngoal (1 subgoal):\n 1. \\<And>a fs.\n       \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n                 set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n                \\<Longrightarrow> distinct (replace oldF newFs fs);\n        distinct (a # fs); distinct newFs;\n        set (a # fs) \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n       \\<Longrightarrow> distinct (replace oldF newFs (a # fs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct fs; distinct newFs;\n   set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n  \\<Longrightarrow> distinct (replace oldF newFs fs)\n  distinct (f # fs)\n  distinct newFs\n  set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct fs; distinct newFs;\n   set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n  \\<Longrightarrow> distinct (replace oldF newFs fs)\n  distinct (f # fs)\n  distinct newFs\n  set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}\n\ngoal (1 subgoal):\n 1. distinct (replace oldF newFs (f # fs))", "proof (cases \"f = oldF\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}; f = oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))\n 2. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF};\n     f \\<noteq> oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))", "case True"], ["proof (state)\nthis:\n  f = oldF\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}; f = oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))\n 2. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF};\n     f \\<noteq> oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct fs; distinct newFs;\n   set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n  \\<Longrightarrow> distinct (replace oldF newFs fs)\n  distinct (f # fs)\n  distinct newFs\n  set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}\n  f = oldF", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct fs; distinct newFs;\n   set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n  \\<Longrightarrow> distinct (replace oldF newFs fs)\n  distinct (f # fs)\n  distinct newFs\n  set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}\n  f = oldF\n\ngoal (1 subgoal):\n 1. distinct (replace oldF newFs (f # fs))", "by simp blast"], ["proof (state)\nthis:\n  distinct (replace oldF newFs (f # fs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF};\n     f \\<noteq> oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF};\n     f \\<noteq> oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))", "case False"], ["proof (state)\nthis:\n  f \\<noteq> oldF\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF};\n     f \\<noteq> oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))", "moreover"], ["proof (state)\nthis:\n  f \\<noteq> oldF\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF};\n     f \\<noteq> oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct fs; distinct newFs;\n   set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n  \\<Longrightarrow> distinct (replace oldF newFs fs)\n  distinct (f # fs)\n  distinct newFs\n  set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}\n  f \\<noteq> oldF", "have \"f \\<notin> set newFs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct fs; distinct newFs;\n   set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n  \\<Longrightarrow> distinct (replace oldF newFs fs)\n  distinct (f # fs)\n  distinct newFs\n  set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}\n  f \\<noteq> oldF\n\ngoal (1 subgoal):\n 1. f \\<notin> set newFs", "by simp blast"], ["proof (state)\nthis:\n  f \\<notin> set newFs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF};\n     f \\<noteq> oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct fs; distinct newFs;\n   set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n  \\<Longrightarrow> distinct (replace oldF newFs fs)\n  distinct (f # fs)\n  distinct newFs\n  set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}\n  f \\<notin> set newFs", "have \"f \\<notin> set (replace oldF newFs fs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct fs; distinct newFs;\n   set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n  \\<Longrightarrow> distinct (replace oldF newFs fs)\n  distinct (f # fs)\n  distinct newFs\n  set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}\n  f \\<notin> set newFs\n\ngoal (1 subgoal):\n 1. f \\<notin> set (replace oldF newFs fs)", "by simp (blast dest: replace1)"], ["proof (state)\nthis:\n  f \\<notin> set (replace oldF newFs fs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF};\n     f \\<noteq> oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))", "moreover"], ["proof (state)\nthis:\n  f \\<notin> set (replace oldF newFs fs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF};\n     f \\<noteq> oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct fs; distinct newFs;\n   set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n  \\<Longrightarrow> distinct (replace oldF newFs fs)\n  distinct (f # fs)\n  distinct newFs\n  set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}", "have \"distinct (replace oldF newFs fs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct fs; distinct newFs;\n   set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n  \\<Longrightarrow> distinct (replace oldF newFs fs)\n  distinct (f # fs)\n  distinct newFs\n  set (f # fs) \\<inter> set newFs \\<subseteq> {oldF}\n\ngoal (1 subgoal):\n 1. distinct (replace oldF newFs fs)", "by (rule_tac Cons) auto"], ["proof (state)\nthis:\n  distinct (replace oldF newFs fs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct fs; distinct newFs;\n              set fs \\<inter> set newFs \\<subseteq> {oldF}\\<rbrakk>\n             \\<Longrightarrow> distinct (replace oldF newFs fs);\n     distinct (f # fs); distinct newFs;\n     set (f # fs) \\<inter> set newFs \\<subseteq> {oldF};\n     f \\<noteq> oldF\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldF newFs (f # fs))", "ultimately"], ["proof (chain)\npicking this:\n  f \\<noteq> oldF\n  f \\<notin> set (replace oldF newFs fs)\n  distinct (replace oldF newFs fs)", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<noteq> oldF\n  f \\<notin> set (replace oldF newFs fs)\n  distinct (replace oldF newFs fs)\n\ngoal (1 subgoal):\n 1. distinct (replace oldF newFs (f # fs))", "by simp"], ["proof (state)\nthis:\n  distinct (replace oldF newFs (f # fs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (replace oldF newFs (f # fs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replace_replace[simp]: \"oldf \\<notin> set newfs \\<Longrightarrow> distinct xs \\<Longrightarrow> \n  replace oldf newfs (replace oldf newfs xs) = replace oldf newfs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oldf \\<notin> set newfs; distinct xs\\<rbrakk>\n    \\<Longrightarrow> replace oldf newfs (replace oldf newfs xs) =\n                      replace oldf newfs xs", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>oldf \\<notin> set newfs; distinct []\\<rbrakk>\n    \\<Longrightarrow> replace oldf newfs (replace oldf newfs []) =\n                      replace oldf newfs []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>oldf \\<notin> set newfs; distinct xs\\<rbrakk>\n                \\<Longrightarrow> replace oldf newfs\n                                   (replace oldf newfs xs) =\n                                  replace oldf newfs xs;\n        oldf \\<notin> set newfs; distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> replace oldf newfs (replace oldf newfs (a # xs)) =\n                         replace oldf newfs (a # xs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>replace oldf newfs (replace oldf newfs xs) =\n                replace oldf newfs xs;\n        oldf \\<notin> set newfs; oldf \\<notin> set xs; distinct xs\\<rbrakk>\n       \\<Longrightarrow> replace oldf newfs xs = xs", "apply (rule replace2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>replace oldf newfs (replace oldf newfs xs) =\n                replace oldf newfs xs;\n        oldf \\<notin> set newfs; oldf \\<notin> set xs; distinct xs\\<rbrakk>\n       \\<Longrightarrow> oldf \\<notin> set xs", "by simp"], ["", "lemma replace_distinct: \"distinct fs \\<Longrightarrow> distinct newfs \\<Longrightarrow> oldf \\<in> set fs \\<longrightarrow> set newfs \\<inter> set fs \\<subseteq> {oldf} \\<Longrightarrow> \n  distinct (replace oldf newfs fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct fs; distinct newfs;\n     oldf \\<in> set fs \\<longrightarrow>\n     set newfs \\<inter> set fs \\<subseteq> {oldf}\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldf newfs fs)", "apply (case_tac \"oldf \\<in> set fs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct fs; distinct newfs;\n     oldf \\<in> set fs \\<longrightarrow>\n     set newfs \\<inter> set fs \\<subseteq> {oldf};\n     oldf \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldf newfs fs)\n 2. \\<lbrakk>distinct fs; distinct newfs;\n     oldf \\<in> set fs \\<longrightarrow>\n     set newfs \\<inter> set fs \\<subseteq> {oldf};\n     oldf \\<notin> set fs\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldf newfs fs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct fs; distinct newfs;\n     set newfs \\<inter> set fs \\<subseteq> {oldf};\n     oldf \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldf newfs fs)\n 2. \\<lbrakk>distinct fs; distinct newfs;\n     oldf \\<in> set fs \\<longrightarrow>\n     set newfs \\<inter> set fs \\<subseteq> {oldf};\n     oldf \\<notin> set fs\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldf newfs fs)", "apply (induct fs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct []; distinct newfs;\n     set newfs \\<inter> set [] \\<subseteq> {oldf};\n     oldf \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldf newfs [])\n 2. \\<And>a fs.\n       \\<lbrakk>\\<lbrakk>distinct fs; distinct newfs;\n                 set newfs \\<inter> set fs \\<subseteq> {oldf};\n                 oldf \\<in> set fs\\<rbrakk>\n                \\<Longrightarrow> distinct (replace oldf newfs fs);\n        distinct (a # fs); distinct newfs;\n        set newfs \\<inter> set (a # fs) \\<subseteq> {oldf};\n        oldf \\<in> set (a # fs)\\<rbrakk>\n       \\<Longrightarrow> distinct (replace oldf newfs (a # fs))\n 3. \\<lbrakk>distinct fs; distinct newfs;\n     oldf \\<in> set fs \\<longrightarrow>\n     set newfs \\<inter> set fs \\<subseteq> {oldf};\n     oldf \\<notin> set fs\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldf newfs fs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a fs.\n       \\<lbrakk>\\<lbrakk>distinct fs; distinct newfs;\n                 set newfs \\<inter> set fs \\<subseteq> {oldf};\n                 oldf \\<in> set fs\\<rbrakk>\n                \\<Longrightarrow> distinct (replace oldf newfs fs);\n        distinct (a # fs); distinct newfs;\n        set newfs \\<inter> set (a # fs) \\<subseteq> {oldf};\n        oldf \\<in> set (a # fs)\\<rbrakk>\n       \\<Longrightarrow> distinct (replace oldf newfs (a # fs))\n 2. \\<lbrakk>distinct fs; distinct newfs;\n     oldf \\<in> set fs \\<longrightarrow>\n     set newfs \\<inter> set fs \\<subseteq> {oldf};\n     oldf \\<notin> set fs\\<rbrakk>\n    \\<Longrightarrow> distinct (replace oldf newfs fs)", "apply (auto simp: replace2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a fs.\n       \\<lbrakk>set newfs \\<inter> set fs\n                \\<subseteq> {oldf} \\<Longrightarrow>\n                distinct (replace oldf newfs fs);\n        distinct newfs;\n        set newfs \\<inter> insert a (set fs) \\<subseteq> {oldf};\n        a \\<notin> set fs; distinct fs; oldf \\<in> set fs; a \\<noteq> oldf;\n        a \\<in> set (replace oldf newfs fs)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule replace1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a fs.\n       \\<lbrakk>set newfs \\<inter> set fs\n                \\<subseteq> {oldf} \\<Longrightarrow>\n                distinct (replace oldf newfs fs);\n        distinct newfs;\n        set newfs \\<inter> insert a (set fs) \\<subseteq> {oldf};\n        a \\<notin> set fs; distinct fs; oldf \\<in> set fs;\n        a \\<noteq> oldf\\<rbrakk>\n       \\<Longrightarrow> a \\<notin> set fs\n 2. \\<And>a fs.\n       \\<lbrakk>set newfs \\<inter> set fs\n                \\<subseteq> {oldf} \\<Longrightarrow>\n                distinct (replace oldf newfs fs);\n        distinct newfs;\n        set newfs \\<inter> insert a (set fs) \\<subseteq> {oldf};\n        a \\<notin> set fs; distinct fs; oldf \\<in> set fs; a \\<noteq> oldf;\n        a \\<in> set newfs\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["", "lemma filter_replace2:\n \"\\<lbrakk> \\<not> P x; \\<forall>y\\<in> set ys. \\<not> P y \\<rbrakk> \\<Longrightarrow>\n  filter P (replace x ys xs) = filter P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P x; \\<forall>y\\<in>set ys. \\<not> P y\\<rbrakk>\n    \\<Longrightarrow> filter P (replace x ys xs) = filter P xs", "apply(cases \"x \\<in> set xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<forall>y\\<in>set ys. \\<not> P y;\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> filter P (replace x ys xs) = filter P xs\n 2. \\<lbrakk>\\<not> P x; \\<forall>y\\<in>set ys. \\<not> P y;\n     x \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> filter P (replace x ys xs) = filter P xs", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<forall>y\\<in>set ys. \\<not> P y;\n     x \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> filter P (replace x ys xs) = filter P xs\n 2. \\<lbrakk>\\<not> P x; \\<forall>y\\<in>set ys. \\<not> P y;\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> filter P (replace x ys xs) = filter P xs", "apply(simp add:replace2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P x; \\<forall>y\\<in>set ys. \\<not> P y;\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> filter P (replace x ys xs) = filter P xs", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> P x; \\<forall>y\\<in>set ys. \\<not> P y;\n     x \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> filter P (replace x ys []) = filter P []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<not> P x; \\<forall>y\\<in>set ys. \\<not> P y;\n                 x \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> filter P (replace x ys xs) = filter P xs;\n        \\<not> P x; \\<forall>y\\<in>set ys. \\<not> P y;\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> filter P (replace x ys (a # xs)) =\n                         filter P (a # xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<not> P x; \\<forall>y\\<in>set ys. \\<not> P y;\n                 x \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> filter P (replace x ys xs) = filter P xs;\n        \\<not> P x; \\<forall>y\\<in>set ys. \\<not> P y;\n        x \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> filter P (replace x ys (a # xs)) =\n                         filter P (a # xs)", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_filter_replace1:\n \"\\<lbrakk> x \\<in> set xs; \\<not> P x \\<rbrakk> \\<Longrightarrow>\n  length(filter P (replace x ys xs)) =\n  length(filter P xs) + length(filter P ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> |filter P (replace x ys xs)| =\n                      |filter P xs| + |filter P ys|", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set []; \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> |filter P (replace x ys [])| =\n                      |filter P []| + |filter P ys|\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n                \\<Longrightarrow> |filter P (replace x ys xs)| =\n                                  |filter P xs| + |filter P ys|;\n        x \\<in> set (a # xs); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> |filter P (replace x ys (a # xs))| =\n                         |filter P (a # xs)| + |filter P ys|", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n                \\<Longrightarrow> |filter P (replace x ys xs)| =\n                                  |filter P xs| + |filter P ys|;\n        x \\<in> set (a # xs); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> |filter P (replace x ys (a # xs))| =\n                         |filter P (a # xs)| + |filter P ys|", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_filter_replace2:\n \"\\<lbrakk> x \\<in> set xs; P x \\<rbrakk> \\<Longrightarrow>\n  length(filter P (replace x ys xs)) =\n  length(filter P xs) + length(filter P ys) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n    \\<Longrightarrow> |filter P (replace x ys xs)| =\n                      |filter P xs| + |filter P ys| - 1", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set []; P x\\<rbrakk>\n    \\<Longrightarrow> |filter P (replace x ys [])| =\n                      |filter P []| + |filter P ys| - 1\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                \\<Longrightarrow> |filter P (replace x ys xs)| =\n                                  |filter P xs| + |filter P ys| - 1;\n        x \\<in> set (a # xs); P x\\<rbrakk>\n       \\<Longrightarrow> |filter P (replace x ys (a # xs))| =\n                         |filter P (a # xs)| + |filter P ys| - 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                \\<Longrightarrow> |filter P (replace x ys xs)| =\n                                  |filter P xs| + |filter P ys| - 1;\n        x \\<in> set (a # xs); P x\\<rbrakk>\n       \\<Longrightarrow> |filter P (replace x ys (a # xs))| =\n                         |filter P (a # xs)| + |filter P ys| - 1", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>|filter P (replace x ys xs)| =\n                |filter P xs| + |filter P ys| - Suc 0;\n        P x; x \\<in> set xs; P a; a \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> Suc (|filter P xs| + |filter P ys| - Suc 0) =\n                         |filter P xs| + |filter P ys|", "apply(drule split_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>|filter P (replace x ys xs)| =\n                |filter P xs| + |filter P ys| - Suc 0;\n        P x; P a; a \\<noteq> x; \\<exists>ys zs. xs = ys @ x # zs\\<rbrakk>\n       \\<Longrightarrow> Suc (|filter P xs| + |filter P ys| - Suc 0) =\n                         |filter P xs| + |filter P ys|", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>@{const\"distinct\"}\\<close>"], ["", "lemma dist_at1: \"\\<And> c vs. distinct vs \\<Longrightarrow> vs = a @ r # b \\<Longrightarrow> vs = c @ r # d \\<Longrightarrow> a = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c vs.\n       \\<lbrakk>distinct vs; vs = a @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a = c", "proof (induct a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c vs.\n       \\<lbrakk>distinct vs; vs = [] @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> [] = c\n 2. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "case Nil"], ["proof (state)\nthis:\n  distinct vs\n  vs = [] @ r # b\n  vs = c @ r # d\n\ngoal (2 subgoals):\n 1. \\<And>c vs.\n       \\<lbrakk>distinct vs; vs = [] @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> [] = c\n 2. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "assume dist: \"distinct vs\" and vs1: \"vs = [] @ r # b\" and vs2: \"vs = c @ r # d\""], ["proof (state)\nthis:\n  distinct vs\n  vs = [] @ r # b\n  vs = c @ r # d\n\ngoal (2 subgoals):\n 1. \\<And>c vs.\n       \\<lbrakk>distinct vs; vs = [] @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> [] = c\n 2. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "from dist vs2"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = c @ r # d", "have rc: \"r \\<notin> set c\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = c @ r # d\n\ngoal (1 subgoal):\n 1. r \\<notin> set c", "by auto"], ["proof (state)\nthis:\n  r \\<notin> set c\n\ngoal (2 subgoals):\n 1. \\<And>c vs.\n       \\<lbrakk>distinct vs; vs = [] @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> [] = c\n 2. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "from vs1 vs2"], ["proof (chain)\npicking this:\n  vs = [] @ r # b\n  vs = c @ r # d", "have \"c @ r # d = r # b\""], ["proof (prove)\nusing this:\n  vs = [] @ r # b\n  vs = c @ r # d\n\ngoal (1 subgoal):\n 1. c @ r # d = r # b", "by auto"], ["proof (state)\nthis:\n  c @ r # d = r # b\n\ngoal (2 subgoals):\n 1. \\<And>c vs.\n       \\<lbrakk>distinct vs; vs = [] @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> [] = c\n 2. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "then"], ["proof (chain)\npicking this:\n  c @ r # d = r # b", "have \"hd (c @ r # d) = r\""], ["proof (prove)\nusing this:\n  c @ r # d = r # b\n\ngoal (1 subgoal):\n 1. hd (c @ r # d) = r", "by auto"], ["proof (state)\nthis:\n  hd (c @ r # d) = r\n\ngoal (2 subgoals):\n 1. \\<And>c vs.\n       \\<lbrakk>distinct vs; vs = [] @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> [] = c\n 2. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "then"], ["proof (chain)\npicking this:\n  hd (c @ r # d) = r", "have \"c \\<noteq> [] \\<Longrightarrow> hd c = r\""], ["proof (prove)\nusing this:\n  hd (c @ r # d) = r\n\ngoal (1 subgoal):\n 1. c \\<noteq> [] \\<Longrightarrow> hd c = r", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> [] \\<Longrightarrow> hd c = r\n\ngoal (2 subgoals):\n 1. \\<And>c vs.\n       \\<lbrakk>distinct vs; vs = [] @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> [] = c\n 2. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "then"], ["proof (chain)\npicking this:\n  c \\<noteq> [] \\<Longrightarrow> hd c = r", "have \"c \\<noteq> [] \\<Longrightarrow> r \\<in> set c\""], ["proof (prove)\nusing this:\n  c \\<noteq> [] \\<Longrightarrow> hd c = r\n\ngoal (1 subgoal):\n 1. c \\<noteq> [] \\<Longrightarrow> r \\<in> set c", "by (induct c) auto"], ["proof (state)\nthis:\n  c \\<noteq> [] \\<Longrightarrow> r \\<in> set c\n\ngoal (2 subgoals):\n 1. \\<And>c vs.\n       \\<lbrakk>distinct vs; vs = [] @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> [] = c\n 2. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "with rc"], ["proof (chain)\npicking this:\n  r \\<notin> set c\n  c \\<noteq> [] \\<Longrightarrow> r \\<in> set c", "have c: \"c = []\""], ["proof (prove)\nusing this:\n  r \\<notin> set c\n  c \\<noteq> [] \\<Longrightarrow> r \\<in> set c\n\ngoal (1 subgoal):\n 1. c = []", "by auto"], ["proof (state)\nthis:\n  c = []\n\ngoal (2 subgoals):\n 1. \\<And>c vs.\n       \\<lbrakk>distinct vs; vs = [] @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> [] = c\n 2. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "then"], ["proof (chain)\npicking this:\n  c = []", "show ?case"], ["proof (prove)\nusing this:\n  c = []\n\ngoal (1 subgoal):\n 1. [] = c", "by auto"], ["proof (state)\nthis:\n  [] = c\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct ?vs; ?vs = xs @ r # b; ?vs = ?c @ r # d\\<rbrakk>\n  \\<Longrightarrow> xs = ?c\n  distinct vs\n  vs = (x # xs) @ r # b\n  vs = c @ r # d\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2 c vs.\n       \\<lbrakk>\\<And>c vs.\n                   \\<lbrakk>distinct vs; vs = a2 @ r # b;\n                    vs = c @ r # d\\<rbrakk>\n                   \\<Longrightarrow> a2 = c;\n        distinct vs; vs = (a1 # a2) @ r # b; vs = c @ r # d\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = c", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct ?vs; ?vs = xs @ r # b; ?vs = ?c @ r # d\\<rbrakk>\n  \\<Longrightarrow> xs = ?c\n  distinct vs\n  vs = (x # xs) @ r # b\n  vs = c @ r # d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?vs; ?vs = xs @ r # b; ?vs = ?c @ r # d\\<rbrakk>\n  \\<Longrightarrow> xs = ?c\n  distinct vs\n  vs = (x # xs) @ r # b\n  vs = c @ r # d\n\ngoal (1 subgoal):\n 1. x # xs = c", "by (induct c)  auto"], ["proof (state)\nthis:\n  x # xs = c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dist_at: \"distinct vs \\<Longrightarrow> vs = a @ r # b \\<Longrightarrow> vs = c @ r # d \\<Longrightarrow> a = c \\<and> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ r # b; vs = c @ r # d\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ r # b; vs = c @ r # d\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "assume dist: \"distinct vs\" and vs1: \"vs = a @ r # b\" and vs2: \"vs = c @ r # d\""], ["proof (state)\nthis:\n  distinct vs\n  vs = a @ r # b\n  vs = c @ r # d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ r # b; vs = c @ r # d\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "then"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ r # b\n  vs = c @ r # d", "have \"a = c\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ r # b\n  vs = c @ r # d\n\ngoal (1 subgoal):\n 1. a = c", "by (rule_tac dist_at1) auto"], ["proof (state)\nthis:\n  a = c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ r # b; vs = c @ r # d\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "with dist vs1 vs2"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ r # b\n  vs = c @ r # d\n  a = c", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ r # b\n  vs = c @ r # d\n  a = c\n\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "by simp"], ["proof (state)\nthis:\n  a = c \\<and> b = d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dist_at2: \"distinct vs \\<Longrightarrow> vs = a @ r # b \\<Longrightarrow> vs = c @ r # d \\<Longrightarrow> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ r # b; vs = c @ r # d\\<rbrakk>\n    \\<Longrightarrow> b = d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ r # b; vs = c @ r # d\\<rbrakk>\n    \\<Longrightarrow> b = d", "assume dist: \"distinct vs\" and vs1: \"vs = a @ r # b\" and vs2: \"vs = c @ r # d\""], ["proof (state)\nthis:\n  distinct vs\n  vs = a @ r # b\n  vs = c @ r # d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ r # b; vs = c @ r # d\\<rbrakk>\n    \\<Longrightarrow> b = d", "then"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ r # b\n  vs = c @ r # d", "have \"a = c \\<and> b = d\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ r # b\n  vs = c @ r # d\n\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "by (rule_tac dist_at) auto"], ["proof (state)\nthis:\n  a = c \\<and> b = d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ r # b; vs = c @ r # d\\<rbrakk>\n    \\<Longrightarrow> b = d", "then"], ["proof (chain)\npicking this:\n  a = c \\<and> b = d", "show ?thesis"], ["proof (prove)\nusing this:\n  a = c \\<and> b = d\n\ngoal (1 subgoal):\n 1. b = d", "by auto"], ["proof (state)\nthis:\n  b = d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_split1: \"distinct xs \\<Longrightarrow> xs = y @ [r] @ z  \\<Longrightarrow> r \\<notin> set y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; xs = y @ [r] @ z\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> set y", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_split2: \"distinct xs \\<Longrightarrow> xs = y @ [r] @ z  \\<Longrightarrow> r \\<notin> set z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; xs = y @ [r] @ z\\<rbrakk>\n    \\<Longrightarrow> r \\<notin> set z", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_hd_not_cons: \"distinct vs \\<Longrightarrow> \\<exists> as bs. vs = as @ x # hd vs # bs \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; \\<exists>as bs. vs = as @ x # hd vs # bs\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; \\<exists>as bs. vs = as @ x # hd vs # bs\\<rbrakk>\n    \\<Longrightarrow> False", "assume d: \"distinct vs\" and ex: \"\\<exists> as bs. vs = as @ x # hd vs # bs\""], ["proof (state)\nthis:\n  distinct vs\n  \\<exists>as bs. vs = as @ x # hd vs # bs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; \\<exists>as bs. vs = as @ x # hd vs # bs\\<rbrakk>\n    \\<Longrightarrow> False", "from ex"], ["proof (chain)\npicking this:\n  \\<exists>as bs. vs = as @ x # hd vs # bs", "have vsne: \"vs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<exists>as bs. vs = as @ x # hd vs # bs\n\ngoal (1 subgoal):\n 1. vs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  vs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; \\<exists>as bs. vs = as @ x # hd vs # bs\\<rbrakk>\n    \\<Longrightarrow> False", "with d ex"], ["proof (chain)\npicking this:\n  distinct vs\n  \\<exists>as bs. vs = as @ x # hd vs # bs\n  vs \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct vs\n  \\<exists>as bs. vs = as @ x # hd vs # bs\n  vs \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "apply (elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       \\<lbrakk>distinct vs; vs \\<noteq> [];\n        vs = as @ x # hd vs # bs\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"as\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>as bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"hd vs = x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = []; hd vs = x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>as bs.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = []\\<rbrakk>\n       \\<Longrightarrow> hd vs = x\n 3. \\<And>as bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = []\\<rbrakk>\n       \\<Longrightarrow> hd vs = x\n 2. \\<And>as bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = []\\<rbrakk>\n       \\<Longrightarrow> x = hd vs\n 2. \\<And>as bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = x # hd vs # bs;\n        as = []\\<rbrakk>\n       \\<Longrightarrow> x = hd vs\n 2. \\<And>as bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"x = hd (x # (hd vs # bs))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>as bs.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = x # hd vs # bs; as = [];\n        x = hd (x # hd vs # bs)\\<rbrakk>\n       \\<Longrightarrow> x = hd vs\n 2. \\<And>as bs.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = x # hd vs # bs;\n        as = []\\<rbrakk>\n       \\<Longrightarrow> x = hd (x # hd vs # bs)\n 3. \\<And>as bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = x # hd vs # bs;\n        as = []\\<rbrakk>\n       \\<Longrightarrow> x = hd (x # hd vs # bs)\n 2. \\<And>as bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply (thin_tac \"vs = x # hd vs # bs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; as = []\\<rbrakk>\n       \\<Longrightarrow> x = hd (x # hd vs # bs)\n 2. \\<And>as bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = as @ x # hd vs # bs;\n        as = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> [];\n        vs = a # list @ x # hd vs # bs\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"hd vs = a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = a # list @ x # hd vs # bs;\n        hd vs = a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> [];\n        vs = a # list @ x # hd vs # bs\\<rbrakk>\n       \\<Longrightarrow> hd vs = a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> [];\n        vs = a # list @ x # hd vs # bs\\<rbrakk>\n       \\<Longrightarrow> hd vs = a", "apply (subgoal_tac \"a = hd (a # list @ x # hd vs # bs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> []; vs = a # list @ x # hd vs # bs;\n        a = hd (a # list @ x # hd vs # bs)\\<rbrakk>\n       \\<Longrightarrow> hd vs = a\n 2. \\<And>bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> [];\n        vs = a # list @ x # hd vs # bs\\<rbrakk>\n       \\<Longrightarrow> a = hd (a # list @ x # hd vs # bs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> [];\n        vs = a # list @ x # hd vs # bs\\<rbrakk>\n       \\<Longrightarrow> a = hd (a # list @ x # hd vs # bs)", "apply (thin_tac \"vs = a # list @ x # hd vs # bs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bs a list.\n       \\<lbrakk>distinct vs; vs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> a = hd (a # list @ x # hd vs # bs)", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Misc\\<close>"], ["", "(* FIXME move to List *)"], ["", "lemma drop_last_in: \"\\<And>n. n < length ls \\<Longrightarrow> last ls \\<in> set (drop n ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. n < |ls| \\<Longrightarrow> last ls \\<in> set (drop n ls)", "apply (frule_tac last_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < |ls|; last (drop n ls) = last ls\\<rbrakk>\n       \\<Longrightarrow> last ls \\<in> set (drop n ls)", "apply(erule subst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < |ls| \\<Longrightarrow> last (drop n ls) \\<in> set (drop n ls)", "apply (case_tac \"drop n ls\" rule: rev_exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n < |ls|; drop n ls = []\\<rbrakk>\n       \\<Longrightarrow> last (drop n ls) \\<in> set (drop n ls)\n 2. \\<And>n ys y.\n       \\<lbrakk>n < |ls|; drop n ls = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> last (drop n ls) \\<in> set (drop n ls)", "by simp_all"], ["", "lemma nth_last_Suc_n: \"distinct ls \\<Longrightarrow> n < length ls \\<Longrightarrow> last ls = ls ! n \\<Longrightarrow> Suc n = length ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; n < |ls|; last ls = ls ! n\\<rbrakk>\n    \\<Longrightarrow> Suc n = |ls|", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; n < |ls|; last ls = ls ! n;\n     Suc n \\<noteq> |ls|\\<rbrakk>\n    \\<Longrightarrow> False", "assume d: \"distinct ls\" and n: \"n < length ls\" and l: \"last ls = ls ! n\" and not: \"Suc n \\<noteq> length ls\""], ["proof (state)\nthis:\n  distinct ls\n  n < |ls|\n  last ls = ls ! n\n  Suc n \\<noteq> |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; n < |ls|; last ls = ls ! n;\n     Suc n \\<noteq> |ls|\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  distinct ls\n  n < |ls|\n  last ls = ls ! n\n  Suc n \\<noteq> |ls|", "have s: \"Suc n < length ls\""], ["proof (prove)\nusing this:\n  distinct ls\n  n < |ls|\n  last ls = ls ! n\n  Suc n \\<noteq> |ls|\n\ngoal (1 subgoal):\n 1. Suc n < |ls|", "by auto"], ["proof (state)\nthis:\n  Suc n < |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; n < |ls|; last ls = ls ! n;\n     Suc n \\<noteq> |ls|\\<rbrakk>\n    \\<Longrightarrow> False", "define lls where  \"lls = ls!n\""], ["proof (state)\nthis:\n  lls = ls ! n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; n < |ls|; last ls = ls ! n;\n     Suc n \\<noteq> |ls|\\<rbrakk>\n    \\<Longrightarrow> False", "with n"], ["proof (chain)\npicking this:\n  n < |ls|\n  lls = ls ! n", "have \"take (Suc n) ls = take n ls @ [lls]\""], ["proof (prove)\nusing this:\n  n < |ls|\n  lls = ls ! n\n\ngoal (1 subgoal):\n 1. take (Suc n) ls = take n ls @ [lls]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < |ls|; lls = ls ! n\\<rbrakk>\n    \\<Longrightarrow> take (Suc n) ls = take n ls @ [ls ! n]", "by (rule take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take (Suc n) ls = take n ls @ [lls]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; n < |ls|; last ls = ls ! n;\n     Suc n \\<noteq> |ls|\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  take (Suc n) ls = take n ls @ [lls]", "have \"take (Suc n) ls @ drop (Suc n) ls = take n ls @ [lls] @ drop (Suc n) ls\""], ["proof (prove)\nusing this:\n  take (Suc n) ls = take n ls @ [lls]\n\ngoal (1 subgoal):\n 1. take (Suc n) ls @ drop (Suc n) ls = take n ls @ [lls] @ drop (Suc n) ls", "by auto"], ["proof (state)\nthis:\n  take (Suc n) ls @ drop (Suc n) ls = take n ls @ [lls] @ drop (Suc n) ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; n < |ls|; last ls = ls ! n;\n     Suc n \\<noteq> |ls|\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  take (Suc n) ls @ drop (Suc n) ls = take n ls @ [lls] @ drop (Suc n) ls", "have ls: \"ls = take n ls @ [lls] @ drop (Suc n) ls\""], ["proof (prove)\nusing this:\n  take (Suc n) ls @ drop (Suc n) ls = take n ls @ [lls] @ drop (Suc n) ls\n\ngoal (1 subgoal):\n 1. ls = take n ls @ [lls] @ drop (Suc n) ls", "by auto"], ["proof (state)\nthis:\n  ls = take n ls @ [lls] @ drop (Suc n) ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; n < |ls|; last ls = ls ! n;\n     Suc n \\<noteq> |ls|\\<rbrakk>\n    \\<Longrightarrow> False", "with d"], ["proof (chain)\npicking this:\n  distinct ls\n  ls = take n ls @ [lls] @ drop (Suc n) ls", "have dls: \"distinct (take n ls @ [lls] @ drop (Suc n) ls)\""], ["proof (prove)\nusing this:\n  distinct ls\n  ls = take n ls @ [lls] @ drop (Suc n) ls\n\ngoal (1 subgoal):\n 1. distinct (take n ls @ [lls] @ drop (Suc n) ls)", "by auto"], ["proof (state)\nthis:\n  distinct (take n ls @ [lls] @ drop (Suc n) ls)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; n < |ls|; last ls = ls ! n;\n     Suc n \\<noteq> |ls|\\<rbrakk>\n    \\<Longrightarrow> False", "from lls_def l"], ["proof (chain)\npicking this:\n  lls = ls ! n\n  last ls = ls ! n", "have \"lls = (last ls)\""], ["proof (prove)\nusing this:\n  lls = ls ! n\n  last ls = ls ! n\n\ngoal (1 subgoal):\n 1. lls = last ls", "by auto"], ["proof (state)\nthis:\n  lls = last ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; n < |ls|; last ls = ls ! n;\n     Suc n \\<noteq> |ls|\\<rbrakk>\n    \\<Longrightarrow> False", "with s"], ["proof (chain)\npicking this:\n  Suc n < |ls|\n  lls = last ls", "have \"lls \\<in> set (drop (Suc n) ls)\""], ["proof (prove)\nusing this:\n  Suc n < |ls|\n  lls = last ls\n\ngoal (1 subgoal):\n 1. lls \\<in> set (drop (Suc n) ls)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc n < |ls|; lls = last ls\\<rbrakk>\n    \\<Longrightarrow> last ls \\<in> set (drop (Suc n) ls)", "by (rule_tac drop_last_in)"], ["proof (state)\nthis:\n  lls \\<in> set (drop (Suc n) ls)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; n < |ls|; last ls = ls ! n;\n     Suc n \\<noteq> |ls|\\<rbrakk>\n    \\<Longrightarrow> False", "with dls"], ["proof (chain)\npicking this:\n  distinct (take n ls @ [lls] @ drop (Suc n) ls)\n  lls \\<in> set (drop (Suc n) ls)", "show False"], ["proof (prove)\nusing this:\n  distinct (take n ls @ [lls] @ drop (Suc n) ls)\n  lls \\<in> set (drop (Suc n) ls)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(****************************** rotate *************************)"], ["", "subsubsection \\<open>@{const rotate}\\<close>"], ["", "lemma  plus_length1[simp]: \"rotate (k+(length ls)) ls = rotate k ls \""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (k + |ls|) ls = rotate k ls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rotate (k + |ls|) ls = rotate k ls", "have \"\\<And> k ls. rotate k (rotate (length ls) ls) = rotate (k+(length ls)) ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k ls. rotate k (rotate |ls| ls) = rotate (k + |ls|) ls", "by (rule rotate_rotate)"], ["proof (state)\nthis:\n  rotate ?k (rotate |?ls| ?ls) = rotate (?k + |?ls|) ?ls\n\ngoal (1 subgoal):\n 1. rotate (k + |ls|) ls = rotate k ls", "then"], ["proof (chain)\npicking this:\n  rotate ?k (rotate |?ls| ?ls) = rotate (?k + |?ls|) ?ls", "have \"\\<And> k ls. rotate k ls =  rotate (k+(length ls)) ls\""], ["proof (prove)\nusing this:\n  rotate ?k (rotate |?ls| ?ls) = rotate (?k + |?ls|) ?ls\n\ngoal (1 subgoal):\n 1. \\<And>k ls. rotate k ls = rotate (k + |ls|) ls", "by auto"], ["proof (state)\nthis:\n  rotate ?k1 ?ls1 = rotate (?k1 + |?ls1|) ?ls1\n\ngoal (1 subgoal):\n 1. rotate (k + |ls|) ls = rotate k ls", "then"], ["proof (chain)\npicking this:\n  rotate ?k1 ?ls1 = rotate (?k1 + |?ls1|) ?ls1", "show ?thesis"], ["proof (prove)\nusing this:\n  rotate ?k1 ?ls1 = rotate (?k1 + |?ls1|) ?ls1\n\ngoal (1 subgoal):\n 1. rotate (k + |ls|) ls = rotate k ls", "by (rule sym)"], ["proof (state)\nthis:\n  rotate (k + |ls|) ls = rotate k ls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  plus_length2[simp]: \"rotate ((length ls)+k) ls = rotate k ls \""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (|ls| + k) ls = rotate k ls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rotate (|ls| + k) ls = rotate k ls", "define x where \"x = (length ls)+k\""], ["proof (state)\nthis:\n  x = |ls| + k\n\ngoal (1 subgoal):\n 1. rotate (|ls| + k) ls = rotate k ls", "then"], ["proof (chain)\npicking this:\n  x = |ls| + k", "have \"x = k+(length ls)\""], ["proof (prove)\nusing this:\n  x = |ls| + k\n\ngoal (1 subgoal):\n 1. x = k + |ls|", "by auto"], ["proof (state)\nthis:\n  x = k + |ls|\n\ngoal (1 subgoal):\n 1. rotate (|ls| + k) ls = rotate k ls", "with x_def"], ["proof (chain)\npicking this:\n  x = |ls| + k\n  x = k + |ls|", "have \"rotate x ls = rotate (k+(length ls)) ls\""], ["proof (prove)\nusing this:\n  x = |ls| + k\n  x = k + |ls|\n\ngoal (1 subgoal):\n 1. rotate x ls = rotate (k + |ls|) ls", "by simp"], ["proof (state)\nthis:\n  rotate x ls = rotate (k + |ls|) ls\n\ngoal (1 subgoal):\n 1. rotate (|ls| + k) ls = rotate k ls", "then"], ["proof (chain)\npicking this:\n  rotate x ls = rotate (k + |ls|) ls", "have \"rotate x ls = rotate k ls\""], ["proof (prove)\nusing this:\n  rotate x ls = rotate (k + |ls|) ls\n\ngoal (1 subgoal):\n 1. rotate x ls = rotate k ls", "by simp"], ["proof (state)\nthis:\n  rotate x ls = rotate k ls\n\ngoal (1 subgoal):\n 1. rotate (|ls| + k) ls = rotate k ls", "with x_def"], ["proof (chain)\npicking this:\n  x = |ls| + k\n  rotate x ls = rotate k ls", "show ?thesis"], ["proof (prove)\nusing this:\n  x = |ls| + k\n  rotate x ls = rotate k ls\n\ngoal (1 subgoal):\n 1. rotate (|ls| + k) ls = rotate k ls", "by simp"], ["proof (state)\nthis:\n  rotate (|ls| + k) ls = rotate k ls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate_minus1: \"n > 0 \\<Longrightarrow> m > 0 \\<Longrightarrow>\n rotate n ls = rotate m ms \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "proof (cases \"ls = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms\n 2. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "assume r: \"rotate n ls = rotate m ms\""], ["proof (state)\nthis:\n  rotate n ls = rotate m ms\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms\n 2. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "case True"], ["proof (state)\nthis:\n  ls = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms\n 2. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "with r"], ["proof (chain)\npicking this:\n  rotate n ls = rotate m ms\n  ls = []", "have \"rotate m ms = []\""], ["proof (prove)\nusing this:\n  rotate n ls = rotate m ms\n  ls = []\n\ngoal (1 subgoal):\n 1. rotate m ms = []", "by auto"], ["proof (state)\nthis:\n  rotate m ms = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms\n 2. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "then"], ["proof (chain)\npicking this:\n  rotate m ms = []", "have \"ms = []\""], ["proof (prove)\nusing this:\n  rotate m ms = []\n\ngoal (1 subgoal):\n 1. ms = []", "by auto"], ["proof (state)\nthis:\n  ms = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms\n 2. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "with True"], ["proof (chain)\npicking this:\n  ls = []\n  ms = []", "show ?thesis"], ["proof (prove)\nusing this:\n  ls = []\n  ms = []\n\ngoal (1 subgoal):\n 1. rotate (n - 1) ls = rotate (m - 1) ms", "by auto"], ["proof (state)\nthis:\n  rotate (n - 1) ls = rotate (m - 1) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "assume n: \"n > 0\" and m: \"m > 0\" and r: \"rotate n ls = rotate m ms\""], ["proof (state)\nthis:\n  0 < n\n  0 < m\n  rotate n ls = rotate m ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "case False"], ["proof (state)\nthis:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "then"], ["proof (chain)\npicking this:\n  ls \\<noteq> []", "have lls: \"length ls > 0\""], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < |ls|", "by auto"], ["proof (state)\nthis:\n  0 < |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "with r"], ["proof (chain)\npicking this:\n  rotate n ls = rotate m ms\n  0 < |ls|", "have lms: \"length ms > 0\""], ["proof (prove)\nusing this:\n  rotate n ls = rotate m ms\n  0 < |ls|\n\ngoal (1 subgoal):\n 1. 0 < |ms|", "by auto"], ["proof (state)\nthis:\n  0 < |ms|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "have mem1: \"rotate (n - 1) ls = rotate ((n - 1) + length ls) ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (n - 1) ls = rotate (n - 1 + |ls|) ls", "by auto"], ["proof (state)\nthis:\n  rotate (n - 1) ls = rotate (n - 1 + |ls|) ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "from n lls"], ["proof (chain)\npicking this:\n  0 < n\n  0 < |ls|", "have \"(n - 1) + length ls = (length ls - 1) + n\""], ["proof (prove)\nusing this:\n  0 < n\n  0 < |ls|\n\ngoal (1 subgoal):\n 1. n - 1 + |ls| = |ls| - 1 + n", "by arith"], ["proof (state)\nthis:\n  n - 1 + |ls| = |ls| - 1 + n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "then"], ["proof (chain)\npicking this:\n  n - 1 + |ls| = |ls| - 1 + n", "have \"rotate ((n - 1) + length ls) ls = rotate ((length ls - 1) + n) ls\""], ["proof (prove)\nusing this:\n  n - 1 + |ls| = |ls| - 1 + n\n\ngoal (1 subgoal):\n 1. rotate (n - 1 + |ls|) ls = rotate (|ls| - 1 + n) ls", "by auto"], ["proof (state)\nthis:\n  rotate (n - 1 + |ls|) ls = rotate (|ls| - 1 + n) ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "with mem1"], ["proof (chain)\npicking this:\n  rotate (n - 1) ls = rotate (n - 1 + |ls|) ls\n  rotate (n - 1 + |ls|) ls = rotate (|ls| - 1 + n) ls", "have mem2: \"rotate (n - 1) ls = rotate ((length ls - 1) + n) ls\""], ["proof (prove)\nusing this:\n  rotate (n - 1) ls = rotate (n - 1 + |ls|) ls\n  rotate (n - 1 + |ls|) ls = rotate (|ls| - 1 + n) ls\n\ngoal (1 subgoal):\n 1. rotate (n - 1) ls = rotate (|ls| - 1 + n) ls", "by auto"], ["proof (state)\nthis:\n  rotate (n - 1) ls = rotate (|ls| - 1 + n) ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "have \"rotate ((length ls - 1) + n) ls = rotate (length ls - 1) (rotate n ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (|ls| - 1 + n) ls = rotate (|ls| - 1) (rotate n ls)", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (|ls| - 1) (rotate n ls) = rotate (|ls| - 1 + n) ls", "by (rule rotate_rotate)"], ["proof (state)\nthis:\n  rotate (|ls| - 1 + n) ls = rotate (|ls| - 1) (rotate n ls)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "with mem2"], ["proof (chain)\npicking this:\n  rotate (n - 1) ls = rotate (|ls| - 1 + n) ls\n  rotate (|ls| - 1 + n) ls = rotate (|ls| - 1) (rotate n ls)", "have mem3: \"rotate (n - 1) ls = rotate (length ls - 1) (rotate n ls)\""], ["proof (prove)\nusing this:\n  rotate (n - 1) ls = rotate (|ls| - 1 + n) ls\n  rotate (|ls| - 1 + n) ls = rotate (|ls| - 1) (rotate n ls)\n\ngoal (1 subgoal):\n 1. rotate (n - 1) ls = rotate (|ls| - 1) (rotate n ls)", "by auto"], ["proof (state)\nthis:\n  rotate (n - 1) ls = rotate (|ls| - 1) (rotate n ls)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "from r"], ["proof (chain)\npicking this:\n  rotate n ls = rotate m ms", "have \"rotate (length ls - 1) (rotate n ls) = rotate (length ls - 1) (rotate m ms)\""], ["proof (prove)\nusing this:\n  rotate n ls = rotate m ms\n\ngoal (1 subgoal):\n 1. rotate (|ls| - 1) (rotate n ls) = rotate (|ls| - 1) (rotate m ms)", "by auto"], ["proof (state)\nthis:\n  rotate (|ls| - 1) (rotate n ls) = rotate (|ls| - 1) (rotate m ms)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "with mem3"], ["proof (chain)\npicking this:\n  rotate (n - 1) ls = rotate (|ls| - 1) (rotate n ls)\n  rotate (|ls| - 1) (rotate n ls) = rotate (|ls| - 1) (rotate m ms)", "have mem4: \"rotate (n - 1) ls = rotate (length ls - 1) (rotate m ms)\""], ["proof (prove)\nusing this:\n  rotate (n - 1) ls = rotate (|ls| - 1) (rotate n ls)\n  rotate (|ls| - 1) (rotate n ls) = rotate (|ls| - 1) (rotate m ms)\n\ngoal (1 subgoal):\n 1. rotate (n - 1) ls = rotate (|ls| - 1) (rotate m ms)", "by auto"], ["proof (state)\nthis:\n  rotate (n - 1) ls = rotate (|ls| - 1) (rotate m ms)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "have \"rotate (length ls - 1) (rotate m ms) = rotate (length ls - 1 + m) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (|ls| - 1) (rotate m ms) = rotate (|ls| - 1 + m) ms", "by (rule rotate_rotate)"], ["proof (state)\nthis:\n  rotate (|ls| - 1) (rotate m ms) = rotate (|ls| - 1 + m) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "with mem4"], ["proof (chain)\npicking this:\n  rotate (n - 1) ls = rotate (|ls| - 1) (rotate m ms)\n  rotate (|ls| - 1) (rotate m ms) = rotate (|ls| - 1 + m) ms", "have mem5: \"rotate (n - 1) ls = rotate (length ls - 1 + m) ms\""], ["proof (prove)\nusing this:\n  rotate (n - 1) ls = rotate (|ls| - 1) (rotate m ms)\n  rotate (|ls| - 1) (rotate m ms) = rotate (|ls| - 1 + m) ms\n\ngoal (1 subgoal):\n 1. rotate (n - 1) ls = rotate (|ls| - 1 + m) ms", "by auto"], ["proof (state)\nthis:\n  rotate (n - 1) ls = rotate (|ls| - 1 + m) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "from r"], ["proof (chain)\npicking this:\n  rotate n ls = rotate m ms", "have \"length (rotate n ls) = length (rotate m ms)\""], ["proof (prove)\nusing this:\n  rotate n ls = rotate m ms\n\ngoal (1 subgoal):\n 1. |rotate n ls| = |rotate m ms|", "by simp"], ["proof (state)\nthis:\n  |rotate n ls| = |rotate m ms|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "then"], ["proof (chain)\npicking this:\n  |rotate n ls| = |rotate m ms|", "have \"length ls = length ms\""], ["proof (prove)\nusing this:\n  |rotate n ls| = |rotate m ms|\n\ngoal (1 subgoal):\n 1. |ls| = |ms|", "by auto"], ["proof (state)\nthis:\n  |ls| = |ms|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "with m lms"], ["proof (chain)\npicking this:\n  0 < m\n  0 < |ms|\n  |ls| = |ms|", "have \"length ls - 1 + m = (m - 1) + length ms\""], ["proof (prove)\nusing this:\n  0 < m\n  0 < |ms|\n  |ls| = |ms|\n\ngoal (1 subgoal):\n 1. |ls| - 1 + m = m - 1 + |ms|", "by arith"], ["proof (state)\nthis:\n  |ls| - 1 + m = m - 1 + |ms|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "with mem5"], ["proof (chain)\npicking this:\n  rotate (n - 1) ls = rotate (|ls| - 1 + m) ms\n  |ls| - 1 + m = m - 1 + |ms|", "have mem6: \"rotate (n - 1) ls = rotate ((m - 1) + length ms) ms\""], ["proof (prove)\nusing this:\n  rotate (n - 1) ls = rotate (|ls| - 1 + m) ms\n  |ls| - 1 + m = m - 1 + |ms|\n\ngoal (1 subgoal):\n 1. rotate (n - 1) ls = rotate (m - 1 + |ms|) ms", "by auto"], ["proof (state)\nthis:\n  rotate (n - 1) ls = rotate (m - 1 + |ms|) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "have \"rotate ((m - 1) + length ms) ms = rotate (m - 1) (rotate (length ms) ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (m - 1 + |ms|) ms = rotate (m - 1) (rotate |ms| ms)", "by auto"], ["proof (state)\nthis:\n  rotate (m - 1 + |ms|) ms = rotate (m - 1) (rotate |ms| ms)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "then"], ["proof (chain)\npicking this:\n  rotate (m - 1 + |ms|) ms = rotate (m - 1) (rotate |ms| ms)", "have \"rotate ((m - 1) + length ms) ms = rotate (m - 1) ms\""], ["proof (prove)\nusing this:\n  rotate (m - 1 + |ms|) ms = rotate (m - 1) (rotate |ms| ms)\n\ngoal (1 subgoal):\n 1. rotate (m - 1 + |ms|) ms = rotate (m - 1) ms", "by auto"], ["proof (state)\nthis:\n  rotate (m - 1 + |ms|) ms = rotate (m - 1) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; 0 < m; rotate n ls = rotate m ms;\n     ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (m - 1) ms", "with mem6"], ["proof (chain)\npicking this:\n  rotate (n - 1) ls = rotate (m - 1 + |ms|) ms\n  rotate (m - 1 + |ms|) ms = rotate (m - 1) ms", "show ?thesis"], ["proof (prove)\nusing this:\n  rotate (n - 1) ls = rotate (m - 1 + |ms|) ms\n  rotate (m - 1 + |ms|) ms = rotate (m - 1) ms\n\ngoal (1 subgoal):\n 1. rotate (n - 1) ls = rotate (m - 1) ms", "by auto"], ["proof (state)\nthis:\n  rotate (n - 1) ls = rotate (m - 1) ms\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate_minus1': \"n > 0 \\<Longrightarrow> rotate n ls = ms \\<Longrightarrow>\n  rotate (n - 1) ls = rotate (length ms - 1) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; rotate n ls = ms\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms", "proof (cases \"ls = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; rotate n ls = ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms\n 2. \\<lbrakk>0 < n; rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms", "assume r: \"rotate n ls = ms\""], ["proof (state)\nthis:\n  rotate n ls = ms\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; rotate n ls = ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms\n 2. \\<lbrakk>0 < n; rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms", "case True"], ["proof (state)\nthis:\n  ls = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < n; rotate n ls = ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms\n 2. \\<lbrakk>0 < n; rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms", "with r"], ["proof (chain)\npicking this:\n  rotate n ls = ms\n  ls = []", "show ?thesis"], ["proof (prove)\nusing this:\n  rotate n ls = ms\n  ls = []\n\ngoal (1 subgoal):\n 1. rotate (n - 1) ls = rotate (|ms| - 1) ms", "by auto"], ["proof (state)\nthis:\n  rotate (n - 1) ls = rotate (|ms| - 1) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms", "assume n: \"n > 0\" and r:\"rotate n ls = ms\""], ["proof (state)\nthis:\n  0 < n\n  rotate n ls = ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms", "then"], ["proof (chain)\npicking this:\n  0 < n\n  rotate n ls = ms", "have r': \"rotate n ls = rotate (length ms) ms\""], ["proof (prove)\nusing this:\n  0 < n\n  rotate n ls = ms\n\ngoal (1 subgoal):\n 1. rotate n ls = rotate |ms| ms", "by auto"], ["proof (state)\nthis:\n  rotate n ls = rotate |ms| ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms", "case False"], ["proof (state)\nthis:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate (n - 1) ls = rotate (|ms| - 1) ms", "with n r'"], ["proof (chain)\npicking this:\n  0 < n\n  rotate n ls = rotate |ms| ms\n  ls \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < n\n  rotate n ls = rotate |ms| ms\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. rotate (n - 1) ls = rotate (|ms| - 1) ms", "apply (rule_tac rotate_minus1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < n; rotate n ls = rotate |ms| ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < n\n 2. \\<lbrakk>0 < n; rotate n ls = rotate |ms| ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < |ms|\n 3. \\<lbrakk>0 < n; rotate n ls = rotate |ms| ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> rotate n ls = rotate |ms| ms", "by auto"], ["proof (state)\nthis:\n  rotate (n - 1) ls = rotate (|ms| - 1) ms\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate_inv1: \"\\<And> ms. n < length ls \\<Longrightarrow> rotate n ls = ms \\<Longrightarrow>\n  ls = rotate ((length ls) - n) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ms.\n       \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n       \\<Longrightarrow> ls = rotate (|ls| - n) ms", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>0 < |ls|; rotate 0 ls = ms\\<rbrakk>\n       \\<Longrightarrow> ls = rotate (|ls| - 0) ms\n 2. \\<And>n ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                   \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n        Suc n < |ls|; rotate (Suc n) ls = ms\\<rbrakk>\n       \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "case 0"], ["proof (state)\nthis:\n  0 < |ls|\n  rotate 0 ls = ms\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>0 < |ls|; rotate 0 ls = ms\\<rbrakk>\n       \\<Longrightarrow> ls = rotate (|ls| - 0) ms\n 2. \\<And>n ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                   \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n        Suc n < |ls|; rotate (Suc n) ls = ms\\<rbrakk>\n       \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "then"], ["proof (chain)\npicking this:\n  0 < |ls|\n  rotate 0 ls = ms", "show ?case"], ["proof (prove)\nusing this:\n  0 < |ls|\n  rotate 0 ls = ms\n\ngoal (1 subgoal):\n 1. ls = rotate (|ls| - 0) ms", "by auto"], ["proof (state)\nthis:\n  ls = rotate (|ls| - 0) ms\n\ngoal (1 subgoal):\n 1. \\<And>n ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                   \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n        Suc n < |ls|; rotate (Suc n) ls = ms\\<rbrakk>\n       \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                   \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n        Suc n < |ls|; rotate (Suc n) ls = ms\\<rbrakk>\n       \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n < |ls|; rotate n ls = ?ms\\<rbrakk>\n  \\<Longrightarrow> ls = rotate (|ls| - n) ?ms\n  Suc n < |ls|\n  rotate (Suc n) ls = ms\n\ngoal (1 subgoal):\n 1. \\<And>n ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                   \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n        Suc n < |ls|; rotate (Suc n) ls = ms\\<rbrakk>\n       \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n < |ls|; rotate n ls = ?ms\\<rbrakk>\n  \\<Longrightarrow> ls = rotate (|ls| - n) ?ms\n  Suc n < |ls|\n  rotate (Suc n) ls = ms", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < |ls|; rotate n ls = ?ms\\<rbrakk>\n  \\<Longrightarrow> ls = rotate (|ls| - n) ?ms\n  Suc n < |ls|\n  rotate (Suc n) ls = ms\n\ngoal (1 subgoal):\n 1. ls = rotate (|ls| - Suc n) ms", "proof (cases \"ls = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms\n 2. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "case True"], ["proof (state)\nthis:\n  ls = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms\n 2. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>n < |ls|; rotate n ls = ?ms\\<rbrakk>\n  \\<Longrightarrow> ls = rotate (|ls| - n) ?ms\n  Suc n < |ls|\n  rotate (Suc n) ls = ms\n  ls = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < |ls|; rotate n ls = ?ms\\<rbrakk>\n  \\<Longrightarrow> ls = rotate (|ls| - n) ?ms\n  Suc n < |ls|\n  rotate (Suc n) ls = ms\n  ls = []\n\ngoal (1 subgoal):\n 1. ls = rotate (|ls| - Suc n) ms", "by auto"], ["proof (state)\nthis:\n  ls = rotate (|ls| - Suc n) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "case False"], ["proof (state)\nthis:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "then"], ["proof (chain)\npicking this:\n  ls \\<noteq> []", "have ll: \"length ls > 0\""], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < |ls|", "by auto"], ["proof (state)\nthis:\n  0 < |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>n < |ls|; rotate n ls = ?ms\\<rbrakk>\n  \\<Longrightarrow> ls = rotate (|ls| - n) ?ms\n  Suc n < |ls|\n  rotate (Suc n) ls = ms", "have nl: \"n < length ls\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n < |ls|; rotate n ls = ?ms\\<rbrakk>\n  \\<Longrightarrow> ls = rotate (|ls| - n) ?ms\n  Suc n < |ls|\n  rotate (Suc n) ls = ms\n\ngoal (1 subgoal):\n 1. n < |ls|", "by auto"], ["proof (state)\nthis:\n  n < |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>n < |ls|; rotate n ls = ?ms\\<rbrakk>\n  \\<Longrightarrow> ls = rotate (|ls| - n) ?ms\n  Suc n < |ls|\n  rotate (Suc n) ls = ms", "have r: \"rotate (Suc n) ls = ms\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n < |ls|; rotate n ls = ?ms\\<rbrakk>\n  \\<Longrightarrow> ls = rotate (|ls| - n) ?ms\n  Suc n < |ls|\n  rotate (Suc n) ls = ms\n\ngoal (1 subgoal):\n 1. rotate (Suc n) ls = ms", "by auto"], ["proof (state)\nthis:\n  rotate (Suc n) ls = ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "then"], ["proof (chain)\npicking this:\n  rotate (Suc n) ls = ms", "have \"rotate (Suc n - 1) ls = rotate (length ms - 1) ms\""], ["proof (prove)\nusing this:\n  rotate (Suc n) ls = ms\n\ngoal (1 subgoal):\n 1. rotate (Suc n - 1) ls = rotate (|ms| - 1) ms", "apply (rule_tac rotate_minus1')"], ["proof (prove)\ngoal (2 subgoals):\n 1. rotate (Suc n) ls = ms \\<Longrightarrow> 0 < Suc n\n 2. rotate (Suc n) ls = ms \\<Longrightarrow> rotate (Suc n) ls = ms", "by auto"], ["proof (state)\nthis:\n  rotate (Suc n - 1) ls = rotate (|ms| - 1) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "then"], ["proof (chain)\npicking this:\n  rotate (Suc n - 1) ls = rotate (|ms| - 1) ms", "have \"rotate n ls = rotate (length ms - 1) ms\""], ["proof (prove)\nusing this:\n  rotate (Suc n - 1) ls = rotate (|ms| - 1) ms\n\ngoal (1 subgoal):\n 1. rotate n ls = rotate (|ms| - 1) ms", "by auto"], ["proof (state)\nthis:\n  rotate n ls = rotate (|ms| - 1) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "then"], ["proof (chain)\npicking this:\n  rotate n ls = rotate (|ms| - 1) ms", "have mem: \"ls = rotate (length ls - n) (rotate (length ms - 1) ms)\""], ["proof (prove)\nusing this:\n  rotate n ls = rotate (|ms| - 1) ms\n\ngoal (1 subgoal):\n 1. ls = rotate (|ls| - n) (rotate (|ms| - 1) ms)", "apply (rule_tac Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rotate n ls = rotate (|ms| - 1) ms \\<Longrightarrow> n < |ls|\n 2. rotate n ls = rotate (|ms| - 1) ms \\<Longrightarrow>\n    rotate n ls = rotate (|ms| - 1) ms", "by (auto simp: nl)"], ["proof (state)\nthis:\n  ls = rotate (|ls| - n) (rotate (|ms| - 1) ms)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "have \" rotate (length ls - n) (rotate (length ms - 1) ms) = rotate (length ls - n + (length ms - 1)) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (|ls| - n) (rotate (|ms| - 1) ms) =\n    rotate (|ls| - n + (|ms| - 1)) ms", "by (rule rotate_rotate)"], ["proof (state)\nthis:\n  rotate (|ls| - n) (rotate (|ms| - 1) ms) =\n  rotate (|ls| - n + (|ms| - 1)) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "with mem"], ["proof (chain)\npicking this:\n  ls = rotate (|ls| - n) (rotate (|ms| - 1) ms)\n  rotate (|ls| - n) (rotate (|ms| - 1) ms) =\n  rotate (|ls| - n + (|ms| - 1)) ms", "have mem2: \"ls =  rotate (length ls - n + (length ms - 1)) ms\""], ["proof (prove)\nusing this:\n  ls = rotate (|ls| - n) (rotate (|ms| - 1) ms)\n  rotate (|ls| - n) (rotate (|ms| - 1) ms) =\n  rotate (|ls| - n + (|ms| - 1)) ms\n\ngoal (1 subgoal):\n 1. ls = rotate (|ls| - n + (|ms| - 1)) ms", "by auto"], ["proof (state)\nthis:\n  ls = rotate (|ls| - n + (|ms| - 1)) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "from r"], ["proof (chain)\npicking this:\n  rotate (Suc n) ls = ms", "have leq: \"length ms = length ls\""], ["proof (prove)\nusing this:\n  rotate (Suc n) ls = ms\n\ngoal (1 subgoal):\n 1. |ms| = |ls|", "by auto"], ["proof (state)\nthis:\n  |ms| = |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "with False nl"], ["proof (chain)\npicking this:\n  ls \\<noteq> []\n  n < |ls|\n  |ms| = |ls|", "have \"length ls - n + (length ms - 1) = length ms + (length ms - (Suc n))\""], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n  n < |ls|\n  |ms| = |ls|\n\ngoal (1 subgoal):\n 1. |ls| - n + (|ms| - 1) = |ms| + (|ms| - Suc n)", "by arith"], ["proof (state)\nthis:\n  |ls| - n + (|ms| - 1) = |ms| + (|ms| - Suc n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "then"], ["proof (chain)\npicking this:\n  |ls| - n + (|ms| - 1) = |ms| + (|ms| - Suc n)", "have \"rotate (length ls - n + (length ms - 1)) ms = rotate (length ms + (length ms - (Suc n))) ms\""], ["proof (prove)\nusing this:\n  |ls| - n + (|ms| - 1) = |ms| + (|ms| - Suc n)\n\ngoal (1 subgoal):\n 1. rotate (|ls| - n + (|ms| - 1)) ms = rotate (|ms| + (|ms| - Suc n)) ms", "by auto"], ["proof (state)\nthis:\n  rotate (|ls| - n + (|ms| - 1)) ms = rotate (|ms| + (|ms| - Suc n)) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "with mem2"], ["proof (chain)\npicking this:\n  ls = rotate (|ls| - n + (|ms| - 1)) ms\n  rotate (|ls| - n + (|ms| - 1)) ms = rotate (|ms| + (|ms| - Suc n)) ms", "have mem3: \"ls = rotate (length ms + (length ms - (Suc n))) ms\""], ["proof (prove)\nusing this:\n  ls = rotate (|ls| - n + (|ms| - 1)) ms\n  rotate (|ls| - n + (|ms| - 1)) ms = rotate (|ms| + (|ms| - Suc n)) ms\n\ngoal (1 subgoal):\n 1. ls = rotate (|ms| + (|ms| - Suc n)) ms", "by auto"], ["proof (state)\nthis:\n  ls = rotate (|ms| + (|ms| - Suc n)) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "have \"rotate (length ms + (length ms - (Suc n))) ms = rotate (length ms - (Suc n)) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (|ms| + (|ms| - Suc n)) ms = rotate (|ms| - Suc n) ms", "by simp"], ["proof (state)\nthis:\n  rotate (|ms| + (|ms| - Suc n)) ms = rotate (|ms| - Suc n) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                \\<lbrakk>n < |ls|; rotate n ls = ms\\<rbrakk>\n                \\<Longrightarrow> ls = rotate (|ls| - n) ms;\n     Suc n < |ls|; rotate (Suc n) ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - Suc n) ms", "with mem3 leq"], ["proof (chain)\npicking this:\n  ls = rotate (|ms| + (|ms| - Suc n)) ms\n  |ms| = |ls|\n  rotate (|ms| + (|ms| - Suc n)) ms = rotate (|ms| - Suc n) ms", "show ?thesis"], ["proof (prove)\nusing this:\n  ls = rotate (|ms| + (|ms| - Suc n)) ms\n  |ms| = |ls|\n  rotate (|ms| + (|ms| - Suc n)) ms = rotate (|ms| - Suc n) ms\n\ngoal (1 subgoal):\n 1. ls = rotate (|ls| - Suc n) ms", "by auto"], ["proof (state)\nthis:\n  ls = rotate (|ls| - Suc n) ms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ls = rotate (|ls| - Suc n) ms\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate_conv_mod'[simp]: \"rotate (n mod length ls) ls = rotate n ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (n mod |ls|) ls = rotate n ls", "by(simp add:rotate_drop_take)"], ["", "lemma rotate_inv2: \"rotate n ls = ms \\<Longrightarrow>\n ls = rotate ((length ls) - (n mod length ls)) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate n ls = ms \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms", "proof (cases \"ls  = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>rotate n ls = ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms\n 2. \\<lbrakk>rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms", "assume r: \"rotate n ls = ms\""], ["proof (state)\nthis:\n  rotate n ls = ms\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rotate n ls = ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms\n 2. \\<lbrakk>rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms", "case True"], ["proof (state)\nthis:\n  ls = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rotate n ls = ms; ls = []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms\n 2. \\<lbrakk>rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms", "with r"], ["proof (chain)\npicking this:\n  rotate n ls = ms\n  ls = []", "show ?thesis"], ["proof (prove)\nusing this:\n  rotate n ls = ms\n  ls = []\n\ngoal (1 subgoal):\n 1. ls = rotate (|ls| - n mod |ls|) ms", "by auto"], ["proof (state)\nthis:\n  ls = rotate (|ls| - n mod |ls|) ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms", "assume r: \"rotate n ls = ms\""], ["proof (state)\nthis:\n  rotate n ls = ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms", "then"], ["proof (chain)\npicking this:\n  rotate n ls = ms", "have r': \"rotate (n mod length ls) ls = ms\""], ["proof (prove)\nusing this:\n  rotate n ls = ms\n\ngoal (1 subgoal):\n 1. rotate (n mod |ls|) ls = ms", "by auto"], ["proof (state)\nthis:\n  rotate (n mod |ls|) ls = ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms", "case False"], ["proof (state)\nthis:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms", "then"], ["proof (chain)\npicking this:\n  ls \\<noteq> []", "have \"length ls > 0\""], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < |ls|", "by auto"], ["proof (state)\nthis:\n  0 < |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rotate n ls = ms; ls \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ls = rotate (|ls| - n mod |ls|) ms", "with r'"], ["proof (chain)\npicking this:\n  rotate (n mod |ls|) ls = ms\n  0 < |ls|", "show ?thesis"], ["proof (prove)\nusing this:\n  rotate (n mod |ls|) ls = ms\n  0 < |ls|\n\ngoal (1 subgoal):\n 1. ls = rotate (|ls| - n mod |ls|) ms", "apply (rule_tac rotate_inv1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rotate (n mod |ls|) ls = ms; 0 < |ls|\\<rbrakk>\n    \\<Longrightarrow> n mod |ls| < |ls|\n 2. \\<lbrakk>rotate (n mod |ls|) ls = ms; 0 < |ls|\\<rbrakk>\n    \\<Longrightarrow> rotate (n mod |ls|) ls = ms", "by auto"], ["proof (state)\nthis:\n  ls = rotate (|ls| - n mod |ls|) ms\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate_id[simp]: \"rotate ((length ls) - (n mod length ls)) (rotate n ls) = ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate (|ls| - n mod |ls|) (rotate n ls) = ls", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ls = rotate (|ls| - n mod |ls|) (rotate n ls)", "apply (rule rotate_inv2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate n ls = rotate n ls", "by simp"], ["", "lemma nth_rotate1_Suc: \"Suc n < length ls \\<Longrightarrow> ls!(Suc n) = (rotate1 ls)!n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n < |ls| \\<Longrightarrow> ls ! Suc n = rotate1 ls ! n", "apply (cases ls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc n < |ls|; ls = []\\<rbrakk>\n    \\<Longrightarrow> ls ! Suc n = rotate1 ls ! n\n 2. \\<And>a list.\n       \\<lbrakk>Suc n < |ls|; ls = a # list\\<rbrakk>\n       \\<Longrightarrow> ls ! Suc n = rotate1 ls ! n", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>n < |list|; ls = a # list\\<rbrakk>\n       \\<Longrightarrow> list ! n = (list @ [a]) ! n", "by (simp add: nth_append)"], ["", "lemma nth_rotate1_0: \"ls!0 = (rotate1 ls)!(length ls - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls ! 0 = rotate1 ls ! (|ls| - 1)", "apply (cases ls)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ls = [] \\<Longrightarrow> ls ! 0 = rotate1 ls ! (|ls| - 1)\n 2. \\<And>a list.\n       ls = a # list \\<Longrightarrow> ls ! 0 = rotate1 ls ! (|ls| - 1)", "by auto"], ["", "lemma nth_rotate1: \"0 < length ls \\<Longrightarrow> ls!((Suc n) mod (length ls)) = (rotate1 ls)!(n mod (length ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < |ls| \\<Longrightarrow>\n    ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "proof (cases \"0 < (Suc n) mod (length ls)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < |ls|; 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)\n 2. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "assume lls: \"0 < length ls\""], ["proof (state)\nthis:\n  0 < |ls|\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < |ls|; 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)\n 2. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "case True"], ["proof (state)\nthis:\n  0 < Suc n mod |ls|\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < |ls|; 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)\n 2. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "define m where \"m = (Suc n) mod (length ls) - 1\""], ["proof (state)\nthis:\n  m = Suc n mod |ls| - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < |ls|; 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)\n 2. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "with True"], ["proof (chain)\npicking this:\n  0 < Suc n mod |ls|\n  m = Suc n mod |ls| - 1", "have m: \"Suc m = (Suc n) mod (length ls)\""], ["proof (prove)\nusing this:\n  0 < Suc n mod |ls|\n  m = Suc n mod |ls| - 1\n\ngoal (1 subgoal):\n 1. Suc m = Suc n mod |ls|", "by auto"], ["proof (state)\nthis:\n  Suc m = Suc n mod |ls|\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < |ls|; 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)\n 2. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "with lls"], ["proof (chain)\npicking this:\n  0 < |ls|\n  Suc m = Suc n mod |ls|", "have a: \"(Suc m) <   length ls\""], ["proof (prove)\nusing this:\n  0 < |ls|\n  Suc m = Suc n mod |ls|\n\ngoal (1 subgoal):\n 1. Suc m < |ls|", "by auto"], ["proof (state)\nthis:\n  Suc m < |ls|\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < |ls|; 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)\n 2. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "from lls m"], ["proof (chain)\npicking this:\n  0 < |ls|\n  Suc m = Suc n mod |ls|", "have \"m = n mod (length ls)\""], ["proof (prove)\nusing this:\n  0 < |ls|\n  Suc m = Suc n mod |ls|\n\ngoal (1 subgoal):\n 1. m = n mod |ls|", "by (simp add: mod_Suc split:if_split_asm)"], ["proof (state)\nthis:\n  m = n mod |ls|\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < |ls|; 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)\n 2. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "with a m"], ["proof (chain)\npicking this:\n  Suc m < |ls|\n  Suc m = Suc n mod |ls|\n  m = n mod |ls|", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc m < |ls|\n  Suc m = Suc n mod |ls|\n  m = n mod |ls|\n\ngoal (1 subgoal):\n 1. ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "apply (drule_tac nth_rotate1_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc m = Suc n mod |ls|; m = n mod |ls|;\n     ls ! Suc m = rotate1 ls ! m\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "by auto"], ["proof (state)\nthis:\n  ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "assume lls: \"0 < length ls\""], ["proof (state)\nthis:\n  0 < |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < Suc n mod |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < Suc n mod |ls|", "have a: \"(Suc n) mod (length ls) = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < Suc n mod |ls|\n\ngoal (1 subgoal):\n 1. Suc n mod |ls| = 0", "by auto"], ["proof (state)\nthis:\n  Suc n mod |ls| = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "with lls"], ["proof (chain)\npicking this:\n  0 < |ls|\n  Suc n mod |ls| = 0", "have \"Suc (n mod (length ls)) = (length ls)\""], ["proof (prove)\nusing this:\n  0 < |ls|\n  Suc n mod |ls| = 0\n\ngoal (1 subgoal):\n 1. Suc (n mod |ls|) = |ls|", "by (auto simp: mod_Suc split: if_split_asm)"], ["proof (state)\nthis:\n  Suc (n mod |ls|) = |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "then"], ["proof (chain)\npicking this:\n  Suc (n mod |ls|) = |ls|", "have \"(n mod (length ls)) = (length ls) - 1\""], ["proof (prove)\nusing this:\n  Suc (n mod |ls|) = |ls|\n\ngoal (1 subgoal):\n 1. n mod |ls| = |ls| - 1", "by arith"], ["proof (state)\nthis:\n  n mod |ls| = |ls| - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < |ls|; \\<not> 0 < Suc n mod |ls|\\<rbrakk>\n    \\<Longrightarrow> ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "with a"], ["proof (chain)\npicking this:\n  Suc n mod |ls| = 0\n  n mod |ls| = |ls| - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc n mod |ls| = 0\n  n mod |ls| = |ls| - 1\n\ngoal (1 subgoal):\n 1. ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)", "by (auto simp: nth_rotate1_0)"], ["proof (state)\nthis:\n  ls ! (Suc n mod |ls|) = rotate1 ls ! (n mod |ls|)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate_Suc2[simp]: \"rotate n (rotate1 xs) = rotate (Suc n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate n (rotate1 xs) = rotate (Suc n) xs", "apply (simp add:rotate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rotate1 ^^ n) (rotate1 xs) = rotate1 ((rotate1 ^^ n) xs)", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (rotate1 ^^ 0) (rotate1 xs) = rotate1 ((rotate1 ^^ 0) xs)\n 2. \\<And>n.\n       (rotate1 ^^ n) (rotate1 xs) =\n       rotate1 ((rotate1 ^^ n) xs) \\<Longrightarrow>\n       (rotate1 ^^ Suc n) (rotate1 xs) = rotate1 ((rotate1 ^^ Suc n) xs)", "by auto"], ["", "lemma nth_rotate: \"\\<And> ls. 0 < length ls \\<Longrightarrow> ls!((n+m) mod (length ls)) = (rotate m ls)!(n mod (length ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       0 < |ls| \\<Longrightarrow>\n       ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|)", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ls.\n       0 < |ls| \\<Longrightarrow>\n       ls ! ((n + 0) mod |ls|) = rotate 0 ls ! (n mod |ls|)\n 2. \\<And>m ls.\n       \\<lbrakk>\\<And>ls.\n                   0 < |ls| \\<Longrightarrow>\n                   ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|);\n        0 < |ls|\\<rbrakk>\n       \\<Longrightarrow> ls ! ((n + Suc m) mod |ls|) =\n                         rotate (Suc m) ls ! (n mod |ls|)", "case 0"], ["proof (state)\nthis:\n  0 < |ls|\n\ngoal (2 subgoals):\n 1. \\<And>ls.\n       0 < |ls| \\<Longrightarrow>\n       ls ! ((n + 0) mod |ls|) = rotate 0 ls ! (n mod |ls|)\n 2. \\<And>m ls.\n       \\<lbrakk>\\<And>ls.\n                   0 < |ls| \\<Longrightarrow>\n                   ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|);\n        0 < |ls|\\<rbrakk>\n       \\<Longrightarrow> ls ! ((n + Suc m) mod |ls|) =\n                         rotate (Suc m) ls ! (n mod |ls|)", "then"], ["proof (chain)\npicking this:\n  0 < |ls|", "show ?case"], ["proof (prove)\nusing this:\n  0 < |ls|\n\ngoal (1 subgoal):\n 1. ls ! ((n + 0) mod |ls|) = rotate 0 ls ! (n mod |ls|)", "by auto"], ["proof (state)\nthis:\n  ls ! ((n + 0) mod |ls|) = rotate 0 ls ! (n mod |ls|)\n\ngoal (1 subgoal):\n 1. \\<And>m ls.\n       \\<lbrakk>\\<And>ls.\n                   0 < |ls| \\<Longrightarrow>\n                   ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|);\n        0 < |ls|\\<rbrakk>\n       \\<Longrightarrow> ls ! ((n + Suc m) mod |ls|) =\n                         rotate (Suc m) ls ! (n mod |ls|)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m ls.\n       \\<lbrakk>\\<And>ls.\n                   0 < |ls| \\<Longrightarrow>\n                   ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|);\n        0 < |ls|\\<rbrakk>\n       \\<Longrightarrow> ls ! ((n + Suc m) mod |ls|) =\n                         rotate (Suc m) ls ! (n mod |ls|)", "case (Suc m)"], ["proof (state)\nthis:\n  0 < |?ls| \\<Longrightarrow>\n  ?ls ! ((n + m) mod |?ls|) = rotate m ?ls ! (n mod |?ls|)\n  0 < |ls|\n\ngoal (1 subgoal):\n 1. \\<And>m ls.\n       \\<lbrakk>\\<And>ls.\n                   0 < |ls| \\<Longrightarrow>\n                   ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|);\n        0 < |ls|\\<rbrakk>\n       \\<Longrightarrow> ls ! ((n + Suc m) mod |ls|) =\n                         rotate (Suc m) ls ! (n mod |ls|)", "define z where \"z = n + m\""], ["proof (state)\nthis:\n  z = n + m\n\ngoal (1 subgoal):\n 1. \\<And>m ls.\n       \\<lbrakk>\\<And>ls.\n                   0 < |ls| \\<Longrightarrow>\n                   ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|);\n        0 < |ls|\\<rbrakk>\n       \\<Longrightarrow> ls ! ((n + Suc m) mod |ls|) =\n                         rotate (Suc m) ls ! (n mod |ls|)", "then"], ["proof (chain)\npicking this:\n  z = n + m", "have \"n + Suc m = Suc (z)\""], ["proof (prove)\nusing this:\n  z = n + m\n\ngoal (1 subgoal):\n 1. n + Suc m = Suc z", "by auto"], ["proof (state)\nthis:\n  n + Suc m = Suc z\n\ngoal (1 subgoal):\n 1. \\<And>m ls.\n       \\<lbrakk>\\<And>ls.\n                   0 < |ls| \\<Longrightarrow>\n                   ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|);\n        0 < |ls|\\<rbrakk>\n       \\<Longrightarrow> ls ! ((n + Suc m) mod |ls|) =\n                         rotate (Suc m) ls ! (n mod |ls|)", "with Suc"], ["proof (chain)\npicking this:\n  0 < |?ls| \\<Longrightarrow>\n  ?ls ! ((n + m) mod |?ls|) = rotate m ?ls ! (n mod |?ls|)\n  0 < |ls|\n  n + Suc m = Suc z", "have r1: \"ls ! ((Suc z) mod length ls) = rotate1 ls ! (z mod length ls)\""], ["proof (prove)\nusing this:\n  0 < |?ls| \\<Longrightarrow>\n  ?ls ! ((n + m) mod |?ls|) = rotate m ?ls ! (n mod |?ls|)\n  0 < |ls|\n  n + Suc m = Suc z\n\ngoal (1 subgoal):\n 1. ls ! (Suc z mod |ls|) = rotate1 ls ! (z mod |ls|)", "by (rule_tac nth_rotate1)"], ["proof (state)\nthis:\n  ls ! (Suc z mod |ls|) = rotate1 ls ! (z mod |ls|)\n\ngoal (1 subgoal):\n 1. \\<And>m ls.\n       \\<lbrakk>\\<And>ls.\n                   0 < |ls| \\<Longrightarrow>\n                   ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|);\n        0 < |ls|\\<rbrakk>\n       \\<Longrightarrow> ls ! ((n + Suc m) mod |ls|) =\n                         rotate (Suc m) ls ! (n mod |ls|)", "from Suc"], ["proof (chain)\npicking this:\n  0 < |?ls| \\<Longrightarrow>\n  ?ls ! ((n + m) mod |?ls|) = rotate m ?ls ! (n mod |?ls|)\n  0 < |ls|", "have \"0 < length (rotate1 ls)\""], ["proof (prove)\nusing this:\n  0 < |?ls| \\<Longrightarrow>\n  ?ls ! ((n + m) mod |?ls|) = rotate m ?ls ! (n mod |?ls|)\n  0 < |ls|\n\ngoal (1 subgoal):\n 1. 0 < |rotate1 ls|", "by auto"], ["proof (state)\nthis:\n  0 < |rotate1 ls|\n\ngoal (1 subgoal):\n 1. \\<And>m ls.\n       \\<lbrakk>\\<And>ls.\n                   0 < |ls| \\<Longrightarrow>\n                   ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|);\n        0 < |ls|\\<rbrakk>\n       \\<Longrightarrow> ls ! ((n + Suc m) mod |ls|) =\n                         rotate (Suc m) ls ! (n mod |ls|)", "then"], ["proof (chain)\npicking this:\n  0 < |rotate1 ls|", "have \"(rotate1 ls) ! ((n + m) mod length (rotate1 ls))\n    = rotate m (rotate1 ls) ! (n mod length (rotate1 ls))\""], ["proof (prove)\nusing this:\n  0 < |rotate1 ls|\n\ngoal (1 subgoal):\n 1. rotate1 ls ! ((n + m) mod |rotate1 ls|) =\n    rotate m (rotate1 ls) ! (n mod |rotate1 ls|)", "by (rule Suc)"], ["proof (state)\nthis:\n  rotate1 ls ! ((n + m) mod |rotate1 ls|) =\n  rotate m (rotate1 ls) ! (n mod |rotate1 ls|)\n\ngoal (1 subgoal):\n 1. \\<And>m ls.\n       \\<lbrakk>\\<And>ls.\n                   0 < |ls| \\<Longrightarrow>\n                   ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|);\n        0 < |ls|\\<rbrakk>\n       \\<Longrightarrow> ls ! ((n + Suc m) mod |ls|) =\n                         rotate (Suc m) ls ! (n mod |ls|)", "with r1 z_def"], ["proof (chain)\npicking this:\n  ls ! (Suc z mod |ls|) = rotate1 ls ! (z mod |ls|)\n  z = n + m\n  rotate1 ls ! ((n + m) mod |rotate1 ls|) =\n  rotate m (rotate1 ls) ! (n mod |rotate1 ls|)", "have \"ls ! ((n + Suc m) mod length ls)\n    = rotate m (rotate1 ls) ! (n mod length (rotate1 ls))\""], ["proof (prove)\nusing this:\n  ls ! (Suc z mod |ls|) = rotate1 ls ! (z mod |ls|)\n  z = n + m\n  rotate1 ls ! ((n + m) mod |rotate1 ls|) =\n  rotate m (rotate1 ls) ! (n mod |rotate1 ls|)\n\ngoal (1 subgoal):\n 1. ls ! ((n + Suc m) mod |ls|) =\n    rotate m (rotate1 ls) ! (n mod |rotate1 ls|)", "by auto"], ["proof (state)\nthis:\n  ls ! ((n + Suc m) mod |ls|) = rotate m (rotate1 ls) ! (n mod |rotate1 ls|)\n\ngoal (1 subgoal):\n 1. \\<And>m ls.\n       \\<lbrakk>\\<And>ls.\n                   0 < |ls| \\<Longrightarrow>\n                   ls ! ((n + m) mod |ls|) = rotate m ls ! (n mod |ls|);\n        0 < |ls|\\<rbrakk>\n       \\<Longrightarrow> ls ! ((n + Suc m) mod |ls|) =\n                         rotate (Suc m) ls ! (n mod |ls|)", "then"], ["proof (chain)\npicking this:\n  ls ! ((n + Suc m) mod |ls|) = rotate m (rotate1 ls) ! (n mod |rotate1 ls|)", "show ?case"], ["proof (prove)\nusing this:\n  ls ! ((n + Suc m) mod |ls|) = rotate m (rotate1 ls) ! (n mod |rotate1 ls|)\n\ngoal (1 subgoal):\n 1. ls ! ((n + Suc m) mod |ls|) = rotate (Suc m) ls ! (n mod |ls|)", "by auto"], ["proof (state)\nthis:\n  ls ! ((n + Suc m) mod |ls|) = rotate (Suc m) ls ! (n mod |ls|)\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************* SplitAt *******************************************)"], ["", "subsection \\<open>\\<open>splitAt\\<close>\\<close>"], ["", "primrec splitAtRec :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<times> 'a list\" where\n  \"splitAtRec c bs [] = (bs,[])\"\n| \"splitAtRec c bs (a#as) = (if a = c then (bs, as)\n                              else splitAtRec c (bs@[a]) as)\""], ["", "definition splitAt :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<times> 'a list\" where\n  \"splitAt c as  \\<equiv> splitAtRec c [] as\""], ["", "subsubsection \\<open>@{const splitAtRec}\\<close>"], ["", "lemma splitAtRec_conv: \"\\<And>bs.\n splitAtRec x bs xs =\n (bs @ takeWhile (\\<lambda>y. y\\<noteq>x) xs, tl(dropWhile (\\<lambda>y. y\\<noteq>x) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       splitAtRec x bs xs =\n       (bs @ takeWhile (\\<lambda>y. y \\<noteq> x) xs,\n        tl (dropWhile (\\<lambda>y. y \\<noteq> x) xs))", "by(induct xs) auto"], ["", "lemma splitAtRec_distinct_fst: \"\\<And> s. distinct vs \\<Longrightarrow> distinct s \\<Longrightarrow> (set s) \\<inter>  (set vs) = {} \\<Longrightarrow> distinct (fst (splitAtRec ram1 s vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>distinct vs; distinct s; set s \\<inter> set vs = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (fst (splitAtRec ram1 s vs))", "by (induct vs) auto"], ["", "lemma splitAtRec_distinct_snd: \"\\<And> s. distinct vs \\<Longrightarrow> distinct s \\<Longrightarrow> (set s) \\<inter>  (set vs) = {} \\<Longrightarrow> distinct (snd (splitAtRec ram1 s vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>distinct vs; distinct s; set s \\<inter> set vs = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (snd (splitAtRec ram1 s vs))", "by (induct vs) auto"], ["", "lemma splitAtRec_ram:\n  \"\\<And> us a b. ram \\<in> set vs \\<Longrightarrow> (a, b) = splitAtRec ram us vs \\<Longrightarrow>\n  us @ vs = a @ [ram] @ b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>us a b.\n       \\<lbrakk>ram \\<in> set vs; (a, b) = splitAtRec ram us vs\\<rbrakk>\n       \\<Longrightarrow> us @ vs = a @ [ram] @ b", "proof (induct vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>us a b.\n       \\<lbrakk>ram \\<in> set []; (a, b) = splitAtRec ram us []\\<rbrakk>\n       \\<Longrightarrow> us @ [] = a @ [ram] @ b\n 2. \\<And>a vs us aa b.\n       \\<lbrakk>\\<And>us a b.\n                   \\<lbrakk>ram \\<in> set vs;\n                    (a, b) = splitAtRec ram us vs\\<rbrakk>\n                   \\<Longrightarrow> us @ vs = a @ [ram] @ b;\n        ram \\<in> set (a # vs);\n        (aa, b) = splitAtRec ram us (a # vs)\\<rbrakk>\n       \\<Longrightarrow> us @ a # vs = aa @ [ram] @ b", "case  Nil"], ["proof (state)\nthis:\n  ram \\<in> set []\n  (a, b) = splitAtRec ram us []\n\ngoal (2 subgoals):\n 1. \\<And>us a b.\n       \\<lbrakk>ram \\<in> set []; (a, b) = splitAtRec ram us []\\<rbrakk>\n       \\<Longrightarrow> us @ [] = a @ [ram] @ b\n 2. \\<And>a vs us aa b.\n       \\<lbrakk>\\<And>us a b.\n                   \\<lbrakk>ram \\<in> set vs;\n                    (a, b) = splitAtRec ram us vs\\<rbrakk>\n                   \\<Longrightarrow> us @ vs = a @ [ram] @ b;\n        ram \\<in> set (a # vs);\n        (aa, b) = splitAtRec ram us (a # vs)\\<rbrakk>\n       \\<Longrightarrow> us @ a # vs = aa @ [ram] @ b", "then"], ["proof (chain)\npicking this:\n  ram \\<in> set []\n  (a, b) = splitAtRec ram us []", "show ?case"], ["proof (prove)\nusing this:\n  ram \\<in> set []\n  (a, b) = splitAtRec ram us []\n\ngoal (1 subgoal):\n 1. us @ [] = a @ [ram] @ b", "by simp"], ["proof (state)\nthis:\n  us @ [] = a @ [ram] @ b\n\ngoal (1 subgoal):\n 1. \\<And>a vs us aa b.\n       \\<lbrakk>\\<And>us a b.\n                   \\<lbrakk>ram \\<in> set vs;\n                    (a, b) = splitAtRec ram us vs\\<rbrakk>\n                   \\<Longrightarrow> us @ vs = a @ [ram] @ b;\n        ram \\<in> set (a # vs);\n        (aa, b) = splitAtRec ram us (a # vs)\\<rbrakk>\n       \\<Longrightarrow> us @ a # vs = aa @ [ram] @ b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a vs us aa b.\n       \\<lbrakk>\\<And>us a b.\n                   \\<lbrakk>ram \\<in> set vs;\n                    (a, b) = splitAtRec ram us vs\\<rbrakk>\n                   \\<Longrightarrow> us @ vs = a @ [ram] @ b;\n        ram \\<in> set (a # vs);\n        (aa, b) = splitAtRec ram us (a # vs)\\<rbrakk>\n       \\<Longrightarrow> us @ a # vs = aa @ [ram] @ b", "case (Cons v vs)"], ["proof (state)\nthis:\n  \\<lbrakk>ram \\<in> set vs; (?a, ?b) = splitAtRec ram ?us vs\\<rbrakk>\n  \\<Longrightarrow> ?us @ vs = ?a @ [ram] @ ?b\n  ram \\<in> set (v # vs)\n  (a, b) = splitAtRec ram us (v # vs)\n\ngoal (1 subgoal):\n 1. \\<And>a vs us aa b.\n       \\<lbrakk>\\<And>us a b.\n                   \\<lbrakk>ram \\<in> set vs;\n                    (a, b) = splitAtRec ram us vs\\<rbrakk>\n                   \\<Longrightarrow> us @ vs = a @ [ram] @ b;\n        ram \\<in> set (a # vs);\n        (aa, b) = splitAtRec ram us (a # vs)\\<rbrakk>\n       \\<Longrightarrow> us @ a # vs = aa @ [ram] @ b", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>ram \\<in> set vs; (?a, ?b) = splitAtRec ram ?us vs\\<rbrakk>\n  \\<Longrightarrow> ?us @ vs = ?a @ [ram] @ ?b\n  ram \\<in> set (v # vs)\n  (a, b) = splitAtRec ram us (v # vs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>ram \\<in> set vs; (?a, ?b) = splitAtRec ram ?us vs\\<rbrakk>\n  \\<Longrightarrow> ?us @ vs = ?a @ [ram] @ ?b\n  ram \\<in> set (v # vs)\n  (a, b) = splitAtRec ram us (v # vs)\n\ngoal (1 subgoal):\n 1. us @ v # vs = a @ [ram] @ b", "by (auto dest: Cons(1) split: if_split_asm)"], ["proof (state)\nthis:\n  us @ v # vs = a @ [ram] @ b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAtRec_notRam:\n \"\\<And> us. ram \\<notin>  set vs \\<Longrightarrow> splitAtRec ram us vs = (us @ vs, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>us.\n       ram \\<notin> set vs \\<Longrightarrow>\n       splitAtRec ram us vs = (us @ vs, [])", "proof (induct vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>us.\n       ram \\<notin> set [] \\<Longrightarrow>\n       splitAtRec ram us [] = (us @ [], [])\n 2. \\<And>a vs us.\n       \\<lbrakk>\\<And>us.\n                   ram \\<notin> set vs \\<Longrightarrow>\n                   splitAtRec ram us vs = (us @ vs, []);\n        ram \\<notin> set (a # vs)\\<rbrakk>\n       \\<Longrightarrow> splitAtRec ram us (a # vs) = (us @ a # vs, [])", "case  Nil"], ["proof (state)\nthis:\n  ram \\<notin> set []\n\ngoal (2 subgoals):\n 1. \\<And>us.\n       ram \\<notin> set [] \\<Longrightarrow>\n       splitAtRec ram us [] = (us @ [], [])\n 2. \\<And>a vs us.\n       \\<lbrakk>\\<And>us.\n                   ram \\<notin> set vs \\<Longrightarrow>\n                   splitAtRec ram us vs = (us @ vs, []);\n        ram \\<notin> set (a # vs)\\<rbrakk>\n       \\<Longrightarrow> splitAtRec ram us (a # vs) = (us @ a # vs, [])", "then"], ["proof (chain)\npicking this:\n  ram \\<notin> set []", "show ?case"], ["proof (prove)\nusing this:\n  ram \\<notin> set []\n\ngoal (1 subgoal):\n 1. splitAtRec ram us [] = (us @ [], [])", "by simp"], ["proof (state)\nthis:\n  splitAtRec ram us [] = (us @ [], [])\n\ngoal (1 subgoal):\n 1. \\<And>a vs us.\n       \\<lbrakk>\\<And>us.\n                   ram \\<notin> set vs \\<Longrightarrow>\n                   splitAtRec ram us vs = (us @ vs, []);\n        ram \\<notin> set (a # vs)\\<rbrakk>\n       \\<Longrightarrow> splitAtRec ram us (a # vs) = (us @ a # vs, [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a vs us.\n       \\<lbrakk>\\<And>us.\n                   ram \\<notin> set vs \\<Longrightarrow>\n                   splitAtRec ram us vs = (us @ vs, []);\n        ram \\<notin> set (a # vs)\\<rbrakk>\n       \\<Longrightarrow> splitAtRec ram us (a # vs) = (us @ a # vs, [])", "case (Cons v vs)"], ["proof (state)\nthis:\n  ram \\<notin> set vs \\<Longrightarrow>\n  splitAtRec ram ?us vs = (?us @ vs, [])\n  ram \\<notin> set (v # vs)\n\ngoal (1 subgoal):\n 1. \\<And>a vs us.\n       \\<lbrakk>\\<And>us.\n                   ram \\<notin> set vs \\<Longrightarrow>\n                   splitAtRec ram us vs = (us @ vs, []);\n        ram \\<notin> set (a # vs)\\<rbrakk>\n       \\<Longrightarrow> splitAtRec ram us (a # vs) = (us @ a # vs, [])", "then"], ["proof (chain)\npicking this:\n  ram \\<notin> set vs \\<Longrightarrow>\n  splitAtRec ram ?us vs = (?us @ vs, [])\n  ram \\<notin> set (v # vs)", "show ?case"], ["proof (prove)\nusing this:\n  ram \\<notin> set vs \\<Longrightarrow>\n  splitAtRec ram ?us vs = (?us @ vs, [])\n  ram \\<notin> set (v # vs)\n\ngoal (1 subgoal):\n 1. splitAtRec ram us (v # vs) = (us @ v # vs, [])", "by auto"], ["proof (state)\nthis:\n  splitAtRec ram us (v # vs) = (us @ v # vs, [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAtRec_distinct: \"\\<And> s. distinct vs \\<Longrightarrow>\n  distinct s \\<Longrightarrow> (set s) \\<inter> (set vs) = {} \\<Longrightarrow>\n  set (fst (splitAtRec ram s vs)) \\<inter> set (snd (splitAtRec ram s vs)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>distinct vs; distinct s; set s \\<inter> set vs = {}\\<rbrakk>\n       \\<Longrightarrow> set (fst (splitAtRec ram s vs)) \\<inter>\n                         set (snd (splitAtRec ram s vs)) =\n                         {}", "by (induct vs) auto"], ["", "subsubsection \\<open>@{const splitAt}\\<close>"], ["", "lemma splitAt_conv:\n \"splitAt x xs = (takeWhile (\\<lambda>y. y\\<noteq>x) xs, tl(dropWhile (\\<lambda>y. y\\<noteq>x) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splitAt x xs =\n    (takeWhile (\\<lambda>y. y \\<noteq> x) xs,\n     tl (dropWhile (\\<lambda>y. y \\<noteq> x) xs))", "by(simp add: splitAt_def splitAtRec_conv)"], ["", "lemma splitAt_no_ram[simp]:\n  \"ram \\<notin> set vs \\<Longrightarrow> splitAt ram vs = (vs, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ram \\<notin> set vs \\<Longrightarrow> splitAt ram vs = (vs, [])", "by (auto simp: splitAt_def splitAtRec_notRam)"], ["", "lemma splitAt_split:\n  \"ram \\<in> set vs \\<Longrightarrow> (a,b) = splitAt ram vs \\<Longrightarrow> vs = a @ ram # b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<in> set vs; (a, b) = splitAt ram vs\\<rbrakk>\n    \\<Longrightarrow> vs = a @ ram # b", "by (auto simp: splitAt_def dest: splitAtRec_ram)"], ["", "lemma splitAt_ram:\n  \"ram \\<in> set vs \\<Longrightarrow> vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ram \\<in> set vs \\<Longrightarrow>\n    vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)", "by (rule_tac splitAt_split) auto"], ["", "lemma fst_splitAt_last:\n \"\\<lbrakk> xs \\<noteq> []; distinct xs \\<rbrakk> \\<Longrightarrow> fst (splitAt (last xs) xs) = butlast xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; distinct xs\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt (last xs) xs) = butlast xs", "by(simp add:splitAt_conv takeWhile_not_last)"], ["", "subsubsection \\<open>Sets\\<close>"], ["", "lemma splitAtRec_union:\n\"\\<And> a b s. (a,b) = splitAtRec ram s vs \\<Longrightarrow> (set a \\<union> set b) - {ram} = (set vs \\<union> set s) - {ram}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b s.\n       (a, b) = splitAtRec ram s vs \\<Longrightarrow>\n       set a \\<union> set b - {ram} = set vs \\<union> set s - {ram}", "apply (induct vs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b s.\n       (a, b) = splitAtRec ram s [] \\<Longrightarrow>\n       set a \\<union> set b - {ram} = set [] \\<union> set s - {ram}\n 2. \\<And>a vs aa b s.\n       \\<lbrakk>\\<And>a b s.\n                   (a, b) = splitAtRec ram s vs \\<Longrightarrow>\n                   set a \\<union> set b - {ram} =\n                   set vs \\<union> set s - {ram};\n        (aa, b) = splitAtRec ram s (a # vs)\\<rbrakk>\n       \\<Longrightarrow> set aa \\<union> set b - {ram} =\n                         set (a # vs) \\<union> set s - {ram}", "by (auto split: if_split_asm)"], ["", "lemma splitAt_subset_ab:\n  \"(a,b) = splitAt ram vs \\<Longrightarrow> set a \\<subseteq> set vs \\<and> set b \\<subseteq> set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) = splitAt ram vs \\<Longrightarrow>\n    set a \\<subseteq> set vs \\<and> set b \\<subseteq> set vs", "apply (cases \"ram \\<in> set vs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(a, b) = splitAt ram vs; ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> set a \\<subseteq> set vs \\<and>\n                      set b \\<subseteq> set vs\n 2. \\<lbrakk>(a, b) = splitAt ram vs; ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> set a \\<subseteq> set vs \\<and>\n                      set b \\<subseteq> set vs", "by (auto dest: splitAt_split simp: splitAt_no_ram)"], ["", "lemma splitAt_in_fst[dest]: \"v \\<in> set (fst (splitAt ram vs)) \\<Longrightarrow> v \\<in> set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (fst (splitAt ram vs)) \\<Longrightarrow> v \\<in> set vs", "proof (cases \"ram \\<in> set vs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (fst (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (fst (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "assume v: \"v \\<in> set (fst (splitAt ram vs))\""], ["proof (state)\nthis:\n  v \\<in> set (fst (splitAt ram vs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (fst (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (fst (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "define a where \"a = fst (splitAt ram vs)\""], ["proof (state)\nthis:\n  a = fst (splitAt ram vs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (fst (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (fst (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "with v"], ["proof (chain)\npicking this:\n  v \\<in> set (fst (splitAt ram vs))\n  a = fst (splitAt ram vs)", "have vin: \"v \\<in> set a\""], ["proof (prove)\nusing this:\n  v \\<in> set (fst (splitAt ram vs))\n  a = fst (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. v \\<in> set a", "by auto"], ["proof (state)\nthis:\n  v \\<in> set a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (fst (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (fst (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "define b where \"b = snd (splitAt ram vs)\""], ["proof (state)\nthis:\n  b = snd (splitAt ram vs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (fst (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (fst (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "case True"], ["proof (state)\nthis:\n  ram \\<in> set vs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (fst (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (fst (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "with a_def b_def"], ["proof (chain)\npicking this:\n  a = fst (splitAt ram vs)\n  b = snd (splitAt ram vs)\n  ram \\<in> set vs", "have \"vs = a @ ram # b\""], ["proof (prove)\nusing this:\n  a = fst (splitAt ram vs)\n  b = snd (splitAt ram vs)\n  ram \\<in> set vs\n\ngoal (1 subgoal):\n 1. vs = a @ ram # b", "by (auto dest: splitAt_ram)"], ["proof (state)\nthis:\n  vs = a @ ram # b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (fst (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (fst (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "with vin"], ["proof (chain)\npicking this:\n  v \\<in> set a\n  vs = a @ ram # b", "show \"v \\<in> set vs\""], ["proof (prove)\nusing this:\n  v \\<in> set a\n  vs = a @ ram # b\n\ngoal (1 subgoal):\n 1. v \\<in> set vs", "by auto"], ["proof (state)\nthis:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (fst (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (fst (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "assume v: \"v \\<in> set (fst (splitAt ram vs))\""], ["proof (state)\nthis:\n  v \\<in> set (fst (splitAt ram vs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (fst (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "case False"], ["proof (state)\nthis:\n  ram \\<notin> set vs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (fst (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "with v"], ["proof (chain)\npicking this:\n  v \\<in> set (fst (splitAt ram vs))\n  ram \\<notin> set vs", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (fst (splitAt ram vs))\n  ram \\<notin> set vs\n\ngoal (1 subgoal):\n 1. v \\<in> set vs", "by (auto dest: splitAt_no_ram del: notI)"], ["proof (state)\nthis:\n  v \\<in> set vs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_not1:\n\"v \\<notin> set vs \\<Longrightarrow> v \\<notin> set (fst (splitAt ram vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> set vs \\<Longrightarrow>\n    v \\<notin> set (fst (splitAt ram vs))", "by (auto dest: splitAt_in_fst)"], ["", "lemma splitAt_in_snd[dest]: \"v \\<in> set (snd (splitAt ram vs)) \\<Longrightarrow> v \\<in> set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (snd (splitAt ram vs)) \\<Longrightarrow> v \\<in> set vs", "proof (cases \"ram \\<in> set vs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (snd (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (snd (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "assume v: \"v \\<in> set (snd (splitAt ram vs))\""], ["proof (state)\nthis:\n  v \\<in> set (snd (splitAt ram vs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (snd (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (snd (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "define a where \"a = fst (splitAt ram vs)\""], ["proof (state)\nthis:\n  a = fst (splitAt ram vs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (snd (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (snd (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "define b where \"b = snd (splitAt ram vs)\""], ["proof (state)\nthis:\n  b = snd (splitAt ram vs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (snd (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (snd (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "with v"], ["proof (chain)\npicking this:\n  v \\<in> set (snd (splitAt ram vs))\n  b = snd (splitAt ram vs)", "have vin: \"v \\<in> set b\""], ["proof (prove)\nusing this:\n  v \\<in> set (snd (splitAt ram vs))\n  b = snd (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. v \\<in> set b", "by auto"], ["proof (state)\nthis:\n  v \\<in> set b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (snd (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (snd (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "case True"], ["proof (state)\nthis:\n  ram \\<in> set vs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (snd (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (snd (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "with a_def b_def"], ["proof (chain)\npicking this:\n  a = fst (splitAt ram vs)\n  b = snd (splitAt ram vs)\n  ram \\<in> set vs", "have \"vs = a @ ram # b\""], ["proof (prove)\nusing this:\n  a = fst (splitAt ram vs)\n  b = snd (splitAt ram vs)\n  ram \\<in> set vs\n\ngoal (1 subgoal):\n 1. vs = a @ ram # b", "by (auto dest: splitAt_ram)"], ["proof (state)\nthis:\n  vs = a @ ram # b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set (snd (splitAt ram vs)); ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs\n 2. \\<lbrakk>v \\<in> set (snd (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "with vin"], ["proof (chain)\npicking this:\n  v \\<in> set b\n  vs = a @ ram # b", "show \"v \\<in> set vs\""], ["proof (prove)\nusing this:\n  v \\<in> set b\n  vs = a @ ram # b\n\ngoal (1 subgoal):\n 1. v \\<in> set vs", "by auto"], ["proof (state)\nthis:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (snd (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (snd (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "assume v: \"v \\<in> set (snd (splitAt ram vs))\""], ["proof (state)\nthis:\n  v \\<in> set (snd (splitAt ram vs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (snd (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "case False"], ["proof (state)\nthis:\n  ram \\<notin> set vs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set (snd (splitAt ram vs));\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set vs", "with v"], ["proof (chain)\npicking this:\n  v \\<in> set (snd (splitAt ram vs))\n  ram \\<notin> set vs", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (snd (splitAt ram vs))\n  ram \\<notin> set vs\n\ngoal (1 subgoal):\n 1. v \\<in> set vs", "by (auto dest: splitAt_no_ram del: notI)"], ["proof (state)\nthis:\n  v \\<in> set vs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Distinctness\\<close>"], ["", "lemma splitAt_distinct_ab_aux:\n \"distinct vs \\<Longrightarrow> (a,b) = splitAt ram vs \\<Longrightarrow> distinct a \\<and> distinct b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; (a, b) = splitAt ram vs\\<rbrakk>\n    \\<Longrightarrow> distinct a \\<and> distinct b", "by (cases \"ram \\<in> set vs\") (auto dest: splitAt_split simp: splitAt_no_ram)"], ["", "lemma splitAt_distinct_fst_aux[intro]:\n \"distinct vs \\<Longrightarrow> distinct (fst (splitAt ram vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (fst (splitAt ram vs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (fst (splitAt ram vs))", "assume d: \"distinct vs\""], ["proof (state)\nthis:\n  distinct vs\n\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (fst (splitAt ram vs))", "define b where \"b = snd (splitAt ram vs)\""], ["proof (state)\nthis:\n  b = snd (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (fst (splitAt ram vs))", "define a where \"a = fst (splitAt ram vs)\""], ["proof (state)\nthis:\n  a = fst (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (fst (splitAt ram vs))", "with b_def"], ["proof (chain)\npicking this:\n  b = snd (splitAt ram vs)\n  a = fst (splitAt ram vs)", "have \"(a,b) = splitAt ram vs\""], ["proof (prove)\nusing this:\n  b = snd (splitAt ram vs)\n  a = fst (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. (a, b) = splitAt ram vs", "by auto"], ["proof (state)\nthis:\n  (a, b) = splitAt ram vs\n\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (fst (splitAt ram vs))", "with a_def d"], ["proof (chain)\npicking this:\n  a = fst (splitAt ram vs)\n  distinct vs\n  (a, b) = splitAt ram vs", "show ?thesis"], ["proof (prove)\nusing this:\n  a = fst (splitAt ram vs)\n  distinct vs\n  (a, b) = splitAt ram vs\n\ngoal (1 subgoal):\n 1. distinct (fst (splitAt ram vs))", "by (auto dest: splitAt_distinct_ab_aux)"], ["proof (state)\nthis:\n  distinct (fst (splitAt ram vs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_distinct_snd_aux[intro]:\n \"distinct vs \\<Longrightarrow> distinct (snd (splitAt ram vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (snd (splitAt ram vs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (snd (splitAt ram vs))", "assume d: \"distinct vs\""], ["proof (state)\nthis:\n  distinct vs\n\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (snd (splitAt ram vs))", "define b where \"b = snd (splitAt ram vs)\""], ["proof (state)\nthis:\n  b = snd (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (snd (splitAt ram vs))", "define a where \"a = fst (splitAt ram vs)\""], ["proof (state)\nthis:\n  a = fst (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (snd (splitAt ram vs))", "with b_def"], ["proof (chain)\npicking this:\n  b = snd (splitAt ram vs)\n  a = fst (splitAt ram vs)", "have \"(a,b) = splitAt ram vs\""], ["proof (prove)\nusing this:\n  b = snd (splitAt ram vs)\n  a = fst (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. (a, b) = splitAt ram vs", "by auto"], ["proof (state)\nthis:\n  (a, b) = splitAt ram vs\n\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (snd (splitAt ram vs))", "with b_def d"], ["proof (chain)\npicking this:\n  b = snd (splitAt ram vs)\n  distinct vs\n  (a, b) = splitAt ram vs", "show ?thesis"], ["proof (prove)\nusing this:\n  b = snd (splitAt ram vs)\n  distinct vs\n  (a, b) = splitAt ram vs\n\ngoal (1 subgoal):\n 1. distinct (snd (splitAt ram vs))", "by (auto dest: splitAt_distinct_ab_aux)"], ["proof (state)\nthis:\n  distinct (snd (splitAt ram vs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_distinct_ab:\n  \"distinct vs \\<Longrightarrow>  (a,b) = splitAt ram vs \\<Longrightarrow> set a \\<inter> set b = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; (a, b) = splitAt ram vs\\<rbrakk>\n    \\<Longrightarrow> set a \\<inter> set b = {}", "apply (cases \"ram \\<in> set vs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; (a, b) = splitAt ram vs; ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> set a \\<inter> set b = {}\n 2. \\<lbrakk>distinct vs; (a, b) = splitAt ram vs;\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> set a \\<inter> set b = {}", "apply (drule_tac splitAt_split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct vs; (a, b) = splitAt ram vs\\<rbrakk>\n    \\<Longrightarrow> (?a1, ?b1) = splitAt ram vs\n 2. \\<lbrakk>distinct vs; (a, b) = splitAt ram vs;\n     vs = ?a1 @ ram # ?b1\\<rbrakk>\n    \\<Longrightarrow> set a \\<inter> set b = {}\n 3. \\<lbrakk>distinct vs; (a, b) = splitAt ram vs;\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> set a \\<inter> set b = {}", "by (auto simp: splitAt_no_ram)"], ["", "lemma splitAt_distinct_fst_snd:\n    \"distinct vs \\<Longrightarrow>  set (fst (splitAt ram vs)) \\<inter> set (snd (splitAt ram vs)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow>\n    set (fst (splitAt ram vs)) \\<inter> set (snd (splitAt ram vs)) = {}", "by (rule_tac splitAt_distinct_ab) simp_all"], ["", "lemma splitAt_distinct_ram_fst[intro]:\n  \"distinct vs \\<Longrightarrow> ram \\<notin> set (fst (splitAt ram vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> ram \\<notin> set (fst (splitAt ram vs))", "apply (case_tac \"ram \\<in> set vs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set (fst (splitAt ram vs))\n 2. \\<lbrakk>distinct vs; ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set (fst (splitAt ram vs))", "apply (drule_tac splitAt_ram)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set (fst (splitAt ram vs))\n 2. \\<lbrakk>distinct vs; ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set (fst (splitAt ram vs))", "apply (rule distinct_split1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> distinct ?xs2\n 2. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> ?xs2 = fst (splitAt ram vs) @ [ram] @ ?z2\n 3. \\<lbrakk>distinct vs; ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set (fst (splitAt ram vs))", "by (force dest: splitAt_in_fst)+"], ["", "(*  apply (frule splitAt_no_ram) by auto  *)"], ["", "lemma splitAt_distinct_ram_snd[intro]:\n  \"distinct vs \\<Longrightarrow> ram \\<notin> set (snd (splitAt ram vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> ram \\<notin> set (snd (splitAt ram vs))", "apply (case_tac \"ram \\<in> set vs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set (snd (splitAt ram vs))\n 2. \\<lbrakk>distinct vs; ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set (snd (splitAt ram vs))", "apply (drule_tac splitAt_ram)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set (snd (splitAt ram vs))\n 2. \\<lbrakk>distinct vs; ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set (snd (splitAt ram vs))", "apply (rule distinct_split2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> distinct ?xs2\n 2. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> ?xs2 = ?y2 @ [ram] @ snd (splitAt ram vs)\n 3. \\<lbrakk>distinct vs; ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set (snd (splitAt ram vs))", "by (force dest: splitAt_in_fst)+"], ["", "lemma splitAt_1[simp]:\n  \"splitAt ram [] = ([],[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splitAt ram [] = ([], [])", "by (simp add: splitAt_def)"], ["", "lemma splitAt_2:\n  \"v \\<in> set vs \\<Longrightarrow> (a,b) = splitAt ram vs \\<Longrightarrow> v \\<in> set a \\<or> v \\<in> set b \\<or> v = ram \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set vs; (a, b) = splitAt ram vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set a \\<or> v \\<in> set b \\<or> v = ram", "apply (cases \"ram \\<in> set vs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set vs; (a, b) = splitAt ram vs;\n     ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set a \\<or> v \\<in> set b \\<or> v = ram\n 2. \\<lbrakk>v \\<in> set vs; (a, b) = splitAt ram vs;\n     ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> v \\<in> set a \\<or> v \\<in> set b \\<or> v = ram", "by (auto dest: splitAt_split simp: splitAt_no_ram)"], ["", "lemma splitAt_distinct_fst: \"distinct vs \\<Longrightarrow> distinct (fst (splitAt ram1 vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (fst (splitAt ram1 vs))", "by (simp add: splitAt_def splitAtRec_distinct_fst)"], ["", "lemma splitAt_distinct_a: \"distinct vs \\<Longrightarrow> (a,b) = splitAt ram vs \\<Longrightarrow> distinct a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; (a, b) = splitAt ram vs\\<rbrakk>\n    \\<Longrightarrow> distinct a", "by (auto dest: splitAt_distinct_fst pairD)"], ["", "lemma splitAt_distinct_snd: \"distinct vs \\<Longrightarrow> distinct (snd (splitAt ram1 vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (snd (splitAt ram1 vs))", "by (simp add: splitAt_def splitAtRec_distinct_snd)"], ["", "lemma splitAt_distinct_b: \"distinct vs \\<Longrightarrow> (a,b) = splitAt ram vs \\<Longrightarrow> distinct b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; (a, b) = splitAt ram vs\\<rbrakk>\n    \\<Longrightarrow> distinct b", "by (auto dest: splitAt_distinct_snd pairD)"], ["", "lemma splitAt_distinct: \"distinct vs \\<Longrightarrow> set (fst (splitAt ram vs)) \\<inter> set (snd (splitAt ram vs)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow>\n    set (fst (splitAt ram vs)) \\<inter> set (snd (splitAt ram vs)) = {}", "by (simp add: splitAt_def splitAtRec_distinct)"], ["", "lemma splitAt_subset: \"(a,b) = splitAt ram vs \\<Longrightarrow> (set a \\<subseteq> set vs) \\<and> (set b \\<subseteq> set vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) = splitAt ram vs \\<Longrightarrow>\n    set a \\<subseteq> set vs \\<and> set b \\<subseteq> set vs", "apply (cases \"ram \\<in> set vs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(a, b) = splitAt ram vs; ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> set a \\<subseteq> set vs \\<and>\n                      set b \\<subseteq> set vs\n 2. \\<lbrakk>(a, b) = splitAt ram vs; ram \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> set a \\<subseteq> set vs \\<and>\n                      set b \\<subseteq> set vs", "by (auto dest: splitAt_split simp: splitAt_no_ram)"], ["", "subsubsection \\<open>@{const splitAt} composition\\<close>"], ["", "lemma set_help: \"v \\<in> set ( as @ bs) \\<Longrightarrow> v \\<in> set as \\<or> v \\<in> set bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (as @ bs) \\<Longrightarrow>\n    v \\<in> set as \\<or> v \\<in> set bs", "by auto"], ["", "lemma splitAt_elements: \"ram1 \\<in> set vs \\<Longrightarrow> ram2 \\<in> set vs \\<Longrightarrow> ram2 \\<in> set( fst (splitAt ram1 vs)) \\<or> ram2 \\<in> set [ram1] \\<or>  ram2 \\<in> set( snd (splitAt ram1 vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram1 \\<in> set vs; ram2 \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> ram2 \\<in> set (fst (splitAt ram1 vs)) \\<or>\n                      ram2 \\<in> set [ram1] \\<or>\n                      ram2 \\<in> set (snd (splitAt ram1 vs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram1 \\<in> set vs; ram2 \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> ram2 \\<in> set (fst (splitAt ram1 vs)) \\<or>\n                      ram2 \\<in> set [ram1] \\<or>\n                      ram2 \\<in> set (snd (splitAt ram1 vs))", "assume r1: \"ram1 \\<in> set vs\" and r2: \"ram2 \\<in> set vs\""], ["proof (state)\nthis:\n  ram1 \\<in> set vs\n  ram2 \\<in> set vs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ram1 \\<in> set vs; ram2 \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> ram2 \\<in> set (fst (splitAt ram1 vs)) \\<or>\n                      ram2 \\<in> set [ram1] \\<or>\n                      ram2 \\<in> set (snd (splitAt ram1 vs))", "then"], ["proof (chain)\npicking this:\n  ram1 \\<in> set vs\n  ram2 \\<in> set vs", "have \"ram2 \\<in> set( fst (splitAt ram1 vs) @ [ram1]) \\<or>  ram2 \\<in> set( snd (splitAt ram1 vs))\""], ["proof (prove)\nusing this:\n  ram1 \\<in> set vs\n  ram2 \\<in> set vs\n\ngoal (1 subgoal):\n 1. ram2 \\<in> set (fst (splitAt ram1 vs) @ [ram1]) \\<or>\n    ram2 \\<in> set (snd (splitAt ram1 vs))", "apply (rule_tac set_help)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram1 \\<in> set vs; ram2 \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> ram2\n                      \\<in> set ((fst (splitAt ram1 vs) @ [ram1]) @\n                                 snd (splitAt ram1 vs))", "apply (drule_tac splitAt_ram)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram2 \\<in> set vs;\n     vs = fst (splitAt ram1 vs) @ ram1 # snd (splitAt ram1 vs)\\<rbrakk>\n    \\<Longrightarrow> ram2\n                      \\<in> set ((fst (splitAt ram1 vs) @ [ram1]) @\n                                 snd (splitAt ram1 vs))", "by auto"], ["proof (state)\nthis:\n  ram2 \\<in> set (fst (splitAt ram1 vs) @ [ram1]) \\<or>\n  ram2 \\<in> set (snd (splitAt ram1 vs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ram1 \\<in> set vs; ram2 \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> ram2 \\<in> set (fst (splitAt ram1 vs)) \\<or>\n                      ram2 \\<in> set [ram1] \\<or>\n                      ram2 \\<in> set (snd (splitAt ram1 vs))", "then"], ["proof (chain)\npicking this:\n  ram2 \\<in> set (fst (splitAt ram1 vs) @ [ram1]) \\<or>\n  ram2 \\<in> set (snd (splitAt ram1 vs))", "show ?thesis"], ["proof (prove)\nusing this:\n  ram2 \\<in> set (fst (splitAt ram1 vs) @ [ram1]) \\<or>\n  ram2 \\<in> set (snd (splitAt ram1 vs))\n\ngoal (1 subgoal):\n 1. ram2 \\<in> set (fst (splitAt ram1 vs)) \\<or>\n    ram2 \\<in> set [ram1] \\<or> ram2 \\<in> set (snd (splitAt ram1 vs))", "by auto"], ["proof (state)\nthis:\n  ram2 \\<in> set (fst (splitAt ram1 vs)) \\<or>\n  ram2 \\<in> set [ram1] \\<or> ram2 \\<in> set (snd (splitAt ram1 vs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_ram3: \"ram2 \\<notin>  set (fst (splitAt ram1 vs)) \\<Longrightarrow>\n  ram1 \\<in> set vs \\<Longrightarrow> ram2 \\<in> set vs \\<Longrightarrow> ram1 \\<noteq> ram2 \\<Longrightarrow>\n  ram2 \\<in> set (snd (splitAt ram1 vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram2 \\<notin> set (fst (splitAt ram1 vs)); ram1 \\<in> set vs;\n     ram2 \\<in> set vs; ram1 \\<noteq> ram2\\<rbrakk>\n    \\<Longrightarrow> ram2 \\<in> set (snd (splitAt ram1 vs))", "by (auto dest: splitAt_elements)"], ["", "lemma splitAt_dist_ram: \"distinct vs \\<Longrightarrow>\n vs = a @ ram # b \\<Longrightarrow> (a,b) = splitAt ram vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram # b\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram vs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram # b\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram vs", "assume dist: \"distinct vs\" and vs: \"vs = a @ ram # b\""], ["proof (state)\nthis:\n  distinct vs\n  vs = a @ ram # b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram # b\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram vs", "from vs"], ["proof (chain)\npicking this:\n  vs = a @ ram # b", "have r:\"ram \\<in> set vs\""], ["proof (prove)\nusing this:\n  vs = a @ ram # b\n\ngoal (1 subgoal):\n 1. ram \\<in> set vs", "by auto"], ["proof (state)\nthis:\n  ram \\<in> set vs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram # b\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram vs", "with dist vs"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ ram # b\n  ram \\<in> set vs", "have \"fst (splitAt ram vs) = a\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ ram # b\n  ram \\<in> set vs\n\ngoal (1 subgoal):\n 1. fst (splitAt ram vs) = a", "apply (drule_tac splitAt_ram)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram # b;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram vs) = a", "by (rule_tac dist_at1)  auto"], ["proof (state)\nthis:\n  fst (splitAt ram vs) = a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram # b\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram vs", "then"], ["proof (chain)\npicking this:\n  fst (splitAt ram vs) = a", "have first:\"a = fst (splitAt ram vs)\""], ["proof (prove)\nusing this:\n  fst (splitAt ram vs) = a\n\ngoal (1 subgoal):\n 1. a = fst (splitAt ram vs)", "by   auto"], ["proof (state)\nthis:\n  a = fst (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram # b\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram vs", "from r dist"], ["proof (chain)\npicking this:\n  ram \\<in> set vs\n  distinct vs", "have second: \"b = snd (splitAt ram vs)\""], ["proof (prove)\nusing this:\n  ram \\<in> set vs\n  distinct vs\n\ngoal (1 subgoal):\n 1. b = snd (splitAt ram vs)", "apply (drule_tac splitAt_ram)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> b = snd (splitAt ram vs)", "apply (rule dist_at2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> distinct ?vs3\n 2. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> ?vs3 = ?a3 @ ?r3 # b\n 3. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> ?vs3 = ?c3 @ ?r3 # snd (splitAt ram vs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> vs = ?a3 @ ?r3 # b\n 2. \\<lbrakk>distinct vs;\n     vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\\<rbrakk>\n    \\<Longrightarrow> vs = ?c3 @ ?r3 # snd (splitAt ram vs)", "by (auto simp: vs)"], ["proof (state)\nthis:\n  b = snd (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram # b\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram vs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) = splitAt ram vs", "by (auto simp: first second)"], ["proof (state)\nthis:\n  (a, b) = splitAt ram vs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_unique1: \"distinct vs \\<Longrightarrow> ram \\<in> set vs \\<Longrightarrow> \\<exists>!s. vs = (fst s) @ ram # (snd s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>!s. vs = fst s @ ram # snd s", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> vs = fst ?a @ ram # snd ?a\n 2. \\<And>s.\n       \\<lbrakk>distinct vs; ram \\<in> set vs;\n        vs = fst s @ ram # snd s\\<rbrakk>\n       \\<Longrightarrow> s = ?a", "assume d: \"distinct vs\" and r: \"ram \\<in> set vs\""], ["proof (state)\nthis:\n  distinct vs\n  ram \\<in> set vs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> vs = fst ?a @ ram # snd ?a\n 2. \\<And>s.\n       \\<lbrakk>distinct vs; ram \\<in> set vs;\n        vs = fst s @ ram # snd s\\<rbrakk>\n       \\<Longrightarrow> s = ?a", "define s where \"s = splitAt ram vs\""], ["proof (state)\nthis:\n  s = splitAt ram vs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; ram \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> vs = fst ?a @ ram # snd ?a\n 2. \\<And>s.\n       \\<lbrakk>distinct vs; ram \\<in> set vs;\n        vs = fst s @ ram # snd s\\<rbrakk>\n       \\<Longrightarrow> s = ?a", "with r"], ["proof (chain)\npicking this:\n  ram \\<in> set vs\n  s = splitAt ram vs", "show  \"vs = (fst s) @ ram # (snd s)\""], ["proof (prove)\nusing this:\n  ram \\<in> set vs\n  s = splitAt ram vs\n\ngoal (1 subgoal):\n 1. vs = fst s @ ram # snd s", "by (auto intro: splitAt_ram)"], ["proof (state)\nthis:\n  vs = fst s @ ram # snd s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>distinct vs; ram \\<in> set vs;\n        vs = fst s @ ram # snd s\\<rbrakk>\n       \\<Longrightarrow> s = splitAt ram vs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>distinct vs; ram \\<in> set vs;\n        vs = fst s @ ram # snd s\\<rbrakk>\n       \\<Longrightarrow> s = splitAt ram vs", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>distinct vs; ram \\<in> set vs;\n        vs = fst s @ ram # snd s\\<rbrakk>\n       \\<Longrightarrow> s = splitAt ram vs", "assume d: \"distinct vs\" and vs1: \"vs = fst s @ ram # snd s\""], ["proof (state)\nthis:\n  distinct vs\n  vs = fst s @ ram # snd s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>distinct vs; ram \\<in> set vs;\n        vs = fst s @ ram # snd s\\<rbrakk>\n       \\<Longrightarrow> s = splitAt ram vs", "from d vs1"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = fst s @ ram # snd s", "show \"s = splitAt ram vs\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = fst s @ ram # snd s\n\ngoal (1 subgoal):\n 1. s = splitAt ram vs", "apply (drule_tac splitAt_dist_ram)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vs = fst s @ ram # snd s \\<Longrightarrow> vs = ?a2 @ ?ram2 # ?b2\n 2. \\<lbrakk>vs = fst s @ ram # snd s;\n     (?a2, ?b2) = splitAt ?ram2 vs\\<rbrakk>\n    \\<Longrightarrow> s = splitAt ram vs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs = fst s @ ram # snd s;\n     (fst s, snd s) = splitAt ram vs\\<rbrakk>\n    \\<Longrightarrow> s = splitAt ram vs", "by simp"], ["proof (state)\nthis:\n  s = splitAt ram vs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_dist_ram2: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>\n (a @ ram1 # b, c) = splitAt ram2 vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a @ ram1 # b, c) = splitAt ram2 vs", "by (auto intro: splitAt_dist_ram)"], ["", "lemma splitAt_dist_ram20: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>\n  c = snd (splitAt ram2 vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> c = snd (splitAt ram2 vs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> c = snd (splitAt ram2 vs)", "assume dist: \"distinct vs\" and vs: \"vs = a @ ram1 # b @ ram2 # c\""], ["proof (state)\nthis:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> c = snd (splitAt ram2 vs)", "then"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c", "show \"c = snd (splitAt ram2 vs)\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. c = snd (splitAt ram2 vs)", "apply (drule_tac splitAt_dist_ram2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>\n    vs = ?a2 @ ?ram1.2 # ?b2 @ ?ram2.2 # ?c2\n 2. \\<lbrakk>vs = a @ ram1 # b @ ram2 # c;\n     (?a2 @ ?ram1.2 # ?b2, ?c2) = splitAt ?ram2.2 vs\\<rbrakk>\n    \\<Longrightarrow> c = snd (splitAt ram2 vs)", "by (auto dest: pairD)"], ["proof (state)\nthis:\n  c = snd (splitAt ram2 vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_dist_ram21: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow> (a, b) = splitAt ram1 (fst (splitAt ram2 vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram1 (fst (splitAt ram2 vs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram1 (fst (splitAt ram2 vs))", "assume dist: \"distinct vs\" and vs: \"vs = a @ ram1 # b @ ram2 # c\""], ["proof (state)\nthis:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram1 (fst (splitAt ram2 vs))", "then"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c", "have \"fst (splitAt ram2 vs) = a @ ram1 # b\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. fst (splitAt ram2 vs) = a @ ram1 # b", "apply (drule_tac splitAt_dist_ram2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>\n    vs = ?a2 @ ?ram1.2 # ?b2 @ ?ram2.2 # ?c2\n 2. \\<lbrakk>vs = a @ ram1 # b @ ram2 # c;\n     (?a2 @ ?ram1.2 # ?b2, ?c2) = splitAt ?ram2.2 vs\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram2 vs) = a @ ram1 # b", "by (auto dest: pairD)"], ["proof (state)\nthis:\n  fst (splitAt ram2 vs) = a @ ram1 # b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram1 (fst (splitAt ram2 vs))", "with dist vs"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n  fst (splitAt ram2 vs) = a @ ram1 # b", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n  fst (splitAt ram2 vs) = a @ ram1 # b\n\ngoal (1 subgoal):\n 1. (a, b) = splitAt ram1 (fst (splitAt ram2 vs))", "by (rule_tac splitAt_dist_ram) auto"], ["proof (state)\nthis:\n  (a, b) = splitAt ram1 (fst (splitAt ram2 vs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_dist_ram22: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>  (c, []) = splitAt ram1 (snd (splitAt ram2 vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (c, []) = splitAt ram1 (snd (splitAt ram2 vs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (c, []) = splitAt ram1 (snd (splitAt ram2 vs))", "assume dist: \"distinct vs\" and vs: \"vs = a @ ram1 # b @ ram2 # c\""], ["proof (state)\nthis:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (c, []) = splitAt ram1 (snd (splitAt ram2 vs))", "then"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c", "have \"snd (splitAt ram2 vs) = c\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. snd (splitAt ram2 vs) = c", "apply (drule_tac splitAt_dist_ram2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>\n    vs = ?a2 @ ?ram1.2 # ?b2 @ ?ram2.2 # ?c2\n 2. \\<lbrakk>vs = a @ ram1 # b @ ram2 # c;\n     (?a2 @ ?ram1.2 # ?b2, ?c2) = splitAt ?ram2.2 vs\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt ram2 vs) = c", "by (auto dest: pairD)"], ["proof (state)\nthis:\n  snd (splitAt ram2 vs) = c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (c, []) = splitAt ram1 (snd (splitAt ram2 vs))", "with dist vs"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n  snd (splitAt ram2 vs) = c", "have \"splitAt ram1 (snd (splitAt ram2 vs)) = (c, [])\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n  snd (splitAt ram2 vs) = c\n\ngoal (1 subgoal):\n 1. splitAt ram1 (snd (splitAt ram2 vs)) = (c, [])", "by (auto intro: splitAt_no_ram)"], ["proof (state)\nthis:\n  splitAt ram1 (snd (splitAt ram2 vs)) = (c, [])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (c, []) = splitAt ram1 (snd (splitAt ram2 vs))", "then"], ["proof (chain)\npicking this:\n  splitAt ram1 (snd (splitAt ram2 vs)) = (c, [])", "show ?thesis"], ["proof (prove)\nusing this:\n  splitAt ram1 (snd (splitAt ram2 vs)) = (c, [])\n\ngoal (1 subgoal):\n 1. (c, []) = splitAt ram1 (snd (splitAt ram2 vs))", "by auto"], ["proof (state)\nthis:\n  (c, []) = splitAt ram1 (snd (splitAt ram2 vs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_dist_ram1: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow> (a, b @ ram2 # c) = splitAt ram1 vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, b @ ram2 # c) = splitAt ram1 vs", "by (auto intro: splitAt_dist_ram)"], ["", "lemma splitAt_dist_ram10: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow> a = fst (splitAt ram1 vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> a = fst (splitAt ram1 vs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> a = fst (splitAt ram1 vs)", "assume dist: \"distinct vs\" and vs: \"vs = a @ ram1 # b @ ram2 # c\""], ["proof (state)\nthis:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> a = fst (splitAt ram1 vs)", "then"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c", "show \"a = fst (splitAt ram1 vs)\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. a = fst (splitAt ram1 vs)", "apply (drule_tac splitAt_dist_ram1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>\n    vs = ?a2 @ ?ram1.2 # ?b2 @ ?ram2.2 # ?c2\n 2. \\<lbrakk>vs = a @ ram1 # b @ ram2 # c;\n     (?a2, ?b2 @ ?ram2.2 # ?c2) = splitAt ?ram1.2 vs\\<rbrakk>\n    \\<Longrightarrow> a = fst (splitAt ram1 vs)", "by (auto dest: pairD)"], ["proof (state)\nthis:\n  a = fst (splitAt ram1 vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_dist_ram11: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs))", "assume dist: \"distinct vs\" and vs: \"vs = a @ ram1 # b @ ram2 # c\""], ["proof (state)\nthis:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs))", "then"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c", "have \"fst (splitAt ram1 vs) = a\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. fst (splitAt ram1 vs) = a", "apply (drule_tac splitAt_dist_ram1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>\n    vs = ?a2 @ ?ram1.2 # ?b2 @ ?ram2.2 # ?c2\n 2. \\<lbrakk>vs = a @ ram1 # b @ ram2 # c;\n     (?a2, ?b2 @ ?ram2.2 # ?c2) = splitAt ?ram1.2 vs\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram1 vs) = a", "by (auto dest: pairD)"], ["proof (state)\nthis:\n  fst (splitAt ram1 vs) = a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs))", "with dist vs"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n  fst (splitAt ram1 vs) = a", "have \"splitAt ram2 (fst (splitAt ram1 vs)) = (a, [])\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n  fst (splitAt ram1 vs) = a\n\ngoal (1 subgoal):\n 1. splitAt ram2 (fst (splitAt ram1 vs)) = (a, [])", "by (auto intro: splitAt_no_ram)"], ["proof (state)\nthis:\n  splitAt ram2 (fst (splitAt ram1 vs)) = (a, [])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs))", "then"], ["proof (chain)\npicking this:\n  splitAt ram2 (fst (splitAt ram1 vs)) = (a, [])", "show ?thesis"], ["proof (prove)\nusing this:\n  splitAt ram2 (fst (splitAt ram1 vs)) = (a, [])\n\ngoal (1 subgoal):\n 1. (a, []) = splitAt ram2 (fst (splitAt ram1 vs))", "by auto"], ["proof (state)\nthis:\n  (a, []) = splitAt ram2 (fst (splitAt ram1 vs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_dist_ram12: \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>  (b, c) = splitAt ram2 (snd (splitAt ram1 vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (b, c) = splitAt ram2 (snd (splitAt ram1 vs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (b, c) = splitAt ram2 (snd (splitAt ram1 vs))", "assume dist: \"distinct vs\" and vs: \"vs = a @ ram1 # b @ ram2 # c\""], ["proof (state)\nthis:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (b, c) = splitAt ram2 (snd (splitAt ram1 vs))", "then"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c", "have \"snd (splitAt ram1 vs) = b @ ram2 # c\""], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n\ngoal (1 subgoal):\n 1. snd (splitAt ram1 vs) = b @ ram2 # c", "apply (drule_tac splitAt_dist_ram1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vs = a @ ram1 # b @ ram2 # c \\<Longrightarrow>\n    vs = ?a2 @ ?ram1.2 # ?b2 @ ?ram2.2 # ?c2\n 2. \\<lbrakk>vs = a @ ram1 # b @ ram2 # c;\n     (?a2, ?b2 @ ?ram2.2 # ?c2) = splitAt ?ram1.2 vs\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt ram1 vs) = b @ ram2 # c", "by (auto dest: pairD)"], ["proof (state)\nthis:\n  snd (splitAt ram1 vs) = b @ ram2 # c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (b, c) = splitAt ram2 (snd (splitAt ram1 vs))", "with dist vs"], ["proof (chain)\npicking this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n  snd (splitAt ram1 vs) = b @ ram2 # c", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct vs\n  vs = a @ ram1 # b @ ram2 # c\n  snd (splitAt ram1 vs) = b @ ram2 # c\n\ngoal (1 subgoal):\n 1. (b, c) = splitAt ram2 (snd (splitAt ram1 vs))", "by (rule_tac splitAt_dist_ram)  auto"], ["proof (state)\nthis:\n  (b, c) = splitAt ram2 (snd (splitAt ram1 vs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_dist_ram_all:\n  \"distinct vs \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # c\n  \\<Longrightarrow> (a, b) = splitAt ram1 (fst (splitAt ram2 vs))\n  \\<and> (c, []) = splitAt ram1 (snd (splitAt ram2 vs))\n  \\<and> (a, []) = splitAt ram2 (fst (splitAt ram1 vs))\n  \\<and> (b, c) = splitAt ram2 (snd (splitAt ram1 vs))\n  \\<and>  c = snd (splitAt ram2 vs)\n  \\<and>  a = fst (splitAt ram1 vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram1 (fst (splitAt ram2 vs)) \\<and>\n                      (c, []) = splitAt ram1 (snd (splitAt ram2 vs)) \\<and>\n                      (a, []) = splitAt ram2 (fst (splitAt ram1 vs)) \\<and>\n                      (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply (rule_tac conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, b) = splitAt ram1 (fst (splitAt ram2 vs))\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (c, []) = splitAt ram1 (snd (splitAt ram2 vs)) \\<and>\n                      (a, []) = splitAt ram2 (fst (splitAt ram1 vs)) \\<and>\n                      (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply (rule_tac splitAt_dist_ram21)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> distinct vs\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # ?c1\n 3. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (c, []) = splitAt ram1 (snd (splitAt ram2 vs)) \\<and>\n                      (a, []) = splitAt ram2 (fst (splitAt ram1 vs)) \\<and>\n                      (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> vs = a @ ram1 # b @ ram2 # ?c1\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (c, []) = splitAt ram1 (snd (splitAt ram2 vs)) \\<and>\n                      (a, []) = splitAt ram2 (fst (splitAt ram1 vs)) \\<and>\n                      (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (c, []) = splitAt ram1 (snd (splitAt ram2 vs)) \\<and>\n                      (a, []) = splitAt ram2 (fst (splitAt ram1 vs)) \\<and>\n                      (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply (rule_tac conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (c, []) = splitAt ram1 (snd (splitAt ram2 vs))\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs)) \\<and>\n                      (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply (rule_tac splitAt_dist_ram22)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> distinct vs\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> vs = ?a14 @ ram1 # ?b14 @ ram2 # c\n 3. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs)) \\<and>\n                      (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> vs = ?a14 @ ram1 # ?b14 @ ram2 # c\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs)) \\<and>\n                      (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs)) \\<and>\n                      (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply (rule_tac conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (a, []) = splitAt ram2 (fst (splitAt ram1 vs))\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply (rule_tac splitAt_dist_ram11 splitAt_dist_ram22)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> distinct vs\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> vs = a @ ram1 # ?b17 @ ram2 # ?c17\n 3. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> vs = a @ ram1 # ?b17 @ ram2 # ?c17\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (b, c) = splitAt ram2 (snd (splitAt ram1 vs)) \\<and>\n                      c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply (rule_tac conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> (b, c) = splitAt ram2 (snd (splitAt ram1 vs))\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply (rule_tac splitAt_dist_ram12)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> distinct vs\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> vs = ?a20 @ ram1 # b @ ram2 # c\n 3. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> vs = ?a20 @ ram1 # b @ ram2 # c\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> c = snd (splitAt ram2 vs) \\<and>\n                      a = fst (splitAt ram1 vs)", "apply (rule_tac conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> c = snd (splitAt ram2 vs)\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> a = fst (splitAt ram1 vs)", "apply (rule_tac splitAt_dist_ram20)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> distinct vs\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> vs = ?a23 @ ?ram1.23 # ?b23 @ ram2 # c\n 3. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> a = fst (splitAt ram1 vs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> vs = ?a23 @ ?ram1.23 # ?b23 @ ram2 # c\n 2. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> a = fst (splitAt ram1 vs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; vs = a @ ram1 # b @ ram2 # c\\<rbrakk>\n    \\<Longrightarrow> a = fst (splitAt ram1 vs)", "by (rule_tac splitAt_dist_ram10) auto"], ["", "subsubsection \\<open>Mixed\\<close>"], ["", "lemma fst_splitAt_rev:\n \"distinct xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow>\n  fst(splitAt x (rev xs)) = rev(snd(splitAt x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt x (rev xs)) = rev (snd (splitAt x xs))", "by(simp add:splitAt_conv takeWhile_neq_rev)"], ["", "lemma snd_splitAt_rev:\n \"distinct xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow>\n  snd(splitAt x (rev xs)) = rev(fst(splitAt x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt x (rev xs)) = rev (fst (splitAt x xs))", "by(simp add:splitAt_conv dropWhile_neq_rev)"], ["", "lemma splitAt_take[simp]: \"distinct ls \\<Longrightarrow> i < length ls \\<Longrightarrow> fst (splitAt (ls!i) ls) = take i ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt (ls ! i) ls) = take i ls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt (ls ! i) ls) = take i ls", "assume d: \"distinct ls\" and si: \"i < length ls\""], ["proof (state)\nthis:\n  distinct ls\n  i < |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt (ls ! i) ls) = take i ls", "then"], ["proof (chain)\npicking this:\n  distinct ls\n  i < |ls|", "have ls1: \"ls = take i ls @ ls!i # drop (Suc i) ls\""], ["proof (prove)\nusing this:\n  distinct ls\n  i < |ls|\n\ngoal (1 subgoal):\n 1. ls = take i ls @ ls ! i # drop (Suc i) ls", "by (rule_tac id_take_nth_drop)"], ["proof (state)\nthis:\n  ls = take i ls @ ls ! i # drop (Suc i) ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt (ls ! i) ls) = take i ls", "from si"], ["proof (chain)\npicking this:\n  i < |ls|", "have \"ls!i \\<in> set ls\""], ["proof (prove)\nusing this:\n  i < |ls|\n\ngoal (1 subgoal):\n 1. ls ! i \\<in> set ls", "by auto"], ["proof (state)\nthis:\n  ls ! i \\<in> set ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt (ls ! i) ls) = take i ls", "then"], ["proof (chain)\npicking this:\n  ls ! i \\<in> set ls", "have ls2: \"ls = fst (splitAt (ls!i) ls) @ ls!i # snd (splitAt (ls!i) ls)\""], ["proof (prove)\nusing this:\n  ls ! i \\<in> set ls\n\ngoal (1 subgoal):\n 1. ls = fst (splitAt (ls ! i) ls) @ ls ! i # snd (splitAt (ls ! i) ls)", "by (auto dest: splitAt_ram)"], ["proof (state)\nthis:\n  ls = fst (splitAt (ls ! i) ls) @ ls ! i # snd (splitAt (ls ! i) ls)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt (ls ! i) ls) = take i ls", "from d ls2 ls1"], ["proof (chain)\npicking this:\n  distinct ls\n  ls = fst (splitAt (ls ! i) ls) @ ls ! i # snd (splitAt (ls ! i) ls)\n  ls = take i ls @ ls ! i # drop (Suc i) ls", "have \"fst (splitAt (ls!i) ls) = take i ls \\<and> snd (splitAt (ls!i) ls) = drop (Suc i) ls\""], ["proof (prove)\nusing this:\n  distinct ls\n  ls = fst (splitAt (ls ! i) ls) @ ls ! i # snd (splitAt (ls ! i) ls)\n  ls = take i ls @ ls ! i # drop (Suc i) ls\n\ngoal (1 subgoal):\n 1. fst (splitAt (ls ! i) ls) = take i ls \\<and>\n    snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "by (rule dist_at)"], ["proof (state)\nthis:\n  fst (splitAt (ls ! i) ls) = take i ls \\<and>\n  snd (splitAt (ls ! i) ls) = drop (Suc i) ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt (ls ! i) ls) = take i ls", "then"], ["proof (chain)\npicking this:\n  fst (splitAt (ls ! i) ls) = take i ls \\<and>\n  snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (splitAt (ls ! i) ls) = take i ls \\<and>\n  snd (splitAt (ls ! i) ls) = drop (Suc i) ls\n\ngoal (1 subgoal):\n 1. fst (splitAt (ls ! i) ls) = take i ls", "by auto"], ["proof (state)\nthis:\n  fst (splitAt (ls ! i) ls) = take i ls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splitAt_drop[simp]: \"distinct ls \\<Longrightarrow>  i < length ls \\<Longrightarrow> snd (splitAt (ls!i) ls) = drop (Suc i) ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "assume d: \"distinct ls\" and si: \"i < length ls\""], ["proof (state)\nthis:\n  distinct ls\n  i < |ls|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "then"], ["proof (chain)\npicking this:\n  distinct ls\n  i < |ls|", "have ls1: \"ls = take i ls @ ls!i # drop (Suc i) ls\""], ["proof (prove)\nusing this:\n  distinct ls\n  i < |ls|\n\ngoal (1 subgoal):\n 1. ls = take i ls @ ls ! i # drop (Suc i) ls", "by (rule_tac id_take_nth_drop)"], ["proof (state)\nthis:\n  ls = take i ls @ ls ! i # drop (Suc i) ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "from si"], ["proof (chain)\npicking this:\n  i < |ls|", "have \"ls!i \\<in> set ls\""], ["proof (prove)\nusing this:\n  i < |ls|\n\ngoal (1 subgoal):\n 1. ls ! i \\<in> set ls", "by auto"], ["proof (state)\nthis:\n  ls ! i \\<in> set ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "then"], ["proof (chain)\npicking this:\n  ls ! i \\<in> set ls", "have ls2: \"ls = fst (splitAt (ls!i) ls) @ ls!i # snd (splitAt (ls!i) ls)\""], ["proof (prove)\nusing this:\n  ls ! i \\<in> set ls\n\ngoal (1 subgoal):\n 1. ls = fst (splitAt (ls ! i) ls) @ ls ! i # snd (splitAt (ls ! i) ls)", "by (auto dest: splitAt_ram)"], ["proof (state)\nthis:\n  ls = fst (splitAt (ls ! i) ls) @ ls ! i # snd (splitAt (ls ! i) ls)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "from d ls2 ls1"], ["proof (chain)\npicking this:\n  distinct ls\n  ls = fst (splitAt (ls ! i) ls) @ ls ! i # snd (splitAt (ls ! i) ls)\n  ls = take i ls @ ls ! i # drop (Suc i) ls", "have \"fst (splitAt (ls!i) ls) = take i ls \\<and> snd (splitAt (ls!i) ls) = drop (Suc i) ls\""], ["proof (prove)\nusing this:\n  distinct ls\n  ls = fst (splitAt (ls ! i) ls) @ ls ! i # snd (splitAt (ls ! i) ls)\n  ls = take i ls @ ls ! i # drop (Suc i) ls\n\ngoal (1 subgoal):\n 1. fst (splitAt (ls ! i) ls) = take i ls \\<and>\n    snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "by (rule dist_at)"], ["proof (state)\nthis:\n  fst (splitAt (ls ! i) ls) = take i ls \\<and>\n  snd (splitAt (ls ! i) ls) = drop (Suc i) ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ls; i < |ls|\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "then"], ["proof (chain)\npicking this:\n  fst (splitAt (ls ! i) ls) = take i ls \\<and>\n  snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (splitAt (ls ! i) ls) = take i ls \\<and>\n  snd (splitAt (ls ! i) ls) = drop (Suc i) ls\n\ngoal (1 subgoal):\n 1. snd (splitAt (ls ! i) ls) = drop (Suc i) ls", "by auto"], ["proof (state)\nthis:\n  snd (splitAt (ls ! i) ls) = drop (Suc i) ls\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fst_splitAt_upt:\n \"j \\<le> i \\<Longrightarrow> i < k \\<Longrightarrow> fst(splitAt i [j..<k]) = [j..<i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<le> i; i < k\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt i [j..<k]) = [j..<i]", "using splitAt_take[where ls = \"[j..<k]\" and i=\"i-j\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct [j..<k]; i - j < |[j..<k]|\\<rbrakk>\n  \\<Longrightarrow> fst (splitAt ([j..<k] ! (i - j)) [j..<k]) =\n                    take (i - j) [j..<k]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<le> i; i < k\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt i [j..<k]) = [j..<i]", "apply (simp del:splitAt_take)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma snd_splitAt_upt:\n \"j \\<le> i \\<Longrightarrow> i < k \\<Longrightarrow> snd(splitAt i [j..<k]) = [i+1..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<le> i; i < k\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt i [j..<k]) = [i + 1..<k]", "using splitAt_drop[where ls = \"[j..<k]\" and i=\"i-j\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct [j..<k]; i - j < |[j..<k]|\\<rbrakk>\n  \\<Longrightarrow> snd (splitAt ([j..<k] ! (i - j)) [j..<k]) =\n                    drop (Suc (i - j)) [j..<k]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<le> i; i < k\\<rbrakk>\n    \\<Longrightarrow> snd (splitAt i [j..<k]) = [i + 1..<k]", "by simp"], ["", "lemma local_help1: \"\\<And> a vs. vs = c @ r # d \\<Longrightarrow> vs = a @ r # b \\<Longrightarrow> r \\<notin> set a \\<Longrightarrow> r \\<notin> set b \\<Longrightarrow> a = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>vs = c @ r # d; vs = a @ r # b; r \\<notin> set a;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> a = c", "proof (induct c)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a vs.\n       \\<lbrakk>vs = [] @ r # d; vs = a @ r # b; r \\<notin> set a;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> a = []\n 2. \\<And>a c aa vs.\n       \\<lbrakk>\\<And>a vs.\n                   \\<lbrakk>vs = c @ r # d; vs = a @ r # b;\n                    r \\<notin> set a; r \\<notin> set b\\<rbrakk>\n                   \\<Longrightarrow> a = c;\n        vs = (a # c) @ r # d; vs = aa @ r # b; r \\<notin> set aa;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> aa = a # c", "case Nil"], ["proof (state)\nthis:\n  vs = [] @ r # d\n  vs = a @ r # b\n  r \\<notin> set a\n  r \\<notin> set b\n\ngoal (2 subgoals):\n 1. \\<And>a vs.\n       \\<lbrakk>vs = [] @ r # d; vs = a @ r # b; r \\<notin> set a;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> a = []\n 2. \\<And>a c aa vs.\n       \\<lbrakk>\\<And>a vs.\n                   \\<lbrakk>vs = c @ r # d; vs = a @ r # b;\n                    r \\<notin> set a; r \\<notin> set b\\<rbrakk>\n                   \\<Longrightarrow> a = c;\n        vs = (a # c) @ r # d; vs = aa @ r # b; r \\<notin> set aa;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> aa = a # c", "then"], ["proof (chain)\npicking this:\n  vs = [] @ r # d\n  vs = a @ r # b\n  r \\<notin> set a\n  r \\<notin> set b", "have ra: \"r \\<notin> set a\" and vs1: \"vs = a @ r # b\" and vs2: \"vs = [] @ r # d\""], ["proof (prove)\nusing this:\n  vs = [] @ r # d\n  vs = a @ r # b\n  r \\<notin> set a\n  r \\<notin> set b\n\ngoal (1 subgoal):\n 1. r \\<notin> set a &&& vs = a @ r # b &&& vs = [] @ r # d", "by auto"], ["proof (state)\nthis:\n  r \\<notin> set a\n  vs = a @ r # b\n  vs = [] @ r # d\n\ngoal (2 subgoals):\n 1. \\<And>a vs.\n       \\<lbrakk>vs = [] @ r # d; vs = a @ r # b; r \\<notin> set a;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> a = []\n 2. \\<And>a c aa vs.\n       \\<lbrakk>\\<And>a vs.\n                   \\<lbrakk>vs = c @ r # d; vs = a @ r # b;\n                    r \\<notin> set a; r \\<notin> set b\\<rbrakk>\n                   \\<Longrightarrow> a = c;\n        vs = (a # c) @ r # d; vs = aa @ r # b; r \\<notin> set aa;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> aa = a # c", "from vs1 vs2"], ["proof (chain)\npicking this:\n  vs = a @ r # b\n  vs = [] @ r # d", "have \"a @ r # b = r # d\""], ["proof (prove)\nusing this:\n  vs = a @ r # b\n  vs = [] @ r # d\n\ngoal (1 subgoal):\n 1. a @ r # b = r # d", "by auto"], ["proof (state)\nthis:\n  a @ r # b = r # d\n\ngoal (2 subgoals):\n 1. \\<And>a vs.\n       \\<lbrakk>vs = [] @ r # d; vs = a @ r # b; r \\<notin> set a;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> a = []\n 2. \\<And>a c aa vs.\n       \\<lbrakk>\\<And>a vs.\n                   \\<lbrakk>vs = c @ r # d; vs = a @ r # b;\n                    r \\<notin> set a; r \\<notin> set b\\<rbrakk>\n                   \\<Longrightarrow> a = c;\n        vs = (a # c) @ r # d; vs = aa @ r # b; r \\<notin> set aa;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> aa = a # c", "then"], ["proof (chain)\npicking this:\n  a @ r # b = r # d", "have \"hd (a @ r # b) = r\""], ["proof (prove)\nusing this:\n  a @ r # b = r # d\n\ngoal (1 subgoal):\n 1. hd (a @ r # b) = r", "by auto"], ["proof (state)\nthis:\n  hd (a @ r # b) = r\n\ngoal (2 subgoals):\n 1. \\<And>a vs.\n       \\<lbrakk>vs = [] @ r # d; vs = a @ r # b; r \\<notin> set a;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> a = []\n 2. \\<And>a c aa vs.\n       \\<lbrakk>\\<And>a vs.\n                   \\<lbrakk>vs = c @ r # d; vs = a @ r # b;\n                    r \\<notin> set a; r \\<notin> set b\\<rbrakk>\n                   \\<Longrightarrow> a = c;\n        vs = (a # c) @ r # d; vs = aa @ r # b; r \\<notin> set aa;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> aa = a # c", "then"], ["proof (chain)\npicking this:\n  hd (a @ r # b) = r", "have \"a \\<noteq> [] \\<Longrightarrow> hd a = r\""], ["proof (prove)\nusing this:\n  hd (a @ r # b) = r\n\ngoal (1 subgoal):\n 1. a \\<noteq> [] \\<Longrightarrow> hd a = r", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> [] \\<Longrightarrow> hd a = r\n\ngoal (2 subgoals):\n 1. \\<And>a vs.\n       \\<lbrakk>vs = [] @ r # d; vs = a @ r # b; r \\<notin> set a;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> a = []\n 2. \\<And>a c aa vs.\n       \\<lbrakk>\\<And>a vs.\n                   \\<lbrakk>vs = c @ r # d; vs = a @ r # b;\n                    r \\<notin> set a; r \\<notin> set b\\<rbrakk>\n                   \\<Longrightarrow> a = c;\n        vs = (a # c) @ r # d; vs = aa @ r # b; r \\<notin> set aa;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> aa = a # c", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> [] \\<Longrightarrow> hd a = r", "have \"a \\<noteq> [] \\<Longrightarrow> r \\<in> set a\""], ["proof (prove)\nusing this:\n  a \\<noteq> [] \\<Longrightarrow> hd a = r\n\ngoal (1 subgoal):\n 1. a \\<noteq> [] \\<Longrightarrow> r \\<in> set a", "by (induct a) auto"], ["proof (state)\nthis:\n  a \\<noteq> [] \\<Longrightarrow> r \\<in> set a\n\ngoal (2 subgoals):\n 1. \\<And>a vs.\n       \\<lbrakk>vs = [] @ r # d; vs = a @ r # b; r \\<notin> set a;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> a = []\n 2. \\<And>a c aa vs.\n       \\<lbrakk>\\<And>a vs.\n                   \\<lbrakk>vs = c @ r # d; vs = a @ r # b;\n                    r \\<notin> set a; r \\<notin> set b\\<rbrakk>\n                   \\<Longrightarrow> a = c;\n        vs = (a # c) @ r # d; vs = aa @ r # b; r \\<notin> set aa;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> aa = a # c", "with ra"], ["proof (chain)\npicking this:\n  r \\<notin> set a\n  a \\<noteq> [] \\<Longrightarrow> r \\<in> set a", "have a: \"a = []\""], ["proof (prove)\nusing this:\n  r \\<notin> set a\n  a \\<noteq> [] \\<Longrightarrow> r \\<in> set a\n\ngoal (1 subgoal):\n 1. a = []", "by auto"], ["proof (state)\nthis:\n  a = []\n\ngoal (2 subgoals):\n 1. \\<And>a vs.\n       \\<lbrakk>vs = [] @ r # d; vs = a @ r # b; r \\<notin> set a;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> a = []\n 2. \\<And>a c aa vs.\n       \\<lbrakk>\\<And>a vs.\n                   \\<lbrakk>vs = c @ r # d; vs = a @ r # b;\n                    r \\<notin> set a; r \\<notin> set b\\<rbrakk>\n                   \\<Longrightarrow> a = c;\n        vs = (a # c) @ r # d; vs = aa @ r # b; r \\<notin> set aa;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> aa = a # c", "then"], ["proof (chain)\npicking this:\n  a = []", "show ?case"], ["proof (prove)\nusing this:\n  a = []\n\ngoal (1 subgoal):\n 1. a = []", "by auto"], ["proof (state)\nthis:\n  a = []\n\ngoal (1 subgoal):\n 1. \\<And>a c aa vs.\n       \\<lbrakk>\\<And>a vs.\n                   \\<lbrakk>vs = c @ r # d; vs = a @ r # b;\n                    r \\<notin> set a; r \\<notin> set b\\<rbrakk>\n                   \\<Longrightarrow> a = c;\n        vs = (a # c) @ r # d; vs = aa @ r # b; r \\<notin> set aa;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> aa = a # c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a c aa vs.\n       \\<lbrakk>\\<And>a vs.\n                   \\<lbrakk>vs = c @ r # d; vs = a @ r # b;\n                    r \\<notin> set a; r \\<notin> set b\\<rbrakk>\n                   \\<Longrightarrow> a = c;\n        vs = (a # c) @ r # d; vs = aa @ r # b; r \\<notin> set aa;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> aa = a # c", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?vs = xs @ r # d; ?vs = ?a @ r # b; r \\<notin> set ?a;\n   r \\<notin> set b\\<rbrakk>\n  \\<Longrightarrow> ?a = xs\n  vs = (x # xs) @ r # d\n  vs = a @ r # b\n  r \\<notin> set a\n  r \\<notin> set b\n\ngoal (1 subgoal):\n 1. \\<And>a c aa vs.\n       \\<lbrakk>\\<And>a vs.\n                   \\<lbrakk>vs = c @ r # d; vs = a @ r # b;\n                    r \\<notin> set a; r \\<notin> set b\\<rbrakk>\n                   \\<Longrightarrow> a = c;\n        vs = (a # c) @ r # d; vs = aa @ r # b; r \\<notin> set aa;\n        r \\<notin> set b\\<rbrakk>\n       \\<Longrightarrow> aa = a # c", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?vs = xs @ r # d; ?vs = ?a @ r # b; r \\<notin> set ?a;\n   r \\<notin> set b\\<rbrakk>\n  \\<Longrightarrow> ?a = xs\n  vs = (x # xs) @ r # d\n  vs = a @ r # b\n  r \\<notin> set a\n  r \\<notin> set b", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?vs = xs @ r # d; ?vs = ?a @ r # b; r \\<notin> set ?a;\n   r \\<notin> set b\\<rbrakk>\n  \\<Longrightarrow> ?a = xs\n  vs = (x # xs) @ r # d\n  vs = a @ r # b\n  r \\<notin> set a\n  r \\<notin> set b\n\ngoal (1 subgoal):\n 1. a = x # xs", "by (induct a) auto"], ["proof (state)\nthis:\n  a = x # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma local_help: \"vs = a @ r # b \\<Longrightarrow> vs = c @ r # d \\<Longrightarrow> r \\<notin> set a \\<Longrightarrow> r \\<notin> set b \\<Longrightarrow> a = c \\<and> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs = a @ r # b; vs = c @ r # d; r \\<notin> set a;\n     r \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs = a @ r # b; vs = c @ r # d; r \\<notin> set a;\n     r \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "assume dist: \"r \\<notin> set a\" \"r \\<notin> set b\" and vs1: \"vs = a @ r # b\" and vs2: \"vs = c @ r # d\""], ["proof (state)\nthis:\n  r \\<notin> set a\n  r \\<notin> set b\n  vs = a @ r # b\n  vs = c @ r # d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs = a @ r # b; vs = c @ r # d; r \\<notin> set a;\n     r \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "from vs2 vs1 dist"], ["proof (chain)\npicking this:\n  vs = c @ r # d\n  vs = a @ r # b\n  r \\<notin> set a\n  r \\<notin> set b", "have \"a = c\""], ["proof (prove)\nusing this:\n  vs = c @ r # d\n  vs = a @ r # b\n  r \\<notin> set a\n  r \\<notin> set b\n\ngoal (1 subgoal):\n 1. a = c", "by (rule local_help1)"], ["proof (state)\nthis:\n  a = c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vs = a @ r # b; vs = c @ r # d; r \\<notin> set a;\n     r \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "with dist vs1 vs2"], ["proof (chain)\npicking this:\n  r \\<notin> set a\n  r \\<notin> set b\n  vs = a @ r # b\n  vs = c @ r # d\n  a = c", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<notin> set a\n  r \\<notin> set b\n  vs = a @ r # b\n  vs = c @ r # d\n  a = c\n\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "by simp"], ["proof (state)\nthis:\n  a = c \\<and> b = d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma local_help': \"a @ r # b = c @ r # d \\<Longrightarrow> r \\<notin> set a \\<Longrightarrow> r \\<notin> set b \\<Longrightarrow> a = c \\<and> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a @ r # b = c @ r # d; r \\<notin> set a;\n     r \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> a = c \\<and> b = d", "by (rule local_help) auto"], ["", "lemma splitAt_simp1: \"ram \\<notin> set a \\<Longrightarrow> ram \\<notin> set b \\<Longrightarrow> fst (splitAt ram (a @ ram # b)) = a \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<notin> set a; ram \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram (a @ ram # b)) = a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<notin> set a; ram \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram (a @ ram # b)) = a", "assume ramab: \"ram \\<notin> set a\"  \"ram \\<notin> set b\""], ["proof (state)\nthis:\n  ram \\<notin> set a\n  ram \\<notin> set b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<notin> set a; ram \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram (a @ ram # b)) = a", "define vs where \"vs = a @ ram # b\""], ["proof (state)\nthis:\n  vs = a @ ram # b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<notin> set a; ram \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram (a @ ram # b)) = a", "then"], ["proof (chain)\npicking this:\n  vs = a @ ram # b", "have vs: \"vs = a @ ram # b\""], ["proof (prove)\nusing this:\n  vs = a @ ram # b\n\ngoal (1 subgoal):\n 1. vs = a @ ram # b", "by auto"], ["proof (state)\nthis:\n  vs = a @ ram # b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<notin> set a; ram \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram (a @ ram # b)) = a", "then"], ["proof (chain)\npicking this:\n  vs = a @ ram # b", "have \"ram \\<in> set vs\""], ["proof (prove)\nusing this:\n  vs = a @ ram # b\n\ngoal (1 subgoal):\n 1. ram \\<in> set vs", "by auto"], ["proof (state)\nthis:\n  ram \\<in> set vs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<notin> set a; ram \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram (a @ ram # b)) = a", "then"], ["proof (chain)\npicking this:\n  ram \\<in> set vs", "have \"vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\""], ["proof (prove)\nusing this:\n  ram \\<in> set vs\n\ngoal (1 subgoal):\n 1. vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)", "by (auto dest: splitAt_ram)"], ["proof (state)\nthis:\n  vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<notin> set a; ram \\<notin> set b\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram (a @ ram # b)) = a", "with  vs ramab"], ["proof (chain)\npicking this:\n  vs = a @ ram # b\n  ram \\<notin> set a\n  ram \\<notin> set b\n  vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)", "show ?thesis"], ["proof (prove)\nusing this:\n  vs = a @ ram # b\n  ram \\<notin> set a\n  ram \\<notin> set b\n  vs = fst (splitAt ram vs) @ ram # snd (splitAt ram vs)\n\ngoal (1 subgoal):\n 1. fst (splitAt ram (a @ ram # b)) = a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram (a @ ram # b)) = a", "apply (rule_tac sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> a = fst (splitAt ram (a @ ram # b))", "apply (rule_tac local_help1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> ?vs5 = fst (splitAt ram (a @ ram # b)) @ ?r5 # ?d5\n 2. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> ?vs5 = a @ ?r5 # ?b5\n 3. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> ?r5 \\<notin> set a\n 4. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> ?r5 \\<notin> set ?b5", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> fst (splitAt ram (a @ ram # b)) @ ?r5 # ?d5 =\n                      a @ ?r5 # ?b5\n 2. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> ?r5 \\<notin> set a\n 3. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> ?r5 \\<notin> set ?b5", "apply (rule sym)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> a @ ?r5 # ?b5 =\n                      fst (splitAt ram (a @ ram # b)) @ ?r5 # ?d5\n 2. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> ?r5 \\<notin> set a\n 3. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> ?r5 \\<notin> set ?b5", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set a\n 2. \\<lbrakk>vs = a @ ram # b; ram \\<notin> set a; ram \\<notin> set b;\n     a @ ram # b =\n     fst (splitAt ram (a @ ram # b)) @\n     ram # snd (splitAt ram (a @ ram # b))\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set b", "by auto"], ["proof (state)\nthis:\n  fst (splitAt ram (a @ ram # b)) = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma help'''_in: \"\\<And> xs. ram \\<in> set b \\<Longrightarrow> fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       ram \\<in> set b \\<Longrightarrow>\n       fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)", "proof (induct b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       ram \\<in> set [] \\<Longrightarrow>\n       fst (splitAtRec ram xs []) = xs @ fst (splitAtRec ram [] [])\n 2. \\<And>a b xs.\n       \\<lbrakk>\\<And>xs.\n                   ram \\<in> set b \\<Longrightarrow>\n                   fst (splitAtRec ram xs b) =\n                   xs @ fst (splitAtRec ram [] b);\n        ram \\<in> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAtRec ram xs (a # b)) =\n                         xs @ fst (splitAtRec ram [] (a # b))", "case Nil"], ["proof (state)\nthis:\n  ram \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       ram \\<in> set [] \\<Longrightarrow>\n       fst (splitAtRec ram xs []) = xs @ fst (splitAtRec ram [] [])\n 2. \\<And>a b xs.\n       \\<lbrakk>\\<And>xs.\n                   ram \\<in> set b \\<Longrightarrow>\n                   fst (splitAtRec ram xs b) =\n                   xs @ fst (splitAtRec ram [] b);\n        ram \\<in> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAtRec ram xs (a # b)) =\n                         xs @ fst (splitAtRec ram [] (a # b))", "then"], ["proof (chain)\npicking this:\n  ram \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  ram \\<in> set []\n\ngoal (1 subgoal):\n 1. fst (splitAtRec ram xs []) = xs @ fst (splitAtRec ram [] [])", "by auto"], ["proof (state)\nthis:\n  fst (splitAtRec ram xs []) = xs @ fst (splitAtRec ram [] [])\n\ngoal (1 subgoal):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<And>xs.\n                   ram \\<in> set b \\<Longrightarrow>\n                   fst (splitAtRec ram xs b) =\n                   xs @ fst (splitAtRec ram [] b);\n        ram \\<in> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAtRec ram xs (a # b)) =\n                         xs @ fst (splitAtRec ram [] (a # b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<And>xs.\n                   ram \\<in> set b \\<Longrightarrow>\n                   fst (splitAtRec ram xs b) =\n                   xs @ fst (splitAtRec ram [] b);\n        ram \\<in> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAtRec ram xs (a # b)) =\n                         xs @ fst (splitAtRec ram [] (a # b))", "case (Cons b bs)"], ["proof (state)\nthis:\n  ram \\<in> set bs \\<Longrightarrow>\n  fst (splitAtRec ram ?xs bs) = ?xs @ fst (splitAtRec ram [] bs)\n  ram \\<in> set (b # bs)\n\ngoal (1 subgoal):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<And>xs.\n                   ram \\<in> set b \\<Longrightarrow>\n                   fst (splitAtRec ram xs b) =\n                   xs @ fst (splitAtRec ram [] b);\n        ram \\<in> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAtRec ram xs (a # b)) =\n                         xs @ fst (splitAtRec ram [] (a # b))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (splitAtRec ram xs (b # bs)) = xs @ fst (splitAtRec ram [] (b # bs))", "using Cons(2)"], ["proof (prove)\nusing this:\n  ram \\<in> set (b # bs)\n\ngoal (1 subgoal):\n 1. fst (splitAtRec ram xs (b # bs)) = xs @ fst (splitAtRec ram [] (b # bs))", "apply (case_tac \"b = ram\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ram \\<in> set (b # bs); b = ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram xs (b # bs)) =\n                      xs @ fst (splitAtRec ram [] (b # bs))\n 2. \\<lbrakk>ram \\<in> set (b # bs); b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram xs (b # bs)) =\n                      xs @ fst (splitAtRec ram [] (b # bs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<in> set (b # bs); b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram xs (b # bs)) =\n                      xs @ fst (splitAtRec ram [] (b # bs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      xs @ fst (splitAtRec ram [b] bs)", "apply (subgoal_tac \"fst (splitAtRec ram (xs @ [b]) bs) = (xs@[b]) @ fst (splitAtRec ram [] bs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     (xs @ [b]) @ fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      xs @ fst (splitAtRec ram [b] bs)\n 2. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     xs @ b # fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> b # fst (splitAtRec ram [] bs) =\n                      fst (splitAtRec ram [b] bs)\n 2. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply (subgoal_tac \"fst (splitAtRec ram [b] bs) = [b] @ fst (splitAtRec ram [] bs)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     xs @ b # fst (splitAtRec ram [] bs);\n     fst (splitAtRec ram [b] bs) = [b] @ fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> b # fst (splitAtRec ram [] bs) =\n                      fst (splitAtRec ram [b] bs)\n 2. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     xs @ b # fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram [b] bs) =\n                      [b] @ fst (splitAtRec ram [] bs)\n 3. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     xs @ b # fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram [b] bs) =\n                      [b] @ fst (splitAtRec ram [] bs)\n 2. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply (rule Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     xs @ b # fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> ram \\<in> set bs\n 2. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply (rule Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<in> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> ram \\<in> set bs", "by force"], ["proof (state)\nthis:\n  fst (splitAtRec ram xs (b # bs)) = xs @ fst (splitAtRec ram [] (b # bs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma help'''_notin: \"\\<And> xs. ram \\<notin>  set b \\<Longrightarrow> fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       ram \\<notin> set b \\<Longrightarrow>\n       fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)", "proof (induct b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       ram \\<notin> set [] \\<Longrightarrow>\n       fst (splitAtRec ram xs []) = xs @ fst (splitAtRec ram [] [])\n 2. \\<And>a b xs.\n       \\<lbrakk>\\<And>xs.\n                   ram \\<notin> set b \\<Longrightarrow>\n                   fst (splitAtRec ram xs b) =\n                   xs @ fst (splitAtRec ram [] b);\n        ram \\<notin> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAtRec ram xs (a # b)) =\n                         xs @ fst (splitAtRec ram [] (a # b))", "case Nil"], ["proof (state)\nthis:\n  ram \\<notin> set []\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       ram \\<notin> set [] \\<Longrightarrow>\n       fst (splitAtRec ram xs []) = xs @ fst (splitAtRec ram [] [])\n 2. \\<And>a b xs.\n       \\<lbrakk>\\<And>xs.\n                   ram \\<notin> set b \\<Longrightarrow>\n                   fst (splitAtRec ram xs b) =\n                   xs @ fst (splitAtRec ram [] b);\n        ram \\<notin> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAtRec ram xs (a # b)) =\n                         xs @ fst (splitAtRec ram [] (a # b))", "then"], ["proof (chain)\npicking this:\n  ram \\<notin> set []", "show ?case"], ["proof (prove)\nusing this:\n  ram \\<notin> set []\n\ngoal (1 subgoal):\n 1. fst (splitAtRec ram xs []) = xs @ fst (splitAtRec ram [] [])", "by auto"], ["proof (state)\nthis:\n  fst (splitAtRec ram xs []) = xs @ fst (splitAtRec ram [] [])\n\ngoal (1 subgoal):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<And>xs.\n                   ram \\<notin> set b \\<Longrightarrow>\n                   fst (splitAtRec ram xs b) =\n                   xs @ fst (splitAtRec ram [] b);\n        ram \\<notin> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAtRec ram xs (a # b)) =\n                         xs @ fst (splitAtRec ram [] (a # b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<And>xs.\n                   ram \\<notin> set b \\<Longrightarrow>\n                   fst (splitAtRec ram xs b) =\n                   xs @ fst (splitAtRec ram [] b);\n        ram \\<notin> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAtRec ram xs (a # b)) =\n                         xs @ fst (splitAtRec ram [] (a # b))", "case (Cons b bs)"], ["proof (state)\nthis:\n  ram \\<notin> set bs \\<Longrightarrow>\n  fst (splitAtRec ram ?xs bs) = ?xs @ fst (splitAtRec ram [] bs)\n  ram \\<notin> set (b # bs)\n\ngoal (1 subgoal):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<And>xs.\n                   ram \\<notin> set b \\<Longrightarrow>\n                   fst (splitAtRec ram xs b) =\n                   xs @ fst (splitAtRec ram [] b);\n        ram \\<notin> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAtRec ram xs (a # b)) =\n                         xs @ fst (splitAtRec ram [] (a # b))", "then"], ["proof (chain)\npicking this:\n  ram \\<notin> set bs \\<Longrightarrow>\n  fst (splitAtRec ram ?xs bs) = ?xs @ fst (splitAtRec ram [] bs)\n  ram \\<notin> set (b # bs)", "have \"ram \\<notin> set bs\""], ["proof (prove)\nusing this:\n  ram \\<notin> set bs \\<Longrightarrow>\n  fst (splitAtRec ram ?xs bs) = ?xs @ fst (splitAtRec ram [] bs)\n  ram \\<notin> set (b # bs)\n\ngoal (1 subgoal):\n 1. ram \\<notin> set bs", "by auto"], ["proof (state)\nthis:\n  ram \\<notin> set bs\n\ngoal (1 subgoal):\n 1. \\<And>a b xs.\n       \\<lbrakk>\\<And>xs.\n                   ram \\<notin> set b \\<Longrightarrow>\n                   fst (splitAtRec ram xs b) =\n                   xs @ fst (splitAtRec ram [] b);\n        ram \\<notin> set (a # b)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAtRec ram xs (a # b)) =\n                         xs @ fst (splitAtRec ram [] (a # b))", "then"], ["proof (chain)\npicking this:\n  ram \\<notin> set bs", "show ?case"], ["proof (prove)\nusing this:\n  ram \\<notin> set bs\n\ngoal (1 subgoal):\n 1. fst (splitAtRec ram xs (b # bs)) = xs @ fst (splitAtRec ram [] (b # bs))", "apply (case_tac \"b = ram\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ram \\<notin> set bs; b = ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram xs (b # bs)) =\n                      xs @ fst (splitAtRec ram [] (b # bs))\n 2. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram xs (b # bs)) =\n                      xs @ fst (splitAtRec ram [] (b # bs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram xs (b # bs)) =\n                      xs @ fst (splitAtRec ram [] (b # bs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      xs @ fst (splitAtRec ram [b] bs)", "apply (subgoal_tac \"fst (splitAtRec ram (xs @ [b]) bs) = (xs@[b]) @ fst (splitAtRec ram [] bs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     (xs @ [b]) @ fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      xs @ fst (splitAtRec ram [b] bs)\n 2. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     xs @ b # fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> b # fst (splitAtRec ram [] bs) =\n                      fst (splitAtRec ram [b] bs)\n 2. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply (subgoal_tac \"fst (splitAtRec ram [b] bs) = [b] @ fst (splitAtRec ram [] bs)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     xs @ b # fst (splitAtRec ram [] bs);\n     fst (splitAtRec ram [b] bs) = [b] @ fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> b # fst (splitAtRec ram [] bs) =\n                      fst (splitAtRec ram [b] bs)\n 2. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     xs @ b # fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram [b] bs) =\n                      [b] @ fst (splitAtRec ram [] bs)\n 3. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     xs @ b # fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram [b] bs) =\n                      [b] @ fst (splitAtRec ram [] bs)\n 2. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply (rule Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram;\n     fst (splitAtRec ram (xs @ [b]) bs) =\n     xs @ b # fst (splitAtRec ram [] bs)\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set bs\n 2. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram (xs @ [b]) bs) =\n                      (xs @ [b]) @ fst (splitAtRec ram [] bs)", "apply (rule Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ram \\<notin> set bs; b \\<noteq> ram\\<rbrakk>\n    \\<Longrightarrow> ram \\<notin> set bs", "by simp"], ["proof (state)\nthis:\n  fst (splitAtRec ram xs (b # bs)) = xs @ fst (splitAtRec ram [] (b # bs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma help''': \"fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)", "apply (cases \"ram \\<in> set b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. ram \\<in> set b \\<Longrightarrow>\n    fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)\n 2. ram \\<notin> set b \\<Longrightarrow>\n    fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)", "apply (rule_tac help'''_in)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ram \\<in> set b \\<Longrightarrow> ram \\<in> set b\n 2. ram \\<notin> set b \\<Longrightarrow>\n    fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ram \\<notin> set b \\<Longrightarrow>\n    fst (splitAtRec ram xs b) = xs @ fst (splitAtRec ram [] b)", "apply (rule_tac help'''_notin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ram \\<notin> set b \\<Longrightarrow> ram \\<notin> set b", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma splitAt_simpA[simp]: \"fst (splitAt ram (ram # b)) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (splitAt ram (ram # b)) = []", "by (simp add: splitAt_def)"], ["", "lemma splitAt_simpB[simp]: \"ram \\<noteq> a \\<Longrightarrow> fst (splitAt ram (a # b)) = a # fst (splitAt ram b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ram \\<noteq> a \\<Longrightarrow>\n    fst (splitAt ram (a # b)) = a # fst (splitAt ram b)", "apply (simp add: splitAt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ram \\<noteq> a \\<Longrightarrow>\n    fst (splitAtRec ram [a] b) = a # fst (splitAtRec ram [] b)", "apply (subgoal_tac \"fst (splitAtRec ram [a] b) = [a] @ fst (splitAtRec ram [] b)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ram \\<noteq> a;\n     fst (splitAtRec ram [a] b) = [a] @ fst (splitAtRec ram [] b)\\<rbrakk>\n    \\<Longrightarrow> fst (splitAtRec ram [a] b) =\n                      a # fst (splitAtRec ram [] b)\n 2. ram \\<noteq> a \\<Longrightarrow>\n    fst (splitAtRec ram [a] b) = [a] @ fst (splitAtRec ram [] b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ram \\<noteq> a \\<Longrightarrow>\n    fst (splitAtRec ram [a] b) = [a] @ fst (splitAtRec ram [] b)", "by (rule help''')"], ["", "lemma splitAt_simpB'[simp]: \"a \\<noteq> ram \\<Longrightarrow> fst (splitAt ram (a # b)) = a # fst (splitAt ram b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> ram \\<Longrightarrow>\n    fst (splitAt ram (a # b)) = a # fst (splitAt ram b)", "apply (rule splitAt_simpB)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> ram \\<Longrightarrow> ram \\<noteq> a", "by auto"], ["", "lemma splitAt_simpC[simp]: \"ram \\<notin> set a  \\<Longrightarrow> fst (splitAt ram (a @ b)) = a @ fst (splitAt ram b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ram \\<notin> set a \\<Longrightarrow>\n    fst (splitAt ram (a @ b)) = a @ fst (splitAt ram b)", "apply (induct a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ram \\<notin> set [] \\<Longrightarrow>\n    fst (splitAt ram ([] @ b)) = [] @ fst (splitAt ram b)\n 2. \\<And>a1 a2.\n       \\<lbrakk>ram \\<notin> set a2 \\<Longrightarrow>\n                fst (splitAt ram (a2 @ b)) = a2 @ fst (splitAt ram b);\n        ram \\<notin> set (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> fst (splitAt ram ((a1 # a2) @ b)) =\n                         (a1 # a2) @ fst (splitAt ram b)", "by auto"], ["", "lemma help'''': \"\\<And> xs ys. snd (splitAtRec ram xs b) = snd (splitAtRec ram ys b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs ys. snd (splitAtRec ram xs b) = snd (splitAtRec ram ys b)", "apply (induct b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs ys. snd (splitAtRec ram xs []) = snd (splitAtRec ram ys [])\n 2. \\<And>a b xs ys.\n       (\\<And>xs ys.\n           snd (splitAtRec ram xs b) =\n           snd (splitAtRec ram ys b)) \\<Longrightarrow>\n       snd (splitAtRec ram xs (a # b)) = snd (splitAtRec ram ys (a # b))", "by auto"], ["", "lemma splitAt_simpD[simp]: \"\\<And> a. ram \\<noteq> a \\<Longrightarrow> snd (splitAt ram (a # b)) = snd (splitAt ram b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ram \\<noteq> a \\<Longrightarrow>\n       snd (splitAt ram (a # b)) = snd (splitAt ram b)", "apply (simp add: splitAt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ram \\<noteq> a \\<Longrightarrow>\n       snd (splitAtRec ram [a] b) = snd (splitAtRec ram [] b)", "by (rule help'''')"], ["", "lemma splitAt_simpD'[simp]: \"\\<And> a. a \\<noteq> ram \\<Longrightarrow> snd (splitAt ram (a # b)) = snd (splitAt ram b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<noteq> ram \\<Longrightarrow>\n       snd (splitAt ram (a # b)) = snd (splitAt ram b)", "apply (rule splitAt_simpD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<noteq> ram \\<Longrightarrow> ram \\<noteq> a", "by auto"], ["", "lemma splitAt_simpE[simp]: \"snd (splitAt ram (ram # b)) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (splitAt ram (ram # b)) = b", "by (simp add: splitAt_def)"], ["", "lemma splitAt_simpF[simp]: \"ram \\<notin> set a  \\<Longrightarrow> snd (splitAt ram (a @ b)) = snd (splitAt ram b) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ram \\<notin> set a \\<Longrightarrow>\n    snd (splitAt ram (a @ b)) = snd (splitAt ram b)", "apply (induct a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ram \\<notin> set [] \\<Longrightarrow>\n    snd (splitAt ram ([] @ b)) = snd (splitAt ram b)\n 2. \\<And>a1 a2.\n       \\<lbrakk>ram \\<notin> set a2 \\<Longrightarrow>\n                snd (splitAt ram (a2 @ b)) = snd (splitAt ram b);\n        ram \\<notin> set (a1 # a2)\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt ram ((a1 # a2) @ b)) =\n                         snd (splitAt ram b)", "by auto"], ["", "lemma splitAt_rotate_pair_conv:\n  \"\\<And>xs. \\<lbrakk> distinct xs; x \\<in> set xs \\<rbrakk>\n  \\<Longrightarrow> snd (splitAt x (rotate n xs)) @ fst (splitAt x (rotate n xs)) =\n      snd (splitAt x xs) @ fst (splitAt x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (rotate n xs)) @\n                         fst (splitAt x (rotate n xs)) =\n                         snd (splitAt x xs) @ fst (splitAt x xs)", "apply(induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (rotate 0 xs)) @\n                         fst (splitAt x (rotate 0 xs)) =\n                         snd (splitAt x xs) @ fst (splitAt x xs)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> snd (splitAt x (rotate n xs)) @\n                                     fst (splitAt x (rotate n xs)) =\n                                     snd (splitAt x xs) @\n                                     fst (splitAt x xs);\n        distinct xs; x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (rotate (Suc n) xs)) @\n                         fst (splitAt x (rotate (Suc n) xs)) =\n                         snd (splitAt x xs) @ fst (splitAt x xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> snd (splitAt x (rotate n xs)) @\n                                     fst (splitAt x (rotate n xs)) =\n                                     snd (splitAt x xs) @\n                                     fst (splitAt x xs);\n        distinct xs; x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (rotate (Suc n) xs)) @\n                         fst (splitAt x (rotate (Suc n) xs)) =\n                         snd (splitAt x xs) @ fst (splitAt x xs)", "apply(simp del:rotate_Suc2 add:rotate1_rotate_swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> snd (splitAt x (rotate n xs)) @\n                                     fst (splitAt x (rotate n xs)) =\n                                     snd (splitAt x xs) @\n                                     fst (splitAt x xs);\n        distinct xs; x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (rotate1 xs)) @\n                         fst (splitAt x (rotate1 xs)) =\n                         snd (splitAt x xs) @ fst (splitAt x xs)", "apply(case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> snd (splitAt x (rotate n xs)) @\n                                     fst (splitAt x (rotate n xs)) =\n                                     snd (splitAt x xs) @\n                                     fst (splitAt x xs);\n        distinct xs; x \\<in> set xs; xs = []\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (rotate1 xs)) @\n                         fst (splitAt x (rotate1 xs)) =\n                         snd (splitAt x xs) @ fst (splitAt x xs)\n 2. \\<And>n xs a list.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> snd (splitAt x (rotate n xs)) @\n                                     fst (splitAt x (rotate n xs)) =\n                                     snd (splitAt x xs) @\n                                     fst (splitAt x xs);\n        distinct xs; x \\<in> set xs; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (rotate1 xs)) @\n                         fst (splitAt x (rotate1 xs)) =\n                         snd (splitAt x xs) @ fst (splitAt x xs)", "apply clarsimp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a list.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> snd (splitAt x (rotate n xs)) @\n                                     fst (splitAt x (rotate n xs)) =\n                                     snd (splitAt x xs) @\n                                     fst (splitAt x xs);\n        x = a \\<or> x \\<in> set list; a \\<notin> set list;\n        distinct list\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (list @ [a])) @\n                         fst (splitAt x (list @ [a])) =\n                         snd (splitAt x (a # list)) @\n                         fst (splitAt x (a # list))", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a list.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> snd (splitAt x (rotate n xs)) @\n                                     fst (splitAt x (rotate n xs)) =\n                                     snd (splitAt x xs) @\n                                     fst (splitAt x xs);\n        a \\<notin> set list; distinct list; x = a\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (list @ [a])) @\n                         fst (splitAt x (list @ [a])) =\n                         snd (splitAt x (a # list)) @\n                         fst (splitAt x (a # list))\n 2. \\<And>n a list.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> snd (splitAt x (rotate n xs)) @\n                                     fst (splitAt x (rotate n xs)) =\n                                     snd (splitAt x xs) @\n                                     fst (splitAt x xs);\n        a \\<notin> set list; distinct list; x \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (list @ [a])) @\n                         fst (splitAt x (list @ [a])) =\n                         snd (splitAt x (a # list)) @\n                         fst (splitAt x (a # list))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a list.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> snd (splitAt x (rotate n xs)) @\n                                     fst (splitAt x (rotate n xs)) =\n                                     snd (splitAt x xs) @\n                                     fst (splitAt x xs);\n        a \\<notin> set list; distinct list; x \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (list @ [a])) @\n                         fst (splitAt x (list @ [a])) =\n                         snd (splitAt x (a # list)) @\n                         fst (splitAt x (a # list))", "apply(drule split_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a list.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> snd (splitAt x (rotate n xs)) @\n                                     fst (splitAt x (rotate n xs)) =\n                                     snd (splitAt x xs) @\n                                     fst (splitAt x xs);\n        a \\<notin> set list; distinct list;\n        \\<exists>ys zs. list = ys @ x # zs\\<rbrakk>\n       \\<Longrightarrow> snd (splitAt x (list @ [a])) @\n                         fst (splitAt x (list @ [a])) =\n                         snd (splitAt x (a # list)) @\n                         fst (splitAt x (a # list))", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>\\<open>between\\<close>\\<close>"], ["", "definition between :: \"'a list \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a list\" where\n \"between vs ram\\<^sub>1 ram\\<^sub>2 \\<equiv>\n     let (pre\\<^sub>1, post\\<^sub>1) = splitAt ram\\<^sub>1 vs in\n     if ram\\<^sub>2 \\<in> set post\\<^sub>1\n     then let (pre\\<^sub>2, post\\<^sub>2) = splitAt ram\\<^sub>2 post\\<^sub>1 in pre\\<^sub>2\n     else let (pre\\<^sub>2, post\\<^sub>2) = splitAt ram\\<^sub>2 pre\\<^sub>1 in post\\<^sub>1 @ pre\\<^sub>2\""], ["", "lemma inbetween_inset:\n \"x \\<in> set(between xs a b) \\<Longrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (between xs a b) \\<Longrightarrow> x \\<in> set xs", "apply(simp add:between_def split_def split:if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<in> set (snd (splitAt a xs));\n     x \\<in> set (fst (splitAt b (snd (splitAt a xs))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set xs\n 2. \\<lbrakk>b \\<notin> set (snd (splitAt a xs));\n     x \\<in> set (snd (splitAt a xs)) \\<or>\n     x \\<in> set (fst (splitAt b (fst (splitAt a xs))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set xs", "apply(blast dest:splitAt_in_snd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<notin> set (snd (splitAt a xs));\n     x \\<in> set (snd (splitAt a xs)) \\<or>\n     x \\<in> set (fst (splitAt b (fst (splitAt a xs))))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set xs", "apply(blast dest:splitAt_in_snd)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma notinset_notinbetween:\n \"x \\<notin> set xs \\<Longrightarrow> x \\<notin> set(between xs a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> x \\<notin> set (between xs a b)", "by(blast dest:inbetween_inset)"], ["", "lemma set_between_id:\n \"distinct xs \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow>\n  set(between xs x x) = set xs - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> set (between xs x x) = set xs - {x}", "apply(drule split_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; \\<exists>ys zs. xs = ys @ x # zs\\<rbrakk>\n    \\<Longrightarrow> set (between xs x x) = set xs - {x}", "apply (clarsimp simp:between_def split_def Un_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma split_between:\n \"\\<lbrakk> distinct vs; r \\<in> set vs; v \\<in> set vs; u \\<in> set(between vs r v) \\<rbrakk> \\<Longrightarrow>\n  between vs r v =\n (if r=u then [] else between vs r u @ [u]) @ between vs u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v)\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v", "apply(cases  \"r = v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r = v\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v\n 2. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v", "apply(clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; v \\<in> set vs; u \\<in> set (between vs v v);\n     r = v; v \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> between vs v v = between vs v u @ u # between vs u v\n 2. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v", "apply(frule split_list[of v])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct vs; v \\<in> set vs; u \\<in> set (between vs v v);\n     r = v; v \\<noteq> u; \\<exists>ys zs. vs = ys @ v # zs\\<rbrakk>\n    \\<Longrightarrow> between vs v v = between vs v u @ u # between vs u v\n 2. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v", "apply(clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>u \\<in> set (between (ys @ v # zs) v v); r = v;\n        v \\<noteq> u; vs = ys @ v # zs; distinct ys; v \\<notin> set zs;\n        distinct zs; v \\<notin> set ys; set ys \\<inter> set zs = {}\\<rbrakk>\n       \\<Longrightarrow> between (ys @ v # zs) v v =\n                         between (ys @ v # zs) v u @\n                         u # between (ys @ v # zs) u v\n 2. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v", "apply(simp add:between_def split_def split:if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>u \\<in> set zs \\<or> u \\<in> set ys; r = v; v \\<noteq> u;\n        vs = ys @ v # zs; distinct ys; v \\<notin> set zs; distinct zs;\n        v \\<notin> set ys; set ys \\<inter> set zs = {}\\<rbrakk>\n       \\<Longrightarrow> (v \\<in> set (snd\n  (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs)))))) \\<and>\n                         (v \\<notin> set\n(snd (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v\n                                 (fst (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v (fst (splitAt u (ys @ v # zs))))))\n 2. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v", "apply(erule disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>r = v; v \\<noteq> u; vs = ys @ v # zs; distinct ys;\n        v \\<notin> set zs; distinct zs; v \\<notin> set ys;\n        set ys \\<inter> set zs = {}; u \\<in> set zs\\<rbrakk>\n       \\<Longrightarrow> (v \\<in> set (snd\n  (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs)))))) \\<and>\n                         (v \\<notin> set\n(snd (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v\n                                 (fst (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v (fst (splitAt u (ys @ v # zs))))))\n 2. \\<And>ys zs.\n       \\<lbrakk>r = v; v \\<noteq> u; vs = ys @ v # zs; distinct ys;\n        v \\<notin> set zs; distinct zs; v \\<notin> set ys;\n        set ys \\<inter> set zs = {}; u \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> (v \\<in> set (snd\n  (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs)))))) \\<and>\n                         (v \\<notin> set\n(snd (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v\n                                 (fst (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v (fst (splitAt u (ys @ v # zs))))))\n 3. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v", "apply(frule split_list[of u])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>r = v; v \\<noteq> u; vs = ys @ v # zs; distinct ys;\n        v \\<notin> set zs; distinct zs; v \\<notin> set ys;\n        set ys \\<inter> set zs = {}; u \\<in> set zs;\n        \\<exists>ys zsa. zs = ys @ u # zsa\\<rbrakk>\n       \\<Longrightarrow> (v \\<in> set (snd\n  (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs)))))) \\<and>\n                         (v \\<notin> set\n(snd (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v\n                                 (fst (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v (fst (splitAt u (ys @ v # zs))))))\n 2. \\<And>ys zs.\n       \\<lbrakk>r = v; v \\<noteq> u; vs = ys @ v # zs; distinct ys;\n        v \\<notin> set zs; distinct zs; v \\<notin> set ys;\n        set ys \\<inter> set zs = {}; u \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> (v \\<in> set (snd\n  (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs)))))) \\<and>\n                         (v \\<notin> set\n(snd (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v\n                                 (fst (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v (fst (splitAt u (ys @ v # zs))))))\n 3. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v", "apply(clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>r = v; v \\<noteq> u; vs = ys @ v # zs; distinct ys;\n        v \\<notin> set zs; distinct zs; v \\<notin> set ys;\n        set ys \\<inter> set zs = {}; u \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> (v \\<in> set (snd\n  (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs)))))) \\<and>\n                         (v \\<notin> set\n(snd (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v\n                                 (fst (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v (fst (splitAt u (ys @ v # zs))))))\n 2. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v", "apply(frule split_list[of u])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>r = v; v \\<noteq> u; vs = ys @ v # zs; distinct ys;\n        v \\<notin> set zs; distinct zs; v \\<notin> set ys;\n        set ys \\<inter> set zs = {}; u \\<in> set ys;\n        \\<exists>ysa zs. ys = ysa @ u # zs\\<rbrakk>\n       \\<Longrightarrow> (v \\<in> set (snd\n  (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           fst (splitAt v\n                                 (snd (splitAt u (ys @ v # zs)))))) \\<and>\n                         (v \\<notin> set\n(snd (splitAt u (ys @ v # zs))) \\<longrightarrow>\n                          (u \\<in> set zs \\<longrightarrow>\n                           zs @ ys =\n                           fst (splitAt u zs) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v\n                                 (fst (splitAt u (ys @ v # zs))))) \\<and>\n                          (u \\<notin> set zs \\<longrightarrow>\n                           ys =\n                           fst (splitAt u ys) @\n                           u #\n                           snd (splitAt u (ys @ v # zs)) @\n                           fst (splitAt v (fst (splitAt u (ys @ v # zs))))))\n 2. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> between vs r v =\n                      (if r = u then [] else between vs r u @ [u]) @\n                      between vs u v", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v; r \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> between vs r v = between vs r u @ u # between vs u v", "apply(frule split_list[of r])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct vs; r \\<in> set vs; v \\<in> set vs;\n     u \\<in> set (between vs r v); r \\<noteq> v; r \\<noteq> u;\n     \\<exists>ys zs. vs = ys @ r # zs\\<rbrakk>\n    \\<Longrightarrow> between vs r v = between vs r u @ u # between vs u v", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>v \\<in> set ys \\<or> v \\<in> set zs;\n        u \\<in> set (between (ys @ r # zs) r v); r \\<noteq> v; r \\<noteq> u;\n        vs = ys @ r # zs; distinct ys; r \\<notin> set zs; distinct zs;\n        r \\<notin> set ys; set ys \\<inter> set zs = {}\\<rbrakk>\n       \\<Longrightarrow> between (ys @ r # zs) r v =\n                         between (ys @ r # zs) r u @\n                         u # between (ys @ r # zs) u v", "apply(rename_tac as bs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       \\<lbrakk>v \\<in> set as \\<or> v \\<in> set bs;\n        u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v; r \\<noteq> u;\n        vs = as @ r # bs; distinct as; r \\<notin> set bs; distinct bs;\n        r \\<notin> set as; set as \\<inter> set bs = {}\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v\n 2. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(frule split_list[of v])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set as; \\<exists>ys zs. as = ys @ v # zs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v\n 2. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs ys zs.\n       \\<lbrakk>u \\<in> set (between (ys @ v # zs @ r # bs) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = ys @ v # zs @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct ys; r \\<notin> set ys;\n        r \\<notin> set zs; v \\<notin> set bs;\n        (set ys \\<union> set zs) \\<inter> set bs = {}; v \\<notin> set zs;\n        distinct zs; v \\<notin> set ys; set ys \\<inter> set zs = {}\\<rbrakk>\n       \\<Longrightarrow> between (ys @ v # zs @ r # bs) r v =\n                         between (ys @ v # zs @ r # bs) r u @\n                         u # between (ys @ v # zs @ r # bs) u v\n 2. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(rename_tac cs ds)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs cs ds.\n       \\<lbrakk>u \\<in> set (between (cs @ v # ds @ r # bs) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {}\\<rbrakk>\n       \\<Longrightarrow> between (cs @ v # ds @ r # bs) r v =\n                         between (cs @ v # ds @ r # bs) r u @\n                         u # between (cs @ v # ds @ r # bs) u v\n 2. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(subgoal_tac \"between (cs @ v # ds @ r # bs) r v = bs @ cs\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>bs cs ds.\n       \\<lbrakk>u \\<in> set (between (cs @ v # ds @ r # bs) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (cs @ v # ds @ r # bs) r v = bs @ cs\\<rbrakk>\n       \\<Longrightarrow> between (cs @ v # ds @ r # bs) r v =\n                         between (cs @ v # ds @ r # bs) r u @\n                         u # between (cs @ v # ds @ r # bs) u v\n 2. \\<And>bs cs ds.\n       \\<lbrakk>u \\<in> set (between (cs @ v # ds @ r # bs) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {}\\<rbrakk>\n       \\<Longrightarrow> between (cs @ v # ds @ r # bs) r v = bs @ cs\n 3. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>bs cs ds.\n       \\<lbrakk>u \\<in> set (between (cs @ v # ds @ r # bs) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {}\\<rbrakk>\n       \\<Longrightarrow> between (cs @ v # ds @ r # bs) r v = bs @ cs\n 2. \\<And>bs cs ds.\n       \\<lbrakk>u \\<in> set (between (cs @ v # ds @ r # bs) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (cs @ v # ds @ r # bs) r v = bs @ cs\\<rbrakk>\n       \\<Longrightarrow> between (cs @ v # ds @ r # bs) r v =\n                         between (cs @ v # ds @ r # bs) r u @\n                         u # between (cs @ v # ds @ r # bs) u v\n 3. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(simp add:between_def split_def split:if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs cs ds.\n       \\<lbrakk>u \\<in> set (between (cs @ v # ds @ r # bs) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (cs @ v # ds @ r # bs) r v = bs @ cs\\<rbrakk>\n       \\<Longrightarrow> between (cs @ v # ds @ r # bs) r v =\n                         between (cs @ v # ds @ r # bs) r u @\n                         u # between (cs @ v # ds @ r # bs) u v\n 2. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs cs ds.\n       \\<lbrakk>u \\<in> set bs \\<or> u \\<in> set cs; r \\<noteq> v;\n        r \\<noteq> u; vs = cs @ v # ds @ r # bs; r \\<notin> set bs;\n        distinct bs; distinct cs; r \\<notin> set cs; r \\<notin> set ds;\n        v \\<notin> set bs; (set cs \\<union> set ds) \\<inter> set bs = {};\n        v \\<notin> set ds; distinct ds; v \\<notin> set cs;\n        set cs \\<inter> set ds = {};\n        between (cs @ v # ds @ r # bs) r v = bs @ cs\\<rbrakk>\n       \\<Longrightarrow> bs @ cs =\n                         between (cs @ v # ds @ r # bs) r u @\n                         u # between (cs @ v # ds @ r # bs) u v\n 2. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(erule disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>bs cs ds.\n       \\<lbrakk>r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (cs @ v # ds @ r # bs) r v = bs @ cs;\n        u \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> bs @ cs =\n                         between (cs @ v # ds @ r # bs) r u @\n                         u # between (cs @ v # ds @ r # bs) u v\n 2. \\<And>bs cs ds.\n       \\<lbrakk>r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (cs @ v # ds @ r # bs) r v = bs @ cs;\n        u \\<in> set cs\\<rbrakk>\n       \\<Longrightarrow> bs @ cs =\n                         between (cs @ v # ds @ r # bs) r u @\n                         u # between (cs @ v # ds @ r # bs) u v\n 3. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(frule split_list[of u])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>bs cs ds.\n       \\<lbrakk>r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (cs @ v # ds @ r # bs) r v = bs @ cs; u \\<in> set bs;\n        \\<exists>ys zs. bs = ys @ u # zs\\<rbrakk>\n       \\<Longrightarrow> bs @ cs =\n                         between (cs @ v # ds @ r # bs) r u @\n                         u # between (cs @ v # ds @ r # bs) u v\n 2. \\<And>bs cs ds.\n       \\<lbrakk>r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (cs @ v # ds @ r # bs) r v = bs @ cs;\n        u \\<in> set cs\\<rbrakk>\n       \\<Longrightarrow> bs @ cs =\n                         between (cs @ v # ds @ r # bs) r u @\n                         u # between (cs @ v # ds @ r # bs) u v\n 3. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(clarsimp simp:between_def split_def split:if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs cs ds.\n       \\<lbrakk>r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (cs @ v # ds @ r # bs) r v = bs @ cs;\n        u \\<in> set cs\\<rbrakk>\n       \\<Longrightarrow> bs @ cs =\n                         between (cs @ v # ds @ r # bs) r u @\n                         u # between (cs @ v # ds @ r # bs) u v\n 2. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(frule split_list[of u])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs cs ds.\n       \\<lbrakk>r \\<noteq> v; r \\<noteq> u; vs = cs @ v # ds @ r # bs;\n        r \\<notin> set bs; distinct bs; distinct cs; r \\<notin> set cs;\n        r \\<notin> set ds; v \\<notin> set bs;\n        (set cs \\<union> set ds) \\<inter> set bs = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (cs @ v # ds @ r # bs) r v = bs @ cs; u \\<in> set cs;\n        \\<exists>ys zs. cs = ys @ u # zs\\<rbrakk>\n       \\<Longrightarrow> bs @ cs =\n                         between (cs @ v # ds @ r # bs) r u @\n                         u # between (cs @ v # ds @ r # bs) u v\n 2. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(clarsimp simp:between_def split_def split:if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(frule split_list[of v])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as bs.\n       \\<lbrakk>u \\<in> set (between (as @ r # bs) r v); r \\<noteq> v;\n        r \\<noteq> u; vs = as @ r # bs; distinct as; r \\<notin> set bs;\n        distinct bs; r \\<notin> set as; set as \\<inter> set bs = {};\n        v \\<in> set bs; \\<exists>ys zs. bs = ys @ v # zs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # bs) r v =\n                         between (as @ r # bs) r u @\n                         u # between (as @ r # bs) u v", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as ys zs.\n       \\<lbrakk>u \\<in> set (between (as @ r # ys @ v # zs) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = as @ r # ys @ v # zs; distinct as;\n        r \\<notin> set as; r \\<notin> set ys; r \\<notin> set zs;\n        distinct ys; v \\<notin> set as;\n        set as \\<inter> (set ys \\<union> set zs) = {}; v \\<notin> set zs;\n        distinct zs; v \\<notin> set ys; set ys \\<inter> set zs = {}\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # ys @ v # zs) r v =\n                         between (as @ r # ys @ v # zs) r u @\n                         u # between (as @ r # ys @ v # zs) u v", "apply(rename_tac cs ds)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as cs ds.\n       \\<lbrakk>u \\<in> set (between (as @ r # cs @ v # ds) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = as @ r # cs @ v # ds; distinct as;\n        r \\<notin> set as; r \\<notin> set cs; r \\<notin> set ds;\n        distinct cs; v \\<notin> set as;\n        set as \\<inter> (set cs \\<union> set ds) = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {}\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # cs @ v # ds) r v =\n                         between (as @ r # cs @ v # ds) r u @\n                         u # between (as @ r # cs @ v # ds) u v", "apply(subgoal_tac \"between (as @ r # cs @ v # ds) r v = cs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as cs ds.\n       \\<lbrakk>u \\<in> set (between (as @ r # cs @ v # ds) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = as @ r # cs @ v # ds; distinct as;\n        r \\<notin> set as; r \\<notin> set cs; r \\<notin> set ds;\n        distinct cs; v \\<notin> set as;\n        set as \\<inter> (set cs \\<union> set ds) = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (as @ r # cs @ v # ds) r v = cs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # cs @ v # ds) r v =\n                         between (as @ r # cs @ v # ds) r u @\n                         u # between (as @ r # cs @ v # ds) u v\n 2. \\<And>as cs ds.\n       \\<lbrakk>u \\<in> set (between (as @ r # cs @ v # ds) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = as @ r # cs @ v # ds; distinct as;\n        r \\<notin> set as; r \\<notin> set cs; r \\<notin> set ds;\n        distinct cs; v \\<notin> set as;\n        set as \\<inter> (set cs \\<union> set ds) = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {}\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # cs @ v # ds) r v = cs", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as cs ds.\n       \\<lbrakk>u \\<in> set (between (as @ r # cs @ v # ds) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = as @ r # cs @ v # ds; distinct as;\n        r \\<notin> set as; r \\<notin> set cs; r \\<notin> set ds;\n        distinct cs; v \\<notin> set as;\n        set as \\<inter> (set cs \\<union> set ds) = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {}\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # cs @ v # ds) r v = cs\n 2. \\<And>as cs ds.\n       \\<lbrakk>u \\<in> set (between (as @ r # cs @ v # ds) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = as @ r # cs @ v # ds; distinct as;\n        r \\<notin> set as; r \\<notin> set cs; r \\<notin> set ds;\n        distinct cs; v \\<notin> set as;\n        set as \\<inter> (set cs \\<union> set ds) = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (as @ r # cs @ v # ds) r v = cs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # cs @ v # ds) r v =\n                         between (as @ r # cs @ v # ds) r u @\n                         u # between (as @ r # cs @ v # ds) u v", "apply(simp add:between_def split_def split:if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as cs ds.\n       \\<lbrakk>u \\<in> set (between (as @ r # cs @ v # ds) r v);\n        r \\<noteq> v; r \\<noteq> u; vs = as @ r # cs @ v # ds; distinct as;\n        r \\<notin> set as; r \\<notin> set cs; r \\<notin> set ds;\n        distinct cs; v \\<notin> set as;\n        set as \\<inter> (set cs \\<union> set ds) = {}; v \\<notin> set ds;\n        distinct ds; v \\<notin> set cs; set cs \\<inter> set ds = {};\n        between (as @ r # cs @ v # ds) r v = cs\\<rbrakk>\n       \\<Longrightarrow> between (as @ r # cs @ v # ds) r v =\n                         between (as @ r # cs @ v # ds) r u @\n                         u # between (as @ r # cs @ v # ds) u v", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as cs ds.\n       \\<lbrakk>u \\<in> set cs; r \\<noteq> v; r \\<noteq> u;\n        vs = as @ r # cs @ v # ds; distinct as; r \\<notin> set as;\n        r \\<notin> set cs; r \\<notin> set ds; distinct cs;\n        v \\<notin> set as; set as \\<inter> (set cs \\<union> set ds) = {};\n        v \\<notin> set ds; distinct ds; v \\<notin> set cs;\n        set cs \\<inter> set ds = {};\n        between (as @ r # cs @ v # ds) r v = cs\\<rbrakk>\n       \\<Longrightarrow> cs =\n                         between (as @ r # cs @ v # ds) r u @\n                         u # between (as @ r # cs @ v # ds) u v", "apply(frule split_list[of u])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as cs ds.\n       \\<lbrakk>u \\<in> set cs; r \\<noteq> v; r \\<noteq> u;\n        vs = as @ r # cs @ v # ds; distinct as; r \\<notin> set as;\n        r \\<notin> set cs; r \\<notin> set ds; distinct cs;\n        v \\<notin> set as; set as \\<inter> (set cs \\<union> set ds) = {};\n        v \\<notin> set ds; distinct ds; v \\<notin> set cs;\n        set cs \\<inter> set ds = {};\n        between (as @ r # cs @ v # ds) r v = cs;\n        \\<exists>ys zs. cs = ys @ u # zs\\<rbrakk>\n       \\<Longrightarrow> cs =\n                         between (as @ r # cs @ v # ds) r u @\n                         u # between (as @ r # cs @ v # ds) u v", "apply(clarsimp simp:between_def split_def split:if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Tables\\<close>"], ["", "type_synonym ('a, 'b) table = \"('a \\<times> 'b) list\""], ["", "definition isTable :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'b) table \\<Rightarrow> bool\" where\n  \"isTable f vs t \\<equiv> \\<forall>p. p \\<in> set t \\<longrightarrow> snd p = f (fst p) \\<and> fst p \\<in> set vs\""], ["", "lemma isTable_eq: \"isTable E vs ((a,b)#ps) \\<Longrightarrow> b = E a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isTable E vs ((a, b) # ps) \\<Longrightarrow> b = E a", "by (auto simp add: isTable_def)"], ["", "lemma isTable_subset: \n  \"set qs \\<subseteq> set ps \\<Longrightarrow> isTable E vs ps \\<Longrightarrow> isTable E vs qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set qs \\<subseteq> set ps; isTable E vs ps\\<rbrakk>\n    \\<Longrightarrow> isTable E vs qs", "by (unfold isTable_def) auto"], ["", "lemma isTable_Cons: \"isTable E vs ((a,b)#ps) \\<Longrightarrow> isTable E vs ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isTable E vs ((a, b) # ps) \\<Longrightarrow> isTable E vs ps", "by (unfold isTable_def) auto"], ["", "definition removeKey :: \"'a \\<Rightarrow> ('a \\<times> 'b) list \\<Rightarrow> ('a \\<times> 'b) list\" where\n\"removeKey a ps \\<equiv> [p \\<leftarrow> ps. a \\<noteq> fst p]\""], ["", "primrec removeKeyList :: \"'a list \\<Rightarrow> ('a \\<times> 'b) list \\<Rightarrow> ('a \\<times> 'b) list\" where\n  \"removeKeyList [] ps = ps\"\n| \"removeKeyList (w#ws) ps = removeKey w (removeKeyList ws ps)\""], ["", "lemma removeKey_subset[simp]: \"set (removeKey a ps) \\<subseteq> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (removeKey a ps) \\<subseteq> set ps", "by (simp add: removeKey_def)"], ["", "lemma length_removeKey[simp]: \"|removeKey w ps| \\<le> |ps|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |removeKey w ps| \\<le> |ps|", "by (simp add: removeKey_def)"], ["", "lemma length_removeKeyList: \n  \"length (removeKeyList ws ps) \\<le> length ps\" (is \"?P ws\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. |removeKeyList ws ps| \\<le> |ps|", "proof (induct ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. |removeKeyList [] ps| \\<le> |ps|\n 2. \\<And>a ws.\n       |removeKeyList ws ps| \\<le> |ps| \\<Longrightarrow>\n       |removeKeyList (a # ws) ps| \\<le> |ps|", "show \"?P []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |removeKeyList [] ps| \\<le> |ps|", "by simp"], ["proof (state)\nthis:\n  |removeKeyList [] ps| \\<le> |ps|\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       |removeKeyList ws ps| \\<le> |ps| \\<Longrightarrow>\n       |removeKeyList (a # ws) ps| \\<le> |ps|", "fix w ws"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       |removeKeyList ws ps| \\<le> |ps| \\<Longrightarrow>\n       |removeKeyList (a # ws) ps| \\<le> |ps|", "have \"length (removeKey w (removeKeyList ws ps)) \n      \\<le> length (removeKeyList ws ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |removeKey w (removeKeyList ws ps)| \\<le> |removeKeyList ws ps|", "by (rule length_removeKey)"], ["proof (state)\nthis:\n  |removeKey w (removeKeyList ws ps)| \\<le> |removeKeyList ws ps|\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       |removeKeyList ws ps| \\<le> |ps| \\<Longrightarrow>\n       |removeKeyList (a # ws) ps| \\<le> |ps|", "also"], ["proof (state)\nthis:\n  |removeKey w (removeKeyList ws ps)| \\<le> |removeKeyList ws ps|\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       |removeKeyList ws ps| \\<le> |ps| \\<Longrightarrow>\n       |removeKeyList (a # ws) ps| \\<le> |ps|", "assume \"?P ws\""], ["proof (state)\nthis:\n  |removeKeyList ws ps| \\<le> |ps|\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       |removeKeyList ws ps| \\<le> |ps| \\<Longrightarrow>\n       |removeKeyList (a # ws) ps| \\<le> |ps|", "finally"], ["proof (chain)\npicking this:\n  |removeKey w (removeKeyList ws ps)| \\<le> |ps|", "show \"?P (w#ws)\""], ["proof (prove)\nusing this:\n  |removeKey w (removeKeyList ws ps)| \\<le> |ps|\n\ngoal (1 subgoal):\n 1. |removeKeyList (w # ws) ps| \\<le> |ps|", "by simp"], ["proof (state)\nthis:\n  |removeKeyList (w # ws) ps| \\<le> |ps|\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma removeKeyList_subset[simp]: \"set (removeKeyList ws ps) \\<subseteq> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (removeKeyList ws ps) \\<subseteq> set ps", "proof (induct ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (removeKeyList [] ps) \\<subseteq> set ps\n 2. \\<And>a ws.\n       set (removeKeyList ws ps) \\<subseteq> set ps \\<Longrightarrow>\n       set (removeKeyList (a # ws) ps) \\<subseteq> set ps", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. set (removeKeyList [] ps) \\<subseteq> set ps\n 2. \\<And>a ws.\n       set (removeKeyList ws ps) \\<subseteq> set ps \\<Longrightarrow>\n       set (removeKeyList (a # ws) ps) \\<subseteq> set ps", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (removeKeyList [] ps) \\<subseteq> set ps", "by simp"], ["proof (state)\nthis:\n  set (removeKeyList [] ps) \\<subseteq> set ps\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       set (removeKeyList ws ps) \\<subseteq> set ps \\<Longrightarrow>\n       set (removeKeyList (a # ws) ps) \\<subseteq> set ps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       set (removeKeyList ws ps) \\<subseteq> set ps \\<Longrightarrow>\n       set (removeKeyList (a # ws) ps) \\<subseteq> set ps", "case (Cons w ws)"], ["proof (state)\nthis:\n  set (removeKeyList ws ps) \\<subseteq> set ps\n\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       set (removeKeyList ws ps) \\<subseteq> set ps \\<Longrightarrow>\n       set (removeKeyList (a # ws) ps) \\<subseteq> set ps", "then"], ["proof (chain)\npicking this:\n  set (removeKeyList ws ps) \\<subseteq> set ps", "show ?case"], ["proof (prove)\nusing this:\n  set (removeKeyList ws ps) \\<subseteq> set ps\n\ngoal (1 subgoal):\n 1. set (removeKeyList (w # ws) ps) \\<subseteq> set ps", "by (metis dual_order.trans removeKeyList.simps(2) removeKey_subset)"], ["proof (state)\nthis:\n  set (removeKeyList (w # ws) ps) \\<subseteq> set ps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma notin_removeKey1: \"(a, b) \\<notin> set (removeKey a ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<notin> set (removeKey a ps)", "by (induct ps) (auto simp add: removeKey_def)"], ["", "lemma removeKeyList_eq:\n  \"removeKeyList as ps = [p \\<leftarrow> ps. \\<forall>a \\<in> set as. a \\<noteq> fst p]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeKeyList as ps =\n    filter (\\<lambda>p. \\<forall>a\\<in>set as. a \\<noteq> fst p) ps", "by (induct as) (simp_all add: filter_comm removeKey_def)"], ["", "lemma removeKey_empty[simp]: \"removeKey a [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeKey a [] = []", "by (simp add: removeKey_def)"], ["", "lemma removeKeyList_empty[simp]: \"removeKeyList ps [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeKeyList ps [] = []", "by (induct ps) simp_all"], ["", "lemma removeKeyList_cons[simp]: \n  \"removeKeyList ws (p#ps) \n  = (if fst p \\<in> set ws then removeKeyList ws ps else p#(removeKeyList ws ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeKeyList ws (p # ps) =\n    (if fst p \\<in> set ws then removeKeyList ws ps\n     else p # removeKeyList ws ps)", "by (induct ws) (simp_all split: if_split_asm add: removeKey_def)"], ["", "end"]]}