{"file_name": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame/ScoreProps.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flyspeck-Tame", "problem_names": ["lemma deleteAround_empty[simp]: \"deleteAround g a [] = []\"", "lemma deleteAroundCons:\n  \"deleteAround g a (p#ps) =\n    (if fst p \\<in> {v. \\<exists>f \\<in> set (facesAt g a).\n               (length (vertices f) = 4) \\<and> v \\<in> {f \\<bullet> a, f \\<bullet> (f \\<bullet> a)}\n             \\<or> (length (vertices f) \\<noteq> 4) \\<and> (v = f \\<bullet> a)}\n     then deleteAround g a ps\n     else p#deleteAround g a ps)\"", "lemma deleteAround_subset: \"set (deleteAround g a ps) \\<subseteq> set ps\"", "lemma distinct_deleteAround: \"distinct (map fst ps) \\<Longrightarrow>\n    distinct (map fst (deleteAround g (fst (a, b)) ps))\"", "lemma deleteAround_eq: \"deleteAround g v ps = deleteAround' g v ps\"", "lemma deleteAround_nextVertex:\n  \"f \\<in> set (facesAt g a) \\<Longrightarrow>\n  (f \\<bullet> a, b) \\<notin> set (deleteAround g a ps)\"", "lemma deleteAround_nextVertex_nextVertex:\n  \"f \\<in> set (facesAt g a) \\<Longrightarrow> |vertices f| = 4 \\<Longrightarrow>\n  (f \\<bullet> (f \\<bullet> a), b) \\<notin> set (deleteAround g a ps)\"", "lemma deleteAround_prevVertex:\n  \"minGraphProps g \\<Longrightarrow> a : \\<V> g \\<Longrightarrow> f \\<in> set (facesAt g a) \\<Longrightarrow>\n  (f\\<^bsup>-1\\<^esup> \\<bullet> a, b) \\<notin> set (deleteAround g a ps)\"", "lemma deleteAround_separated:\nassumes mgp: \"minGraphProps g\" and fin: \"final g\" and ag: \"a : \\<V> g\" and 4: \"|vertices f| \\<le> 4\"\nand f: \"f \\<in> set(facesAt g a)\"\nshows \"\\<V> f \\<inter> set [fst p. p \\<leftarrow> deleteAround g a ps] \\<subseteq> {a}\" (is \"?A\")", "lemma [iff]: \"separated g {}\"", "lemma separated_insert:\nassumes mgp: \"minGraphProps g\" and a: \"a \\<in> \\<V> g\"\n  and Vg: \"V \\<subseteq> \\<V> g\"\n  and ps: \"separated g V\"\n  and s2: \"(\\<And>f. f \\<in> set (facesAt g a) \\<Longrightarrow> f \\<bullet> a \\<notin> V)\"\n  and s3: \"(\\<And>f. f \\<in> set (facesAt g a) \\<Longrightarrow>\n      |vertices f| \\<le> 4 \\<Longrightarrow> \\<V> f \\<inter> V \\<subseteq> {a})\"\n  shows \"separated g (insert a V)\"", "lemma isTable_deleteAround:\n  \"isTable E vs ((a,b)#ps) \\<Longrightarrow> isTable E vs (deleteAround g a ps)\"", "lemma ListSum_ExcessNotAtRecList:\n \"isTable E vs ps \\<Longrightarrow> ExcessNotAtRec ps g\n  = (\\<Sum>\\<^bsub>p \\<in> ExcessNotAtRecList ps g\\<^esub> E p)\" (is \"?T ps \\<Longrightarrow> ?P ps\")", "lemma ExcessNotAtRecList_subset:\n  \"set (ExcessNotAtRecList ps g) \\<subseteq> set [fst p. p \\<leftarrow> ps]\" (is \"?P ps\")", "lemma separated_ExcessNotAtRecList:\n \"minGraphProps g \\<Longrightarrow> final g \\<Longrightarrow> isTable E (vertices g) ps \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList ps g))\"", "lemma isTable_ExcessTable:\n  \"isTable (\\<lambda>v. ExcessAt g v) vs (ExcessTable g vs)\"", "lemma ExcessTable_subset:\n  \"set (map fst (ExcessTable g vs)) \\<subseteq> set vs\"", "lemma distinct_ExcessNotAtRecList:\n  \"distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\"\n    (is \"?T ps \\<Longrightarrow> ?P ps\")", "lemma distinct_ExcessTable_cont:\n  \"distinct vs \\<Longrightarrow>\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\"", "lemma ExcessTable_cont_eq:\n \"ExcessTable_cont E vs =\n  [(v, E v). v \\<leftarrow> [v\\<leftarrow>vs . 0 < E v]]\"", "lemma ExcessTable_eq: \"ExcessTable = ExcessTable'\"", "lemma distinct_ExcessTable:\n   \"distinct vs \\<Longrightarrow> distinct [fst p. p \\<leftarrow> ExcessTable g vs]\"", "lemma ExcessNotAt_eq:\n  \"minGraphProps g \\<Longrightarrow> final g \\<Longrightarrow>\n  \\<exists>V. ExcessNotAt g None\n      = (\\<Sum>\\<^bsub>v \\<in> V\\<^esub> ExcessAt g v)\n   \\<and> separated g (set V) \\<and> set V \\<subseteq> set (vertices g)\n   \\<and> distinct V\"", "lemma excess_eq:\n  assumes 7: \"t + q \\<le> 7\"\n  shows \"excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\"", "lemma excess_eq1:\n  \"\\<lbrakk> inv g; final g; tame g; except g v = 0; v \\<in> set(vertices g) \\<rbrakk> \\<Longrightarrow>\n   ExcessAt g v + (tri g v) * \\<d> 3 + (quad g v) * \\<d>  4\n   = \\<b> (tri g v) (quad g v)\"", "lemma separating_insert1: \n  \"separating (insert a V) F \\<Longrightarrow> separating V F\"", "lemma separating_insert2:\n  \"separating (insert a V) F \\<Longrightarrow> a \\<notin> V \\<Longrightarrow>  v \\<in> V \\<Longrightarrow> \n  F a \\<inter> F v = {}\"", "lemma sum_disj_Union: \n \"finite V \\<Longrightarrow> \n  (\\<And>f. finite (F f)) \\<Longrightarrow> \n  separating V F \\<Longrightarrow> \n  (\\<Sum>v\\<in>V. \\<Sum>f\\<in>(F v). (w f::nat)) = (\\<Sum>f\\<in>(\\<Union>v\\<in>V. F v). w f)\"", "lemma separated_separating:\nassumes Vg: \"set V \\<subseteq> \\<V> g\"\nand pS: \"separated g (set V)\"\nand noex: \"\\<forall>f\\<in>P. |vertices f| \\<le> 4\"\nshows \"separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> P)\"", "lemma ListSum_V_F_eq_ListSum_F:\nassumes pl: \"inv g\"\nand pS: \"separated g (set V)\" and dist: \"distinct V\"\nand V_subset: \"set V \\<subseteq> set (vertices g)\"\nand noex: \"\\<forall>f \\<in> Collect P. |vertices f| \\<le> 4\"\nshows \"(\\<Sum>\\<^bsub>v \\<in> V\\<^esub> \\<Sum>\\<^bsub>f \\<in> filter P (facesAt g v)\\<^esub> (w::face \\<Rightarrow> nat) f)\n       = (\\<Sum>\\<^bsub>f \\<in> [f\\<leftarrow>faces g . \\<exists>v \\<in> set V. f \\<in> set (facesAt g v) \\<inter> Collect P]\\<^esub> w f)\"", "lemma separated_disj_Union2:\nassumes pl: \"inv g\" and fin: \"final g\" and ne: \"noExceptionals g (set V)\"\nand pS: \"separated g (set V)\" and dist: \"distinct V\"\nand V_subset: \"set V \\<subseteq> set (vertices g)\"\nshows \"(\\<Sum>\\<^bsub>v \\<in> V\\<^esub> \\<Sum>\\<^bsub>f \\<in> facesAt g v\\<^esub> (w::face \\<Rightarrow> nat) f)\n       = (\\<Sum>\\<^bsub>f \\<in> [f\\<leftarrow>faces g . \\<exists>v \\<in> set V. f \\<in> set (facesAt g v)]\\<^esub> w f)\"", "lemma squanderFace_distr2: \"inv g \\<Longrightarrow> final g \\<Longrightarrow> noExceptionals g (set V) \\<Longrightarrow>\n  separated g (set V) \\<Longrightarrow> distinct V \\<Longrightarrow> set V \\<subseteq> set (vertices g) \\<Longrightarrow>\n     (\\<Sum>\\<^bsub>f \\<in> [f\\<leftarrow>faces g. \\<exists>v \\<in> set V. f \\<in> set (facesAt g v)]\\<^esub>\n         \\<d> |vertices f| )\n   = (\\<Sum>\\<^bsub>v \\<in> V\\<^esub> ((tri g v) * \\<d> 3\n         + (quad g v) * \\<d> 4))\"", "lemma separated_subset: (* separated *)\n   \"V1 \\<subseteq> V2 \\<Longrightarrow> separated g V2 \\<Longrightarrow> separated g V1\""], "translations": [["", "lemma deleteAround_empty[simp]: \"deleteAround g a [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deleteAround g a [] = []", "by (simp add: deleteAround_def)"], ["", "lemma deleteAroundCons:\n  \"deleteAround g a (p#ps) =\n    (if fst p \\<in> {v. \\<exists>f \\<in> set (facesAt g a).\n               (length (vertices f) = 4) \\<and> v \\<in> {f \\<bullet> a, f \\<bullet> (f \\<bullet> a)}\n             \\<or> (length (vertices f) \\<noteq> 4) \\<and> (v = f \\<bullet> a)}\n     then deleteAround g a ps\n     else p#deleteAround g a ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deleteAround g a (p # ps) =\n    (if fst p\n        \\<in> {v. \\<exists>f\\<in>set (facesAt g a).\n                     |vertices f| = 4 \\<and>\n                     v \\<in> {f \\<bullet> a,\n                              f \\<bullet> (f \\<bullet> a)} \\<or>\n                     |vertices f| \\<noteq> 4 \\<and> v = f \\<bullet> a}\n     then deleteAround g a ps else p # deleteAround g a ps)", "by (fastforce simp: nextV2 deleteAround_def)"], ["", "lemma deleteAround_subset: \"set (deleteAround g a ps) \\<subseteq> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (deleteAround g a ps) \\<subseteq> set ps", "by (simp add: deleteAround_def)"], ["", "lemma distinct_deleteAround: \"distinct (map fst ps) \\<Longrightarrow>\n    distinct (map fst (deleteAround g (fst (a, b)) ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ps) \\<Longrightarrow>\n    distinct (map fst (deleteAround g (fst (a, b)) ps))", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map fst (deleteAround g (fst (a, b)) []))\n 2. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map fst (deleteAround g (fst (a, b)) []))\n 2. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "then"], ["proof (chain)\npicking this:\n  distinct (map fst [])", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. distinct (map fst (deleteAround g (fst (a, b)) []))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (deleteAround g (fst (a, b)) []))\n\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "case (Cons p ps)"], ["proof (state)\nthis:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (deleteAround g (fst (a, b)) ps))\n  distinct (map fst (p # ps))\n\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "then"], ["proof (chain)\npicking this:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (deleteAround g (fst (a, b)) ps))\n  distinct (map fst (p # ps))", "have \"fst p \\<notin> fst ` set ps\""], ["proof (prove)\nusing this:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (deleteAround g (fst (a, b)) ps))\n  distinct (map fst (p # ps))\n\ngoal (1 subgoal):\n 1. fst p \\<notin> fst ` set ps", "by simp"], ["proof (state)\nthis:\n  fst p \\<notin> fst ` set ps\n\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "moreover"], ["proof (state)\nthis:\n  fst p \\<notin> fst ` set ps\n\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "have \"set (deleteAround g a ps) \\<subseteq> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (deleteAround g a ps) \\<subseteq> set ps", "by (rule deleteAround_subset)"], ["proof (state)\nthis:\n  set (deleteAround g a ps) \\<subseteq> set ps\n\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "ultimately"], ["proof (chain)\npicking this:\n  fst p \\<notin> fst ` set ps\n  set (deleteAround g a ps) \\<subseteq> set ps", "have \"fst p \\<notin> fst ` set (deleteAround g a ps)\""], ["proof (prove)\nusing this:\n  fst p \\<notin> fst ` set ps\n  set (deleteAround g a ps) \\<subseteq> set ps\n\ngoal (1 subgoal):\n 1. fst p \\<notin> fst ` set (deleteAround g a ps)", "by auto"], ["proof (state)\nthis:\n  fst p \\<notin> fst ` set (deleteAround g a ps)\n\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "moreover"], ["proof (state)\nthis:\n  fst p \\<notin> fst ` set (deleteAround g a ps)\n\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "from Cons"], ["proof (chain)\npicking this:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (deleteAround g (fst (a, b)) ps))\n  distinct (map fst (p # ps))", "have \"distinct (map fst ps)\""], ["proof (prove)\nusing this:\n  distinct (map fst ps) \\<Longrightarrow>\n  distinct (map fst (deleteAround g (fst (a, b)) ps))\n  distinct (map fst (p # ps))\n\ngoal (1 subgoal):\n 1. distinct (map fst ps)", "by simp"], ["proof (state)\nthis:\n  distinct (map fst ps)\n\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "then"], ["proof (chain)\npicking this:\n  distinct (map fst ps)", "have \"distinct (map fst (deleteAround g (fst (a, b)) ps))\""], ["proof (prove)\nusing this:\n  distinct (map fst ps)\n\ngoal (1 subgoal):\n 1. distinct (map fst (deleteAround g (fst (a, b)) ps))", "by (rule Cons)"], ["proof (state)\nthis:\n  distinct (map fst (deleteAround g (fst (a, b)) ps))\n\ngoal (1 subgoal):\n 1. \\<And>aa ps.\n       \\<lbrakk>distinct (map fst ps) \\<Longrightarrow>\n                distinct (map fst (deleteAround g (fst (a, b)) ps));\n        distinct (map fst (aa # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (deleteAround g (fst (a, b)) (aa # ps)))", "ultimately"], ["proof (chain)\npicking this:\n  fst p \\<notin> fst ` set (deleteAround g a ps)\n  distinct (map fst (deleteAround g (fst (a, b)) ps))", "show ?case"], ["proof (prove)\nusing this:\n  fst p \\<notin> fst ` set (deleteAround g a ps)\n  distinct (map fst (deleteAround g (fst (a, b)) ps))\n\ngoal (1 subgoal):\n 1. distinct (map fst (deleteAround g (fst (a, b)) (p # ps)))", "by (simp add: deleteAroundCons)"], ["proof (state)\nthis:\n  distinct (map fst (deleteAround g (fst (a, b)) (p # ps)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition deleteAround' :: \"graph \\<Rightarrow> vertex \\<Rightarrow> (vertex \\<times> nat) list \\<Rightarrow>\n    (vertex \\<times> nat) list\" where\n  \"deleteAround' g v ps \\<equiv>\n      let fs = facesAt g v;\n      vs = (\\<lambda>f. let n1 = f \\<bullet> v;\n                n2 = f \\<bullet> n1 in\n                if length (vertices f) = 4 then [n1, n2] else [n1]);\n      ws = concat (map vs fs) in\n      removeKeyList ws ps\""], ["", "lemma deleteAround_eq: \"deleteAround g v ps = deleteAround' g v ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deleteAround g v ps = deleteAround' g v ps", "apply (auto simp add: deleteAround_def deleteAround'_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. removeKeyList\n     (concat\n       (map (\\<lambda>f.\n                if |vertices f| = 4\n                then [f \\<bullet> v, f\\<^bsup>2\\<^esup> \\<bullet> v]\n                else [f \\<bullet> v])\n         (facesAt g v)))\n     ps =\n    removeKeyList\n     (concat\n       (map (\\<lambda>f.\n                if |vertices f| = 4\n                then [f \\<bullet> v, f \\<bullet> (f \\<bullet> v)]\n                else [f \\<bullet> v])\n         (facesAt g v)))\n     ps", "apply (unfold nextV2[THEN eq_reflection], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma deleteAround_nextVertex:\n  \"f \\<in> set (facesAt g a) \\<Longrightarrow>\n  (f \\<bullet> a, b) \\<notin> set (deleteAround g a ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> set (facesAt g a) \\<Longrightarrow>\n    (f \\<bullet> a, b) \\<notin> set (deleteAround g a ps)", "by (auto simp add: deleteAround_eq deleteAround'_def removeKeyList_eq)"], ["", "lemma deleteAround_nextVertex_nextVertex:\n  \"f \\<in> set (facesAt g a) \\<Longrightarrow> |vertices f| = 4 \\<Longrightarrow>\n  (f \\<bullet> (f \\<bullet> a), b) \\<notin> set (deleteAround g a ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| = 4\\<rbrakk>\n    \\<Longrightarrow> (f \\<bullet> (f \\<bullet> a), b)\n                      \\<notin> set (deleteAround g a ps)", "by (auto simp add: deleteAround_eq deleteAround'_def removeKeyList_eq)"], ["", "lemma deleteAround_prevVertex:\n  \"minGraphProps g \\<Longrightarrow> a : \\<V> g \\<Longrightarrow> f \\<in> set (facesAt g a) \\<Longrightarrow>\n  (f\\<^bsup>-1\\<^esup> \\<bullet> a, b) \\<notin> set (deleteAround g a ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; a \\<in> \\<V> g;\n     f \\<in> set (facesAt g a)\\<rbrakk>\n    \\<Longrightarrow> (f\\<^bsup>-1\\<^esup> \\<bullet> a, b)\n                      \\<notin> set (deleteAround g a ps)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; a \\<in> \\<V> g;\n     f \\<in> set (facesAt g a)\\<rbrakk>\n    \\<Longrightarrow> (f\\<^bsup>-1\\<^esup> \\<bullet> a, b)\n                      \\<notin> set (deleteAround g a ps)", "assume a: \"minGraphProps g\" \"a : \\<V> g\" \"f \\<in> set (facesAt g a)\""], ["proof (state)\nthis:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; a \\<in> \\<V> g;\n     f \\<in> set (facesAt g a)\\<rbrakk>\n    \\<Longrightarrow> (f\\<^bsup>-1\\<^esup> \\<bullet> a, b)\n                      \\<notin> set (deleteAround g a ps)", "have \"(f\\<^bsup>-1\\<^esup> \\<bullet> a, a) \\<in> \\<E> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f\\<^bsup>-1\\<^esup> \\<bullet> a, a) \\<in> \\<E> f", "using a"], ["proof (prove)\nusing this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. (f\\<^bsup>-1\\<^esup> \\<bullet> a, a) \\<in> \\<E> f", "by(blast intro:prevVertex_in_edges minGraphProps)"], ["proof (state)\nthis:\n  (f\\<^bsup>-1\\<^esup> \\<bullet> a, a) \\<in> \\<E> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; a \\<in> \\<V> g;\n     f \\<in> set (facesAt g a)\\<rbrakk>\n    \\<Longrightarrow> (f\\<^bsup>-1\\<^esup> \\<bullet> a, b)\n                      \\<notin> set (deleteAround g a ps)", "then"], ["proof (chain)\npicking this:\n  (f\\<^bsup>-1\\<^esup> \\<bullet> a, a) \\<in> \\<E> f", "obtain f' :: face where f': \"f' \\<in> set(facesAt g a)\"\n    and e: \"(a, f\\<^bsup>-1\\<^esup> \\<bullet> a) \\<in> \\<E> f'\""], ["proof (prove)\nusing this:\n  (f\\<^bsup>-1\\<^esup> \\<bullet> a, a) \\<in> \\<E> f\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g a);\n         (a, f\\<^bsup>-1\\<^esup> \\<bullet> a) \\<in> \\<E> f'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a"], ["proof (prove)\nusing this:\n  (f\\<^bsup>-1\\<^esup> \\<bullet> a, a) \\<in> \\<E> f\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g a);\n         (a, f\\<^bsup>-1\\<^esup> \\<bullet> a) \\<in> \\<E> f'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(blast dest:mgp_edge_face_ex)"], ["proof (state)\nthis:\n  f' \\<in> set (facesAt g a)\n  (a, f\\<^bsup>-1\\<^esup> \\<bullet> a) \\<in> \\<E> f'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; a \\<in> \\<V> g;\n     f \\<in> set (facesAt g a)\\<rbrakk>\n    \\<Longrightarrow> (f\\<^bsup>-1\\<^esup> \\<bullet> a, b)\n                      \\<notin> set (deleteAround g a ps)", "have \"(f' \\<bullet> a, b) \\<notin> set (deleteAround g a ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f' \\<bullet> a, b) \\<notin> set (deleteAround g a ps)", "using f'"], ["proof (prove)\nusing this:\n  f' \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. (f' \\<bullet> a, b) \\<notin> set (deleteAround g a ps)", "by (auto simp add: deleteAround_eq deleteAround'_def removeKeyList_eq)"], ["proof (state)\nthis:\n  (f' \\<bullet> a, b) \\<notin> set (deleteAround g a ps)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; a \\<in> \\<V> g;\n     f \\<in> set (facesAt g a)\\<rbrakk>\n    \\<Longrightarrow> (f\\<^bsup>-1\\<^esup> \\<bullet> a, b)\n                      \\<notin> set (deleteAround g a ps)", "moreover"], ["proof (state)\nthis:\n  (f' \\<bullet> a, b) \\<notin> set (deleteAround g a ps)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; a \\<in> \\<V> g;\n     f \\<in> set (facesAt g a)\\<rbrakk>\n    \\<Longrightarrow> (f\\<^bsup>-1\\<^esup> \\<bullet> a, b)\n                      \\<notin> set (deleteAround g a ps)", "have \"f' \\<bullet> a = f\\<^bsup>-1\\<^esup> \\<bullet> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' \\<bullet> a = f\\<^bsup>-1\\<^esup> \\<bullet> a", "using e"], ["proof (prove)\nusing this:\n  (a, f\\<^bsup>-1\\<^esup> \\<bullet> a) \\<in> \\<E> f'\n\ngoal (1 subgoal):\n 1. f' \\<bullet> a = f\\<^bsup>-1\\<^esup> \\<bullet> a", "by (simp add:edges_face_eq)"], ["proof (state)\nthis:\n  f' \\<bullet> a = f\\<^bsup>-1\\<^esup> \\<bullet> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; a \\<in> \\<V> g;\n     f \\<in> set (facesAt g a)\\<rbrakk>\n    \\<Longrightarrow> (f\\<^bsup>-1\\<^esup> \\<bullet> a, b)\n                      \\<notin> set (deleteAround g a ps)", "ultimately"], ["proof (chain)\npicking this:\n  (f' \\<bullet> a, b) \\<notin> set (deleteAround g a ps)\n  f' \\<bullet> a = f\\<^bsup>-1\\<^esup> \\<bullet> a", "show ?thesis"], ["proof (prove)\nusing this:\n  (f' \\<bullet> a, b) \\<notin> set (deleteAround g a ps)\n  f' \\<bullet> a = f\\<^bsup>-1\\<^esup> \\<bullet> a\n\ngoal (1 subgoal):\n 1. (f\\<^bsup>-1\\<^esup> \\<bullet> a, b) \\<notin> set (deleteAround g a ps)", "by simp"], ["proof (state)\nthis:\n  (f\\<^bsup>-1\\<^esup> \\<bullet> a, b) \\<notin> set (deleteAround g a ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deleteAround_separated:\nassumes mgp: \"minGraphProps g\" and fin: \"final g\" and ag: \"a : \\<V> g\" and 4: \"|vertices f| \\<le> 4\"\nand f: \"f \\<in> set(facesAt g a)\"\nshows \"\\<V> f \\<inter> set [fst p. p \\<leftarrow> deleteAround g a ps] \\<subseteq> {a}\" (is \"?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "note MGP = mgp ag f"], ["proof (state)\nthis:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "have af: \"a \\<in> \\<V> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<V> f", "using MGP"], ["proof (prove)\nusing this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V> f", "by(blast intro:minGraphProps)"], ["proof (state)\nthis:\n  a \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "have \"2 < |vertices f|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < |vertices f|", "using MGP"], ["proof (prove)\nusing this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. 2 < |vertices f|", "by(blast intro:minGraphProps)"], ["proof (state)\nthis:\n  2 < |vertices f|\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "with 4"], ["proof (chain)\npicking this:\n  |vertices f| \\<le> 4\n  2 < |vertices f|", "have \"|vertices f| = 3 \\<or> |vertices f| = 4\""], ["proof (prove)\nusing this:\n  |vertices f| \\<le> 4\n  2 < |vertices f|\n\ngoal (1 subgoal):\n 1. triangle f \\<or> |vertices f| = 4", "by arith"], ["proof (state)\nthis:\n  triangle f \\<or> |vertices f| = 4\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "then"], ["proof (chain)\npicking this:\n  triangle f \\<or> |vertices f| = 4", "show \"?A\""], ["proof (prove)\nusing this:\n  triangle f \\<or> |vertices f| = 4\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. triangle f \\<Longrightarrow>\n    \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n 2. |vertices f| = 4 \\<Longrightarrow>\n    \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "assume 3: \"|vertices f| = 3\""], ["proof (state)\nthis:\n  triangle f\n\ngoal (2 subgoals):\n 1. triangle f \\<Longrightarrow>\n    \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n 2. |vertices f| = 4 \\<Longrightarrow>\n    \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "show \"?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "assume \"\\<not> ?A\""], ["proof (state)\nthis:\n  \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "obtain b where b1: \"b \\<noteq> a\" \"b \\<in> \\<V> f\"\n        \"b \\<in> set (map fst (deleteAround g a ps))\""], ["proof (prove)\nusing this:\n  \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<noteq> a; b \\<in> \\<V> f;\n         b \\<in> set (map fst (deleteAround g a ps))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> a\n  b \\<in> \\<V> f\n  b \\<in> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "from MGP"], ["proof (chain)\npicking this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)", "have d: \"distinct (vertices f)\""], ["proof (prove)\nusing this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. distinct (vertices f)", "by(blast intro:minGraphProps)"], ["proof (state)\nthis:\n  distinct (vertices f)\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "with af 3"], ["proof (chain)\npicking this:\n  a \\<in> \\<V> f\n  triangle f\n  distinct (vertices f)", "have \"\\<V> f = {a, f \\<bullet> a, f \\<bullet> (f \\<bullet> a)}\""], ["proof (prove)\nusing this:\n  a \\<in> \\<V> f\n  triangle f\n  distinct (vertices f)\n\ngoal (1 subgoal):\n 1. \\<V> f = {a, f \\<bullet> a, f \\<bullet> (f \\<bullet> a)}", "by (rule_tac vertices_triangle)"], ["proof (state)\nthis:\n  \\<V> f = {a, f \\<bullet> a, f \\<bullet> (f \\<bullet> a)}\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  \\<V> f = {a, f \\<bullet> a, f \\<bullet> (f \\<bullet> a)}\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "from d af 3"], ["proof (chain)\npicking this:\n  distinct (vertices f)\n  a \\<in> \\<V> f\n  triangle f", "have\n        \"f \\<bullet> (f \\<bullet> a) = f\\<^bsup>-1\\<^esup> \\<bullet> a\""], ["proof (prove)\nusing this:\n  distinct (vertices f)\n  a \\<in> \\<V> f\n  triangle f\n\ngoal (1 subgoal):\n 1. f \\<bullet> (f \\<bullet> a) = f\\<^bsup>-1\\<^esup> \\<bullet> a", "by (simp add: triangle_nextVertex_prevVertex)"], ["proof (state)\nthis:\n  f \\<bullet> (f \\<bullet> a) = f\\<^bsup>-1\\<^esup> \\<bullet> a\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  \\<V> f = {a, f \\<bullet> a, f\\<^bsup>-1\\<^esup> \\<bullet> a}", "have\n        \"b \\<in> {f \\<bullet> a, f\\<^bsup>-1\\<^esup> \\<bullet> a}\""], ["proof (prove)\nusing this:\n  \\<V> f = {a, f \\<bullet> a, f\\<^bsup>-1\\<^esup> \\<bullet> a}\n\ngoal (1 subgoal):\n 1. b \\<in> {f \\<bullet> a, f\\<^bsup>-1\\<^esup> \\<bullet> a}", "using b1"], ["proof (prove)\nusing this:\n  \\<V> f = {a, f \\<bullet> a, f\\<^bsup>-1\\<^esup> \\<bullet> a}\n  b \\<noteq> a\n  b \\<in> \\<V> f\n  b \\<in> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. b \\<in> {f \\<bullet> a, f\\<^bsup>-1\\<^esup> \\<bullet> a}", "by simp"], ["proof (state)\nthis:\n  b \\<in> {f \\<bullet> a, f\\<^bsup>-1\\<^esup> \\<bullet> a}\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "with MGP"], ["proof (chain)\npicking this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n  b \\<in> {f \\<bullet> a, f\\<^bsup>-1\\<^esup> \\<bullet> a}", "have \"b \\<notin> set (map fst (deleteAround g a ps))\""], ["proof (prove)\nusing this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n  b \\<in> {f \\<bullet> a, f\\<^bsup>-1\\<^esup> \\<bullet> a}\n\ngoal (1 subgoal):\n 1. b \\<notin> set (map fst (deleteAround g a ps))", "using deleteAround_nextVertex deleteAround_prevVertex"], ["proof (prove)\nusing this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n  b \\<in> {f \\<bullet> a, f\\<^bsup>-1\\<^esup> \\<bullet> a}\n  ?f \\<in> set (facesAt ?g ?a) \\<Longrightarrow>\n  (?f \\<bullet> ?a, ?b) \\<notin> set (deleteAround ?g ?a ?ps)\n  \\<lbrakk>minGraphProps ?g; ?a \\<in> \\<V> ?g;\n   ?f \\<in> set (facesAt ?g ?a)\\<rbrakk>\n  \\<Longrightarrow> (?f\\<^bsup>-1\\<^esup> \\<bullet> ?a, ?b)\n                    \\<notin> set (deleteAround ?g ?a ?ps)\n\ngoal (1 subgoal):\n 1. b \\<notin> set (map fst (deleteAround g a ps))", "by auto"], ["proof (state)\nthis:\n  b \\<notin> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  b \\<notin> set (map fst (deleteAround g a ps))", "show False"], ["proof (prove)\nusing this:\n  b \\<notin> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. False", "by contradiction (rule b1)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n\ngoal (1 subgoal):\n 1. |vertices f| = 4 \\<Longrightarrow>\n    \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. |vertices f| = 4 \\<Longrightarrow>\n    \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "assume 4: \"|vertices f| = 4\""], ["proof (state)\nthis:\n  |vertices f| = 4\n\ngoal (1 subgoal):\n 1. |vertices f| = 4 \\<Longrightarrow>\n    \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "show \"?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "assume \"\\<not> ?A\""], ["proof (state)\nthis:\n  \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "obtain b where b1: \"b \\<noteq> a\" \"b \\<in> \\<V> f\"\n        \"b \\<in> set (map fst (deleteAround g a ps))\""], ["proof (prove)\nusing this:\n  \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<noteq> a; b \\<in> \\<V> f;\n         b \\<in> set (map fst (deleteAround g a ps))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> a\n  b \\<in> \\<V> f\n  b \\<in> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "from MGP"], ["proof (chain)\npicking this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)", "have d: \"distinct (vertices f)\""], ["proof (prove)\nusing this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. distinct (vertices f)", "by(blast intro:minGraphProps)"], ["proof (state)\nthis:\n  distinct (vertices f)\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "with af 4"], ["proof (chain)\npicking this:\n  a \\<in> \\<V> f\n  |vertices f| = 4\n  distinct (vertices f)", "have \"\\<V> f = {a, f \\<bullet> a, f \\<bullet> (f \\<bullet> a), f \\<bullet> (f \\<bullet> (f \\<bullet> a))}\""], ["proof (prove)\nusing this:\n  a \\<in> \\<V> f\n  |vertices f| = 4\n  distinct (vertices f)\n\ngoal (1 subgoal):\n 1. \\<V> f =\n    {a, f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n     f \\<bullet> (f \\<bullet> (f \\<bullet> a))}", "by (rule_tac vertices_quad)"], ["proof (state)\nthis:\n  \\<V> f =\n  {a, f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n   f \\<bullet> (f \\<bullet> (f \\<bullet> a))}\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  \\<V> f =\n  {a, f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n   f \\<bullet> (f \\<bullet> (f \\<bullet> a))}\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "from d af 4"], ["proof (chain)\npicking this:\n  distinct (vertices f)\n  a \\<in> \\<V> f\n  |vertices f| = 4", "have \"f \\<bullet> (f \\<bullet> (f \\<bullet> a)) = f\\<^bsup>-1\\<^esup> \\<bullet> a\""], ["proof (prove)\nusing this:\n  distinct (vertices f)\n  a \\<in> \\<V> f\n  |vertices f| = 4\n\ngoal (1 subgoal):\n 1. f \\<bullet> (f \\<bullet> (f \\<bullet> a)) =\n    f\\<^bsup>-1\\<^esup> \\<bullet> a", "by (simp add: quad_nextVertex_prevVertex)"], ["proof (state)\nthis:\n  f \\<bullet> (f \\<bullet> (f \\<bullet> a)) =\n  f\\<^bsup>-1\\<^esup> \\<bullet> a\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  \\<V> f =\n  {a, f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n   f\\<^bsup>-1\\<^esup> \\<bullet> a}", "have \"b \\<in> {f \\<bullet> a, f \\<bullet> (f \\<bullet> a), f\\<^bsup>-1\\<^esup> \\<bullet> a}\""], ["proof (prove)\nusing this:\n  \\<V> f =\n  {a, f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n   f\\<^bsup>-1\\<^esup> \\<bullet> a}\n\ngoal (1 subgoal):\n 1. b \\<in> {f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n             f\\<^bsup>-1\\<^esup> \\<bullet> a}", "using b1"], ["proof (prove)\nusing this:\n  \\<V> f =\n  {a, f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n   f\\<^bsup>-1\\<^esup> \\<bullet> a}\n  b \\<noteq> a\n  b \\<in> \\<V> f\n  b \\<in> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. b \\<in> {f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n             f\\<^bsup>-1\\<^esup> \\<bullet> a}", "by simp"], ["proof (state)\nthis:\n  b \\<in> {f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n           f\\<^bsup>-1\\<^esup> \\<bullet> a}\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "with MGP 4"], ["proof (chain)\npicking this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n  |vertices f| = 4\n  b \\<in> {f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n           f\\<^bsup>-1\\<^esup> \\<bullet> a}", "have \"b \\<notin> set (map fst (deleteAround g a ps))\""], ["proof (prove)\nusing this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n  |vertices f| = 4\n  b \\<in> {f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n           f\\<^bsup>-1\\<^esup> \\<bullet> a}\n\ngoal (1 subgoal):\n 1. b \\<notin> set (map fst (deleteAround g a ps))", "using deleteAround_nextVertex deleteAround_prevVertex\n           deleteAround_nextVertex_nextVertex"], ["proof (prove)\nusing this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n  |vertices f| = 4\n  b \\<in> {f \\<bullet> a, f \\<bullet> (f \\<bullet> a),\n           f\\<^bsup>-1\\<^esup> \\<bullet> a}\n  ?f \\<in> set (facesAt ?g ?a) \\<Longrightarrow>\n  (?f \\<bullet> ?a, ?b) \\<notin> set (deleteAround ?g ?a ?ps)\n  \\<lbrakk>minGraphProps ?g; ?a \\<in> \\<V> ?g;\n   ?f \\<in> set (facesAt ?g ?a)\\<rbrakk>\n  \\<Longrightarrow> (?f\\<^bsup>-1\\<^esup> \\<bullet> ?a, ?b)\n                    \\<notin> set (deleteAround ?g ?a ?ps)\n  \\<lbrakk>?f \\<in> set (facesAt ?g ?a); |vertices ?f| = 4\\<rbrakk>\n  \\<Longrightarrow> (?f \\<bullet> (?f \\<bullet> ?a), ?b)\n                    \\<notin> set (deleteAround ?g ?a ?ps)\n\ngoal (1 subgoal):\n 1. b \\<notin> set (map fst (deleteAround g a ps))", "by auto"], ["proof (state)\nthis:\n  b \\<notin> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. \\<not> \\<V> f \\<inter> set (map fst (deleteAround g a ps))\n           \\<subseteq> {a} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  b \\<notin> set (map fst (deleteAround g a ps))", "show False"], ["proof (prove)\nusing this:\n  b \\<notin> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. False", "by contradiction (rule b1)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\ndeleteAround g y loescht nextVertex f a,\nnextVertex f (nextVertex f a),\nprevVertex f a wird mit nachbarflaeche geloescht.\n*)"], ["", "lemma [iff]: \"separated g {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated g {}", "by (simp add: separated_def separated\\<^sub>2_def separated\\<^sub>3_def)"], ["", "lemma separated_insert:\nassumes mgp: \"minGraphProps g\" and a: \"a \\<in> \\<V> g\"\n  and Vg: \"V \\<subseteq> \\<V> g\"\n  and ps: \"separated g V\"\n  and s2: \"(\\<And>f. f \\<in> set (facesAt g a) \\<Longrightarrow> f \\<bullet> a \\<notin> V)\"\n  and s3: \"(\\<And>f. f \\<in> set (facesAt g a) \\<Longrightarrow>\n      |vertices f| \\<le> 4 \\<Longrightarrow> \\<V> f \\<inter> V \\<subseteq> {a})\"\n  shows \"separated g (insert a V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated g (insert a V)", "proof (simp add: separated_def separated\\<^sub>2_def separated\\<^sub>3_def,\n intro conjI ballI impI)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow> f \\<bullet> a \\<noteq> a\n 2. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow> f \\<bullet> a \\<notin> V\n 3. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<noteq> a\n 4. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V\n 5. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 6. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "fix f"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow> f \\<bullet> a \\<noteq> a\n 2. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow> f \\<bullet> a \\<notin> V\n 3. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<noteq> a\n 4. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V\n 5. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 6. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "assume f: \"f \\<in> set (facesAt g a)\""], ["proof (state)\nthis:\n  f \\<in> set (facesAt g a)\n\ngoal (6 subgoals):\n 1. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow> f \\<bullet> a \\<noteq> a\n 2. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow> f \\<bullet> a \\<notin> V\n 3. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<noteq> a\n 4. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V\n 5. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 6. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "then"], ["proof (chain)\npicking this:\n  f \\<in> set (facesAt g a)", "show \"f \\<bullet> a \\<noteq> a\""], ["proof (prove)\nusing this:\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. f \\<bullet> a \\<noteq> a", "by (rule mgp_facesAt_no_loop[OF mgp a])"], ["proof (state)\nthis:\n  f \\<bullet> a \\<noteq> a\n\ngoal (5 subgoals):\n 1. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow> f \\<bullet> a \\<notin> V\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<noteq> a\n 3. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V\n 4. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 5. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "from f"], ["proof (chain)\npicking this:\n  f \\<in> set (facesAt g a)", "show \"f \\<bullet> a \\<notin> V\""], ["proof (prove)\nusing this:\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. f \\<bullet> a \\<notin> V", "by (rule s2)"], ["proof (state)\nthis:\n  f \\<bullet> a \\<notin> V\n\ngoal (4 subgoals):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<noteq> a\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V\n 3. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 4. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<noteq> a\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V\n 3. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 4. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "fix f v"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<noteq> a\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V\n 3. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 4. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "assume v: \"f \\<in> set (facesAt g v)\" and vV: \"v \\<in> V\""], ["proof (state)\nthis:\n  f \\<in> set (facesAt g v)\n  v \\<in> V\n\ngoal (4 subgoals):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<noteq> a\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V\n 3. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 4. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "have \"v : \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> \\<V> g", "using vV Vg"], ["proof (prove)\nusing this:\n  v \\<in> V\n  V \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. v \\<in> \\<V> g", "by blast"], ["proof (state)\nthis:\n  v \\<in> \\<V> g\n\ngoal (4 subgoals):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<noteq> a\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V\n 3. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 4. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "show \"f \\<bullet> v \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<bullet> v \\<noteq> a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<bullet> v = a \\<Longrightarrow> False", "assume f: \"f \\<bullet> v = a\""], ["proof (state)\nthis:\n  f \\<bullet> v = a\n\ngoal (1 subgoal):\n 1. f \\<bullet> v = a \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  f \\<bullet> v = a", "obtain f' where f': \"f' \\<in> set(facesAt g a)\" and v: \"f' \\<bullet> a = v\""], ["proof (prove)\nusing this:\n  f \\<bullet> v = a\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g a); f' \\<bullet> a = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mgp_nextVertex_face_ex2[OF mgp \\<open>v : \\<V> g\\<close> v]"], ["proof (prove)\nusing this:\n  f \\<bullet> v = a\n  \\<exists>f'\\<in>set (facesAt g (f \\<bullet> v)).\n     f' \\<bullet> (f \\<bullet> v) = v\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>f' \\<in> set (facesAt g a); f' \\<bullet> a = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f' \\<in> set (facesAt g a)\n  f' \\<bullet> a = v\n\ngoal (1 subgoal):\n 1. f \\<bullet> v = a \\<Longrightarrow> False", "have \"f' \\<bullet> a \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' \\<bullet> a \\<in> V", "using v vV"], ["proof (prove)\nusing this:\n  f' \\<bullet> a = v\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. f' \\<bullet> a \\<in> V", "by simp"], ["proof (state)\nthis:\n  f' \\<bullet> a \\<in> V\n\ngoal (1 subgoal):\n 1. f \\<bullet> v = a \\<Longrightarrow> False", "with f' s2"], ["proof (chain)\npicking this:\n  f' \\<in> set (facesAt g a)\n  ?f \\<in> set (facesAt g a) \\<Longrightarrow> ?f \\<bullet> a \\<notin> V\n  f' \\<bullet> a \\<in> V", "show False"], ["proof (prove)\nusing this:\n  f' \\<in> set (facesAt g a)\n  ?f \\<in> set (facesAt g a) \\<Longrightarrow> ?f \\<bullet> a \\<notin> V\n  f' \\<bullet> a \\<in> V\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f \\<bullet> v \\<noteq> a\n\ngoal (3 subgoals):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 3. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "from ps v vV"], ["proof (chain)\npicking this:\n  separated g V\n  f \\<in> set (facesAt g v)\n  v \\<in> V", "show \"f \\<bullet> v \\<notin> V\""], ["proof (prove)\nusing this:\n  separated g V\n  f \\<in> set (facesAt g v)\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. f \\<bullet> v \\<notin> V", "by (simp add: separated_def separated\\<^sub>2_def)"], ["proof (state)\nthis:\n  f \\<bullet> v \\<notin> V\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "assume f:  \"f \\<in> set (facesAt g a)\" \"|vertices f| \\<le> 4\""], ["proof (state)\nthis:\n  f \\<in> set (facesAt g a)\n  |vertices f| \\<le> 4\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "then"], ["proof (chain)\npicking this:\n  f \\<in> set (facesAt g a)\n  |vertices f| \\<le> 4", "have \"\\<V> f \\<inter> V \\<subseteq> {a}\""], ["proof (prove)\nusing this:\n  f \\<in> set (facesAt g a)\n  |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> V \\<subseteq> {a}", "by (rule s3)"], ["proof (state)\nthis:\n  \\<V> f \\<inter> V \\<subseteq> {a}\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "moreover"], ["proof (state)\nthis:\n  \\<V> f \\<inter> V \\<subseteq> {a}\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "from mgp a f"], ["proof (chain)\npicking this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n  |vertices f| \\<le> 4", "have \"a \\<in> \\<V> f\""], ["proof (prove)\nusing this:\n  minGraphProps g\n  a \\<in> \\<V> g\n  f \\<in> set (facesAt g a)\n  |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V> f", "by(blast intro:minGraphProps)"], ["proof (state)\nthis:\n  a \\<in> \\<V> f\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {a}\n 2. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "ultimately"], ["proof (chain)\npicking this:\n  \\<V> f \\<inter> V \\<subseteq> {a}\n  a \\<in> \\<V> f", "show \"\\<V> f \\<inter> insert a V = {a}\""], ["proof (prove)\nusing this:\n  \\<V> f \\<inter> V \\<subseteq> {a}\n  a \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> insert a V = {a}", "by auto"], ["proof (state)\nthis:\n  \\<V> f \\<inter> insert a V = {a}\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "fix v f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "assume a: \"v \\<in> V\" \"f \\<in> set (facesAt g v)\"\n    \"|vertices f| \\<le> 4\""], ["proof (state)\nthis:\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "with ps"], ["proof (chain)\npicking this:\n  separated g V\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4", "have v: \"\\<V> f \\<inter> V = {v}\""], ["proof (prove)\nusing this:\n  separated g V\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> V = {v}", "by (simp add: separated_def separated\\<^sub>3_def)"], ["proof (state)\nthis:\n  \\<V> f \\<inter> V = {v}\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "have \"v : \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> \\<V> g", "using a Vg"], ["proof (prove)\nusing this:\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  V \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. v \\<in> \\<V> g", "by blast"], ["proof (state)\nthis:\n  v \\<in> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>v \\<in> V; f \\<in> set (facesAt g v);\n        |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "show  \"\\<V> f \\<inter> insert a V = {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> insert a V = {v}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}\n 2. \\<not> ?P \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "assume \"a = v\""], ["proof (state)\nthis:\n  a = v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}\n 2. \\<not> ?P \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "with v mgp a"], ["proof (chain)\npicking this:\n  \\<V> f \\<inter> V = {v}\n  minGraphProps g\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  a = v", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<V> f \\<inter> V = {v}\n  minGraphProps g\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  a = v\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> insert a V = {v}", "by(blast intro:minGraphProps)"], ["proof (state)\nthis:\n  \\<V> f \\<inter> insert a V = {v}\n\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "assume n: \"a \\<noteq> v\""], ["proof (state)\nthis:\n  a \\<noteq> v\n\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "have  \"a \\<notin> \\<V> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> \\<V> f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> \\<V> f \\<Longrightarrow> False", "assume a2: \"a \\<in> \\<V> f\""], ["proof (state)\nthis:\n  a \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V> f \\<Longrightarrow> False", "with mgp a \\<open>v : \\<V> g\\<close>"], ["proof (chain)\npicking this:\n  minGraphProps g\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  v \\<in> \\<V> g\n  a \\<in> \\<V> f", "have \"f \\<in> \\<F> g\""], ["proof (prove)\nusing this:\n  minGraphProps g\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  v \\<in> \\<V> g\n  a \\<in> \\<V> f\n\ngoal (1 subgoal):\n 1. f \\<in> \\<F> g", "by(blast intro:minGraphProps)"], ["proof (state)\nthis:\n  f \\<in> \\<F> g\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V> f \\<Longrightarrow> False", "with mgp a2"], ["proof (chain)\npicking this:\n  minGraphProps g\n  a \\<in> \\<V> f\n  f \\<in> \\<F> g", "have \"f \\<in> set (facesAt g a)\""], ["proof (prove)\nusing this:\n  minGraphProps g\n  a \\<in> \\<V> f\n  f \\<in> \\<F> g\n\ngoal (1 subgoal):\n 1. f \\<in> set (facesAt g a)", "by(blast intro:minGraphProps)"], ["proof (state)\nthis:\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V> f \\<Longrightarrow> False", "with a"], ["proof (chain)\npicking this:\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  f \\<in> set (facesAt g a)", "have \"\\<V> f \\<inter> V \\<subseteq> {a}\""], ["proof (prove)\nusing this:\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> V \\<subseteq> {a}", "by (simp add: s3)"], ["proof (state)\nthis:\n  \\<V> f \\<inter> V \\<subseteq> {a}\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V> f \\<Longrightarrow> False", "with v"], ["proof (chain)\npicking this:\n  \\<V> f \\<inter> V = {v}\n  \\<V> f \\<inter> V \\<subseteq> {a}", "have \"a = v\""], ["proof (prove)\nusing this:\n  \\<V> f \\<inter> V = {v}\n  \\<V> f \\<inter> V \\<subseteq> {a}\n\ngoal (1 subgoal):\n 1. a = v", "by auto"], ["proof (state)\nthis:\n  a = v\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V> f \\<Longrightarrow> False", "with n"], ["proof (chain)\npicking this:\n  a \\<noteq> v\n  a = v", "show False"], ["proof (prove)\nusing this:\n  a \\<noteq> v\n  a = v\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<notin> \\<V> f\n\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow> \\<V> f \\<inter> insert a V = {v}", "with a  v"], ["proof (chain)\npicking this:\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  \\<V> f \\<inter> V = {v}\n  a \\<notin> \\<V> f", "show \"\\<V> f \\<inter> insert a V = {v}\""], ["proof (prove)\nusing this:\n  v \\<in> V\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  \\<V> f \\<inter> V = {v}\n  a \\<notin> \\<V> f\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> insert a V = {v}", "by blast"], ["proof (state)\nthis:\n  \\<V> f \\<inter> insert a V = {v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<V> f \\<inter> insert a V = {v}\n\ngoal:\nNo subgoals!", "qed"], ["", "function ExcessNotAtRecList :: \"(vertex, nat) table \\<Rightarrow> graph \\<Rightarrow> vertex list\" where\n  \"ExcessNotAtRecList [] = (\\<lambda>g. [])\"\n  | \"ExcessNotAtRecList ((x, y) # ps) = (\\<lambda>g.\n      let l1 = ExcessNotAtRecList ps g;\n      l2 = ExcessNotAtRecList (deleteAround g x ps) g in\n      if ExcessNotAtRec ps g\n       \\<le> y + ExcessNotAtRec (deleteAround g x ps) g\n      then x # l2 else l1)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>xa y ps. x = (xa, y) # ps \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. [] = [] \\<Longrightarrow> (\\<lambda>g. []) = (\\<lambda>g. [])\n 3. \\<And>x y ps.\n       [] = (x, y) # ps \\<Longrightarrow>\n       (\\<lambda>g. []) =\n       (\\<lambda>g.\n           let l1 = ExcessNotAtRecList_sumC ps g;\n               l2 = ExcessNotAtRecList_sumC (deleteAround g x ps) g\n           in if ExcessNotAtRec ps g\n                 \\<le> y + ExcessNotAtRec (deleteAround g x ps) g\n              then x # l2 else l1)\n 4. \\<And>x y ps xa ya psa.\n       (x, y) # ps = (xa, ya) # psa \\<Longrightarrow>\n       (\\<lambda>g.\n           let l1 = ExcessNotAtRecList_sumC ps g;\n               l2 = ExcessNotAtRecList_sumC (deleteAround g x ps) g\n           in if ExcessNotAtRec ps g\n                 \\<le> y + ExcessNotAtRec (deleteAround g x ps) g\n              then x # l2 else l1) =\n       (\\<lambda>g.\n           let l1 = ExcessNotAtRecList_sumC psa g;\n               l2 = ExcessNotAtRecList_sumC (deleteAround g xa psa) g\n           in if ExcessNotAtRec psa g\n                 \\<le> ya + ExcessNotAtRec (deleteAround g xa psa) g\n              then xa # l2 else l1)", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All ExcessNotAtRecList_dom", "by (relation \"measure size\")\n  (auto simp add: less_Suc_eq_le length_deleteAround)"], ["", "lemma isTable_deleteAround:\n  \"isTable E vs ((a,b)#ps) \\<Longrightarrow> isTable E vs (deleteAround g a ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isTable E vs ((a, b) # ps) \\<Longrightarrow>\n    isTable E vs (deleteAround g a ps)", "by (rule isTable_subset, rule deleteAround_subset,\n    rule isTable_Cons)"], ["", "lemma ListSum_ExcessNotAtRecList:\n \"isTable E vs ps \\<Longrightarrow> ExcessNotAtRec ps g\n  = (\\<Sum>\\<^bsub>p \\<in> ExcessNotAtRecList ps g\\<^esub> E p)\" (is \"?T ps \\<Longrightarrow> ?P ps\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. isTable E vs ps \\<Longrightarrow>\n    ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E", "proof (induct ps rule: ExcessNotAtRecList.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. isTable E vs [] \\<Longrightarrow>\n    ExcessNotAtRec [] g = ListSum (ExcessNotAtRecList [] g) E\n 2. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E vs ps \\<Longrightarrow>\n                   ExcessNotAtRec ps g =\n                   ListSum (ExcessNotAtRecList ps g) E;\n        \\<And>xa xb.\n           \\<lbrakk>xb = ExcessNotAtRecList ps xa;\n            isTable E vs (deleteAround xa x ps)\\<rbrakk>\n           \\<Longrightarrow> ExcessNotAtRec (deleteAround xa x ps) g =\n                             ListSum\n                              (ExcessNotAtRecList (deleteAround xa x ps) g)\n                              E;\n        isTable E vs ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec ((x, y) # ps) g =\n                         ListSum (ExcessNotAtRecList ((x, y) # ps) g) E", "case 1"], ["proof (state)\nthis:\n  isTable E vs []\n\ngoal (2 subgoals):\n 1. isTable E vs [] \\<Longrightarrow>\n    ExcessNotAtRec [] g = ListSum (ExcessNotAtRecList [] g) E\n 2. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E vs ps \\<Longrightarrow>\n                   ExcessNotAtRec ps g =\n                   ListSum (ExcessNotAtRecList ps g) E;\n        \\<And>xa xb.\n           \\<lbrakk>xb = ExcessNotAtRecList ps xa;\n            isTable E vs (deleteAround xa x ps)\\<rbrakk>\n           \\<Longrightarrow> ExcessNotAtRec (deleteAround xa x ps) g =\n                             ListSum\n                              (ExcessNotAtRecList (deleteAround xa x ps) g)\n                              E;\n        isTable E vs ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec ((x, y) # ps) g =\n                         ListSum (ExcessNotAtRecList ((x, y) # ps) g) E", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ExcessNotAtRec [] g = ListSum (ExcessNotAtRecList [] g) E", "by simp"], ["proof (state)\nthis:\n  ExcessNotAtRec [] g = ListSum (ExcessNotAtRecList [] g) E\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E vs ps \\<Longrightarrow>\n                   ExcessNotAtRec ps g =\n                   ListSum (ExcessNotAtRecList ps g) E;\n        \\<And>xa xb.\n           \\<lbrakk>xb = ExcessNotAtRecList ps xa;\n            isTable E vs (deleteAround xa x ps)\\<rbrakk>\n           \\<Longrightarrow> ExcessNotAtRec (deleteAround xa x ps) g =\n                             ListSum\n                              (ExcessNotAtRecList (deleteAround xa x ps) g)\n                              E;\n        isTable E vs ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec ((x, y) # ps) g =\n                         ListSum (ExcessNotAtRecList ((x, y) # ps) g) E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E vs ps \\<Longrightarrow>\n                   ExcessNotAtRec ps g =\n                   ListSum (ExcessNotAtRecList ps g) E;\n        \\<And>xa xb.\n           \\<lbrakk>xb = ExcessNotAtRecList ps xa;\n            isTable E vs (deleteAround xa x ps)\\<rbrakk>\n           \\<Longrightarrow> ExcessNotAtRec (deleteAround xa x ps) g =\n                             ListSum\n                              (ExcessNotAtRecList (deleteAround xa x ps) g)\n                              E;\n        isTable E vs ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec ((x, y) # ps) g =\n                         ListSum (ExcessNotAtRecList ((x, y) # ps) g) E", "case (2 a b ps)"], ["proof (state)\nthis:\n  isTable E vs ps \\<Longrightarrow>\n  ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E\n  \\<lbrakk>?xb = ExcessNotAtRecList ps ?xa;\n   isTable E vs (deleteAround ?xa a ps)\\<rbrakk>\n  \\<Longrightarrow> ExcessNotAtRec (deleteAround ?xa a ps) g =\n                    ListSum (ExcessNotAtRecList (deleteAround ?xa a ps) g) E\n  isTable E vs ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E vs ps \\<Longrightarrow>\n                   ExcessNotAtRec ps g =\n                   ListSum (ExcessNotAtRecList ps g) E;\n        \\<And>xa xb.\n           \\<lbrakk>xb = ExcessNotAtRecList ps xa;\n            isTable E vs (deleteAround xa x ps)\\<rbrakk>\n           \\<Longrightarrow> ExcessNotAtRec (deleteAround xa x ps) g =\n                             ListSum\n                              (ExcessNotAtRecList (deleteAround xa x ps) g)\n                              E;\n        isTable E vs ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec ((x, y) # ps) g =\n                         ListSum (ExcessNotAtRecList ((x, y) # ps) g) E", "from 2"], ["proof (chain)\npicking this:\n  isTable E vs ps \\<Longrightarrow>\n  ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E\n  \\<lbrakk>?xb = ExcessNotAtRecList ps ?xa;\n   isTable E vs (deleteAround ?xa a ps)\\<rbrakk>\n  \\<Longrightarrow> ExcessNotAtRec (deleteAround ?xa a ps) g =\n                    ListSum (ExcessNotAtRecList (deleteAround ?xa a ps) g) E\n  isTable E vs ((a, b) # ps)", "have prem: \"?T ((a,b)#ps)\""], ["proof (prove)\nusing this:\n  isTable E vs ps \\<Longrightarrow>\n  ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E\n  \\<lbrakk>?xb = ExcessNotAtRecList ps ?xa;\n   isTable E vs (deleteAround ?xa a ps)\\<rbrakk>\n  \\<Longrightarrow> ExcessNotAtRec (deleteAround ?xa a ps) g =\n                    ListSum (ExcessNotAtRecList (deleteAround ?xa a ps) g) E\n  isTable E vs ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. isTable E vs ((a, b) # ps)", "by blast"], ["proof (state)\nthis:\n  isTable E vs ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E vs ps \\<Longrightarrow>\n                   ExcessNotAtRec ps g =\n                   ListSum (ExcessNotAtRecList ps g) E;\n        \\<And>xa xb.\n           \\<lbrakk>xb = ExcessNotAtRecList ps xa;\n            isTable E vs (deleteAround xa x ps)\\<rbrakk>\n           \\<Longrightarrow> ExcessNotAtRec (deleteAround xa x ps) g =\n                             ListSum\n                              (ExcessNotAtRecList (deleteAround xa x ps) g)\n                              E;\n        isTable E vs ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec ((x, y) # ps) g =\n                         ListSum (ExcessNotAtRecList ((x, y) # ps) g) E", "then"], ["proof (chain)\npicking this:\n  isTable E vs ((a, b) # ps)", "have E: \"b = E a\""], ["proof (prove)\nusing this:\n  isTable E vs ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. b = E a", "by (simp add: isTable_eq)"], ["proof (state)\nthis:\n  b = E a\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E vs ps \\<Longrightarrow>\n                   ExcessNotAtRec ps g =\n                   ListSum (ExcessNotAtRecList ps g) E;\n        \\<And>xa xb.\n           \\<lbrakk>xb = ExcessNotAtRecList ps xa;\n            isTable E vs (deleteAround xa x ps)\\<rbrakk>\n           \\<Longrightarrow> ExcessNotAtRec (deleteAround xa x ps) g =\n                             ListSum\n                              (ExcessNotAtRecList (deleteAround xa x ps) g)\n                              E;\n        isTable E vs ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec ((x, y) # ps) g =\n                         ListSum (ExcessNotAtRecList ((x, y) # ps) g) E", "from 2"], ["proof (chain)\npicking this:\n  isTable E vs ps \\<Longrightarrow>\n  ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E\n  \\<lbrakk>?xb = ExcessNotAtRecList ps ?xa;\n   isTable E vs (deleteAround ?xa a ps)\\<rbrakk>\n  \\<Longrightarrow> ExcessNotAtRec (deleteAround ?xa a ps) g =\n                    ListSum (ExcessNotAtRecList (deleteAround ?xa a ps) g) E\n  isTable E vs ((a, b) # ps)", "have hyp1: \"?T (deleteAround g a ps) \\<Longrightarrow>\n   ?P (deleteAround g a ps)\""], ["proof (prove)\nusing this:\n  isTable E vs ps \\<Longrightarrow>\n  ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E\n  \\<lbrakk>?xb = ExcessNotAtRecList ps ?xa;\n   isTable E vs (deleteAround ?xa a ps)\\<rbrakk>\n  \\<Longrightarrow> ExcessNotAtRec (deleteAround ?xa a ps) g =\n                    ListSum (ExcessNotAtRecList (deleteAround ?xa a ps) g) E\n  isTable E vs ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. isTable E vs (deleteAround g a ps) \\<Longrightarrow>\n    ExcessNotAtRec (deleteAround g a ps) g =\n    ListSum (ExcessNotAtRecList (deleteAround g a ps) g) E", "by blast"], ["proof (state)\nthis:\n  isTable E vs (deleteAround g a ps) \\<Longrightarrow>\n  ExcessNotAtRec (deleteAround g a ps) g =\n  ListSum (ExcessNotAtRecList (deleteAround g a ps) g) E\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E vs ps \\<Longrightarrow>\n                   ExcessNotAtRec ps g =\n                   ListSum (ExcessNotAtRecList ps g) E;\n        \\<And>xa xb.\n           \\<lbrakk>xb = ExcessNotAtRecList ps xa;\n            isTable E vs (deleteAround xa x ps)\\<rbrakk>\n           \\<Longrightarrow> ExcessNotAtRec (deleteAround xa x ps) g =\n                             ListSum\n                              (ExcessNotAtRecList (deleteAround xa x ps) g)\n                              E;\n        isTable E vs ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec ((x, y) # ps) g =\n                         ListSum (ExcessNotAtRecList ((x, y) # ps) g) E", "from 2"], ["proof (chain)\npicking this:\n  isTable E vs ps \\<Longrightarrow>\n  ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E\n  \\<lbrakk>?xb = ExcessNotAtRecList ps ?xa;\n   isTable E vs (deleteAround ?xa a ps)\\<rbrakk>\n  \\<Longrightarrow> ExcessNotAtRec (deleteAround ?xa a ps) g =\n                    ListSum (ExcessNotAtRecList (deleteAround ?xa a ps) g) E\n  isTable E vs ((a, b) # ps)", "have hyp2:  \"?T ps \\<Longrightarrow> ?P ps\""], ["proof (prove)\nusing this:\n  isTable E vs ps \\<Longrightarrow>\n  ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E\n  \\<lbrakk>?xb = ExcessNotAtRecList ps ?xa;\n   isTable E vs (deleteAround ?xa a ps)\\<rbrakk>\n  \\<Longrightarrow> ExcessNotAtRec (deleteAround ?xa a ps) g =\n                    ListSum (ExcessNotAtRecList (deleteAround ?xa a ps) g) E\n  isTable E vs ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. isTable E vs ps \\<Longrightarrow>\n    ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E", "by blast"], ["proof (state)\nthis:\n  isTable E vs ps \\<Longrightarrow>\n  ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E vs ps \\<Longrightarrow>\n                   ExcessNotAtRec ps g =\n                   ListSum (ExcessNotAtRecList ps g) E;\n        \\<And>xa xb.\n           \\<lbrakk>xb = ExcessNotAtRecList ps xa;\n            isTable E vs (deleteAround xa x ps)\\<rbrakk>\n           \\<Longrightarrow> ExcessNotAtRec (deleteAround xa x ps) g =\n                             ListSum\n                              (ExcessNotAtRecList (deleteAround xa x ps) g)\n                              E;\n        isTable E vs ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec ((x, y) # ps) g =\n                         ListSum (ExcessNotAtRecList ((x, y) # ps) g) E", "have H1: \"?P (deleteAround g a ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ExcessNotAtRec (deleteAround g a ps) g =\n    ListSum (ExcessNotAtRecList (deleteAround g a ps) g) E", "by (rule hyp1, rule isTable_deleteAround) (rule prem)"], ["proof (state)\nthis:\n  ExcessNotAtRec (deleteAround g a ps) g =\n  ListSum (ExcessNotAtRecList (deleteAround g a ps) g) E\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E vs ps \\<Longrightarrow>\n                   ExcessNotAtRec ps g =\n                   ListSum (ExcessNotAtRecList ps g) E;\n        \\<And>xa xb.\n           \\<lbrakk>xb = ExcessNotAtRecList ps xa;\n            isTable E vs (deleteAround xa x ps)\\<rbrakk>\n           \\<Longrightarrow> ExcessNotAtRec (deleteAround xa x ps) g =\n                             ListSum\n                              (ExcessNotAtRecList (deleteAround xa x ps) g)\n                              E;\n        isTable E vs ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec ((x, y) # ps) g =\n                         ListSum (ExcessNotAtRecList ((x, y) # ps) g) E", "have H2: \"?P ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E", "by (rule hyp2, rule isTable_Cons, rule prem)"], ["proof (state)\nthis:\n  ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E vs ps \\<Longrightarrow>\n                   ExcessNotAtRec ps g =\n                   ListSum (ExcessNotAtRecList ps g) E;\n        \\<And>xa xb.\n           \\<lbrakk>xb = ExcessNotAtRecList ps xa;\n            isTable E vs (deleteAround xa x ps)\\<rbrakk>\n           \\<Longrightarrow> ExcessNotAtRec (deleteAround xa x ps) g =\n                             ListSum\n                              (ExcessNotAtRecList (deleteAround xa x ps) g)\n                              E;\n        isTable E vs ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> ExcessNotAtRec ((x, y) # ps) g =\n                         ListSum (ExcessNotAtRecList ((x, y) # ps) g) E", "show \"?P ((a,b)#ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ExcessNotAtRec ((a, b) # ps) g =\n    ListSum (ExcessNotAtRecList ((a, b) # ps) g) E", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ExcessNotAtRec ((a, b) # ps) g =\n    ListSum (ExcessNotAtRecList ((a, b) # ps) g) E\n 2. \\<not> ?P \\<Longrightarrow>\n    ExcessNotAtRec ((a, b) # ps) g =\n    ListSum (ExcessNotAtRecList ((a, b) # ps) g) E", "assume\n    \"ExcessNotAtRec ps g\n    \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\""], ["proof (state)\nthis:\n  ExcessNotAtRec ps g \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ExcessNotAtRec ((a, b) # ps) g =\n    ListSum (ExcessNotAtRecList ((a, b) # ps) g) E\n 2. \\<not> ?P \\<Longrightarrow>\n    ExcessNotAtRec ((a, b) # ps) g =\n    ListSum (ExcessNotAtRecList ((a, b) # ps) g) E", "with H1 E"], ["proof (chain)\npicking this:\n  ExcessNotAtRec (deleteAround g a ps) g =\n  ListSum (ExcessNotAtRecList (deleteAround g a ps) g) E\n  b = E a\n  ExcessNotAtRec ps g \\<le> b + ExcessNotAtRec (deleteAround g a ps) g", "show ?thesis"], ["proof (prove)\nusing this:\n  ExcessNotAtRec (deleteAround g a ps) g =\n  ListSum (ExcessNotAtRecList (deleteAround g a ps) g) E\n  b = E a\n  ExcessNotAtRec ps g \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n\ngoal (1 subgoal):\n 1. ExcessNotAtRec ((a, b) # ps) g =\n    ListSum (ExcessNotAtRecList ((a, b) # ps) g) E", "by (simp add: max_def split: if_split_asm)"], ["proof (state)\nthis:\n  ExcessNotAtRec ((a, b) # ps) g =\n  ListSum (ExcessNotAtRecList ((a, b) # ps) g) E\n\ngoal (1 subgoal):\n 1. \\<not> ExcessNotAtRec ps g\n           \\<le> b +\n                 ExcessNotAtRec (deleteAround g a ps) g \\<Longrightarrow>\n    ExcessNotAtRec ((a, b) # ps) g =\n    ListSum (ExcessNotAtRecList ((a, b) # ps) g) E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ExcessNotAtRec ps g\n           \\<le> b +\n                 ExcessNotAtRec (deleteAround g a ps) g \\<Longrightarrow>\n    ExcessNotAtRec ((a, b) # ps) g =\n    ListSum (ExcessNotAtRecList ((a, b) # ps) g) E", "assume \"\\<not> ExcessNotAtRec ps g\n       \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\""], ["proof (state)\nthis:\n  \\<not> ExcessNotAtRec ps g\n         \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n\ngoal (1 subgoal):\n 1. \\<not> ExcessNotAtRec ps g\n           \\<le> b +\n                 ExcessNotAtRec (deleteAround g a ps) g \\<Longrightarrow>\n    ExcessNotAtRec ((a, b) # ps) g =\n    ListSum (ExcessNotAtRecList ((a, b) # ps) g) E", "with H2 E"], ["proof (chain)\npicking this:\n  ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E\n  b = E a\n  \\<not> ExcessNotAtRec ps g\n         \\<le> b + ExcessNotAtRec (deleteAround g a ps) g", "show ?thesis"], ["proof (prove)\nusing this:\n  ExcessNotAtRec ps g = ListSum (ExcessNotAtRecList ps g) E\n  b = E a\n  \\<not> ExcessNotAtRec ps g\n         \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n\ngoal (1 subgoal):\n 1. ExcessNotAtRec ((a, b) # ps) g =\n    ListSum (ExcessNotAtRecList ((a, b) # ps) g) E", "by (simp add: max_def split: if_split_asm)"], ["proof (state)\nthis:\n  ExcessNotAtRec ((a, b) # ps) g =\n  ListSum (ExcessNotAtRecList ((a, b) # ps) g) E\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ExcessNotAtRec ((a, b) # ps) g =\n  ListSum (ExcessNotAtRecList ((a, b) # ps) g) E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ExcessNotAtRecList_subset:\n  \"set (ExcessNotAtRecList ps g) \\<subseteq> set [fst p. p \\<leftarrow> ps]\" (is \"?P ps\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList ps g) \\<subseteq> set (map fst ps)", "proof (induct ps rule: ExcessNotAtRecList.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (ExcessNotAtRecList [] g) \\<subseteq> set (map fst [])\n 2. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   set (ExcessNotAtRecList ps g)\n                   \\<subseteq> set (map fst ps);\n        \\<And>xa xb.\n           xb = ExcessNotAtRecList ps xa \\<Longrightarrow>\n           set (ExcessNotAtRecList (deleteAround xa x ps) g)\n           \\<subseteq> set (map fst (deleteAround xa x ps))\\<rbrakk>\n       \\<Longrightarrow> set (ExcessNotAtRecList ((x, y) # ps) g)\n                         \\<subseteq> set (map fst ((x, y) # ps))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. set (ExcessNotAtRecList [] g) \\<subseteq> set (map fst [])\n 2. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   set (ExcessNotAtRecList ps g)\n                   \\<subseteq> set (map fst ps);\n        \\<And>xa xb.\n           xb = ExcessNotAtRecList ps xa \\<Longrightarrow>\n           set (ExcessNotAtRecList (deleteAround xa x ps) g)\n           \\<subseteq> set (map fst (deleteAround xa x ps))\\<rbrakk>\n       \\<Longrightarrow> set (ExcessNotAtRecList ((x, y) # ps) g)\n                         \\<subseteq> set (map fst ((x, y) # ps))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList [] g) \\<subseteq> set (map fst [])", "by simp"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList [] g) \\<subseteq> set (map fst [])\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   set (ExcessNotAtRecList ps g)\n                   \\<subseteq> set (map fst ps);\n        \\<And>xa xb.\n           xb = ExcessNotAtRecList ps xa \\<Longrightarrow>\n           set (ExcessNotAtRecList (deleteAround xa x ps) g)\n           \\<subseteq> set (map fst (deleteAround xa x ps))\\<rbrakk>\n       \\<Longrightarrow> set (ExcessNotAtRecList ((x, y) # ps) g)\n                         \\<subseteq> set (map fst ((x, y) # ps))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   set (ExcessNotAtRecList ps g)\n                   \\<subseteq> set (map fst ps);\n        \\<And>xa xb.\n           xb = ExcessNotAtRecList ps xa \\<Longrightarrow>\n           set (ExcessNotAtRecList (deleteAround xa x ps) g)\n           \\<subseteq> set (map fst (deleteAround xa x ps))\\<rbrakk>\n       \\<Longrightarrow> set (ExcessNotAtRecList ((x, y) # ps) g)\n                         \\<subseteq> set (map fst ((x, y) # ps))", "case (2 a b ps)"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList ps g) \\<subseteq> set (map fst ps)\n  ?xb = ExcessNotAtRecList ps ?xa \\<Longrightarrow>\n  set (ExcessNotAtRecList (deleteAround ?xa a ps) g)\n  \\<subseteq> set (map fst (deleteAround ?xa a ps))\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   set (ExcessNotAtRecList ps g)\n                   \\<subseteq> set (map fst ps);\n        \\<And>xa xb.\n           xb = ExcessNotAtRecList ps xa \\<Longrightarrow>\n           set (ExcessNotAtRecList (deleteAround xa x ps) g)\n           \\<subseteq> set (map fst (deleteAround xa x ps))\\<rbrakk>\n       \\<Longrightarrow> set (ExcessNotAtRecList ((x, y) # ps) g)\n                         \\<subseteq> set (map fst ((x, y) # ps))", "presume H1: \"?P (deleteAround g a ps)\""], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   set (ExcessNotAtRecList ps g)\n                   \\<subseteq> set (map fst ps);\n        \\<And>xa xb.\n           xb = ExcessNotAtRecList ps xa \\<Longrightarrow>\n           set (ExcessNotAtRecList (deleteAround xa x ps) g)\n           \\<subseteq> set (map fst (deleteAround xa x ps))\\<rbrakk>\n       \\<Longrightarrow> set (ExcessNotAtRecList ((x, y) # ps) g)\n                         \\<subseteq> set (map fst ((x, y) # ps))", "presume H2: \"?P ps\""], ["proof (state)\nthis:\n  set (ExcessNotAtRecList ps g) \\<subseteq> set (map fst ps)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   set (ExcessNotAtRecList ps g)\n                   \\<subseteq> set (map fst ps);\n        \\<And>xa xb.\n           xb = ExcessNotAtRecList ps xa \\<Longrightarrow>\n           set (ExcessNotAtRecList (deleteAround xa x ps) g)\n           \\<subseteq> set (map fst (deleteAround xa x ps))\\<rbrakk>\n       \\<Longrightarrow> set (ExcessNotAtRecList ((x, y) # ps) g)\n                         \\<subseteq> set (map fst ((x, y) # ps))", "show \"?P ((a, b) # ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))\n 2. \\<not> ?P \\<Longrightarrow>\n    set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))", "assume a: \"ExcessNotAtRec ps g\n      \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\""], ["proof (state)\nthis:\n  ExcessNotAtRec ps g \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))\n 2. \\<not> ?P \\<Longrightarrow>\n    set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))", "have \"set (deleteAround g a ps) \\<subseteq> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (deleteAround g a ps) \\<subseteq> set ps", "by (simp add: deleteAround_subset)"], ["proof (state)\nthis:\n  set (deleteAround g a ps) \\<subseteq> set ps\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))\n 2. \\<not> ?P \\<Longrightarrow>\n    set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))", "then"], ["proof (chain)\npicking this:\n  set (deleteAround g a ps) \\<subseteq> set ps", "have\n    \"fst ` set (deleteAround g a ps) \\<subseteq> insert a (fst ` set ps)\""], ["proof (prove)\nusing this:\n  set (deleteAround g a ps) \\<subseteq> set ps\n\ngoal (1 subgoal):\n 1. fst ` set (deleteAround g a ps) \\<subseteq> insert a (fst ` set ps)", "by blast"], ["proof (state)\nthis:\n  fst ` set (deleteAround g a ps) \\<subseteq> insert a (fst ` set ps)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))\n 2. \\<not> ?P \\<Longrightarrow>\n    set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))", "with a H1"], ["proof (chain)\npicking this:\n  ExcessNotAtRec ps g \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))\n  fst ` set (deleteAround g a ps) \\<subseteq> insert a (fst ` set ps)", "show ?thesis"], ["proof (prove)\nusing this:\n  ExcessNotAtRec ps g \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))\n  fst ` set (deleteAround g a ps) \\<subseteq> insert a (fst ` set ps)\n\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))", "by (simp)"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList ((a, b) # ps) g)\n  \\<subseteq> set (map fst ((a, b) # ps))\n\ngoal (1 subgoal):\n 1. \\<not> ExcessNotAtRec ps g\n           \\<le> b +\n                 ExcessNotAtRec (deleteAround g a ps) g \\<Longrightarrow>\n    set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ExcessNotAtRec ps g\n           \\<le> b +\n                 ExcessNotAtRec (deleteAround g a ps) g \\<Longrightarrow>\n    set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))", "assume \"\\<not> ExcessNotAtRec ps g\n      \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\""], ["proof (state)\nthis:\n  \\<not> ExcessNotAtRec ps g\n         \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n\ngoal (1 subgoal):\n 1. \\<not> ExcessNotAtRec ps g\n           \\<le> b +\n                 ExcessNotAtRec (deleteAround g a ps) g \\<Longrightarrow>\n    set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))", "with H2"], ["proof (chain)\npicking this:\n  set (ExcessNotAtRecList ps g) \\<subseteq> set (map fst ps)\n  \\<not> ExcessNotAtRec ps g\n         \\<le> b + ExcessNotAtRec (deleteAround g a ps) g", "show ?thesis"], ["proof (prove)\nusing this:\n  set (ExcessNotAtRecList ps g) \\<subseteq> set (map fst ps)\n  \\<not> ExcessNotAtRec ps g\n         \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList ((a, b) # ps) g)\n    \\<subseteq> set (map fst ((a, b) # ps))", "by (auto)"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList ((a, b) # ps) g)\n  \\<subseteq> set (map fst ((a, b) # ps))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList ((a, b) # ps) g)\n  \\<subseteq> set (map fst ((a, b) # ps))\n\ngoal (2 subgoals):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   set (ExcessNotAtRecList ps g)\n                   \\<subseteq> set (map fst ps);\n        \\<And>xa xb.\n           xb = ExcessNotAtRecList ps xa \\<Longrightarrow>\n           set (ExcessNotAtRecList (deleteAround xa x ps) g)\n           \\<subseteq> set (map fst (deleteAround xa x ps))\\<rbrakk>\n       \\<Longrightarrow> set (ExcessNotAtRecList (deleteAround g x ps) g)\n                         \\<subseteq> set (map fst (deleteAround g x ps))\n 2. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   set (ExcessNotAtRecList ps g)\n                   \\<subseteq> set (map fst ps);\n        \\<And>xa xb.\n           xb = ExcessNotAtRecList ps xa \\<Longrightarrow>\n           set (ExcessNotAtRecList (deleteAround xa x ps) g)\n           \\<subseteq> set (map fst (deleteAround xa x ps))\\<rbrakk>\n       \\<Longrightarrow> set (ExcessNotAtRecList ps g)\n                         \\<subseteq> set (map fst ps)", "qed simp"], ["", "lemma separated_ExcessNotAtRecList:\n \"minGraphProps g \\<Longrightarrow> final g \\<Longrightarrow> isTable E (vertices g) ps \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList ps g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; final g; isTable E (vertices g) ps\\<rbrakk>\n    \\<Longrightarrow> separated g (set (ExcessNotAtRecList ps g))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; final g; isTable E (vertices g) ps\\<rbrakk>\n    \\<Longrightarrow> separated g (set (ExcessNotAtRecList ps g))", "assume fin: \"final g\" and mgp: \"minGraphProps g\""], ["proof (state)\nthis:\n  final g\n  minGraphProps g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; final g; isTable E (vertices g) ps\\<rbrakk>\n    \\<Longrightarrow> separated g (set (ExcessNotAtRecList ps g))", "show\n   \"isTable E (vertices g) ps \\<Longrightarrow> separated g (set (ExcessNotAtRecList ps g))\"\n   (is \"?T ps \\<Longrightarrow> ?P ps\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. isTable E (vertices g) ps \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList ps g))", "proof (induct rule: ExcessNotAtRec.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. isTable E (vertices g) [] \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList [] g))\n 2. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "case 1"], ["proof (state)\nthis:\n  isTable E (vertices g) []\n\ngoal (2 subgoals):\n 1. isTable E (vertices g) [] \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList [] g))\n 2. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. separated g (set (ExcessNotAtRecList [] g))", "by simp"], ["proof (state)\nthis:\n  separated g (set (ExcessNotAtRecList [] g))\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "case (2 a b ps)"], ["proof (state)\nthis:\n  isTable E (vertices g) ps \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList ps g))\n  isTable E (vertices g) (deleteAround ?xa a ps) \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList (deleteAround ?xa a ps) g))\n  isTable E (vertices g) ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "from 2"], ["proof (chain)\npicking this:\n  isTable E (vertices g) ps \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList ps g))\n  isTable E (vertices g) (deleteAround ?xa a ps) \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList (deleteAround ?xa a ps) g))\n  isTable E (vertices g) ((a, b) # ps)", "have prem: \"?T ((a,b)#ps)\""], ["proof (prove)\nusing this:\n  isTable E (vertices g) ps \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList ps g))\n  isTable E (vertices g) (deleteAround ?xa a ps) \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList (deleteAround ?xa a ps) g))\n  isTable E (vertices g) ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. isTable E (vertices g) ((a, b) # ps)", "by blast"], ["proof (state)\nthis:\n  isTable E (vertices g) ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "then"], ["proof (chain)\npicking this:\n  isTable E (vertices g) ((a, b) # ps)", "have E: \"b = E a\""], ["proof (prove)\nusing this:\n  isTable E (vertices g) ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. b = E a", "by (simp add: isTable_eq)"], ["proof (state)\nthis:\n  b = E a\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "have \"a :\\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<V> g", "using prem"], ["proof (prove)\nusing this:\n  isTable E (vertices g) ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V> g", "by(auto simp: isTable_def)"], ["proof (state)\nthis:\n  a \\<in> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "from 2"], ["proof (chain)\npicking this:\n  isTable E (vertices g) ps \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList ps g))\n  isTable E (vertices g) (deleteAround ?xa a ps) \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList (deleteAround ?xa a ps) g))\n  isTable E (vertices g) ((a, b) # ps)", "have hyp1: \"?T (deleteAround g a ps) \\<Longrightarrow>\n      ?P (deleteAround g a ps)\""], ["proof (prove)\nusing this:\n  isTable E (vertices g) ps \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList ps g))\n  isTable E (vertices g) (deleteAround ?xa a ps) \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList (deleteAround ?xa a ps) g))\n  isTable E (vertices g) ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. isTable E (vertices g) (deleteAround g a ps) \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))", "by blast"], ["proof (state)\nthis:\n  isTable E (vertices g) (deleteAround g a ps) \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "from 2"], ["proof (chain)\npicking this:\n  isTable E (vertices g) ps \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList ps g))\n  isTable E (vertices g) (deleteAround ?xa a ps) \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList (deleteAround ?xa a ps) g))\n  isTable E (vertices g) ((a, b) # ps)", "have hyp2:  \"?T ps \\<Longrightarrow> ?P ps\""], ["proof (prove)\nusing this:\n  isTable E (vertices g) ps \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList ps g))\n  isTable E (vertices g) (deleteAround ?xa a ps) \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList (deleteAround ?xa a ps) g))\n  isTable E (vertices g) ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. isTable E (vertices g) ps \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList ps g))", "by blast"], ["proof (state)\nthis:\n  isTable E (vertices g) ps \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList ps g))\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "have H1: \"?P (deleteAround g a ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))", "by (rule hyp1, rule isTable_deleteAround) (rule prem)"], ["proof (state)\nthis:\n  separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "have H2: \"?P ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated g (set (ExcessNotAtRecList ps g))", "by (rule hyp2, rule isTable_Cons) (rule prem)"], ["proof (state)\nthis:\n  separated g (set (ExcessNotAtRecList ps g))\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   isTable E (vertices g) ps \\<Longrightarrow>\n                   separated g (set (ExcessNotAtRecList ps g));\n        \\<And>xa.\n           isTable E (vertices g) (deleteAround xa x ps) \\<Longrightarrow>\n           separated g (set (ExcessNotAtRecList (deleteAround xa x ps) g));\n        isTable E (vertices g) ((x, y) # ps)\\<rbrakk>\n       \\<Longrightarrow> separated g\n                          (set (ExcessNotAtRecList ((x, y) # ps) g))", "show \"?P ((a,b)#ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated g (set (ExcessNotAtRecList ((a, b) # ps) g))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList ((a, b) # ps) g))\n 2. \\<not> ?P \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList ((a, b) # ps) g))", "assume c: \"ExcessNotAtRec ps g\n        \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\""], ["proof (state)\nthis:\n  ExcessNotAtRec ps g \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList ((a, b) # ps) g))\n 2. \\<not> ?P \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList ((a, b) # ps) g))", "have \"separated g\n       (insert a (set (ExcessNotAtRecList (deleteAround g a ps) g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated g\n     (insert a (set (ExcessNotAtRecList (deleteAround g a ps) g)))", "proof (rule separated_insert[OF mgp])"], ["proof (state)\ngoal (5 subgoals):\n 1. a \\<in> \\<V> g\n 2. set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g\n 3. separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))\n 4. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow>\n       f \\<bullet> a\n       \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n 5. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "from prem"], ["proof (chain)\npicking this:\n  isTable E (vertices g) ((a, b) # ps)", "show \"a \\<in> set (vertices g)\""], ["proof (prove)\nusing this:\n  isTable E (vertices g) ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V> g", "by (auto simp add: isTable_def)"], ["proof (state)\nthis:\n  a \\<in> \\<V> g\n\ngoal (4 subgoals):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g\n 2. separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))\n 3. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow>\n       f \\<bullet> a\n       \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n 4. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "show \"set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g", "have \"set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq>\n                set (map fst (deleteAround g a ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g)\n    \\<subseteq> set (map fst (deleteAround g a ps))", "by(rule ExcessNotAtRecList_subset[simplified concat_map_singleton])"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g", "also"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g", "have \"\\<dots> \\<subseteq> set (map fst ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (deleteAround g a ps)) \\<subseteq> set (map fst ps)", "using deleteAround_subset"], ["proof (prove)\nusing this:\n  set (deleteAround ?g ?a ?ps) \\<subseteq> set ?ps\n\ngoal (1 subgoal):\n 1. set (map fst (deleteAround g a ps)) \\<subseteq> set (map fst ps)", "by fastforce"], ["proof (state)\nthis:\n  set (map fst (deleteAround g a ps)) \\<subseteq> set (map fst ps)\n\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g", "finally"], ["proof (chain)\npicking this:\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst ps)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst ps)\n\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g", "using prem"], ["proof (prove)\nusing this:\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst ps)\n  isTable E (vertices g) ((a, b) # ps)\n\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g", "by(auto simp: isTable_def)"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> \\<V> g\n\ngoal (3 subgoals):\n 1. separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))\n 2. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow>\n       f \\<bullet> a\n       \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n 3. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "from H1"], ["proof (chain)\npicking this:\n  separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))", "show pS: \"separated g\n            (set (ExcessNotAtRecList (deleteAround g a ps) g))\""], ["proof (prove)\nusing this:\n  separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))\n\ngoal (1 subgoal):\n 1. separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))", "by simp"], ["proof (state)\nthis:\n  separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow>\n       f \\<bullet> a\n       \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow>\n       f \\<bullet> a\n       \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "assume f: \"f \\<in> set (facesAt g a)\""], ["proof (state)\nthis:\n  f \\<in> set (facesAt g a)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow>\n       f \\<bullet> a\n       \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "then"], ["proof (chain)\npicking this:\n  f \\<in> set (facesAt g a)", "have\n        \"f \\<bullet> a \\<notin> set [fst p. p \\<leftarrow> deleteAround g a ps]\""], ["proof (prove)\nusing this:\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. f \\<bullet> a \\<notin> set (map fst (deleteAround g a ps))", "by (auto simp add: facesAt_def deleteAround_eq deleteAround'_def\n            removeKeyList_eq split: if_split_asm)"], ["proof (state)\nthis:\n  f \\<bullet> a \\<notin> set (map fst (deleteAround g a ps))\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow>\n       f \\<bullet> a\n       \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "moreover"], ["proof (state)\nthis:\n  f \\<bullet> a \\<notin> set (map fst (deleteAround g a ps))\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow>\n       f \\<bullet> a\n       \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "have \"set (ExcessNotAtRecList (deleteAround g a ps) g)\n          \\<subseteq> set [fst p. p \\<leftarrow> deleteAround g a ps]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g)\n    \\<subseteq> set (map fst (deleteAround g a ps))", "by (rule ExcessNotAtRecList_subset)"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<in> set (facesAt g a) \\<Longrightarrow>\n       f \\<bullet> a\n       \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "ultimately"], ["proof (chain)\npicking this:\n  f \\<bullet> a \\<notin> set (map fst (deleteAround g a ps))\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))", "show \"f \\<bullet> a\n          \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\""], ["proof (prove)\nusing this:\n  f \\<bullet> a \\<notin> set (map fst (deleteAround g a ps))\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. f \\<bullet> a \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)", "by auto"], ["proof (state)\nthis:\n  f \\<bullet> a \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "assume \"|vertices f| \\<le> 4\""], ["proof (state)\nthis:\n  |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "from this f"], ["proof (chain)\npicking this:\n  |vertices f| \\<le> 4\n  f \\<in> set (facesAt g a)", "have \"set (vertices f)\n          \\<inter> set [fst p. p \\<leftarrow> deleteAround g a ps] \\<subseteq> {a}\""], ["proof (prove)\nusing this:\n  |vertices f| \\<le> 4\n  f \\<in> set (facesAt g a)\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}", "by (rule deleteAround_separated[OF mgp fin \\<open>a : \\<V> g\\<close>])"], ["proof (state)\nthis:\n  \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "moreover"], ["proof (state)\nthis:\n  \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "have \"set (ExcessNotAtRecList (deleteAround g a ps) g)\n          \\<subseteq> set [fst p. p \\<leftarrow> deleteAround g a ps]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g)\n    \\<subseteq> set (map fst (deleteAround g a ps))", "by (rule ExcessNotAtRecList_subset)"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g a); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter>\n                         set (ExcessNotAtRecList (deleteAround g a ps) g)\n                         \\<subseteq> {a}", "ultimately"], ["proof (chain)\npicking this:\n  \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))", "show \"set (vertices f)\n           \\<inter> set (ExcessNotAtRecList (deleteAround g a ps) g) \\<subseteq> {a}\""], ["proof (prove)\nusing this:\n  \\<V> f \\<inter> set (map fst (deleteAround g a ps)) \\<subseteq> {a}\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set (ExcessNotAtRecList (deleteAround g a ps) g)\n    \\<subseteq> {a}", "by blast"], ["proof (state)\nthis:\n  \\<V> f \\<inter> set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> {a}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separated g (insert a (set (ExcessNotAtRecList (deleteAround g a ps) g)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList ((a, b) # ps) g))\n 2. \\<not> ?P \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList ((a, b) # ps) g))", "with H1 E c"], ["proof (chain)\npicking this:\n  separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))\n  b = E a\n  ExcessNotAtRec ps g \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n  separated g (insert a (set (ExcessNotAtRecList (deleteAround g a ps) g)))", "show ?thesis"], ["proof (prove)\nusing this:\n  separated g (set (ExcessNotAtRecList (deleteAround g a ps) g))\n  b = E a\n  ExcessNotAtRec ps g \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n  separated g (insert a (set (ExcessNotAtRecList (deleteAround g a ps) g)))\n\ngoal (1 subgoal):\n 1. separated g (set (ExcessNotAtRecList ((a, b) # ps) g))", "by (simp)"], ["proof (state)\nthis:\n  separated g (set (ExcessNotAtRecList ((a, b) # ps) g))\n\ngoal (1 subgoal):\n 1. \\<not> ExcessNotAtRec ps g\n           \\<le> b +\n                 ExcessNotAtRec (deleteAround g a ps) g \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList ((a, b) # ps) g))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ExcessNotAtRec ps g\n           \\<le> b +\n                 ExcessNotAtRec (deleteAround g a ps) g \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList ((a, b) # ps) g))", "assume \"\\<not> ExcessNotAtRec ps g\n        \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\""], ["proof (state)\nthis:\n  \\<not> ExcessNotAtRec ps g\n         \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n\ngoal (1 subgoal):\n 1. \\<not> ExcessNotAtRec ps g\n           \\<le> b +\n                 ExcessNotAtRec (deleteAround g a ps) g \\<Longrightarrow>\n    separated g (set (ExcessNotAtRecList ((a, b) # ps) g))", "with H2 E"], ["proof (chain)\npicking this:\n  separated g (set (ExcessNotAtRecList ps g))\n  b = E a\n  \\<not> ExcessNotAtRec ps g\n         \\<le> b + ExcessNotAtRec (deleteAround g a ps) g", "show ?thesis"], ["proof (prove)\nusing this:\n  separated g (set (ExcessNotAtRecList ps g))\n  b = E a\n  \\<not> ExcessNotAtRec ps g\n         \\<le> b + ExcessNotAtRec (deleteAround g a ps) g\n\ngoal (1 subgoal):\n 1. separated g (set (ExcessNotAtRecList ((a, b) # ps) g))", "by simp"], ["proof (state)\nthis:\n  separated g (set (ExcessNotAtRecList ((a, b) # ps) g))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separated g (set (ExcessNotAtRecList ((a, b) # ps) g))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isTable E (vertices g) ps \\<Longrightarrow>\n  separated g (set (ExcessNotAtRecList ps g))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isTable_ExcessTable:\n  \"isTable (\\<lambda>v. ExcessAt g v) vs (ExcessTable g vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isTable (ExcessAt g) vs (ExcessTable g vs)", "by (auto simp add: isTable_def ExcessTable_def ExcessAt_def)"], ["", "lemma ExcessTable_subset:\n  \"set (map fst (ExcessTable g vs)) \\<subseteq> set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (ExcessTable g vs)) \\<subseteq> set vs", "by (induct vs) (auto simp add: ExcessTable_def)"], ["", "lemma distinct_ExcessNotAtRecList:\n  \"distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\"\n    (is \"?T ps \\<Longrightarrow> ?P ps\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ps) \\<Longrightarrow>\n    distinct (ExcessNotAtRecList ps g)", "proof (induct rule: ExcessNotAtRec.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (ExcessNotAtRecList [] g)\n 2. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "case 1"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (ExcessNotAtRecList [] g)\n 2. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ExcessNotAtRecList [] g)", "by simp"], ["proof (state)\nthis:\n  distinct (ExcessNotAtRecList [] g)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "case (2 a b ps)"], ["proof (state)\nthis:\n  distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\n  distinct (map fst (deleteAround ?xa a ps)) \\<Longrightarrow>\n  distinct (ExcessNotAtRecList (deleteAround ?xa a ps) g)\n  distinct (map fst ((a, b) # ps))\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "from 2"], ["proof (chain)\npicking this:\n  distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\n  distinct (map fst (deleteAround ?xa a ps)) \\<Longrightarrow>\n  distinct (ExcessNotAtRecList (deleteAround ?xa a ps) g)\n  distinct (map fst ((a, b) # ps))", "have prem: \"?T ((a,b)#ps)\""], ["proof (prove)\nusing this:\n  distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\n  distinct (map fst (deleteAround ?xa a ps)) \\<Longrightarrow>\n  distinct (ExcessNotAtRecList (deleteAround ?xa a ps) g)\n  distinct (map fst ((a, b) # ps))\n\ngoal (1 subgoal):\n 1. distinct (map fst ((a, b) # ps))", "by blast"], ["proof (state)\nthis:\n  distinct (map fst ((a, b) # ps))\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "then"], ["proof (chain)\npicking this:\n  distinct (map fst ((a, b) # ps))", "have a: \"a \\<notin> set (map fst ps)\""], ["proof (prove)\nusing this:\n  distinct (map fst ((a, b) # ps))\n\ngoal (1 subgoal):\n 1. a \\<notin> set (map fst ps)", "by simp"], ["proof (state)\nthis:\n  a \\<notin> set (map fst ps)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "from 2"], ["proof (chain)\npicking this:\n  distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\n  distinct (map fst (deleteAround ?xa a ps)) \\<Longrightarrow>\n  distinct (ExcessNotAtRecList (deleteAround ?xa a ps) g)\n  distinct (map fst ((a, b) # ps))", "have hyp1: \"?T (deleteAround g a ps) \\<Longrightarrow>\n    ?P (deleteAround g a ps)\""], ["proof (prove)\nusing this:\n  distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\n  distinct (map fst (deleteAround ?xa a ps)) \\<Longrightarrow>\n  distinct (ExcessNotAtRecList (deleteAround ?xa a ps) g)\n  distinct (map fst ((a, b) # ps))\n\ngoal (1 subgoal):\n 1. distinct (map fst (deleteAround g a ps)) \\<Longrightarrow>\n    distinct (ExcessNotAtRecList (deleteAround g a ps) g)", "by blast"], ["proof (state)\nthis:\n  distinct (map fst (deleteAround g a ps)) \\<Longrightarrow>\n  distinct (ExcessNotAtRecList (deleteAround g a ps) g)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "from 2"], ["proof (chain)\npicking this:\n  distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\n  distinct (map fst (deleteAround ?xa a ps)) \\<Longrightarrow>\n  distinct (ExcessNotAtRecList (deleteAround ?xa a ps) g)\n  distinct (map fst ((a, b) # ps))", "have hyp2:  \"?T ps \\<Longrightarrow> ?P ps\""], ["proof (prove)\nusing this:\n  distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\n  distinct (map fst (deleteAround ?xa a ps)) \\<Longrightarrow>\n  distinct (ExcessNotAtRecList (deleteAround ?xa a ps) g)\n  distinct (map fst ((a, b) # ps))\n\ngoal (1 subgoal):\n 1. distinct (map fst ps) \\<Longrightarrow>\n    distinct (ExcessNotAtRecList ps g)", "by blast"], ["proof (state)\nthis:\n  distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "from 2"], ["proof (chain)\npicking this:\n  distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\n  distinct (map fst (deleteAround ?xa a ps)) \\<Longrightarrow>\n  distinct (ExcessNotAtRecList (deleteAround ?xa a ps) g)\n  distinct (map fst ((a, b) # ps))", "have \"?T ps\""], ["proof (prove)\nusing this:\n  distinct (map fst ps) \\<Longrightarrow> distinct (ExcessNotAtRecList ps g)\n  distinct (map fst (deleteAround ?xa a ps)) \\<Longrightarrow>\n  distinct (ExcessNotAtRecList (deleteAround ?xa a ps) g)\n  distinct (map fst ((a, b) # ps))\n\ngoal (1 subgoal):\n 1. distinct (map fst ps)", "by simp"], ["proof (state)\nthis:\n  distinct (map fst ps)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "then"], ["proof (chain)\npicking this:\n  distinct (map fst ps)", "have H1: \"?P (deleteAround g a ps)\""], ["proof (prove)\nusing this:\n  distinct (map fst ps)\n\ngoal (1 subgoal):\n 1. distinct (ExcessNotAtRecList (deleteAround g a ps) g)", "by (rule_tac hyp1) (rule distinct_deleteAround [simplified])"], ["proof (state)\nthis:\n  distinct (ExcessNotAtRecList (deleteAround g a ps) g)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "from prem"], ["proof (chain)\npicking this:\n  distinct (map fst ((a, b) # ps))", "have H2: \"?P ps\""], ["proof (prove)\nusing this:\n  distinct (map fst ((a, b) # ps))\n\ngoal (1 subgoal):\n 1. distinct (ExcessNotAtRecList ps g)", "by (rule_tac hyp2) simp"], ["proof (state)\nthis:\n  distinct (ExcessNotAtRecList ps g)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "have \"a \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)", "(* auto ?? *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> set (ExcessNotAtRecList (deleteAround g a ps)\n                  g) \\<Longrightarrow>\n    False", "assume \"a \\<in> set (ExcessNotAtRecList (deleteAround g a ps) g)\""], ["proof (state)\nthis:\n  a \\<in> set (ExcessNotAtRecList (deleteAround g a ps) g)\n\ngoal (1 subgoal):\n 1. a \\<in> set (ExcessNotAtRecList (deleteAround g a ps)\n                  g) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  a \\<in> set (ExcessNotAtRecList (deleteAround g a ps) g)\n\ngoal (1 subgoal):\n 1. a \\<in> set (ExcessNotAtRecList (deleteAround g a ps)\n                  g) \\<Longrightarrow>\n    False", "have \"set (ExcessNotAtRecList (deleteAround g a ps) g)\n      \\<subseteq> set [fst p. p \\<leftarrow> deleteAround g a ps]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (deleteAround g a ps) g)\n    \\<subseteq> set (map fst (deleteAround g a ps))", "by (rule ExcessNotAtRecList_subset)"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. a \\<in> set (ExcessNotAtRecList (deleteAround g a ps)\n                  g) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (deleteAround g a ps) g)\n  \\<subseteq> set (map fst (deleteAround g a ps))\n\ngoal (1 subgoal):\n 1. a \\<in> set (ExcessNotAtRecList (deleteAround g a ps)\n                  g) \\<Longrightarrow>\n    False", "have \"set (deleteAround g a ps) \\<subseteq> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (deleteAround g a ps) \\<subseteq> set ps", "by (rule deleteAround_subset)"], ["proof (state)\nthis:\n  set (deleteAround g a ps) \\<subseteq> set ps\n\ngoal (1 subgoal):\n 1. a \\<in> set (ExcessNotAtRecList (deleteAround g a ps)\n                  g) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  set (deleteAround g a ps) \\<subseteq> set ps", "have \"set [fst p. p \\<leftarrow> deleteAround g a ps]\n      \\<subseteq> set [fst p. p \\<leftarrow> ps]\""], ["proof (prove)\nusing this:\n  set (deleteAround g a ps) \\<subseteq> set ps\n\ngoal (1 subgoal):\n 1. set (map fst (deleteAround g a ps)) \\<subseteq> set (map fst ps)", "by auto"], ["proof (state)\nthis:\n  set (map fst (deleteAround g a ps)) \\<subseteq> set (map fst ps)\n\ngoal (1 subgoal):\n 1. a \\<in> set (ExcessNotAtRecList (deleteAround g a ps)\n                  g) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  a \\<in> set (map fst ps)", "have \"a \\<in> set (map fst ps)\""], ["proof (prove)\nusing this:\n  a \\<in> set (map fst ps)\n\ngoal (1 subgoal):\n 1. a \\<in> set (map fst ps)", "by simp"], ["proof (state)\nthis:\n  a \\<in> set (map fst ps)\n\ngoal (1 subgoal):\n 1. a \\<in> set (ExcessNotAtRecList (deleteAround g a ps)\n                  g) \\<Longrightarrow>\n    False", "with a"], ["proof (chain)\npicking this:\n  a \\<notin> set (map fst ps)\n  a \\<in> set (map fst ps)", "show False"], ["proof (prove)\nusing this:\n  a \\<notin> set (map fst ps)\n  a \\<in> set (map fst ps)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n\ngoal (1 subgoal):\n 1. \\<And>x y ps.\n       \\<lbrakk>\\<And>xa.\n                   distinct (map fst ps) \\<Longrightarrow>\n                   distinct (ExcessNotAtRecList ps g);\n        \\<And>xa.\n           distinct (map fst (deleteAround xa x ps)) \\<Longrightarrow>\n           distinct (ExcessNotAtRecList (deleteAround xa x ps) g);\n        distinct (map fst ((x, y) # ps))\\<rbrakk>\n       \\<Longrightarrow> distinct (ExcessNotAtRecList ((x, y) # ps) g)", "with H1 H2"], ["proof (chain)\npicking this:\n  distinct (ExcessNotAtRecList (deleteAround g a ps) g)\n  distinct (ExcessNotAtRecList ps g)\n  a \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)", "show \"?P ((a,b)#ps)\""], ["proof (prove)\nusing this:\n  distinct (ExcessNotAtRecList (deleteAround g a ps) g)\n  distinct (ExcessNotAtRecList ps g)\n  a \\<notin> set (ExcessNotAtRecList (deleteAround g a ps) g)\n\ngoal (1 subgoal):\n 1. distinct (ExcessNotAtRecList ((a, b) # ps) g)", "by ( simp add: ExcessNotAtRecList_subset)"], ["proof (state)\nthis:\n  distinct (ExcessNotAtRecList ((a, b) # ps) g)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* alternative definition *)"], ["", "primrec ExcessTable_cont ::\n  \"(vertex \\<Rightarrow> nat) \\<Rightarrow> vertex list \\<Rightarrow> (vertex \\<times> nat) list\"\nwhere\n  \"ExcessTable_cont ExcessAtPG [] = []\" |\n  \"ExcessTable_cont ExcessAtPG (v#vs) =\n   (let vi = ExcessAtPG v in\n     if 0 < vi\n     then (v, vi)#ExcessTable_cont ExcessAtPG vs\n     else ExcessTable_cont ExcessAtPG vs)\""], ["", "definition ExcessTable' :: \"graph \\<Rightarrow> vertex list \\<Rightarrow> (vertex \\<times> nat) list\" where\n  \"ExcessTable' g \\<equiv> ExcessTable_cont (ExcessAt g)\""], ["", "lemma distinct_ExcessTable_cont:\n  \"distinct vs \\<Longrightarrow>\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow>\n    distinct (map fst (ExcessTable_cont (ExcessAt g) vs))", "proof (induct vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    distinct (map fst (ExcessTable_cont (ExcessAt g) []))\n 2. \\<And>a vs.\n       \\<lbrakk>distinct vs \\<Longrightarrow>\n                distinct (map fst (ExcessTable_cont (ExcessAt g) vs));\n        distinct (a # vs)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (ExcessTable_cont (ExcessAt g) (a # vs)))", "case Nil"], ["proof (state)\nthis:\n  distinct []\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    distinct (map fst (ExcessTable_cont (ExcessAt g) []))\n 2. \\<And>a vs.\n       \\<lbrakk>distinct vs \\<Longrightarrow>\n                distinct (map fst (ExcessTable_cont (ExcessAt g) vs));\n        distinct (a # vs)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (ExcessTable_cont (ExcessAt g) (a # vs)))", "then"], ["proof (chain)\npicking this:\n  distinct []", "show ?case"], ["proof (prove)\nusing this:\n  distinct []\n\ngoal (1 subgoal):\n 1. distinct (map fst (ExcessTable_cont (ExcessAt g) []))", "by (simp add: ExcessTable_def)"], ["proof (state)\nthis:\n  distinct (map fst (ExcessTable_cont (ExcessAt g) []))\n\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>distinct vs \\<Longrightarrow>\n                distinct (map fst (ExcessTable_cont (ExcessAt g) vs));\n        distinct (a # vs)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (ExcessTable_cont (ExcessAt g) (a # vs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>distinct vs \\<Longrightarrow>\n                distinct (map fst (ExcessTable_cont (ExcessAt g) vs));\n        distinct (a # vs)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (ExcessTable_cont (ExcessAt g) (a # vs)))", "case (Cons v vs)"], ["proof (state)\nthis:\n  distinct vs \\<Longrightarrow>\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\n  distinct (v # vs)\n\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>distinct vs \\<Longrightarrow>\n                distinct (map fst (ExcessTable_cont (ExcessAt g) vs));\n        distinct (a # vs)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (ExcessTable_cont (ExcessAt g) (a # vs)))", "from Cons"], ["proof (chain)\npicking this:\n  distinct vs \\<Longrightarrow>\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\n  distinct (v # vs)", "have v: \"v \\<notin> set vs\""], ["proof (prove)\nusing this:\n  distinct vs \\<Longrightarrow>\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\n  distinct (v # vs)\n\ngoal (1 subgoal):\n 1. v \\<notin> set vs", "by simp"], ["proof (state)\nthis:\n  v \\<notin> set vs\n\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>distinct vs \\<Longrightarrow>\n                distinct (map fst (ExcessTable_cont (ExcessAt g) vs));\n        distinct (a # vs)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (ExcessTable_cont (ExcessAt g) (a # vs)))", "from Cons"], ["proof (chain)\npicking this:\n  distinct vs \\<Longrightarrow>\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\n  distinct (v # vs)", "have \"distinct vs\""], ["proof (prove)\nusing this:\n  distinct vs \\<Longrightarrow>\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\n  distinct (v # vs)\n\ngoal (1 subgoal):\n 1. distinct vs", "by simp"], ["proof (state)\nthis:\n  distinct vs\n\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>distinct vs \\<Longrightarrow>\n                distinct (map fst (ExcessTable_cont (ExcessAt g) vs));\n        distinct (a # vs)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (ExcessTable_cont (ExcessAt g) (a # vs)))", "with Cons"], ["proof (chain)\npicking this:\n  distinct vs \\<Longrightarrow>\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\n  distinct (v # vs)\n  distinct vs", "have IH:\n    \"distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\""], ["proof (prove)\nusing this:\n  distinct vs \\<Longrightarrow>\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\n  distinct (v # vs)\n  distinct vs\n\ngoal (1 subgoal):\n 1. distinct (map fst (ExcessTable_cont (ExcessAt g) vs))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\n\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>distinct vs \\<Longrightarrow>\n                distinct (map fst (ExcessTable_cont (ExcessAt g) vs));\n        distinct (a # vs)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (ExcessTable_cont (ExcessAt g) (a # vs)))", "moreover"], ["proof (state)\nthis:\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\n\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>distinct vs \\<Longrightarrow>\n                distinct (map fst (ExcessTable_cont (ExcessAt g) vs));\n        distinct (a # vs)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (ExcessTable_cont (ExcessAt g) (a # vs)))", "have\n    \"v \\<notin> fst ` set (ExcessTable_cont (ExcessAt g) vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> fst ` set (ExcessTable_cont (ExcessAt g) vs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> fst ` set (ExcessTable_cont (ExcessAt g) vs) \\<Longrightarrow>\n    False", "assume \"v \\<in> fst ` set (ExcessTable_cont (ExcessAt g) vs)\""], ["proof (state)\nthis:\n  v \\<in> fst ` set (ExcessTable_cont (ExcessAt g) vs)\n\ngoal (1 subgoal):\n 1. v \\<in> fst ` set (ExcessTable_cont (ExcessAt g) vs) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  v \\<in> fst ` set (ExcessTable_cont (ExcessAt g) vs)\n\ngoal (1 subgoal):\n 1. v \\<in> fst ` set (ExcessTable_cont (ExcessAt g) vs) \\<Longrightarrow>\n    False", "have \"fst ` set (ExcessTable_cont (ExcessAt g) vs) \\<subseteq> set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (ExcessTable_cont (ExcessAt g) vs) \\<subseteq> set vs", "by (induct vs) auto"], ["proof (state)\nthis:\n  fst ` set (ExcessTable_cont (ExcessAt g) vs) \\<subseteq> set vs\n\ngoal (1 subgoal):\n 1. v \\<in> fst ` set (ExcessTable_cont (ExcessAt g) vs) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  v \\<in> set vs", "have \" v \\<in> set vs\""], ["proof (prove)\nusing this:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. v \\<in> set vs", "."], ["proof (state)\nthis:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. v \\<in> fst ` set (ExcessTable_cont (ExcessAt g) vs) \\<Longrightarrow>\n    False", "with v"], ["proof (chain)\npicking this:\n  v \\<notin> set vs\n  v \\<in> set vs", "show False"], ["proof (prove)\nusing this:\n  v \\<notin> set vs\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<notin> fst ` set (ExcessTable_cont (ExcessAt g) vs)\n\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>distinct vs \\<Longrightarrow>\n                distinct (map fst (ExcessTable_cont (ExcessAt g) vs));\n        distinct (a # vs)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (ExcessTable_cont (ExcessAt g) (a # vs)))", "ultimately"], ["proof (chain)\npicking this:\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\n  v \\<notin> fst ` set (ExcessTable_cont (ExcessAt g) vs)", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst (ExcessTable_cont (ExcessAt g) vs))\n  v \\<notin> fst ` set (ExcessTable_cont (ExcessAt g) vs)\n\ngoal (1 subgoal):\n 1. distinct (map fst (ExcessTable_cont (ExcessAt g) (v # vs)))", "by (simp add: ExcessTable_def)"], ["proof (state)\nthis:\n  distinct (map fst (ExcessTable_cont (ExcessAt g) (v # vs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ExcessTable_cont_eq:\n \"ExcessTable_cont E vs =\n  [(v, E v). v \\<leftarrow> [v\\<leftarrow>vs . 0 < E v]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ExcessTable_cont E vs =\n    map (\\<lambda>v. (v, E v)) (filter (\\<lambda>v. 0 < E v) vs)", "by (induct vs) (simp_all)"], ["", "lemma ExcessTable_eq: \"ExcessTable = ExcessTable'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ExcessTable = ExcessTable'", "proof (rule ext, rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. ExcessTable x xa = ExcessTable' x xa", "fix p g vs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. ExcessTable x xa = ExcessTable' x xa", "show \"ExcessTable g vs = ExcessTable' g vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ExcessTable g vs = ExcessTable' g vs", "by (simp add: ExcessTable_def ExcessTable'_def ExcessTable_cont_eq)"], ["proof (state)\nthis:\n  ExcessTable g vs = ExcessTable' g vs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_ExcessTable:\n   \"distinct vs \\<Longrightarrow> distinct [fst p. p \\<leftarrow> ExcessTable g vs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct vs \\<Longrightarrow> distinct (map fst (ExcessTable g vs))", "by (simp_all add: ExcessTable_eq ExcessTable'_def distinct_ExcessTable_cont)"], ["", "lemma ExcessNotAt_eq:\n  \"minGraphProps g \\<Longrightarrow> final g \\<Longrightarrow>\n  \\<exists>V. ExcessNotAt g None\n      = (\\<Sum>\\<^bsub>v \\<in> V\\<^esub> ExcessAt g v)\n   \\<and> separated g (set V) \\<and> set V \\<subseteq> set (vertices g)\n   \\<and> distinct V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> \\<exists>V.\n                         ExcessNotAt g None = ListSum V (ExcessAt g) \\<and>\n                         separated g (set V) \\<and>\n                         set V \\<subseteq> \\<V> g \\<and> distinct V", "proof (intro exI conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> ExcessNotAt g None = ListSum ?V (ExcessAt g)\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> separated g (set ?V)\n 3. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set ?V \\<subseteq> \\<V> g\n 4. \\<lbrakk>minGraphProps g; final g\\<rbrakk> \\<Longrightarrow> distinct ?V", "assume mgp: \"minGraphProps g\" and fin: \"final g\""], ["proof (state)\nthis:\n  minGraphProps g\n  final g\n\ngoal (4 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> ExcessNotAt g None = ListSum ?V (ExcessAt g)\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> separated g (set ?V)\n 3. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set ?V \\<subseteq> \\<V> g\n 4. \\<lbrakk>minGraphProps g; final g\\<rbrakk> \\<Longrightarrow> distinct ?V", "let ?ps = \"ExcessTable g (vertices g)\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> ExcessNotAt g None = ListSum ?V (ExcessAt g)\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> separated g (set ?V)\n 3. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set ?V \\<subseteq> \\<V> g\n 4. \\<lbrakk>minGraphProps g; final g\\<rbrakk> \\<Longrightarrow> distinct ?V", "let ?V = \"ExcessNotAtRecList ?ps g\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> ExcessNotAt g None = ListSum ?V (ExcessAt g)\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> separated g (set ?V)\n 3. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set ?V \\<subseteq> \\<V> g\n 4. \\<lbrakk>minGraphProps g; final g\\<rbrakk> \\<Longrightarrow> distinct ?V", "let ?vs = \"vertices g\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> ExcessNotAt g None = ListSum ?V (ExcessAt g)\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> separated g (set ?V)\n 3. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set ?V \\<subseteq> \\<V> g\n 4. \\<lbrakk>minGraphProps g; final g\\<rbrakk> \\<Longrightarrow> distinct ?V", "let ?E = \"\\<lambda>v. ExcessAt g v\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> ExcessNotAt g None = ListSum ?V (ExcessAt g)\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> separated g (set ?V)\n 3. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set ?V \\<subseteq> \\<V> g\n 4. \\<lbrakk>minGraphProps g; final g\\<rbrakk> \\<Longrightarrow> distinct ?V", "have t: \"isTable ?E ?vs ?ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isTable (ExcessAt g) (vertices g) (ExcessTable g (vertices g))", "by (rule isTable_ExcessTable)"], ["proof (state)\nthis:\n  isTable (ExcessAt g) (vertices g) (ExcessTable g (vertices g))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> ExcessNotAt g None = ListSum ?V (ExcessAt g)\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> separated g (set ?V)\n 3. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set ?V \\<subseteq> \\<V> g\n 4. \\<lbrakk>minGraphProps g; final g\\<rbrakk> \\<Longrightarrow> distinct ?V", "with this"], ["proof (chain)\npicking this:\n  isTable (ExcessAt g) (vertices g) (ExcessTable g (vertices g))\n  isTable (ExcessAt g) (vertices g) (ExcessTable g (vertices g))", "show \"ExcessNotAt g None = (\\<Sum>\\<^bsub>v \\<in> ?V\\<^esub> ?E v)\""], ["proof (prove)\nusing this:\n  isTable (ExcessAt g) (vertices g) (ExcessTable g (vertices g))\n  isTable (ExcessAt g) (vertices g) (ExcessTable g (vertices g))\n\ngoal (1 subgoal):\n 1. ExcessNotAt g None =\n    ListSum (ExcessNotAtRecList (ExcessTable g (vertices g)) g) (ExcessAt g)", "by (simp add: ListSum_ExcessNotAtRecList ExcessNotAt_def)"], ["proof (state)\nthis:\n  ExcessNotAt g None =\n  ListSum (ExcessNotAtRecList (ExcessTable g (vertices g)) g) (ExcessAt g)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> separated g\n                       (set (ExcessNotAtRecList (ExcessTable g (vertices g))\n                              g))\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set (ExcessNotAtRecList (ExcessTable g (vertices g))\n                            g)\n                      \\<subseteq> \\<V> g\n 3. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (ExcessNotAtRecList (ExcessTable g (vertices g)) g)", "show \"separated g (set ?V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separated g (set (ExcessNotAtRecList (ExcessTable g (vertices g)) g))", "by(rule separated_ExcessNotAtRecList[OF mgp fin t])"], ["proof (state)\nthis:\n  separated g (set (ExcessNotAtRecList (ExcessTable g (vertices g)) g))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set (ExcessNotAtRecList (ExcessTable g (vertices g))\n                            g)\n                      \\<subseteq> \\<V> g\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (ExcessNotAtRecList (ExcessTable g (vertices g)) g)", "have \"set (ExcessNotAtRecList ?ps g) \\<subseteq> set (map fst ?ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (ExcessTable g (vertices g)) g)\n    \\<subseteq> set (map fst (ExcessTable g (vertices g)))", "by (rule ExcessNotAtRecList_subset[simplified concat_map_singleton])"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (ExcessTable g (vertices g)) g)\n  \\<subseteq> set (map fst (ExcessTable g (vertices g)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set (ExcessNotAtRecList (ExcessTable g (vertices g))\n                            g)\n                      \\<subseteq> \\<V> g\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (ExcessNotAtRecList (ExcessTable g (vertices g)) g)", "also"], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (ExcessTable g (vertices g)) g)\n  \\<subseteq> set (map fst (ExcessTable g (vertices g)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set (ExcessNotAtRecList (ExcessTable g (vertices g))\n                            g)\n                      \\<subseteq> \\<V> g\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (ExcessNotAtRecList (ExcessTable g (vertices g)) g)", "have \"\\<dots> \\<subseteq> set (vertices g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (ExcessTable g (vertices g))) \\<subseteq> \\<V> g", "by (rule ExcessTable_subset)"], ["proof (state)\nthis:\n  set (map fst (ExcessTable g (vertices g))) \\<subseteq> \\<V> g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> set (ExcessNotAtRecList (ExcessTable g (vertices g))\n                            g)\n                      \\<subseteq> \\<V> g\n 2. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (ExcessNotAtRecList (ExcessTable g (vertices g)) g)", "finally"], ["proof (chain)\npicking this:\n  set (ExcessNotAtRecList (ExcessTable g (vertices g)) g) \\<subseteq> \\<V> g", "show \"set ?V \\<subseteq> set (vertices g)\""], ["proof (prove)\nusing this:\n  set (ExcessNotAtRecList (ExcessTable g (vertices g)) g) \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. set (ExcessNotAtRecList (ExcessTable g (vertices g)) g)\n    \\<subseteq> \\<V> g", "."], ["proof (state)\nthis:\n  set (ExcessNotAtRecList (ExcessTable g (vertices g)) g) \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>minGraphProps g; final g\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (ExcessNotAtRecList (ExcessTable g (vertices g)) g)", "show \"distinct ?V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ExcessNotAtRecList (ExcessTable g (vertices g)) g)", "by (simp add: distinct_ExcessNotAtRecList distinct_ExcessTable[simplified concat_map_singleton])"], ["proof (state)\nthis:\n  distinct (ExcessNotAtRecList (ExcessTable g (vertices g)) g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma excess_eq:\n  assumes 7: \"t + q \\<le> 7\"\n  shows \"excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "note simps = excessAtType_def squanderVertex_def squanderFace_def\n    nat_minus_add_max squanderTarget_def"], ["proof (state)\nthis:\n  excessAtType ?t ?q ?e \\<equiv>\n  if ?e = 0\n  then if 7 < ?t + ?q then squanderTarget\n       else \\<b> ?t ?q - ?t * d3_const - ?q * d4_const\n  else if ?t + ?q + ?e \\<noteq> 6 then 0\n       else if ?t = 5 then \\<a> else squanderTarget\n  \\<b> ?p ?q \\<equiv>\n  if ?p = 0 \\<and> ?q = 3 then 6177\n  else if ?p = 0 \\<and> ?q = 4 then 9696\n       else if ?p = 1 \\<and> ?q = 2 then 6557\n            else if ?p = 1 \\<and> ?q = 3 then 6176\n                 else if ?p = 2 \\<and> ?q = 1 then 7967\n                      else if ?p = 2 \\<and> ?q = 2 then 4116\n                           else if ?p = 2 \\<and> ?q = 3 then 12846\n                                else if ?p = 3 \\<and> ?q = 1 then 3106\n                                     else if ?p = 3 \\<and> ?q = 2 then 8165\n    else if ?p = 4 \\<and> ?q = 0 then 3466\n         else if ?p = 4 \\<and> ?q = 1 then 3655\n              else if ?p = 5 \\<and> ?q = 0 then 395\n                   else if ?p = 5 \\<and> ?q = 1 then 11354\n                        else if ?p = 6 \\<and> ?q = 0 then 6854\n                             else if ?p = 7 \\<and> ?q = 0 then 14493\n                                  else squanderTarget\n  \\<d> ?n \\<equiv>\n  if ?n = 3 then 0\n  else if ?n = 4 then 2058\n       else if ?n = 5 then 4819 else if ?n = 6 then 7120 else squanderTarget\n  ?n - ?m + ?m = max ?n ?m\n  squanderTarget \\<equiv> 15410\n\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "from 7"], ["proof (chain)\npicking this:\n  t + q \\<le> 7", "have \"q=0 \\<or> q=1 \\<or> q=2 \\<or> q=3 \\<or> q=4 \\<or> q=5 \\<or> q=6 \\<or> q=7\""], ["proof (prove)\nusing this:\n  t + q \\<le> 7\n\ngoal (1 subgoal):\n 1. q = 0 \\<or>\n    q = 1 \\<or>\n    q = 2 \\<or> q = 3 \\<or> q = 4 \\<or> q = 5 \\<or> q = 6 \\<or> q = 7", "by arith"], ["proof (state)\nthis:\n  q = 0 \\<or>\n  q = 1 \\<or>\n  q = 2 \\<or> q = 3 \\<or> q = 4 \\<or> q = 5 \\<or> q = 6 \\<or> q = 7\n\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "then"], ["proof (chain)\npicking this:\n  q = 0 \\<or>\n  q = 1 \\<or>\n  q = 2 \\<or> q = 3 \\<or> q = 4 \\<or> q = 5 \\<or> q = 6 \\<or> q = 7", "show ?thesis"], ["proof (prove)\nusing this:\n  q = 0 \\<or>\n  q = 1 \\<or>\n  q = 2 \\<or> q = 3 \\<or> q = 4 \\<or> q = 5 \\<or> q = 6 \\<or> q = 7\n\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "proof (elim disjE)"], ["proof (state)\ngoal (8 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 1 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 2 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 6. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 7. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 8. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "assume q: \"q = 0\""], ["proof (state)\nthis:\n  q = 0\n\ngoal (8 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 1 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 2 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 6. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 7. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 8. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "(* 16 subgoals *)"], ["proof (state)\nthis:\n  q = 0\n\ngoal (8 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 1 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 2 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 6. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 7. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 8. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "with 7"], ["proof (chain)\npicking this:\n  t + q \\<le> 7\n  q = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  t + q \\<le> 7\n  q = 0\n\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "by (simp add: simps)"], ["proof (state)\nthis:\n  excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n\ngoal (7 subgoals):\n 1. q = 1 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 2 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 6. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 7. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. q = 1 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 2 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 6. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 7. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "assume q: \"q = 1\""], ["proof (state)\nthis:\n  q = 1\n\ngoal (7 subgoals):\n 1. q = 1 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 2 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 6. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 7. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "(* 29 subgoals *)"], ["proof (state)\nthis:\n  q = 1\n\ngoal (7 subgoals):\n 1. q = 1 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 2 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 6. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 7. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "with 7"], ["proof (chain)\npicking this:\n  t + q \\<le> 7\n  q = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  t + q \\<le> 7\n  q = 1\n\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "by (simp add: simps)"], ["proof (state)\nthis:\n  excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n\ngoal (6 subgoals):\n 1. q = 2 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 6. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. q = 2 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 6. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "assume q: \"q = 2\""], ["proof (state)\nthis:\n  q = 2\n\ngoal (6 subgoals):\n 1. q = 2 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 6. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "(* 16 subgoals *)"], ["proof (state)\nthis:\n  q = 2\n\ngoal (6 subgoals):\n 1. q = 2 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 6. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "with 7"], ["proof (chain)\npicking this:\n  t + q \\<le> 7\n  q = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  t + q \\<le> 7\n  q = 2\n\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "by (simp add: simps)"], ["proof (state)\nthis:\n  excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n\ngoal (5 subgoals):\n 1. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "assume q: \"q = 3\""], ["proof (state)\nthis:\n  q = 3\n\ngoal (5 subgoals):\n 1. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "(* 16 subgoals *)"], ["proof (state)\nthis:\n  q = 3\n\ngoal (5 subgoals):\n 1. q = 3 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 5. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "with 7"], ["proof (chain)\npicking this:\n  t + q \\<le> 7\n  q = 3", "show ?thesis"], ["proof (prove)\nusing this:\n  t + q \\<le> 7\n  q = 3\n\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "by (simp add: simps)"], ["proof (state)\nthis:\n  excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n\ngoal (4 subgoals):\n 1. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "assume q: \"q = 4\""], ["proof (state)\nthis:\n  q = 4\n\ngoal (4 subgoals):\n 1. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "(* 6 subgoals *)"], ["proof (state)\nthis:\n  q = 4\n\ngoal (4 subgoals):\n 1. q = 4 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 4. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "with 7"], ["proof (chain)\npicking this:\n  t + q \\<le> 7\n  q = 4", "show ?thesis"], ["proof (prove)\nusing this:\n  t + q \\<le> 7\n  q = 4\n\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "by (simp add: simps)"], ["proof (state)\nthis:\n  excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n\ngoal (3 subgoals):\n 1. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "assume q: \"q = 5\""], ["proof (state)\nthis:\n  q = 5\n\ngoal (3 subgoals):\n 1. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "(* 1 subgoal *)"], ["proof (state)\nthis:\n  q = 5\n\ngoal (3 subgoals):\n 1. q = 5 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 3. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "with 7"], ["proof (chain)\npicking this:\n  t + q \\<le> 7\n  q = 5", "show ?thesis"], ["proof (prove)\nusing this:\n  t + q \\<le> 7\n  q = 5\n\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "by (simp add: simps)"], ["proof (state)\nthis:\n  excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n\ngoal (2 subgoals):\n 1. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "assume q: \"q = 6\""], ["proof (state)\nthis:\n  q = 6\n\ngoal (2 subgoals):\n 1. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "(* 1 subgoal *)"], ["proof (state)\nthis:\n  q = 6\n\ngoal (2 subgoals):\n 1. q = 6 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n 2. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "with 7"], ["proof (chain)\npicking this:\n  t + q \\<le> 7\n  q = 6", "show ?thesis"], ["proof (prove)\nusing this:\n  t + q \\<le> 7\n  q = 6\n\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "by (simp add: simps)"], ["proof (state)\nthis:\n  excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n\ngoal (1 subgoal):\n 1. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "assume q: \"q = 7\""], ["proof (state)\nthis:\n  q = 7\n\ngoal (1 subgoal):\n 1. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "(* 1 subgoal *)"], ["proof (state)\nthis:\n  q = 7\n\ngoal (1 subgoal):\n 1. q = 7 \\<Longrightarrow>\n    excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "with 7"], ["proof (chain)\npicking this:\n  t + q \\<le> 7\n  q = 7", "show ?thesis"], ["proof (prove)\nusing this:\n  t + q \\<le> 7\n  q = 7\n\ngoal (1 subgoal):\n 1. excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q", "by (simp add: simps)"], ["proof (state)\nthis:\n  excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  excessAtType t q 0 + t * \\<d> 3 + q * \\<d> 4 = \\<b> t q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma excess_eq1:\n  \"\\<lbrakk> inv g; final g; tame g; except g v = 0; v \\<in> set(vertices g) \\<rbrakk> \\<Longrightarrow>\n   ExcessAt g v + (tri g v) * \\<d> 3 + (quad g v) * \\<d>  4\n   = \\<b> (tri g v) (quad g v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; tame g; except g v = 0;\n     v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> ExcessAt g v + tri g v * \\<d> 3 + quad g v * \\<d> 4 =\n                      \\<b> (tri g v) (quad g v)", "apply(subgoal_tac \"finalVertex g v\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Invariants.inv g; final g; tame g; except g v = 0;\n     v \\<in> \\<V> g; finalVertex g v\\<rbrakk>\n    \\<Longrightarrow> ExcessAt g v + tri g v * \\<d> 3 + quad g v * \\<d> 4 =\n                      \\<b> (tri g v) (quad g v)\n 2. \\<lbrakk>Invariants.inv g; final g; tame g; except g v = 0;\n     v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> finalVertex g v", "apply(simp add: ExcessAt_def excess_eq faceCountMax_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; tame g; except g v = 0;\n     v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> finalVertex g v", "apply(auto simp:finalVertex_def plane_final_facesAt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>separating\\<close>"], ["", "definition separating :: \"'a set \\<Rightarrow> ('a \\<Rightarrow> 'b set) \\<Rightarrow> bool\" where\n  \"separating V F \\<equiv> \n   (\\<forall>v1 \\<in> V. \\<forall>v2 \\<in> V. v1 \\<noteq> v2 \\<longrightarrow>  F v1 \\<inter> F v2 = {})\""], ["", "lemma separating_insert1: \n  \"separating (insert a V) F \\<Longrightarrow> separating V F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (insert a V) F \\<Longrightarrow> separating V F", "by (simp add: separating_def)"], ["", "lemma separating_insert2:\n  \"separating (insert a V) F \\<Longrightarrow> a \\<notin> V \\<Longrightarrow>  v \\<in> V \\<Longrightarrow> \n  F a \\<inter> F v = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>separating (insert a V) F; a \\<notin> V; v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> F a \\<inter> F v = {}", "by (auto simp add: separating_def)"], ["", "lemma sum_disj_Union: \n \"finite V \\<Longrightarrow> \n  (\\<And>f. finite (F f)) \\<Longrightarrow> \n  separating V F \\<Longrightarrow> \n  (\\<Sum>v\\<in>V. \\<Sum>f\\<in>(F v). (w f::nat)) = (\\<Sum>f\\<in>(\\<Union>v\\<in>V. F v). w f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; \\<And>f. finite (F f); separating V F\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>v\\<in>V. sum w (F v)) =\n                      sum w (\\<Union> (F ` V))", "proof (induct  rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>f. finite (F f); separating {} F\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>v\\<in>{}. sum w (F v)) =\n                      sum w (\\<Union> (F ` {}))\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "case empty"], ["proof (state)\nthis:\n  finite (F ?f)\n  separating {} F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>f. finite (F f); separating {} F\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>v\\<in>{}. sum w (F v)) =\n                      sum w (\\<Union> (F ` {}))\n 2. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "then"], ["proof (chain)\npicking this:\n  finite (F ?f)\n  separating {} F", "show ?case"], ["proof (prove)\nusing this:\n  finite (F ?f)\n  separating {} F\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>{}. sum w (F v)) = sum w (\\<Union> (F ` {}))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>{}. sum w (F v)) = sum w (\\<Union> (F ` {}))\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "case (insert a V)"], ["proof (state)\nthis:\n  finite V\n  a \\<notin> V\n  \\<lbrakk>\\<And>f. finite (F f); separating V F\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>v\\<in>V. sum w (F v)) = sum w (\\<Union> (F ` V))\n  finite (F ?f)\n  separating (insert a V) F\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "then"], ["proof (chain)\npicking this:\n  finite V\n  a \\<notin> V\n  \\<lbrakk>\\<And>f. finite (F f); separating V F\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>v\\<in>V. sum w (F v)) = sum w (\\<Union> (F ` V))\n  finite (F ?f)\n  separating (insert a V) F", "have s: \"separating (insert a V) F\""], ["proof (prove)\nusing this:\n  finite V\n  a \\<notin> V\n  \\<lbrakk>\\<And>f. finite (F f); separating V F\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>v\\<in>V. sum w (F v)) = sum w (\\<Union> (F ` V))\n  finite (F ?f)\n  separating (insert a V) F\n\ngoal (1 subgoal):\n 1. separating (insert a V) F", "by simp"], ["proof (state)\nthis:\n  separating (insert a V) F\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "then"], ["proof (chain)\npicking this:\n  separating (insert a V) F", "have \"separating V F\""], ["proof (prove)\nusing this:\n  separating (insert a V) F\n\ngoal (1 subgoal):\n 1. separating V F", "by (rule_tac separating_insert1)"], ["proof (state)\nthis:\n  separating V F\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "with insert"], ["proof (chain)\npicking this:\n  finite V\n  a \\<notin> V\n  \\<lbrakk>\\<And>f. finite (F f); separating V F\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>v\\<in>V. sum w (F v)) = sum w (\\<Union> (F ` V))\n  finite (F ?f)\n  separating (insert a V) F\n  separating V F", "have IH: \"(\\<Sum>v\\<in>V. \\<Sum>f\\<in>(F v). w f) = (\\<Sum>f\\<in>(\\<Union>v\\<in>V. F v). w f)\""], ["proof (prove)\nusing this:\n  finite V\n  a \\<notin> V\n  \\<lbrakk>\\<And>f. finite (F f); separating V F\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>v\\<in>V. sum w (F v)) = sum w (\\<Union> (F ` V))\n  finite (F ?f)\n  separating (insert a V) F\n  separating V F\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. sum w (F v)) = sum w (\\<Union> (F ` V))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>V. sum w (F v)) = sum w (\\<Union> (F ` V))\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>V. sum w (F v)) = sum w (\\<Union> (F ` V))\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "have fin: \"finite V\" \"a \\<notin> V\" \"\\<And>f. finite (F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V &&& a \\<notin> V &&& (\\<And>f. finite (F f))", "by fact+"], ["proof (state)\nthis:\n  finite V\n  a \\<notin> V\n  finite (F ?f)\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "moreover"], ["proof (state)\nthis:\n  finite V\n  a \\<notin> V\n  finite (F ?f)\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "from s"], ["proof (chain)\npicking this:\n  separating (insert a V) F", "have \"\\<And>v. a \\<notin> V \\<Longrightarrow> v \\<in> V \\<Longrightarrow> F a \\<inter> F v = {}\""], ["proof (prove)\nusing this:\n  separating (insert a V) F\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>a \\<notin> V; v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> F a \\<inter> F v = {}", "by (simp add: separating_insert2)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<notin> V; ?v \\<in> V\\<rbrakk>\n  \\<Longrightarrow> F a \\<inter> F ?v = {}\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "with fin"], ["proof (chain)\npicking this:\n  finite V\n  a \\<notin> V\n  finite (F ?f)\n  \\<lbrakk>a \\<notin> V; ?v \\<in> V\\<rbrakk>\n  \\<Longrightarrow> F a \\<inter> F ?v = {}", "have \"(F a) \\<inter> (\\<Union>v\\<in>V. F v) = {}\""], ["proof (prove)\nusing this:\n  finite V\n  a \\<notin> V\n  finite (F ?f)\n  \\<lbrakk>a \\<notin> V; ?v \\<in> V\\<rbrakk>\n  \\<Longrightarrow> F a \\<inter> F ?v = {}\n\ngoal (1 subgoal):\n 1. F a \\<inter> \\<Union> (F ` V) = {}", "by auto"], ["proof (state)\nthis:\n  F a \\<inter> \\<Union> (F ` V) = {}\n\ngoal (1 subgoal):\n 1. \\<And>x Fa.\n       \\<lbrakk>finite Fa; x \\<notin> Fa;\n        \\<lbrakk>\\<And>f. finite (F f); separating Fa F\\<rbrakk>\n        \\<Longrightarrow> (\\<Sum>v\\<in>Fa. sum w (F v)) =\n                          sum w (\\<Union> (F ` Fa));\n        \\<And>f. finite (F f); separating (insert x Fa) F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>v\\<in>insert x Fa. sum w (F v)) =\n                         sum w (\\<Union> (F ` insert x Fa))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>v\\<in>V. sum w (F v)) = sum w (\\<Union> (F ` V))\n  finite V\n  a \\<notin> V\n  finite (F ?f)\n  F a \\<inter> \\<Union> (F ` V) = {}", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>V. sum w (F v)) = sum w (\\<Union> (F ` V))\n  finite V\n  a \\<notin> V\n  finite (F ?f)\n  F a \\<inter> \\<Union> (F ` V) = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>insert a V. sum w (F v)) =\n    sum w (\\<Union> (F ` insert a V))", "by (simp add: sum.union_disjoint)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>insert a V. sum w (F v)) = sum w (\\<Union> (F ` insert a V))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma separated_separating:\nassumes Vg: \"set V \\<subseteq> \\<V> g\"\nand pS: \"separated g (set V)\"\nand noex: \"\\<forall>f\\<in>P. |vertices f| \\<le> 4\"\nshows \"separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> P)", "from pS"], ["proof (chain)\npicking this:\n  separated g (set V)", "have i: \"\\<forall>v\\<in>set V. \\<forall>f\\<in>set (facesAt g v).\n    |vertices f| \\<le> 4 \\<longrightarrow> set (vertices f) \\<inter> set V = {v}\""], ["proof (prove)\nusing this:\n  separated g (set V)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set V.\n       \\<forall>f\\<in>set (facesAt g v).\n          |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> set V = {v}", "by (simp add: separated_def separated\\<^sub>3_def)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set V.\n     \\<forall>f\\<in>set (facesAt g v).\n        |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> set V = {v}\n\ngoal (1 subgoal):\n 1. separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> P)", "show \"separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> P)", "proof (simp add: separating_def, intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v1 v2.\n       \\<lbrakk>v1 \\<in> set V; v2 \\<in> set V; v1 \\<noteq> v2\\<rbrakk>\n       \\<Longrightarrow> set (facesAt g v1) \\<inter> P \\<inter>\n                         (set (facesAt g v2) \\<inter> P) =\n                         {}", "fix v1 v2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v1 v2.\n       \\<lbrakk>v1 \\<in> set V; v2 \\<in> set V; v1 \\<noteq> v2\\<rbrakk>\n       \\<Longrightarrow> set (facesAt g v1) \\<inter> P \\<inter>\n                         (set (facesAt g v2) \\<inter> P) =\n                         {}", "assume v: \"v1 \\<in> set V\" \"v2 \\<in> set V\" \"v1 \\<noteq> v2\""], ["proof (state)\nthis:\n  v1 \\<in> set V\n  v2 \\<in> set V\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. \\<And>v1 v2.\n       \\<lbrakk>v1 \\<in> set V; v2 \\<in> set V; v1 \\<noteq> v2\\<rbrakk>\n       \\<Longrightarrow> set (facesAt g v1) \\<inter> P \\<inter>\n                         (set (facesAt g v2) \\<inter> P) =\n                         {}", "hence \"v1 : \\<V> g\""], ["proof (prove)\nusing this:\n  v1 \\<in> set V\n  v2 \\<in> set V\n  v1 \\<noteq> v2\n\ngoal (1 subgoal):\n 1. v1 \\<in> \\<V> g", "using Vg"], ["proof (prove)\nusing this:\n  v1 \\<in> set V\n  v2 \\<in> set V\n  v1 \\<noteq> v2\n  set V \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. v1 \\<in> \\<V> g", "by blast"], ["proof (state)\nthis:\n  v1 \\<in> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>v1 v2.\n       \\<lbrakk>v1 \\<in> set V; v2 \\<in> set V; v1 \\<noteq> v2\\<rbrakk>\n       \\<Longrightarrow> set (facesAt g v1) \\<inter> P \\<inter>\n                         (set (facesAt g v2) \\<inter> P) =\n                         {}", "show \"(set (facesAt g v1) \\<inter> P) \\<inter> (set (facesAt g v2) \\<inter> P) = {}\" (is \"?P\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (facesAt g v1) \\<inter> P \\<inter> (set (facesAt g v2) \\<inter> P) =\n    {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. set (facesAt g v1) \\<inter> P \\<inter>\n    (set (facesAt g v2) \\<inter> P) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"\\<not> ?P\""], ["proof (state)\nthis:\n  set (facesAt g v1) \\<inter> P \\<inter>\n  (set (facesAt g v2) \\<inter> P) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. set (facesAt g v1) \\<inter> P \\<inter>\n    (set (facesAt g v2) \\<inter> P) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  set (facesAt g v1) \\<inter> P \\<inter>\n  (set (facesAt g v2) \\<inter> P) \\<noteq>\n  {}", "obtain f where f1: \"f \\<in> set (facesAt g v1)\"\n        and f2: \"f \\<in> set (facesAt g v2)\" and \"f : P\""], ["proof (prove)\nusing this:\n  set (facesAt g v1) \\<inter> P \\<inter>\n  (set (facesAt g v2) \\<inter> P) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> set (facesAt g v1); f \\<in> set (facesAt g v2);\n         f \\<in> P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in> set (facesAt g v1)\n  f \\<in> set (facesAt g v2)\n  f \\<in> P\n\ngoal (1 subgoal):\n 1. set (facesAt g v1) \\<inter> P \\<inter>\n    (set (facesAt g v2) \\<inter> P) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "with noex"], ["proof (chain)\npicking this:\n  \\<forall>f\\<in>P. |vertices f| \\<le> 4\n  f \\<in> set (facesAt g v1)\n  f \\<in> set (facesAt g v2)\n  f \\<in> P", "have l: \"|vertices f| \\<le> 4\""], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>P. |vertices f| \\<le> 4\n  f \\<in> set (facesAt g v1)\n  f \\<in> set (facesAt g v2)\n  f \\<in> P\n\ngoal (1 subgoal):\n 1. |vertices f| \\<le> 4", "by blast"], ["proof (state)\nthis:\n  |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. set (facesAt g v1) \\<inter> P \\<inter>\n    (set (facesAt g v2) \\<inter> P) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from v f1 l i"], ["proof (chain)\npicking this:\n  v1 \\<in> set V\n  v2 \\<in> set V\n  v1 \\<noteq> v2\n  f \\<in> set (facesAt g v1)\n  |vertices f| \\<le> 4\n  \\<forall>v\\<in>set V.\n     \\<forall>f\\<in>set (facesAt g v).\n        |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> set V = {v}", "have \"set (vertices f) \\<inter> set V = {v1}\""], ["proof (prove)\nusing this:\n  v1 \\<in> set V\n  v2 \\<in> set V\n  v1 \\<noteq> v2\n  f \\<in> set (facesAt g v1)\n  |vertices f| \\<le> 4\n  \\<forall>v\\<in>set V.\n     \\<forall>f\\<in>set (facesAt g v).\n        |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> set V = {v}\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set V = {v1}", "by simp"], ["proof (state)\nthis:\n  \\<V> f \\<inter> set V = {v1}\n\ngoal (1 subgoal):\n 1. set (facesAt g v1) \\<inter> P \\<inter>\n    (set (facesAt g v2) \\<inter> P) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  \\<V> f \\<inter> set V = {v1}\n\ngoal (1 subgoal):\n 1. set (facesAt g v1) \\<inter> P \\<inter>\n    (set (facesAt g v2) \\<inter> P) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from v f2 l i"], ["proof (chain)\npicking this:\n  v1 \\<in> set V\n  v2 \\<in> set V\n  v1 \\<noteq> v2\n  f \\<in> set (facesAt g v2)\n  |vertices f| \\<le> 4\n  \\<forall>v\\<in>set V.\n     \\<forall>f\\<in>set (facesAt g v).\n        |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> set V = {v}", "have \"set (vertices f) \\<inter> set V = {v2}\""], ["proof (prove)\nusing this:\n  v1 \\<in> set V\n  v2 \\<in> set V\n  v1 \\<noteq> v2\n  f \\<in> set (facesAt g v2)\n  |vertices f| \\<le> 4\n  \\<forall>v\\<in>set V.\n     \\<forall>f\\<in>set (facesAt g v).\n        |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> set V = {v}\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> set V = {v2}", "by simp"], ["proof (state)\nthis:\n  \\<V> f \\<inter> set V = {v2}\n\ngoal (1 subgoal):\n 1. set (facesAt g v1) \\<inter> P \\<inter>\n    (set (facesAt g v2) \\<inter> P) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  {v2} = {v1}", "have \"v1 = v2\""], ["proof (prove)\nusing this:\n  {v2} = {v1}\n\ngoal (1 subgoal):\n 1. v1 = v2", "by auto"], ["proof (state)\nthis:\n  v1 = v2\n\ngoal (1 subgoal):\n 1. set (facesAt g v1) \\<inter> P \\<inter>\n    (set (facesAt g v2) \\<inter> P) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  v1 = v2", "show False"], ["proof (prove)\nusing this:\n  v1 = v2\n\ngoal (1 subgoal):\n 1. False", "by contradiction (rule v)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (facesAt g v1) \\<inter> P \\<inter> (set (facesAt g v2) \\<inter> P) =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ListSum_V_F_eq_ListSum_F:\nassumes pl: \"inv g\"\nand pS: \"separated g (set V)\" and dist: \"distinct V\"\nand V_subset: \"set V \\<subseteq> set (vertices g)\"\nand noex: \"\\<forall>f \\<in> Collect P. |vertices f| \\<le> 4\"\nshows \"(\\<Sum>\\<^bsub>v \\<in> V\\<^esub> \\<Sum>\\<^bsub>f \\<in> filter P (facesAt g v)\\<^esub> (w::face \\<Rightarrow> nat) f)\n       = (\\<Sum>\\<^bsub>f \\<in> [f\\<leftarrow>faces g . \\<exists>v \\<in> set V. f \\<in> set (facesAt g v) \\<inter> Collect P]\\<^esub> w f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "have s: \"separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> Collect P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> Collect P)", "by (rule separated_separating[OF V_subset pS noex])"], ["proof (state)\nthis:\n  separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> Collect P)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "moreover"], ["proof (state)\nthis:\n  separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> Collect P)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "note dist"], ["proof (state)\nthis:\n  distinct V\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "moreover"], ["proof (state)\nthis:\n  distinct V\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "from pl V_subset"], ["proof (chain)\npicking this:\n  Invariants.inv g\n  set V \\<subseteq> \\<V> g", "have \"\\<And>v. v \\<in> set V \\<Longrightarrow> distinct (facesAt g v)\""], ["proof (prove)\nusing this:\n  Invariants.inv g\n  set V \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> set V \\<Longrightarrow> distinct (facesAt g v)", "by(blast intro:mgp_dist_facesAt[OF inv_mgp])"], ["proof (state)\nthis:\n  ?v \\<in> set V \\<Longrightarrow> distinct (facesAt g ?v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "hence v: \"\\<And>v. v \\<in> set V \\<Longrightarrow> distinct (filter P (facesAt g v))\""], ["proof (prove)\nusing this:\n  ?v \\<in> set V \\<Longrightarrow> distinct (facesAt g ?v)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set V \\<Longrightarrow> distinct (filter P (facesAt g v))", "by simp"], ["proof (state)\nthis:\n  ?v \\<in> set V \\<Longrightarrow> distinct (filter P (facesAt g ?v))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "moreover"], ["proof (state)\nthis:\n  ?v \\<in> set V \\<Longrightarrow> distinct (filter P (facesAt g ?v))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "have \"distinct [f\\<leftarrow>faces g . \\<exists>v \\<in> set V. f \\<in> set (facesAt g v) \\<inter> Collect P]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))", "by (intro distinct_filter minGraphProps11'[OF inv_mgp[OF pl]])"], ["proof (state)\nthis:\n  distinct\n   (filter\n     (\\<lambda>f.\n         \\<exists>v\\<in>set V. f \\<in> set (facesAt g v) \\<inter> Collect P)\n     (faces g))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "moreover"], ["proof (state)\nthis:\n  distinct\n   (filter\n     (\\<lambda>f.\n         \\<exists>v\\<in>set V. f \\<in> set (facesAt g v) \\<inter> Collect P)\n     (faces g))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "from pl"], ["proof (chain)\npicking this:\n  Invariants.inv g", "have \"{x. x \\<in> \\<F> g \\<and> (\\<exists>v \\<in> set V. x \\<in> set (facesAt g v) \\<and> P x)} =\n      (\\<Union>v\\<in>set V. set (facesAt g v) \\<inter> Collect P)\""], ["proof (prove)\nusing this:\n  Invariants.inv g\n\ngoal (1 subgoal):\n 1. {x \\<in> \\<F> g.\n     \\<exists>v\\<in>set V. x \\<in> set (facesAt g v) \\<and> P x} =\n    (\\<Union>\\<^bsub>v\\<in>set V\\<^esub>\n        set (facesAt g v) \\<inter> Collect P)", "using V_subset"], ["proof (prove)\nusing this:\n  Invariants.inv g\n  set V \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. {x \\<in> \\<F> g.\n     \\<exists>v\\<in>set V. x \\<in> set (facesAt g v) \\<and> P x} =\n    (\\<Union>\\<^bsub>v\\<in>set V\\<^esub>\n        set (facesAt g v) \\<inter> Collect P)", "by (blast intro:minGraphProps inv_mgp)"], ["proof (state)\nthis:\n  {x \\<in> \\<F> g.\n   \\<exists>v\\<in>set V. x \\<in> set (facesAt g v) \\<and> P x} =\n  (\\<Union>\\<^bsub>v\\<in>set V\\<^esub> set (facesAt g v) \\<inter> Collect P)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "moreover"], ["proof (state)\nthis:\n  {x \\<in> \\<F> g.\n   \\<exists>v\\<in>set V. x \\<in> set (facesAt g v) \\<and> P x} =\n  (\\<Union>\\<^bsub>v\\<in>set V\\<^esub> set (facesAt g v) \\<inter> Collect P)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "from v"], ["proof (chain)\npicking this:\n  ?v \\<in> set V \\<Longrightarrow> distinct (filter P (facesAt g ?v))", "have \"(\\<Sum>v\\<in>set V. ListSum (filter P (facesAt g v)) w) = (\\<Sum>v\\<in>set V. sum w (set(facesAt g v) \\<inter> Collect P))\""], ["proof (prove)\nusing this:\n  ?v \\<in> set V \\<Longrightarrow> distinct (filter P (facesAt g ?v))\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>set V. ListSum (filter P (facesAt g v)) w) =\n    (\\<Sum>v\\<in>set V. sum w (set (facesAt g v) \\<inter> Collect P))", "by (auto simp add: ListSum_conv_sum Int_def)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>set V. ListSum (filter P (facesAt g v)) w) =\n  (\\<Sum>v\\<in>set V. sum w (set (facesAt g v) \\<inter> Collect P))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "ultimately"], ["proof (chain)\npicking this:\n  separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> Collect P)\n  distinct V\n  ?v \\<in> set V \\<Longrightarrow> distinct (filter P (facesAt g ?v))\n  distinct\n   (filter\n     (\\<lambda>f.\n         \\<exists>v\\<in>set V. f \\<in> set (facesAt g v) \\<inter> Collect P)\n     (faces g))\n  {x \\<in> \\<F> g.\n   \\<exists>v\\<in>set V. x \\<in> set (facesAt g v) \\<and> P x} =\n  (\\<Union>\\<^bsub>v\\<in>set V\\<^esub> set (facesAt g v) \\<inter> Collect P)\n  (\\<Sum>v\\<in>set V. ListSum (filter P (facesAt g v)) w) =\n  (\\<Sum>v\\<in>set V. sum w (set (facesAt g v) \\<inter> Collect P))", "show ?thesis"], ["proof (prove)\nusing this:\n  separating (set V) (\\<lambda>v. set (facesAt g v) \\<inter> Collect P)\n  distinct V\n  ?v \\<in> set V \\<Longrightarrow> distinct (filter P (facesAt g ?v))\n  distinct\n   (filter\n     (\\<lambda>f.\n         \\<exists>v\\<in>set V. f \\<in> set (facesAt g v) \\<inter> Collect P)\n     (faces g))\n  {x \\<in> \\<F> g.\n   \\<exists>v\\<in>set V. x \\<in> set (facesAt g v) \\<and> P x} =\n  (\\<Union>\\<^bsub>v\\<in>set V\\<^esub> set (facesAt g v) \\<inter> Collect P)\n  (\\<Sum>v\\<in>set V. ListSum (filter P (facesAt g v)) w) =\n  (\\<Sum>v\\<in>set V. sum w (set (facesAt g v) \\<inter> Collect P))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n    ListSum\n     (filter\n       (\\<lambda>f.\n           \\<exists>v\\<in>set V.\n              f \\<in> set (facesAt g v) \\<inter> Collect P)\n       (faces g))\n     w", "by (simp add: ListSum_conv_sum sum_disj_Union)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (filter P (facesAt g v)) w) =\n  ListSum\n   (filter\n     (\\<lambda>f.\n         \\<exists>v\\<in>set V. f \\<in> set (facesAt g v) \\<inter> Collect P)\n     (faces g))\n   w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma separated_disj_Union2:\nassumes pl: \"inv g\" and fin: \"final g\" and ne: \"noExceptionals g (set V)\"\nand pS: \"separated g (set V)\" and dist: \"distinct V\"\nand V_subset: \"set V \\<subseteq> set (vertices g)\"\nshows \"(\\<Sum>\\<^bsub>v \\<in> V\\<^esub> \\<Sum>\\<^bsub>f \\<in> facesAt g v\\<^esub> (w::face \\<Rightarrow> nat) f)\n       = (\\<Sum>\\<^bsub>f \\<in> [f\\<leftarrow>faces g . \\<exists>v \\<in> set V. f \\<in> set (facesAt g v)]\\<^esub> w f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (facesAt g v) w) =\n    ListSum\n     (filter (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n       (faces g))\n     w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (facesAt g v) w) =\n    ListSum\n     (filter (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n       (faces g))\n     w", "let ?P = \"\\<lambda>f. |vertices f| \\<le> 4\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (facesAt g v) w) =\n    ListSum\n     (filter (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n       (faces g))\n     w", "have \"\\<forall>v \\<in> set V. \\<forall>f \\<in> set (facesAt g v). |vertices f| \\<le> 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set V.\n       \\<forall>f\\<in>set (facesAt g v). |vertices f| \\<le> 4", "using V_subset ne"], ["proof (prove)\nusing this:\n  set V \\<subseteq> \\<V> g\n  noExceptionals g (set V)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set V.\n       \\<forall>f\\<in>set (facesAt g v). |vertices f| \\<le> 4", "by (auto simp: noExceptionals_def\n      intro: minGraphProps5[OF inv_mgp[OF pl]] not_exceptional[OF pl fin])"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set V.\n     \\<forall>f\\<in>set (facesAt g v). |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (facesAt g v) w) =\n    ListSum\n     (filter (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n       (faces g))\n     w", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set V.\n     \\<forall>f\\<in>set (facesAt g v). |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (facesAt g v) w) =\n    ListSum\n     (filter (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n       (faces g))\n     w", "using ListSum_V_F_eq_ListSum_F[where P = ?P, OF pl pS dist V_subset]"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>set V.\n     \\<forall>f\\<in>set (facesAt g v). |vertices f| \\<le> 4\n  \\<forall>f\\<in>{f. |vertices f| \\<le> 4}.\n     |vertices f| \\<le> 4 \\<Longrightarrow>\n  (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum\n                                  (filter (\\<lambda>f. |vertices f| \\<le> 4)\n                                    (facesAt g v))\n                                  ?w) =\n  ListSum\n   (filter\n     (\\<lambda>f.\n         \\<exists>v\\<in>set V.\n            f \\<in> set (facesAt g v) \\<inter> {f. |vertices f| \\<le> 4})\n     (faces g))\n   ?w\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (facesAt g v) w) =\n    ListSum\n     (filter (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n       (faces g))\n     w", "by (simp add: Int_def cong: conj_cong)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> ListSum (facesAt g v) w) =\n  ListSum\n   (filter (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n     (faces g))\n   w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma squanderFace_distr2: \"inv g \\<Longrightarrow> final g \\<Longrightarrow> noExceptionals g (set V) \\<Longrightarrow>\n  separated g (set V) \\<Longrightarrow> distinct V \\<Longrightarrow> set V \\<subseteq> set (vertices g) \\<Longrightarrow>\n     (\\<Sum>\\<^bsub>f \\<in> [f\\<leftarrow>faces g. \\<exists>v \\<in> set V. f \\<in> set (facesAt g v)]\\<^esub>\n         \\<d> |vertices f| )\n   = (\\<Sum>\\<^bsub>v \\<in> V\\<^esub> ((tri g v) * \\<d> 3\n         + (quad g v) * \\<d> 4))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; noExceptionals g (set V);\n     separated g (set V); distinct V; set V \\<subseteq> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^bsub>f\\<in>filter\n      (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n      (faces g)\\<^esub> \\<d> |vertices f|) =\n                      (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 +\n               quad g v * \\<d> 4)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; noExceptionals g (set V);\n     separated g (set V); distinct V; set V \\<subseteq> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^bsub>f\\<in>filter\n      (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n      (faces g)\\<^esub> \\<d> |vertices f|) =\n                      (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 +\n               quad g v * \\<d> 4)", "assume pl: \"inv g\""], ["proof (state)\nthis:\n  Invariants.inv g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; noExceptionals g (set V);\n     separated g (set V); distinct V; set V \\<subseteq> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^bsub>f\\<in>filter\n      (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n      (faces g)\\<^esub> \\<d> |vertices f|) =\n                      (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 +\n               quad g v * \\<d> 4)", "assume fin: \"final g\""], ["proof (state)\nthis:\n  final g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; noExceptionals g (set V);\n     separated g (set V); distinct V; set V \\<subseteq> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^bsub>f\\<in>filter\n      (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n      (faces g)\\<^esub> \\<d> |vertices f|) =\n                      (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 +\n               quad g v * \\<d> 4)", "assume ne: \"noExceptionals g (set V)\""], ["proof (state)\nthis:\n  noExceptionals g (set V)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; noExceptionals g (set V);\n     separated g (set V); distinct V; set V \\<subseteq> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^bsub>f\\<in>filter\n      (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n      (faces g)\\<^esub> \\<d> |vertices f|) =\n                      (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 +\n               quad g v * \\<d> 4)", "assume \"separated g (set V)\"  \"distinct V\" and V_subset: \"set V \\<subseteq> set (vertices g)\""], ["proof (state)\nthis:\n  separated g (set V)\n  distinct V\n  set V \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; noExceptionals g (set V);\n     separated g (set V); distinct V; set V \\<subseteq> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^bsub>f\\<in>filter\n      (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n      (faces g)\\<^esub> \\<d> |vertices f|) =\n                      (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 +\n               quad g v * \\<d> 4)", "with pl ne fin"], ["proof (chain)\npicking this:\n  Invariants.inv g\n  noExceptionals g (set V)\n  final g\n  separated g (set V)\n  distinct V\n  set V \\<subseteq> \\<V> g", "have\n    \"(\\<Sum>\\<^bsub>f \\<in> [f\\<leftarrow>faces g. \\<exists>v\\<in>set V. f\\<in>set (facesAt g v)]\\<^esub> \\<d> |vertices f| )\n   = (\\<Sum>\\<^bsub>v \\<in> V\\<^esub> \\<Sum>\\<^bsub>f \\<in> facesAt g v\\<^esub> \\<d> |vertices f| )\""], ["proof (prove)\nusing this:\n  Invariants.inv g\n  noExceptionals g (set V)\n  final g\n  separated g (set V)\n  distinct V\n  set V \\<subseteq> \\<V> g\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>filter\n                          (\\<lambda>f.\n                              \\<exists>v\\<in>set V.\n                                 f \\<in> set (facesAt g v))\n                          (faces g)\\<^esub> \\<d> |vertices f|) =\n    (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> \\<Sum>\\<^bsub>f\\<in>facesAt g\n                  v\\<^esub> \\<d> |vertices f|)", "by (simp add: separated_disj_Union2)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>f\\<in>filter\n                        (\\<lambda>f.\n                            \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n                        (faces g)\\<^esub> \\<d> |vertices f|) =\n  (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> \\<Sum>\\<^bsub>f\\<in>facesAt g\n                v\\<^esub> \\<d> |vertices f|)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; noExceptionals g (set V);\n     separated g (set V); distinct V; set V \\<subseteq> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^bsub>f\\<in>filter\n      (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n      (faces g)\\<^esub> \\<d> |vertices f|) =\n                      (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 +\n               quad g v * \\<d> 4)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>f\\<in>filter\n                        (\\<lambda>f.\n                            \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n                        (faces g)\\<^esub> \\<d> |vertices f|) =\n  (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> \\<Sum>\\<^bsub>f\\<in>facesAt g\n                v\\<^esub> \\<d> |vertices f|)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; noExceptionals g (set V);\n     separated g (set V); distinct V; set V \\<subseteq> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^bsub>f\\<in>filter\n      (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n      (faces g)\\<^esub> \\<d> |vertices f|) =\n                      (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 +\n               quad g v * \\<d> 4)", "have \"\\<And>v. v \\<in> set V \\<Longrightarrow>\n    (\\<Sum>\\<^bsub>f \\<in> facesAt g v\\<^esub> \\<d> |vertices f| )\n  = (tri g v) * \\<d> 3 + (quad g v) * \\<d> 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set V \\<Longrightarrow>\n       (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n       tri g v * \\<d> 3 + quad g v * \\<d> 4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set V \\<Longrightarrow>\n       (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n       tri g v * \\<d> 3 + quad g v * \\<d> 4", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set V \\<Longrightarrow>\n       (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n       tri g v * \\<d> 3 + quad g v * \\<d> 4", "assume v1: \"v \\<in> set V\""], ["proof (state)\nthis:\n  v \\<in> set V\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set V \\<Longrightarrow>\n       (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n       tri g v * \\<d> 3 + quad g v * \\<d> 4", "with V_subset"], ["proof (chain)\npicking this:\n  set V \\<subseteq> \\<V> g\n  v \\<in> set V", "have v: \"v \\<in> set (vertices g)\""], ["proof (prove)\nusing this:\n  set V \\<subseteq> \\<V> g\n  v \\<in> set V\n\ngoal (1 subgoal):\n 1. v \\<in> \\<V> g", "by auto"], ["proof (state)\nthis:\n  v \\<in> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set V \\<Longrightarrow>\n       (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n       tri g v * \\<d> 3 + quad g v * \\<d> 4", "with ne"], ["proof (chain)\npicking this:\n  noExceptionals g (set V)\n  v \\<in> \\<V> g", "have d:\n      \"\\<And>f. f \\<in> set (facesAt g v) \\<Longrightarrow>\n      |vertices f| = 3 \\<or> |vertices f| = 4\""], ["proof (prove)\nusing this:\n  noExceptionals g (set V)\n  v \\<in> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (facesAt g v) \\<Longrightarrow>\n       triangle f \\<or> |vertices f| = 4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g v); noExceptionals g (set V);\n        v \\<in> \\<V> g\\<rbrakk>\n       \\<Longrightarrow> triangle f \\<or> |vertices f| = 4", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g v); noExceptionals g (set V);\n        v \\<in> \\<V> g\\<rbrakk>\n       \\<Longrightarrow> triangle f \\<or> |vertices f| = 4", "assume f: \"f \\<in> set (facesAt g v)\""], ["proof (state)\nthis:\n  f \\<in> set (facesAt g v)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g v); noExceptionals g (set V);\n        v \\<in> \\<V> g\\<rbrakk>\n       \\<Longrightarrow> triangle f \\<or> |vertices f| = 4", "then"], ["proof (chain)\npicking this:\n  f \\<in> set (facesAt g v)", "have ff: \"f \\<in> set (faces g)\""], ["proof (prove)\nusing this:\n  f \\<in> set (facesAt g v)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<F> g", "by (rule minGraphProps5[OF inv_mgp[OF pl] v])"], ["proof (state)\nthis:\n  f \\<in> \\<F> g\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g v); noExceptionals g (set V);\n        v \\<in> \\<V> g\\<rbrakk>\n       \\<Longrightarrow> triangle f \\<or> |vertices f| = 4", "with ne f v1 pl fin v"], ["proof (chain)\npicking this:\n  noExceptionals g (set V)\n  f \\<in> set (facesAt g v)\n  v \\<in> set V\n  Invariants.inv g\n  final g\n  v \\<in> \\<V> g\n  f \\<in> \\<F> g", "have \"|vertices f| \\<le> 4\""], ["proof (prove)\nusing this:\n  noExceptionals g (set V)\n  f \\<in> set (facesAt g v)\n  v \\<in> set V\n  Invariants.inv g\n  final g\n  v \\<in> \\<V> g\n  f \\<in> \\<F> g\n\ngoal (1 subgoal):\n 1. |vertices f| \\<le> 4", "by (auto simp add: noExceptionals_def not_exceptional)"], ["proof (state)\nthis:\n  |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g v); noExceptionals g (set V);\n        v \\<in> \\<V> g\\<rbrakk>\n       \\<Longrightarrow> triangle f \\<or> |vertices f| = 4", "moreover"], ["proof (state)\nthis:\n  |vertices f| \\<le> 4\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g v); noExceptionals g (set V);\n        v \\<in> \\<V> g\\<rbrakk>\n       \\<Longrightarrow> triangle f \\<or> |vertices f| = 4", "from pl ff"], ["proof (chain)\npicking this:\n  Invariants.inv g\n  f \\<in> \\<F> g", "have \"3 \\<le> |vertices f|\""], ["proof (prove)\nusing this:\n  Invariants.inv g\n  f \\<in> \\<F> g\n\ngoal (1 subgoal):\n 1. 3 \\<le> |vertices f|", "by(rule planeN4)"], ["proof (state)\nthis:\n  3 \\<le> |vertices f|\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> set (facesAt g v); noExceptionals g (set V);\n        v \\<in> \\<V> g\\<rbrakk>\n       \\<Longrightarrow> triangle f \\<or> |vertices f| = 4", "ultimately"], ["proof (chain)\npicking this:\n  |vertices f| \\<le> 4\n  3 \\<le> |vertices f|", "show \"?thesis f\""], ["proof (prove)\nusing this:\n  |vertices f| \\<le> 4\n  3 \\<le> |vertices f|\n\ngoal (1 subgoal):\n 1. triangle f \\<or> |vertices f| = 4", "by arith"], ["proof (state)\nthis:\n  triangle f \\<or> |vertices f| = 4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> set (facesAt g v) \\<Longrightarrow>\n  triangle ?f \\<or> |vertices ?f| = 4\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set V \\<Longrightarrow>\n       (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n       tri g v * \\<d> 3 + quad g v * \\<d> 4", "from d pl v"], ["proof (chain)\npicking this:\n  ?f \\<in> set (facesAt g v) \\<Longrightarrow>\n  triangle ?f \\<or> |vertices ?f| = 4\n  Invariants.inv g\n  v \\<in> \\<V> g", "have\n      \"(\\<Sum>\\<^bsub>f \\<in> facesAt g v\\<^esub> \\<d> |vertices f| )\n    = (\\<Sum>\\<^bsub>f\\<in>[f \\<leftarrow> facesAt g v. |vertices f| = 3]\\<^esub> \\<d> |vertices f| )\n    + (\\<Sum>\\<^bsub>f\\<in>[f \\<leftarrow> facesAt g v. |vertices f| = 4]\\<^esub> \\<d> |vertices f| )\""], ["proof (prove)\nusing this:\n  ?f \\<in> set (facesAt g v) \\<Longrightarrow>\n  triangle ?f \\<or> |vertices ?f| = 4\n  Invariants.inv g\n  v \\<in> \\<V> g\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n    (\\<Sum>\\<^bsub>f\\<in>filter triangle\n                          (facesAt g v)\\<^esub> \\<d> |vertices f|) +\n    (\\<Sum>\\<^bsub>f\\<in>filter (\\<lambda>f. |vertices f| = 4)\n                          (facesAt g v)\\<^esub> \\<d> |vertices f|)", "apply (rule_tac ListSum_disj_union)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> distinct (filter triangle (facesAt g v))\n 2. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (filter (\\<lambda>f. |vertices f| = 4) (facesAt g v))\n 3. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> distinct (facesAt g v)\n 4. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (facesAt g v) =\n                      set (filter triangle (facesAt g v)) \\<union>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v))\n 5. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (filter triangle (facesAt g v)) \\<inter>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v)) =\n                      {}", "apply (rule distinct_filter)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> distinct (facesAt g v)\n 2. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (filter (\\<lambda>f. |vertices f| = 4) (facesAt g v))\n 3. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> distinct (facesAt g v)\n 4. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (facesAt g v) =\n                      set (filter triangle (facesAt g v)) \\<union>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v))\n 5. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (filter triangle (facesAt g v)) \\<inter>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v)) =\n                      {}", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (filter (\\<lambda>f. |vertices f| = 4) (facesAt g v))\n 2. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> distinct (facesAt g v)\n 3. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (facesAt g v) =\n                      set (filter triangle (facesAt g v)) \\<union>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v))\n 4. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (filter triangle (facesAt g v)) \\<inter>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v)) =\n                      {}", "apply (rule distinct_filter)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> distinct (facesAt g v)\n 2. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> distinct (facesAt g v)\n 3. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (facesAt g v) =\n                      set (filter triangle (facesAt g v)) \\<union>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v))\n 4. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (filter triangle (facesAt g v)) \\<inter>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v)) =\n                      {}", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> distinct (facesAt g v)\n 2. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (facesAt g v) =\n                      set (filter triangle (facesAt g v)) \\<union>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v))\n 3. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (filter triangle (facesAt g v)) \\<inter>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v)) =\n                      {}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (facesAt g v) =\n                      set (filter triangle (facesAt g v)) \\<union>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v))\n 2. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (filter triangle (facesAt g v)) \\<inter>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v)) =\n                      {}", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f.\n                f \\<in> set (facesAt g v) \\<Longrightarrow>\n                triangle f \\<or> |vertices f| = 4;\n     Invariants.inv g; v \\<in> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> set (filter triangle (facesAt g v)) \\<inter>\n                      set (filter (\\<lambda>f. |vertices f| = 4)\n                            (facesAt g v)) =\n                      {}", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n  (\\<Sum>\\<^bsub>f\\<in>filter triangle\n                        (facesAt g v)\\<^esub> \\<d> |vertices f|) +\n  (\\<Sum>\\<^bsub>f\\<in>filter (\\<lambda>f. |vertices f| = 4)\n                        (facesAt g v)\\<^esub> \\<d> |vertices f|)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set V \\<Longrightarrow>\n       (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n       tri g v * \\<d> 3 + quad g v * \\<d> 4", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n  (\\<Sum>\\<^bsub>f\\<in>filter triangle\n                        (facesAt g v)\\<^esub> \\<d> |vertices f|) +\n  (\\<Sum>\\<^bsub>f\\<in>filter (\\<lambda>f. |vertices f| = 4)\n                        (facesAt g v)\\<^esub> \\<d> |vertices f|)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set V \\<Longrightarrow>\n       (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n       tri g v * \\<d> 3 + quad g v * \\<d> 4", "have \"\\<dots> = tri g v * \\<d> 3 + quad g v * \\<d> 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>filter triangle\n                          (facesAt g v)\\<^esub> \\<d> |vertices f|) +\n    (\\<Sum>\\<^bsub>f\\<in>filter (\\<lambda>f. |vertices f| = 4)\n                          (facesAt g v)\\<^esub> \\<d> |vertices f|) =\n    tri g v * \\<d> 3 + quad g v * \\<d> 4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>filter triangle\n                          (facesAt g v)\\<^esub> \\<d> |vertices f|) +\n    (\\<Sum>\\<^bsub>f\\<in>filter (\\<lambda>f. |vertices f| = 4)\n                          (facesAt g v)\\<^esub> \\<d> |vertices f|) =\n    tri g v * \\<d> 3 + quad g v * \\<d> 4", "from pl fin v"], ["proof (chain)\npicking this:\n  Invariants.inv g\n  final g\n  v \\<in> \\<V> g", "have \"\\<And>A.[f \\<leftarrow> facesAt g v. final f \\<and> A f]\n        = [f \\<leftarrow> facesAt g v. A f]\""], ["proof (prove)\nusing this:\n  Invariants.inv g\n  final g\n  v \\<in> \\<V> g\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       filter (\\<lambda>f. final f \\<and> A f) (facesAt g v) =\n       filter A (facesAt g v)", "by (rule_tac filter_eqI) (auto simp:plane_final_facesAt)"], ["proof (state)\nthis:\n  filter (\\<lambda>f. final f \\<and> ?A f) (facesAt g v) =\n  filter ?A (facesAt g v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>filter triangle\n                          (facesAt g v)\\<^esub> \\<d> |vertices f|) +\n    (\\<Sum>\\<^bsub>f\\<in>filter (\\<lambda>f. |vertices f| = 4)\n                          (facesAt g v)\\<^esub> \\<d> |vertices f|) =\n    tri g v * \\<d> 3 + quad g v * \\<d> 4", "with fin"], ["proof (chain)\npicking this:\n  final g\n  filter (\\<lambda>f. final f \\<and> ?A f) (facesAt g v) =\n  filter ?A (facesAt g v)", "show ?thesis"], ["proof (prove)\nusing this:\n  final g\n  filter (\\<lambda>f. final f \\<and> ?A f) (facesAt g v) =\n  filter ?A (facesAt g v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>filter triangle\n                          (facesAt g v)\\<^esub> \\<d> |vertices f|) +\n    (\\<Sum>\\<^bsub>f\\<in>filter (\\<lambda>f. |vertices f| = 4)\n                          (facesAt g v)\\<^esub> \\<d> |vertices f|) =\n    tri g v * \\<d> 3 + quad g v * \\<d> 4", "by (auto simp add: tri_def quad_def)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>f\\<in>filter triangle\n                        (facesAt g v)\\<^esub> \\<d> |vertices f|) +\n  (\\<Sum>\\<^bsub>f\\<in>filter (\\<lambda>f. |vertices f| = 4)\n                        (facesAt g v)\\<^esub> \\<d> |vertices f|) =\n  tri g v * \\<d> 3 + quad g v * \\<d> 4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>f\\<in>filter triangle\n                        (facesAt g v)\\<^esub> \\<d> |vertices f|) +\n  (\\<Sum>\\<^bsub>f\\<in>filter (\\<lambda>f. |vertices f| = 4)\n                        (facesAt g v)\\<^esub> \\<d> |vertices f|) =\n  tri g v * \\<d> 3 + quad g v * \\<d> 4\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> set V \\<Longrightarrow>\n       (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n       tri g v * \\<d> 3 + quad g v * \\<d> 4", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n  tri g v * \\<d> 3 + quad g v * \\<d> 4", "show \"(\\<Sum>\\<^bsub>f \\<in> facesAt g v\\<^esub> \\<d> |vertices f| ) = tri g v * \\<d> 3 + quad g v * \\<d> 4\""], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n  tri g v * \\<d> 3 + quad g v * \\<d> 4\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n    tri g v * \\<d> 3 + quad g v * \\<d> 4", "."], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>f\\<in>facesAt g v\\<^esub> \\<d> |vertices f|) =\n  tri g v * \\<d> 3 + quad g v * \\<d> 4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?v \\<in> set V \\<Longrightarrow>\n  (\\<Sum>\\<^bsub>f\\<in>facesAt g ?v\\<^esub> \\<d> |vertices f|) =\n  tri g ?v * \\<d> 3 + quad g ?v * \\<d> 4\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; noExceptionals g (set V);\n     separated g (set V); distinct V; set V \\<subseteq> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^bsub>f\\<in>filter\n      (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n      (faces g)\\<^esub> \\<d> |vertices f|) =\n                      (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 +\n               quad g v * \\<d> 4)", "then"], ["proof (chain)\npicking this:\n  ?v \\<in> set V \\<Longrightarrow>\n  (\\<Sum>\\<^bsub>f\\<in>facesAt g ?v\\<^esub> \\<d> |vertices f|) =\n  tri g ?v * \\<d> 3 + quad g ?v * \\<d> 4", "have \"(\\<Sum>\\<^bsub>v \\<in> V\\<^esub> \\<Sum>\\<^bsub>f \\<in> facesAt g v\\<^esub> \\<d> |vertices f| ) =\n         (\\<Sum>\\<^bsub>v \\<in> V\\<^esub> (tri g v * \\<d> 3 + quad g v * \\<d> 4))\""], ["proof (prove)\nusing this:\n  ?v \\<in> set V \\<Longrightarrow>\n  (\\<Sum>\\<^bsub>f\\<in>facesAt g ?v\\<^esub> \\<d> |vertices f|) =\n  tri g ?v * \\<d> 3 + quad g ?v * \\<d> 4\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> \\<Sum>\\<^bsub>f\\<in>facesAt g\n                  v\\<^esub> \\<d> |vertices f|) =\n    (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 + quad g v * \\<d> 4)", "by (rule ListSum_eq)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> \\<Sum>\\<^bsub>f\\<in>facesAt g\n                v\\<^esub> \\<d> |vertices f|) =\n  (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 + quad g v * \\<d> 4)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Invariants.inv g; final g; noExceptionals g (set V);\n     separated g (set V); distinct V; set V \\<subseteq> \\<V> g\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>\\<^bsub>f\\<in>filter\n      (\\<lambda>f. \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n      (faces g)\\<^esub> \\<d> |vertices f|) =\n                      (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 +\n               quad g v * \\<d> 4)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^bsub>f\\<in>filter\n                        (\\<lambda>f.\n                            \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n                        (faces g)\\<^esub> \\<d> |vertices f|) =\n  (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 + quad g v * \\<d> 4)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^bsub>f\\<in>filter\n                        (\\<lambda>f.\n                            \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n                        (faces g)\\<^esub> \\<d> |vertices f|) =\n  (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 + quad g v * \\<d> 4)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^bsub>f\\<in>filter\n                          (\\<lambda>f.\n                              \\<exists>v\\<in>set V.\n                                 f \\<in> set (facesAt g v))\n                          (faces g)\\<^esub> \\<d> |vertices f|) =\n    (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 + quad g v * \\<d> 4)", "."], ["proof (state)\nthis:\n  (\\<Sum>\\<^bsub>f\\<in>filter\n                        (\\<lambda>f.\n                            \\<exists>v\\<in>set V. f \\<in> set (facesAt g v))\n                        (faces g)\\<^esub> \\<d> |vertices f|) =\n  (\\<Sum>\\<^bsub>v\\<in>V\\<^esub> tri g v * \\<d> 3 + quad g v * \\<d> 4)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma separated_subset: (* separated *)\n   \"V1 \\<subseteq> V2 \\<Longrightarrow> separated g V2 \\<Longrightarrow> separated g V1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V1 \\<subseteq> V2; separated g V2\\<rbrakk>\n    \\<Longrightarrow> separated g V1", "proof (simp add:  separated_def separated\\<^sub>3_def separated\\<^sub>2_def,\n  elim conjE, intro allI impI ballI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V1\n 2. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V1 = {v}", "fix v f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V1\n 2. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V1 = {v}", "assume a: \"v \\<in> V1\" \"V1 \\<subseteq> V2\" \"f \\<in> set (facesAt g v)\"\n    \"|vertices f| \\<le> 4\"\n    \"\\<forall>v\\<in>V2. \\<forall>f\\<in>set (facesAt g v). |vertices f| \\<le> 4 \\<longrightarrow>\n      set (vertices f) \\<inter> V2 = {v}\""], ["proof (state)\nthis:\n  v \\<in> V1\n  V1 \\<subseteq> V2\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  \\<forall>v\\<in>V2.\n     \\<forall>f\\<in>set (facesAt g v).\n        |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> V2 = {v}\n\ngoal (2 subgoals):\n 1. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V1\n 2. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v); |vertices f| \\<le> 4\\<rbrakk>\n       \\<Longrightarrow> \\<V> f \\<inter> V1 = {v}", "then"], ["proof (chain)\npicking this:\n  v \\<in> V1\n  V1 \\<subseteq> V2\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  \\<forall>v\\<in>V2.\n     \\<forall>f\\<in>set (facesAt g v).\n        |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> V2 = {v}", "show \"set (vertices f) \\<inter> V1 = {v}\""], ["proof (prove)\nusing this:\n  v \\<in> V1\n  V1 \\<subseteq> V2\n  f \\<in> set (facesAt g v)\n  |vertices f| \\<le> 4\n  \\<forall>v\\<in>V2.\n     \\<forall>f\\<in>set (facesAt g v).\n        |vertices f| \\<le> 4 \\<longrightarrow> \\<V> f \\<inter> V2 = {v}\n\ngoal (1 subgoal):\n 1. \\<V> f \\<inter> V1 = {v}", "by auto"], ["proof (state)\nthis:\n  \\<V> f \\<inter> V1 = {v}\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V1", "fix v f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V1", "assume a: \"v \\<in> V1\" \"V1 \\<subseteq> V2\" \"f \\<in> set (facesAt g v)\"\n    \"\\<forall>v\\<in>V2. \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2\""], ["proof (state)\nthis:\n  v \\<in> V1\n  V1 \\<subseteq> V2\n  f \\<in> set (facesAt g v)\n  \\<forall>v\\<in>V2.\n     \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V1", "then"], ["proof (chain)\npicking this:\n  v \\<in> V1\n  V1 \\<subseteq> V2\n  f \\<in> set (facesAt g v)\n  \\<forall>v\\<in>V2.\n     \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2", "have \"v \\<in> V2\""], ["proof (prove)\nusing this:\n  v \\<in> V1\n  V1 \\<subseteq> V2\n  f \\<in> set (facesAt g v)\n  \\<forall>v\\<in>V2.\n     \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2\n\ngoal (1 subgoal):\n 1. v \\<in> V2", "by auto"], ["proof (state)\nthis:\n  v \\<in> V2\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V1", "with a"], ["proof (chain)\npicking this:\n  v \\<in> V1\n  V1 \\<subseteq> V2\n  f \\<in> set (facesAt g v)\n  \\<forall>v\\<in>V2.\n     \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2\n  v \\<in> V2", "have \"f \\<bullet> v \\<notin> V2\""], ["proof (prove)\nusing this:\n  v \\<in> V1\n  V1 \\<subseteq> V2\n  f \\<in> set (facesAt g v)\n  \\<forall>v\\<in>V2.\n     \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2\n  v \\<in> V2\n\ngoal (1 subgoal):\n 1. f \\<bullet> v \\<notin> V2", "by auto"], ["proof (state)\nthis:\n  f \\<bullet> v \\<notin> V2\n\ngoal (1 subgoal):\n 1. \\<And>v f.\n       \\<lbrakk>V1 \\<subseteq> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2;\n        \\<forall>v\\<in>V2.\n           \\<forall>f\\<in>set (facesAt g v).\n              |vertices f| \\<le> 4 \\<longrightarrow>\n              \\<V> f \\<inter> V2 = {v};\n        v \\<in> V1; f \\<in> set (facesAt g v)\\<rbrakk>\n       \\<Longrightarrow> f \\<bullet> v \\<notin> V1", "with a"], ["proof (chain)\npicking this:\n  v \\<in> V1\n  V1 \\<subseteq> V2\n  f \\<in> set (facesAt g v)\n  \\<forall>v\\<in>V2.\n     \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2\n  f \\<bullet> v \\<notin> V2", "show \"f \\<bullet> v \\<notin> V1\""], ["proof (prove)\nusing this:\n  v \\<in> V1\n  V1 \\<subseteq> V2\n  f \\<in> set (facesAt g v)\n  \\<forall>v\\<in>V2.\n     \\<forall>f\\<in>set (facesAt g v). f \\<bullet> v \\<notin> V2\n  f \\<bullet> v \\<notin> V2\n\ngoal (1 subgoal):\n 1. f \\<bullet> v \\<notin> V1", "by auto"], ["proof (state)\nthis:\n  f \\<bullet> v \\<notin> V1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}