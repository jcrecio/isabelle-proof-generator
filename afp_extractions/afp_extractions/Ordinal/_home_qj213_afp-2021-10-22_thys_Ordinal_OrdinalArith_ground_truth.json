{"file_name": "/home/qj213/afp-2021-10-22/thys/Ordinal/OrdinalArith.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ordinal", "problem_names": ["lemma normal_plus: \"normal ((+) x)\"", "lemma ordinal_plus_0 [simp]: \"x + 0 = (x::ordinal)\"", "lemma ordinal_plus_oSuc [simp]: \"x + oSuc y = oSuc (x + y)\"", "lemma ordinal_plus_oLimit [simp]: \"x + oLimit f = oLimit (\\<lambda>n. x + f n)\"", "lemma ordinal_0_plus [simp]: \"0 + x = (x::ordinal)\"", "lemma ordinal_plus_assoc:\n\"(x + y) + z = x + (y + z::ordinal)\"", "lemma ordinal_plus_monoL [rule_format]:\n\"\\<forall>x x'. x \\<le> x' \\<longrightarrow> x + y \\<le> x' + (y::ordinal)\"", "lemma ordinal_plus_monoR: \"y \\<le> y' \\<Longrightarrow> x + y \\<le> x + (y'::ordinal)\"", "lemma ordinal_plus_mono:\n\"\\<lbrakk>x \\<le> x'; y \\<le> y'\\<rbrakk> \\<Longrightarrow> x + y \\<le> x' + (y'::ordinal)\"", "lemma ordinal_plus_strict_monoR: \"y < y' \\<Longrightarrow> x + y < x + (y'::ordinal)\"", "lemma ordinal_le_plusL [simp]: \"y \\<le> x + (y::ordinal)\"", "lemma ordinal_le_plusR [simp]: \"x \\<le> x + (y::ordinal)\"", "lemma ordinal_less_plusR: \"0 < y \\<Longrightarrow> x < x + (y::ordinal)\"", "lemma ordinal_plus_left_cancel [simp]:\n\"(w + x = w + y) = (x = (y::ordinal))\"", "lemma ordinal_plus_left_cancel_le [simp]:\n\"(w + x \\<le> w + y) = (x \\<le> (y::ordinal))\"", "lemma ordinal_plus_left_cancel_less [simp]:\n\"(w + x < w + y) = (x < (y::ordinal))\"", "lemma ordinal_plus_not_0: \"(0 < x + y) = (0 < x \\<or> 0 < (y::ordinal))\"", "lemma not_inject: \"(\\<not> P) = (\\<not> Q) \\<Longrightarrow> P = Q\"", "lemma ordinal_plus_eq_0:\n\"((x::ordinal) + y = 0) = (x = 0 \\<and> y = 0)\"", "lemma continuous_minus: \"continuous (\\<lambda>x. x - y)\"", "lemma ordinal_0_minus [simp]: \"0 - x = (0::ordinal)\"", "lemma ordinal_oSuc_minus [simp]: \"y \\<le> x \\<Longrightarrow> oSuc x - y = oSuc (x - y)\"", "lemma ordinal_oLimit_minus [simp]: \"oLimit f - y = oLimit (\\<lambda>n. f n - y)\"", "lemma ordinal_minus_0 [simp]: \"x - 0 = (x::ordinal)\"", "lemma ordinal_oSuc_minus2: \"x < y \\<Longrightarrow> oSuc x - y = x - y\"", "lemma ordinal_minus_eq_0 [rule_format, simp]:\n\"x \\<le> y \\<longrightarrow> x - y = (0::ordinal)\"", "lemma ordinal_plus_minus1 [simp]: \"(x + y) - x = (y::ordinal)\"", "lemma ordinal_plus_minus2 [simp]: \"x \\<le> y \\<Longrightarrow> x + (y - x) = (y::ordinal)\"", "lemma ordinal_minusI: \"x = y + z \\<Longrightarrow> x - y = (z::ordinal)\"", "lemma ordinal_minus_less_eq [simp]:\n\"(y::ordinal) \\<le> x \\<Longrightarrow> (x - y < z) = (x < y + z)\"", "lemma ordinal_minus_le_eq [simp]:\n\"(x - y \\<le> z) = (x \\<le> y + (z::ordinal))\"", "lemma ordinal_minus_monoL: \"x \\<le> y \\<Longrightarrow> x - z \\<le> y - (z::ordinal)\"", "lemma ordinal_minus_monoR: \"x \\<le> y \\<Longrightarrow> z - y \\<le> z - (x::ordinal)\"", "lemma continuous_times: \"continuous ((*) x)\"", "lemma normal_times: \"0 < x \\<Longrightarrow> normal ((*) x)\"", "lemma ordinal_times_0 [simp]: \"x * 0 = (0::ordinal)\"", "lemma ordinal_times_oSuc [simp]: \"x * oSuc y = (x * y) + x\"", "lemma ordinal_times_oLimit [simp]: \"x * oLimit f = oLimit (\\<lambda>n. x * f n)\"", "lemma ordinal_0_times [simp]: \"0 * x = (0::ordinal)\"", "lemma ordinal_1_times [simp]: \"oSuc 0 * x = (x::ordinal)\"", "lemma ordinal_times_1 [simp]: \"x * oSuc 0 = (x::ordinal)\"", "lemma ordinal_times_distrib:\n\"x * (y + z) = (x * y) + (x * z::ordinal)\"", "lemma ordinal_times_assoc:\n\"(x * y::ordinal) * z = x * (y * z)\"", "lemma ordinal_times_monoL [rule_format]:\n\"\\<forall>x x'. x \\<le> x' \\<longrightarrow> x * y \\<le> x' * (y::ordinal)\"", "lemma ordinal_times_monoR: \"y \\<le> y' \\<Longrightarrow> x * y \\<le> x * (y'::ordinal)\"", "lemma ordinal_times_mono:\n\"\\<lbrakk>x \\<le> x'; y \\<le> y'\\<rbrakk> \\<Longrightarrow> x * y \\<le> x' * (y'::ordinal)\"", "lemma ordinal_times_strict_monoR:\n\"\\<lbrakk>y < y'; 0 < x\\<rbrakk> \\<Longrightarrow> x * y < x * (y'::ordinal)\"", "lemma ordinal_le_timesL [simp]: \"0 < x \\<Longrightarrow> y \\<le> x * (y::ordinal)\"", "lemma ordinal_le_timesR [simp]: \"0 < y \\<Longrightarrow> x \\<le> x * (y::ordinal)\"", "lemma ordinal_less_timesR: \"\\<lbrakk>0 < x; oSuc 0 < y\\<rbrakk> \\<Longrightarrow> x < x * (y::ordinal)\"", "lemma ordinal_times_left_cancel [simp]:\n\"0 < w \\<Longrightarrow> (w * x = w * y) = (x = (y::ordinal))\"", "lemma ordinal_times_left_cancel_le [simp]:\n\"0 < w \\<Longrightarrow> (w * x \\<le> w * y) = (x \\<le> (y::ordinal))\"", "lemma ordinal_times_left_cancel_less [simp]:\n\"0 < w \\<Longrightarrow> (w * x < w * y) = (x < (y::ordinal))\"", "lemma ordinal_times_eq_0:\n\"((x::ordinal) * y = 0) = (x = 0 \\<or> y = 0)\"", "lemma ordinal_times_not_0 [simp]:\n\"((0::ordinal) < x * y) = (0 < x \\<and> 0 < y)\"", "lemma continuous_exp: \"0 < x \\<Longrightarrow> continuous ((**) x)\"", "lemma ordinal_exp_0 [simp]: \"x ** 0 = (1::ordinal)\"", "lemma ordinal_exp_oSuc [simp]: \"x ** oSuc y = (x ** y) * x\"", "lemma ordinal_exp_oLimit [simp]:\n\"0 < x \\<Longrightarrow> x ** oLimit f = oLimit (\\<lambda>n. x ** f n)\"", "lemma ordinal_0_exp [simp]: \"0 ** x = (if x = 0 then 1 else 0)\"", "lemma ordinal_1_exp [simp]: \"oSuc 0 ** x = oSuc 0\"", "lemma ordinal_exp_1 [simp]: \"x ** oSuc 0 = x\"", "lemma ordinal_exp_distrib:\n\"x ** (y + z) = (x ** y) * (x ** (z::ordinal))\"", "lemma ordinal_exp_not_0 [simp]: \"(0 < x ** y) = (0 < x \\<or> y = 0)\"", "lemma ordinal_exp_eq_0 [simp]: \"(x ** y = 0) = (x = 0 \\<and> 0 < y)\"", "lemma ordinal_exp_assoc:\n\"(x ** y) ** z = x ** (y * z)\"", "lemma ordinal_exp_monoL [rule_format]:\n\"\\<forall>x x'. x \\<le> x' \\<longrightarrow> x ** y \\<le> x' ** (y::ordinal)\"", "lemma normal_exp: \"oSuc 0 < x \\<Longrightarrow> normal ((**) x)\"", "lemma ordinal_exp_monoR:\n\"\\<lbrakk>0 < x; y \\<le> y'\\<rbrakk> \\<Longrightarrow> x ** y \\<le> x ** (y'::ordinal)\"", "lemma ordinal_exp_mono:\n\"\\<lbrakk>0 < x'; x \\<le> x'; y \\<le> y'\\<rbrakk> \\<Longrightarrow> x ** y \\<le> x' ** (y'::ordinal)\"", "lemma ordinal_exp_strict_monoR:\n\"\\<lbrakk>oSuc 0 < x; y < y'\\<rbrakk> \\<Longrightarrow> x ** y < x ** (y'::ordinal)\"", "lemma ordinal_le_expR [simp]: \"0 < y \\<Longrightarrow> x \\<le> x ** (y::ordinal)\"", "lemma ordinal_exp_left_cancel [simp]:\n\"oSuc 0 < w \\<Longrightarrow> (w ** x = w ** y) = (x = y)\"", "lemma ordinal_exp_left_cancel_le [simp]:\n\"oSuc 0 < w \\<Longrightarrow> (w ** x \\<le> w ** y) = (x \\<le> y)\"", "lemma ordinal_exp_left_cancel_less [simp]:\n\"oSuc 0 < w \\<Longrightarrow> (w ** x < w ** y) = (x < y)\""], "translations": [["", "lemma normal_plus: \"normal ((+) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal ((+) x)", "by (simp add: plus_ordinal_def normal_ordinal_rec)"], ["", "lemma ordinal_plus_0 [simp]: \"x + 0 = (x::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 0 = x", "by (simp add: plus_ordinal_def)"], ["", "lemma ordinal_plus_oSuc [simp]: \"x + oSuc y = oSuc (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + oSuc y = oSuc (x + y)", "by (simp add: plus_ordinal_def)"], ["", "lemma ordinal_plus_oLimit [simp]: \"x + oLimit f = oLimit (\\<lambda>n. x + f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + oLimit f = oLimit (\\<lambda>n. x + f n)", "by (simp add: normal.oLimit normal_plus)"], ["", "lemma ordinal_0_plus [simp]: \"0 + x = (x::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + x = x", "by (rule_tac a=x in oLimit_induct, simp_all)"], ["", "lemma ordinal_plus_assoc:\n\"(x + y) + z = x + (y + z::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y + z = x + (y + z)", "by (rule_tac a=z in oLimit_induct, simp_all)"], ["", "lemma ordinal_plus_monoL [rule_format]:\n\"\\<forall>x x'. x \\<le> x' \\<longrightarrow> x + y \\<le> x' + (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x x'. x \\<le> x' \\<longrightarrow> x + y \\<le> x' + y", "apply (rule_tac a=y in oLimit_induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x + f n \\<le> x' + f n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x x'.\n                            x \\<le> x' \\<longrightarrow>\n                            oLimit (\\<lambda>n. x + f n)\n                            \\<le> oLimit (\\<lambda>n. x' + f n)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x x'.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x + f n \\<le> x' + f n;\n        x \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> oLimit (\\<lambda>n. x + f n)\n                         \\<le> oLimit (\\<lambda>n. x' + f n)", "apply (rule oLimit_leI, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x x' n.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x + f n \\<le> x' + f n;\n        x \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> x + f n \\<le> oLimit (\\<lambda>n. x' + f n)", "apply (rule_tac n=n in le_oLimitI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x x' n.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x + f n \\<le> x' + f n;\n        x \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> x + f n \\<le> x' + f n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_plus_monoR: \"y \\<le> y' \\<Longrightarrow> x + y \\<le> x + (y'::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> y' \\<Longrightarrow> x + y \\<le> x + y'", "by (rule normal.monoD[OF normal_plus])"], ["", "lemma ordinal_plus_mono:\n\"\\<lbrakk>x \\<le> x'; y \\<le> y'\\<rbrakk> \\<Longrightarrow> x + y \\<le> x' + (y'::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x'; y \\<le> y'\\<rbrakk>\n    \\<Longrightarrow> x + y \\<le> x' + y'", "by (rule order_trans[OF ordinal_plus_monoL ordinal_plus_monoR])"], ["", "lemma ordinal_plus_strict_monoR: \"y < y' \\<Longrightarrow> x + y < x + (y'::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < y' \\<Longrightarrow> x + y < x + y'", "by (rule normal.strict_monoD[OF normal_plus])"], ["", "lemma ordinal_le_plusL [simp]: \"y \\<le> x + (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x + y", "by (cut_tac ordinal_plus_monoL[OF ordinal_0_le], simp)"], ["", "lemma ordinal_le_plusR [simp]: \"x \\<le> x + (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x + y", "by (cut_tac ordinal_plus_monoR[OF ordinal_0_le], simp)"], ["", "lemma ordinal_less_plusR: \"0 < y \\<Longrightarrow> x < x + (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> x < x + y", "by (drule_tac ordinal_plus_strict_monoR, simp)"], ["", "lemma ordinal_plus_left_cancel [simp]:\n\"(w + x = w + y) = (x = (y::ordinal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w + x = w + y) = (x = y)", "by (rule normal.cancel_eq[OF normal_plus])"], ["", "lemma ordinal_plus_left_cancel_le [simp]:\n\"(w + x \\<le> w + y) = (x \\<le> (y::ordinal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w + x \\<le> w + y) = (x \\<le> y)", "by (rule normal.cancel_le[OF normal_plus])"], ["", "lemma ordinal_plus_left_cancel_less [simp]:\n\"(w + x < w + y) = (x < (y::ordinal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w + x < w + y) = (x < y)", "by (rule normal.cancel_less[OF normal_plus])"], ["", "lemma ordinal_plus_not_0: \"(0 < x + y) = (0 < x \\<or> 0 < (y::ordinal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < x + y) = (0 < x \\<or> 0 < y)", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < x + 0; y = 0\\<rbrakk> \\<Longrightarrow> 0 < x\n 2. 0 < x \\<Longrightarrow> 0 < x + y\n 3. 0 < y \\<Longrightarrow> 0 < x + y", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> 0 < x + y\n 2. 0 < y \\<Longrightarrow> 0 < x + y", "apply (erule order_less_le_trans, rule ordinal_le_plusR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> 0 < x + y", "apply (erule order_less_le_trans, rule ordinal_le_plusL)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_inject: \"(\\<not> P) = (\\<not> Q) \\<Longrightarrow> P = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> P) = (\\<not> Q) \\<Longrightarrow> P = Q", "by auto"], ["", "lemma ordinal_plus_eq_0:\n\"((x::ordinal) + y = 0) = (x = 0 \\<and> y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y = 0) = (x = 0 \\<and> y = 0)", "by (rule not_inject, simp add: ordinal_plus_not_0)"], ["", "subsection \\<open>Subtraction\\<close>"], ["", "instantiation ordinal :: minus\nbegin"], ["", "definition\n  minus_ordinal_def:\n    \"x - y = ordinal_rec 0 (\\<lambda>p w. if y \\<le> p then oSuc w else w) x\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(ordinal, minus_class)", ".."], ["", "end"], ["", "lemma continuous_minus: \"continuous (\\<lambda>x. x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (\\<lambda>x. x - y)", "apply (unfold minus_ordinal_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous\n     (ordinal_rec 0 (\\<lambda>p w. if y \\<le> p then oSuc w else w))", "apply (rule continuous_ordinal_rec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p x. x \\<le> (if y \\<le> p then oSuc x else x)", "apply (simp add: order_less_imp_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_0_minus [simp]: \"0 - x = (0::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 - x = 0", "by (simp add: minus_ordinal_def)"], ["", "lemma ordinal_oSuc_minus [simp]: \"y \\<le> x \\<Longrightarrow> oSuc x - y = oSuc (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow> oSuc x - y = oSuc (x - y)", "by (simp add: minus_ordinal_def)"], ["", "lemma ordinal_oLimit_minus [simp]: \"oLimit f - y = oLimit (\\<lambda>n. f n - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oLimit f - y = oLimit (\\<lambda>n. f n - y)", "by (rule continuousD[OF continuous_minus])"], ["", "lemma ordinal_minus_0 [simp]: \"x - 0 = (x::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - 0 = x", "by (rule_tac a=x in oLimit_induct, simp_all)"], ["", "lemma ordinal_oSuc_minus2: \"x < y \\<Longrightarrow> oSuc x - y = x - y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y \\<Longrightarrow> oSuc x - y = x - y", "by (simp add: minus_ordinal_def linorder_not_le[symmetric])"], ["", "lemma ordinal_minus_eq_0 [rule_format, simp]:\n\"x \\<le> y \\<longrightarrow> x - y = (0::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<longrightarrow> x - y = 0", "apply (rule_tac a=x in oLimit_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<le> y \\<longrightarrow> 0 - y = 0\n 2. \\<And>x.\n       x \\<le> y \\<longrightarrow> x - y = 0 \\<Longrightarrow>\n       oSuc x \\<le> y \\<longrightarrow> oSuc x - y = 0\n 3. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n. f n \\<le> y \\<longrightarrow> f n - y = 0\\<rbrakk>\n       \\<Longrightarrow> oLimit f \\<le> y \\<longrightarrow> oLimit f - y = 0", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<le> y \\<longrightarrow> x - y = 0 \\<Longrightarrow>\n       oSuc x \\<le> y \\<longrightarrow> oSuc x - y = 0\n 2. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n. f n \\<le> y \\<longrightarrow> f n - y = 0\\<rbrakk>\n       \\<Longrightarrow> oLimit f \\<le> y \\<longrightarrow> oLimit f - y = 0", "apply (simp add: ordinal_oSuc_minus2 order_less_imp_le oSuc_le_eq_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n. f n \\<le> y \\<longrightarrow> f n - y = 0\\<rbrakk>\n       \\<Longrightarrow> oLimit f \\<le> y \\<longrightarrow> oLimit f - y = 0", "apply (simp add: order_trans[OF le_oLimit])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_plus_minus1 [simp]: \"(x + y) - x = (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y - x = y", "by (rule_tac a=y in oLimit_induct, simp_all)"], ["", "lemma ordinal_plus_minus2 [simp]: \"x \\<le> y \\<Longrightarrow> x + (y - x) = (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x + (y - x) = y", "apply (subgoal_tac \"\\<forall>z. y < x + z \\<longrightarrow> x + (y - x) = y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y;\n     \\<forall>z. y < x + z \\<longrightarrow> x + (y - x) = y\\<rbrakk>\n    \\<Longrightarrow> x + (y - x) = y\n 2. x \\<le> y \\<Longrightarrow>\n    \\<forall>z. y < x + z \\<longrightarrow> x + (y - x) = y", "apply (drule_tac x=\"oSuc y\" in spec, erule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> y < x + oSuc y\n 2. x \\<le> y \\<Longrightarrow>\n    \\<forall>z. y < x + z \\<longrightarrow> x + (y - x) = y", "apply (rule order_less_le_trans[OF less_oSuc], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow>\n    \\<forall>z. y < x + z \\<longrightarrow> x + (y - x) = y", "apply (rule allI, rule_tac a=z in oLimit_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>z.\n       x \\<le> y \\<Longrightarrow>\n       y < x + 0 \\<longrightarrow> x + (y - x) = y\n 2. \\<And>z xa.\n       \\<lbrakk>x \\<le> y;\n        y < x + xa \\<longrightarrow> x + (y - x) = y\\<rbrakk>\n       \\<Longrightarrow> y < x + oSuc xa \\<longrightarrow> x + (y - x) = y\n 3. \\<And>z f.\n       \\<lbrakk>x \\<le> y; OrdinalInduct.strict_mono f;\n        \\<forall>n. y < x + f n \\<longrightarrow> x + (y - x) = y\\<rbrakk>\n       \\<Longrightarrow> y < x + oLimit f \\<longrightarrow> x + (y - x) = y", "apply (simp add: linorder_not_less[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z xa.\n       \\<lbrakk>x \\<le> y;\n        y < x + xa \\<longrightarrow> x + (y - x) = y\\<rbrakk>\n       \\<Longrightarrow> y < x + oSuc xa \\<longrightarrow> x + (y - x) = y\n 2. \\<And>z f.\n       \\<lbrakk>x \\<le> y; OrdinalInduct.strict_mono f;\n        \\<forall>n. y < x + f n \\<longrightarrow> x + (y - x) = y\\<rbrakk>\n       \\<Longrightarrow> y < x + oLimit f \\<longrightarrow> x + (y - x) = y", "apply (clarsimp simp add: less_oSuc_eq_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z f.\n       \\<lbrakk>x \\<le> y; OrdinalInduct.strict_mono f;\n        \\<forall>n. y < x + f n \\<longrightarrow> x + (y - x) = y\\<rbrakk>\n       \\<Longrightarrow> y < x + oLimit f \\<longrightarrow> x + (y - x) = y", "apply (clarsimp, drule less_oLimitD, clarsimp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_minusI: \"x = y + z \\<Longrightarrow> x - y = (z::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y + z \\<Longrightarrow> x - y = z", "by simp"], ["", "lemma ordinal_minus_less_eq [simp]:\n\"(y::ordinal) \\<le> x \\<Longrightarrow> (x - y < z) = (x < y + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow> (x - y < z) = (x < y + z)", "apply (subgoal_tac \"(x - y < z) = (y + (x - y) < y + z)\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow> (x - y < z) = (y + (x - y) < y + z)", "apply (simp only: ordinal_plus_left_cancel_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_minus_le_eq [simp]:\n\"(x - y \\<le> z) = (x \\<le> y + (z::ordinal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - y \\<le> z) = (x \\<le> y + z)", "apply (rule_tac x=x and y=y in linorder_le_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> (x - y \\<le> z) = (x \\<le> y + z)\n 2. y \\<le> x \\<Longrightarrow> (x - y \\<le> z) = (x \\<le> y + z)", "apply (simp, erule order_trans, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow> (x - y \\<le> z) = (x \\<le> y + z)", "apply (subgoal_tac \"(x - y \\<le> z) = (y + (x - y) \\<le> y + z)\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow> (x - y \\<le> z) = (y + (x - y) \\<le> y + z)", "apply (simp only: ordinal_plus_left_cancel_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_minus_monoL: \"x \\<le> y \\<Longrightarrow> x - z \\<le> y - (z::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x - z \\<le> y - z", "by (erule continuous.monoD[OF continuous_minus])"], ["", "lemma ordinal_minus_monoR: \"x \\<le> y \\<Longrightarrow> z - y \\<le> z - (x::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z - y \\<le> z - x", "apply (rule_tac x=y and y=z in linorder_le_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> z - y \\<le> z - x\n 2. \\<lbrakk>x \\<le> y; z \\<le> y\\<rbrakk>\n    \\<Longrightarrow> z - y \\<le> z - x", "apply (subst ordinal_minus_le_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> z \\<le> y + (z - x)\n 2. \\<lbrakk>x \\<le> y; z \\<le> y\\<rbrakk>\n    \\<Longrightarrow> z - y \\<le> z - x", "apply (subgoal_tac \"x + (z - x) \\<le> y + (z - x)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z; x + (z - x) \\<le> y + (z - x)\\<rbrakk>\n    \\<Longrightarrow> z \\<le> y + (z - x)\n 2. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x + (z - x) \\<le> y + (z - x)\n 3. \\<lbrakk>x \\<le> y; z \\<le> y\\<rbrakk>\n    \\<Longrightarrow> z - y \\<le> z - x", "apply (drule order_trans, assumption, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x + (z - x) \\<le> y + (z - x)\n 2. \\<lbrakk>x \\<le> y; z \\<le> y\\<rbrakk>\n    \\<Longrightarrow> z - y \\<le> z - x", "apply (erule ordinal_plus_monoL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; z \\<le> y\\<rbrakk>\n    \\<Longrightarrow> z - y \\<le> z - x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Multiplication\\<close>"], ["", "instantiation ordinal :: times\nbegin"], ["", "definition\n  times_ordinal_def: \"(*) = (\\<lambda>x. ordinal_rec 0 (\\<lambda>p w. w + x))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(ordinal, times_class)", ".."], ["", "end"], ["", "lemma continuous_times: \"continuous ((*) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous ((*) x)", "by (simp add: times_ordinal_def continuous_ordinal_rec)"], ["", "lemma normal_times: \"0 < x \\<Longrightarrow> normal ((*) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> normal ((*) x)", "apply (unfold times_ordinal_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> normal (ordinal_rec 0 (\\<lambda>p w. w + x))", "apply (rule normal_ordinal_rec[rule_format], rename_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p y. 0 < x \\<Longrightarrow> y < y + x", "apply (subgoal_tac \"y + 0 < y + x\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p y. 0 < x \\<Longrightarrow> y + 0 < y + x", "apply (simp only: ordinal_plus_left_cancel_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_times_0 [simp]: \"x * 0 = (0::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 0 = 0", "by (simp add: times_ordinal_def)"], ["", "lemma ordinal_times_oSuc [simp]: \"x * oSuc y = (x * y) + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * oSuc y = x * y + x", "by (simp add: times_ordinal_def)"], ["", "lemma ordinal_times_oLimit [simp]: \"x * oLimit f = oLimit (\\<lambda>n. x * f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * oLimit f = oLimit (\\<lambda>n. x * f n)", "by (simp add: times_ordinal_def ordinal_rec_oLimit)"], ["", "lemma ordinal_0_times [simp]: \"0 * x = (0::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 * x = 0", "by (rule_tac a=x in oLimit_induct, simp_all)"], ["", "lemma ordinal_1_times [simp]: \"oSuc 0 * x = (x::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oSuc 0 * x = x", "by (rule_tac a=x in oLimit_induct, simp_all)"], ["", "lemma ordinal_times_1 [simp]: \"x * oSuc 0 = (x::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * oSuc 0 = x", "by simp"], ["", "lemma ordinal_times_distrib:\n\"x * (y + z) = (x * y) + (x * z::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y + z) = x * y + x * z", "by (rule_tac a=z in oLimit_induct, simp_all add: ordinal_plus_assoc)"], ["", "lemma ordinal_times_assoc:\n\"(x * y::ordinal) * z = x * (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * z = x * (y * z)", "by (rule_tac a=z in oLimit_induct, simp_all add: ordinal_times_distrib)"], ["", "lemma ordinal_times_monoL [rule_format]:\n\"\\<forall>x x'. x \\<le> x' \\<longrightarrow> x * y \\<le> x' * (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x x'. x \\<le> x' \\<longrightarrow> x * y \\<le> x' * y", "apply (rule_tac a=y in oLimit_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x x'. x \\<le> x' \\<longrightarrow> x * 0 \\<le> x' * 0\n 2. \\<And>x.\n       \\<forall>xa x'.\n          xa \\<le> x' \\<longrightarrow>\n          xa * x \\<le> x' * x \\<Longrightarrow>\n       \\<forall>xa x'.\n          xa \\<le> x' \\<longrightarrow> xa * oSuc x \\<le> x' * oSuc x\n 3. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x * f n \\<le> x' * f n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x x'.\n                            x \\<le> x' \\<longrightarrow>\n                            x * oLimit f \\<le> x' * oLimit f", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>xa x'.\n          xa \\<le> x' \\<longrightarrow>\n          xa * x \\<le> x' * x \\<Longrightarrow>\n       \\<forall>xa x'.\n          xa \\<le> x' \\<longrightarrow> xa * oSuc x \\<le> x' * oSuc x\n 2. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x * f n \\<le> x' * f n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x x'.\n                            x \\<le> x' \\<longrightarrow>\n                            x * oLimit f \\<le> x' * oLimit f", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa x'.\n       \\<lbrakk>\\<forall>xa x'.\n                   xa \\<le> x' \\<longrightarrow> xa * x \\<le> x' * x;\n        xa \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> xa * oSuc x \\<le> x' * oSuc x\n 2. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x * f n \\<le> x' * f n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x x'.\n                            x \\<le> x' \\<longrightarrow>\n                            x * oLimit f \\<le> x' * oLimit f", "apply (simp add: ordinal_plus_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x * f n \\<le> x' * f n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x x'.\n                            x \\<le> x' \\<longrightarrow>\n                            x * oLimit f \\<le> x' * oLimit f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x x'.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x * f n \\<le> x' * f n;\n        x \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> oLimit (\\<lambda>n. x * f n)\n                         \\<le> oLimit (\\<lambda>n. x' * f n)", "apply (rule oLimit_leI, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x x' n.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x * f n \\<le> x' * f n;\n        x \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> x * f n \\<le> oLimit (\\<lambda>n. x' * f n)", "apply (rule_tac n=n in le_oLimitI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x x' n.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x * f n \\<le> x' * f n;\n        x \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> x * f n \\<le> x' * f n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_times_monoR: \"y \\<le> y' \\<Longrightarrow> x * y \\<le> x * (y'::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> y' \\<Longrightarrow> x * y \\<le> x * y'", "by (rule continuous.monoD[OF continuous_times])"], ["", "lemma ordinal_times_mono:\n\"\\<lbrakk>x \\<le> x'; y \\<le> y'\\<rbrakk> \\<Longrightarrow> x * y \\<le> x' * (y'::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x'; y \\<le> y'\\<rbrakk>\n    \\<Longrightarrow> x * y \\<le> x' * y'", "by (rule order_trans[OF ordinal_times_monoL ordinal_times_monoR])"], ["", "lemma ordinal_times_strict_monoR:\n\"\\<lbrakk>y < y'; 0 < x\\<rbrakk> \\<Longrightarrow> x * y < x * (y'::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < y'; 0 < x\\<rbrakk> \\<Longrightarrow> x * y < x * y'", "by (rule normal.strict_monoD[OF normal_times])"], ["", "lemma ordinal_le_timesL [simp]: \"0 < x \\<Longrightarrow> y \\<le> x * (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> y \\<le> x * y", "by (drule ordinal_times_monoL[OF oSuc_leI], simp)"], ["", "lemma ordinal_le_timesR [simp]: \"0 < y \\<Longrightarrow> x \\<le> x * (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> x \\<le> x * y", "by (drule ordinal_times_monoR[OF oSuc_leI], simp)"], ["", "lemma ordinal_less_timesR: \"\\<lbrakk>0 < x; oSuc 0 < y\\<rbrakk> \\<Longrightarrow> x < x * (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; oSuc 0 < y\\<rbrakk> \\<Longrightarrow> x < x * y", "by (drule ordinal_times_strict_monoR, assumption, simp)"], ["", "lemma ordinal_times_left_cancel [simp]:\n\"0 < w \\<Longrightarrow> (w * x = w * y) = (x = (y::ordinal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < w \\<Longrightarrow> (w * x = w * y) = (x = y)", "by (rule normal.cancel_eq[OF normal_times])"], ["", "lemma ordinal_times_left_cancel_le [simp]:\n\"0 < w \\<Longrightarrow> (w * x \\<le> w * y) = (x \\<le> (y::ordinal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < w \\<Longrightarrow> (w * x \\<le> w * y) = (x \\<le> y)", "by (rule normal.cancel_le[OF normal_times])"], ["", "lemma ordinal_times_left_cancel_less [simp]:\n\"0 < w \\<Longrightarrow> (w * x < w * y) = (x < (y::ordinal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < w \\<Longrightarrow> (w * x < w * y) = (x < y)", "by (rule normal.cancel_less[OF normal_times])"], ["", "lemma ordinal_times_eq_0:\n\"((x::ordinal) * y = 0) = (x = 0 \\<or> y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y = 0) = (x = 0 \\<or> y = 0)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x * y = 0 \\<Longrightarrow> x = 0 \\<or> y = 0\n 2. x = 0 \\<or> y = 0 \\<Longrightarrow> x * y = 0", "apply (erule contrapos_pp, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < x; 0 < y\\<rbrakk> \\<Longrightarrow> 0 < x * y\n 2. x = 0 \\<or> y = 0 \\<Longrightarrow> x * y = 0", "apply (drule oSuc_leI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < y; oSuc 0 \\<le> x\\<rbrakk> \\<Longrightarrow> 0 < x * y\n 2. x = 0 \\<or> y = 0 \\<Longrightarrow> x * y = 0", "apply (erule order_less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. oSuc 0 \\<le> x \\<Longrightarrow> y \\<le> x * y\n 2. x = 0 \\<or> y = 0 \\<Longrightarrow> x * y = 0", "apply (drule ordinal_times_monoL, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0 \\<or> y = 0 \\<Longrightarrow> x * y = 0", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_times_not_0 [simp]:\n\"((0::ordinal) < x * y) = (0 < x \\<and> 0 < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < x * y) = (0 < x \\<and> 0 < y)", "by (rule not_inject, simp add: ordinal_times_eq_0)"], ["", "subsection \\<open>Exponentiation\\<close>"], ["", "definition\n  exp_ordinal :: \"[ordinal, ordinal] \\<Rightarrow> ordinal\" (infixr \"**\" 75) where\n  \"(**) = (\\<lambda>x. if 0 < x then ordinal_rec 1 (\\<lambda>p w. w * x)\n                         else (\\<lambda>y. if y = 0 then 1 else 0))\""], ["", "lemma continuous_exp: \"0 < x \\<Longrightarrow> continuous ((**) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> continuous ((**) x)", "by (simp add: exp_ordinal_def continuous_ordinal_rec)"], ["", "lemma ordinal_exp_0 [simp]: \"x ** 0 = (1::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ** 0 = 1", "by (simp add: exp_ordinal_def)"], ["", "lemma ordinal_exp_oSuc [simp]: \"x ** oSuc y = (x ** y) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ** oSuc y = x ** y * x", "by (simp add: exp_ordinal_def)"], ["", "lemma ordinal_exp_oLimit [simp]:\n\"0 < x \\<Longrightarrow> x ** oLimit f = oLimit (\\<lambda>n. x ** f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> x ** oLimit f = oLimit (\\<lambda>n. x ** f n)", "by (rule continuousD[OF continuous_exp])"], ["", "lemma ordinal_0_exp [simp]: \"0 ** x = (if x = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 ** x = (if x = 0 then 1 else 0)", "by (simp add: exp_ordinal_def)"], ["", "lemma ordinal_1_exp [simp]: \"oSuc 0 ** x = oSuc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oSuc 0 ** x = oSuc 0", "by (rule_tac a=x in oLimit_induct, simp_all)"], ["", "lemma ordinal_exp_1 [simp]: \"x ** oSuc 0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ** oSuc 0 = x", "by simp"], ["", "lemma ordinal_exp_distrib:\n\"x ** (y + z) = (x ** y) * (x ** (z::ordinal))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ** (y + z) = x ** y * x ** z", "apply (case_tac \"x = 0\", simp_all add: ordinal_plus_not_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> x ** (y + z) = x ** y * x ** z", "apply (rule_tac a=z in oLimit_induct, simp_all add: ordinal_times_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_exp_not_0 [simp]: \"(0 < x ** y) = (0 < x \\<or> y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < x ** y) = (0 < x \\<or> y = 0)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < x ** y; 0 < y\\<rbrakk> \\<Longrightarrow> 0 < x\n 2. 0 < x \\<Longrightarrow> 0 < x ** y", "apply (erule contrapos_pp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> 0 < x ** y", "apply (rule_tac a=y in oLimit_induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>0 < x; OrdinalInduct.strict_mono f;\n        \\<forall>n. 0 < x ** f n\\<rbrakk>\n       \\<Longrightarrow> 0 < oLimit (\\<lambda>n. x ** f n)", "apply (rule less_oLimitI, erule spec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_exp_eq_0 [simp]: \"(x ** y = 0) = (x = 0 \\<and> 0 < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ** y = 0) = (x = 0 \\<and> 0 < y)", "by (rule not_inject, simp)"], ["", "lemma ordinal_exp_assoc:\n\"(x ** y) ** z = x ** (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ** y) ** z = x ** (y * z)", "apply (case_tac \"x = 0\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> (x ** y) ** z = x ** (y * z)", "apply (rule_tac a=z in oLimit_induct, simp_all add: ordinal_exp_distrib)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_exp_monoL [rule_format]:\n\"\\<forall>x x'. x \\<le> x' \\<longrightarrow> x ** y \\<le> x' ** (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x x'. x \\<le> x' \\<longrightarrow> x ** y \\<le> x' ** y", "apply (rule_tac a=y in oLimit_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x x'. x \\<le> x' \\<longrightarrow> x ** 0 \\<le> x' ** 0\n 2. \\<And>x.\n       \\<forall>xa x'.\n          xa \\<le> x' \\<longrightarrow>\n          xa ** x \\<le> x' ** x \\<Longrightarrow>\n       \\<forall>xa x'.\n          xa \\<le> x' \\<longrightarrow> xa ** oSuc x \\<le> x' ** oSuc x\n 3. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x ** f n \\<le> x' ** f n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x x'.\n                            x \\<le> x' \\<longrightarrow>\n                            x ** oLimit f \\<le> x' ** oLimit f", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>xa x'.\n          xa \\<le> x' \\<longrightarrow>\n          xa ** x \\<le> x' ** x \\<Longrightarrow>\n       \\<forall>xa x'.\n          xa \\<le> x' \\<longrightarrow> xa ** oSuc x \\<le> x' ** oSuc x\n 2. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x ** f n \\<le> x' ** f n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x x'.\n                            x \\<le> x' \\<longrightarrow>\n                            x ** oLimit f \\<le> x' ** oLimit f", "apply (simp add: ordinal_times_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x ** f n \\<le> x' ** f n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x x'.\n                            x \\<le> x' \\<longrightarrow>\n                            x ** oLimit f \\<le> x' ** oLimit f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x x'.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x ** f n \\<le> x' ** f n;\n        x \\<le> x'\\<rbrakk>\n       \\<Longrightarrow> x ** oLimit f \\<le> x' ** oLimit f", "apply (case_tac \"x = 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x x'.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x ** f n \\<le> x' ** f n;\n        x \\<le> x'; x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> x ** oLimit f \\<le> x' ** oLimit f", "apply (case_tac \"x' = 0\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x x'.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x ** f n \\<le> x' ** f n;\n        x \\<le> x'; 0 < x; 0 < x'\\<rbrakk>\n       \\<Longrightarrow> oLimit (\\<lambda>n. x ** f n)\n                         \\<le> oLimit (\\<lambda>n. x' ** f n)", "apply (rule oLimit_leI, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x x' n.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x ** f n \\<le> x' ** f n;\n        x \\<le> x'; 0 < x; 0 < x'\\<rbrakk>\n       \\<Longrightarrow> x ** f n \\<le> oLimit (\\<lambda>n. x' ** f n)", "apply (rule_tac n=n in le_oLimitI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x x' n.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n x x'.\n           x \\<le> x' \\<longrightarrow> x ** f n \\<le> x' ** f n;\n        x \\<le> x'; 0 < x; 0 < x'\\<rbrakk>\n       \\<Longrightarrow> x ** f n \\<le> x' ** f n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma normal_exp: \"oSuc 0 < x \\<Longrightarrow> normal ((**) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oSuc 0 < x \\<Longrightarrow> normal ((**) x)", "apply (frule_tac order_less_trans[OF less_oSuc])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oSuc 0 < x; 0 < x\\<rbrakk> \\<Longrightarrow> normal ((**) x)", "apply (rule normalI, simp, rename_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>oSuc 0 < x; 0 < x\\<rbrakk>\n       \\<Longrightarrow> x ** y < x ** oSuc y", "apply (subgoal_tac \"x ** y * 1 < x ** y * x\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>oSuc 0 < x; 0 < x\\<rbrakk>\n       \\<Longrightarrow> x ** y * 1 < x ** y * x", "apply (subst ordinal_times_left_cancel_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>oSuc 0 < x; 0 < x\\<rbrakk> \\<Longrightarrow> 0 < x ** y\n 2. \\<And>y. \\<lbrakk>oSuc 0 < x; 0 < x\\<rbrakk> \\<Longrightarrow> 1 < x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. \\<lbrakk>oSuc 0 < x; 0 < x\\<rbrakk> \\<Longrightarrow> 1 < x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_exp_monoR:\n\"\\<lbrakk>0 < x; y \\<le> y'\\<rbrakk> \\<Longrightarrow> x ** y \\<le> x ** (y'::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; y \\<le> y'\\<rbrakk>\n    \\<Longrightarrow> x ** y \\<le> x ** y'", "by (rule continuous.monoD[OF continuous_exp])"], ["", "lemma ordinal_exp_mono:\n\"\\<lbrakk>0 < x'; x \\<le> x'; y \\<le> y'\\<rbrakk> \\<Longrightarrow> x ** y \\<le> x' ** (y'::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x'; x \\<le> x'; y \\<le> y'\\<rbrakk>\n    \\<Longrightarrow> x ** y \\<le> x' ** y'", "by (rule order_trans[OF ordinal_exp_monoL ordinal_exp_monoR])"], ["", "lemma ordinal_exp_strict_monoR:\n\"\\<lbrakk>oSuc 0 < x; y < y'\\<rbrakk> \\<Longrightarrow> x ** y < x ** (y'::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oSuc 0 < x; y < y'\\<rbrakk> \\<Longrightarrow> x ** y < x ** y'", "by (rule normal.strict_monoD[OF normal_exp])"], ["", "lemma ordinal_le_expR [simp]: \"0 < y \\<Longrightarrow> x \\<le> x ** (y::ordinal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> x \\<le> x ** y", "apply (subgoal_tac \"x ** oSuc 0 \\<le> x ** y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < y; x ** oSuc 0 \\<le> x ** y\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x ** y\n 2. 0 < y \\<Longrightarrow> x ** oSuc 0 \\<le> x ** y", "apply (simp del: ordinal_exp_oSuc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> x ** oSuc 0 \\<le> x ** y", "apply (case_tac \"x = 0\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < y; x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> x ** oSuc 0 \\<le> x ** y", "apply (rule ordinal_exp_monoR, simp_all add: oSuc_leI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_exp_left_cancel [simp]:\n\"oSuc 0 < w \\<Longrightarrow> (w ** x = w ** y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oSuc 0 < w \\<Longrightarrow> (w ** x = w ** y) = (x = y)", "by (rule normal.cancel_eq[OF normal_exp])"], ["", "lemma ordinal_exp_left_cancel_le [simp]:\n\"oSuc 0 < w \\<Longrightarrow> (w ** x \\<le> w ** y) = (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oSuc 0 < w \\<Longrightarrow> (w ** x \\<le> w ** y) = (x \\<le> y)", "by (rule normal.cancel_le[OF normal_exp])"], ["", "lemma ordinal_exp_left_cancel_less [simp]:\n\"oSuc 0 < w \\<Longrightarrow> (w ** x < w ** y) = (x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oSuc 0 < w \\<Longrightarrow> (w ** x < w ** y) = (x < y)", "by (rule normal.cancel_less[OF normal_exp])"], ["", "end"]]}