{"file_name": "/home/qj213/afp-2021-10-22/thys/Ordinal/OrdinalOmega.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ordinal", "problem_names": ["lemma strict_mono_ordinal_of_nat: \"strict_mono ordinal_of_nat\"", "lemma not_limit_ordinal_nat: \"\\<not> limit_ordinal (ordinal_of_nat n)\"", "lemma ordinal_of_nat_eq [simp]:\n\"(ordinal_of_nat x = ordinal_of_nat y) = (x = y)\"", "lemma ordinal_of_nat_less [simp]:\n\"(ordinal_of_nat x < ordinal_of_nat y) = (x < y)\"", "lemma ordinal_of_nat_le [simp]:\n\"(ordinal_of_nat x \\<le> ordinal_of_nat y) = (x \\<le> y)\"", "lemma ordinal_of_nat_plus [simp]:\n\"ordinal_of_nat x + ordinal_of_nat y = ordinal_of_nat (x + y)\"", "lemma ordinal_of_nat_times [simp]:\n\"ordinal_of_nat x * ordinal_of_nat y = ordinal_of_nat (x * y)\"", "lemma ordinal_of_nat_exp [simp]:\n\"ordinal_of_nat x ** ordinal_of_nat y = ordinal_of_nat (x ^ y)\"", "lemma oSuc_plus_ordinal_of_nat:\n\"oSuc x + ordinal_of_nat n = oSuc (x + ordinal_of_nat n)\"", "lemma less_ordinal_of_nat:\n\"(x < ordinal_of_nat n) = (\\<exists>m. x = ordinal_of_nat m \\<and> m < n)\"", "lemma le_ordinal_of_nat:\n\"(x \\<le> ordinal_of_nat n) = (\\<exists>m. x = ordinal_of_nat m \\<and> m \\<le> n)\"", "lemma less_omegaD: \"x < \\<omega> \\<Longrightarrow> \\<exists>n. x = ordinal_of_nat n\"", "lemma omega_leI: \"\\<forall>n. ordinal_of_nat n \\<le> x \\<Longrightarrow> \\<omega> \\<le> x\"", "lemma nat_le_omega [simp]: \"ordinal_of_nat n \\<le> \\<omega>\"", "lemma nat_less_omega [simp]: \"ordinal_of_nat n < \\<omega>\"", "lemma zero_less_omega [simp]: \"0 < \\<omega>\"", "lemma limit_ordinal_omega: \"limit_ordinal \\<omega>\"", "lemma Least_limit_ordinal: \"(LEAST x. limit_ordinal x) = \\<omega>\"", "lemma \"range f = range ordinal_of_nat \\<Longrightarrow> oLimit f = \\<omega>\"", "lemma oSuc_less_omega [simp]: \"(oSuc x < \\<omega>) = (x < \\<omega>)\"", "lemma oSuc_plus_omega [simp]: \"oSuc x + \\<omega> = x + \\<omega>\"", "lemma ordinal_of_nat_plus_omega [simp]:\n\"ordinal_of_nat n + \\<omega> = \\<omega>\"", "lemma ordinal_of_nat_times_omega [simp]:\n\"0 < k \\<Longrightarrow> ordinal_of_nat k * \\<omega> = \\<omega>\"", "lemma ordinal_plus_times_omega: \"x + x * \\<omega> = x * \\<omega>\"", "lemma ordinal_plus_absorb: \"x * \\<omega> \\<le> y \\<Longrightarrow> x + y = y\"", "lemma ordinal_less_plusL: \"y < x * \\<omega> \\<Longrightarrow> y < x + y\"", "lemma ordinal_plus_absorb_iff: \"(x + y = y) = (x * \\<omega> \\<le> y)\"", "lemma ordinal_less_plusL_iff: \"(y < x + y) = (y < x * \\<omega>)\"", "lemma (in additive_principal) sum_less:\n\"\\<lbrakk>x < a; y < a\\<rbrakk> \\<Longrightarrow> x + y < a\"", "lemma (in additive_principal) times_nat_less:\n\"x < a \\<Longrightarrow> x * ordinal_of_nat n < a\"", "lemma not_additive_principal_0: \"\\<not> additive_principal 0\"", "lemma additive_principal_oSuc:\n\"additive_principal (oSuc a) = (a = 0)\"", "lemma additive_principal_intro2 [rule_format]:\nassumes not_0: \"0 < a\"\nshows \"(\\<forall>x<a. \\<forall>y<a. x + y < a) \\<longrightarrow> additive_principal a\"", "lemma additive_principal_1: \"additive_principal (oSuc 0)\"", "lemma additive_principal_omega: \"additive_principal \\<omega>\"", "lemma additive_principal_times_omega:\n\"0 < x \\<Longrightarrow> additive_principal (x * \\<omega>)\"", "lemma additive_principal_oLimit:\n\"\\<forall>n. additive_principal (f n) \\<Longrightarrow> additive_principal (oLimit f)\"", "lemma additive_principal_omega_exp: \"additive_principal (\\<omega> ** x)\"", "lemma (in additive_principal) omega_exp: \"\\<exists>x. a = \\<omega> ** x\"", "lemma additive_principal_iff:\n\"additive_principal a = (\\<exists>x. a = \\<omega> ** x)\"", "lemma absorb_omega_exp:\n\"x < \\<omega> ** a \\<Longrightarrow> x + \\<omega> ** a = \\<omega> ** a\"", "lemma absorb_omega_exp2: \"a < b \\<Longrightarrow> \\<omega> ** a + \\<omega> ** b = \\<omega> ** b\"", "lemma cnf_lemma: \"x > 0 \\<Longrightarrow> x - \\<omega> ** oLog \\<omega> x < x\"", "lemma to_cnf_0 [simp]: \"to_cnf 0 = []\"", "lemma to_cnf_not_0:\n\"0 < x \\<Longrightarrow> to_cnf x = oLog \\<omega> x # to_cnf (x - \\<omega> ** oLog \\<omega> x)\"", "lemma to_cnf_eq_Cons: \"to_cnf x = a # list \\<Longrightarrow> a = oLog \\<omega> x\"", "lemma to_cnf_inverse: \"from_cnf (to_cnf x) = x\"", "lemma from_cnf_normalize_cnf: \"from_cnf (normalize_cnf xs) = from_cnf xs\"", "lemma normalize_cnf_to_cnf: \"normalize_cnf (to_cnf x) = to_cnf x\"", "lemma cnf2_lemma:\n\"0 < x \\<Longrightarrow> x mod \\<omega> ** oLog \\<omega> x < x\"", "lemma to_cnf2_0 [simp]: \"to_cnf2 0 = []\"", "lemma to_cnf2_not_0:\n\"0 < x \\<Longrightarrow> to_cnf2 x =\n  (oLog \\<omega> x, inv ordinal_of_nat (x div (\\<omega> ** oLog \\<omega> x)))\n     # to_cnf2 (x mod (\\<omega> ** oLog \\<omega> x))\"", "lemma to_cnf2_eq_Cons: \"to_cnf2 x = (a,b) # list \\<Longrightarrow> a = oLog \\<omega> x\"", "lemma ordinal_of_nat_of_ordinal:\n\"x < \\<omega> \\<Longrightarrow> ordinal_of_nat (inv ordinal_of_nat x) = x\"", "lemma to_cnf2_inverse: \"from_cnf2 (to_cnf2 x) = x\"", "lemma is_normalized2_to_cnf2: \"is_normalized2 (to_cnf2 x)\"", "lemma less_omega_exp: \"x < \\<epsilon>\\<^sub>0 \\<Longrightarrow> x < \\<omega> ** x\"", "lemma omega_exp_epsilon0: \"\\<omega> ** \\<epsilon>\\<^sub>0 = \\<epsilon>\\<^sub>0\"", "lemma oLog_omega_less: \"\\<lbrakk>0 < x; x < \\<epsilon>\\<^sub>0\\<rbrakk> \\<Longrightarrow> oLog \\<omega> x < x\""], "translations": [["", "lemma strict_mono_ordinal_of_nat: \"strict_mono ordinal_of_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OrdinalInduct.strict_mono ordinal_of_nat", "by (rule strict_mono_natI, simp)"], ["", "lemma not_limit_ordinal_nat: \"\\<not> limit_ordinal (ordinal_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> limit_ordinal (ordinal_of_nat n)", "by (induct n) simp_all"], ["", "lemma ordinal_of_nat_eq [simp]:\n\"(ordinal_of_nat x = ordinal_of_nat y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordinal_of_nat x = ordinal_of_nat y) = (x = y)", "by (rule strict_mono_cancel_eq[OF strict_mono_ordinal_of_nat])"], ["", "lemma ordinal_of_nat_less [simp]:\n\"(ordinal_of_nat x < ordinal_of_nat y) = (x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordinal_of_nat x < ordinal_of_nat y) = (x < y)", "by (rule strict_mono_cancel_less[OF strict_mono_ordinal_of_nat])"], ["", "lemma ordinal_of_nat_le [simp]:\n\"(ordinal_of_nat x \\<le> ordinal_of_nat y) = (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordinal_of_nat x \\<le> ordinal_of_nat y) = (x \\<le> y)", "by (rule strict_mono_cancel_le[OF strict_mono_ordinal_of_nat])"], ["", "lemma ordinal_of_nat_plus [simp]:\n\"ordinal_of_nat x + ordinal_of_nat y = ordinal_of_nat (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordinal_of_nat x + ordinal_of_nat y = ordinal_of_nat (x + y)", "by (induct y) simp_all"], ["", "lemma ordinal_of_nat_times [simp]:\n\"ordinal_of_nat x * ordinal_of_nat y = ordinal_of_nat (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordinal_of_nat x * ordinal_of_nat y = ordinal_of_nat (x * y)", "by (induct y) (simp_all add: add.commute)"], ["", "lemma ordinal_of_nat_exp [simp]:\n\"ordinal_of_nat x ** ordinal_of_nat y = ordinal_of_nat (x ^ y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordinal_of_nat x ** ordinal_of_nat y = ordinal_of_nat (x ^ y)", "by (induct y, cases x) (simp_all add: mult.commute)"], ["", "lemma oSuc_plus_ordinal_of_nat:\n\"oSuc x + ordinal_of_nat n = oSuc (x + ordinal_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oSuc x + ordinal_of_nat n = oSuc (x + ordinal_of_nat n)", "by (induct n) simp_all"], ["", "lemma less_ordinal_of_nat:\n\"(x < ordinal_of_nat n) = (\\<exists>m. x = ordinal_of_nat m \\<and> m < n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < ordinal_of_nat n) = (\\<exists>m. x = ordinal_of_nat m \\<and> m < n)", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x < ordinal_of_nat 0) = (\\<exists>m. x = ordinal_of_nat m \\<and> m < 0)\n 2. \\<And>n.\n       (x < ordinal_of_nat n) =\n       (\\<exists>m. x = ordinal_of_nat m \\<and> m < n) \\<Longrightarrow>\n       (x < ordinal_of_nat (Suc n)) =\n       (\\<exists>m. x = ordinal_of_nat m \\<and> m < Suc n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (x < ordinal_of_nat n) =\n       (\\<exists>m. x = ordinal_of_nat m \\<and> m < n) \\<Longrightarrow>\n       (x < ordinal_of_nat (Suc n)) =\n       (\\<exists>m. x = ordinal_of_nat m \\<and> m < Suc n)", "apply (safe, simp_all del: ordinal_of_nat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<not> x < ordinal_of_nat n;\n        \\<forall>m. x = ordinal_of_nat m \\<longrightarrow> \\<not> m < n;\n        x < ordinal_of_nat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. x = ordinal_of_nat m \\<and> m < Suc n", "apply (auto elim: less_oSucE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma le_ordinal_of_nat:\n\"(x \\<le> ordinal_of_nat n) = (\\<exists>m. x = ordinal_of_nat m \\<and> m \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> ordinal_of_nat n) =\n    (\\<exists>m. x = ordinal_of_nat m \\<and> m \\<le> n)", "by (auto simp add: order_le_less less_ordinal_of_nat)"], ["", "subsection \\<open>Omega, the least limit ordinal\\<close>"], ["", "definition\n  omega :: \"ordinal\"  (\"\\<omega>\") where\n  \"omega = oLimit ordinal_of_nat\""], ["", "lemma less_omegaD: \"x < \\<omega> \\<Longrightarrow> \\<exists>n. x = ordinal_of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < \\<omega> \\<Longrightarrow> \\<exists>n. x = ordinal_of_nat n", "apply (unfold omega_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < oLimit ordinal_of_nat \\<Longrightarrow>\n    \\<exists>n. x = ordinal_of_nat n", "apply (drule less_oLimitD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. x < ordinal_of_nat n \\<Longrightarrow>\n    \\<exists>n. x = ordinal_of_nat n", "apply (clarsimp simp add: less_ordinal_of_nat)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma omega_leI: \"\\<forall>n. ordinal_of_nat n \\<le> x \\<Longrightarrow> \\<omega> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. ordinal_of_nat n \\<le> x \\<Longrightarrow> \\<omega> \\<le> x", "by (unfold omega_def, erule oLimit_leI)"], ["", "lemma nat_le_omega [simp]: \"ordinal_of_nat n \\<le> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordinal_of_nat n \\<le> \\<omega>", "by (unfold omega_def, rule le_oLimit)"], ["", "lemma nat_less_omega [simp]: \"ordinal_of_nat n < \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordinal_of_nat n < \\<omega>", "apply (rule_tac y=\"ordinal_of_nat (Suc n)\" in order_less_le_trans, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordinal_of_nat (Suc n) \\<le> \\<omega>", "apply (rule nat_le_omega)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma zero_less_omega [simp]: \"0 < \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<omega>", "by (cut_tac n=0 in nat_less_omega, simp)"], ["", "lemma limit_ordinal_omega: \"limit_ordinal \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limit_ordinal \\<omega>", "apply (rule limit_ordinalI[rule_format], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x < \\<omega> \\<Longrightarrow> oSuc x < \\<omega>", "apply (drule less_omegaD, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n. oSuc (ordinal_of_nat n) < \\<omega>", "apply (subgoal_tac \"ordinal_of_nat (Suc n) < \\<omega>\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n. ordinal_of_nat (Suc n) < \\<omega>", "apply (simp only: nat_less_omega)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Least_limit_ordinal: \"(LEAST x. limit_ordinal x) = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST x. limit_ordinal x) = \\<omega>", "apply (rule Least_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. limit_ordinal \\<omega>\n 2. \\<And>y. limit_ordinal y \\<Longrightarrow> \\<omega> \\<le> y", "apply (rule limit_ordinal_omega)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. limit_ordinal y \\<Longrightarrow> \\<omega> \\<le> y", "apply (erule contrapos_pp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<not> \\<omega> \\<le> y \\<Longrightarrow> \\<not> limit_ordinal y", "apply (simp add: linorder_not_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y < \\<omega> \\<Longrightarrow> \\<not> limit_ordinal y", "apply (drule less_omegaD, erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y n. y = ordinal_of_nat n \\<Longrightarrow> \\<not> limit_ordinal y", "apply (simp add: not_limit_ordinal_nat)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"range f = range ordinal_of_nat \\<Longrightarrow> oLimit f = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range f = range ordinal_of_nat \\<Longrightarrow> oLimit f = \\<omega>", "apply (rule order_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. range f = range ordinal_of_nat \\<Longrightarrow> oLimit f \\<le> \\<omega>\n 2. range f = range ordinal_of_nat \\<Longrightarrow> \\<omega> \\<le> oLimit f", "apply (rule oLimit_leI, clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       range f = range ordinal_of_nat \\<Longrightarrow> f n \\<le> \\<omega>\n 2. range f = range ordinal_of_nat \\<Longrightarrow> \\<omega> \\<le> oLimit f", "apply (drule equalityD1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       range f \\<subseteq> range ordinal_of_nat \\<Longrightarrow>\n       f n \\<le> \\<omega>\n 2. range f = range ordinal_of_nat \\<Longrightarrow> \\<omega> \\<le> oLimit f", "apply (drule_tac c=\"f n\" in subsetD, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       f n \\<in> range ordinal_of_nat \\<Longrightarrow> f n \\<le> \\<omega>\n 2. range f = range ordinal_of_nat \\<Longrightarrow> \\<omega> \\<le> oLimit f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. range f = range ordinal_of_nat \\<Longrightarrow> \\<omega> \\<le> oLimit f", "apply (rule omega_leI, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       range f = range ordinal_of_nat \\<Longrightarrow>\n       ordinal_of_nat n \\<le> oLimit f", "apply (drule equalityD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       range ordinal_of_nat \\<subseteq> range f \\<Longrightarrow>\n       ordinal_of_nat n \\<le> oLimit f", "apply (drule_tac c=\"ordinal_of_nat n\" in subsetD, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ordinal_of_nat n \\<in> range f \\<Longrightarrow>\n       ordinal_of_nat n \\<le> oLimit f", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Arithmetic properties of @{term \\<omega>}\\<close>"], ["", "lemma oSuc_less_omega [simp]: \"(oSuc x < \\<omega>) = (x < \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oSuc x < \\<omega>) = (x < \\<omega>)", "by (rule oSuc_less_limit_ordinal[OF limit_ordinal_omega])"], ["", "lemma oSuc_plus_omega [simp]: \"oSuc x + \\<omega> = x + \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oSuc x + \\<omega> = x + \\<omega>", "apply (simp add: omega_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. oLimit (\\<lambda>n. oSuc x + ordinal_of_nat n) =\n    oLimit (\\<lambda>n. x + ordinal_of_nat n)", "apply (rule oLimit_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<exists>m. oSuc x + ordinal_of_nat n \\<le> x + ordinal_of_nat m\n 2. \\<And>n.\n       \\<exists>m. x + ordinal_of_nat n \\<le> oSuc x + ordinal_of_nat m", "apply (rule_tac x=\"Suc n\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. oSuc x + ordinal_of_nat n \\<le> x + ordinal_of_nat (Suc n)\n 2. \\<And>n.\n       \\<exists>m. x + ordinal_of_nat n \\<le> oSuc x + ordinal_of_nat m", "apply (simp add: oSuc_plus_ordinal_of_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>m. x + ordinal_of_nat n \\<le> oSuc x + ordinal_of_nat m", "apply (rule_tac x=n in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. x + ordinal_of_nat n \\<le> oSuc x + ordinal_of_nat n", "apply (simp add: oSuc_plus_ordinal_of_nat order_less_imp_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_of_nat_plus_omega [simp]:\n\"ordinal_of_nat n + \\<omega> = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordinal_of_nat n + \\<omega> = \\<omega>", "by (induct n) simp_all"], ["", "lemma ordinal_of_nat_times_omega [simp]:\n\"0 < k \\<Longrightarrow> ordinal_of_nat k * \\<omega> = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow> ordinal_of_nat k * \\<omega> = \\<omega>", "apply (simp add: omega_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k \\<Longrightarrow>\n    oLimit (\\<lambda>n. ordinal_of_nat (k * n)) = oLimit ordinal_of_nat", "apply (rule oLimit_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       0 < k \\<Longrightarrow>\n       \\<exists>m. ordinal_of_nat (k * n) \\<le> ordinal_of_nat m\n 2. \\<And>n.\n       0 < k \\<Longrightarrow>\n       \\<exists>m. ordinal_of_nat n \\<le> ordinal_of_nat (k * m)", "apply (rule_tac exI, rule order_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       0 < k \\<Longrightarrow>\n       \\<exists>m. ordinal_of_nat n \\<le> ordinal_of_nat (k * m)", "apply (rule_tac x=n in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_plus_times_omega: \"x + x * \\<omega> = x * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + x * \\<omega> = x * \\<omega>", "apply (subgoal_tac \"x + x * \\<omega> = x * (1 + \\<omega>)\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + x * \\<omega> = x * (1 + \\<omega>)", "apply (simp del: oSuc_plus_omega add: ordinal_times_distrib)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_plus_absorb: \"x * \\<omega> \\<le> y \\<Longrightarrow> x + y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<omega> \\<le> y \\<Longrightarrow> x + y = y", "apply (drule ordinal_plus_minus2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<omega> + (y - x * \\<omega>) = y \\<Longrightarrow> x + y = y", "apply (erule subst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (x * \\<omega> + (y - x * \\<omega>)) =\n    x * \\<omega> + (y - x * \\<omega>)", "apply (simp only: ordinal_plus_assoc[symmetric] ordinal_plus_times_omega)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_less_plusL: \"y < x * \\<omega> \\<Longrightarrow> y < x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x * \\<omega> \\<Longrightarrow> y < x + y", "apply (case_tac \"x = 0\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y < x * \\<omega>; 0 < x\\<rbrakk> \\<Longrightarrow> y < x + y", "apply (drule ordinal_div_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; y div x < \\<omega>\\<rbrakk> \\<Longrightarrow> y < x + y", "apply (drule less_omegaD, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < x; y div x = ordinal_of_nat n\\<rbrakk>\n       \\<Longrightarrow> y < x + y", "apply (rule_tac y=\"x * (1 + ordinal_of_nat n)\" in order_less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>0 < x; y div x = ordinal_of_nat n\\<rbrakk>\n       \\<Longrightarrow> y < x * (1 + ordinal_of_nat n)\n 2. \\<And>n.\n       \\<lbrakk>0 < x; y div x = ordinal_of_nat n\\<rbrakk>\n       \\<Longrightarrow> x * (1 + ordinal_of_nat n) \\<le> x + y", "apply (simp add: oSuc_plus_ordinal_of_nat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>0 < x; y div x = ordinal_of_nat n\\<rbrakk>\n       \\<Longrightarrow> y < x * ordinal_of_nat n + x\n 2. \\<And>n.\n       \\<lbrakk>0 < x; y div x = ordinal_of_nat n\\<rbrakk>\n       \\<Longrightarrow> x * (1 + ordinal_of_nat n) \\<le> x + y", "apply (erule subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. 0 < x \\<Longrightarrow> y < x * (y div x) + x\n 2. \\<And>n.\n       \\<lbrakk>0 < x; y div x = ordinal_of_nat n\\<rbrakk>\n       \\<Longrightarrow> x * (1 + ordinal_of_nat n) \\<le> x + y", "apply (erule ordinal_less_times_div_plus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < x; y div x = ordinal_of_nat n\\<rbrakk>\n       \\<Longrightarrow> x * (1 + ordinal_of_nat n) \\<le> x + y", "apply (simp add: ordinal_times_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>0 < x; y div x = ordinal_of_nat n\\<rbrakk>\n       \\<Longrightarrow> x * ordinal_of_nat n \\<le> y", "apply (erule subst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. 0 < x \\<Longrightarrow> x * (y div x) \\<le> y", "apply (rule ordinal_times_div_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_plus_absorb_iff: \"(x + y = y) = (x * \\<omega> \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y = y) = (x * \\<omega> \\<le> y)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. x + y = y \\<Longrightarrow> x * \\<omega> \\<le> y\n 2. x * \\<omega> \\<le> y \\<Longrightarrow> x + y = y", "apply (rule ccontr, simp add: linorder_not_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x + y = y; y < x * \\<omega>\\<rbrakk> \\<Longrightarrow> False\n 2. x * \\<omega> \\<le> y \\<Longrightarrow> x + y = y", "apply (drule ordinal_less_plusL, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * \\<omega> \\<le> y \\<Longrightarrow> x + y = y", "apply (erule ordinal_plus_absorb)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ordinal_less_plusL_iff: \"(y < x + y) = (y < x * \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y < x + y) = (y < x * \\<omega>)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. y < x + y \\<Longrightarrow> y < x * \\<omega>\n 2. y < x * \\<omega> \\<Longrightarrow> y < x + y", "apply (rule ccontr, simp add: linorder_not_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>y < x + y; x * \\<omega> \\<le> y\\<rbrakk>\n    \\<Longrightarrow> False\n 2. y < x * \\<omega> \\<Longrightarrow> y < x + y", "apply (drule ordinal_plus_absorb, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x * \\<omega> \\<Longrightarrow> y < x + y", "apply (erule ordinal_less_plusL)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Additive principal ordinals\\<close>"], ["", "locale additive_principal =\n  fixes a :: ordinal\n  assumes not_0:  \"0 < a\"\n  assumes sum_eq: \"\\<And>b. b < a \\<Longrightarrow> b + a = a\""], ["", "lemma (in additive_principal) sum_less:\n\"\\<lbrakk>x < a; y < a\\<rbrakk> \\<Longrightarrow> x + y < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < a; y < a\\<rbrakk> \\<Longrightarrow> x + y < a", "by (drule sum_eq, erule subst, simp)"], ["", "lemma (in additive_principal) times_nat_less:\n\"x < a \\<Longrightarrow> x * ordinal_of_nat n < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < a \\<Longrightarrow> x * ordinal_of_nat n < a", "apply (induct_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x < a \\<Longrightarrow> x * ordinal_of_nat 0 < a\n 2. \\<And>n.\n       \\<lbrakk>x < a; x * ordinal_of_nat n < a\\<rbrakk>\n       \\<Longrightarrow> x * ordinal_of_nat (Suc n) < a", "apply (simp add: not_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x < a; x * ordinal_of_nat n < a\\<rbrakk>\n       \\<Longrightarrow> x * ordinal_of_nat (Suc n) < a", "apply (simp add: sum_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma not_additive_principal_0: \"\\<not> additive_principal 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> additive_principal 0", "by (clarify, drule additive_principal.not_0, simp)"], ["", "lemma additive_principal_oSuc:\n\"additive_principal (oSuc a) = (a = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. additive_principal (oSuc a) = (a = 0)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. additive_principal (oSuc a) \\<Longrightarrow> a = 0\n 2. a = 0 \\<Longrightarrow> additive_principal (oSuc 0)", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>additive_principal (oSuc a); 0 < a\\<rbrakk>\n    \\<Longrightarrow> False\n 2. a = 0 \\<Longrightarrow> additive_principal (oSuc 0)", "apply (subgoal_tac \"a + oSuc 0 < oSuc a\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>additive_principal (oSuc a); 0 < a\\<rbrakk>\n    \\<Longrightarrow> a + oSuc 0 < oSuc a\n 2. a = 0 \\<Longrightarrow> additive_principal (oSuc 0)", "apply (erule additive_principal.sum_less, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = 0 \\<Longrightarrow> additive_principal (oSuc 0)", "apply (simp add: additive_principal_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma additive_principal_intro2 [rule_format]:\nassumes not_0: \"0 < a\"\nshows \"(\\<forall>x<a. \\<forall>y<a. x + y < a) \\<longrightarrow> additive_principal a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x<a. \\<forall>y<a. x + y < a) \\<longrightarrow>\n    additive_principal a", "apply (simp add: additive_principal_def not_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x<a. \\<forall>y<a. x + y < a) \\<longrightarrow>\n    (\\<forall>b<a. b + a = a)", "apply (rule_tac a=a in oLimit_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<forall>x<0. \\<forall>y<0. x + y < 0) \\<longrightarrow>\n    (\\<forall>b<0. b + 0 = 0)\n 2. \\<And>x.\n       (\\<forall>xa<x. \\<forall>y<x. xa + y < x) \\<longrightarrow>\n       (\\<forall>b<x. b + x = x) \\<Longrightarrow>\n       (\\<forall>xa<oSuc x.\n           \\<forall>y<oSuc x. xa + y < oSuc x) \\<longrightarrow>\n       (\\<forall>b<oSuc x. b + oSuc x = oSuc x)\n 3. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x<oLimit f.\n                             \\<forall>y<oLimit f.\n                                x + y < oLimit f) \\<longrightarrow>\n                         (\\<forall>b<oLimit f. b + oLimit f = oLimit f)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<forall>xa<x. \\<forall>y<x. xa + y < x) \\<longrightarrow>\n       (\\<forall>b<x. b + x = x) \\<Longrightarrow>\n       (\\<forall>xa<oSuc x.\n           \\<forall>y<oSuc x. xa + y < oSuc x) \\<longrightarrow>\n       (\\<forall>b<oSuc x. b + oSuc x = oSuc x)\n 2. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x<oLimit f.\n                             \\<forall>y<oLimit f.\n                                x + y < oLimit f) \\<longrightarrow>\n                         (\\<forall>b<oLimit f. b + oLimit f = oLimit f)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x b.\n       \\<lbrakk>(\\<forall>xa<x. \\<forall>y<x. xa + y < x) \\<longrightarrow>\n                (\\<forall>b<x. b + x = x);\n        \\<forall>xa<oSuc x. \\<forall>y<oSuc x. xa + y < oSuc x;\n        b < oSuc x\\<rbrakk>\n       \\<Longrightarrow> b + x = x\n 2. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x<oLimit f.\n                             \\<forall>y<oLimit f.\n                                x + y < oLimit f) \\<longrightarrow>\n                         (\\<forall>b<oLimit f. b + oLimit f = oLimit f)", "apply (drule_tac x=x in spec, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x b.\n       \\<lbrakk>(\\<forall>xa<x. \\<forall>y<x. xa + y < x) \\<longrightarrow>\n                (\\<forall>b<x. b + x = x);\n        b < oSuc x; \\<forall>y<oSuc x. x + y < oSuc x\\<rbrakk>\n       \\<Longrightarrow> b + x = x\n 2. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x<oLimit f.\n                             \\<forall>y<oLimit f.\n                                x + y < oLimit f) \\<longrightarrow>\n                         (\\<forall>b<oLimit f. b + oLimit f = oLimit f)", "apply (drule_tac x=1 in spec, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x<oLimit f.\n                             \\<forall>y<oLimit f.\n                                x + y < oLimit f) \\<longrightarrow>\n                         (\\<forall>b<oLimit f. b + oLimit f = oLimit f)", "apply (simp add: linorder_not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x<oLimit f.\n                             \\<forall>y<oLimit f.\n                                x + y < oLimit f) \\<longrightarrow>\n                         (\\<forall>b<oLimit f.\n                             oLimit (\\<lambda>n. b + f n) = oLimit f)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f b.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n);\n        \\<forall>x<oLimit f. \\<forall>y<oLimit f. x + y < oLimit f;\n        b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> oLimit (\\<lambda>n. b + f n) = oLimit f", "apply (rule order_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f b.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n);\n        \\<forall>x<oLimit f. \\<forall>y<oLimit f. x + y < oLimit f;\n        b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> oLimit (\\<lambda>n. b + f n) \\<le> oLimit f\n 2. \\<And>f b.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n);\n        \\<forall>x<oLimit f. \\<forall>y<oLimit f. x + y < oLimit f;\n        b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> oLimit f \\<le> oLimit (\\<lambda>n. b + f n)", "apply (rule oLimit_leI, clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f b n.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n);\n        \\<forall>x<oLimit f. \\<forall>y<oLimit f. x + y < oLimit f;\n        b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> b + f n \\<le> oLimit f\n 2. \\<And>f b.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n);\n        \\<forall>x<oLimit f. \\<forall>y<oLimit f. x + y < oLimit f;\n        b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> oLimit f \\<le> oLimit (\\<lambda>n. b + f n)", "apply (rule order_less_imp_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f b n.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n);\n        \\<forall>x<oLimit f. \\<forall>y<oLimit f. x + y < oLimit f;\n        b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> b + f n < oLimit f\n 2. \\<And>f b.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n);\n        \\<forall>x<oLimit f. \\<forall>y<oLimit f. x + y < oLimit f;\n        b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> oLimit f \\<le> oLimit (\\<lambda>n. b + f n)", "apply (simp add: strict_mono_less_oLimit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f b.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n);\n        \\<forall>x<oLimit f. \\<forall>y<oLimit f. x + y < oLimit f;\n        b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> oLimit f \\<le> oLimit (\\<lambda>n. b + f n)", "apply (rule oLimit_leI, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f b n.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n);\n        \\<forall>x<oLimit f. \\<forall>y<oLimit f. x + y < oLimit f;\n        b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> f n \\<le> oLimit (\\<lambda>n. b + f n)", "apply (rule_tac n=n in le_oLimitI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f b n.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n.\n           (\\<forall>x<f n. \\<forall>y<f n. x + y < f n) \\<longrightarrow>\n           (\\<forall>b<f n. b + f n = f n);\n        \\<forall>x<oLimit f. \\<forall>y<oLimit f. x + y < oLimit f;\n        b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> f n \\<le> b + f n", "apply (rule ordinal_le_plusL)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma additive_principal_1: \"additive_principal (oSuc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. additive_principal (oSuc 0)", "by (simp add: additive_principal_def)"], ["", "lemma additive_principal_omega: \"additive_principal \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. additive_principal \\<omega>", "apply (rule additive_principal.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < \\<omega>\n 2. \\<And>b. b < \\<omega> \\<Longrightarrow> b + \\<omega> = \\<omega>", "apply (rule zero_less_omega)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. b < \\<omega> \\<Longrightarrow> b + \\<omega> = \\<omega>", "apply (drule less_omegaD, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b n. ordinal_of_nat n + \\<omega> = \\<omega>", "apply (rule ordinal_of_nat_plus_omega)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma additive_principal_times_omega:\n\"0 < x \\<Longrightarrow> additive_principal (x * \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> additive_principal (x * \\<omega>)", "apply (rule additive_principal.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> 0 < x * \\<omega>\n 2. \\<And>b.\n       \\<lbrakk>0 < x; b < x * \\<omega>\\<rbrakk>\n       \\<Longrightarrow> b + x * \\<omega> = x * \\<omega>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>0 < x; b < x * \\<omega>\\<rbrakk>\n       \\<Longrightarrow> b + x * \\<omega> = x * \\<omega>", "apply (simp add: omega_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>0 < x;\n        b < oLimit (\\<lambda>n. x * ordinal_of_nat n)\\<rbrakk>\n       \\<Longrightarrow> oLimit (\\<lambda>n. b + x * ordinal_of_nat n) =\n                         oLimit (\\<lambda>n. x * ordinal_of_nat n)", "apply (drule less_oLimitD, clarify, rename_tac k)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b k.\n       \\<lbrakk>0 < x; b < x * ordinal_of_nat k\\<rbrakk>\n       \\<Longrightarrow> oLimit (\\<lambda>n. b + x * ordinal_of_nat n) =\n                         oLimit (\\<lambda>n. x * ordinal_of_nat n)", "apply (drule_tac x=b in order_less_imp_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b k.\n       \\<lbrakk>0 < x; b \\<le> x * ordinal_of_nat k\\<rbrakk>\n       \\<Longrightarrow> oLimit (\\<lambda>n. b + x * ordinal_of_nat n) =\n                         oLimit (\\<lambda>n. x * ordinal_of_nat n)", "apply (rule oLimit_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b k n.\n       \\<lbrakk>0 < x; b \\<le> x * ordinal_of_nat k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            b + x * ordinal_of_nat n\n                            \\<le> x * ordinal_of_nat m\n 2. \\<And>b k n.\n       \\<lbrakk>0 < x; b \\<le> x * ordinal_of_nat k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            x * ordinal_of_nat n\n                            \\<le> b + x * ordinal_of_nat m", "apply (rule_tac x=\"k + n\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b k n.\n       \\<lbrakk>0 < x; b \\<le> x * ordinal_of_nat k\\<rbrakk>\n       \\<Longrightarrow> b + x * ordinal_of_nat n\n                         \\<le> x * ordinal_of_nat (k + n)\n 2. \\<And>b k n.\n       \\<lbrakk>0 < x; b \\<le> x * ordinal_of_nat k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            x * ordinal_of_nat n\n                            \\<le> b + x * ordinal_of_nat m", "apply (erule order_trans[OF ordinal_plus_monoL])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b k n.\n       0 < x \\<Longrightarrow>\n       x * ordinal_of_nat k + x * ordinal_of_nat n\n       \\<le> x * ordinal_of_nat (k + n)\n 2. \\<And>b k n.\n       \\<lbrakk>0 < x; b \\<le> x * ordinal_of_nat k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            x * ordinal_of_nat n\n                            \\<le> b + x * ordinal_of_nat m", "apply (simp add: ordinal_times_distrib[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b k n.\n       \\<lbrakk>0 < x; b \\<le> x * ordinal_of_nat k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            x * ordinal_of_nat n\n                            \\<le> b + x * ordinal_of_nat m", "apply (rule_tac x=n in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma additive_principal_oLimit:\n\"\\<forall>n. additive_principal (f n) \\<Longrightarrow> additive_principal (oLimit f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. additive_principal (f n) \\<Longrightarrow>\n    additive_principal (oLimit f)", "apply (rule additive_principal.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>n. additive_principal (f n) \\<Longrightarrow> 0 < oLimit f\n 2. \\<And>b.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> b + oLimit f = oLimit f", "apply (rule_tac n=0 in less_oLimitI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>n. additive_principal (f n) \\<Longrightarrow> 0 < f 0\n 2. \\<And>b.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> b + oLimit f = oLimit f", "apply (simp add: additive_principal.not_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> b + oLimit f = oLimit f", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < oLimit f\\<rbrakk>\n       \\<Longrightarrow> oLimit (\\<lambda>n. b + f n) = oLimit f", "apply (drule less_oLimitD, clarify, rename_tac k)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b k.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k\\<rbrakk>\n       \\<Longrightarrow> oLimit (\\<lambda>n. b + f n) = oLimit f", "apply (rule oLimit_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. b + f n \\<le> f m\n 2. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. f n \\<le> b + f m", "apply (rule_tac x=\"f n\" and y = \"f k\" in linorder_le_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k;\n        f n \\<le> f k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. b + f n \\<le> f m\n 2. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k;\n        f k \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. b + f n \\<le> f m\n 3. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. f n \\<le> b + f m", "apply (rule_tac x=k in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k;\n        f n \\<le> f k\\<rbrakk>\n       \\<Longrightarrow> b + f n \\<le> f k\n 2. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k;\n        f k \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. b + f n \\<le> f m\n 3. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. f n \\<le> b + f m", "apply (rule_tac y=\"b + f k\" in order_trans, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k;\n        f n \\<le> f k\\<rbrakk>\n       \\<Longrightarrow> b + f k \\<le> f k\n 2. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k;\n        f k \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. b + f n \\<le> f m\n 3. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. f n \\<le> b + f m", "apply (simp add: additive_principal.sum_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k;\n        f k \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. b + f n \\<le> f m\n 2. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. f n \\<le> b + f m", "apply (rule_tac x=n in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k;\n        f k \\<le> f n\\<rbrakk>\n       \\<Longrightarrow> b + f n \\<le> f n\n 2. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. f n \\<le> b + f m", "apply (drule order_less_le_trans, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); f k \\<le> f n;\n        b < f n\\<rbrakk>\n       \\<Longrightarrow> b + f n \\<le> f n\n 2. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. f n \\<le> b + f m", "apply (simp add: additive_principal.sum_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b k n.\n       \\<lbrakk>\\<forall>n. additive_principal (f n); b < f k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. f n \\<le> b + f m", "apply (rule_tac x=n in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma additive_principal_omega_exp: \"additive_principal (\\<omega> ** x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. additive_principal (\\<omega> ** x)", "apply (rule_tac a=x in oLimit_induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. additive_principal (\\<omega> ** 0)\n 2. \\<And>x.\n       additive_principal (\\<omega> ** x) \\<Longrightarrow>\n       additive_principal (\\<omega> ** oSuc x)\n 3. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n. additive_principal (\\<omega> ** f n)\\<rbrakk>\n       \\<Longrightarrow> additive_principal (\\<omega> ** oLimit f)", "apply (simp add: additive_principal_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       additive_principal (\\<omega> ** x) \\<Longrightarrow>\n       additive_principal (\\<omega> ** oSuc x)\n 2. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n. additive_principal (\\<omega> ** f n)\\<rbrakk>\n       \\<Longrightarrow> additive_principal (\\<omega> ** oLimit f)", "apply (simp add: additive_principal_times_omega)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>OrdinalInduct.strict_mono f;\n        \\<forall>n. additive_principal (\\<omega> ** f n)\\<rbrakk>\n       \\<Longrightarrow> additive_principal (\\<omega> ** oLimit f)", "apply (simp add: additive_principal_oLimit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in additive_principal) omega_exp: \"\\<exists>x. a = \\<omega> ** x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. a = \\<omega> ** x", "apply (subgoal_tac \"\\<exists>x. \\<omega> ** x \\<le> a \\<and> a < \\<omega> ** (oSuc x)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x.\n       \\<omega> ** x \\<le> a \\<and> a < \\<omega> ** oSuc x \\<Longrightarrow>\n    \\<exists>x. a = \\<omega> ** x\n 2. \\<exists>x. \\<omega> ** x \\<le> a \\<and> a < \\<omega> ** oSuc x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x. \\<omega> ** x \\<le> a \\<and> a < \\<omega> ** oSuc x\n 2. \\<exists>x.\n       \\<omega> ** x \\<le> a \\<and> a < \\<omega> ** oSuc x \\<Longrightarrow>\n    \\<exists>x. a = \\<omega> ** x", "apply (rule normal.oInv_ex)"], ["proof (prove)\ngoal (3 subgoals):\n 1. normal ((**) \\<omega>)\n 2. \\<omega> ** 0 \\<le> a\n 3. \\<exists>x.\n       \\<omega> ** x \\<le> a \\<and> a < \\<omega> ** oSuc x \\<Longrightarrow>\n    \\<exists>x. a = \\<omega> ** x", "apply (rule normal_exp, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<omega> ** 0 \\<le> a\n 2. \\<exists>x.\n       \\<omega> ** x \\<le> a \\<and> a < \\<omega> ** oSuc x \\<Longrightarrow>\n    \\<exists>x. a = \\<omega> ** x", "apply (simp add: oSuc_le_eq_less not_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<omega> ** x \\<le> a \\<and> a < \\<omega> ** oSuc x \\<Longrightarrow>\n    \\<exists>x. a = \\<omega> ** x", "apply (auto simp add: order_le_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a < \\<omega> ** x * \\<omega>; \\<omega> ** x < a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. a = \\<omega> ** x", "apply (subgoal_tac \"a < a\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a < \\<omega> ** x * \\<omega>; \\<omega> ** x < a\\<rbrakk>\n       \\<Longrightarrow> a < a", "apply (rule order_less_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>a < \\<omega> ** x * \\<omega>; \\<omega> ** x < a\\<rbrakk>\n       \\<Longrightarrow> a < ?y24 x\n 2. \\<And>x.\n       \\<lbrakk>a < \\<omega> ** x * \\<omega>; \\<omega> ** x < a\\<rbrakk>\n       \\<Longrightarrow> ?y24 x < a", "apply (rule_tac y=\"\\<omega> ** x\" in ordinal_less_times_div_plus)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>a < \\<omega> ** x * \\<omega>; \\<omega> ** x < a\\<rbrakk>\n       \\<Longrightarrow> 0 < \\<omega> ** x\n 2. \\<And>x.\n       \\<lbrakk>a < \\<omega> ** x * \\<omega>; \\<omega> ** x < a\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** x * (a div \\<omega> ** x) +\n                         \\<omega> ** x\n                         < a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a < \\<omega> ** x * \\<omega>; \\<omega> ** x < a\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** x * (a div \\<omega> ** x) +\n                         \\<omega> ** x\n                         < a", "apply (drule ordinal_div_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<omega> ** x < a; a div \\<omega> ** x < \\<omega>\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** x * (a div \\<omega> ** x) +\n                         \\<omega> ** x\n                         < a", "apply (drule less_omegaD, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>\\<omega> ** x < a;\n        a div \\<omega> ** x = ordinal_of_nat n\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** x * (a div \\<omega> ** x) +\n                         \\<omega> ** x\n                         < a", "apply (drule_tac n=\"Suc n\" in times_nat_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>a div \\<omega> ** x = ordinal_of_nat n;\n        \\<omega> ** x * ordinal_of_nat (Suc n) < a\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** x * (a div \\<omega> ** x) +\n                         \\<omega> ** x\n                         < a", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma additive_principal_iff:\n\"additive_principal a = (\\<exists>x. a = \\<omega> ** x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. additive_principal a = (\\<exists>x. a = \\<omega> ** x)", "by (auto intro: additive_principal_omega_exp\n                additive_principal.omega_exp)"], ["", "lemma absorb_omega_exp:\n\"x < \\<omega> ** a \\<Longrightarrow> x + \\<omega> ** a = \\<omega> ** a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < \\<omega> ** a \\<Longrightarrow> x + \\<omega> ** a = \\<omega> ** a", "by (rule additive_principal.sum_eq[OF additive_principal_omega_exp])"], ["", "lemma absorb_omega_exp2: \"a < b \\<Longrightarrow> \\<omega> ** a + \\<omega> ** b = \\<omega> ** b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b \\<Longrightarrow> \\<omega> ** a + \\<omega> ** b = \\<omega> ** b", "by (rule absorb_omega_exp, simp add: ordinal_exp_strict_monoR)"], ["", "subsection \\<open>Cantor normal form\\<close>"], ["", "lemma cnf_lemma: \"x > 0 \\<Longrightarrow> x - \\<omega> ** oLog \\<omega> x < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> x - \\<omega> ** oLog \\<omega> x < x", "apply (subst ordinal_minus_less_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> \\<omega> ** oLog \\<omega> x \\<le> x\n 2. 0 < x \\<Longrightarrow> x < \\<omega> ** oLog \\<omega> x + x", "apply (erule ordinal_exp_oLog_le, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> x < \\<omega> ** oLog \\<omega> x + x", "apply (rule ordinal_less_plusL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> x < \\<omega> ** oLog \\<omega> x * \\<omega>", "apply (rule ordinal_less_exp_oLog, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec from_cnf where\n  \"from_cnf []       = 0\"\n  | \"from_cnf (x # xs) = \\<omega> ** x + from_cnf xs\""], ["", "function to_cnf where\n [simp del]: \"to_cnf x = (if x = 0 then [] else\n    oLog \\<omega> x # to_cnf (x - \\<omega> ** oLog \\<omega> x))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>xa. x = xa \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>x xa.\n       x = xa \\<Longrightarrow>\n       (if x = 0 then []\n        else oLog \\<omega> x #\n             to_cnf_sumC (x - \\<omega> ** oLog \\<omega> x)) =\n       (if xa = 0 then []\n        else oLog \\<omega> xa #\n             to_cnf_sumC (xa - \\<omega> ** oLog \\<omega> xa))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All to_cnf_dom", "by (relation \"{(x, y). x < y}\")\n  (simp_all add: wf cnf_lemma)"], ["", "lemma to_cnf_0 [simp]: \"to_cnf 0 = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_cnf 0 = []", "by (simp add: to_cnf.simps)"], ["", "lemma to_cnf_not_0:\n\"0 < x \\<Longrightarrow> to_cnf x = oLog \\<omega> x # to_cnf (x - \\<omega> ** oLog \\<omega> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow>\n    to_cnf x = oLog \\<omega> x # to_cnf (x - \\<omega> ** oLog \\<omega> x)", "by (simp add: to_cnf.simps[of x])"], ["", "lemma to_cnf_eq_Cons: \"to_cnf x = a # list \\<Longrightarrow> a = oLog \\<omega> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_cnf x = a # list \\<Longrightarrow> a = oLog \\<omega> x", "by (case_tac \"x = 0\", simp, simp add: to_cnf_not_0)"], ["", "lemma to_cnf_inverse: \"from_cnf (to_cnf x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_cnf (to_cnf x) = x", "apply (rule wf_induct[OF wf], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. from_cnf (to_cnf y) = y \\<Longrightarrow>\n       from_cnf (to_cnf x) = x", "apply (case_tac \"x = 0\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. from_cnf (to_cnf y) = y; 0 < x\\<rbrakk>\n       \\<Longrightarrow> from_cnf (to_cnf x) = x", "apply (simp add: to_cnf_not_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. from_cnf (to_cnf y) = y; 0 < x\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** oLog \\<omega> x +\n                         from_cnf\n                          (to_cnf (x - \\<omega> ** oLog \\<omega> x)) =\n                         x", "apply (simp add: cnf_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. from_cnf (to_cnf y) = y; 0 < x\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** oLog \\<omega> x +\n                         (x - \\<omega> ** oLog \\<omega> x) =\n                         x", "apply (rule ordinal_plus_minus2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. from_cnf (to_cnf y) = y; 0 < x\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** oLog \\<omega> x \\<le> x", "apply (erule ordinal_exp_oLog_le, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec normalize_cnf where\n  normalize_cnf_Nil: \"normalize_cnf [] = []\"\n  | normalize_cnf_Cons: \"normalize_cnf (x # xs) =\n      (case xs of [] \\<Rightarrow> [x] | y # ys \\<Rightarrow>\n        (if x < y then [] else [x]) @ normalize_cnf xs)\""], ["", "lemma from_cnf_normalize_cnf: \"from_cnf (normalize_cnf xs) = from_cnf xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_cnf (normalize_cnf xs) = from_cnf xs", "apply (induct_tac xs, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       from_cnf (normalize_cnf list) = from_cnf list \\<Longrightarrow>\n       from_cnf\n        (case list of [] \\<Rightarrow> [a]\n         | y # ys \\<Rightarrow>\n             (if a < y then [] else [a]) @ normalize_cnf list) =\n       \\<omega> ** a + from_cnf list", "apply (case_tac list, simp, clarsimp simp del: normalize_cnf_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa lista.\n       \\<lbrakk>from_cnf (normalize_cnf (aa # lista)) =\n                \\<omega> ** aa + from_cnf lista;\n        a < aa\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** aa + from_cnf lista =\n                         \\<omega> ** a + (\\<omega> ** aa + from_cnf lista)", "apply (simp add: ordinal_plus_assoc[symmetric] absorb_omega_exp2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma normalize_cnf_to_cnf: \"normalize_cnf (to_cnf x) = to_cnf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_cnf (to_cnf x) = to_cnf x", "apply (rule_tac a=x in wf_induct[OF wf], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. normalize_cnf (to_cnf y) = to_cnf y \\<Longrightarrow>\n       normalize_cnf (to_cnf x) = to_cnf x", "apply (case_tac \"x = 0\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. normalize_cnf (to_cnf y) = to_cnf y;\n        0 < x\\<rbrakk>\n       \\<Longrightarrow> normalize_cnf (to_cnf x) = to_cnf x", "apply (drule spec, drule mp, erule cnf_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < x;\n        normalize_cnf (to_cnf (x - \\<omega> ** oLog \\<omega> x)) =\n        to_cnf (x - \\<omega> ** oLog \\<omega> x)\\<rbrakk>\n       \\<Longrightarrow> normalize_cnf (to_cnf x) = to_cnf x", "apply (simp add: to_cnf_not_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < x;\n        normalize_cnf (to_cnf (x - \\<omega> ** oLog \\<omega> x)) =\n        to_cnf (x - \\<omega> ** oLog \\<omega> x)\\<rbrakk>\n       \\<Longrightarrow> (case to_cnf (x - \\<omega> ** oLog \\<omega> x) of\n                          [] \\<Rightarrow> [oLog \\<omega> x]\n                          | y # ys \\<Rightarrow>\n                              (if oLog \\<omega> x < y then []\n                               else [oLog \\<omega> x]) @\n                              normalize_cnf\n                               (to_cnf (x - \\<omega> ** oLog \\<omega> x))) =\n                         oLog \\<omega> x #\n                         to_cnf (x - \\<omega> ** oLog \\<omega> x)", "apply (case_tac \"to_cnf (x - \\<omega> ** oLog \\<omega> x)\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a list.\n       \\<lbrakk>0 < x;\n        (case list of [] \\<Rightarrow> [a]\n         | y # ys \\<Rightarrow>\n             (if a < y then [] else [a]) @ normalize_cnf list) =\n        a # list;\n        to_cnf (x - \\<omega> ** oLog \\<omega> x) = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<not> oLog \\<omega> x < a", "apply (drule to_cnf_eq_Cons, simp add: linorder_not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a list.\n       \\<lbrakk>0 < x;\n        (case list of [] \\<Rightarrow> [a]\n         | y # ys \\<Rightarrow>\n             (if a < y then [] else [a]) @ normalize_cnf list) =\n        oLog \\<omega> (x - \\<omega> ** oLog \\<omega> x) # list;\n        a = oLog \\<omega> (x - \\<omega> ** oLog \\<omega> x)\\<rbrakk>\n       \\<Longrightarrow> oLog \\<omega> (x - \\<omega> ** oLog \\<omega> x)\n                         \\<le> oLog \\<omega> x", "apply (rule ordinal_oLog_monoR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a list.\n       \\<lbrakk>0 < x;\n        (case list of [] \\<Rightarrow> [a]\n         | y # ys \\<Rightarrow>\n             (if a < y then [] else [a]) @ normalize_cnf list) =\n        oLog \\<omega> (x - \\<omega> ** oLog \\<omega> x) # list;\n        a = oLog \\<omega> (x - \\<omega> ** oLog \\<omega> x)\\<rbrakk>\n       \\<Longrightarrow> x - \\<omega> ** oLog \\<omega> x \\<le> x", "apply (rule order_less_imp_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a list.\n       \\<lbrakk>0 < x;\n        (case list of [] \\<Rightarrow> [a]\n         | y # ys \\<Rightarrow>\n             (if a < y then [] else [a]) @ normalize_cnf list) =\n        oLog \\<omega> (x - \\<omega> ** oLog \\<omega> x) # list;\n        a = oLog \\<omega> (x - \\<omega> ** oLog \\<omega> x)\\<rbrakk>\n       \\<Longrightarrow> x - \\<omega> ** oLog \\<omega> x < x", "apply (erule cnf_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \"alternate form of CNF\""], ["", "lemma cnf2_lemma:\n\"0 < x \\<Longrightarrow> x mod \\<omega> ** oLog \\<omega> x < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> x mod \\<omega> ** oLog \\<omega> x < x", "apply (rule order_less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow> x mod \\<omega> ** oLog \\<omega> x < ?y\n 2. 0 < x \\<Longrightarrow> ?y \\<le> x", "apply (rule ordinal_mod_less, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> \\<omega> ** oLog \\<omega> x \\<le> x", "apply (erule ordinal_exp_oLog_le, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec from_cnf2 where\n  \"from_cnf2 []       = 0\"\n  | \"from_cnf2 (x # xs) = \\<omega> ** fst x * ordinal_of_nat (snd x) + from_cnf2 xs\""], ["", "function to_cnf2 where\n  [simp del]: \"to_cnf2 x = (if x = 0 then [] else\n    (oLog \\<omega> x, inv ordinal_of_nat (x div (\\<omega> ** oLog \\<omega> x)))\n      # to_cnf2 (x mod (\\<omega> ** oLog \\<omega> x)))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>xa. x = xa \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>x xa.\n       x = xa \\<Longrightarrow>\n       (if x = 0 then []\n        else (oLog \\<omega> x,\n              inv ordinal_of_nat (x div \\<omega> ** oLog \\<omega> x)) #\n             to_cnf2_sumC (x mod \\<omega> ** oLog \\<omega> x)) =\n       (if xa = 0 then []\n        else (oLog \\<omega> xa,\n              inv ordinal_of_nat (xa div \\<omega> ** oLog \\<omega> xa)) #\n             to_cnf2_sumC (xa mod \\<omega> ** oLog \\<omega> xa))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All to_cnf2_dom", "by (relation \"{(x,y). x < y}\")\n  (simp_all add: wf cnf2_lemma)"], ["", "lemma to_cnf2_0 [simp]: \"to_cnf2 0 = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_cnf2 0 = []", "by (simp add: to_cnf2.simps)"], ["", "lemma to_cnf2_not_0:\n\"0 < x \\<Longrightarrow> to_cnf2 x =\n  (oLog \\<omega> x, inv ordinal_of_nat (x div (\\<omega> ** oLog \\<omega> x)))\n     # to_cnf2 (x mod (\\<omega> ** oLog \\<omega> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow>\n    to_cnf2 x =\n    (oLog \\<omega> x,\n     inv ordinal_of_nat (x div \\<omega> ** oLog \\<omega> x)) #\n    to_cnf2 (x mod \\<omega> ** oLog \\<omega> x)", "by (simp add: to_cnf2.simps[of x])"], ["", "lemma to_cnf2_eq_Cons: \"to_cnf2 x = (a,b) # list \\<Longrightarrow> a = oLog \\<omega> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_cnf2 x = (a, b) # list \\<Longrightarrow> a = oLog \\<omega> x", "by (case_tac \"x = 0\", simp, simp add: to_cnf2_not_0)"], ["", "lemma ordinal_of_nat_of_ordinal:\n\"x < \\<omega> \\<Longrightarrow> ordinal_of_nat (inv ordinal_of_nat x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < \\<omega> \\<Longrightarrow> ordinal_of_nat (inv ordinal_of_nat x) = x", "apply (rule f_inv_into_f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < \\<omega> \\<Longrightarrow> x \\<in> range ordinal_of_nat", "apply (simp add: image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < \\<omega> \\<Longrightarrow> \\<exists>xa. x = ordinal_of_nat xa", "apply (erule less_omegaD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma to_cnf2_inverse: \"from_cnf2 (to_cnf2 x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_cnf2 (to_cnf2 x) = x", "apply (rule wf_induct[OF wf], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. from_cnf2 (to_cnf2 y) = y \\<Longrightarrow>\n       from_cnf2 (to_cnf2 x) = x", "apply (case_tac \"x = 0\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. from_cnf2 (to_cnf2 y) = y; 0 < x\\<rbrakk>\n       \\<Longrightarrow> from_cnf2 (to_cnf2 x) = x", "apply (simp add: to_cnf2_not_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. from_cnf2 (to_cnf2 y) = y; 0 < x\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** oLog \\<omega> x *\n                         ordinal_of_nat\n                          (inv ordinal_of_nat\n                            (x div \\<omega> ** oLog \\<omega> x)) +\n                         from_cnf2\n                          (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x)) =\n                         x", "apply (simp add: cnf2_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. from_cnf2 (to_cnf2 y) = y; 0 < x\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** oLog \\<omega> x *\n                         ordinal_of_nat\n                          (inv ordinal_of_nat\n                            (x div \\<omega> ** oLog \\<omega> x)) +\n                         x mod \\<omega> ** oLog \\<omega> x =\n                         x", "apply (drule_tac x=\"x mod \\<omega> ** oLog \\<omega> x\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < x;\n        x mod \\<omega> ** oLog \\<omega> x < x \\<longrightarrow>\n        from_cnf2 (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x)) =\n        x mod \\<omega> ** oLog \\<omega> x\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** oLog \\<omega> x *\n                         ordinal_of_nat\n                          (inv ordinal_of_nat\n                            (x div \\<omega> ** oLog \\<omega> x)) +\n                         x mod \\<omega> ** oLog \\<omega> x =\n                         x", "apply (simp add: cnf2_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < x;\n        from_cnf2 (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x)) =\n        x mod \\<omega> ** oLog \\<omega> x\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** oLog \\<omega> x *\n                         ordinal_of_nat\n                          (inv ordinal_of_nat\n                            (x div \\<omega> ** oLog \\<omega> x)) +\n                         x mod \\<omega> ** oLog \\<omega> x =\n                         x", "apply (subst ordinal_of_nat_of_ordinal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < x;\n        from_cnf2 (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x)) =\n        x mod \\<omega> ** oLog \\<omega> x\\<rbrakk>\n       \\<Longrightarrow> x div \\<omega> ** oLog \\<omega> x < \\<omega>\n 2. \\<And>x.\n       \\<lbrakk>0 < x;\n        from_cnf2 (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x)) =\n        x mod \\<omega> ** oLog \\<omega> x\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** oLog \\<omega> x *\n                         (x div \\<omega> ** oLog \\<omega> x) +\n                         x mod \\<omega> ** oLog \\<omega> x =\n                         x", "apply (rule ordinal_div_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < x;\n        from_cnf2 (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x)) =\n        x mod \\<omega> ** oLog \\<omega> x\\<rbrakk>\n       \\<Longrightarrow> x < \\<omega> ** oLog \\<omega> x * \\<omega>\n 2. \\<And>x.\n       \\<lbrakk>0 < x;\n        from_cnf2 (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x)) =\n        x mod \\<omega> ** oLog \\<omega> x\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** oLog \\<omega> x *\n                         (x div \\<omega> ** oLog \\<omega> x) +\n                         x mod \\<omega> ** oLog \\<omega> x =\n                         x", "apply (rule ordinal_less_exp_oLog, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < x;\n        from_cnf2 (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x)) =\n        x mod \\<omega> ** oLog \\<omega> x\\<rbrakk>\n       \\<Longrightarrow> \\<omega> ** oLog \\<omega> x *\n                         (x div \\<omega> ** oLog \\<omega> x) +\n                         x mod \\<omega> ** oLog \\<omega> x =\n                         x", "apply (rule ordinal_div_plus_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec is_normalized2 where\n  is_normalized2_Nil: \"is_normalized2 [] = True\"\n  | is_normalized2_Cons: \"is_normalized2 (x # xs) =\n      (case xs of [] \\<Rightarrow> True | y # ys \\<Rightarrow> fst y < fst x \\<and> is_normalized2 xs)\""], ["", "lemma is_normalized2_to_cnf2: \"is_normalized2 (to_cnf2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_normalized2 (to_cnf2 x)", "apply (rule_tac a=x in wf_induct[OF wf], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y<x. is_normalized2 (to_cnf2 y) \\<Longrightarrow>\n       is_normalized2 (to_cnf2 x)", "apply (case_tac \"x = 0\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y<x. is_normalized2 (to_cnf2 y); 0 < x\\<rbrakk>\n       \\<Longrightarrow> is_normalized2 (to_cnf2 x)", "apply (drule spec, drule mp, erule cnf2_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < x;\n        is_normalized2\n         (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x))\\<rbrakk>\n       \\<Longrightarrow> is_normalized2 (to_cnf2 x)", "apply (simp add: to_cnf2_not_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < x;\n        is_normalized2\n         (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x))\\<rbrakk>\n       \\<Longrightarrow> case to_cnf2 (x mod \\<omega> ** oLog \\<omega> x) of\n                         [] \\<Rightarrow> True\n                         | y # ys \\<Rightarrow>\n                             fst y\n                             < fst (oLog \\<omega> x,\n                                    inv ordinal_of_nat\n                                     (x div\n\\<omega> ** oLog \\<omega> x)) \\<and>\n                             is_normalized2\n                              (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x))", "apply (case_tac \"x mod \\<omega> ** oLog \\<omega> x = 0\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < x;\n        is_normalized2 (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x));\n        0 < x mod \\<omega> ** oLog \\<omega> x\\<rbrakk>\n       \\<Longrightarrow> case to_cnf2 (x mod \\<omega> ** oLog \\<omega> x) of\n                         [] \\<Rightarrow> True\n                         | y # ys \\<Rightarrow>\n                             fst y\n                             < fst (oLog \\<omega> x,\n                                    inv ordinal_of_nat\n                                     (x div\n\\<omega> ** oLog \\<omega> x)) \\<and>\n                             is_normalized2\n                              (to_cnf2 (x mod \\<omega> ** oLog \\<omega> x))", "apply (case_tac \"to_cnf2 (x mod \\<omega> ** oLog \\<omega> x)\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a list.\n       \\<lbrakk>0 < x;\n        case list of [] \\<Rightarrow> True\n        | y # ys \\<Rightarrow> fst y < fst a \\<and> is_normalized2 list;\n        0 < x mod \\<omega> ** oLog \\<omega> x;\n        to_cnf2 (x mod \\<omega> ** oLog \\<omega> x) = a # list\\<rbrakk>\n       \\<Longrightarrow> fst a < oLog \\<omega> x", "apply (case_tac a, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a list aa b.\n       \\<lbrakk>0 < x;\n        case list of [] \\<Rightarrow> True\n        | y # ys \\<Rightarrow> fst y < fst a \\<and> is_normalized2 list;\n        0 < x mod \\<omega> ** oLog \\<omega> x;\n        to_cnf2 (x mod \\<omega> ** oLog \\<omega> x) = (aa, b) # list;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> aa < oLog \\<omega> x", "apply (drule to_cnf2_eq_Cons, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a list aa b.\n       \\<lbrakk>0 < x;\n        case list of [] \\<Rightarrow> True\n        | y # ys \\<Rightarrow> fst y < fst a \\<and> is_normalized2 list;\n        0 < x mod \\<omega> ** oLog \\<omega> x;\n        a = (oLog \\<omega> (x mod \\<omega> ** oLog \\<omega> x), b);\n        aa = oLog \\<omega> (x mod \\<omega> ** oLog \\<omega> x)\\<rbrakk>\n       \\<Longrightarrow> oLog \\<omega> (x mod \\<omega> ** oLog \\<omega> x)\n                         < oLog \\<omega> x", "apply (erule ordinal_oLog_less, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a list aa b.\n       \\<lbrakk>0 < x;\n        case list of [] \\<Rightarrow> True\n        | y # ys \\<Rightarrow> fst y < fst a \\<and> is_normalized2 list;\n        a = (oLog \\<omega> (x mod \\<omega> ** oLog \\<omega> x), b);\n        aa = oLog \\<omega> (x mod \\<omega> ** oLog \\<omega> x)\\<rbrakk>\n       \\<Longrightarrow> x mod \\<omega> ** oLog \\<omega> x\n                         < \\<omega> ** oLog \\<omega> x", "apply (rule ordinal_mod_less, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Epsilon 0\\<close>"], ["", "definition epsilon0 :: ordinal  (\"\\<epsilon>\\<^sub>0\") where\n  \"epsilon0 = oFix ((**) \\<omega>) 0\""], ["", "lemma less_omega_exp: \"x < \\<epsilon>\\<^sub>0 \\<Longrightarrow> x < \\<omega> ** x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < \\<epsilon>\\<^sub>0 \\<Longrightarrow> x < \\<omega> ** x", "apply (unfold epsilon0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < oFix ((**) \\<omega>) 0 \\<Longrightarrow> x < \\<omega> ** x", "apply (erule less_oFix_0D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((**) \\<omega>)", "apply (rule continuous.mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous ((**) \\<omega>)", "apply (rule continuous_exp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<omega>", "apply (rule zero_less_omega)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma omega_exp_epsilon0: \"\\<omega> ** \\<epsilon>\\<^sub>0 = \\<epsilon>\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> ** \\<epsilon>\\<^sub>0 = \\<epsilon>\\<^sub>0", "apply (unfold epsilon0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> ** oFix ((**) \\<omega>) 0 = oFix ((**) \\<omega>) 0", "apply (rule oFix_fixed)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous ((**) \\<omega>)\n 2. 0 \\<le> \\<omega> ** 0", "apply (rule continuous_exp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < \\<omega>\n 2. 0 \\<le> \\<omega> ** 0", "apply (rule zero_less_omega)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<omega> ** 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma oLog_omega_less: \"\\<lbrakk>0 < x; x < \\<epsilon>\\<^sub>0\\<rbrakk> \\<Longrightarrow> oLog \\<omega> x < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; x < \\<epsilon>\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> oLog \\<omega> x < x", "apply (erule ordinal_oLog_less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x < \\<epsilon>\\<^sub>0 \\<Longrightarrow> oSuc 0 < \\<omega>\n 2. x < \\<epsilon>\\<^sub>0 \\<Longrightarrow> x < \\<omega> ** x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < \\<epsilon>\\<^sub>0 \\<Longrightarrow> x < \\<omega> ** x", "apply (erule less_omega_exp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}