{"file_name": "/home/qj213/afp-2021-10-22/thys/Budan_Fourier/BF_Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Budan_Fourier", "problem_names": ["lemma poly_root_induct_alt [case_names 0 no_proots root]:\n  fixes p :: \"'a :: idom poly\"\n  assumes \"Q 0\"\n  assumes \"\\<And>p. (\\<And>a. poly p a \\<noteq> 0) \\<Longrightarrow> Q p\"\n  assumes \"\\<And>a p. Q p \\<Longrightarrow> Q ([:-a, 1:] * p)\"\n  shows   \"Q p\"", "lemma lead_coeff_pderiv:\n  fixes p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors,semiring_char_0} poly\"\n  shows \"lead_coeff (pderiv p) = of_nat (degree p) * lead_coeff p\"", "lemma gcd_degree_le_min:\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"degree (gcd p q) \\<le> min (degree p) (degree q)\"", "lemma lead_coeff_normalize_field:\n  fixes p::\"'a::{field,semidom_divide_unit_factor} poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"lead_coeff (normalize p) = 1\"", "lemma smult_normalize_field_eq:\n  fixes p::\"'a::{field,semidom_divide_unit_factor} poly\"\n  shows \"p = smult (lead_coeff p) (normalize p)\"", "lemma lead_coeff_gcd_field:\n  fixes p q::\"'a::field_gcd poly\"\n  assumes \"p\\<noteq>0 \\<or> q\\<noteq>0\"\n  shows \"lead_coeff (gcd p q) = 1\"", "lemma poly_gcd_0_iff:\n  \"poly (gcd p q) x = 0 \\<longleftrightarrow> poly p x=0 \\<and> poly q x=0\"", "lemma degree_eq_oneE:\n  fixes p :: \"'a::zero poly\"\n  assumes \"degree p = 1\"\n  obtains a b where \"p = [:a,b:]\" \"b\\<noteq>0\"", "lemma changes_0[simp]:\"changes (0#xs) = changes xs\"", "lemma changes_Cons:\"changes (x#xs) = (if filter (\\<lambda>x. x\\<noteq>0) xs = [] then \n                            0 \n                          else if x* hd (filter (\\<lambda>x. x\\<noteq>0) xs) < 0 then \n                            1 + changes xs \n                          else changes xs)\"", "lemma changes_filter_eq:\n  \"changes (filter (\\<lambda>x. x\\<noteq>0) xs) = changes xs\"", "lemma changes_filter_empty:\n  assumes \"filter (\\<lambda>x. x\\<noteq>0) xs = []\"\n  shows \"changes xs = 0\" \"changes (a#xs) = 0\"", "lemma changes_append:\n  assumes \"xs\\<noteq> [] \\<and> ys\\<noteq> [] \\<longrightarrow> (last xs = hd ys \\<and> last xs\\<noteq>0)\"\n  shows \"changes (xs@ys) = changes xs + changes ys\"", "lemma changes_drop_dup:\n  assumes \"xs\\<noteq> []\" \"ys\\<noteq> [] \\<longrightarrow> last xs=hd ys\"\n  shows \"changes (xs@ys) = changes (xs@ tl ys)\"", "lemma Im_poly_of_real:\n  \"Im (poly p (of_real x)) = poly (map_poly Im p) x\"", "lemma Re_poly_of_real:\n  \"Re (poly p (of_real x)) = poly (map_poly Re p) x\"", "lemma of_real_poly_map_pCons[simp]:\"map_poly of_real (pCons a p) = pCons (of_real a) (map_poly of_real p)\"", "lemma of_real_poly_map_plus[simp]: \"map_poly of_real (p + q) = map_poly of_real p +  map_poly of_real q\"", "lemma of_real_poly_map_smult[simp]:\"map_poly of_real (smult s p) = smult (of_real s) (map_poly of_real p)\"", "lemma of_real_poly_map_mult[simp]:\"map_poly of_real (p*q) = map_poly of_real p * map_poly of_real q\"", "lemma of_real_poly_map_poly:\n  \"of_real (poly p x) = poly (map_poly of_real p) (of_real x)\"", "lemma of_real_poly_map_power:\"map_poly of_real (p^n) = (map_poly of_real p) ^ n\"", "lemma of_real_poly_eq_iff [simp]: \"map_poly of_real p = map_poly of_real q \\<longleftrightarrow> p = q\"", "lemma of_real_poly_eq_0_iff [simp]: \"map_poly of_real p = 0 \\<longleftrightarrow> p = 0\"", "lemma order_multiplicity_eq:\n  assumes \"p\\<noteq>0\"\n  shows \"order a p = multiplicity [:-a,1:] p\"", "lemma order_gcd:\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"order x (gcd p q) = min (order x p) (order x q)\"", "lemma order_linear[simp]: \"order x [:-a,1:] = (if x=a then 1 else 0)\"", "lemma map_poly_order_of_real:\n  assumes \"p\\<noteq>0\"\n  shows \"order (of_real t) (map_poly of_real p) = order t p\"", "lemma order_pcompose:\n  assumes \"pcompose p q\\<noteq>0\"\n  shows \"order x (pcompose p q) = order x (q-[:poly q x:]) * order (poly q x) p\"", "lemma proots_def: \"proots p = {x. poly p x=0}\"", "lemma proots_within_empty[simp]:\n  \"proots_within p {} = {}\"", "lemma proots_within_0[simp]:\n  \"proots_within 0 s = s\"", "lemma proots_withinI[intro,simp]:\n  \"poly p x=0 \\<Longrightarrow> x\\<in>s \\<Longrightarrow> x\\<in>proots_within p s\"", "lemma proots_within_iff[simp]:\n  \"x\\<in>proots_within p s \\<longleftrightarrow> poly p x=0 \\<and> x\\<in>s\"", "lemma proots_within_union:\n  \"proots_within p A \\<union> proots_within p B = proots_within p (A \\<union> B)\"", "lemma proots_within_times:\n  fixes s::\"'a::{semiring_no_zero_divisors,comm_semiring_0} set\"\n  shows \"proots_within (p*q) s = proots_within p s \\<union> proots_within q s\"", "lemma proots_within_gcd:\n  fixes s::\"'a::{factorial_ring_gcd,semiring_gcd_mult_normalize} set\"\n  shows \"proots_within (gcd p q) s= proots_within p s \\<inter> proots_within q s\"", "lemma proots_within_inter:\n  \"NO_MATCH UNIV s \\<Longrightarrow> proots_within p s = proots p \\<inter> s\"", "lemma proots_within_proots[simp]:\n  \"proots_within p s \\<subseteq> proots p\"", "lemma finite_proots[simp]: \n  fixes p :: \"'a::idom poly\"\n  shows \"p\\<noteq>0 \\<Longrightarrow> finite (proots_within p s)\"", "lemma proots_within_pCons_1_iff:\n  fixes a::\"'a::idom\"\n  shows \"proots_within [:-a,1:] s = (if a\\<in>s then {a} else {})\"\n    \"proots_within [:a,-1:] s = (if a\\<in>s then {a} else {})\"", "lemma proots_within_uminus[simp]:\n  fixes p :: \"'a::comm_ring poly\"\n  shows \"proots_within (- p) s = proots_within p s\"", "lemma proots_within_smult:\n  fixes a::\"'a::{semiring_no_zero_divisors,comm_semiring_0}\"\n  assumes \"a\\<noteq>0\"\n  shows \"proots_within (smult a p) s = proots_within p s\"", "lemma proots_count_emtpy[simp]:\"proots_count p {} = 0\"", "lemma proots_count_times:\n  fixes s :: \"'a::idom set\"\n  assumes \"p*q\\<noteq>0\"\n  shows \"proots_count (p*q) s = proots_count p s + proots_count q s\"", "lemma proots_count_power_n_n:\n  shows \"proots_count ([:- a, 1:]^n) s = (if a\\<in>s \\<and> n>0 then n else 0)\"", "lemma degree_proots_count:\n  fixes p::\"complex poly\"\n  shows \"degree p = proots_count p UNIV\"", "lemma proots_count_smult:\n  fixes a::\"'a::{semiring_no_zero_divisors,idom}\"\n  assumes \"a\\<noteq>0\"\n  shows \"proots_count (smult a p) s= proots_count p s\"", "lemma proots_count_pCons_1_iff:\n  fixes a::\"'a::idom\"\n  shows \"proots_count [:-a,1:] s = (if a\\<in>s then 1 else 0)\"", "lemma proots_count_uminus[simp]:\n  \"proots_count (- p) s = proots_count p s\"", "lemma card_proots_within_leq:\n  assumes \"p\\<noteq>0\"\n  shows \"proots_count p s \\<ge> card (proots_within p s)\"", "lemma proots_count_0_imp_empty:\n  assumes \"proots_count p s=0\" \"p\\<noteq>0\"\n  shows \"proots_within p s = {}\"", "lemma proots_count_leq_degree:\n  assumes \"p\\<noteq>0\"\n  shows \"proots_count p s\\<le> degree p\"", "lemma proots_count_union_disjoint:\n  assumes \"A \\<inter> B = {}\" \"p\\<noteq>0\"\n  shows \"proots_count p (A \\<union> B) = proots_count p A + proots_count p B\"", "lemma proots_count_cong:\n  assumes order_eq:\"\\<forall>x\\<in>s. order x p = order x q\" and \"p\\<noteq>0\" and \"q\\<noteq>0\"\n  shows \"proots_count p s = proots_count q s\"", "lemma proots_count_of_real:\n  assumes \"p\\<noteq>0\"\n  shows \"proots_count (map_poly of_real p) ((of_real::_\\<Rightarrow>'a::{real_algebra_1,idom}) ` s) \n            = proots_count p s\"", "lemma proots_pcompose:\n  fixes p q::\"'a::field poly\"\n  assumes \"p\\<noteq>0\" \"degree q=1\"\n  shows \"proots_count (pcompose p q) s = proots_count p (poly q ` s)\"", "lemma fcompose_0 [simp]: \"fcompose 0 q r = 0\"", "lemma fcompose_const[simp]:\"fcompose [:a:] q r = [:a:]\"", "lemma fcompose_pCons: \n  \"fcompose (pCons a p) q1 q2 = smult a (q2^(degree (pCons a p))) + q1 * fcompose p q1 q2\"", "lemma fcompose_uminus:\n  \"fcompose (-p) q r = - fcompose p q r\"", "lemma fcompose_add_less:\n  assumes \"degree p1 > degree p2\"\n  shows \"fcompose (p1+p2) q1 q2 \n            = fcompose p1 q1 q2 + q2^(degree p1-degree p2) * fcompose p2 q1 q2\"", "lemma fcompose_add_eq:\n  assumes \"degree p1 = degree p2\"\n  shows \"q2^(degree p1 - degree (p1+p2)) * fcompose (p1+p2) q1 q2 \n            = fcompose p1 q1 q2 + fcompose p2 q1 q2\"", "lemma fcompose_add_const:\n  \"fcompose ([:a:] + p) q1 q2 = smult a (q2 ^ degree p) + fcompose p q1 q2\"", "lemma fcompose_smult: \"fcompose (smult a p) q1 q2 = smult a (fcompose p q1 q2)\"", "lemma fcompose_mult: \"fcompose (p1*p2) q1 q2 = fcompose p1 q1 q2 * fcompose p2 q1 q2\"", "lemma fcompose_poly:\n  assumes \"poly q2 x\\<noteq>0\"\n  shows \"poly p (poly q1 x/poly q2 x) = poly (fcompose p q1 q2) x / poly (q2^(degree p)) x\"", "lemma poly_fcompose:\n   assumes \"poly q2 x\\<noteq>0\"\n   shows \"poly (fcompose p q1 q2) x = poly p (poly q1 x/poly q2 x) * (poly q2 x)^(degree p)\"", "lemma poly_fcompose_0_denominator:\n  assumes \"poly q2 x=0\"\n  shows \"poly (fcompose p q1 q2) x = poly q1 x ^ degree p * lead_coeff p\"", "lemma fcompose_0_denominator:\"fcompose p q1 0 = smult (lead_coeff p) (q1^degree p)\"", "lemma fcompose_nzero:\n  fixes p::\"'a::field poly\"\n  assumes \"p\\<noteq>0\" and \"q2\\<noteq>0\" and nconst:\"\\<forall>c. q1 \\<noteq> smult c q2\"\n      and infi:\"infinite (UNIV::'a set)\"\n  shows \"fcompose p q1 q2 \\<noteq> 0\"", "lemma proots_fcompose_bij_eq:\n  fixes p::\"'a::field poly\"\n  assumes bij:\"bij_betw (\\<lambda>x. poly q1 x/poly q2 x) A B\" and \"p\\<noteq>0\" \n      and nzero:\"\\<forall>x\\<in>A. poly q2 x\\<noteq>0\"\n      and max_deg: \"max (degree q1) (degree q2) \\<le> 1\"\n      and nconst:\"\\<forall>c. q1 \\<noteq> smult c q2\"\n      and infi:\"infinite (UNIV::'a set)\"\n  shows \"proots_count p B = proots_count (fcompose p q1 q2) A\"", "lemma proots_card_fcompose_bij_eq:\n  fixes p::\"'a::field poly\"\n  assumes bij:\"bij_betw (\\<lambda>x. poly q1 x/poly q2 x) A B\" and \"p\\<noteq>0\" \n      and nzero:\"\\<forall>x\\<in>A. poly q2 x\\<noteq>0\"\n      and max_deg: \"max (degree q1) (degree q2) \\<le> 1\"\n      and nconst:\"\\<forall>c. q1 \\<noteq> smult c q2\"\n      and infi:\"infinite (UNIV::'a set)\"\n  shows \"card (proots_within p B) = card (proots_within (fcompose p q1 q2) A)\"", "lemma proots_pcompose_bij_eq:\n  fixes p::\"'a::idom poly\"\n  assumes bij:\"bij_betw (\\<lambda>x. poly q x) A B\" and \"p\\<noteq>0\" \n      and q_deg: \"degree q = 1\"\n  shows \"proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A\"", "lemma proots_card_pcompose_bij_eq:\n  fixes p::\"'a::idom poly\"\n  assumes bij:\"bij_betw (\\<lambda>x. poly q x) A B\" and \"p\\<noteq>0\" \n      and q_deg: \"degree q = 1\"\n  shows \"card (proots_within p B) = card (proots_within (p \\<circ>\\<^sub>p q) A)\""], "translations": [["", "lemma poly_root_induct_alt [case_names 0 no_proots root]:\n  fixes p :: \"'a :: idom poly\"\n  assumes \"Q 0\"\n  assumes \"\\<And>p. (\\<And>a. poly p a \\<noteq> 0) \\<Longrightarrow> Q p\"\n  assumes \"\\<And>a p. Q p \\<Longrightarrow> Q ([:-a, 1:] * p)\"\n  shows   \"Q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q p", "proof (induction \"degree p\" arbitrary: p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> Q pa) \\<Longrightarrow>\n       Q p", "case (less p)"], ["proof (state)\nthis:\n  degree ?p < degree p \\<Longrightarrow> Q ?p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> Q pa) \\<Longrightarrow>\n       Q p", "have ?case when \"p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q p", "using \\<open>Q 0\\<close> that"], ["proof (prove)\nusing this:\n  Q 0\n  p = 0\n\ngoal (1 subgoal):\n 1. Q p", "by auto"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow> Q p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> Q pa) \\<Longrightarrow>\n       Q p", "moreover"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow> Q p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> Q pa) \\<Longrightarrow>\n       Q p", "have ?case when \"\\<nexists>a. poly p a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q p", "using assms(2) that"], ["proof (prove)\nusing this:\n  (\\<And>a. poly ?p a \\<noteq> (0::'a)) \\<Longrightarrow> Q ?p\n  \\<nexists>a. poly p a = (0::'a)\n\ngoal (1 subgoal):\n 1. Q p", "by blast"], ["proof (state)\nthis:\n  \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow> Q p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> Q pa) \\<Longrightarrow>\n       Q p", "moreover"], ["proof (state)\nthis:\n  \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow> Q p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> Q pa) \\<Longrightarrow>\n       Q p", "have ?case when \"\\<exists>a. poly p a = 0\" \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Q p", "obtain a where \"poly p a =0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. poly p a = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<exists>a. poly p a = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>a. poly p a = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>a. poly p a = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly p a = (0::'a)\n\ngoal (1 subgoal):\n 1. Q p", "then"], ["proof (chain)\npicking this:\n  poly p a = (0::'a)", "obtain q where pq:\"p= [:-a,1:] * q\""], ["proof (prove)\nusing this:\n  poly p a = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = [:- a, 1::'a:] * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson dvdE poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  p = [:- a, 1::'a:] * q\n\ngoal (1 subgoal):\n 1. Q p", "then"], ["proof (chain)\npicking this:\n  p = [:- a, 1::'a:] * q", "have \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  p = [:- a, 1::'a:] * q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = [:- a, 1::'a:] * q\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Q p", "then"], ["proof (chain)\npicking this:\n  q \\<noteq> 0", "have \"degree q<degree p\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree q < degree p", "unfolding pq"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree q < degree ([:- a, 1::'a:] * q)", "by (subst degree_mult_eq,auto)"], ["proof (state)\nthis:\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. Q p", "then"], ["proof (chain)\npicking this:\n  degree q < degree p", "have \"Q q\""], ["proof (prove)\nusing this:\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. Q q", "using less"], ["proof (prove)\nusing this:\n  degree q < degree p\n  degree ?p < degree p \\<Longrightarrow> Q ?p\n\ngoal (1 subgoal):\n 1. Q q", "by auto"], ["proof (state)\nthis:\n  Q q\n\ngoal (1 subgoal):\n 1. Q p", "then"], ["proof (chain)\npicking this:\n  Q q", "show ?case"], ["proof (prove)\nusing this:\n  Q q\n\ngoal (1 subgoal):\n 1. Q p", "using assms(3)"], ["proof (prove)\nusing this:\n  Q q\n  Q ?p \\<Longrightarrow> Q ([:- ?a, 1::'a:] * ?p)\n\ngoal (1 subgoal):\n 1. Q p", "unfolding pq"], ["proof (prove)\nusing this:\n  Q q\n  Q ?p \\<Longrightarrow> Q ([:- ?a, 1::'a:] * ?p)\n\ngoal (1 subgoal):\n 1. Q ([:- a, 1::'a:] * q)", "by auto"], ["proof (state)\nthis:\n  Q p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>a. poly p a = (0::'a); p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> Q p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> Q pa) \\<Longrightarrow>\n       Q p", "ultimately"], ["proof (chain)\npicking this:\n  p = 0 \\<Longrightarrow> Q p\n  \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow> Q p\n  \\<lbrakk>\\<exists>a. poly p a = (0::'a); p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> Q p", "show ?case"], ["proof (prove)\nusing this:\n  p = 0 \\<Longrightarrow> Q p\n  \\<nexists>a. poly p a = (0::'a) \\<Longrightarrow> Q p\n  \\<lbrakk>\\<exists>a. poly p a = (0::'a); p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> Q p\n\ngoal (1 subgoal):\n 1. Q p", "by auto"], ["proof (state)\nthis:\n  Q p\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Misc\\<close>"], ["", "lemma lead_coeff_pderiv:\n  fixes p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors,semiring_char_0} poly\"\n  shows \"lead_coeff (pderiv p) = of_nat (degree p) * lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (pderiv p) = of_nat (degree p) * lead_coeff p", "apply (auto simp:degree_pderiv coeff_pderiv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) + of_nat (degree p - Suc 0)) *\n    coeff p (Suc (degree p - Suc 0)) =\n    of_nat (degree p) * lead_coeff p", "apply (cases \"degree p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    ((1::'a) + of_nat (degree p - Suc 0)) *\n    coeff p (Suc (degree p - Suc 0)) =\n    of_nat (degree p) * lead_coeff p\n 2. \\<And>nat.\n       degree p = Suc nat \\<Longrightarrow>\n       ((1::'a) + of_nat (degree p - Suc 0)) *\n       coeff p (Suc (degree p - Suc 0)) =\n       of_nat (degree p) * lead_coeff p", "by (auto simp add: coeff_eq_0)"], ["", "lemma gcd_degree_le_min:\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"degree (gcd p q) \\<le> min (degree p) (degree q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (gcd p q) \\<le> min (degree p) (degree q)", "by (simp add: assms(1) assms(2) dvd_imp_degree_le)"], ["", "lemma lead_coeff_normalize_field:\n  fixes p::\"'a::{field,semidom_divide_unit_factor} poly\"\n  assumes \"p\\<noteq>0\"\n  shows \"lead_coeff (normalize p) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (normalize p) = (1::'a)", "by (metis (no_types, lifting) assms coeff_normalize divide_self_if dvd_field_iff \n      is_unit_unit_factor leading_coeff_0_iff normalize_eq_0_iff normalize_idem)"], ["", "lemma smult_normalize_field_eq:\n  fixes p::\"'a::{field,semidom_divide_unit_factor} poly\"\n  shows \"p = smult (lead_coeff p) (normalize p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult (lead_coeff p) (normalize p)", "proof (rule poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (smult (lead_coeff p) (normalize p)) n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (smult (lead_coeff p) (normalize p)) n", "have \"unit_factor (lead_coeff p) = lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor (lead_coeff p) = lead_coeff p", "by (metis dvd_field_iff is_unit_unit_factor unit_factor_0)"], ["proof (state)\nthis:\n  unit_factor (lead_coeff p) = lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff p n = coeff (smult (lead_coeff p) (normalize p)) n", "then"], ["proof (chain)\npicking this:\n  unit_factor (lead_coeff p) = lead_coeff p", "show \"coeff p n = coeff (smult (lead_coeff p) (normalize p)) n\""], ["proof (prove)\nusing this:\n  unit_factor (lead_coeff p) = lead_coeff p\n\ngoal (1 subgoal):\n 1. coeff p n = coeff (smult (lead_coeff p) (normalize p)) n", "by simp"], ["proof (state)\nthis:\n  coeff p n = coeff (smult (lead_coeff p) (normalize p)) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_coeff_gcd_field:\n  fixes p q::\"'a::field_gcd poly\"\n  assumes \"p\\<noteq>0 \\<or> q\\<noteq>0\"\n  shows \"lead_coeff (gcd p q) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (gcd p q) = (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<or> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (gcd p q) = (1::'a)", "by (metis gcd.normalize_idem gcd_eq_0_iff lead_coeff_normalize_field)"], ["", "lemma poly_gcd_0_iff:\n  \"poly (gcd p q) x = 0 \\<longleftrightarrow> poly p x=0 \\<and> poly q x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (gcd p q) x = (0::'a)) =\n    (poly p x = (0::'a) \\<and> poly q x = (0::'a))", "by (simp add:poly_eq_0_iff_dvd)"], ["", "lemma degree_eq_oneE:\n  fixes p :: \"'a::zero poly\"\n  assumes \"degree p = 1\"\n  obtains a b where \"p = [:a,b:]\" \"b\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = [:a, b:]; b \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = [:a, b:]; b \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain a b q where p:\"p=pCons a (pCons b q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b q.\n        p = pCons a (pCons b q) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis pCons_cases)"], ["proof (state)\nthis:\n  p = pCons a (pCons b q)\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = [:a, b:]; b \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  degree p = 1\n  p = pCons a (pCons b q)", "have \"q=0\""], ["proof (prove)\nusing this:\n  degree p = 1\n  p = pCons a (pCons b q)\n\ngoal (1 subgoal):\n 1. q = 0", "by (cases \"q = 0\") simp_all"], ["proof (state)\nthis:\n  q = 0\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = [:a, b:]; b \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with p"], ["proof (chain)\npicking this:\n  p = pCons a (pCons b q)\n  q = 0", "have \"p=[:a,b:]\""], ["proof (prove)\nusing this:\n  p = pCons a (pCons b q)\n  q = 0\n\ngoal (1 subgoal):\n 1. p = [:a, b:]", "by auto"], ["proof (state)\nthis:\n  p = [:a, b:]\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = [:a, b:]; b \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  p = [:a, b:]\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = [:a, b:]; b \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  p = [:a, b:]", "have \"b\\<noteq>0\""], ["proof (prove)\nusing this:\n  p = [:a, b:]\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  p = [:a, b:]\n  degree p = 1\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = [:a, b:]; b \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  p = [:a, b:]\n  b \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  p = [:a, b:]\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>More results about sign variations (i.e. @{term changes}\\<close>"], ["", "lemma changes_0[simp]:\"changes (0#xs) = changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ((0::'a) # xs) = changes xs", "by (cases xs) auto"], ["", "lemma changes_Cons:\"changes (x#xs) = (if filter (\\<lambda>x. x\\<noteq>0) xs = [] then \n                            0 \n                          else if x* hd (filter (\\<lambda>x. x\\<noteq>0) xs) < 0 then \n                            1 + changes xs \n                          else changes xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (x # xs) =\n    (if filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] then 0\n     else if x * hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) xs) < (0::'a)\n          then 1 + changes xs else changes xs)", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. changes [x] =\n    (if filter (\\<lambda>x. x \\<noteq> (0::'a)) [] = [] then 0\n     else if x * hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) []) < (0::'a)\n          then 1 + changes [] else changes [])\n 2. \\<And>a xs.\n       changes (x # xs) =\n       (if filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] then 0\n        else if x * hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) xs)\n                < (0::'a)\n             then 1 + changes xs else changes xs) \\<Longrightarrow>\n       changes (x # a # xs) =\n       (if filter (\\<lambda>x. x \\<noteq> (0::'a)) (a # xs) = [] then 0\n        else if x * hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) (a # xs))\n                < (0::'a)\n             then 1 + changes (a # xs) else changes (a # xs))", "by auto"], ["", "lemma changes_filter_eq:\n  \"changes (filter (\\<lambda>x. x\\<noteq>0) xs) = changes xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (filter (\\<lambda>x. x \\<noteq> (0::'a)) xs) = changes xs", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. changes (filter (\\<lambda>x. x \\<noteq> (0::'a)) []) = changes []\n 2. \\<And>a xs.\n       changes (filter (\\<lambda>x. x \\<noteq> (0::'a)) xs) =\n       changes xs \\<Longrightarrow>\n       changes (filter (\\<lambda>x. x \\<noteq> (0::'a)) (a # xs)) =\n       changes (a # xs)", "by (auto simp add:changes_Cons)"], ["", "lemma changes_filter_empty:\n  assumes \"filter (\\<lambda>x. x\\<noteq>0) xs = []\"\n  shows \"changes xs = 0\" \"changes (a#xs) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes xs = 0 &&& changes (a # xs) = 0", "using assms"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = []\n\ngoal (1 subgoal):\n 1. changes xs = 0 &&& changes (a # xs) = 0", "apply (induct xs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) [] = [] \\<Longrightarrow>\n    changes [] = 0\n 2. filter (\\<lambda>x. x \\<noteq> (0::'a)) [] = [] \\<Longrightarrow>\n    changes [a] = 0\n 3. \\<And>aa xs.\n       \\<lbrakk>filter (\\<lambda>x. x \\<noteq> (0::'a)) xs =\n                [] \\<Longrightarrow>\n                changes xs = 0;\n        filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] \\<Longrightarrow>\n        changes (a # xs) = 0;\n        filter (\\<lambda>x. x \\<noteq> (0::'a)) (aa # xs) = []\\<rbrakk>\n       \\<Longrightarrow> changes (aa # xs) = 0\n 4. \\<And>aa xs.\n       \\<lbrakk>filter (\\<lambda>x. x \\<noteq> (0::'a)) xs =\n                [] \\<Longrightarrow>\n                changes xs = 0;\n        filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] \\<Longrightarrow>\n        changes (a # xs) = 0;\n        filter (\\<lambda>x. x \\<noteq> (0::'a)) (aa # xs) = []\\<rbrakk>\n       \\<Longrightarrow> changes (a # aa # xs) = 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>filter (\\<lambda>x. x \\<noteq> (0::'a)) xs =\n                [] \\<Longrightarrow>\n                changes xs = 0;\n        filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] \\<Longrightarrow>\n        changes (a # xs) = 0;\n        (if aa \\<noteq> (0::'a)\n         then aa # filter (\\<lambda>x. x \\<noteq> (0::'a)) xs\n         else filter (\\<lambda>x. x \\<noteq> (0::'a)) xs) =\n        []\\<rbrakk>\n       \\<Longrightarrow> changes (aa # xs) = 0", "by (metis changes_0 neq_Nil_conv)"], ["", "lemma changes_append:\n  assumes \"xs\\<noteq> [] \\<and> ys\\<noteq> [] \\<longrightarrow> (last xs = hd ys \\<and> last xs\\<noteq>0)\"\n  shows \"changes (xs@ys) = changes xs + changes ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (xs @ ys) = changes xs + changes ys", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last xs = hd ys \\<and> last xs \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. changes (xs @ ys) = changes xs + changes ys", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n    last [] = hd ys \\<and> last [] \\<noteq> (0::'a) \\<Longrightarrow>\n    changes ([] @ ys) = changes [] + changes ys\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n                last xs = hd ys \\<and>\n                last xs \\<noteq> (0::'a) \\<Longrightarrow>\n                changes (xs @ ys) = changes xs + changes ys;\n        a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes (a # xs) + changes ys", "case Nil"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last [] = hd ys \\<and> last [] \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n    last [] = hd ys \\<and> last [] \\<noteq> (0::'a) \\<Longrightarrow>\n    changes ([] @ ys) = changes [] + changes ys\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n                last xs = hd ys \\<and>\n                last xs \\<noteq> (0::'a) \\<Longrightarrow>\n                changes (xs @ ys) = changes xs + changes ys;\n        a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes (a # xs) + changes ys", "then"], ["proof (chain)\npicking this:\n  [] \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last [] = hd ys \\<and> last [] \\<noteq> (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last [] = hd ys \\<and> last [] \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. changes ([] @ ys) = changes [] + changes ys", "by simp"], ["proof (state)\nthis:\n  changes ([] @ ys) = changes [] + changes ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n                last xs = hd ys \\<and>\n                last xs \\<noteq> (0::'a) \\<Longrightarrow>\n                changes (xs @ ys) = changes xs + changes ys;\n        a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes (a # xs) + changes ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n                last xs = hd ys \\<and>\n                last xs \\<noteq> (0::'a) \\<Longrightarrow>\n                changes (xs @ ys) = changes xs + changes ys;\n        a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes (a # xs) + changes ys", "case (Cons a xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last xs = hd ys \\<and> last xs \\<noteq> (0::'a) \\<Longrightarrow>\n  changes (xs @ ys) = changes xs + changes ys\n  a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n                last xs = hd ys \\<and>\n                last xs \\<noteq> (0::'a) \\<Longrightarrow>\n                changes (xs @ ys) = changes xs + changes ys;\n        a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes (a # xs) + changes ys", "have ?case when \"xs=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes (a # xs) + changes ys", "using that Cons"], ["proof (prove)\nusing this:\n  xs = []\n  xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last xs = hd ys \\<and> last xs \\<noteq> (0::'a) \\<Longrightarrow>\n  changes (xs @ ys) = changes xs + changes ys\n  a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes (a # xs) + changes ys", "apply (cases ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = [];\n     xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n     last xs = hd ys \\<and> last xs \\<noteq> (0::'a) \\<Longrightarrow>\n     changes (xs @ ys) = changes xs + changes ys;\n     a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n     last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a);\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> changes ((a # xs) @ ys) =\n                      changes (a # xs) + changes ys\n 2. \\<And>aa list.\n       \\<lbrakk>xs = [];\n        xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last xs = hd ys \\<and> last xs \\<noteq> (0::'a) \\<Longrightarrow>\n        changes (xs @ ys) = changes xs + changes ys;\n        a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a);\n        ys = aa # list\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes (a # xs) + changes ys", "by auto"], ["proof (state)\nthis:\n  xs = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n                last xs = hd ys \\<and>\n                last xs \\<noteq> (0::'a) \\<Longrightarrow>\n                changes (xs @ ys) = changes xs + changes ys;\n        a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes (a # xs) + changes ys", "moreover"], ["proof (state)\nthis:\n  xs = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n                last xs = hd ys \\<and>\n                last xs \\<noteq> (0::'a) \\<Longrightarrow>\n                changes (xs @ ys) = changes xs + changes ys;\n        a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes (a # xs) + changes ys", "have ?case when \"ys=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes (a # xs) + changes ys", "using that Cons"], ["proof (prove)\nusing this:\n  ys = []\n  xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last xs = hd ys \\<and> last xs \\<noteq> (0::'a) \\<Longrightarrow>\n  changes (xs @ ys) = changes xs + changes ys\n  a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes (a # xs) + changes ys", "by auto"], ["proof (state)\nthis:\n  ys = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n                last xs = hd ys \\<and>\n                last xs \\<noteq> (0::'a) \\<Longrightarrow>\n                changes (xs @ ys) = changes xs + changes ys;\n        a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes (a # xs) + changes ys", "moreover"], ["proof (state)\nthis:\n  ys = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n                last xs = hd ys \\<and>\n                last xs \\<noteq> (0::'a) \\<Longrightarrow>\n                changes (xs @ ys) = changes xs + changes ys;\n        a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes (a # xs) + changes ys", "have ?case when \"xs\\<noteq>[]\" \"ys\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes (a # xs) + changes ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes (a # xs) + changes ys", "have \"filter (\\<lambda>x. x \\<noteq> 0) xs \\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> []", "using that Cons"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last xs = hd ys \\<and> last xs \\<noteq> (0::'a) \\<Longrightarrow>\n  changes (xs @ ys) = changes xs + changes ys\n  a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; ys \\<noteq> [];\n     changes (xs @ ys) = changes xs + changes ys; last xs = hd ys;\n     hd ys \\<noteq> (0::'a);\n     filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = []\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis (mono_tags, lifting) filter.simps(1) filter.simps(2) filter_append snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes (a # xs) + changes ys", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> []", "have \"changes (a # xs @ ys) = changes (a # xs) + changes ys\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. changes (a # xs @ ys) = changes (a # xs) + changes ys", "apply (subst (1 2) changes_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> [] \\<Longrightarrow>\n    (if filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ ys) = [] then 0\n     else if a * hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ ys))\n             < (0::'a)\n          then 1 + changes (xs @ ys) else changes (xs @ ys)) =\n    (if filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] then 0\n     else if a * hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) xs) < (0::'a)\n          then 1 + changes xs else changes xs) +\n    changes ys", "using that Cons"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last xs = hd ys \\<and> last xs \\<noteq> (0::'a) \\<Longrightarrow>\n  changes (xs @ ys) = changes xs + changes ys\n  a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n  last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> [] \\<Longrightarrow>\n    (if filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ ys) = [] then 0\n     else if a * hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ ys))\n             < (0::'a)\n          then 1 + changes (xs @ ys) else changes (xs @ ys)) =\n    (if filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] then 0\n     else if a * hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) xs) < (0::'a)\n          then 1 + changes xs else changes xs) +\n    changes ys", "by auto"], ["proof (state)\nthis:\n  changes (a # xs @ ys) = changes (a # xs) + changes ys\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes (a # xs) + changes ys", "then"], ["proof (chain)\npicking this:\n  changes (a # xs @ ys) = changes (a # xs) + changes ys", "show ?thesis"], ["proof (prove)\nusing this:\n  changes (a # xs @ ys) = changes (a # xs) + changes ys\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes (a # xs) + changes ys", "by auto"], ["proof (state)\nthis:\n  changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n                last xs = hd ys \\<and>\n                last xs \\<noteq> (0::'a) \\<Longrightarrow>\n                changes (xs @ ys) = changes xs + changes ys;\n        a # xs \\<noteq> [] \\<and> ys \\<noteq> [] \\<longrightarrow>\n        last (a # xs) = hd ys \\<and> last (a # xs) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes (a # xs) + changes ys", "ultimately"], ["proof (chain)\npicking this:\n  xs = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n  ys = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n  \\<lbrakk>xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> changes ((a # xs) @ ys) = changes (a # xs) + changes ys", "show ?case"], ["proof (prove)\nusing this:\n  xs = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n  ys = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n  \\<lbrakk>xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes (a # xs) + changes ys", "by blast"], ["proof (state)\nthis:\n  changes ((a # xs) @ ys) = changes (a # xs) + changes ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma changes_drop_dup:\n  assumes \"xs\\<noteq> []\" \"ys\\<noteq> [] \\<longrightarrow> last xs=hd ys\"\n  shows \"changes (xs@ys) = changes (xs@ tl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (xs @ ys) = changes (xs @ tl ys)", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\n\ngoal (1 subgoal):\n 1. changes (xs @ ys) = changes (xs @ tl ys)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> [];\n     ys \\<noteq> [] \\<longrightarrow> last [] = hd ys\\<rbrakk>\n    \\<Longrightarrow> changes ([] @ ys) = changes ([] @ tl ys)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> [];\n                 ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n                \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys);\n        a # xs \\<noteq> [];\n        ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes ((a # xs) @ tl ys)", "case Nil"], ["proof (state)\nthis:\n  [] \\<noteq> []\n  ys \\<noteq> [] \\<longrightarrow> last [] = hd ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> [];\n     ys \\<noteq> [] \\<longrightarrow> last [] = hd ys\\<rbrakk>\n    \\<Longrightarrow> changes ([] @ ys) = changes ([] @ tl ys)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> [];\n                 ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n                \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys);\n        a # xs \\<noteq> [];\n        ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes ((a # xs) @ tl ys)", "then"], ["proof (chain)\npicking this:\n  [] \\<noteq> []\n  ys \\<noteq> [] \\<longrightarrow> last [] = hd ys", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<noteq> []\n  ys \\<noteq> [] \\<longrightarrow> last [] = hd ys\n\ngoal (1 subgoal):\n 1. changes ([] @ ys) = changes ([] @ tl ys)", "by simp"], ["proof (state)\nthis:\n  changes ([] @ ys) = changes ([] @ tl ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> [];\n                 ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n                \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys);\n        a # xs \\<noteq> [];\n        ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes ((a # xs) @ tl ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> [];\n                 ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n                \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys);\n        a # xs \\<noteq> [];\n        ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes ((a # xs) @ tl ys)", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>xs \\<noteq> [];\n   ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n  \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys)\n  a # xs \\<noteq> []\n  ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> [];\n                 ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n                \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys);\n        a # xs \\<noteq> [];\n        ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes ((a # xs) @ tl ys)", "have ?case when \"ys=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "using that"], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "by simp"], ["proof (state)\nthis:\n  ys = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> [];\n                 ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n                \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys);\n        a # xs \\<noteq> [];\n        ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes ((a # xs) @ tl ys)", "moreover"], ["proof (state)\nthis:\n  ys = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> [];\n                 ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n                \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys);\n        a # xs \\<noteq> [];\n        ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes ((a # xs) @ tl ys)", "have ?case when \"ys\\<noteq>[]\" \"xs=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "using that Cons"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  xs = []\n  \\<lbrakk>xs \\<noteq> [];\n   ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n  \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys)\n  a # xs \\<noteq> []\n  ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys \\<noteq> []; xs = []; a = hd ys\\<rbrakk>\n    \\<Longrightarrow> changes (hd ys # ys) = changes ys", "by (metis changes.simps(3) list.exhaust_sel not_square_less_zero)"], ["proof (state)\nthis:\n  \\<lbrakk>ys \\<noteq> []; xs = []\\<rbrakk>\n  \\<Longrightarrow> changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> [];\n                 ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n                \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys);\n        a # xs \\<noteq> [];\n        ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes ((a # xs) @ tl ys)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>ys \\<noteq> []; xs = []\\<rbrakk>\n  \\<Longrightarrow> changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> [];\n                 ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n                \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys);\n        a # xs \\<noteq> [];\n        ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes ((a # xs) @ tl ys)", "have ?case when \"ys\\<noteq>[]\" \"xs\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "define ts ts' where \"ts = filter (\\<lambda>x. x \\<noteq> 0) (xs @ ys)\"\n      and \"ts' = filter (\\<lambda>x. x \\<noteq> 0) (xs @ tl ys)\""], ["proof (state)\nthis:\n  ts = filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ ys)\n  ts' = filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ tl ys)\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "have \"(ts = [] \\<longleftrightarrow> ts' = []) \\<and> hd ts = hd ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ts = []) = (ts' = []) \\<and> hd ts = hd ts'", "proof (cases \"filter (\\<lambda>x. x \\<noteq> 0) xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'\n 2. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'", "case True"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = []\n\ngoal (2 subgoals):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'\n 2. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = []", "have \"last xs = 0\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = []\n\ngoal (1 subgoal):\n 1. last xs = (0::'a)", "using \\<open>xs\\<noteq>[]\\<close>"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = []\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. last xs = (0::'a)", "by (metis (mono_tags, lifting) append_butlast_last_id append_is_Nil_conv \n            filter.simps(2) filter_append list.simps(3))"], ["proof (state)\nthis:\n  last xs = (0::'a)\n\ngoal (2 subgoals):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'\n 2. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'", "then"], ["proof (chain)\npicking this:\n  last xs = (0::'a)", "have \"hd ys=0\""], ["proof (prove)\nusing this:\n  last xs = (0::'a)\n\ngoal (1 subgoal):\n 1. hd ys = (0::'a)", "using Cons(3)[rule_format, OF \\<open>ys\\<noteq>[]\\<close>] \\<open>xs\\<noteq>[]\\<close>"], ["proof (prove)\nusing this:\n  last xs = (0::'a)\n  last (a # xs) = hd ys\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd ys = (0::'a)", "by auto"], ["proof (state)\nthis:\n  hd ys = (0::'a)\n\ngoal (2 subgoals):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'\n 2. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'", "then"], ["proof (chain)\npicking this:\n  hd ys = (0::'a)", "have \"filter (\\<lambda>x. x \\<noteq> 0) ys = filter (\\<lambda>x. x \\<noteq> 0) (tl ys)\""], ["proof (prove)\nusing this:\n  hd ys = (0::'a)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) ys =\n    filter (\\<lambda>x. x \\<noteq> (0::'a)) (tl ys)", "by (metis (mono_tags, lifting) filter.simps(2) list.exhaust_sel that(1))"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) ys =\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) (tl ys)\n\ngoal (2 subgoals):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs = [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'\n 2. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) ys =\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) (tl ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) ys =\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) (tl ys)\n\ngoal (1 subgoal):\n 1. (ts = []) = (ts' = []) \\<and> hd ts = hd ts'", "unfolding ts_def ts'_def"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) ys =\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) (tl ys)\n\ngoal (1 subgoal):\n 1. (filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ ys) = []) =\n    (filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ tl ys) = []) \\<and>\n    hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ ys)) =\n    hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ tl ys))", "by auto"], ["proof (state)\nthis:\n  (ts = []) = (ts' = []) \\<and> hd ts = hd ts'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'", "case False"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> [] \\<Longrightarrow>\n    (ts = []) = (ts' = []) \\<and> hd ts = hd ts'", "then"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (ts = []) = (ts' = []) \\<and> hd ts = hd ts'", "unfolding ts_def ts'_def"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> (0::'a)) xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ ys) = []) =\n    (filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ tl ys) = []) \\<and>\n    hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ ys)) =\n    hd (filter (\\<lambda>x. x \\<noteq> (0::'a)) (xs @ tl ys))", "by auto"], ["proof (state)\nthis:\n  (ts = []) = (ts' = []) \\<and> hd ts = hd ts'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ts = []) = (ts' = []) \\<and> hd ts = hd ts'\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "moreover"], ["proof (state)\nthis:\n  (ts = []) = (ts' = []) \\<and> hd ts = hd ts'\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "have \"changes (xs @ ys) = changes (xs @ tl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (xs @ ys) = changes (xs @ tl ys)", "apply (rule Cons(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs \\<noteq> []\n 2. ys \\<noteq> [] \\<longrightarrow> last xs = hd ys", "using that Cons(3)"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  xs \\<noteq> []\n  ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\n\ngoal (2 subgoals):\n 1. xs \\<noteq> []\n 2. ys \\<noteq> [] \\<longrightarrow> last xs = hd ys", "by auto"], ["proof (state)\nthis:\n  changes (xs @ ys) = changes (xs @ tl ys)\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "moreover"], ["proof (state)\nthis:\n  changes (xs @ ys) = changes (xs @ tl ys)\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "have \"changes (a # xs @ ys) = (if ts = [] then 0 else if a * hd ts < 0 \n            then 1 + changes (xs @ ys) else changes (xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (a # xs @ ys) =\n    (if ts = [] then 0\n     else if a * hd ts < (0::'a) then 1 + changes (xs @ ys)\n          else changes (xs @ ys))", "using changes_Cons[of a \"xs @ ys\",folded ts_def]"], ["proof (prove)\nusing this:\n  changes (a # xs @ ys) =\n  (if ts = [] then 0\n   else if a * hd ts < (0::'a) then 1 + changes (xs @ ys)\n        else changes (xs @ ys))\n\ngoal (1 subgoal):\n 1. changes (a # xs @ ys) =\n    (if ts = [] then 0\n     else if a * hd ts < (0::'a) then 1 + changes (xs @ ys)\n          else changes (xs @ ys))", "."], ["proof (state)\nthis:\n  changes (a # xs @ ys) =\n  (if ts = [] then 0\n   else if a * hd ts < (0::'a) then 1 + changes (xs @ ys)\n        else changes (xs @ ys))\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "moreover"], ["proof (state)\nthis:\n  changes (a # xs @ ys) =\n  (if ts = [] then 0\n   else if a * hd ts < (0::'a) then 1 + changes (xs @ ys)\n        else changes (xs @ ys))\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "have \"changes (a # xs @ tl ys) = (if ts' = [] then 0 else if a * hd ts' < 0 \n            then 1 + changes (xs @ tl ys) else changes (xs @ tl ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (a # xs @ tl ys) =\n    (if ts' = [] then 0\n     else if a * hd ts' < (0::'a) then 1 + changes (xs @ tl ys)\n          else changes (xs @ tl ys))", "using changes_Cons[of a \"xs @ tl ys\",folded ts'_def]"], ["proof (prove)\nusing this:\n  changes (a # xs @ tl ys) =\n  (if ts' = [] then 0\n   else if a * hd ts' < (0::'a) then 1 + changes (xs @ tl ys)\n        else changes (xs @ tl ys))\n\ngoal (1 subgoal):\n 1. changes (a # xs @ tl ys) =\n    (if ts' = [] then 0\n     else if a * hd ts' < (0::'a) then 1 + changes (xs @ tl ys)\n          else changes (xs @ tl ys))", "."], ["proof (state)\nthis:\n  changes (a # xs @ tl ys) =\n  (if ts' = [] then 0\n   else if a * hd ts' < (0::'a) then 1 + changes (xs @ tl ys)\n        else changes (xs @ tl ys))\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "ultimately"], ["proof (chain)\npicking this:\n  (ts = []) = (ts' = []) \\<and> hd ts = hd ts'\n  changes (xs @ ys) = changes (xs @ tl ys)\n  changes (a # xs @ ys) =\n  (if ts = [] then 0\n   else if a * hd ts < (0::'a) then 1 + changes (xs @ ys)\n        else changes (xs @ ys))\n  changes (a # xs @ tl ys) =\n  (if ts' = [] then 0\n   else if a * hd ts' < (0::'a) then 1 + changes (xs @ tl ys)\n        else changes (xs @ tl ys))", "show ?thesis"], ["proof (prove)\nusing this:\n  (ts = []) = (ts' = []) \\<and> hd ts = hd ts'\n  changes (xs @ ys) = changes (xs @ tl ys)\n  changes (a # xs @ ys) =\n  (if ts = [] then 0\n   else if a * hd ts < (0::'a) then 1 + changes (xs @ ys)\n        else changes (xs @ ys))\n  changes (a # xs @ tl ys) =\n  (if ts' = [] then 0\n   else if a * hd ts' < (0::'a) then 1 + changes (xs @ tl ys)\n        else changes (xs @ tl ys))\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "by auto"], ["proof (state)\nthis:\n  changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>ys \\<noteq> []; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>xs \\<noteq> [];\n                 ys \\<noteq> [] \\<longrightarrow> last xs = hd ys\\<rbrakk>\n                \\<Longrightarrow> changes (xs @ ys) = changes (xs @ tl ys);\n        a # xs \\<noteq> [];\n        ys \\<noteq> [] \\<longrightarrow> last (a # xs) = hd ys\\<rbrakk>\n       \\<Longrightarrow> changes ((a # xs) @ ys) =\n                         changes ((a # xs) @ tl ys)", "ultimately"], ["proof (chain)\npicking this:\n  ys = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n  \\<lbrakk>ys \\<noteq> []; xs = []\\<rbrakk>\n  \\<Longrightarrow> changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n  \\<lbrakk>ys \\<noteq> []; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "show ?case"], ["proof (prove)\nusing this:\n  ys = [] \\<Longrightarrow>\n  changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n  \\<lbrakk>ys \\<noteq> []; xs = []\\<rbrakk>\n  \\<Longrightarrow> changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n  \\<lbrakk>ys \\<noteq> []; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n\ngoal (1 subgoal):\n 1. changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)", "by blast"], ["proof (state)\nthis:\n  changes ((a # xs) @ ys) = changes ((a # xs) @ tl ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\n  TODO: the following lemmas contain duplicates of some lemmas in \n          Winding_Number_Eval/Missing_Algebraic.thy\n  Will resolve later.  \n*)"], ["", "lemma Im_poly_of_real:\n  \"Im (poly p (of_real x)) = poly (map_poly Im p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (poly p (complex_of_real x)) = poly (map_poly Im p) x", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Im (poly 0 (complex_of_real x)) = poly (map_poly Im 0) x\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        Im (poly p (complex_of_real x)) = poly (map_poly Im p) x\\<rbrakk>\n       \\<Longrightarrow> Im (poly (pCons a p) (complex_of_real x)) =\n                         poly (map_poly Im (pCons a p)) x", "by (auto simp add:map_poly_pCons)"], ["", "lemma Re_poly_of_real:\n  \"Re (poly p (of_real x)) = poly (map_poly Re p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (poly p (complex_of_real x)) = poly (map_poly Re p) x", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Re (poly 0 (complex_of_real x)) = poly (map_poly Re 0) x\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        Re (poly p (complex_of_real x)) = poly (map_poly Re p) x\\<rbrakk>\n       \\<Longrightarrow> Re (poly (pCons a p) (complex_of_real x)) =\n                         poly (map_poly Re (pCons a p)) x", "by (auto simp add:map_poly_pCons)"], ["", "subsection \\<open>More about @{term map_poly} and @{term of_real}\\<close>"], ["", "lemma of_real_poly_map_pCons[simp]:\"map_poly of_real (pCons a p) = pCons (of_real a) (map_poly of_real p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly of_real (pCons a p) = pCons (of_real a) (map_poly of_real p)", "by (simp add: map_poly_pCons)"], ["", "lemma of_real_poly_map_plus[simp]: \"map_poly of_real (p + q) = map_poly of_real p +  map_poly of_real q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly of_real (p + q) = map_poly of_real p + map_poly of_real q", "apply (rule poly_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff (map_poly of_real (p + q)) n =\n       coeff (map_poly of_real p + map_poly of_real q) n", "by (auto simp add: coeff_map_poly)"], ["", "lemma of_real_poly_map_smult[simp]:\"map_poly of_real (smult s p) = smult (of_real s) (map_poly of_real p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly of_real (smult s p) = smult (of_real s) (map_poly of_real p)", "apply (rule poly_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       coeff (map_poly of_real (smult s p)) n =\n       coeff (smult (of_real s) (map_poly of_real p)) n", "by (auto simp add: coeff_map_poly)"], ["", "lemma of_real_poly_map_mult[simp]:\"map_poly of_real (p*q) = map_poly of_real p * map_poly of_real q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly of_real (p * q) = map_poly of_real p * map_poly of_real q", "by (induct p,intro poly_eqI,auto)"], ["", "lemma of_real_poly_map_poly:\n  \"of_real (poly p x) = poly (map_poly of_real p) (of_real x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real (poly p x) = poly (map_poly of_real p) (of_real x)", "by (induct p,auto)"], ["", "lemma of_real_poly_map_power:\"map_poly of_real (p^n) = (map_poly of_real p) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly of_real (p ^ n) = map_poly of_real p ^ n", "by (induct n,auto)"], ["", "(*FIXME: not duplicate*)"], ["", "lemma of_real_poly_eq_iff [simp]: \"map_poly of_real p = map_poly of_real q \\<longleftrightarrow> p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_poly of_real p = map_poly of_real q) = (p = q)", "by (auto simp: poly_eq_iff coeff_map_poly)"], ["", "(*FIXME: not duplicate*)"], ["", "lemma of_real_poly_eq_0_iff [simp]: \"map_poly of_real p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_poly of_real p = 0) = (p = 0)", "by (auto simp: poly_eq_iff coeff_map_poly)"], ["", "subsection \\<open>More about @{term order}\\<close>"], ["", "lemma order_multiplicity_eq:\n  assumes \"p\\<noteq>0\"\n  shows \"order a p = multiplicity [:-a,1:] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a p = multiplicity [:- a, 1::'a:] p", "by (metis assms multiplicity_eqI order_1 order_2)"], ["", "lemma order_gcd:\n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"order x (gcd p q) = min (order x p) (order x q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "have \"prime [:- x, 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime [:- x, 1::'a:]", "apply (auto simp add: prime_elem_linear_poly normalize_poly_def  intro!:primeI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] div [:1::'a:] = [:- x, 1::'a:]", "by (simp add: pCons_one)"], ["proof (state)\nthis:\n  prime [:- x, 1::'a:]\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "then"], ["proof (chain)\npicking this:\n  prime [:- x, 1::'a:]", "show ?thesis"], ["proof (prove)\nusing this:\n  prime [:- x, 1::'a:]\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "using assms"], ["proof (prove)\nusing this:\n  prime [:- x, 1::'a:]\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x (gcd p q) = min (order x p) (order x q)", "by (auto simp add:order_multiplicity_eq intro:multiplicity_gcd)"], ["proof (state)\nthis:\n  order x (gcd p q) = min (order x p) (order x q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_linear[simp]: \"order x [:-a,1:] = (if x=a then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x [:- a, 1::'a:] = (if x = a then 1 else 0)", "by (auto simp add:order_power_n_n[where n=1,simplified] order_0I)"], ["", "lemma map_poly_order_of_real:\n  assumes \"p\\<noteq>0\"\n  shows \"order (of_real t) (map_poly of_real p) = order t p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (of_real t) (map_poly of_real p) = order t p", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order (of_real t) (map_poly of_real p) = order t p", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    order (of_real t) (map_poly of_real 0) = order t 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t) (map_poly of_real p) = order t p\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "case 0"], ["proof (state)\nthis:\n  0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    order (of_real t) (map_poly of_real 0) = order t 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t) (map_poly of_real p) = order t p\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order (of_real t) (map_poly of_real 0) = order t 0", "by simp"], ["proof (state)\nthis:\n  order (of_real t) (map_poly of_real 0) = order t 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t) (map_poly of_real p) = order t p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t) (map_poly of_real p) = order t p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t) (map_poly of_real p) = order t p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "then"], ["proof (chain)\npicking this:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0", "have \"order t p = 0\""], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order t p = 0", "using order_root"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. order t p = 0", "by blast"], ["proof (state)\nthis:\n  order t p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t) (map_poly of_real p) = order t p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "moreover"], ["proof (state)\nthis:\n  order t p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t) (map_poly of_real p) = order t p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "have \"poly (map_poly of_real p) (of_real x) \\<noteq>0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly of_real p) (of_real x) \\<noteq> (0::'b)", "apply (subst of_real_poly_map_poly[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real (poly p x) \\<noteq> (0::'b)", "using no_proots order_root"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. of_real (poly p x) \\<noteq> (0::'b)", "by simp"], ["proof (state)\nthis:\n  poly (map_poly of_real p) (of_real ?x1) \\<noteq> (0::?'b2)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t) (map_poly of_real p) = order t p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "then"], ["proof (chain)\npicking this:\n  poly (map_poly of_real p) (of_real ?x1) \\<noteq> (0::?'b2)", "have \"order (of_real t) (map_poly of_real p) = 0\""], ["proof (prove)\nusing this:\n  poly (map_poly of_real p) (of_real ?x1) \\<noteq> (0::?'b2)\n\ngoal (1 subgoal):\n 1. order (of_real t) (map_poly of_real p) = 0", "using order_root"], ["proof (prove)\nusing this:\n  poly (map_poly of_real p) (of_real ?x1) \\<noteq> (0::?'b2)\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. order (of_real t) (map_poly of_real p) = 0", "by blast"], ["proof (state)\nthis:\n  order (of_real t) (map_poly of_real p) = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t) (map_poly of_real p) = order t p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "ultimately"], ["proof (chain)\npicking this:\n  order t p = 0\n  order (of_real t) (map_poly of_real p) = 0", "show ?case"], ["proof (prove)\nusing this:\n  order t p = 0\n  order (of_real t) (map_poly of_real p) = 0\n\ngoal (1 subgoal):\n 1. order (of_real t) (map_poly of_real p) = order t p", "by auto"], ["proof (state)\nthis:\n  order (of_real t) (map_poly of_real p) = order t p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "case (root a p)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  order (of_real t) (map_poly of_real p) = order t p\n  [:- a, 1:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "define a1 where \"a1=[:-a,1:]\""], ["proof (state)\nthis:\n  a1 = [:- a, 1:]\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "have [simp]:\"a1\\<noteq>0\" \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a1 \\<noteq> 0 &&& p \\<noteq> 0", "unfolding a1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- a, 1:] \\<noteq> 0 &&& p \\<noteq> 0", "using root(2)"], ["proof (prove)\nusing this:\n  [:- a, 1:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:- a, 1:] \\<noteq> 0 &&& p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a1 \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "have \"order (of_real t) (map_poly of_real a1) = order t a1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (of_real t) (map_poly of_real a1) = order t a1", "unfolding a1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order (of_real t) (map_poly of_real [:- a, 1:]) = order t [:- a, 1:]", "by simp"], ["proof (state)\nthis:\n  order (of_real t) (map_poly of_real a1) = order t a1\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                order (of_real t) (map_poly of_real p) = order t p;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order (of_real t)\n                          (map_poly of_real ([:- a, 1:] * p)) =\n                         order t ([:- a, 1:] * p)", "then"], ["proof (chain)\npicking this:\n  order (of_real t) (map_poly of_real a1) = order t a1", "show ?case"], ["proof (prove)\nusing this:\n  order (of_real t) (map_poly of_real a1) = order t a1\n\ngoal (1 subgoal):\n 1. order (of_real t) (map_poly of_real ([:- a, 1:] * p)) =\n    order t ([:- a, 1:] * p)", "apply (fold a1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. order (of_real t) (map_poly of_real a1) = order t a1 \\<Longrightarrow>\n    order (of_real t) (map_poly of_real (a1 * p)) = order t (a1 * p)", "by (simp add:order_mult root)"], ["proof (state)\nthis:\n  order (of_real t) (map_poly of_real ([:- a, 1:] * p)) =\n  order t ([:- a, 1:] * p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_pcompose:\n  assumes \"pcompose p q\\<noteq>0\"\n  shows \"order x (pcompose p q) = order x (q-[:poly q x:]) * order (poly q x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (p \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * order (poly q x) p", "using \\<open>pcompose p q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x (p \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * order (poly q x) p", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n    order x (0 \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * order (poly q x) 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        p \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (p \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) * order (poly q x) p\n 3. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "case 0"], ["proof (state)\nthis:\n  0 \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n    order x (0 \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * order (poly q x) 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        p \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (p \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) * order (poly q x) p\n 3. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "then"], ["proof (chain)\npicking this:\n  0 \\<circ>\\<^sub>p q \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x (0 \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * order (poly q x) 0", "by simp"], ["proof (state)\nthis:\n  order x (0 \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        p \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (p \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) * order (poly q x) p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        p \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (p \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) * order (poly q x) p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        p \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (p \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) * order (poly q x) p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "have \"order x (p \\<circ>\\<^sub>p q) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (p \\<circ>\\<^sub>p q) = 0", "apply (rule order_0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (p \\<circ>\\<^sub>p q) x \\<noteq> (0::'a)", "using no_proots"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (p \\<circ>\\<^sub>p q) x \\<noteq> (0::'a)", "by (auto simp:poly_pcompose)"], ["proof (state)\nthis:\n  order x (p \\<circ>\\<^sub>p q) = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        p \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (p \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) * order (poly q x) p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "moreover"], ["proof (state)\nthis:\n  order x (p \\<circ>\\<^sub>p q) = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        p \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (p \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) * order (poly q x) p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "have \"order (poly q x) p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (poly q x) p = 0", "apply (rule order_0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (poly q x) \\<noteq> (0::'a)", "using no_proots"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p (poly q x) \\<noteq> (0::'a)", "by (auto simp:poly_pcompose)"], ["proof (state)\nthis:\n  order (poly q x) p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a);\n        p \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (p \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) * order (poly q x) p\n 2. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "ultimately"], ["proof (chain)\npicking this:\n  order x (p \\<circ>\\<^sub>p q) = 0\n  order (poly q x) p = 0", "show ?case"], ["proof (prove)\nusing this:\n  order x (p \\<circ>\\<^sub>p q) = 0\n  order (poly q x) p = 0\n\ngoal (1 subgoal):\n 1. order x (p \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * order (poly q x) p", "by auto"], ["proof (state)\nthis:\n  order x (p \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "case (root a p)"], ["proof (state)\nthis:\n  p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n  order x (p \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) p\n  ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "define a1 where \"a1=[:-a,1:]\""], ["proof (state)\nthis:\n  a1 = [:- a, 1::'a:]\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "have [simp]: \"a1\\<noteq>0\" \"p\\<noteq>0\" \"a1 \\<circ>\\<^sub>p q \\<noteq>0\" \"p \\<circ>\\<^sub>p q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a1 \\<noteq> 0 &&& p \\<noteq> 0) &&&\n    a1 \\<circ>\\<^sub>p q \\<noteq> 0 &&& p \\<circ>\\<^sub>p q \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a1 \\<noteq> 0", "using root(2)"], ["proof (prove)\nusing this:\n  ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a1 \\<noteq> 0", "unfolding a1_def"], ["proof (prove)\nusing this:\n  ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] \\<noteq> 0", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. p \\<noteq> 0\n 2. a1 \\<circ>\\<^sub>p q \\<noteq> 0\n 3. p \\<circ>\\<^sub>p q \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using root(2)"], ["proof (prove)\nusing this:\n  ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. a1 \\<circ>\\<^sub>p q \\<noteq> 0\n 2. p \\<circ>\\<^sub>p q \\<noteq> 0", "using root(2)"], ["proof (prove)\nusing this:\n  ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a1 \\<circ>\\<^sub>p q \\<noteq> 0\n 2. p \\<circ>\\<^sub>p q \\<noteq> 0", "by (fold a1_def,auto simp:pcompose_mult)"], ["proof (state)\nthis:\n  a1 \\<noteq> 0\n  p \\<noteq> 0\n  a1 \\<circ>\\<^sub>p q \\<noteq> 0\n  p \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "have \"order x ((a1 * p) \\<circ>\\<^sub>p q) = order x (a1  \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x ((a1 * p) \\<circ>\\<^sub>p q) =\n    order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)", "unfolding pcompose_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (a1 \\<circ>\\<^sub>p q * p \\<circ>\\<^sub>p q) =\n    order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)", "by (auto simp: order_mult)"], ["proof (state)\nthis:\n  order x ((a1 * p) \\<circ>\\<^sub>p q) =\n  order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "also"], ["proof (state)\nthis:\n  order x ((a1 * p) \\<circ>\\<^sub>p q) =\n  order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "have \"... = order x (q-[:poly q x:]) * (order (poly q x) a1 + order (poly q x) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * (order (poly q x) a1 + order (poly q x) p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * (order (poly q x) a1 + order (poly q x) p)", "have \"order x (a1  \\<circ>\\<^sub>p q) = order x (q-[:poly q x:]) * order (poly q x) a1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (a1 \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * order (poly q x) a1", "unfolding a1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x ([:- a, 1::'a:] \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * order (poly q x) [:- a, 1::'a:]", "apply (auto simp: pcompose_pCons algebra_simps diff_conv_add_uminus )"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly q x \\<noteq> a \\<Longrightarrow> order x (q + [:- a:]) = 0", "by (simp add: order_0I)"], ["proof (state)\nthis:\n  order x (a1 \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) a1\n\ngoal (1 subgoal):\n 1. order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * (order (poly q x) a1 + order (poly q x) p)", "moreover"], ["proof (state)\nthis:\n  order x (a1 \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) a1\n\ngoal (1 subgoal):\n 1. order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * (order (poly q x) a1 + order (poly q x) p)", "have \"order x (p \\<circ>\\<^sub>p q) = order x (q - [:poly q x:]) * order (poly q x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (p \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * order (poly q x) p", "apply (rule root.hyps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  order x (p \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) p\n\ngoal (1 subgoal):\n 1. order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * (order (poly q x) a1 + order (poly q x) p)", "ultimately"], ["proof (chain)\npicking this:\n  order x (a1 \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) a1\n  order x (p \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) p", "show ?thesis"], ["proof (prove)\nusing this:\n  order x (a1 \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) a1\n  order x (p \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) p\n\ngoal (1 subgoal):\n 1. order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * (order (poly q x) a1 + order (poly q x) p)", "by (auto simp:algebra_simps)"], ["proof (state)\nthis:\n  order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * (order (poly q x) a1 + order (poly q x) p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * (order (poly q x) a1 + order (poly q x) p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "also"], ["proof (state)\nthis:\n  order x (a1 \\<circ>\\<^sub>p q) + order x (p \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * (order (poly q x) a1 + order (poly q x) p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "have \"... =  order x (q - [:poly q x:]) * order (poly q x) (a1 * p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (q - [:poly q x:]) *\n    (order (poly q x) a1 + order (poly q x) p) =\n    order x (q - [:poly q x:]) * order (poly q x) (a1 * p)", "by (auto simp:order_mult)"], ["proof (state)\nthis:\n  order x (q - [:poly q x:]) * (order (poly q x) a1 + order (poly q x) p) =\n  order x (q - [:poly q x:]) * order (poly q x) (a1 * p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0 \\<Longrightarrow>\n                order x (p \\<circ>\\<^sub>p q) =\n                order x (q - [:poly q x:]) * order (poly q x) p;\n        ([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n                         order x (q - [:poly q x:]) *\n                         order (poly q x) ([:- a, 1::'a:] * p)", "finally"], ["proof (chain)\npicking this:\n  order x ((a1 * p) \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) (a1 * p)", "show ?case"], ["proof (prove)\nusing this:\n  order x ((a1 * p) \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) (a1 * p)\n\ngoal (1 subgoal):\n 1. order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * order (poly q x) ([:- a, 1::'a:] * p)", "unfolding a1_def"], ["proof (prove)\nusing this:\n  order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) ([:- a, 1::'a:] * p)\n\ngoal (1 subgoal):\n 1. order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n    order x (q - [:poly q x:]) * order (poly q x) ([:- a, 1::'a:] * p)", "."], ["proof (state)\nthis:\n  order x (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) =\n  order x (q - [:poly q x:]) * order (poly q x) ([:- a, 1::'a:] * p)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Polynomial roots / zeros\\<close>"], ["", "definition proots_within::\"'a::comm_semiring_0 poly \\<Rightarrow> 'a set \\<Rightarrow> 'a set\" where\n  \"proots_within p s = {x\\<in>s. poly p x=0}\""], ["", "abbreviation proots::\"'a::comm_semiring_0 poly \\<Rightarrow> 'a set\" where\n  \"proots p \\<equiv> proots_within p UNIV\""], ["", "lemma proots_def: \"proots p = {x. poly p x=0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots p = {x. poly p x = (0::'a)}", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> UNIV. poly p x = (0::'a)} = {x. poly p x = (0::'a)}", "by auto"], ["", "lemma proots_within_empty[simp]:\n  \"proots_within p {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p {} = {}", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> {}. poly p x = (0::'a)} = {}", "by auto"], ["", "lemma proots_within_0[simp]:\n  \"proots_within 0 s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within 0 s = s", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> s. poly 0 x = (0::'a)} = s", "by auto"], ["", "lemma proots_withinI[intro,simp]:\n  \"poly p x=0 \\<Longrightarrow> x\\<in>s \\<Longrightarrow> x\\<in>proots_within p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly p x = (0::'a); x \\<in> s\\<rbrakk>\n    \\<Longrightarrow> x \\<in> proots_within p s", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly p x = (0::'a); x \\<in> s\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {x \\<in> s. poly p x = (0::'a)}", "by auto"], ["", "lemma proots_within_iff[simp]:\n  \"x\\<in>proots_within p s \\<longleftrightarrow> poly p x=0 \\<and> x\\<in>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> proots_within p s) = (poly p x = (0::'a) \\<and> x \\<in> s)", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {x \\<in> s. poly p x = (0::'a)}) =\n    (poly p x = (0::'a) \\<and> x \\<in> s)", "by auto"], ["", "lemma proots_within_union:\n  \"proots_within p A \\<union> proots_within p B = proots_within p (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p A \\<union> proots_within p B =\n    proots_within p (A \\<union> B)", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> A. poly p x = (0::'a)} \\<union>\n    {x \\<in> B. poly p x = (0::'a)} =\n    {x \\<in> A \\<union> B. poly p x = (0::'a)}", "by auto"], ["", "lemma proots_within_times:\n  fixes s::\"'a::{semiring_no_zero_divisors,comm_semiring_0} set\"\n  shows \"proots_within (p*q) s = proots_within p s \\<union> proots_within q s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (p * q) s = proots_within p s \\<union> proots_within q s", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> s. poly (p * q) x = (0::'a)} =\n    {x \\<in> s. poly p x = (0::'a)} \\<union> {x \\<in> s. poly q x = (0::'a)}", "by auto"], ["", "lemma proots_within_gcd:\n  fixes s::\"'a::{factorial_ring_gcd,semiring_gcd_mult_normalize} set\"\n  shows \"proots_within (gcd p q) s= proots_within p s \\<inter> proots_within q s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (gcd p q) s = proots_within p s \\<inter> proots_within q s", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> s. poly (gcd p q) x = (0::'a)} =\n    {x \\<in> s. poly p x = (0::'a)} \\<inter> {x \\<in> s. poly q x = (0::'a)}", "by (auto simp add: poly_eq_0_iff_dvd)"], ["", "lemma proots_within_inter:\n  \"NO_MATCH UNIV s \\<Longrightarrow> proots_within p s = proots p \\<inter> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NO_MATCH UNIV s \\<Longrightarrow>\n    proots_within p s = proots p \\<inter> s", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. NO_MATCH UNIV s \\<Longrightarrow>\n    {x \\<in> s. poly p x = (0::'b)} =\n    {x \\<in> UNIV. poly p x = (0::'b)} \\<inter> s", "by auto"], ["", "lemma proots_within_proots[simp]:\n  \"proots_within p s \\<subseteq> proots p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p s \\<subseteq> proots p", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> s. poly p x = (0::'a)}\n    \\<subseteq> {x \\<in> UNIV. poly p x = (0::'a)}", "by auto"], ["", "lemma finite_proots[simp]: \n  fixes p :: \"'a::idom poly\"\n  shows \"p\\<noteq>0 \\<Longrightarrow> finite (proots_within p s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> finite (proots_within p s)", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> finite {x \\<in> s. poly p x = (0::'a)}", "using poly_roots_finite"], ["proof (prove)\nusing this:\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> finite {x \\<in> s. poly p x = (0::'a)}", "by fast"], ["", "lemma proots_within_pCons_1_iff:\n  fixes a::\"'a::idom\"\n  shows \"proots_within [:-a,1:] s = (if a\\<in>s then {a} else {})\"\n    \"proots_within [:a,-1:] s = (if a\\<in>s then {a} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within [:- a, 1::'a:] s = (if a \\<in> s then {a} else {}) &&&\n    proots_within [:a, - (1::'a):] s = (if a \\<in> s then {a} else {})", "by (cases \"a\\<in>s\",auto)"], ["", "lemma proots_within_uminus[simp]:\n  fixes p :: \"'a::comm_ring poly\"\n  shows \"proots_within (- p) s = proots_within p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (- p) s = proots_within p s", "by auto"], ["", "lemma proots_within_smult:\n  fixes a::\"'a::{semiring_no_zero_divisors,comm_semiring_0}\"\n  assumes \"a\\<noteq>0\"\n  shows \"proots_within (smult a p) s = proots_within p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (smult a p) s = proots_within p s", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> s. poly (smult a p) x = (0::'a)} =\n    {x \\<in> s. poly p x = (0::'a)}", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. {x \\<in> s. poly (smult a p) x = (0::'a)} =\n    {x \\<in> s. poly p x = (0::'a)}", "by auto"], ["", "subsection \\<open>Polynomial roots counting multiplicities.\\<close>"], ["", "(*counting the number of proots WITH MULTIPLICITIES within a set*)"], ["", "definition proots_count::\"'a::idom poly \\<Rightarrow> 'a set \\<Rightarrow> nat\" where\n  \"proots_count p s = (\\<Sum>r\\<in>proots_within p s. order r p)\""], ["", "lemma proots_count_emtpy[simp]:\"proots_count p {} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {} = 0", "unfolding proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p {}. order r p) = 0", "by auto"], ["", "lemma proots_count_times:\n  fixes s :: \"'a::idom set\"\n  assumes \"p*q\\<noteq>0\"\n  shows \"proots_count (p*q) s = proots_count p s + proots_count q s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (p * q) s = proots_count p s + proots_count q s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count (p * q) s = proots_count p s + proots_count q s", "define pts where \"pts=proots_within p s\""], ["proof (state)\nthis:\n  pts = proots_within p s\n\ngoal (1 subgoal):\n 1. proots_count (p * q) s = proots_count p s + proots_count q s", "define qts where \"qts=proots_within q s\""], ["proof (state)\nthis:\n  qts = proots_within q s\n\ngoal (1 subgoal):\n 1. proots_count (p * q) s = proots_count p s + proots_count q s", "have [simp]: \"finite pts\" \"finite qts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite pts &&& finite qts", "using \\<open>p*q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p * q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite pts &&& finite qts", "unfolding pts_def qts_def"], ["proof (prove)\nusing this:\n  p * q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (proots_within p s) &&& finite (proots_within q s)", "by auto"], ["proof (state)\nthis:\n  finite pts\n  finite qts\n\ngoal (1 subgoal):\n 1. proots_count (p * q) s = proots_count p s + proots_count q s", "have \"(\\<Sum>r\\<in>pts \\<union> qts. order r p) =  (\\<Sum>r\\<in>pts. order r p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>pts \\<union> qts. order r p) = (\\<Sum>r\\<in>pts. order r p)", "proof (rule comm_monoid_add_class.sum.mono_neutral_cong_right,simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>pts \\<union> qts - pts. order i p = 0", "show \"\\<forall>i\\<in>pts \\<union> qts - pts. order i p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>pts \\<union> qts - pts. order i p = 0", "unfolding pts_def qts_def proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x \\<in> s. poly p x = (0::'a)} \\<union>\n                   {x \\<in> s. poly q x = (0::'a)} -\n                   {x \\<in> s. poly p x = (0::'a)}.\n       order i p = 0", "using order_root"], ["proof (prove)\nusing this:\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x \\<in> s. poly p x = (0::'a)} \\<union>\n                   {x \\<in> s. poly q x = (0::'a)} -\n                   {x \\<in> s. poly p x = (0::'a)}.\n       order i p = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i\\<in>pts \\<union> qts - pts. order i p = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>pts \\<union> qts. order r p) = (\\<Sum>r\\<in>pts. order r p)\n\ngoal (1 subgoal):\n 1. proots_count (p * q) s = proots_count p s + proots_count q s", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>pts \\<union> qts. order r p) = (\\<Sum>r\\<in>pts. order r p)\n\ngoal (1 subgoal):\n 1. proots_count (p * q) s = proots_count p s + proots_count q s", "have \"(\\<Sum>r\\<in>pts \\<union> qts. order r q) = (\\<Sum>r\\<in>qts. order r q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>pts \\<union> qts. order r q) = (\\<Sum>r\\<in>qts. order r q)", "proof (rule comm_monoid_add_class.sum.mono_neutral_cong_right,simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>pts \\<union> qts - qts. order i q = 0", "show \"\\<forall>i\\<in>pts \\<union> qts - qts. order i q = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>pts \\<union> qts - qts. order i q = 0", "unfolding pts_def qts_def proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x \\<in> s. poly p x = (0::'a)} \\<union>\n                   {x \\<in> s. poly q x = (0::'a)} -\n                   {x \\<in> s. poly q x = (0::'a)}.\n       order i q = 0", "using order_root"], ["proof (prove)\nusing this:\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{x \\<in> s. poly p x = (0::'a)} \\<union>\n                   {x \\<in> s. poly q x = (0::'a)} -\n                   {x \\<in> s. poly q x = (0::'a)}.\n       order i q = 0", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i\\<in>pts \\<union> qts - qts. order i q = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>pts \\<union> qts. order r q) = (\\<Sum>r\\<in>qts. order r q)\n\ngoal (1 subgoal):\n 1. proots_count (p * q) s = proots_count p s + proots_count q s", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>r\\<in>pts \\<union> qts. order r p) = (\\<Sum>r\\<in>pts. order r p)\n  (\\<Sum>r\\<in>pts \\<union> qts. order r q) = (\\<Sum>r\\<in>qts. order r q)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>r\\<in>pts \\<union> qts. order r p) = (\\<Sum>r\\<in>pts. order r p)\n  (\\<Sum>r\\<in>pts \\<union> qts. order r q) = (\\<Sum>r\\<in>qts. order r q)\n\ngoal (1 subgoal):\n 1. proots_count (p * q) s = proots_count p s + proots_count q s", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  (\\<Sum>r\\<in>pts \\<union> qts. order r p) = (\\<Sum>r\\<in>pts. order r p)\n  (\\<Sum>r\\<in>pts \\<union> qts. order r q) = (\\<Sum>r\\<in>qts. order r q)\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within (p * q) s. order r (p * q)) =\n    (\\<Sum>r\\<in>proots_within p s. order r p) +\n    (\\<Sum>r\\<in>proots_within q s. order r q)", "apply (simp add:proots_within_times order_mult[OF \\<open>p*q\\<noteq>0\\<close>] sum.distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>r\\<in>pts \\<union> qts. order r p) =\n             (\\<Sum>r\\<in>pts. order r p);\n     (\\<Sum>r\\<in>pts \\<union> qts. order r q) =\n     (\\<Sum>r\\<in>qts. order r q)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>r\\<in>proots_within p s \\<union>\n                                   proots_within q s.\n                         order r p) +\n                      (\\<Sum>r\\<in>proots_within p s \\<union>\n                                   proots_within q s.\n                         order r q) =\n                      (\\<Sum>r\\<in>proots_within p s. order r p) +\n                      (\\<Sum>r\\<in>proots_within q s. order r q)", "apply (fold pts_def qts_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<Sum>r\\<in>pts \\<union> qts. order r p) =\n             (\\<Sum>r\\<in>pts. order r p);\n     (\\<Sum>r\\<in>pts \\<union> qts. order r q) =\n     (\\<Sum>r\\<in>qts. order r q)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>r\\<in>pts \\<union> qts. order r p) +\n                      (\\<Sum>r\\<in>pts \\<union> qts. order r q) =\n                      (\\<Sum>r\\<in>pts. order r p) +\n                      (\\<Sum>r\\<in>qts. order r q)", "by auto"], ["proof (state)\nthis:\n  proots_count (p * q) s = proots_count p s + proots_count q s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_count_power_n_n:\n  shows \"proots_count ([:- a, 1:]^n) s = (if a\\<in>s \\<and> n>0 then n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count ([:- a, 1::'a:] ^ n) s =\n    (if a \\<in> s \\<and> 0 < n then n else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count ([:- a, 1::'a:] ^ n) s =\n    (if a \\<in> s \\<and> 0 < n then n else 0)", "have \"proots_within ([:- a, 1:] ^ n) s= (if a\\<in>s \\<and> n>0 then {a} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within ([:- a, 1::'a:] ^ n) s =\n    (if a \\<in> s \\<and> 0 < n then {a} else {})", "unfolding proots_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> s. poly ([:- a, 1::'a:] ^ n) x = (0::'a)} =\n    (if a \\<in> s \\<and> 0 < n then {a} else {})", "by auto"], ["proof (state)\nthis:\n  proots_within ([:- a, 1::'a:] ^ n) s =\n  (if a \\<in> s \\<and> 0 < n then {a} else {})\n\ngoal (1 subgoal):\n 1. proots_count ([:- a, 1::'a:] ^ n) s =\n    (if a \\<in> s \\<and> 0 < n then n else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  proots_within ([:- a, 1::'a:] ^ n) s =\n  (if a \\<in> s \\<and> 0 < n then {a} else {})\n\ngoal (1 subgoal):\n 1. proots_count ([:- a, 1::'a:] ^ n) s =\n    (if a \\<in> s \\<and> 0 < n then n else 0)", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within ([:- a, 1::'a:] ^ n) s =\n  (if a \\<in> s \\<and> 0 < n then {a} else {})\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within ([:- a, 1::'a:] ^ n) s.\n       order r ([:- a, 1::'a:] ^ n)) =\n    (if a \\<in> s \\<and> 0 < n then n else 0)", "using order_power_n_n"], ["proof (prove)\nusing this:\n  proots_within ([:- a, 1::'a:] ^ n) s =\n  (if a \\<in> s \\<and> 0 < n then {a} else {})\n  order ?a ([:- ?a, 1::?'a:] ^ ?n) = ?n\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within ([:- a, 1::'a:] ^ n) s.\n       order r ([:- a, 1::'a:] ^ n)) =\n    (if a \\<in> s \\<and> 0 < n then n else 0)", "by auto"], ["proof (state)\nthis:\n  proots_count ([:- a, 1::'a:] ^ n) s =\n  (if a \\<in> s \\<and> 0 < n then n else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_proots_count:\n  fixes p::\"complex poly\"\n  shows \"degree p = proots_count p UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = proots_count p UNIV", "proof (induct \"degree p\" arbitrary:p )"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p. 0 = degree p \\<Longrightarrow> degree p = proots_count p UNIV\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "case 0"], ["proof (state)\nthis:\n  0 = degree p\n\ngoal (2 subgoals):\n 1. \\<And>p. 0 = degree p \\<Longrightarrow> degree p = proots_count p UNIV\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "then"], ["proof (chain)\npicking this:\n  0 = degree p", "obtain c where c_def:\"p=[:c:]\""], ["proof (prove)\nusing this:\n  0 = degree p\n\ngoal (1 subgoal):\n 1. (\\<And>c. p = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using degree_eq_zeroE"], ["proof (prove)\nusing this:\n  0 = degree p\n  \\<lbrakk>degree ?p = 0;\n   \\<And>a. ?p = [:a:] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c. p = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = [:c:]\n\ngoal (2 subgoals):\n 1. \\<And>p. 0 = degree p \\<Longrightarrow> degree p = proots_count p UNIV\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "then"], ["proof (chain)\npicking this:\n  p = [:c:]", "show ?case"], ["proof (prove)\nusing this:\n  p = [:c:]\n\ngoal (1 subgoal):\n 1. degree p = proots_count p UNIV", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  p = [:c:]\n\ngoal (1 subgoal):\n 1. degree p = (\\<Sum>r\\<in>proots p. order r p)", "apply (cases \"c=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = [:c:]; c = 0\\<rbrakk>\n    \\<Longrightarrow> degree p = (\\<Sum>r\\<in>proots p. order r p)\n 2. \\<lbrakk>p = [:c:]; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> degree p = (\\<Sum>r\\<in>proots p. order r p)", "by (auto intro!:sum.infinite simp add:infinite_UNIV_char_0 order_0I)"], ["proof (state)\nthis:\n  degree p = proots_count p UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "case (Suc n)"], ["proof (state)\nthis:\n  n = degree ?p \\<Longrightarrow> degree ?p = proots_count ?p UNIV\n  Suc n = degree p\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "then"], ["proof (chain)\npicking this:\n  n = degree ?p \\<Longrightarrow> degree ?p = proots_count ?p UNIV\n  Suc n = degree p", "have \"degree p\\<noteq>0\" and \"p\\<noteq>0\""], ["proof (prove)\nusing this:\n  n = degree ?p \\<Longrightarrow> degree ?p = proots_count ?p UNIV\n  Suc n = degree p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 &&& p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "obtain z where \"poly p z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z. poly p z = 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Fundamental_Theorem_Algebra.fundamental_theorem_of_algebra \\<open>degree p\\<noteq>0\\<close> constant_degree[of p]"], ["proof (prove)\nusing this:\n  \\<not> constant (poly ?p) \\<Longrightarrow> \\<exists>z. poly ?p z = 0\n  degree p \\<noteq> 0\n  constant (poly p) = (degree p = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>z. poly p z = 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly p z = 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "define onez where \"onez=[:-z,1:]\""], ["proof (state)\nthis:\n  onez = [:- z, 1:]\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "have [simp]: \"onez\\<noteq>0\" \"degree onez = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onez \\<noteq> 0 &&& degree onez = 1", "unfolding onez_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- z, 1:] \\<noteq> 0 &&& degree [:- z, 1:] = 1", "by auto"], ["proof (state)\nthis:\n  onez \\<noteq> 0\n  degree onez = 1\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "obtain q where q_def:\"p= onez * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q. p = onez * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using poly_eq_0_iff_dvd \\<open>poly p z = 0\\<close> dvdE"], ["proof (prove)\nusing this:\n  (poly ?p ?c = (0::?'a)) = ([:- ?c, 1::?'a:] dvd ?p)\n  poly p z = 0\n  \\<lbrakk>?b dvd ?a; \\<And>k. ?a = ?b * k \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = onez * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding onez_def"], ["proof (prove)\nusing this:\n  (poly ?p ?c = (0::?'a)) = ([:- ?c, 1::?'a:] dvd ?p)\n  poly p z = 0\n  \\<lbrakk>?b dvd ?a; \\<And>k. ?a = ?b * k \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = [:- z, 1:] * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p = onez * q\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "hence \"q\\<noteq>0\""], ["proof (prove)\nusing this:\n  p = onez * q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = onez * q\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "hence \"n=degree q\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n = degree q", "using degree_mult_eq[of onez q] \\<open>Suc n = degree p\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  \\<lbrakk>onez \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> degree (onez * q) = degree onez + degree q\n  Suc n = degree p\n\ngoal (1 subgoal):\n 1. n = degree q", "apply (fold q_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> 0;\n     \\<lbrakk>onez \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> degree p = degree onez + degree q;\n     Suc n = degree p\\<rbrakk>\n    \\<Longrightarrow> n = degree q", "by auto"], ["proof (state)\nthis:\n  n = degree q\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "hence \"degree q = proots_count q UNIV\""], ["proof (prove)\nusing this:\n  n = degree q\n\ngoal (1 subgoal):\n 1. degree q = proots_count q UNIV", "using Suc.hyps(1)"], ["proof (prove)\nusing this:\n  n = degree q\n  n = degree ?p \\<Longrightarrow> degree ?p = proots_count ?p UNIV\n\ngoal (1 subgoal):\n 1. degree q = proots_count q UNIV", "by simp"], ["proof (state)\nthis:\n  degree q = proots_count q UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "moreover"], ["proof (state)\nthis:\n  degree q = proots_count q UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "have \" Suc 0 = proots_count onez UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 = proots_count onez UNIV", "unfolding onez_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 = proots_count [:- z, 1:] UNIV", "using proots_count_power_n_n[of z 1 UNIV]"], ["proof (prove)\nusing this:\n  proots_count ([:- z, 1:] ^ 1) UNIV =\n  (if z \\<in> UNIV \\<and> 0 < 1 then 1 else 0)\n\ngoal (1 subgoal):\n 1. Suc 0 = proots_count [:- z, 1:] UNIV", "by auto"], ["proof (state)\nthis:\n  Suc 0 = proots_count onez UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   degree p = proots_count p UNIV;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> degree p = proots_count p UNIV", "ultimately"], ["proof (chain)\npicking this:\n  degree q = proots_count q UNIV\n  Suc 0 = proots_count onez UNIV", "show ?case"], ["proof (prove)\nusing this:\n  degree q = proots_count q UNIV\n  Suc 0 = proots_count onez UNIV\n\ngoal (1 subgoal):\n 1. degree p = proots_count p UNIV", "unfolding q_def"], ["proof (prove)\nusing this:\n  degree q = proots_count q UNIV\n  Suc 0 = proots_count onez UNIV\n\ngoal (1 subgoal):\n 1. degree (onez * q) = proots_count (onez * q) UNIV", "using degree_mult_eq[of onez q] proots_count_times[of onez q UNIV] \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  degree q = proots_count q UNIV\n  Suc 0 = proots_count onez UNIV\n  \\<lbrakk>onez \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> degree (onez * q) = degree onez + degree q\n  onez * q \\<noteq> 0 \\<Longrightarrow>\n  proots_count (onez * q) UNIV =\n  proots_count onez UNIV + proots_count q UNIV\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (onez * q) = proots_count (onez * q) UNIV", "by auto"], ["proof (state)\nthis:\n  degree p = proots_count p UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_count_smult:\n  fixes a::\"'a::{semiring_no_zero_divisors,idom}\"\n  assumes \"a\\<noteq>0\"\n  shows \"proots_count (smult a p) s= proots_count p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (smult a p) s = proots_count p s", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> proots_count (smult a p) s = proots_count p s\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    proots_count (smult a p) s = proots_count p s", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> proots_count (smult a p) s = proots_count p s\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    proots_count (smult a p) s = proots_count p s", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. proots_count (smult a p) s = proots_count p s", "by auto"], ["proof (state)\nthis:\n  proots_count (smult a p) s = proots_count p s\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    proots_count (smult a p) s = proots_count p s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    proots_count (smult a p) s = proots_count p s", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    proots_count (smult a p) s = proots_count p s", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count (smult a p) s = proots_count p s", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within (smult a p) s. order r (smult a p)) =\n    (\\<Sum>r\\<in>proots_within p s. order r p)", "using order_smult[OF assms] proots_within_smult[OF assms]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  order ?x (smult a ?p) = order ?x ?p\n  proots_within (smult a ?p) ?s = proots_within ?p ?s\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within (smult a p) s. order r (smult a p)) =\n    (\\<Sum>r\\<in>proots_within p s. order r p)", "by auto"], ["proof (state)\nthis:\n  proots_count (smult a p) s = proots_count p s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_count_pCons_1_iff:\n  fixes a::\"'a::idom\"\n  shows \"proots_count [:-a,1:] s = (if a\\<in>s then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count [:- a, 1::'a:] s = (if a \\<in> s then 1 else 0)", "unfolding proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within [:- a, 1::'a:] s. order r [:- a, 1::'a:]) =\n    (if a \\<in> s then 1 else 0)", "by (cases \"a\\<in>s\",auto simp add:proots_within_pCons_1_iff order_power_n_n[of _ 1,simplified])"], ["", "lemma proots_count_uminus[simp]:\n  \"proots_count (- p) s = proots_count p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (- p) s = proots_count p s", "unfolding proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within (- p) s. order r (- p)) =\n    (\\<Sum>r\\<in>proots_within p s. order r p)", "by simp"], ["", "lemma card_proots_within_leq:\n  assumes \"p\\<noteq>0\"\n  shows \"proots_count p s \\<ge> card (proots_within p s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p s) \\<le> proots_count p s", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within p s) \\<le> proots_count p s", "proof (induct rule:poly_root_induct[of _ \"\\<lambda>x. x\\<in>s\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    card (proots_within 0 s) \\<le> proots_count 0 s\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p s) \\<le> proots_count p s\n 3. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "case 0"], ["proof (state)\nthis:\n  0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    card (proots_within 0 s) \\<le> proots_count 0 s\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p s) \\<le> proots_count p s\n 3. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within 0 s) \\<le> proots_count 0 s", "unfolding proots_within_def proots_count_def"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card {x \\<in> s. poly 0 x = (0::'a)}\n    \\<le> (\\<Sum>r\\<in>{x \\<in> s. poly 0 x = (0::'a)}. order r 0)", "by auto"], ["proof (state)\nthis:\n  card (proots_within 0 s) \\<le> proots_count 0 s\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p s) \\<le> proots_count p s\n 2. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p s) \\<le> proots_count p s\n 2. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "case (no_roots p)"], ["proof (state)\nthis:\n  ?a \\<in> s \\<Longrightarrow> poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p s) \\<le> proots_count p s\n 2. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "then"], ["proof (chain)\npicking this:\n  ?a \\<in> s \\<Longrightarrow> poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0", "have \"proots_within p s = {}\""], ["proof (prove)\nusing this:\n  ?a \\<in> s \\<Longrightarrow> poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_within p s = {}", "by auto"], ["proof (state)\nthis:\n  proots_within p s = {}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p s) \\<le> proots_count p s\n 2. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "then"], ["proof (chain)\npicking this:\n  proots_within p s = {}", "show ?case"], ["proof (prove)\nusing this:\n  proots_within p s = {}\n\ngoal (1 subgoal):\n 1. card (proots_within p s) \\<le> proots_count p s", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within p s = {}\n\ngoal (1 subgoal):\n 1. card (proots_within p s)\n    \\<le> (\\<Sum>r\\<in>proots_within p s. order r p)", "by auto"], ["proof (state)\nthis:\n  card (proots_within p s) \\<le> proots_count p s\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "case (root a p)"], ["proof (state)\nthis:\n  a \\<in> s\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p s) \\<le> proots_count p s\n  [:a, - (1::'a):] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "have \"card (proots_within ([:- a, 1:] * p) s) \n      \\<le> card (proots_within [:- a, 1:] s)+card (proots_within p s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within ([:- a, 1::'a:] * p) s)\n    \\<le> card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)", "unfolding proots_within_times"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within [:- a, 1::'a:] s \\<union> proots_within p s)\n    \\<le> card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)", "by (auto simp add:card_Un_le)"], ["proof (state)\nthis:\n  card (proots_within ([:- a, 1::'a:] * p) s)\n  \\<le> card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "also"], ["proof (state)\nthis:\n  card (proots_within ([:- a, 1::'a:] * p) s)\n  \\<le> card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "have \"... \\<le> 1+ proots_count p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)\n    \\<le> 1 + proots_count p s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)\n    \\<le> 1 + proots_count p s", "have \"card (proots_within [:- a, 1:] s) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within [:- a, 1::'a:] s) \\<le> 1", "proof (cases \"a\\<in>s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> s \\<Longrightarrow>\n    card (proots_within [:- a, 1::'a:] s) \\<le> 1\n 2. a \\<notin> s \\<Longrightarrow>\n    card (proots_within [:- a, 1::'a:] s) \\<le> 1", "case True"], ["proof (state)\nthis:\n  a \\<in> s\n\ngoal (2 subgoals):\n 1. a \\<in> s \\<Longrightarrow>\n    card (proots_within [:- a, 1::'a:] s) \\<le> 1\n 2. a \\<notin> s \\<Longrightarrow>\n    card (proots_within [:- a, 1::'a:] s) \\<le> 1", "then"], ["proof (chain)\npicking this:\n  a \\<in> s", "have \"proots_within [:- a, 1:] s = {a}\""], ["proof (prove)\nusing this:\n  a \\<in> s\n\ngoal (1 subgoal):\n 1. proots_within [:- a, 1::'a:] s = {a}", "by auto"], ["proof (state)\nthis:\n  proots_within [:- a, 1::'a:] s = {a}\n\ngoal (2 subgoals):\n 1. a \\<in> s \\<Longrightarrow>\n    card (proots_within [:- a, 1::'a:] s) \\<le> 1\n 2. a \\<notin> s \\<Longrightarrow>\n    card (proots_within [:- a, 1::'a:] s) \\<le> 1", "then"], ["proof (chain)\npicking this:\n  proots_within [:- a, 1::'a:] s = {a}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within [:- a, 1::'a:] s = {a}\n\ngoal (1 subgoal):\n 1. card (proots_within [:- a, 1::'a:] s) \\<le> 1", "by auto"], ["proof (state)\nthis:\n  card (proots_within [:- a, 1::'a:] s) \\<le> 1\n\ngoal (1 subgoal):\n 1. a \\<notin> s \\<Longrightarrow>\n    card (proots_within [:- a, 1::'a:] s) \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> s \\<Longrightarrow>\n    card (proots_within [:- a, 1::'a:] s) \\<le> 1", "case False"], ["proof (state)\nthis:\n  a \\<notin> s\n\ngoal (1 subgoal):\n 1. a \\<notin> s \\<Longrightarrow>\n    card (proots_within [:- a, 1::'a:] s) \\<le> 1", "then"], ["proof (chain)\npicking this:\n  a \\<notin> s", "have \"proots_within [:- a, 1:] s = {}\""], ["proof (prove)\nusing this:\n  a \\<notin> s\n\ngoal (1 subgoal):\n 1. proots_within [:- a, 1::'a:] s = {}", "by auto"], ["proof (state)\nthis:\n  proots_within [:- a, 1::'a:] s = {}\n\ngoal (1 subgoal):\n 1. a \\<notin> s \\<Longrightarrow>\n    card (proots_within [:- a, 1::'a:] s) \\<le> 1", "then"], ["proof (chain)\npicking this:\n  proots_within [:- a, 1::'a:] s = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within [:- a, 1::'a:] s = {}\n\ngoal (1 subgoal):\n 1. card (proots_within [:- a, 1::'a:] s) \\<le> 1", "by auto"], ["proof (state)\nthis:\n  card (proots_within [:- a, 1::'a:] s) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (proots_within [:- a, 1::'a:] s) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)\n    \\<le> 1 + proots_count p s", "moreover"], ["proof (state)\nthis:\n  card (proots_within [:- a, 1::'a:] s) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)\n    \\<le> 1 + proots_count p s", "have \"card (proots_within p s) \\<le> proots_count p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p s) \\<le> proots_count p s", "apply (rule root.hyps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using root"], ["proof (prove)\nusing this:\n  a \\<in> s\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p s) \\<le> proots_count p s\n  [:a, - (1::'a):] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (proots_within p s) \\<le> proots_count p s\n\ngoal (1 subgoal):\n 1. card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)\n    \\<le> 1 + proots_count p s", "ultimately"], ["proof (chain)\npicking this:\n  card (proots_within [:- a, 1::'a:] s) \\<le> 1\n  card (proots_within p s) \\<le> proots_count p s", "show ?thesis"], ["proof (prove)\nusing this:\n  card (proots_within [:- a, 1::'a:] s) \\<le> 1\n  card (proots_within p s) \\<le> proots_count p s\n\ngoal (1 subgoal):\n 1. card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)\n    \\<le> 1 + proots_count p s", "by auto"], ["proof (state)\nthis:\n  card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)\n  \\<le> 1 + proots_count p s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)\n  \\<le> 1 + proots_count p s\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "also"], ["proof (state)\nthis:\n  card (proots_within [:- a, 1::'a:] s) + card (proots_within p s)\n  \\<le> 1 + proots_count p s\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "have \"... =  proots_count ([:- a,1:] * p) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + proots_count p s = proots_count ([:- a, 1::'a:] * p) s", "apply (subst proots_count_times)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [:- a, 1::'a:] * p \\<noteq> 0\n 2. 1 + proots_count p s = proots_count [:- a, 1::'a:] s + proots_count p s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * p \\<noteq> 0", "by (metis mult_eq_0_iff pCons_eq_0_iff root.prems zero_neq_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + proots_count p s = proots_count [:- a, 1::'a:] s + proots_count p s", "using root"], ["proof (prove)\nusing this:\n  a \\<in> s\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p s) \\<le> proots_count p s\n  [:a, - (1::'a):] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 + proots_count p s = proots_count [:- a, 1::'a:] s + proots_count p s", "by (auto simp add:proots_count_pCons_1_iff)"], ["proof (state)\nthis:\n  1 + proots_count p s = proots_count ([:- a, 1::'a:] * p) s\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "finally"], ["proof (chain)\npicking this:\n  card (proots_within ([:- a, 1::'a:] * p) s)\n  \\<le> proots_count ([:- a, 1::'a:] * p) s", "have \"card (proots_within ([:- a, 1:] * p) s) \\<le> proots_count ([:- a, 1:] * p) s\""], ["proof (prove)\nusing this:\n  card (proots_within ([:- a, 1::'a:] * p) s)\n  \\<le> proots_count ([:- a, 1::'a:] * p) s\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- a, 1::'a:] * p) s)\n    \\<le> proots_count ([:- a, 1::'a:] * p) s", "."], ["proof (state)\nthis:\n  card (proots_within ([:- a, 1::'a:] * p) s)\n  \\<le> proots_count ([:- a, 1::'a:] * p) s\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow>\n        card (proots_within p s) \\<le> proots_count p s;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:a, - (1::'a):] * p) s)\n                         \\<le> proots_count ([:a, - (1::'a):] * p) s", "then"], ["proof (chain)\npicking this:\n  card (proots_within ([:- a, 1::'a:] * p) s)\n  \\<le> proots_count ([:- a, 1::'a:] * p) s", "show ?case"], ["proof (prove)\nusing this:\n  card (proots_within ([:- a, 1::'a:] * p) s)\n  \\<le> proots_count ([:- a, 1::'a:] * p) s\n\ngoal (1 subgoal):\n 1. card (proots_within ([:a, - (1::'a):] * p) s)\n    \\<le> proots_count ([:a, - (1::'a):] * p) s", "by (metis (no_types, hide_lams) add.inverse_inverse add.inverse_neutral minus_pCons \n        mult_minus_left proots_count_uminus proots_within_uminus)"], ["proof (state)\nthis:\n  card (proots_within ([:a, - (1::'a):] * p) s)\n  \\<le> proots_count ([:a, - (1::'a):] * p) s\n\ngoal:\nNo subgoals!", "qed"], ["", "(*FIXME: not duplicate*)"], ["", "lemma proots_count_0_imp_empty:\n  assumes \"proots_count p s=0\" \"p\\<noteq>0\"\n  shows \"proots_within p s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p s = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_within p s = {}", "have \"card (proots_within p s) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p s) = 0", "using card_proots_within_leq[OF \\<open>p\\<noteq>0\\<close>,of s] \\<open>proots_count p s=0\\<close>"], ["proof (prove)\nusing this:\n  card (proots_within p s) \\<le> proots_count p s\n  proots_count p s = 0\n\ngoal (1 subgoal):\n 1. card (proots_within p s) = 0", "by auto"], ["proof (state)\nthis:\n  card (proots_within p s) = 0\n\ngoal (1 subgoal):\n 1. proots_within p s = {}", "moreover"], ["proof (state)\nthis:\n  card (proots_within p s) = 0\n\ngoal (1 subgoal):\n 1. proots_within p s = {}", "have \"finite (proots_within p s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within p s)", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (proots_within p s)", "by auto"], ["proof (state)\nthis:\n  finite (proots_within p s)\n\ngoal (1 subgoal):\n 1. proots_within p s = {}", "ultimately"], ["proof (chain)\npicking this:\n  card (proots_within p s) = 0\n  finite (proots_within p s)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (proots_within p s) = 0\n  finite (proots_within p s)\n\ngoal (1 subgoal):\n 1. proots_within p s = {}", "by auto"], ["proof (state)\nthis:\n  proots_within p s = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_count_leq_degree:\n  assumes \"p\\<noteq>0\"\n  shows \"proots_count p s\\<le> degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p s \\<le> degree p", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count p s \\<le> degree p", "proof (induct rule:poly_root_induct[of _ \"\\<lambda>x. x\\<in>s\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> proots_count 0 s \\<le> degree 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p s \\<le> degree p\n 3. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "case 0"], ["proof (state)\nthis:\n  0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> proots_count 0 s \\<le> degree 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p s \\<le> degree p\n 3. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count 0 s \\<le> degree 0", "by auto"], ["proof (state)\nthis:\n  proots_count 0 s \\<le> degree 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p s \\<le> degree p\n 2. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p s \\<le> degree p\n 2. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "case (no_roots p)"], ["proof (state)\nthis:\n  ?a \\<in> s \\<Longrightarrow> poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p s \\<le> degree p\n 2. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "then"], ["proof (chain)\npicking this:\n  ?a \\<in> s \\<Longrightarrow> poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0", "have \"proots_within p s = {}\""], ["proof (prove)\nusing this:\n  ?a \\<in> s \\<Longrightarrow> poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_within p s = {}", "by auto"], ["proof (state)\nthis:\n  proots_within p s = {}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a.\n                   a \\<in> s \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p s \\<le> degree p\n 2. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "then"], ["proof (chain)\npicking this:\n  proots_within p s = {}", "show ?case"], ["proof (prove)\nusing this:\n  proots_within p s = {}\n\ngoal (1 subgoal):\n 1. proots_count p s \\<le> degree p", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within p s = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p s. order r p) \\<le> degree p", "by auto"], ["proof (state)\nthis:\n  proots_count p s \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "case (root a p)"], ["proof (state)\nthis:\n  a \\<in> s\n  p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p\n  [:a, - (1::'a):] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "have \"proots_count ([:a, - 1:] * p) s = proots_count [:a, - 1:] s + proots_count p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count ([:a, - (1::'a):] * p) s =\n    proots_count [:a, - (1::'a):] s + proots_count p s", "apply (subst proots_count_times)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p \\<noteq> 0\n 2. proots_count [:a, - (1::'a):] s + proots_count p s =\n    proots_count [:a, - (1::'a):] s + proots_count p s", "using root"], ["proof (prove)\nusing this:\n  a \\<in> s\n  p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p\n  [:a, - (1::'a):] * p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p \\<noteq> 0\n 2. proots_count [:a, - (1::'a):] s + proots_count p s =\n    proots_count [:a, - (1::'a):] s + proots_count p s", "by auto"], ["proof (state)\nthis:\n  proots_count ([:a, - (1::'a):] * p) s =\n  proots_count [:a, - (1::'a):] s + proots_count p s\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "also"], ["proof (state)\nthis:\n  proots_count ([:a, - (1::'a):] * p) s =\n  proots_count [:a, - (1::'a):] s + proots_count p s\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "have \"... = 1 + proots_count p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count [:a, - (1::'a):] s + proots_count p s =\n    1 + proots_count p s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count [:a, - (1::'a):] s + proots_count p s =\n    1 + proots_count p s", "have \"proots_count [:a, - 1:] s  =1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count [:a, - (1::'a):] s = 1", "by (metis (no_types, lifting) add.inverse_inverse add.inverse_neutral minus_pCons \n          proots_count_pCons_1_iff proots_count_uminus root.hyps(1))"], ["proof (state)\nthis:\n  proots_count [:a, - (1::'a):] s = 1\n\ngoal (1 subgoal):\n 1. proots_count [:a, - (1::'a):] s + proots_count p s =\n    1 + proots_count p s", "then"], ["proof (chain)\npicking this:\n  proots_count [:a, - (1::'a):] s = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count [:a, - (1::'a):] s = 1\n\ngoal (1 subgoal):\n 1. proots_count [:a, - (1::'a):] s + proots_count p s =\n    1 + proots_count p s", "by auto"], ["proof (state)\nthis:\n  proots_count [:a, - (1::'a):] s + proots_count p s = 1 + proots_count p s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count [:a, - (1::'a):] s + proots_count p s = 1 + proots_count p s\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "also"], ["proof (state)\nthis:\n  proots_count [:a, - (1::'a):] s + proots_count p s = 1 + proots_count p s\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "have \"... \\<le>  degree ([:a,-1:] * p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + proots_count p s \\<le> degree ([:a, - (1::'a):] * p)", "apply (subst degree_mult_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. [:a, - (1::'a):] \\<noteq> 0\n 2. p \\<noteq> 0\n 3. 1 + proots_count p s \\<le> degree [:a, - (1::'a):] + degree p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:a, - (1::'a):] \\<noteq> 0", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. 1 + proots_count p s \\<le> degree [:a, - (1::'a):] + degree p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using root"], ["proof (prove)\nusing this:\n  a \\<in> s\n  p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p\n  [:a, - (1::'a):] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + proots_count p s \\<le> degree [:a, - (1::'a):] + degree p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + proots_count p s \\<le> degree [:a, - (1::'a):] + degree p", "using root"], ["proof (prove)\nusing this:\n  a \\<in> s\n  p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p\n  [:a, - (1::'a):] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 + proots_count p s \\<le> degree [:a, - (1::'a):] + degree p", "by (simp add: \\<open>p \\<noteq> 0\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  1 + proots_count p s \\<le> degree ([:a, - (1::'a):] * p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<in> s;\n        p \\<noteq> 0 \\<Longrightarrow> proots_count p s \\<le> degree p;\n        [:a, - (1::'a):] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:a, - (1::'a):] * p) s\n                         \\<le> degree ([:a, - (1::'a):] * p)", "finally"], ["proof (chain)\npicking this:\n  proots_count ([:a, - (1::'a):] * p) s \\<le> degree ([:a, - (1::'a):] * p)", "show ?case"], ["proof (prove)\nusing this:\n  proots_count ([:a, - (1::'a):] * p) s \\<le> degree ([:a, - (1::'a):] * p)\n\ngoal (1 subgoal):\n 1. proots_count ([:a, - (1::'a):] * p) s\n    \\<le> degree ([:a, - (1::'a):] * p)", "."], ["proof (state)\nthis:\n  proots_count ([:a, - (1::'a):] * p) s \\<le> degree ([:a, - (1::'a):] * p)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*TODO: not a duplicate*)"], ["", "lemma proots_count_union_disjoint:\n  assumes \"A \\<inter> B = {}\" \"p\\<noteq>0\"\n  shows \"proots_count p (A \\<union> B) = proots_count p A + proots_count p B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p (A \\<union> B) = proots_count p A + proots_count p B", "unfolding proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p (A \\<union> B). order r p) =\n    (\\<Sum>r\\<in>proots_within p A. order r p) +\n    (\\<Sum>r\\<in>proots_within p B. order r p)", "apply (subst proots_within_union[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p A \\<union> proots_within p B. order r p) =\n    (\\<Sum>r\\<in>proots_within p A. order r p) +\n    (\\<Sum>r\\<in>proots_within p B. order r p)", "apply (subst sum.union_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (proots_within p A)\n 2. finite (proots_within p B)\n 3. proots_within p A \\<inter> proots_within p B = {}\n 4. (\\<Sum>r\\<in>proots_within p A. order r p) +\n    (\\<Sum>r\\<in>proots_within p B. order r p) =\n    (\\<Sum>r\\<in>proots_within p A. order r p) +\n    (\\<Sum>r\\<in>proots_within p B. order r p)", "using assms"], ["proof (prove)\nusing this:\n  A \\<inter> B = {}\n  p \\<noteq> 0\n\ngoal (4 subgoals):\n 1. finite (proots_within p A)\n 2. finite (proots_within p B)\n 3. proots_within p A \\<inter> proots_within p B = {}\n 4. (\\<Sum>r\\<in>proots_within p A. order r p) +\n    (\\<Sum>r\\<in>proots_within p B. order r p) =\n    (\\<Sum>r\\<in>proots_within p A. order r p) +\n    (\\<Sum>r\\<in>proots_within p B. order r p)", "by auto"], ["", "lemma proots_count_cong:\n  assumes order_eq:\"\\<forall>x\\<in>s. order x p = order x q\" and \"p\\<noteq>0\" and \"q\\<noteq>0\"\n  shows \"proots_count p s = proots_count q s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p s = proots_count q s", "unfolding proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p s. order r p) =\n    (\\<Sum>r\\<in>proots_within q s. order r q)", "proof (rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. proots_within p s = proots_within q s\n 2. \\<And>x.\n       x \\<in> proots_within q s \\<Longrightarrow> order x p = order x q", "have \"poly p x = 0 \\<longleftrightarrow> poly q x = 0\" when \"x\\<in>s\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p x = (0::'a)) = (poly q x = (0::'a))", "using order_eq that"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>s. order x p = order x q\n  x \\<in> s\n\ngoal (1 subgoal):\n 1. (poly p x = (0::'a)) = (poly q x = (0::'a))", "by (simp add: assms(2) assms(3) order_root)"], ["proof (state)\nthis:\n  ?x \\<in> s \\<Longrightarrow> (poly p ?x = (0::'a)) = (poly q ?x = (0::'a))\n\ngoal (2 subgoals):\n 1. proots_within p s = proots_within q s\n 2. \\<And>x.\n       x \\<in> proots_within q s \\<Longrightarrow> order x p = order x q", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> s \\<Longrightarrow> (poly p ?x = (0::'a)) = (poly q ?x = (0::'a))", "show \"proots_within p s = proots_within q s\""], ["proof (prove)\nusing this:\n  ?x \\<in> s \\<Longrightarrow> (poly p ?x = (0::'a)) = (poly q ?x = (0::'a))\n\ngoal (1 subgoal):\n 1. proots_within p s = proots_within q s", "by auto"], ["proof (state)\nthis:\n  proots_within p s = proots_within q s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within q s \\<Longrightarrow> order x p = order x q", "show \"\\<And>x. x \\<in> proots_within q s \\<Longrightarrow> order x p = order x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within q s \\<Longrightarrow> order x p = order x q", "using order_eq"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>s. order x p = order x q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proots_within q s \\<Longrightarrow> order x p = order x q", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> proots_within q s \\<Longrightarrow> order ?x p = order ?x q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_count_of_real:\n  assumes \"p\\<noteq>0\"\n  shows \"proots_count (map_poly of_real p) ((of_real::_\\<Rightarrow>'a::{real_algebra_1,idom}) ` s) \n            = proots_count p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (of_real ` s) = proots_count p s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (of_real ` s) = proots_count p s", "define k where \"k=(of_real::_\\<Rightarrow>'a)\""], ["proof (state)\nthis:\n  k = of_real\n\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (of_real ` s) = proots_count p s", "have \"proots_within (map_poly of_real p) (k ` s) =k ` (proots_within p s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (map_poly of_real p) (k ` s) = k ` proots_within p s", "unfolding proots_within_def k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> of_real ` s. poly (map_poly of_real p) x = (0::'a)} =\n    of_real ` {x \\<in> s. poly p x = 0}", "by (auto simp add:of_real_poly_map_poly[symmetric])"], ["proof (state)\nthis:\n  proots_within (map_poly of_real p) (k ` s) = k ` proots_within p s\n\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (of_real ` s) = proots_count p s", "then"], ["proof (chain)\npicking this:\n  proots_within (map_poly of_real p) (k ` s) = k ` proots_within p s", "have \"proots_count (map_poly of_real p) (k ` s) \n                = (\\<Sum>r\\<in>k ` (proots_within p s). order r (map_poly of_real p))\""], ["proof (prove)\nusing this:\n  proots_within (map_poly of_real p) (k ` s) = k ` proots_within p s\n\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (k ` s) =\n    (\\<Sum>r\\<in>k ` proots_within p s. order r (map_poly of_real p))", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within (map_poly of_real p) (k ` s) = k ` proots_within p s\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within (map_poly of_real p) (k ` s).\n       order r (map_poly of_real p)) =\n    (\\<Sum>r\\<in>k ` proots_within p s. order r (map_poly of_real p))", "by simp"], ["proof (state)\nthis:\n  proots_count (map_poly of_real p) (k ` s) =\n  (\\<Sum>r\\<in>k ` proots_within p s. order r (map_poly of_real p))\n\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (of_real ` s) = proots_count p s", "also"], ["proof (state)\nthis:\n  proots_count (map_poly of_real p) (k ` s) =\n  (\\<Sum>r\\<in>k ` proots_within p s. order r (map_poly of_real p))\n\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (of_real ` s) = proots_count p s", "have \"... = sum ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> k) (proots_within p s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>k ` proots_within p s. order r (map_poly of_real p)) =\n    sum ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> k)\n     (proots_within p s)", "apply (subst sum.reindex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on k (proots_within p s)\n 2. sum ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> k)\n     (proots_within p s) =\n    sum ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> k)\n     (proots_within p s)", "unfolding k_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on of_real (proots_within p s)\n 2. sum ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> of_real)\n     (proots_within p s) =\n    sum ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> of_real)\n     (proots_within p s)", "by (auto simp add: inj_on_def)"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>k ` proots_within p s. order r (map_poly of_real p)) =\n  sum ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> k)\n   (proots_within p s)\n\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (of_real ` s) = proots_count p s", "also"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>k ` proots_within p s. order r (map_poly of_real p)) =\n  sum ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> k)\n   (proots_within p s)\n\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (of_real ` s) = proots_count p s", "have \"... = proots_count p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> k)\n     (proots_within p s) =\n    proots_count p s", "unfolding proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> k)\n     (proots_within p s) =\n    (\\<Sum>r\\<in>proots_within p s. order r p)", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proots_within p s = proots_within p s\n 2. \\<And>x.\n       x \\<in> proots_within p s \\<Longrightarrow>\n       ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> k) x = order x p", "unfolding k_def comp_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. proots_within p s = proots_within p s\n 2. \\<And>x.\n       x \\<in> proots_within p s \\<Longrightarrow>\n       order (of_real x) (map_poly of_real p) = order x p", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. proots_within p s = proots_within p s\n 2. \\<And>x.\n       x \\<in> proots_within p s \\<Longrightarrow>\n       order (of_real x) (map_poly of_real p) = order x p", "by (auto simp add:map_poly_order_of_real)"], ["proof (state)\nthis:\n  sum ((\\<lambda>r. order r (map_poly of_real p)) \\<circ> k)\n   (proots_within p s) =\n  proots_count p s\n\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (of_real ` s) = proots_count p s", "finally"], ["proof (chain)\npicking this:\n  proots_count (map_poly of_real p) (k ` s) = proots_count p s", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count (map_poly of_real p) (k ` s) = proots_count p s\n\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (of_real ` s) = proots_count p s", "unfolding k_def"], ["proof (prove)\nusing this:\n  proots_count (map_poly of_real p) (of_real ` s) = proots_count p s\n\ngoal (1 subgoal):\n 1. proots_count (map_poly of_real p) (of_real ` s) = proots_count p s", "."], ["proof (state)\nthis:\n  proots_count (map_poly of_real p) (of_real ` s) = proots_count p s\n\ngoal:\nNo subgoals!", "qed"], ["", "(*Is field really necessary here?*)"], ["", "lemma proots_pcompose:\n  fixes p q::\"'a::field poly\"\n  assumes \"p\\<noteq>0\" \"degree q=1\"\n  shows \"proots_count (pcompose p q) s = proots_count p (poly q ` s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "obtain a b where ab:\"q=[:a,b:]\" \"b\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>q = [:a, b:]; b \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>degree q=1\\<close> degree_eq_oneE"], ["proof (prove)\nusing this:\n  degree q = 1\n  \\<lbrakk>degree ?p = 1;\n   \\<And>a b.\n      \\<lbrakk>?p = [:a, b:]; b \\<noteq> (0::?'a)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>q = [:a, b:]; b \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  q = [:a, b:]\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "define f where \"f=(\\<lambda>y. (y-a)/b)\""], ["proof (state)\nthis:\n  f = (\\<lambda>y. (y - a) / b)\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "have f_eq:\"f (poly q x) = x\" \"poly q (f x) = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (poly q x) = x &&& poly q (f x) = x", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly q x - a) / b = x &&& poly q ((x - a) / b) = x", "using ab"], ["proof (prove)\nusing this:\n  q = [:a, b:]\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (poly q x - a) / b = x &&& poly q ((x - a) / b) = x", "by auto"], ["proof (state)\nthis:\n  f (poly q ?x) = ?x\n  poly q (f ?x) = ?x\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "have \"proots_count (p \\<circ>\\<^sub>p q) s = (\\<Sum>r\\<in> f ` proots_within p (poly q ` s). order r (p \\<circ>\\<^sub>p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s =\n    (\\<Sum>r\\<in>f ` proots_within p (poly q ` s).\n       order r (p \\<circ>\\<^sub>p q))", "unfolding proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within (p \\<circ>\\<^sub>p q) s.\n       order r (p \\<circ>\\<^sub>p q)) =\n    (\\<Sum>r\\<in>f ` proots_within p (poly q ` s).\n       order r (p \\<circ>\\<^sub>p q))", "apply (rule arg_cong2[where f =sum])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>r. order r (p \\<circ>\\<^sub>p q)) =\n    (\\<lambda>r. order r (p \\<circ>\\<^sub>p q))\n 2. proots_within (p \\<circ>\\<^sub>p q) s = f ` proots_within p (poly q ` s)", "apply (auto simp:poly_pcompose proots_within_def f_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> s; poly p (poly q x) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f `\n                                 {x \\<in> poly q ` s. poly p x = (0::'a)}", "by (metis (mono_tags, lifting) f_eq(1) image_eqI mem_Collect_eq)"], ["proof (state)\nthis:\n  proots_count (p \\<circ>\\<^sub>p q) s =\n  (\\<Sum>r\\<in>f ` proots_within p (poly q ` s).\n     order r (p \\<circ>\\<^sub>p q))\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "also"], ["proof (state)\nthis:\n  proots_count (p \\<circ>\\<^sub>p q) s =\n  (\\<Sum>r\\<in>f ` proots_within p (poly q ` s).\n     order r (p \\<circ>\\<^sub>p q))\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "have \"... = (\\<Sum>x\\<in>proots_within p (poly q ` s). order (f x) (p \\<circ>\\<^sub>p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>f ` proots_within p (poly q ` s).\n       order r (p \\<circ>\\<^sub>p q)) =\n    (\\<Sum>x\\<in>proots_within p (poly q ` s).\n       order (f x) (p \\<circ>\\<^sub>p q))", "apply (subst sum.reindex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on f (proots_within p (poly q ` s))\n 2. sum ((\\<lambda>r. order r (p \\<circ>\\<^sub>p q)) \\<circ> f)\n     (proots_within p (poly q ` s)) =\n    (\\<Sum>x\\<in>proots_within p (poly q ` s).\n       order (f x) (p \\<circ>\\<^sub>p q))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (proots_within p (poly q ` s))", "unfolding f_def inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>proots_within p (poly q ` s).\n       \\<forall>y\\<in>proots_within p (poly q ` s).\n          (x - a) / b = (y - a) / b \\<longrightarrow> x = y", "using \\<open>b\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>proots_within p (poly q ` s).\n       \\<forall>y\\<in>proots_within p (poly q ` s).\n          (x - a) / b = (y - a) / b \\<longrightarrow> x = y", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>r. order r (p \\<circ>\\<^sub>p q)) \\<circ> f)\n     (proots_within p (poly q ` s)) =\n    (\\<Sum>x\\<in>proots_within p (poly q ` s).\n       order (f x) (p \\<circ>\\<^sub>p q))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>f ` proots_within p (poly q ` s).\n     order r (p \\<circ>\\<^sub>p q)) =\n  (\\<Sum>x\\<in>proots_within p (poly q ` s).\n     order (f x) (p \\<circ>\\<^sub>p q))\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "also"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>f ` proots_within p (poly q ` s).\n     order r (p \\<circ>\\<^sub>p q)) =\n  (\\<Sum>x\\<in>proots_within p (poly q ` s).\n     order (f x) (p \\<circ>\\<^sub>p q))\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "have \"... = (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>proots_within p (poly q ` s).\n       order (f x) (p \\<circ>\\<^sub>p q)) =\n    (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>proots_within p (poly q ` s).\n       order (f x) (p \\<circ>\\<^sub>p q)) =\n    (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p)", "have \"p \\<circ>\\<^sub>p q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p q \\<noteq> 0", "using assms(1) assms(2) pcompose_eq_0"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  degree q = 1\n  \\<lbrakk>?p \\<circ>\\<^sub>p ?q = 0; 0 < degree ?q\\<rbrakk>\n  \\<Longrightarrow> ?p = 0\n\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p q \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  p \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>proots_within p (poly q ` s).\n       order (f x) (p \\<circ>\\<^sub>p q)) =\n    (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p)", "moreover"], ["proof (state)\nthis:\n  p \\<circ>\\<^sub>p q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>proots_within p (poly q ` s).\n       order (f x) (p \\<circ>\\<^sub>p q)) =\n    (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p)", "have \"order (f x) (q - [:x:]) = 1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. order (f x) (q - [:x:]) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order (f x) (q - [:x:]) = 1", "have \"order (f x) (q - [:x:]) = order (f x) (smult b [:-((x - a) / b),1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (f x) (q - [:x:]) =\n    order (f x) (smult b [:- ((x - a) / b), 1::'a:])", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order ((x - a) / b) (q - [:x:]) =\n    order ((x - a) / b) (smult b [:- ((x - a) / b), 1::'a:])", "using ab"], ["proof (prove)\nusing this:\n  q = [:a, b:]\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. order ((x - a) / b) (q - [:x:]) =\n    order ((x - a) / b) (smult b [:- ((x - a) / b), 1::'a:])", "by auto"], ["proof (state)\nthis:\n  order (f x) (q - [:x:]) = order (f x) (smult b [:- ((x - a) / b), 1::'a:])\n\ngoal (1 subgoal):\n 1. order (f x) (q - [:x:]) = 1", "also"], ["proof (state)\nthis:\n  order (f x) (q - [:x:]) = order (f x) (smult b [:- ((x - a) / b), 1::'a:])\n\ngoal (1 subgoal):\n 1. order (f x) (q - [:x:]) = 1", "have \"... = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order (f x) (smult b [:- ((x - a) / b), 1::'a:]) = 1", "apply (subst order_smult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<noteq> (0::'a)\n 2. order (f x) [:- ((x - a) / b), 1::'a:] = 1", "using \\<open>b\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. b \\<noteq> (0::'a)\n 2. order (f x) [:- ((x - a) / b), 1::'a:] = 1", "unfolding f_def"], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. b \\<noteq> (0::'a)\n 2. order ((x - a) / b) [:- ((x - a) / b), 1::'a:] = 1", "by auto"], ["proof (state)\nthis:\n  order (f x) (smult b [:- ((x - a) / b), 1::'a:]) = 1\n\ngoal (1 subgoal):\n 1. order (f x) (q - [:x:]) = 1", "finally"], ["proof (chain)\npicking this:\n  order (f x) (q - [:x:]) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  order (f x) (q - [:x:]) = 1\n\ngoal (1 subgoal):\n 1. order (f x) (q - [:x:]) = 1", "."], ["proof (state)\nthis:\n  order (f x) (q - [:x:]) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order (f ?x) (q - [:?x:]) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>proots_within p (poly q ` s).\n       order (f x) (p \\<circ>\\<^sub>p q)) =\n    (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p)", "ultimately"], ["proof (chain)\npicking this:\n  p \\<circ>\\<^sub>p q \\<noteq> 0\n  order (f ?x) (q - [:?x:]) = 1", "have \"order (f x) (p \\<circ>\\<^sub>p q) = order x p\" for x"], ["proof (prove)\nusing this:\n  p \\<circ>\\<^sub>p q \\<noteq> 0\n  order (f ?x) (q - [:?x:]) = 1\n\ngoal (1 subgoal):\n 1. order (f x) (p \\<circ>\\<^sub>p q) = order x p", "apply (subst order_pcompose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0;\n     \\<And>x. order (f x) (q - [:x:]) = 1\\<rbrakk>\n    \\<Longrightarrow> p \\<circ>\\<^sub>p q \\<noteq> 0\n 2. \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0;\n     \\<And>x. order (f x) (q - [:x:]) = 1\\<rbrakk>\n    \\<Longrightarrow> order (f x) (q - [:poly q (f x):]) *\n                      order (poly q (f x)) p =\n                      order x p", "using f_eq"], ["proof (prove)\nusing this:\n  f (poly q ?x) = ?x\n  poly q (f ?x) = ?x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0;\n     \\<And>x. order (f x) (q - [:x:]) = 1\\<rbrakk>\n    \\<Longrightarrow> p \\<circ>\\<^sub>p q \\<noteq> 0\n 2. \\<lbrakk>p \\<circ>\\<^sub>p q \\<noteq> 0;\n     \\<And>x. order (f x) (q - [:x:]) = 1\\<rbrakk>\n    \\<Longrightarrow> order (f x) (q - [:poly q (f x):]) *\n                      order (poly q (f x)) p =\n                      order x p", "by auto"], ["proof (state)\nthis:\n  order (f ?x) (p \\<circ>\\<^sub>p q) = order ?x p\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>proots_within p (poly q ` s).\n       order (f x) (p \\<circ>\\<^sub>p q)) =\n    (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p)", "then"], ["proof (chain)\npicking this:\n  order (f ?x) (p \\<circ>\\<^sub>p q) = order ?x p", "show ?thesis"], ["proof (prove)\nusing this:\n  order (f ?x) (p \\<circ>\\<^sub>p q) = order ?x p\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>proots_within p (poly q ` s).\n       order (f x) (p \\<circ>\\<^sub>p q)) =\n    (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>proots_within p (poly q ` s).\n     order (f x) (p \\<circ>\\<^sub>p q)) =\n  (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>proots_within p (poly q ` s).\n     order (f x) (p \\<circ>\\<^sub>p q)) =\n  (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p)\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>proots_within p (poly q ` s).\n     order (f x) (p \\<circ>\\<^sub>p q)) =\n  (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p)\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "have \"... =  proots_count p (poly q ` s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p) =\n    proots_count p (poly q ` s)", "unfolding proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p) =\n    (\\<Sum>r\\<in>proots_within p (poly q ` s). order r p)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>proots_within p (poly q ` s). order x p) =\n  proots_count p (poly q ` s)\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "finally"], ["proof (chain)\npicking this:\n  proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)", "."], ["proof (state)\nthis:\n  proots_count (p \\<circ>\\<^sub>p q) s = proots_count p (poly q ` s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Composition of a polynomial and a rational function\\<close>"], ["", "(*composition of a polynomial and a rational function. Maybe a more general version in the future?*)"], ["", "definition fcompose::\"'a ::field poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly\" where\n  \"fcompose p q r = fst (fold_coeffs (\\<lambda>a (c,d). (d*[:a:] + q * c,r*d)) p (0,1))\""], ["", "lemma fcompose_0 [simp]: \"fcompose 0 q r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose 0 q r = 0", "by (simp add: fcompose_def)"], ["", "lemma fcompose_const[simp]:\"fcompose [:a:] q r = [:a:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose [:a:] q r = [:a:]", "unfolding fcompose_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fold_coeffs (\\<lambda>a (c, d). (d * [:a:] + q * c, r * d)) [:a:]\n          (0, 1)) =\n    [:a:]", "by (cases \"a=0\") auto"], ["", "lemma fcompose_pCons: \n  \"fcompose (pCons a p) q1 q2 = smult a (q2^(degree (pCons a p))) + q1 * fcompose p q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "define ff where \"ff=(\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d))\""], ["proof (state)\nthis:\n  ff = (\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "define fc where \"fc=fold_coeffs ff p (0, 1)\""], ["proof (state)\nthis:\n  fc = fold_coeffs ff p (0, 1)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "have snd_ff:\"snd fc = (if p=0 then 1 else q2^(degree p + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd fc = (if p = 0 then 1 else q2 ^ (degree p + 1))", "unfolding fc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fold_coeffs ff p (0, 1)) =\n    (if p = 0 then 1 else q2 ^ (degree p + 1))", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd (fold_coeffs ff 0 (0, 1)) =\n    (if 0 = 0 then 1 else q2 ^ (degree 0 + 1))\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        snd (fold_coeffs ff p (0, 1)) =\n        (if p = 0 then 1 else q2 ^ (degree p + 1))\\<rbrakk>\n       \\<Longrightarrow> snd (fold_coeffs ff (pCons a p) (0, 1)) =\n                         (if pCons a p = 0 then 1\n                          else q2 ^ (degree (pCons a p) + 1))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fold_coeffs ff 0 (0, 1)) =\n    (if 0 = 0 then 1 else q2 ^ (degree 0 + 1))", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        snd (fold_coeffs ff p (0, 1)) =\n        (if p = 0 then 1 else q2 ^ (degree p + 1))\\<rbrakk>\n       \\<Longrightarrow> snd (fold_coeffs ff (pCons a p) (0, 1)) =\n                         (if pCons a p = 0 then 1\n                          else q2 ^ (degree (pCons a p) + 1))", "subgoal for a p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n     snd (fold_coeffs ff p (0, 1)) =\n     (if p = 0 then 1 else q2 ^ (degree p + 1))\\<rbrakk>\n    \\<Longrightarrow> snd (fold_coeffs ff (pCons a p) (0, 1)) =\n                      (if pCons a p = 0 then 1\n                       else q2 ^ (degree (pCons a p) + 1))", "by (auto simp add:ff_def split:if_splits prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  snd fc = (if p = 0 then 1 else q2 ^ (degree p + 1))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "have \"fcompose (pCons a p) q1 q2 = fst (fold_coeffs ff (pCons a p) (0, 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons a p) q1 q2 = fst (fold_coeffs ff (pCons a p) (0, 1))", "unfolding fcompose_def ff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fold_coeffs (\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d))\n          (pCons a p) (0, 1)) =\n    fst (fold_coeffs (\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d))\n          (pCons a p) (0, 1))", "by simp"], ["proof (state)\nthis:\n  fcompose (pCons a p) q1 q2 = fst (fold_coeffs ff (pCons a p) (0, 1))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "also"], ["proof (state)\nthis:\n  fcompose (pCons a p) q1 q2 = fst (fold_coeffs ff (pCons a p) (0, 1))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "have \"... = fst (ff a fc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fold_coeffs ff (pCons a p) (0, 1)) = fst (ff a fc)", "using False"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fst (fold_coeffs ff (pCons a p) (0, 1)) = fst (ff a fc)", "unfolding fc_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fst (fold_coeffs ff (pCons a p) (0, 1)) =\n    fst (ff a (fold_coeffs ff p (0, 1)))", "by auto"], ["proof (state)\nthis:\n  fst (fold_coeffs ff (pCons a p) (0, 1)) = fst (ff a fc)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "also"], ["proof (state)\nthis:\n  fst (fold_coeffs ff (pCons a p) (0, 1)) = fst (ff a fc)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "have \"... = snd fc * [:a:] + q1 * fst fc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (ff a fc) = snd fc * [:a:] + q1 * fst fc", "unfolding ff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (case fc of (c, d) \\<Rightarrow> (d * [:a:] + q1 * c, q2 * d)) =\n    snd fc * [:a:] + q1 * fst fc", "by (auto split:prod.splits)"], ["proof (state)\nthis:\n  fst (ff a fc) = snd fc * [:a:] + q1 * fst fc\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "also"], ["proof (state)\nthis:\n  fst (ff a fc) = snd fc * [:a:] + q1 * fst fc\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "have \"... = smult a (q2^(degree (pCons a p))) + q1 * fst fc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd fc * [:a:] + q1 * fst fc =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fst fc", "using snd_ff False"], ["proof (prove)\nusing this:\n  snd fc = (if p = 0 then 1 else q2 ^ (degree p + 1))\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd fc * [:a:] + q1 * fst fc =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fst fc", "by auto"], ["proof (state)\nthis:\n  snd fc * [:a:] + q1 * fst fc =\n  smult a (q2 ^ degree (pCons a p)) + q1 * fst fc\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "also"], ["proof (state)\nthis:\n  snd fc * [:a:] + q1 * fst fc =\n  smult a (q2 ^ degree (pCons a p)) + q1 * fst fc\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "have \"... = smult a (q2^(degree (pCons a p))) + q1 * fcompose p q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult a (q2 ^ degree (pCons a p)) + q1 * fst fc =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "unfolding fc_def ff_def fcompose_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult a (q2 ^ degree (pCons a p)) +\n    q1 *\n    fst (fold_coeffs (\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d)) p\n          (0, 1)) =\n    smult a (q2 ^ degree (pCons a p)) +\n    q1 *\n    fst (fold_coeffs (\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d)) p\n          (0, 1))", "by simp"], ["proof (state)\nthis:\n  smult a (q2 ^ degree (pCons a p)) + q1 * fst fc =\n  smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "finally"], ["proof (chain)\npicking this:\n  fcompose (pCons a p) q1 q2 =\n  smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "show ?thesis"], ["proof (prove)\nusing this:\n  fcompose (pCons a p) q1 q2 =\n  smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "."], ["proof (state)\nthis:\n  fcompose (pCons a p) q1 q2 =\n  smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    fcompose (pCons a p) q1 q2 =\n    smult a (q2 ^ degree (pCons a p)) + q1 * fcompose p q1 q2", "qed simp"], ["", "lemma fcompose_uminus:\n  \"fcompose (-p) q r = - fcompose p q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (- p) q r = - fcompose p q r", "by (induct p) (auto simp:fcompose_pCons)"], ["", "lemma fcompose_add_less:\n  assumes \"degree p1 > degree p2\"\n  shows \"fcompose (p1+p2) q1 q2 \n            = fcompose p1 q1 q2 + q2^(degree p1-degree p2) * fcompose p2 q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (p1 + p2) q1 q2 =\n    fcompose p1 q1 q2 + q2 ^ (degree p1 - degree p2) * fcompose p2 q1 q2", "using assms"], ["proof (prove)\nusing this:\n  degree p2 < degree p1\n\ngoal (1 subgoal):\n 1. fcompose (p1 + p2) q1 q2 =\n    fcompose p1 q1 q2 + q2 ^ (degree p1 - degree p2) * fcompose p2 q1 q2", "proof (induction p1 p2 rule: poly_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. degree 0 < degree 0 \\<Longrightarrow>\n    fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + q2 ^ (degree 0 - degree 0) * fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree q < degree p \\<Longrightarrow>\n                fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 +\n                q2 ^ (degree p - degree q) * fcompose q q1 q2;\n        degree (pCons b q) < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         q2 ^ (degree (pCons a p) - degree (pCons b q)) *\n                         fcompose (pCons b q) q1 q2", "case (pCons a1 p1 a2 p2)"], ["proof (state)\nthis:\n  degree p2 < degree p1 \\<Longrightarrow>\n  fcompose (p1 + p2) q1 q2 =\n  fcompose p1 q1 q2 + q2 ^ (degree p1 - degree p2) * fcompose p2 q1 q2\n  degree (pCons a2 p2) < degree (pCons a1 p1)\n\ngoal (2 subgoals):\n 1. degree 0 < degree 0 \\<Longrightarrow>\n    fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + q2 ^ (degree 0 - degree 0) * fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree q < degree p \\<Longrightarrow>\n                fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 +\n                q2 ^ (degree p - degree q) * fcompose q q1 q2;\n        degree (pCons b q) < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         q2 ^ (degree (pCons a p) - degree (pCons b q)) *\n                         fcompose (pCons b q) q1 q2", "have ?case when \"p2=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "using that"], ["proof (prove)\nusing this:\n  p2 = 0\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "by (simp add:fcompose_pCons smult_add_left)"], ["proof (state)\nthis:\n  p2 = 0 \\<Longrightarrow>\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 +\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n  fcompose (pCons a2 p2) q1 q2\n\ngoal (2 subgoals):\n 1. degree 0 < degree 0 \\<Longrightarrow>\n    fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + q2 ^ (degree 0 - degree 0) * fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree q < degree p \\<Longrightarrow>\n                fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 +\n                q2 ^ (degree p - degree q) * fcompose q q1 q2;\n        degree (pCons b q) < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         q2 ^ (degree (pCons a p) - degree (pCons b q)) *\n                         fcompose (pCons b q) q1 q2", "moreover"], ["proof (state)\nthis:\n  p2 = 0 \\<Longrightarrow>\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 +\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n  fcompose (pCons a2 p2) q1 q2\n\ngoal (2 subgoals):\n 1. degree 0 < degree 0 \\<Longrightarrow>\n    fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + q2 ^ (degree 0 - degree 0) * fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree q < degree p \\<Longrightarrow>\n                fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 +\n                q2 ^ (degree p - degree q) * fcompose q q1 q2;\n        degree (pCons b q) < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         q2 ^ (degree (pCons a p) - degree (pCons b q)) *\n                         fcompose (pCons b q) q1 q2", "have ?case when \"p2\\<noteq>0\" \"\\<not> degree p2 < degree p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "using that pCons(2)"], ["proof (prove)\nusing this:\n  p2 \\<noteq> 0\n  \\<not> degree p2 < degree p1\n  degree (pCons a2 p2) < degree (pCons a1 p1)\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>p2 \\<noteq> 0; \\<not> degree p2 < degree p1\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n                    fcompose (pCons a1 p1) q1 q2 +\n                    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n                    fcompose (pCons a2 p2) q1 q2\n\ngoal (2 subgoals):\n 1. degree 0 < degree 0 \\<Longrightarrow>\n    fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + q2 ^ (degree 0 - degree 0) * fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree q < degree p \\<Longrightarrow>\n                fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 +\n                q2 ^ (degree p - degree q) * fcompose q q1 q2;\n        degree (pCons b q) < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         q2 ^ (degree (pCons a p) - degree (pCons b q)) *\n                         fcompose (pCons b q) q1 q2", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>p2 \\<noteq> 0; \\<not> degree p2 < degree p1\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n                    fcompose (pCons a1 p1) q1 q2 +\n                    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n                    fcompose (pCons a2 p2) q1 q2\n\ngoal (2 subgoals):\n 1. degree 0 < degree 0 \\<Longrightarrow>\n    fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + q2 ^ (degree 0 - degree 0) * fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree q < degree p \\<Longrightarrow>\n                fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 +\n                q2 ^ (degree p - degree q) * fcompose q q1 q2;\n        degree (pCons b q) < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         q2 ^ (degree (pCons a p) - degree (pCons b q)) *\n                         fcompose (pCons b q) q1 q2", "have ?case when \"p2\\<noteq>0\" \"degree p2< degree p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "define d1 d2 where \"d1=degree (pCons a1 p1)\" and \"d2=degree (pCons a2 p2) \""], ["proof (state)\nthis:\n  d1 = degree (pCons a1 p1)\n  d2 = degree (pCons a2 p2)\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "define fp1 fp2 where \"fp1= fcompose p1 q1 q2\" and \"fp2=fcompose p2 q1 q2\""], ["proof (state)\nthis:\n  fp1 = fcompose p1 q1 q2\n  fp2 = fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "have \"fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 \n            = fcompose (pCons (a1+a2) (p1+p2)) q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2", "by simp"], ["proof (state)\nthis:\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "also"], ["proof (state)\nthis:\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "have \"... = smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2", "have \"degree (pCons (a1 + a2) (p1 + p2)) = d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pCons (a1 + a2) (p1 + p2)) = d1", "unfolding d1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pCons (a1 + a2) (p1 + p2)) = degree (pCons a1 p1)", "using that degree_add_eq_left"], ["proof (prove)\nusing this:\n  p2 \\<noteq> 0\n  degree p2 < degree p1\n  degree ?q < degree ?p \\<Longrightarrow> degree (?p + ?q) = degree ?p\n\ngoal (1 subgoal):\n 1. degree (pCons (a1 + a2) (p1 + p2)) = degree (pCons a1 p1)", "by fastforce"], ["proof (state)\nthis:\n  degree (pCons (a1 + a2) (p1 + p2)) = d1\n\ngoal (1 subgoal):\n 1. fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2", "then"], ["proof (chain)\npicking this:\n  degree (pCons (a1 + a2) (p1 + p2)) = d1", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (pCons (a1 + a2) (p1 + p2)) = d1\n\ngoal (1 subgoal):\n 1. fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2", "unfolding fcompose_pCons"], ["proof (prove)\nusing this:\n  degree (pCons (a1 + a2) (p1 + p2)) = d1\n\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ degree (pCons (a1 + a2) (p1 + p2))) +\n    q1 * fcompose (p1 + p2) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2", "by simp"], ["proof (state)\nthis:\n  fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n  smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n  smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "also"], ["proof (state)\nthis:\n  fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n  smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "have \"... = smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2)", "have \"degree p1 - degree p2 = d1 - d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p1 - degree p2 = d1 - d2", "unfolding d1_def d2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p1 - degree p2 = degree (pCons a1 p1) - degree (pCons a2 p2)", "using that"], ["proof (prove)\nusing this:\n  p2 \\<noteq> 0\n  degree p2 < degree p1\n\ngoal (1 subgoal):\n 1. degree p1 - degree p2 = degree (pCons a1 p1) - degree (pCons a2 p2)", "by simp"], ["proof (state)\nthis:\n  degree p1 - degree p2 = d1 - d2\n\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2)", "then"], ["proof (chain)\npicking this:\n  degree p1 - degree p2 = d1 - d2", "show ?thesis"], ["proof (prove)\nusing this:\n  degree p1 - degree p2 = d1 - d2\n\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2)", "unfolding pCons(1)[OF that(2),folded fp1_def fp2_def]"], ["proof (prove)\nusing this:\n  degree p1 - degree p2 = d1 - d2\n\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) +\n    q1 * (fp1 + q2 ^ (degree p1 - degree p2) * fp2) =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2)", "by simp"], ["proof (state)\nthis:\n  smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2 =\n  smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2 =\n  smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2)\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "also"], ["proof (state)\nthis:\n  smult (a1 + a2) (q2 ^ d1) + q1 * fcompose (p1 + p2) q1 q2 =\n  smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2)\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "have \"... = fcompose (pCons a1 p1) q1 q2 + q2 ^ (d1 - d2) \n                        * fcompose (pCons a2 p2) q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2) =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (d1 - d2) * fcompose (pCons a2 p2) q1 q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2) =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (d1 - d2) * fcompose (pCons a2 p2) q1 q2", "have \"d1 > d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d2 < d1", "unfolding d1_def d2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pCons a2 p2) < degree (pCons a1 p1)", "using that"], ["proof (prove)\nusing this:\n  p2 \\<noteq> 0\n  degree p2 < degree p1\n\ngoal (1 subgoal):\n 1. degree (pCons a2 p2) < degree (pCons a1 p1)", "by auto"], ["proof (state)\nthis:\n  d2 < d1\n\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2) =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (d1 - d2) * fcompose (pCons a2 p2) q1 q2", "then"], ["proof (chain)\npicking this:\n  d2 < d1", "show ?thesis"], ["proof (prove)\nusing this:\n  d2 < d1\n\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2) =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (d1 - d2) * fcompose (pCons a2 p2) q1 q2", "unfolding fcompose_pCons"], ["proof (prove)\nusing this:\n  d2 < d1\n\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2) =\n    smult a1 (q2 ^ degree (pCons a1 p1)) + q1 * fcompose p1 q1 q2 +\n    q2 ^ (d1 - d2) *\n    (smult a2 (q2 ^ degree (pCons a2 p2)) + q1 * fcompose p2 q1 q2)", "apply (fold d1_def d2_def fp1_def fp2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. d2 < d1 \\<Longrightarrow>\n    smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2) =\n    smult a1 (q2 ^ d1) + q1 * fp1 +\n    q2 ^ (d1 - d2) * (smult a2 (q2 ^ d2) + q1 * fp2)", "by (simp add:algebra_simps smult_add_left power_add[symmetric])"], ["proof (state)\nthis:\n  smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2) =\n  fcompose (pCons a1 p1) q1 q2 +\n  q2 ^ (d1 - d2) * fcompose (pCons a2 p2) q1 q2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + q2 ^ (d1 - d2) * fp2) =\n  fcompose (pCons a1 p1) q1 q2 +\n  q2 ^ (d1 - d2) * fcompose (pCons a2 p2) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "finally"], ["proof (chain)\npicking this:\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 +\n  q2 ^ (d1 - d2) * fcompose (pCons a2 p2) q1 q2", "show ?thesis"], ["proof (prove)\nusing this:\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 +\n  q2 ^ (d1 - d2) * fcompose (pCons a2 p2) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "unfolding d1_def d2_def"], ["proof (prove)\nusing this:\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 +\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n  fcompose (pCons a2 p2) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "."], ["proof (state)\nthis:\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 +\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n  fcompose (pCons a2 p2) q1 q2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p2 \\<noteq> 0; degree p2 < degree p1\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n                    fcompose (pCons a1 p1) q1 q2 +\n                    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n                    fcompose (pCons a2 p2) q1 q2\n\ngoal (2 subgoals):\n 1. degree 0 < degree 0 \\<Longrightarrow>\n    fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + q2 ^ (degree 0 - degree 0) * fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree q < degree p \\<Longrightarrow>\n                fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 +\n                q2 ^ (degree p - degree q) * fcompose q q1 q2;\n        degree (pCons b q) < degree (pCons a p)\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         q2 ^ (degree (pCons a p) - degree (pCons b q)) *\n                         fcompose (pCons b q) q1 q2", "ultimately"], ["proof (chain)\npicking this:\n  p2 = 0 \\<Longrightarrow>\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 +\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n  fcompose (pCons a2 p2) q1 q2\n  \\<lbrakk>p2 \\<noteq> 0; \\<not> degree p2 < degree p1\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n                    fcompose (pCons a1 p1) q1 q2 +\n                    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n                    fcompose (pCons a2 p2) q1 q2\n  \\<lbrakk>p2 \\<noteq> 0; degree p2 < degree p1\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n                    fcompose (pCons a1 p1) q1 q2 +\n                    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n                    fcompose (pCons a2 p2) q1 q2", "show ?case"], ["proof (prove)\nusing this:\n  p2 = 0 \\<Longrightarrow>\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 +\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n  fcompose (pCons a2 p2) q1 q2\n  \\<lbrakk>p2 \\<noteq> 0; \\<not> degree p2 < degree p1\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n                    fcompose (pCons a1 p1) q1 q2 +\n                    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n                    fcompose (pCons a2 p2) q1 q2\n  \\<lbrakk>p2 \\<noteq> 0; degree p2 < degree p1\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n                    fcompose (pCons a1 p1) q1 q2 +\n                    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n                    fcompose (pCons a2 p2) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 +\n    q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n    fcompose (pCons a2 p2) q1 q2", "by blast"], ["proof (state)\nthis:\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 +\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a2 p2)) *\n  fcompose (pCons a2 p2) q1 q2\n\ngoal (1 subgoal):\n 1. degree 0 < degree 0 \\<Longrightarrow>\n    fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + q2 ^ (degree 0 - degree 0) * fcompose 0 q1 q2", "qed simp"], ["", "lemma fcompose_add_eq:\n  assumes \"degree p1 = degree p2\"\n  shows \"q2^(degree p1 - degree (p1+p2)) * fcompose (p1+p2) q1 q2 \n            = fcompose p1 q1 q2 + fcompose p2 q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 ^ (degree p1 - degree (p1 + p2)) * fcompose (p1 + p2) q1 q2 =\n    fcompose p1 q1 q2 + fcompose p2 q1 q2", "using assms"], ["proof (prove)\nusing this:\n  degree p1 = degree p2\n\ngoal (1 subgoal):\n 1. q2 ^ (degree p1 - degree (p1 + p2)) * fcompose (p1 + p2) q1 q2 =\n    fcompose p1 q1 q2 + fcompose p2 q1 q2", "proof (induction p1 p2 rule: poly_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. degree 0 = degree 0 \\<Longrightarrow>\n    q2 ^ (degree 0 - degree (0 + 0)) * fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree p = degree q \\<Longrightarrow>\n                q2 ^ (degree p - degree (p + q)) * fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 + fcompose q q1 q2;\n        degree (pCons a p) = degree (pCons b q)\\<rbrakk>\n       \\<Longrightarrow> q2 ^\n                         (degree (pCons a p) -\n                          degree (pCons a p + pCons b q)) *\n                         fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         fcompose (pCons b q) q1 q2", "case (pCons a1 p1 a2 p2)"], ["proof (state)\nthis:\n  degree p1 = degree p2 \\<Longrightarrow>\n  q2 ^ (degree p1 - degree (p1 + p2)) * fcompose (p1 + p2) q1 q2 =\n  fcompose p1 q1 q2 + fcompose p2 q1 q2\n  degree (pCons a1 p1) = degree (pCons a2 p2)\n\ngoal (2 subgoals):\n 1. degree 0 = degree 0 \\<Longrightarrow>\n    q2 ^ (degree 0 - degree (0 + 0)) * fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree p = degree q \\<Longrightarrow>\n                q2 ^ (degree p - degree (p + q)) * fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 + fcompose q q1 q2;\n        degree (pCons a p) = degree (pCons b q)\\<rbrakk>\n       \\<Longrightarrow> q2 ^\n                         (degree (pCons a p) -\n                          degree (pCons a p + pCons b q)) *\n                         fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         fcompose (pCons b q) q1 q2", "have ?case when \"p1+p2=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "have \"p2=-p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p2 = - p1", "using that"], ["proof (prove)\nusing this:\n  p1 + p2 = 0\n\ngoal (1 subgoal):\n 1. p2 = - p1", "by algebra"], ["proof (state)\nthis:\n  p2 = - p1\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "then"], ["proof (chain)\npicking this:\n  p2 = - p1", "show ?thesis"], ["proof (prove)\nusing this:\n  p2 = - p1\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "by (simp add:fcompose_pCons fcompose_uminus smult_add_left)"], ["proof (state)\nthis:\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 + p2 = 0 \\<Longrightarrow>\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n\ngoal (2 subgoals):\n 1. degree 0 = degree 0 \\<Longrightarrow>\n    q2 ^ (degree 0 - degree (0 + 0)) * fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree p = degree q \\<Longrightarrow>\n                q2 ^ (degree p - degree (p + q)) * fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 + fcompose q q1 q2;\n        degree (pCons a p) = degree (pCons b q)\\<rbrakk>\n       \\<Longrightarrow> q2 ^\n                         (degree (pCons a p) -\n                          degree (pCons a p + pCons b q)) *\n                         fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         fcompose (pCons b q) q1 q2", "moreover"], ["proof (state)\nthis:\n  p1 + p2 = 0 \\<Longrightarrow>\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n\ngoal (2 subgoals):\n 1. degree 0 = degree 0 \\<Longrightarrow>\n    q2 ^ (degree 0 - degree (0 + 0)) * fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree p = degree q \\<Longrightarrow>\n                q2 ^ (degree p - degree (p + q)) * fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 + fcompose q q1 q2;\n        degree (pCons a p) = degree (pCons b q)\\<rbrakk>\n       \\<Longrightarrow> q2 ^\n                         (degree (pCons a p) -\n                          degree (pCons a p + pCons b q)) *\n                         fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         fcompose (pCons b q) q1 q2", "have ?case when \"p1=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "have \"p2=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p2 = 0", "using pCons(2) that"], ["proof (prove)\nusing this:\n  degree (pCons a1 p1) = degree (pCons a2 p2)\n  p1 = 0\n\ngoal (1 subgoal):\n 1. p2 = 0", "by (auto split:if_splits)"], ["proof (state)\nthis:\n  p2 = 0\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "then"], ["proof (chain)\npicking this:\n  p2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p2 = 0\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "using that"], ["proof (prove)\nusing this:\n  p2 = 0\n  p1 = 0\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "by simp"], ["proof (state)\nthis:\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 = 0 \\<Longrightarrow>\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n\ngoal (2 subgoals):\n 1. degree 0 = degree 0 \\<Longrightarrow>\n    q2 ^ (degree 0 - degree (0 + 0)) * fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree p = degree q \\<Longrightarrow>\n                q2 ^ (degree p - degree (p + q)) * fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 + fcompose q q1 q2;\n        degree (pCons a p) = degree (pCons b q)\\<rbrakk>\n       \\<Longrightarrow> q2 ^\n                         (degree (pCons a p) -\n                          degree (pCons a p + pCons b q)) *\n                         fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         fcompose (pCons b q) q1 q2", "moreover"], ["proof (state)\nthis:\n  p1 = 0 \\<Longrightarrow>\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n\ngoal (2 subgoals):\n 1. degree 0 = degree 0 \\<Longrightarrow>\n    q2 ^ (degree 0 - degree (0 + 0)) * fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree p = degree q \\<Longrightarrow>\n                q2 ^ (degree p - degree (p + q)) * fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 + fcompose q q1 q2;\n        degree (pCons a p) = degree (pCons b q)\\<rbrakk>\n       \\<Longrightarrow> q2 ^\n                         (degree (pCons a p) -\n                          degree (pCons a p + pCons b q)) *\n                         fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         fcompose (pCons b q) q1 q2", "have ?case when \"p1\\<noteq>0\" \"p1+p2\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "define d1 d2 dp where \"d1=degree (pCons a1 p1)\" and \"d2=degree (pCons a2 p2)\"\n                            and \"dp = degree p1 - degree (p1+p2)\""], ["proof (state)\nthis:\n  d1 = degree (pCons a1 p1)\n  d2 = degree (pCons a2 p2)\n  dp = degree p1 - degree (p1 + p2)\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "define fp1 fp2 where \"fp1= fcompose p1 q1 q2\" and \"fp2=fcompose p2 q1 q2\""], ["proof (state)\nthis:\n  fp1 = fcompose p1 q1 q2\n  fp2 = fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "have \"q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n             fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 \n                = q2 ^ dp * fcompose (pCons (a1+a2) (p1 +p2)) q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    q2 ^ dp * fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2", "unfolding dp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    q2 ^ (degree p1 - degree (p1 + p2)) *\n    fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2", "using that"], ["proof (prove)\nusing this:\n  p1 \\<noteq> 0\n  p1 + p2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    q2 ^ (degree p1 - degree (p1 + p2)) *\n    fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2", "by auto"], ["proof (state)\nthis:\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  q2 ^ dp * fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "also"], ["proof (state)\nthis:\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  q2 ^ dp * fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "have \"... = smult (a1 + a2) (q2 ^ d1) + q1 * (q2 ^ dp * fcompose (p1 + p2) q1 q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 ^ dp * fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (q2 ^ dp * fcompose (p1 + p2) q1 q2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q2 ^ dp * fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (q2 ^ dp * fcompose (p1 + p2) q1 q2)", "have \"degree p1 \\<ge> degree (p1 + p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p1 + p2) \\<le> degree p1", "by (metis degree_add_le degree_pCons_eq_if not_less_eq_eq order_refl pCons.prems zero_le)"], ["proof (state)\nthis:\n  degree (p1 + p2) \\<le> degree p1\n\ngoal (1 subgoal):\n 1. q2 ^ dp * fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (q2 ^ dp * fcompose (p1 + p2) q1 q2)", "then"], ["proof (chain)\npicking this:\n  degree (p1 + p2) \\<le> degree p1", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (p1 + p2) \\<le> degree p1\n\ngoal (1 subgoal):\n 1. q2 ^ dp * fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (q2 ^ dp * fcompose (p1 + p2) q1 q2)", "unfolding fcompose_pCons dp_def d1_def"], ["proof (prove)\nusing this:\n  degree (p1 + p2) \\<le> degree p1\n\ngoal (1 subgoal):\n 1. q2 ^ (degree p1 - degree (p1 + p2)) *\n    (smult (a1 + a2) (q2 ^ degree (pCons (a1 + a2) (p1 + p2))) +\n     q1 * fcompose (p1 + p2) q1 q2) =\n    smult (a1 + a2) (q2 ^ degree (pCons a1 p1)) +\n    q1 * (q2 ^ (degree p1 - degree (p1 + p2)) * fcompose (p1 + p2) q1 q2)", "using that"], ["proof (prove)\nusing this:\n  degree (p1 + p2) \\<le> degree p1\n  p1 \\<noteq> 0\n  p1 + p2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q2 ^ (degree p1 - degree (p1 + p2)) *\n    (smult (a1 + a2) (q2 ^ degree (pCons (a1 + a2) (p1 + p2))) +\n     q1 * fcompose (p1 + p2) q1 q2) =\n    smult (a1 + a2) (q2 ^ degree (pCons a1 p1)) +\n    q1 * (q2 ^ (degree p1 - degree (p1 + p2)) * fcompose (p1 + p2) q1 q2)", "by (simp add:algebra_simps power_add[symmetric])"], ["proof (state)\nthis:\n  q2 ^ dp * fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n  smult (a1 + a2) (q2 ^ d1) + q1 * (q2 ^ dp * fcompose (p1 + p2) q1 q2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q2 ^ dp * fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n  smult (a1 + a2) (q2 ^ d1) + q1 * (q2 ^ dp * fcompose (p1 + p2) q1 q2)\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "also"], ["proof (state)\nthis:\n  q2 ^ dp * fcompose (pCons (a1 + a2) (p1 + p2)) q1 q2 =\n  smult (a1 + a2) (q2 ^ d1) + q1 * (q2 ^ dp * fcompose (p1 + p2) q1 q2)\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "have \"... =  smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (q2 ^ dp * fcompose (p1 + p2) q1 q2) =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2)", "apply (subst pCons(1)[folded dp_def fp1_def fp2_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree p1 = degree p2\n 2. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2) =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p1 = degree p2", "by (metis degree_pCons_eq_if diff_Suc_Suc diff_zero not_less_eq_eq pCons.prems zero_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2) =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2) =\n    smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  smult (a1 + a2) (q2 ^ d1) + q1 * (q2 ^ dp * fcompose (p1 + p2) q1 q2) =\n  smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2)\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "also"], ["proof (state)\nthis:\n  smult (a1 + a2) (q2 ^ d1) + q1 * (q2 ^ dp * fcompose (p1 + p2) q1 q2) =\n  smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2)\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "have \"... = fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2) =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2) =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "have *:\"d1 = degree (pCons a2 p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d1 = degree (pCons a2 p2)", "unfolding d1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pCons a1 p1) = degree (pCons a2 p2)", "using pCons(2)"], ["proof (prove)\nusing this:\n  degree (pCons a1 p1) = degree (pCons a2 p2)\n\ngoal (1 subgoal):\n 1. degree (pCons a1 p1) = degree (pCons a2 p2)", "by simp"], ["proof (state)\nthis:\n  d1 = degree (pCons a2 p2)\n\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2) =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2) =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "unfolding fcompose_pCons"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2) =\n    smult a1 (q2 ^ degree (pCons a1 p1)) + q1 * fcompose p1 q1 q2 +\n    (smult a2 (q2 ^ degree (pCons a2 p2)) + q1 * fcompose p2 q1 q2)", "apply (fold d1_def fp1_def fp2_def *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2) =\n    smult a1 (q2 ^ d1) + q1 * fp1 + (smult a2 (q2 ^ d1) + q1 * fp2)", "by (simp add:smult_add_left algebra_simps)"], ["proof (state)\nthis:\n  smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2) =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  smult (a1 + a2) (q2 ^ d1) + q1 * (fp1 + fp2) =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "finally"], ["proof (chain)\npicking this:\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "show ?thesis"], ["proof (prove)\nusing this:\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "."], ["proof (state)\nthis:\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p1 \\<noteq> 0; p1 + p2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q2 ^\n                    (degree (pCons a1 p1) -\n                     degree (pCons a1 p1 + pCons a2 p2)) *\n                    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n                    fcompose (pCons a1 p1) q1 q2 +\n                    fcompose (pCons a2 p2) q1 q2\n\ngoal (2 subgoals):\n 1. degree 0 = degree 0 \\<Longrightarrow>\n    q2 ^ (degree 0 - degree (0 + 0)) * fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + fcompose 0 q1 q2\n 2. \\<And>a p b q.\n       \\<lbrakk>degree p = degree q \\<Longrightarrow>\n                q2 ^ (degree p - degree (p + q)) * fcompose (p + q) q1 q2 =\n                fcompose p q1 q2 + fcompose q q1 q2;\n        degree (pCons a p) = degree (pCons b q)\\<rbrakk>\n       \\<Longrightarrow> q2 ^\n                         (degree (pCons a p) -\n                          degree (pCons a p + pCons b q)) *\n                         fcompose (pCons a p + pCons b q) q1 q2 =\n                         fcompose (pCons a p) q1 q2 +\n                         fcompose (pCons b q) q1 q2", "ultimately"], ["proof (chain)\npicking this:\n  p1 + p2 = 0 \\<Longrightarrow>\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n  p1 = 0 \\<Longrightarrow>\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n  \\<lbrakk>p1 \\<noteq> 0; p1 + p2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q2 ^\n                    (degree (pCons a1 p1) -\n                     degree (pCons a1 p1 + pCons a2 p2)) *\n                    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n                    fcompose (pCons a1 p1) q1 q2 +\n                    fcompose (pCons a2 p2) q1 q2", "show ?case"], ["proof (prove)\nusing this:\n  p1 + p2 = 0 \\<Longrightarrow>\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n  p1 = 0 \\<Longrightarrow>\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n  \\<lbrakk>p1 \\<noteq> 0; p1 + p2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> q2 ^\n                    (degree (pCons a1 p1) -\n                     degree (pCons a1 p1 + pCons a2 p2)) *\n                    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n                    fcompose (pCons a1 p1) q1 q2 +\n                    fcompose (pCons a2 p2) q1 q2\n\ngoal (1 subgoal):\n 1. q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n    fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n    fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2", "by blast"], ["proof (state)\nthis:\n  q2 ^ (degree (pCons a1 p1) - degree (pCons a1 p1 + pCons a2 p2)) *\n  fcompose (pCons a1 p1 + pCons a2 p2) q1 q2 =\n  fcompose (pCons a1 p1) q1 q2 + fcompose (pCons a2 p2) q1 q2\n\ngoal (1 subgoal):\n 1. degree 0 = degree 0 \\<Longrightarrow>\n    q2 ^ (degree 0 - degree (0 + 0)) * fcompose (0 + 0) q1 q2 =\n    fcompose 0 q1 q2 + fcompose 0 q1 q2", "qed simp"], ["", "lemma fcompose_add_const:\n  \"fcompose ([:a:] + p) q1 q2 = smult a (q2 ^ degree p) + fcompose p q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose ([:a:] + p) q1 q2 = smult a (q2 ^ degree p) + fcompose p q1 q2", "apply (cases p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa q.\n       p = pCons aa q \\<Longrightarrow>\n       fcompose ([:a:] + p) q1 q2 =\n       smult a (q2 ^ degree p) + fcompose p q1 q2", "by (auto simp add:fcompose_pCons smult_add_left)"], ["", "lemma fcompose_smult: \"fcompose (smult a p) q1 q2 = smult a (fcompose p q1 q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (smult a p) q1 q2 = smult a (fcompose p q1 q2)", "by (induct p) (simp_all add:fcompose_pCons smult_add_right)"], ["", "lemma fcompose_mult: \"fcompose (p1*p2) q1 q2 = fcompose p1 q1 q2 * fcompose p2 q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (p1 * p2) q1 q2 = fcompose p1 q1 q2 * fcompose p2 q1 q2", "proof (induct p1)"], ["proof (state)\ngoal (2 subgoals):\n 1. fcompose (0 * p2) q1 q2 = fcompose 0 q1 q2 * fcompose p2 q1 q2\n 2. \\<And>a p1.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p1 \\<noteq> 0;\n        fcompose (p1 * p2) q1 q2 =\n        fcompose p1 q1 q2 * fcompose p2 q1 q2\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                         fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. fcompose (0 * p2) q1 q2 = fcompose 0 q1 q2 * fcompose p2 q1 q2\n 2. \\<And>a p1.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p1 \\<noteq> 0;\n        fcompose (p1 * p2) q1 q2 =\n        fcompose p1 q1 q2 * fcompose p2 q1 q2\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                         fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (0 * p2) q1 q2 = fcompose 0 q1 q2 * fcompose p2 q1 q2", "by simp"], ["proof (state)\nthis:\n  fcompose (0 * p2) q1 q2 = fcompose 0 q1 q2 * fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. \\<And>a p1.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p1 \\<noteq> 0;\n        fcompose (p1 * p2) q1 q2 =\n        fcompose p1 q1 q2 * fcompose p2 q1 q2\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                         fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p1.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p1 \\<noteq> 0;\n        fcompose (p1 * p2) q1 q2 =\n        fcompose p1 q1 q2 * fcompose p2 q1 q2\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                         fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "case (pCons a p1)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a) \\<or> p1 \\<noteq> 0\n  fcompose (p1 * p2) q1 q2 = fcompose p1 q1 q2 * fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. \\<And>a p1.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p1 \\<noteq> 0;\n        fcompose (p1 * p2) q1 q2 =\n        fcompose p1 q1 q2 * fcompose p2 q1 q2\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                         fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "have ?case when \"p1=0 \\<or> p2=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "using that"], ["proof (prove)\nusing this:\n  p1 = 0 \\<or> p2 = 0\n\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "by (auto simp add:fcompose_smult)"], ["proof (state)\nthis:\n  p1 = 0 \\<or> p2 = 0 \\<Longrightarrow>\n  fcompose (pCons a p1 * p2) q1 q2 =\n  fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. \\<And>a p1.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p1 \\<noteq> 0;\n        fcompose (p1 * p2) q1 q2 =\n        fcompose p1 q1 q2 * fcompose p2 q1 q2\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                         fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "moreover"], ["proof (state)\nthis:\n  p1 = 0 \\<or> p2 = 0 \\<Longrightarrow>\n  fcompose (pCons a p1 * p2) q1 q2 =\n  fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. \\<And>a p1.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p1 \\<noteq> 0;\n        fcompose (p1 * p2) q1 q2 =\n        fcompose p1 q1 q2 * fcompose p2 q1 q2\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                         fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "have ?case when \"p1\\<noteq>0\" \"p2\\<noteq>0\" \"a=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "using that"], ["proof (prove)\nusing this:\n  p1 \\<noteq> 0\n  p2 \\<noteq> 0\n  a = (0::'a)\n\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "by (simp add:fcompose_pCons pCons)"], ["proof (state)\nthis:\n  \\<lbrakk>p1 \\<noteq> 0; p2 \\<noteq> 0; a = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. \\<And>a p1.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p1 \\<noteq> 0;\n        fcompose (p1 * p2) q1 q2 =\n        fcompose p1 q1 q2 * fcompose p2 q1 q2\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                         fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>p1 \\<noteq> 0; p2 \\<noteq> 0; a = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. \\<And>a p1.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p1 \\<noteq> 0;\n        fcompose (p1 * p2) q1 q2 =\n        fcompose p1 q1 q2 * fcompose p2 q1 q2\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                         fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "have ?case when \"p1\\<noteq>0\" \"p2\\<noteq>0\" \"a\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "have \"fcompose (pCons a p1 * p2) q1 q2 \n            = fcompose (pCons 0 (p1 * p2) + smult a p2) q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2", "by (simp add:algebra_simps)"], ["proof (state)\nthis:\n  fcompose (pCons a p1 * p2) q1 q2 =\n  fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "also"], ["proof (state)\nthis:\n  fcompose (pCons a p1 * p2) q1 q2 =\n  fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "have \"... =  fcompose (pCons 0 (p1 * p2)) q1 q2 \n                        + q2 ^ (degree p1 +1) * fcompose (smult a p2) q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2 =\n    fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n    q2 ^ (degree p1 + 1) * fcompose (smult a p2) q1 q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2 =\n    fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n    q2 ^ (degree p1 + 1) * fcompose (smult a p2) q1 q2", "have \"degree (pCons 0 (p1 * p2)) > degree (smult a p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (smult a p2) < degree (pCons (0::'a) (p1 * p2))", "using that"], ["proof (prove)\nusing this:\n  p1 \\<noteq> 0\n  p2 \\<noteq> 0\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree (smult a p2) < degree (pCons (0::'a) (p1 * p2))", "by (simp add: degree_mult_eq)"], ["proof (state)\nthis:\n  degree (smult a p2) < degree (pCons (0::'a) (p1 * p2))\n\ngoal (1 subgoal):\n 1. fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2 =\n    fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n    q2 ^ (degree p1 + 1) * fcompose (smult a p2) q1 q2", "from fcompose_add_less[OF this,of q1 q2] that"], ["proof (chain)\npicking this:\n  fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2 =\n  fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n  q2 ^ (degree (pCons (0::'a) (p1 * p2)) - degree (smult a p2)) *\n  fcompose (smult a p2) q1 q2\n  p1 \\<noteq> 0\n  p2 \\<noteq> 0\n  a \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2 =\n  fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n  q2 ^ (degree (pCons (0::'a) (p1 * p2)) - degree (smult a p2)) *\n  fcompose (smult a p2) q1 q2\n  p1 \\<noteq> 0\n  p2 \\<noteq> 0\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2 =\n    fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n    q2 ^ (degree p1 + 1) * fcompose (smult a p2) q1 q2", "by (simp add:degree_mult_eq)"], ["proof (state)\nthis:\n  fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2 =\n  fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n  q2 ^ (degree p1 + 1) * fcompose (smult a p2) q1 q2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2 =\n  fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n  q2 ^ (degree p1 + 1) * fcompose (smult a p2) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "also"], ["proof (state)\nthis:\n  fcompose (pCons (0::'a) (p1 * p2) + smult a p2) q1 q2 =\n  fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n  q2 ^ (degree p1 + 1) * fcompose (smult a p2) q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "have \"... = fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n    q2 ^ (degree p1 + 1) * fcompose (smult a p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "using that"], ["proof (prove)\nusing this:\n  p1 \\<noteq> 0\n  p2 \\<noteq> 0\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n    q2 ^ (degree p1 + 1) * fcompose (smult a p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "by (simp add:fcompose_pCons fcompose_smult pCons algebra_simps)"], ["proof (state)\nthis:\n  fcompose (pCons (0::'a) (p1 * p2)) q1 q2 +\n  q2 ^ (degree p1 + 1) * fcompose (smult a p2) q1 q2 =\n  fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "finally"], ["proof (chain)\npicking this:\n  fcompose (pCons a p1 * p2) q1 q2 =\n  fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "show ?thesis"], ["proof (prove)\nusing this:\n  fcompose (pCons a p1 * p2) q1 q2 =\n  fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "."], ["proof (state)\nthis:\n  fcompose (pCons a p1 * p2) q1 q2 =\n  fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p1 \\<noteq> 0; p2 \\<noteq> 0; a \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. \\<And>a p1.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p1 \\<noteq> 0;\n        fcompose (p1 * p2) q1 q2 =\n        fcompose p1 q1 q2 * fcompose p2 q1 q2\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                         fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "ultimately"], ["proof (chain)\npicking this:\n  p1 = 0 \\<or> p2 = 0 \\<Longrightarrow>\n  fcompose (pCons a p1 * p2) q1 q2 =\n  fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n  \\<lbrakk>p1 \\<noteq> 0; p2 \\<noteq> 0; a = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n  \\<lbrakk>p1 \\<noteq> 0; p2 \\<noteq> 0; a \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "show ?case"], ["proof (prove)\nusing this:\n  p1 = 0 \\<or> p2 = 0 \\<Longrightarrow>\n  fcompose (pCons a p1 * p2) q1 q2 =\n  fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n  \\<lbrakk>p1 \\<noteq> 0; p2 \\<noteq> 0; a = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n  \\<lbrakk>p1 \\<noteq> 0; p2 \\<noteq> 0; a \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> fcompose (pCons a p1 * p2) q1 q2 =\n                    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n\ngoal (1 subgoal):\n 1. fcompose (pCons a p1 * p2) q1 q2 =\n    fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2", "by blast"], ["proof (state)\nthis:\n  fcompose (pCons a p1 * p2) q1 q2 =\n  fcompose (pCons a p1) q1 q2 * fcompose p2 q1 q2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fcompose_poly:\n  assumes \"poly q2 x\\<noteq>0\"\n  shows \"poly p (poly q1 x/poly q2 x) = poly (fcompose p q1 q2) x / poly (q2^(degree p)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (poly q1 x / poly q2 x) =\n    poly (fcompose p q1 q2) x / poly (q2 ^ degree p) x", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly 0 (poly q1 x / poly q2 x) =\n    poly (fcompose 0 q1 q2) x / poly (q2 ^ degree 0) x\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly p (poly q1 x / poly q2 x) =\n        poly (fcompose p q1 q2) x / poly (q2 ^ degree p) x\\<rbrakk>\n       \\<Longrightarrow> poly (pCons a p) (poly q1 x / poly q2 x) =\n                         poly (fcompose (pCons a p) q1 q2) x /\n                         poly (q2 ^ degree (pCons a p)) x", "using assms"], ["proof (prove)\nusing this:\n  poly q2 x \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. poly 0 (poly q1 x / poly q2 x) =\n    poly (fcompose 0 q1 q2) x / poly (q2 ^ degree 0) x\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly p (poly q1 x / poly q2 x) =\n        poly (fcompose p q1 q2) x / poly (q2 ^ degree p) x\\<rbrakk>\n       \\<Longrightarrow> poly (pCons a p) (poly q1 x / poly q2 x) =\n                         poly (fcompose (pCons a p) q1 q2) x /\n                         poly (q2 ^ degree (pCons a p)) x", "by (simp_all add:fcompose_pCons field_simps)"], ["", "lemma poly_fcompose:\n   assumes \"poly q2 x\\<noteq>0\"\n   shows \"poly (fcompose p q1 q2) x = poly p (poly q1 x/poly q2 x) * (poly q2 x)^(degree p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (fcompose p q1 q2) x =\n    poly p (poly q1 x / poly q2 x) * poly q2 x ^ degree p", "using fcompose_poly[OF assms] assms"], ["proof (prove)\nusing this:\n  poly ?p (poly ?q1.0 x / poly q2 x) =\n  poly (fcompose ?p ?q1.0 q2) x / poly (q2 ^ degree ?p) x\n  poly q2 x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly (fcompose p q1 q2) x =\n    poly p (poly q1 x / poly q2 x) * poly q2 x ^ degree p", "by (auto simp add:field_simps)"], ["", "lemma poly_fcompose_0_denominator:\n  assumes \"poly q2 x=0\"\n  shows \"poly (fcompose p q1 q2) x = poly q1 x ^ degree p * lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (fcompose p q1 q2) x = poly q1 x ^ degree p * lead_coeff p", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly (fcompose 0 q1 q2) x = poly q1 x ^ degree 0 * lead_coeff 0\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly (fcompose p q1 q2) x =\n        poly q1 x ^ degree p * lead_coeff p\\<rbrakk>\n       \\<Longrightarrow> poly (fcompose (pCons a p) q1 q2) x =\n                         poly q1 x ^ degree (pCons a p) *\n                         lead_coeff (pCons a p)", "using assms"], ["proof (prove)\nusing this:\n  poly q2 x = (0::'a)\n\ngoal (2 subgoals):\n 1. poly (fcompose 0 q1 q2) x = poly q1 x ^ degree 0 * lead_coeff 0\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly (fcompose p q1 q2) x =\n        poly q1 x ^ degree p * lead_coeff p\\<rbrakk>\n       \\<Longrightarrow> poly (fcompose (pCons a p) q1 q2) x =\n                         poly q1 x ^ degree (pCons a p) *\n                         lead_coeff (pCons a p)", "by (auto simp add:fcompose_pCons)"], ["", "lemma fcompose_0_denominator:\"fcompose p q1 0 = smult (lead_coeff p) (q1^degree p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose p q1 0 = smult (lead_coeff p) (q1 ^ degree p)", "apply (induct p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fcompose 0 q1 0 = smult (lead_coeff 0) (q1 ^ degree 0)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        fcompose p q1 0 = smult (lead_coeff p) (q1 ^ degree p)\\<rbrakk>\n       \\<Longrightarrow> fcompose (pCons a p) q1 0 =\n                         smult (lead_coeff (pCons a p))\n                          (q1 ^ degree (pCons a p))", "by (auto simp:fcompose_pCons)"], ["", "lemma fcompose_nzero:\n  fixes p::\"'a::field poly\"\n  assumes \"p\\<noteq>0\" and \"q2\\<noteq>0\" and nconst:\"\\<forall>c. q1 \\<noteq> smult c q2\"\n      and infi:\"infinite (UNIV::'a set)\"\n  shows \"fcompose p q1 q2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose p q1 q2 \\<noteq> 0", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fcompose p q1 q2 \\<noteq> 0", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> fcompose 0 q1 q2 \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "case 0"], ["proof (state)\nthis:\n  0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> fcompose 0 q1 q2 \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fcompose 0 q1 q2 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  fcompose 0 q1 q2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "have False when \"fcompose p q1 q2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "obtain x where \"poly q2 x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        poly q2 x \\<noteq> (0::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        poly q2 x \\<noteq> (0::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"finite (proots q2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots q2)", "using \\<open>q2\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (proots q2)", "by auto"], ["proof (state)\nthis:\n  finite (proots q2)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        poly q2 x \\<noteq> (0::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  finite (proots q2)", "have \"\\<exists>x. poly q2 x\\<noteq>0\""], ["proof (prove)\nusing this:\n  finite (proots q2)\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly q2 x \\<noteq> (0::'a)", "by (meson UNIV_I ex_new_if_finite infi proots_withinI)"], ["proof (state)\nthis:\n  \\<exists>x. poly q2 x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        poly q2 x \\<noteq> (0::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. poly q2 x \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x. poly q2 x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>x. poly q2 x \\<noteq> (0::'a)\n  poly q2 ?x \\<noteq> (0::'a) \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly q2 x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "define y where \"y = poly q1 x / poly q2 x\""], ["proof (state)\nthis:\n  y = poly q1 x / poly q2 x\n\ngoal (1 subgoal):\n 1. False", "have \"poly p y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p y = (0::'a)", "using \\<open>fcompose p q1 q2 = 0\\<close> fcompose_poly[OF \\<open>poly q2 x\\<noteq>0\\<close>,of p q1,folded y_def]"], ["proof (prove)\nusing this:\n  fcompose p q1 q2 = 0\n  poly p y = poly (fcompose p q1 q2) x / poly (q2 ^ degree p) x\n\ngoal (1 subgoal):\n 1. poly p y = (0::'a)", "by simp"], ["proof (state)\nthis:\n  poly p y = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  poly p y = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  poly p y = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using no_proots(1)"], ["proof (prove)\nusing this:\n  poly p y = (0::'a)\n  poly p ?a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fcompose p q1 q2 = 0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  fcompose p q1 q2 = 0 \\<Longrightarrow> False", "show ?case"], ["proof (prove)\nusing this:\n  fcompose p q1 q2 = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. fcompose p q1 q2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  fcompose p q1 q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "case (root a p)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0\n  [:- a, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "have \"fcompose [:- a, 1:] q1 q2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose [:- a, 1::'a:] q1 q2 \\<noteq> 0", "unfolding fcompose_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fold_coeffs (\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d))\n          [:- a, 1::'a:] (0, 1)) \\<noteq>\n    0", "using nconst[rule_format,of a]"], ["proof (prove)\nusing this:\n  q1 \\<noteq> smult a q2\n\ngoal (1 subgoal):\n 1. fst (fold_coeffs (\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d))\n          [:- a, 1::'a:] (0, 1)) \\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  fcompose [:- a, 1::'a:] q1 q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  fcompose [:- a, 1::'a:] q1 q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "have \"fcompose p q1 q2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose p q1 q2 \\<noteq> 0", "using root"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0\n  [:- a, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fcompose p q1 q2 \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  fcompose p q1 q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow> fcompose p q1 q2 \\<noteq> 0;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  fcompose [:- a, 1::'a:] q1 q2 \\<noteq> 0\n  fcompose p q1 q2 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  fcompose [:- a, 1::'a:] q1 q2 \\<noteq> 0\n  fcompose p q1 q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0", "unfolding fcompose_mult"], ["proof (prove)\nusing this:\n  fcompose [:- a, 1::'a:] q1 q2 \\<noteq> 0\n  fcompose p q1 q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fcompose [:- a, 1::'a:] q1 q2 * fcompose p q1 q2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  fcompose ([:- a, 1::'a:] * p) q1 q2 \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Bijection (@{term bij_betw}) and the number of polynomial roots\\<close>"], ["", "lemma proots_fcompose_bij_eq:\n  fixes p::\"'a::field poly\"\n  assumes bij:\"bij_betw (\\<lambda>x. poly q1 x/poly q2 x) A B\" and \"p\\<noteq>0\" \n      and nzero:\"\\<forall>x\\<in>A. poly q2 x\\<noteq>0\"\n      and max_deg: \"max (degree q1) (degree q2) \\<le> 1\"\n      and nconst:\"\\<forall>c. q1 \\<noteq> smult c q2\"\n      and infi:\"infinite (UNIV::'a set)\"\n  shows \"proots_count p B = proots_count (fcompose p q1 q2) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p B = proots_count (fcompose p q1 q2) A", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count p B = proots_count (fcompose p q1 q2) A", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    proots_count 0 B = proots_count (fcompose 0 q1 q2) A\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (fcompose p q1 q2) A\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "case 0"], ["proof (state)\nthis:\n  0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    proots_count 0 B = proots_count (fcompose 0 q1 q2) A\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (fcompose p q1 q2) A\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count 0 B = proots_count (fcompose 0 q1 q2) A", "by simp"], ["proof (state)\nthis:\n  proots_count 0 B = proots_count (fcompose 0 q1 q2) A\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (fcompose p q1 q2) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (fcompose p q1 q2) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (fcompose p q1 q2) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "have \"proots_count p B = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p B = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count p B = 0", "have \"proots_within p B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p B = {}", "using no_proots"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_within p B = {}", "by auto"], ["proof (state)\nthis:\n  proots_within p B = {}\n\ngoal (1 subgoal):\n 1. proots_count p B = 0", "then"], ["proof (chain)\npicking this:\n  proots_within p B = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within p B = {}\n\ngoal (1 subgoal):\n 1. proots_count p B = 0", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within p B = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p B. order r p) = 0", "by auto"], ["proof (state)\nthis:\n  proots_count p B = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count p B = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (fcompose p q1 q2) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "moreover"], ["proof (state)\nthis:\n  proots_count p B = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (fcompose p q1 q2) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "have \"proots_count (fcompose p q1 q2) A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (fcompose p q1 q2) A = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count (fcompose p q1 q2) A = 0", "have \"proots_within (fcompose p q1 q2) A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (fcompose p q1 q2) A = {}", "using no_proots"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_within (fcompose p q1 q2) A = {}", "unfolding proots_within_def"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x \\<in> A. poly (fcompose p q1 q2) x = (0::'a)} = {}", "by (smt div_0 empty_Collect_eq fcompose_poly nzero)"], ["proof (state)\nthis:\n  proots_within (fcompose p q1 q2) A = {}\n\ngoal (1 subgoal):\n 1. proots_count (fcompose p q1 q2) A = 0", "then"], ["proof (chain)\npicking this:\n  proots_within (fcompose p q1 q2) A = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within (fcompose p q1 q2) A = {}\n\ngoal (1 subgoal):\n 1. proots_count (fcompose p q1 q2) A = 0", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within (fcompose p q1 q2) A = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within (fcompose p q1 q2) A.\n       order r (fcompose p q1 q2)) =\n    0", "by auto"], ["proof (state)\nthis:\n  proots_count (fcompose p q1 q2) A = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count (fcompose p q1 q2) A = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (fcompose p q1 q2) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "ultimately"], ["proof (chain)\npicking this:\n  proots_count p B = 0\n  proots_count (fcompose p q1 q2) A = 0", "show ?case"], ["proof (prove)\nusing this:\n  proots_count p B = 0\n  proots_count (fcompose p q1 q2) A = 0\n\ngoal (1 subgoal):\n 1. proots_count p B = proots_count (fcompose p q1 q2) A", "by auto"], ["proof (state)\nthis:\n  proots_count p B = proots_count (fcompose p q1 q2) A\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "case (root b p)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  proots_count p B = proots_count (fcompose p q1 q2) A\n  [:- b, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "have \"proots_count ([:- b, 1:] * p) B = proots_count [:- b, 1:] B + proots_count p B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] * p) B =\n    proots_count [:- b, 1::'a:] B + proots_count p B", "using proots_count_times[OF \\<open>[:- b, 1:] * p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  proots_count ([:- b, 1::'a:] * p) ?s =\n  proots_count [:- b, 1::'a:] ?s + proots_count p ?s\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] * p) B =\n    proots_count [:- b, 1::'a:] B + proots_count p B", "by simp"], ["proof (state)\nthis:\n  proots_count ([:- b, 1::'a:] * p) B =\n  proots_count [:- b, 1::'a:] B + proots_count p B\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "also"], ["proof (state)\nthis:\n  proots_count ([:- b, 1::'a:] * p) B =\n  proots_count [:- b, 1::'a:] B + proots_count p B\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "have \"... = proots_count (fcompose [:- b, 1:] q1 q2) A \n                    + proots_count (fcompose p q1 q2) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A", "define g where \"g=(\\<lambda>x. poly q1 x/poly q2 x)\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. poly q1 x / poly q2 x)\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A", "have \"proots_count [:- b, 1:] B = proots_count (fcompose [:- b, 1:] q1 q2) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "proof (cases \"b\\<in>B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A\n 2. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "case True"], ["proof (state)\nthis:\n  b \\<in> B\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A\n 2. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "then"], ["proof (chain)\npicking this:\n  b \\<in> B", "have \"proots_count [:- b, 1:] B = 1\""], ["proof (prove)\nusing this:\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B = 1", "unfolding proots_count_pCons_1_iff"], ["proof (prove)\nusing this:\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. (if b \\<in> B then 1 else 0) = 1", "by simp"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B = 1\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A\n 2. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "moreover"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B = 1\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A\n 2. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "have \"proots_count (fcompose [:- b, 1:] q1 q2) A = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1", "obtain a where \"b=g a\" \"a\\<in>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>b = g a; a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using bij[folded g_def] True"], ["proof (prove)\nusing this:\n  bij_betw g A B\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>b = g a; a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis bij_betwE bij_betw_the_inv_into f_the_inv_into_f_bij_betw)"], ["proof (state)\nthis:\n  b = g a\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1", "define qq where \"qq=q1 - smult b q2\""], ["proof (state)\nthis:\n  qq = q1 - smult b q2\n\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1", "have qq_0:\"poly qq a=0\" and qq_deg: \"degree qq\\<le>1\" and \\<open>qq\\<noteq>0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly qq a = (0::'a) &&& degree qq \\<le> 1 &&& qq \\<noteq> 0", "unfolding qq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (q1 - smult b q2) a = (0::'a) &&&\n    degree (q1 - smult b q2) \\<le> 1 &&& q1 - smult b q2 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (q1 - smult b q2) a = (0::'a)", "using \\<open>b=g a\\<close> nzero[rule_format,OF \\<open>a\\<in>A\\<close>]"], ["proof (prove)\nusing this:\n  b = g a\n  poly q2 a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly (q1 - smult b q2) a = (0::'a)", "unfolding g_def"], ["proof (prove)\nusing this:\n  b = poly q1 a / poly q2 a\n  poly q2 a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly (q1 - smult b q2) a = (0::'a)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree (q1 - smult b q2) \\<le> 1\n 2. q1 - smult b q2 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (q1 - smult b q2) \\<le> 1", "using max_deg"], ["proof (prove)\nusing this:\n  max (degree q1) (degree q2) \\<le> 1\n\ngoal (1 subgoal):\n 1. degree (q1 - smult b q2) \\<le> 1", "by (simp add: degree_diff_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 - smult b q2 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. q1 - smult b q2 \\<noteq> 0", "using nconst[rule_format,of b]"], ["proof (prove)\nusing this:\n  q1 \\<noteq> smult b q2\n\ngoal (1 subgoal):\n 1. q1 - smult b q2 \\<noteq> 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  poly qq a = (0::'a)\n  degree qq \\<le> 1\n  qq \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1", "have \"proots_within qq A = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "have \"a\\<in>proots_within qq A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> proots_within qq A", "using qq_0 \\<open>a\\<in>A\\<close>"], ["proof (prove)\nusing this:\n  poly qq a = (0::'a)\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. a \\<in> proots_within qq A", "by auto"], ["proof (state)\nthis:\n  a \\<in> proots_within qq A\n\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "moreover"], ["proof (state)\nthis:\n  a \\<in> proots_within qq A\n\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "have \"card (proots_within qq A) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "have \"finite (proots_within qq A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within qq A)", "using \\<open>qq\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  qq \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (proots_within qq A)", "by simp"], ["proof (state)\nthis:\n  finite (proots_within qq A)\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "moreover"], ["proof (state)\nthis:\n  finite (proots_within qq A)\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "have \"proots_within qq A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within qq A \\<noteq> {}", "using \\<open>a\\<in>proots_within qq A\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> proots_within qq A\n\ngoal (1 subgoal):\n 1. proots_within qq A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  proots_within qq A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "ultimately"], ["proof (chain)\npicking this:\n  finite (proots_within qq A)\n  proots_within qq A \\<noteq> {}", "have \"card (proots_within qq A) \\<noteq>0\""], ["proof (prove)\nusing this:\n  finite (proots_within qq A)\n  proots_within qq A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (proots_within qq A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "moreover"], ["proof (state)\nthis:\n  card (proots_within qq A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "have \"card (proots_within qq A) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within qq A) \\<le> 1", "by (meson \\<open>qq \\<noteq> 0\\<close> card_proots_within_leq le_trans proots_count_leq_degree qq_deg)"], ["proof (state)\nthis:\n  card (proots_within qq A) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "ultimately"], ["proof (chain)\npicking this:\n  card (proots_within qq A) \\<noteq> 0\n  card (proots_within qq A) \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  card (proots_within qq A) \\<noteq> 0\n  card (proots_within qq A) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "by auto"], ["proof (state)\nthis:\n  card (proots_within qq A) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (proots_within qq A) = 1\n\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> proots_within qq A\n  card (proots_within qq A) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> proots_within qq A\n  card (proots_within qq A) = 1\n\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "by (metis card_1_singletonE singletonD)"], ["proof (state)\nthis:\n  proots_within qq A = {a}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_within qq A = {a}\n\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1", "moreover"], ["proof (state)\nthis:\n  proots_within qq A = {a}\n\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1", "have \"order a qq=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a qq = 1", "by (metis One_nat_def \\<open>qq \\<noteq> 0\\<close> le_antisym le_zero_eq not_less_eq_eq order_degree\n                order_root qq_0 qq_deg)"], ["proof (state)\nthis:\n  order a qq = 1\n\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1", "ultimately"], ["proof (chain)\npicking this:\n  proots_within qq A = {a}\n  order a qq = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within qq A = {a}\n  order a qq = 1\n\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1", "unfolding fcompose_def proots_count_def qq_def"], ["proof (prove)\nusing this:\n  proots_within (q1 - smult b q2) A = {a}\n  order a (q1 - smult b q2) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within\n                  (fst (fold_coeffs\n                         (\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d))\n                         [:- b, 1::'a:] (0, 1)))\n                  A.\n       order r\n        (fst (fold_coeffs (\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d))\n               [:- b, 1::'a:] (0, 1)))) =\n    1", "by auto"], ["proof (state)\nthis:\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A\n 2. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "ultimately"], ["proof (chain)\npicking this:\n  proots_count [:- b, 1::'a:] B = 1\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count [:- b, 1::'a:] B = 1\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 1\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "by auto"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B =\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "case False"], ["proof (state)\nthis:\n  b \\<notin> B\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "then"], ["proof (chain)\npicking this:\n  b \\<notin> B", "have \"proots_count [:- b, 1:] B  = 0\""], ["proof (prove)\nusing this:\n  b \\<notin> B\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B = 0", "unfolding proots_count_pCons_1_iff"], ["proof (prove)\nusing this:\n  b \\<notin> B\n\ngoal (1 subgoal):\n 1. (if b \\<in> B then 1 else 0) = 0", "by simp"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B = 0\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "moreover"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B = 0\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "have \"proots_count (fcompose [:- b, 1:] q1 q2) A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 0", "have \"proots_within (fcompose [:- b, 1:] q1 q2) A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (fcompose [:- b, 1::'a:] q1 q2) A = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_within (fcompose [:- b, 1::'a:] q1 q2) A \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"proots_within (fcompose [:- b, 1:] q1 q2) A \\<noteq> {}\""], ["proof (state)\nthis:\n  proots_within (fcompose [:- b, 1::'a:] q1 q2) A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. proots_within (fcompose [:- b, 1::'a:] q1 q2) A \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  proots_within (fcompose [:- b, 1::'a:] q1 q2) A \\<noteq> {}", "obtain a where \"a\\<in>A\" \"poly q1 a = b * poly q2 a\""], ["proof (prove)\nusing this:\n  proots_within (fcompose [:- b, 1::'a:] q1 q2) A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A; poly q1 a = b * poly q2 a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fcompose_def proots_within_def"], ["proof (prove)\nusing this:\n  {x \\<in> A.\n   poly\n    (fst (fold_coeffs (\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d))\n           [:- b, 1::'a:] (0, 1)))\n    x =\n   (0::'a)} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A; poly q1 a = b * poly q2 a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> A\n  poly q1 a = b * poly q2 a\n\ngoal (1 subgoal):\n 1. proots_within (fcompose [:- b, 1::'a:] q1 q2) A \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  a \\<in> A\n  poly q1 a = b * poly q2 a", "have \"b = g a\""], ["proof (prove)\nusing this:\n  a \\<in> A\n  poly q1 a = b * poly q2 a\n\ngoal (1 subgoal):\n 1. b = g a", "unfolding g_def"], ["proof (prove)\nusing this:\n  a \\<in> A\n  poly q1 a = b * poly q2 a\n\ngoal (1 subgoal):\n 1. b = poly q1 a / poly q2 a", "using nzero[rule_format,OF \\<open>a\\<in>A\\<close>]"], ["proof (prove)\nusing this:\n  a \\<in> A\n  poly q1 a = b * poly q2 a\n  poly q2 a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. b = poly q1 a / poly q2 a", "by auto"], ["proof (state)\nthis:\n  b = g a\n\ngoal (1 subgoal):\n 1. proots_within (fcompose [:- b, 1::'a:] q1 q2) A \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  b = g a", "have \"b\\<in>B\""], ["proof (prove)\nusing this:\n  b = g a\n\ngoal (1 subgoal):\n 1. b \\<in> B", "using \\<open>a\\<in>A\\<close> bij[folded g_def]"], ["proof (prove)\nusing this:\n  b = g a\n  a \\<in> A\n  bij_betw g A B\n\ngoal (1 subgoal):\n 1. b \\<in> B", "using bij_betwE"], ["proof (prove)\nusing this:\n  b = g a\n  a \\<in> A\n  bij_betw g A B\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n\ngoal (1 subgoal):\n 1. b \\<in> B", "by blast"], ["proof (state)\nthis:\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. proots_within (fcompose [:- b, 1::'a:] q1 q2) A \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  b \\<in> B", "show False"], ["proof (prove)\nusing this:\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  b \\<in> B\n  b \\<notin> B\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_within (fcompose [:- b, 1::'a:] q1 q2) A = {}\n\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 0", "then"], ["proof (chain)\npicking this:\n  proots_within (fcompose [:- b, 1::'a:] q1 q2) A = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within (fcompose [:- b, 1::'a:] q1 q2) A = {}\n\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 0", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within (fcompose [:- b, 1::'a:] q1 q2) A = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within (fcompose [:- b, 1::'a:] q1 q2) A.\n       order r (fcompose [:- b, 1::'a:] q1 q2)) =\n    0", "by auto"], ["proof (state)\nthis:\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 0\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "ultimately"], ["proof (chain)\npicking this:\n  proots_count [:- b, 1::'a:] B = 0\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count [:- b, 1::'a:] B = 0\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A = 0\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A", "by simp"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B =\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B =\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A", "moreover"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B =\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A", "have \"proots_count p B = proots_count (fcompose p q1 q2) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p B = proots_count (fcompose p q1 q2) A", "apply (rule root.hyps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using mult_eq_0_iff root.prems"], ["proof (prove)\nusing this:\n  (?a * ?b = (0::?'a)) = (?a = (0::?'a) \\<or> ?b = (0::?'a))\n  [:- b, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  proots_count p B = proots_count (fcompose p q1 q2) A\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A", "ultimately"], ["proof (chain)\npicking this:\n  proots_count [:- b, 1::'a:] B =\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A\n  proots_count p B = proots_count (fcompose p q1 q2) A", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count [:- b, 1::'a:] B =\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A\n  proots_count p B = proots_count (fcompose p q1 q2) A\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A", "by auto"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B + proots_count p B =\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n  proots_count (fcompose p q1 q2) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B + proots_count p B =\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n  proots_count (fcompose p q1 q2) A\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "also"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B + proots_count p B =\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n  proots_count (fcompose p q1 q2) A\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "have \"... = proots_count (fcompose ([:- b, 1:] * p) q1 q2) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A", "proof (cases \"A={}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A\n 2. A \\<noteq> {} \\<Longrightarrow>\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A", "case False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A\n 2. A \\<noteq> {} \\<Longrightarrow>\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A", "have \"fcompose [:- b, 1:] q1 q2 \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0", "using nconst[rule_format,of b]"], ["proof (prove)\nusing this:\n  q1 \\<noteq> smult b q2\n\ngoal (1 subgoal):\n 1. fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0", "unfolding fcompose_def"], ["proof (prove)\nusing this:\n  q1 \\<noteq> smult b q2\n\ngoal (1 subgoal):\n 1. fst (fold_coeffs (\\<lambda>a (c, d). (d * [:a:] + q1 * c, q2 * d))\n          [:- b, 1::'a:] (0, 1)) \\<noteq>\n    0", "by auto"], ["proof (state)\nthis:\n  fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A\n 2. A \\<noteq> {} \\<Longrightarrow>\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A", "moreover"], ["proof (state)\nthis:\n  fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A\n 2. A \\<noteq> {} \\<Longrightarrow>\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A", "have \"fcompose p q1 q2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose p q1 q2 \\<noteq> 0", "apply (rule fcompose_nzero[OF _ _ nconst infi])"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. q2 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using \\<open>[:- b, 1:] * p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  [:- b, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. q2 \\<noteq> 0", "using nzero False"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>A. poly q2 x \\<noteq> (0::'a)\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. q2 \\<noteq> 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fcompose p q1 q2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A\n 2. A \\<noteq> {} \\<Longrightarrow>\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A", "ultimately"], ["proof (chain)\npicking this:\n  fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0\n  fcompose p q1 q2 \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0\n  fcompose p q1 q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A", "unfolding fcompose_mult"], ["proof (prove)\nusing this:\n  fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0\n  fcompose p q1 q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose [:- b, 1::'a:] q1 q2 * fcompose p q1 q2) A", "apply (subst proots_count_times)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0;\n     fcompose p q1 q2 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fcompose [:- b, 1::'a:] q1 q2 *\n                      fcompose p q1 q2 \\<noteq>\n                      0\n 2. \\<lbrakk>fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0;\n     fcompose p q1 q2 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n                      proots_count (fcompose p q1 q2) A =\n                      proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n                      proots_count (fcompose p q1 q2) A", "by auto"], ["proof (state)\nthis:\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n  proots_count (fcompose p q1 q2) A =\n  proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A\n\ngoal (1 subgoal):\n 1. A = {} \\<Longrightarrow>\n    proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n    proots_count (fcompose p q1 q2) A =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A", "qed auto"], ["proof (state)\nthis:\n  proots_count (fcompose [:- b, 1::'a:] q1 q2) A +\n  proots_count (fcompose p q1 q2) A =\n  proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (fcompose p q1 q2) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count (fcompose ([:- a, 1::'a:] * p) q1 q2)\n                          A", "finally"], ["proof (chain)\npicking this:\n  proots_count ([:- b, 1::'a:] * p) B =\n  proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A", "show ?case"], ["proof (prove)\nusing this:\n  proots_count ([:- b, 1::'a:] * p) B =\n  proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] * p) B =\n    proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A", "."], ["proof (state)\nthis:\n  proots_count ([:- b, 1::'a:] * p) B =\n  proots_count (fcompose ([:- b, 1::'a:] * p) q1 q2) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_card_fcompose_bij_eq:\n  fixes p::\"'a::field poly\"\n  assumes bij:\"bij_betw (\\<lambda>x. poly q1 x/poly q2 x) A B\" and \"p\\<noteq>0\" \n      and nzero:\"\\<forall>x\\<in>A. poly q2 x\\<noteq>0\"\n      and max_deg: \"max (degree q1) (degree q2) \\<le> 1\"\n      and nconst:\"\\<forall>c. q1 \\<noteq> smult c q2\"\n      and infi:\"infinite (UNIV::'a set)\"\n  shows \"card (proots_within p B) = card (proots_within (fcompose p q1 q2) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p B) = card (proots_within (fcompose p q1 q2) A)", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within p B) = card (proots_within (fcompose p q1 q2) A)", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    card (proots_within 0 B) = card (proots_within (fcompose 0 q1 q2) A)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (fcompose p q1 q2) A)\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "case 0"], ["proof (state)\nthis:\n  0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    card (proots_within 0 B) = card (proots_within (fcompose 0 q1 q2) A)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (fcompose p q1 q2) A)\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within 0 B) = card (proots_within (fcompose 0 q1 q2) A)", "by simp"], ["proof (state)\nthis:\n  card (proots_within 0 B) = card (proots_within (fcompose 0 q1 q2) A)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (fcompose p q1 q2) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (fcompose p q1 q2) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (fcompose p q1 q2) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "have \"proots_within p B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p B = {}", "using no_proots"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_within p B = {}", "by auto"], ["proof (state)\nthis:\n  proots_within p B = {}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (fcompose p q1 q2) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "moreover"], ["proof (state)\nthis:\n  proots_within p B = {}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (fcompose p q1 q2) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "have \"proots_within (fcompose p q1 q2) A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (fcompose p q1 q2) A = {}", "using no_proots fcompose_poly"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n  poly ?q2.0 ?x \\<noteq> (0::?'a) \\<Longrightarrow>\n  poly ?p (poly ?q1.0 ?x / poly ?q2.0 ?x) =\n  poly (fcompose ?p ?q1.0 ?q2.0) ?x / poly (?q2.0 ^ degree ?p) ?x\n\ngoal (1 subgoal):\n 1. proots_within (fcompose p q1 q2) A = {}", "by (smt Collect_empty_eq divide_eq_0_iff nzero proots_within_def)"], ["proof (state)\nthis:\n  proots_within (fcompose p q1 q2) A = {}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (fcompose p q1 q2) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "ultimately"], ["proof (chain)\npicking this:\n  proots_within p B = {}\n  proots_within (fcompose p q1 q2) A = {}", "show ?case"], ["proof (prove)\nusing this:\n  proots_within p B = {}\n  proots_within (fcompose p q1 q2) A = {}\n\ngoal (1 subgoal):\n 1. card (proots_within p B) = card (proots_within (fcompose p q1 q2) A)", "by auto"], ["proof (state)\nthis:\n  card (proots_within p B) = card (proots_within (fcompose p q1 q2) A)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "case (root b p)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p B) = card (proots_within (fcompose p q1 q2) A)\n  [:- b, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p B) = card (proots_within (fcompose p q1 q2) A)\n  [:- b, 1::'a:] * p \\<noteq> 0", "have [simp]:\"p\\<noteq>0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p B) = card (proots_within (fcompose p q1 q2) A)\n  [:- b, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "have ?case when \"b\\<notin>B \\<or> poly p b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "have \"proots_within ([:- b, 1:] * p) B = proots_within p B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within ([:- b, 1::'a:] * p) B = proots_within p B", "using that"], ["proof (prove)\nusing this:\n  b \\<notin> B \\<or> poly p b = (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within ([:- b, 1::'a:] * p) B = proots_within p B", "by auto"], ["proof (state)\nthis:\n  proots_within ([:- b, 1::'a:] * p) B = proots_within p B\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "moreover"], ["proof (state)\nthis:\n  proots_within ([:- b, 1::'a:] * p) B = proots_within p B\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "have \"proots_within (fcompose ([:- b, 1:] * p) q1 q2) A \n        = proots_within (fcompose p q1 q2) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A =\n    proots_within (fcompose p q1 q2) A", "using that nzero"], ["proof (prove)\nusing this:\n  b \\<notin> B \\<or> poly p b = (0::'a)\n  \\<forall>x\\<in>A. poly q2 x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A =\n    proots_within (fcompose p q1 q2) A", "unfolding fcompose_mult proots_within_times"], ["proof (prove)\nusing this:\n  b \\<notin> B \\<or> poly p b = (0::'a)\n  \\<forall>x\\<in>A. poly q2 x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within (fcompose [:- b, 1::'a:] q1 q2) A \\<union>\n    proots_within (fcompose p q1 q2) A =\n    proots_within (fcompose p q1 q2) A", "apply (auto simp add: poly_fcompose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>A. poly q2 x \\<noteq> (0::'a);\n        poly q1 x / poly q2 x \\<notin> B; x \\<in> A;\n        b = poly q1 x / poly q2 x\\<rbrakk>\n       \\<Longrightarrow> poly p (poly q1 x / poly q2 x) = (0::'a)", "using bij bij_betwE"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>x. poly q1 x / poly q2 x) A B\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>A. poly q2 x \\<noteq> (0::'a);\n        poly q1 x / poly q2 x \\<notin> B; x \\<in> A;\n        b = poly q1 x / poly q2 x\\<rbrakk>\n       \\<Longrightarrow> poly p (poly q1 x / poly q2 x) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A =\n  proots_within (fcompose p q1 q2) A\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "ultimately"], ["proof (chain)\npicking this:\n  proots_within ([:- b, 1::'a:] * p) B = proots_within p B\n  proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A =\n  proots_within (fcompose p q1 q2) A", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within ([:- b, 1::'a:] * p) B = proots_within p B\n  proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A =\n  proots_within (fcompose p q1 q2) A\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "using root"], ["proof (prove)\nusing this:\n  proots_within ([:- b, 1::'a:] * p) B = proots_within p B\n  proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A =\n  proots_within (fcompose p q1 q2) A\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p B) = card (proots_within (fcompose p q1 q2) A)\n  [:- b, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "by auto"], ["proof (state)\nthis:\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<notin> B \\<or> poly p b = (0::'a) \\<Longrightarrow>\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "moreover"], ["proof (state)\nthis:\n  b \\<notin> B \\<or> poly p b = (0::'a) \\<Longrightarrow>\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "have ?case when \"b\\<in>B\" \"poly p b\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "define bb where \"bb=[:- b, 1:]\""], ["proof (state)\nthis:\n  bb = [:- b, 1::'a:]\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "have \"card (proots_within (bb * p) B) = card {b} + card (proots_within p B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within (bb * p) B) = card {b} + card (proots_within p B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within (bb * p) B) = card {b} + card (proots_within p B)", "have \"proots_within bb B = {b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within bb B = {b}", "using that"], ["proof (prove)\nusing this:\n  b \\<in> B\n  poly p b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within bb B = {b}", "unfolding bb_def"], ["proof (prove)\nusing this:\n  b \\<in> B\n  poly p b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within [:- b, 1::'a:] B = {b}", "by auto"], ["proof (state)\nthis:\n  proots_within bb B = {b}\n\ngoal (1 subgoal):\n 1. card (proots_within (bb * p) B) = card {b} + card (proots_within p B)", "then"], ["proof (chain)\npicking this:\n  proots_within bb B = {b}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within bb B = {b}\n\ngoal (1 subgoal):\n 1. card (proots_within (bb * p) B) = card {b} + card (proots_within p B)", "unfolding proots_within_times"], ["proof (prove)\nusing this:\n  proots_within bb B = {b}\n\ngoal (1 subgoal):\n 1. card (proots_within bb B \\<union> proots_within p B) =\n    card {b} + card (proots_within p B)", "apply (subst card_Un_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. proots_within bb B = {b} \\<Longrightarrow> finite (proots_within bb B)\n 2. proots_within bb B = {b} \\<Longrightarrow> finite (proots_within p B)\n 3. proots_within bb B = {b} \\<Longrightarrow>\n    proots_within bb B \\<inter> proots_within p B = {}\n 4. proots_within bb B = {b} \\<Longrightarrow>\n    card (proots_within bb B) + card (proots_within p B) =\n    card {b} + card (proots_within p B)", "by (use that in auto)"], ["proof (state)\nthis:\n  card (proots_within (bb * p) B) = card {b} + card (proots_within p B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (proots_within (bb * p) B) = card {b} + card (proots_within p B)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "also"], ["proof (state)\nthis:\n  card (proots_within (bb * p) B) = card {b} + card (proots_within p B)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "have \"... = 1 + card (proots_within (fcompose p q1 q2) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {b} + card (proots_within p B) =\n    1 + card (proots_within (fcompose p q1 q2) A)", "using root.hyps"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p B) = card (proots_within (fcompose p q1 q2) A)\n\ngoal (1 subgoal):\n 1. card {b} + card (proots_within p B) =\n    1 + card (proots_within (fcompose p q1 q2) A)", "by simp"], ["proof (state)\nthis:\n  card {b} + card (proots_within p B) =\n  1 + card (proots_within (fcompose p q1 q2) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "also"], ["proof (state)\nthis:\n  card {b} + card (proots_within p B) =\n  1 + card (proots_within (fcompose p q1 q2) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "have \"... = card (proots_within (fcompose (bb * p) q1 q2) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + card (proots_within (fcompose p q1 q2) A) =\n    card (proots_within (fcompose (bb * p) q1 q2) A)", "unfolding proots_within_times fcompose_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + card (proots_within (fcompose p q1 q2) A) =\n    card\n     (proots_within (fcompose bb q1 q2) A \\<union>\n      proots_within (fcompose p q1 q2) A)", "proof (subst card_Un_disjoint)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (proots_within (fcompose bb q1 q2) A)\n 2. finite (proots_within (fcompose p q1 q2) A)\n 3. proots_within (fcompose bb q1 q2) A \\<inter>\n    proots_within (fcompose p q1 q2) A =\n    {}\n 4. 1 + card (proots_within (fcompose p q1 q2) A) =\n    card (proots_within (fcompose bb q1 q2) A) +\n    card (proots_within (fcompose p q1 q2) A)", "obtain a where b_poly:\"b=poly q1 a / poly q2 a\" and \"a\\<in>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>b = poly q1 a / poly q2 a; a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) \\<open>b \\<in> B\\<close> bij bij_betwE bij_betw_the_inv_into \n            f_the_inv_into_f_bij_betw)"], ["proof (state)\nthis:\n  b = poly q1 a / poly q2 a\n  a \\<in> A\n\ngoal (4 subgoals):\n 1. finite (proots_within (fcompose bb q1 q2) A)\n 2. finite (proots_within (fcompose p q1 q2) A)\n 3. proots_within (fcompose bb q1 q2) A \\<inter>\n    proots_within (fcompose p q1 q2) A =\n    {}\n 4. 1 + card (proots_within (fcompose p q1 q2) A) =\n    card (proots_within (fcompose bb q1 q2) A) +\n    card (proots_within (fcompose p q1 q2) A)", "define bbq pq where \"bbq=fcompose bb q1 q2\" and \"pq=fcompose p q1 q2\""], ["proof (state)\nthis:\n  bbq = fcompose bb q1 q2\n  pq = fcompose p q1 q2\n\ngoal (4 subgoals):\n 1. finite (proots_within (fcompose bb q1 q2) A)\n 2. finite (proots_within (fcompose p q1 q2) A)\n 3. proots_within (fcompose bb q1 q2) A \\<inter>\n    proots_within (fcompose p q1 q2) A =\n    {}\n 4. 1 + card (proots_within (fcompose p q1 q2) A) =\n    card (proots_within (fcompose bb q1 q2) A) +\n    card (proots_within (fcompose p q1 q2) A)", "have bbq_0:\"poly bbq a=0\" and bbq_deg: \"degree bbq\\<le>1\" and \"bbq\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly bbq a = (0::'a) &&& degree bbq \\<le> 1 &&& bbq \\<noteq> 0", "unfolding bbq_def bb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (fcompose [:- b, 1::'a:] q1 q2) a = (0::'a) &&&\n    degree (fcompose [:- b, 1::'a:] q1 q2) \\<le> 1 &&&\n    fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (fcompose [:- b, 1::'a:] q1 q2) a = (0::'a)", "using \\<open>a \\<in> A\\<close> b_poly nzero poly_fcompose"], ["proof (prove)\nusing this:\n  a \\<in> A\n  b = poly q1 a / poly q2 a\n  \\<forall>x\\<in>A. poly q2 x \\<noteq> (0::'a)\n  poly ?q2.0 ?x \\<noteq> (0::?'a) \\<Longrightarrow>\n  poly (fcompose ?p ?q1.0 ?q2.0) ?x =\n  poly ?p (poly ?q1.0 ?x / poly ?q2.0 ?x) * poly ?q2.0 ?x ^ degree ?p\n\ngoal (1 subgoal):\n 1. poly (fcompose [:- b, 1::'a:] q1 q2) a = (0::'a)", "by fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree (fcompose [:- b, 1::'a:] q1 q2) \\<le> 1\n 2. fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (fcompose [:- b, 1::'a:] q1 q2) \\<le> 1", "by (metis (no_types, lifting) degree_add_le degree_pCons_eq_if degree_smult_le \n           dual_order.trans fcompose_const fcompose_pCons max.boundedE max_deg mult_cancel_left2 \n           one_neq_zero one_poly_eq_simps(1) power.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fcompose [:- b, 1::'a:] q1 q2 \\<noteq> 0", "by (metis \\<open>a \\<in> A\\<close> \\<open>poly (fcompose [:- b, 1:] q1 q2) a = 0\\<close> fcompose_nzero infi \n                  nconst nzero one_neq_zero pCons_eq_0_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  poly bbq a = (0::'a)\n  degree bbq \\<le> 1\n  bbq \\<noteq> 0\n\ngoal (4 subgoals):\n 1. finite (proots_within (fcompose bb q1 q2) A)\n 2. finite (proots_within (fcompose p q1 q2) A)\n 3. proots_within (fcompose bb q1 q2) A \\<inter>\n    proots_within (fcompose p q1 q2) A =\n    {}\n 4. 1 + card (proots_within (fcompose p q1 q2) A) =\n    card (proots_within (fcompose bb q1 q2) A) +\n    card (proots_within (fcompose p q1 q2) A)", "show \"finite (proots_within bbq A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within bbq A)", "using \\<open>bbq\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  bbq \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (proots_within bbq A)", "by simp"], ["proof (state)\nthis:\n  finite (proots_within bbq A)\n\ngoal (3 subgoals):\n 1. finite (proots_within (fcompose p q1 q2) A)\n 2. proots_within (fcompose bb q1 q2) A \\<inter>\n    proots_within (fcompose p q1 q2) A =\n    {}\n 3. 1 + card (proots_within (fcompose p q1 q2) A) =\n    card (proots_within (fcompose bb q1 q2) A) +\n    card (proots_within (fcompose p q1 q2) A)", "show \"finite (proots_within pq A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within pq A)", "unfolding pq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within (fcompose p q1 q2) A)", "by (metis \\<open>a \\<in> A\\<close> \\<open>p \\<noteq> 0\\<close> fcompose_nzero finite_proots infi nconst nzero poly_0 pq_def)"], ["proof (state)\nthis:\n  finite (proots_within pq A)\n\ngoal (2 subgoals):\n 1. proots_within (fcompose bb q1 q2) A \\<inter>\n    proots_within (fcompose p q1 q2) A =\n    {}\n 2. 1 + card (proots_within (fcompose p q1 q2) A) =\n    card (proots_within (fcompose bb q1 q2) A) +\n    card (proots_within (fcompose p q1 q2) A)", "have bbq_a:\"proots_within bbq A = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "have \"a\\<in>proots_within bbq A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> proots_within bbq A", "by (simp add: \\<open>a \\<in> A\\<close> bbq_0)"], ["proof (state)\nthis:\n  a \\<in> proots_within bbq A\n\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "moreover"], ["proof (state)\nthis:\n  a \\<in> proots_within bbq A\n\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "have \"card (proots_within bbq A) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "have \"card (proots_within bbq A) \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within bbq A) \\<noteq> 0", "using \\<open>a\\<in>proots_within bbq A\\<close> \\<open>finite (proots_within bbq A)\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> proots_within bbq A\n  finite (proots_within bbq A)\n\ngoal (1 subgoal):\n 1. card (proots_within bbq A) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (proots_within bbq A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "moreover"], ["proof (state)\nthis:\n  card (proots_within bbq A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "have \"card (proots_within bbq A) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within bbq A) \\<le> 1", "by (meson \\<open>bbq \\<noteq> 0\\<close> card_proots_within_leq le_trans proots_count_leq_degree bbq_deg)"], ["proof (state)\nthis:\n  card (proots_within bbq A) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "ultimately"], ["proof (chain)\npicking this:\n  card (proots_within bbq A) \\<noteq> 0\n  card (proots_within bbq A) \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  card (proots_within bbq A) \\<noteq> 0\n  card (proots_within bbq A) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "by auto"], ["proof (state)\nthis:\n  card (proots_within bbq A) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (proots_within bbq A) = 1\n\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> proots_within bbq A\n  card (proots_within bbq A) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> proots_within bbq A\n  card (proots_within bbq A) = 1\n\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "by (metis card_1_singletonE singletonD)"], ["proof (state)\nthis:\n  proots_within bbq A = {a}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_within bbq A = {a}\n\ngoal (2 subgoals):\n 1. proots_within (fcompose bb q1 q2) A \\<inter>\n    proots_within (fcompose p q1 q2) A =\n    {}\n 2. 1 + card (proots_within (fcompose p q1 q2) A) =\n    card (proots_within (fcompose bb q1 q2) A) +\n    card (proots_within (fcompose p q1 q2) A)", "show \"proots_within (bbq) A \\<inter> proots_within (pq) A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within bbq A \\<inter> proots_within pq A = {}", "using b_poly bbq_a fcompose_poly nzero pq_def that(2)"], ["proof (prove)\nusing this:\n  b = poly q1 a / poly q2 a\n  proots_within bbq A = {a}\n  poly ?q2.0 ?x \\<noteq> (0::?'a) \\<Longrightarrow>\n  poly ?p (poly ?q1.0 ?x / poly ?q2.0 ?x) =\n  poly (fcompose ?p ?q1.0 ?q2.0) ?x / poly (?q2.0 ^ degree ?p) ?x\n  \\<forall>x\\<in>A. poly q2 x \\<noteq> (0::'a)\n  pq = fcompose p q1 q2\n  poly p b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within bbq A \\<inter> proots_within pq A = {}", "by fastforce"], ["proof (state)\nthis:\n  proots_within bbq A \\<inter> proots_within pq A = {}\n\ngoal (1 subgoal):\n 1. 1 + card (proots_within (fcompose p q1 q2) A) =\n    card (proots_within (fcompose bb q1 q2) A) +\n    card (proots_within (fcompose p q1 q2) A)", "show \"1 + card (proots_within pq A) = card (proots_within bbq A) + card (proots_within pq A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + card (proots_within pq A) =\n    card (proots_within bbq A) + card (proots_within pq A)", "using bbq_a"], ["proof (prove)\nusing this:\n  proots_within bbq A = {a}\n\ngoal (1 subgoal):\n 1. 1 + card (proots_within pq A) =\n    card (proots_within bbq A) + card (proots_within pq A)", "by simp"], ["proof (state)\nthis:\n  1 + card (proots_within pq A) =\n  card (proots_within bbq A) + card (proots_within pq A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 + card (proots_within (fcompose p q1 q2) A) =\n  card (proots_within (fcompose (bb * p) q1 q2) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "finally"], ["proof (chain)\npicking this:\n  card (proots_within (bb * p) B) =\n  card (proots_within (fcompose (bb * p) q1 q2) A)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (proots_within (bb * p) B) =\n  card (proots_within (fcompose (bb * p) q1 q2) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "unfolding bb_def"], ["proof (prove)\nusing this:\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "."], ["proof (state)\nthis:\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>b \\<in> B; poly p b \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> card (proots_within ([:- b, 1::'a:] * p) B) =\n                    card\n                     (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (fcompose p q1 q2) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (fcompose ([:- a, 1::'a:] * p) q1 q2) A)", "ultimately"], ["proof (chain)\npicking this:\n  b \\<notin> B \\<or> poly p b = (0::'a) \\<Longrightarrow>\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)\n  \\<lbrakk>b \\<in> B; poly p b \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> card (proots_within ([:- b, 1::'a:] * p) B) =\n                    card\n                     (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "show ?case"], ["proof (prove)\nusing this:\n  b \\<notin> B \\<or> poly p b = (0::'a) \\<Longrightarrow>\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)\n  \\<lbrakk>b \\<in> B; poly p b \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> card (proots_within ([:- b, 1::'a:] * p) B) =\n                    card\n                     (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)", "by auto"], ["proof (state)\nthis:\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (fcompose ([:- b, 1::'a:] * p) q1 q2) A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_pcompose_bij_eq:\n  fixes p::\"'a::idom poly\"\n  assumes bij:\"bij_betw (\\<lambda>x. poly q x) A B\" and \"p\\<noteq>0\" \n      and q_deg: \"degree q = 1\"\n  shows \"proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    proots_count 0 B = proots_count (0 \\<circ>\\<^sub>p q) A\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (p \\<circ>\\<^sub>p q) A\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "case 0"], ["proof (state)\nthis:\n  0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    proots_count 0 B = proots_count (0 \\<circ>\\<^sub>p q) A\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (p \\<circ>\\<^sub>p q) A\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count 0 B = proots_count (0 \\<circ>\\<^sub>p q) A", "by simp"], ["proof (state)\nthis:\n  proots_count 0 B = proots_count (0 \\<circ>\\<^sub>p q) A\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (p \\<circ>\\<^sub>p q) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (p \\<circ>\\<^sub>p q) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (p \\<circ>\\<^sub>p q) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "have \"proots_count p B = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p B = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count p B = 0", "have \"proots_within p B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p B = {}", "using no_proots"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_within p B = {}", "by auto"], ["proof (state)\nthis:\n  proots_within p B = {}\n\ngoal (1 subgoal):\n 1. proots_count p B = 0", "then"], ["proof (chain)\npicking this:\n  proots_within p B = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within p B = {}\n\ngoal (1 subgoal):\n 1. proots_count p B = 0", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within p B = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p B. order r p) = 0", "by auto"], ["proof (state)\nthis:\n  proots_count p B = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count p B = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (p \\<circ>\\<^sub>p q) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "moreover"], ["proof (state)\nthis:\n  proots_count p B = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (p \\<circ>\\<^sub>p q) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "have \"proots_count (p \\<circ>\\<^sub>p q) A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) A = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) A = 0", "have \"proots_within (p \\<circ>\\<^sub>p q) A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (p \\<circ>\\<^sub>p q) A = {}", "using no_proots"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_within (p \\<circ>\\<^sub>p q) A = {}", "unfolding proots_within_def"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x \\<in> A. poly (p \\<circ>\\<^sub>p q) x = (0::'a)} = {}", "by (auto simp:poly_pcompose)"], ["proof (state)\nthis:\n  proots_within (p \\<circ>\\<^sub>p q) A = {}\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) A = 0", "then"], ["proof (chain)\npicking this:\n  proots_within (p \\<circ>\\<^sub>p q) A = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within (p \\<circ>\\<^sub>p q) A = {}\n\ngoal (1 subgoal):\n 1. proots_count (p \\<circ>\\<^sub>p q) A = 0", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within (p \\<circ>\\<^sub>p q) A = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within (p \\<circ>\\<^sub>p q) A.\n       order r (p \\<circ>\\<^sub>p q)) =\n    0", "by auto"], ["proof (state)\nthis:\n  proots_count (p \\<circ>\\<^sub>p q) A = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count (p \\<circ>\\<^sub>p q) A = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count p B =\n                         proots_count (p \\<circ>\\<^sub>p q) A\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "ultimately"], ["proof (chain)\npicking this:\n  proots_count p B = 0\n  proots_count (p \\<circ>\\<^sub>p q) A = 0", "show ?case"], ["proof (prove)\nusing this:\n  proots_count p B = 0\n  proots_count (p \\<circ>\\<^sub>p q) A = 0\n\ngoal (1 subgoal):\n 1. proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A", "by auto"], ["proof (state)\nthis:\n  proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "case (root b p)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A\n  [:- b, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "have \"proots_count ([:- b, 1:] * p) B = proots_count [:- b, 1:] B + proots_count p B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] * p) B =\n    proots_count [:- b, 1::'a:] B + proots_count p B", "using proots_count_times[OF \\<open>[:- b, 1:] * p \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  proots_count ([:- b, 1::'a:] * p) ?s =\n  proots_count [:- b, 1::'a:] ?s + proots_count p ?s\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] * p) B =\n    proots_count [:- b, 1::'a:] B + proots_count p B", "by simp"], ["proof (state)\nthis:\n  proots_count ([:- b, 1::'a:] * p) B =\n  proots_count [:- b, 1::'a:] B + proots_count p B\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "also"], ["proof (state)\nthis:\n  proots_count ([:- b, 1::'a:] * p) B =\n  proots_count [:- b, 1::'a:] B + proots_count p B\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "have \"... = proots_count ([:- b, 1:] \\<circ>\\<^sub>p q) A + proots_count (p \\<circ>\\<^sub>p q) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A", "have \"proots_count [:- b, 1:] B = proots_count ([:- b, 1:] \\<circ>\\<^sub>p q) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "proof (cases \"b\\<in>B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A\n 2. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "case True"], ["proof (state)\nthis:\n  b \\<in> B\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A\n 2. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "then"], ["proof (chain)\npicking this:\n  b \\<in> B", "have \"proots_count [:- b, 1:] B = 1\""], ["proof (prove)\nusing this:\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B = 1", "unfolding proots_count_pCons_1_iff"], ["proof (prove)\nusing this:\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. (if b \\<in> B then 1 else 0) = 1", "by simp"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B = 1\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A\n 2. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "moreover"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B = 1\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A\n 2. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "have \"proots_count ([:- b, 1:] \\<circ>\\<^sub>p q) A = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1", "obtain a where \"b=poly q a\" \"a\\<in>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>b = poly q a; a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using True bij"], ["proof (prove)\nusing this:\n  b \\<in> B\n  bij_betw (poly q) A B\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>b = poly q a; a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis bij_betwE bij_betw_the_inv_into f_the_inv_into_f_bij_betw)"], ["proof (state)\nthis:\n  b = poly q a\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1", "define qq where \"qq=[:- b:] + q\""], ["proof (state)\nthis:\n  qq = [:- b:] + q\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1", "have qq_0:\"poly qq a=0\" and qq_deg: \"degree qq\\<le>1\" and \\<open>qq\\<noteq>0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly qq a = (0::'a) &&& degree qq \\<le> 1 &&& qq \\<noteq> 0", "unfolding qq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ([:- b:] + q) a = (0::'a) &&&\n    degree ([:- b:] + q) \\<le> 1 &&& [:- b:] + q \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ([:- b:] + q) a = (0::'a)", "using \\<open>b=poly q a\\<close>"], ["proof (prove)\nusing this:\n  b = poly q a\n\ngoal (1 subgoal):\n 1. poly ([:- b:] + q) a = (0::'a)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree ([:- b:] + q) \\<le> 1\n 2. [:- b:] + q \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:- b:] + q) \\<le> 1", "using q_deg"], ["proof (prove)\nusing this:\n  degree q = 1\n\ngoal (1 subgoal):\n 1. degree ([:- b:] + q) \\<le> 1", "by (simp add: degree_add_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- b:] + q \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- b:] + q \\<noteq> 0", "using q_deg add.inverse_unique"], ["proof (prove)\nusing this:\n  degree q = 1\n  ?a + ?b = (0::?'a) \\<Longrightarrow> - ?a = ?b\n\ngoal (1 subgoal):\n 1. [:- b:] + q \\<noteq> 0", "by force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  poly qq a = (0::'a)\n  degree qq \\<le> 1\n  qq \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1", "have \"proots_within qq A = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "have \"a\\<in>proots_within qq A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> proots_within qq A", "using qq_0 \\<open>a\\<in>A\\<close>"], ["proof (prove)\nusing this:\n  poly qq a = (0::'a)\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. a \\<in> proots_within qq A", "by auto"], ["proof (state)\nthis:\n  a \\<in> proots_within qq A\n\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "moreover"], ["proof (state)\nthis:\n  a \\<in> proots_within qq A\n\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "have \"card (proots_within qq A) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "have \"finite (proots_within qq A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within qq A)", "using \\<open>qq\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  qq \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (proots_within qq A)", "by simp"], ["proof (state)\nthis:\n  finite (proots_within qq A)\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "moreover"], ["proof (state)\nthis:\n  finite (proots_within qq A)\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "have \"proots_within qq A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within qq A \\<noteq> {}", "using \\<open>a\\<in>proots_within qq A\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> proots_within qq A\n\ngoal (1 subgoal):\n 1. proots_within qq A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  proots_within qq A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "ultimately"], ["proof (chain)\npicking this:\n  finite (proots_within qq A)\n  proots_within qq A \\<noteq> {}", "have \"card (proots_within qq A) \\<noteq>0\""], ["proof (prove)\nusing this:\n  finite (proots_within qq A)\n  proots_within qq A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (proots_within qq A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "moreover"], ["proof (state)\nthis:\n  card (proots_within qq A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "have \"card (proots_within qq A) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within qq A) \\<le> 1", "by (meson \\<open>qq \\<noteq> 0\\<close> card_proots_within_leq le_trans proots_count_leq_degree qq_deg)"], ["proof (state)\nthis:\n  card (proots_within qq A) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "ultimately"], ["proof (chain)\npicking this:\n  card (proots_within qq A) \\<noteq> 0\n  card (proots_within qq A) \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  card (proots_within qq A) \\<noteq> 0\n  card (proots_within qq A) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (proots_within qq A) = 1", "by auto"], ["proof (state)\nthis:\n  card (proots_within qq A) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (proots_within qq A) = 1\n\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> proots_within qq A\n  card (proots_within qq A) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> proots_within qq A\n  card (proots_within qq A) = 1\n\ngoal (1 subgoal):\n 1. proots_within qq A = {a}", "by (metis card_1_singletonE singletonD)"], ["proof (state)\nthis:\n  proots_within qq A = {a}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_within qq A = {a}\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1", "moreover"], ["proof (state)\nthis:\n  proots_within qq A = {a}\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1", "have \"order a qq=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order a qq = 1", "by (metis One_nat_def \\<open>qq \\<noteq> 0\\<close> le_antisym le_zero_eq not_less_eq_eq order_degree\n                order_root qq_0 qq_deg)"], ["proof (state)\nthis:\n  order a qq = 1\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1", "ultimately"], ["proof (chain)\npicking this:\n  proots_within qq A = {a}\n  order a qq = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within qq A = {a}\n  order a qq = 1\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1", "unfolding pcompose_def proots_count_def qq_def"], ["proof (prove)\nusing this:\n  proots_within ([:- b:] + q) A = {a}\n  order a ([:- b:] + q) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within\n                  (fold_coeffs (\\<lambda>a c. [:a:] + q * c) [:- b, 1::'a:]\n                    0)\n                  A.\n       order r\n        (fold_coeffs (\\<lambda>a c. [:a:] + q * c) [:- b, 1::'a:] 0)) =\n    1", "by auto"], ["proof (state)\nthis:\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A\n 2. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "ultimately"], ["proof (chain)\npicking this:\n  proots_count [:- b, 1::'a:] B = 1\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count [:- b, 1::'a:] B = 1\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 1\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "by auto"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B =\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "case False"], ["proof (state)\nthis:\n  b \\<notin> B\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "then"], ["proof (chain)\npicking this:\n  b \\<notin> B", "have \"proots_count [:- b, 1:] B  = 0\""], ["proof (prove)\nusing this:\n  b \\<notin> B\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B = 0", "unfolding proots_count_pCons_1_iff"], ["proof (prove)\nusing this:\n  b \\<notin> B\n\ngoal (1 subgoal):\n 1. (if b \\<in> B then 1 else 0) = 0", "by simp"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B = 0\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "moreover"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B = 0\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "have \"proots_count ([:- b, 1:] \\<circ>\\<^sub>p q) A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 0", "have \"proots_within ([:- b, 1:] \\<circ>\\<^sub>p q) A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = {}", "unfolding pcompose_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within\n     (fold_coeffs (\\<lambda>a c. [:a:] + q * c) [:- b, 1::'a:] 0) A =\n    {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> A; b = poly q x\\<rbrakk> \\<Longrightarrow> False", "using False bij bij_betwE"], ["proof (prove)\nusing this:\n  b \\<notin> B\n  bij_betw (poly q) A B\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> A; b = poly q x\\<rbrakk> \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  proots_within ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = {}\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 0", "then"], ["proof (chain)\npicking this:\n  proots_within ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = {}\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 0", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A.\n       order r ([:- b, 1::'a:] \\<circ>\\<^sub>p q)) =\n    0", "by auto"], ["proof (state)\nthis:\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 0\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "ultimately"], ["proof (chain)\npicking this:\n  proots_count [:- b, 1::'a:] B = 0\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count [:- b, 1::'a:] B = 0\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A = 0\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A", "by simp"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B =\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B =\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A", "moreover"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B =\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A", "have \"proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A", "apply (rule root.hyps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using \\<open>[:- b, 1:] * p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  [:- b, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A", "ultimately"], ["proof (chain)\npicking this:\n  proots_count [:- b, 1::'a:] B =\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A\n  proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count [:- b, 1::'a:] B =\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A\n  proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. proots_count [:- b, 1::'a:] B + proots_count p B =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A", "by auto"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B + proots_count p B =\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n  proots_count (p \\<circ>\\<^sub>p q) A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B + proots_count p B =\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n  proots_count (p \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "also"], ["proof (state)\nthis:\n  proots_count [:- b, 1::'a:] B + proots_count p B =\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n  proots_count (p \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "have \"... = proots_count (([:- b, 1:] * p) \\<circ>\\<^sub>p q) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A =\n    proots_count (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "unfolding pcompose_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q * p \\<circ>\\<^sub>p q) A", "apply (subst proots_count_times)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [:- b, 1::'a:] \\<circ>\\<^sub>p q * p \\<circ>\\<^sub>p q \\<noteq> 0\n 2. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- b, 1::'a:] \\<circ>\\<^sub>p q * p \\<circ>\\<^sub>p q \\<noteq> 0", "by (metis (no_types, lifting) One_nat_def add.right_neutral degree_0 degree_mult_eq\n      degree_pCons_eq_if degree_pcompose mult_eq_0_iff one_neq_zero one_pCons pcompose_mult\n      q_deg root.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A =\n    proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n    proots_count (p \\<circ>\\<^sub>p q) A", "by simp"], ["proof (state)\nthis:\n  proots_count ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A +\n  proots_count (p \\<circ>\\<^sub>p q) A =\n  proots_count (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                proots_count p B = proots_count (p \\<circ>\\<^sub>p q) A;\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1::'a:] * p) B =\n                         proots_count\n                          (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "finally"], ["proof (chain)\npicking this:\n  proots_count ([:- b, 1::'a:] * p) B =\n  proots_count (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "show ?case"], ["proof (prove)\nusing this:\n  proots_count ([:- b, 1::'a:] * p) B =\n  proots_count (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. proots_count ([:- b, 1::'a:] * p) B =\n    proots_count (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A", "."], ["proof (state)\nthis:\n  proots_count ([:- b, 1::'a:] * p) B =\n  proots_count (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proots_card_pcompose_bij_eq:\n  fixes p::\"'a::idom poly\"\n  assumes bij:\"bij_betw (\\<lambda>x. poly q x) A B\" and \"p\\<noteq>0\" \n      and q_deg: \"degree q = 1\"\n  shows \"card (proots_within p B) = card (proots_within (p \\<circ>\\<^sub>p q) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p B) = card (proots_within (p \\<circ>\\<^sub>p q) A)", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within p B) = card (proots_within (p \\<circ>\\<^sub>p q) A)", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    card (proots_within 0 B) = card (proots_within (0 \\<circ>\\<^sub>p q) A)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (p \\<circ>\\<^sub>p q) A)\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "case 0"], ["proof (state)\nthis:\n  0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    card (proots_within 0 B) = card (proots_within (0 \\<circ>\\<^sub>p q) A)\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (p \\<circ>\\<^sub>p q) A)\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within 0 B) = card (proots_within (0 \\<circ>\\<^sub>p q) A)", "by auto"], ["proof (state)\nthis:\n  card (proots_within 0 B) = card (proots_within (0 \\<circ>\\<^sub>p q) A)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (p \\<circ>\\<^sub>p q) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (p \\<circ>\\<^sub>p q) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (p \\<circ>\\<^sub>p q) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "have \"proots_within p B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p B = {}", "using no_proots"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_within p B = {}", "by auto"], ["proof (state)\nthis:\n  proots_within p B = {}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (p \\<circ>\\<^sub>p q) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "moreover"], ["proof (state)\nthis:\n  proots_within p B = {}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (p \\<circ>\\<^sub>p q) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "have \"proots_within (p \\<circ>\\<^sub>p q) A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (p \\<circ>\\<^sub>p q) A = {}", "using no_proots"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_within (p \\<circ>\\<^sub>p q) A = {}", "by (simp add: poly_pcompose proots_within_def)"], ["proof (state)\nthis:\n  proots_within (p \\<circ>\\<^sub>p q) A = {}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within p B) =\n                         card (proots_within (p \\<circ>\\<^sub>p q) A)\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "ultimately"], ["proof (chain)\npicking this:\n  proots_within p B = {}\n  proots_within (p \\<circ>\\<^sub>p q) A = {}", "show ?case"], ["proof (prove)\nusing this:\n  proots_within p B = {}\n  proots_within (p \\<circ>\\<^sub>p q) A = {}\n\ngoal (1 subgoal):\n 1. card (proots_within p B) = card (proots_within (p \\<circ>\\<^sub>p q) A)", "by auto"], ["proof (state)\nthis:\n  card (proots_within p B) = card (proots_within (p \\<circ>\\<^sub>p q) A)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "case (root b p)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p B) = card (proots_within (p \\<circ>\\<^sub>p q) A)\n  [:- b, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p B) = card (proots_within (p \\<circ>\\<^sub>p q) A)\n  [:- b, 1::'a:] * p \\<noteq> 0", "have [simp]:\"p\\<noteq>0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p B) = card (proots_within (p \\<circ>\\<^sub>p q) A)\n  [:- b, 1::'a:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "have ?case when \"b\\<notin>B \\<or> poly p b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "have \"proots_within ([:- b, 1:] * p) B = proots_within p B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within ([:- b, 1::'a:] * p) B = proots_within p B", "using that"], ["proof (prove)\nusing this:\n  b \\<notin> B \\<or> poly p b = (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within ([:- b, 1::'a:] * p) B = proots_within p B", "by auto"], ["proof (state)\nthis:\n  proots_within ([:- b, 1::'a:] * p) B = proots_within p B\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "moreover"], ["proof (state)\nthis:\n  proots_within ([:- b, 1::'a:] * p) B = proots_within p B\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "have \"proots_within (([:- b, 1:] * p) \\<circ>\\<^sub>p q) A = proots_within (p \\<circ>\\<^sub>p q) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A =\n    proots_within (p \\<circ>\\<^sub>p q) A", "using that"], ["proof (prove)\nusing this:\n  b \\<notin> B \\<or> poly p b = (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A =\n    proots_within (p \\<circ>\\<^sub>p q) A", "unfolding pcompose_mult proots_within_times"], ["proof (prove)\nusing this:\n  b \\<notin> B \\<or> poly p b = (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within ([:- b, 1::'a:] \\<circ>\\<^sub>p q) A \\<union>\n    proots_within (p \\<circ>\\<^sub>p q) A =\n    proots_within (p \\<circ>\\<^sub>p q) A", "apply (auto simp add: poly_pcompose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>poly q x \\<notin> B; x \\<in> A; b = poly q x\\<rbrakk>\n       \\<Longrightarrow> poly p (poly q x) = (0::'a)", "using bij bij_betwE"], ["proof (prove)\nusing this:\n  bij_betw (poly q) A B\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>poly q x \\<notin> B; x \\<in> A; b = poly q x\\<rbrakk>\n       \\<Longrightarrow> poly p (poly q x) = (0::'a)", "by blast"], ["proof (state)\nthis:\n  proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A =\n  proots_within (p \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "ultimately"], ["proof (chain)\npicking this:\n  proots_within ([:- b, 1::'a:] * p) B = proots_within p B\n  proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A =\n  proots_within (p \\<circ>\\<^sub>p q) A", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within ([:- b, 1::'a:] * p) B = proots_within p B\n  proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A =\n  proots_within (p \\<circ>\\<^sub>p q) A\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "using root.hyps[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  proots_within ([:- b, 1::'a:] * p) B = proots_within p B\n  proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A =\n  proots_within (p \\<circ>\\<^sub>p q) A\n  card (proots_within p B) = card (proots_within (p \\<circ>\\<^sub>p q) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "by auto"], ["proof (state)\nthis:\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<notin> B \\<or> poly p b = (0::'a) \\<Longrightarrow>\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "moreover"], ["proof (state)\nthis:\n  b \\<notin> B \\<or> poly p b = (0::'a) \\<Longrightarrow>\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "have ?case when \"b\\<in>B\" \"poly p b\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "define bb where \"bb=[:- b, 1:]\""], ["proof (state)\nthis:\n  bb = [:- b, 1::'a:]\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "have \"card (proots_within (bb * p) B) = card {b} + card (proots_within p B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within (bb * p) B) = card {b} + card (proots_within p B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within (bb * p) B) = card {b} + card (proots_within p B)", "have \"proots_within bb B = {b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within bb B = {b}", "using that"], ["proof (prove)\nusing this:\n  b \\<in> B\n  poly p b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within bb B = {b}", "unfolding bb_def"], ["proof (prove)\nusing this:\n  b \\<in> B\n  poly p b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within [:- b, 1::'a:] B = {b}", "by auto"], ["proof (state)\nthis:\n  proots_within bb B = {b}\n\ngoal (1 subgoal):\n 1. card (proots_within (bb * p) B) = card {b} + card (proots_within p B)", "then"], ["proof (chain)\npicking this:\n  proots_within bb B = {b}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within bb B = {b}\n\ngoal (1 subgoal):\n 1. card (proots_within (bb * p) B) = card {b} + card (proots_within p B)", "unfolding proots_within_times"], ["proof (prove)\nusing this:\n  proots_within bb B = {b}\n\ngoal (1 subgoal):\n 1. card (proots_within bb B \\<union> proots_within p B) =\n    card {b} + card (proots_within p B)", "apply (subst card_Un_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. proots_within bb B = {b} \\<Longrightarrow> finite (proots_within bb B)\n 2. proots_within bb B = {b} \\<Longrightarrow> finite (proots_within p B)\n 3. proots_within bb B = {b} \\<Longrightarrow>\n    proots_within bb B \\<inter> proots_within p B = {}\n 4. proots_within bb B = {b} \\<Longrightarrow>\n    card (proots_within bb B) + card (proots_within p B) =\n    card {b} + card (proots_within p B)", "by (use that in auto)"], ["proof (state)\nthis:\n  card (proots_within (bb * p) B) = card {b} + card (proots_within p B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (proots_within (bb * p) B) = card {b} + card (proots_within p B)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "also"], ["proof (state)\nthis:\n  card (proots_within (bb * p) B) = card {b} + card (proots_within p B)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "have \"... = 1 + card (proots_within (p \\<circ>\\<^sub>p q) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {b} + card (proots_within p B) =\n    1 + card (proots_within (p \\<circ>\\<^sub>p q) A)", "using root.hyps"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  card (proots_within p B) = card (proots_within (p \\<circ>\\<^sub>p q) A)\n\ngoal (1 subgoal):\n 1. card {b} + card (proots_within p B) =\n    1 + card (proots_within (p \\<circ>\\<^sub>p q) A)", "by simp"], ["proof (state)\nthis:\n  card {b} + card (proots_within p B) =\n  1 + card (proots_within (p \\<circ>\\<^sub>p q) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "also"], ["proof (state)\nthis:\n  card {b} + card (proots_within p B) =\n  1 + card (proots_within (p \\<circ>\\<^sub>p q) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "have \"... = card (proots_within ((bb * p) \\<circ>\\<^sub>p q) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + card (proots_within (p \\<circ>\\<^sub>p q) A) =\n    card (proots_within ((bb * p) \\<circ>\\<^sub>p q) A)", "unfolding proots_within_times pcompose_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + card (proots_within (p \\<circ>\\<^sub>p q) A) =\n    card\n     (proots_within (bb \\<circ>\\<^sub>p q) A \\<union>\n      proots_within (p \\<circ>\\<^sub>p q) A)", "proof (subst card_Un_disjoint)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (proots_within (bb \\<circ>\\<^sub>p q) A)\n 2. finite (proots_within (p \\<circ>\\<^sub>p q) A)\n 3. proots_within (bb \\<circ>\\<^sub>p q) A \\<inter>\n    proots_within (p \\<circ>\\<^sub>p q) A =\n    {}\n 4. 1 + card (proots_within (p \\<circ>\\<^sub>p q) A) =\n    card (proots_within (bb \\<circ>\\<^sub>p q) A) +\n    card (proots_within (p \\<circ>\\<^sub>p q) A)", "obtain a where \"b=poly q a\" \"a\\<in>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>b = poly q a; a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>b \\<in> B\\<close> bij bij_betwE bij_betw_the_inv_into f_the_inv_into_f_bij_betw)"], ["proof (state)\nthis:\n  b = poly q a\n  a \\<in> A\n\ngoal (4 subgoals):\n 1. finite (proots_within (bb \\<circ>\\<^sub>p q) A)\n 2. finite (proots_within (p \\<circ>\\<^sub>p q) A)\n 3. proots_within (bb \\<circ>\\<^sub>p q) A \\<inter>\n    proots_within (p \\<circ>\\<^sub>p q) A =\n    {}\n 4. 1 + card (proots_within (p \\<circ>\\<^sub>p q) A) =\n    card (proots_within (bb \\<circ>\\<^sub>p q) A) +\n    card (proots_within (p \\<circ>\\<^sub>p q) A)", "define bbq pq where \"bbq=bb \\<circ>\\<^sub>p q\" and \"pq=p \\<circ>\\<^sub>p q\""], ["proof (state)\nthis:\n  bbq = bb \\<circ>\\<^sub>p q\n  pq = p \\<circ>\\<^sub>p q\n\ngoal (4 subgoals):\n 1. finite (proots_within (bb \\<circ>\\<^sub>p q) A)\n 2. finite (proots_within (p \\<circ>\\<^sub>p q) A)\n 3. proots_within (bb \\<circ>\\<^sub>p q) A \\<inter>\n    proots_within (p \\<circ>\\<^sub>p q) A =\n    {}\n 4. 1 + card (proots_within (p \\<circ>\\<^sub>p q) A) =\n    card (proots_within (bb \\<circ>\\<^sub>p q) A) +\n    card (proots_within (p \\<circ>\\<^sub>p q) A)", "have bbq_0:\"poly bbq a=0\" and bbq_deg: \"degree bbq\\<le>1\" and \"bbq\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly bbq a = (0::'a) &&& degree bbq \\<le> 1 &&& bbq \\<noteq> 0", "unfolding bbq_def bb_def poly_pcompose"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly [:- b, 1::'a:] (poly q a) = (0::'a) &&&\n    degree ([:- b, 1::'a:] \\<circ>\\<^sub>p q) \\<le> 1 &&&\n    [:- b, 1::'a:] \\<circ>\\<^sub>p q \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly [:- b, 1::'a:] (poly q a) = (0::'a)", "using \\<open>b=poly q a\\<close>"], ["proof (prove)\nusing this:\n  b = poly q a\n\ngoal (1 subgoal):\n 1. poly [:- b, 1::'a:] (poly q a) = (0::'a)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree ([:- b, 1::'a:] \\<circ>\\<^sub>p q) \\<le> 1\n 2. [:- b, 1::'a:] \\<circ>\\<^sub>p q \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:- b, 1::'a:] \\<circ>\\<^sub>p q) \\<le> 1", "using q_deg"], ["proof (prove)\nusing this:\n  degree q = 1\n\ngoal (1 subgoal):\n 1. degree ([:- b, 1::'a:] \\<circ>\\<^sub>p q) \\<le> 1", "by (simp add: degree_add_le degree_pcompose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- b, 1::'a:] \\<circ>\\<^sub>p q \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- b, 1::'a:] \\<circ>\\<^sub>p q \\<noteq> 0", "using pcompose_eq_0 q_deg"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<circ>\\<^sub>p ?q = 0; 0 < degree ?q\\<rbrakk>\n  \\<Longrightarrow> ?p = 0\n  degree q = 1\n\ngoal (1 subgoal):\n 1. [:- b, 1::'a:] \\<circ>\\<^sub>p q \\<noteq> 0", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  poly bbq a = (0::'a)\n  degree bbq \\<le> 1\n  bbq \\<noteq> 0\n\ngoal (4 subgoals):\n 1. finite (proots_within (bb \\<circ>\\<^sub>p q) A)\n 2. finite (proots_within (p \\<circ>\\<^sub>p q) A)\n 3. proots_within (bb \\<circ>\\<^sub>p q) A \\<inter>\n    proots_within (p \\<circ>\\<^sub>p q) A =\n    {}\n 4. 1 + card (proots_within (p \\<circ>\\<^sub>p q) A) =\n    card (proots_within (bb \\<circ>\\<^sub>p q) A) +\n    card (proots_within (p \\<circ>\\<^sub>p q) A)", "show \"finite (proots_within bbq A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within bbq A)", "using \\<open>bbq\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  bbq \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (proots_within bbq A)", "by simp"], ["proof (state)\nthis:\n  finite (proots_within bbq A)\n\ngoal (3 subgoals):\n 1. finite (proots_within (p \\<circ>\\<^sub>p q) A)\n 2. proots_within (bb \\<circ>\\<^sub>p q) A \\<inter>\n    proots_within (p \\<circ>\\<^sub>p q) A =\n    {}\n 3. 1 + card (proots_within (p \\<circ>\\<^sub>p q) A) =\n    card (proots_within (bb \\<circ>\\<^sub>p q) A) +\n    card (proots_within (p \\<circ>\\<^sub>p q) A)", "show \"finite (proots_within pq A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within pq A)", "unfolding pq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within (p \\<circ>\\<^sub>p q) A)", "by (metis \\<open>p \\<noteq> 0\\<close> finite_proots pcompose_eq_0 q_deg zero_less_one)"], ["proof (state)\nthis:\n  finite (proots_within pq A)\n\ngoal (2 subgoals):\n 1. proots_within (bb \\<circ>\\<^sub>p q) A \\<inter>\n    proots_within (p \\<circ>\\<^sub>p q) A =\n    {}\n 2. 1 + card (proots_within (p \\<circ>\\<^sub>p q) A) =\n    card (proots_within (bb \\<circ>\\<^sub>p q) A) +\n    card (proots_within (p \\<circ>\\<^sub>p q) A)", "have bbq_a:\"proots_within bbq A = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "have \"a\\<in>proots_within bbq A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> proots_within bbq A", "unfolding bb_def proots_within_def poly_pcompose bbq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> {x \\<in> A. poly [:- b, 1::'a:] (poly q x) = (0::'a)}", "using \\<open>b=poly q a\\<close> \\<open>a\\<in>A\\<close>"], ["proof (prove)\nusing this:\n  b = poly q a\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. a \\<in> {x \\<in> A. poly [:- b, 1::'a:] (poly q x) = (0::'a)}", "by simp"], ["proof (state)\nthis:\n  a \\<in> proots_within bbq A\n\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "moreover"], ["proof (state)\nthis:\n  a \\<in> proots_within bbq A\n\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "have \"card (proots_within bbq A) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "have \"card (proots_within bbq A) \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within bbq A) \\<noteq> 0", "using \\<open>a\\<in>proots_within bbq A\\<close> \\<open>finite (proots_within bbq A)\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> proots_within bbq A\n  finite (proots_within bbq A)\n\ngoal (1 subgoal):\n 1. card (proots_within bbq A) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card (proots_within bbq A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "moreover"], ["proof (state)\nthis:\n  card (proots_within bbq A) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "have \"card (proots_within bbq A) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within bbq A) \\<le> 1", "by (meson \\<open>bbq \\<noteq> 0\\<close> card_proots_within_leq le_trans proots_count_leq_degree bbq_deg)"], ["proof (state)\nthis:\n  card (proots_within bbq A) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "ultimately"], ["proof (chain)\npicking this:\n  card (proots_within bbq A) \\<noteq> 0\n  card (proots_within bbq A) \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  card (proots_within bbq A) \\<noteq> 0\n  card (proots_within bbq A) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (proots_within bbq A) = 1", "by auto"], ["proof (state)\nthis:\n  card (proots_within bbq A) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (proots_within bbq A) = 1\n\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> proots_within bbq A\n  card (proots_within bbq A) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> proots_within bbq A\n  card (proots_within bbq A) = 1\n\ngoal (1 subgoal):\n 1. proots_within bbq A = {a}", "by (metis card_1_singletonE singletonD)"], ["proof (state)\nthis:\n  proots_within bbq A = {a}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_within bbq A = {a}\n\ngoal (2 subgoals):\n 1. proots_within (bb \\<circ>\\<^sub>p q) A \\<inter>\n    proots_within (p \\<circ>\\<^sub>p q) A =\n    {}\n 2. 1 + card (proots_within (p \\<circ>\\<^sub>p q) A) =\n    card (proots_within (bb \\<circ>\\<^sub>p q) A) +\n    card (proots_within (p \\<circ>\\<^sub>p q) A)", "show \"proots_within (bbq) A \\<inter> proots_within (pq) A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within bbq A \\<inter> proots_within pq A = {}", "using bbq_a \\<open>b = poly q a\\<close> that(2)"], ["proof (prove)\nusing this:\n  proots_within bbq A = {a}\n  b = poly q a\n  poly p b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within bbq A \\<inter> proots_within pq A = {}", "unfolding pq_def"], ["proof (prove)\nusing this:\n  proots_within bbq A = {a}\n  b = poly q a\n  poly p b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. proots_within bbq A \\<inter> proots_within (p \\<circ>\\<^sub>p q) A = {}", "by (simp add:poly_pcompose)"], ["proof (state)\nthis:\n  proots_within bbq A \\<inter> proots_within pq A = {}\n\ngoal (1 subgoal):\n 1. 1 + card (proots_within (p \\<circ>\\<^sub>p q) A) =\n    card (proots_within (bb \\<circ>\\<^sub>p q) A) +\n    card (proots_within (p \\<circ>\\<^sub>p q) A)", "show \"1 + card (proots_within pq A) = card (proots_within bbq A) + card (proots_within pq A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + card (proots_within pq A) =\n    card (proots_within bbq A) + card (proots_within pq A)", "using bbq_a"], ["proof (prove)\nusing this:\n  proots_within bbq A = {a}\n\ngoal (1 subgoal):\n 1. 1 + card (proots_within pq A) =\n    card (proots_within bbq A) + card (proots_within pq A)", "by simp"], ["proof (state)\nthis:\n  1 + card (proots_within pq A) =\n  card (proots_within bbq A) + card (proots_within pq A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 + card (proots_within (p \\<circ>\\<^sub>p q) A) =\n  card (proots_within ((bb * p) \\<circ>\\<^sub>p q) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "finally"], ["proof (chain)\npicking this:\n  card (proots_within (bb * p) B) =\n  card (proots_within ((bb * p) \\<circ>\\<^sub>p q) A)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (proots_within (bb * p) B) =\n  card (proots_within ((bb * p) \\<circ>\\<^sub>p q) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "unfolding bb_def"], ["proof (prove)\nusing this:\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "."], ["proof (state)\nthis:\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>b \\<in> B; poly p b \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> card (proots_within ([:- b, 1::'a:] * p) B) =\n                    card\n                     (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q)\n                       A)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                card (proots_within p B) =\n                card (proots_within (p \\<circ>\\<^sub>p q) A);\n        [:- a, 1::'a:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card (proots_within ([:- a, 1::'a:] * p) B) =\n                         card\n                          (proots_within\n                            (([:- a, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "ultimately"], ["proof (chain)\npicking this:\n  b \\<notin> B \\<or> poly p b = (0::'a) \\<Longrightarrow>\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)\n  \\<lbrakk>b \\<in> B; poly p b \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> card (proots_within ([:- b, 1::'a:] * p) B) =\n                    card\n                     (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q)\n                       A)", "show ?case"], ["proof (prove)\nusing this:\n  b \\<notin> B \\<or> poly p b = (0::'a) \\<Longrightarrow>\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)\n  \\<lbrakk>b \\<in> B; poly p b \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> card (proots_within ([:- b, 1::'a:] * p) B) =\n                    card\n                     (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q)\n                       A)\n\ngoal (1 subgoal):\n 1. card (proots_within ([:- b, 1::'a:] * p) B) =\n    card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)", "by auto"], ["proof (state)\nthis:\n  card (proots_within ([:- b, 1::'a:] * p) B) =\n  card (proots_within (([:- b, 1::'a:] * p) \\<circ>\\<^sub>p q) A)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}