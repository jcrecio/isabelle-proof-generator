{"file_name": "/home/qj213/afp-2021-10-22/thys/Budan_Fourier/Sturm_Multiple_Roots.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Budan_Fourier", "problem_names": ["lemma last_smods_gcd:\n  fixes p q ::\"real poly\"\n  defines \"pp \\<equiv> last (smods p q)\" \n  assumes \"p\\<noteq>0\"\n  shows \"pp = smult (lead_coeff pp) (gcd p q)\"", "lemma last_smods_nzero:\n  assumes \"p\\<noteq>0\"\n  shows \"last (smods p q) \\<noteq>0\"", "lemma smods_ext_prefix:\n  fixes p q::\"real poly\"\n  defines \"pp \\<equiv> last (smods p q)\" \n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"smods_ext p q = smods p q @ tl (smods_ext pp (pderiv pp))\"", "lemma no_0_in_smods_ext: \"0\\<notin>set (smods_ext p q)\"", "theorem sturm_ext_interval:\n  assumes \"a<b\" \"poly p a\\<noteq>0\" \"poly p b\\<noteq>0\"\n  shows \"proots_count p {x. a<x \\<and> x<b} = changes_itv_smods_ext a b p (pderiv p)\"", "theorem sturm_ext_above:\n  assumes \"poly p a\\<noteq>0\" \n  shows \"proots_count p {x. a<x} = changes_gt_smods_ext a p (pderiv p)\"", "theorem sturm_ext_below:\n  assumes \"poly p b\\<noteq>0\" \n  shows \"proots_count p {x. x<b} = changes_le_smods_ext b p (pderiv p)\"", "theorem sturm_ext_R: \n  assumes \"p\\<noteq>0\"\n  shows \"proots_count p UNIV = changes_R_smods_ext p (pderiv p)\""], "translations": [["", "lemma last_smods_gcd:\n  fixes p q ::\"real poly\"\n  defines \"pp \\<equiv> last (smods p q)\" \n  assumes \"p\\<noteq>0\"\n  shows \"pp = smult (lead_coeff pp) (gcd p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp = smult (lead_coeff pp) (gcd p q)", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pp = smult (lead_coeff pp) (gcd p q)", "unfolding pp_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "proof (induct \"smods p q\" arbitrary:p q rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       last (smods x xa) =\n                       smult (lead_coeff (last (smods x xa))) (gcd x xa));\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> last (smods p q) =\n                         smult (lead_coeff (last (smods p q))) (gcd p q)", "case 1"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length (smods p q) \\<longrightarrow>\n     (\\<forall>x xa.\n         ys = smods x xa \\<longrightarrow>\n         x \\<noteq> 0 \\<longrightarrow>\n         last (smods x xa) =\n         smult (lead_coeff (last (smods x xa))) (gcd x xa))\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       last (smods x xa) =\n                       smult (lead_coeff (last (smods x xa))) (gcd x xa));\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> last (smods p q) =\n                         smult (lead_coeff (last (smods p q))) (gcd p q)", "have ?case when \"q=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "using that smult_normalize_field_eq \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q = 0\n  ?p = smult (lead_coeff ?p) (normalize ?p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "by auto"], ["proof (state)\nthis:\n  q = 0 \\<Longrightarrow>\n  last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       last (smods x xa) =\n                       smult (lead_coeff (last (smods x xa))) (gcd x xa));\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> last (smods p q) =\n                         smult (lead_coeff (last (smods p q))) (gcd p q)", "moreover"], ["proof (state)\nthis:\n  q = 0 \\<Longrightarrow>\n  last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       last (smods x xa) =\n                       smult (lead_coeff (last (smods x xa))) (gcd x xa));\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> last (smods p q) =\n                         smult (lead_coeff (last (smods p q))) (gcd p q)", "have ?case when \"q\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "define r where \"r= - (p mod q)\""], ["proof (state)\nthis:\n  r = - (p mod q)\n\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "have smods_cons:\"smods p q = p # smods q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods p q = p # smods q r", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. smods p q = p # smods q (- (p mod q))", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smods p q = p # smods q (- (p mod q))", "by simp"], ["proof (state)\nthis:\n  smods p q = p # smods q r\n\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "have \"last (smods q r) = smult (lead_coeff (last (smods q r))) (gcd q r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (smods q r) = smult (lead_coeff (last (smods q r))) (gcd q r)", "apply (rule 1(1)[rule_format,of \"smods q r\" q r])"], ["proof (prove)\ngoal (3 subgoals):\n 1. length (smods q r) < length (smods p q)\n 2. smods q r = smods q r\n 3. q \\<noteq> 0", "using smods_cons \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  smods p q = p # smods q r\n  q \\<noteq> 0\n\ngoal (3 subgoals):\n 1. length (smods q r) < length (smods p q)\n 2. smods q r = smods q r\n 3. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  last (smods q r) = smult (lead_coeff (last (smods q r))) (gcd q r)\n\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "moreover"], ["proof (state)\nthis:\n  last (smods q r) = smult (lead_coeff (last (smods q r))) (gcd q r)\n\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "have \"gcd p q = gcd q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p q = gcd q r", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p q = gcd q (- (p mod q))", "by (simp add: gcd.commute that)"], ["proof (state)\nthis:\n  gcd p q = gcd q r\n\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "ultimately"], ["proof (chain)\npicking this:\n  last (smods q r) = smult (lead_coeff (last (smods q r))) (gcd q r)\n  gcd p q = gcd q r", "show ?thesis"], ["proof (prove)\nusing this:\n  last (smods q r) = smult (lead_coeff (last (smods q r))) (gcd q r)\n  gcd p q = gcd q r\n\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "unfolding smods_cons"], ["proof (prove)\nusing this:\n  last (smods q r) = smult (lead_coeff (last (smods q r))) (gcd q r)\n  gcd p q = gcd q r\n\ngoal (1 subgoal):\n 1. last (p # smods q r) =\n    smult (lead_coeff (last (p # smods q r))) (gcd p q)", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  last (smods q r) = smult (lead_coeff (last (smods q r))) (gcd q r)\n  gcd p q = gcd q r\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. last (p # smods q r) =\n    smult (lead_coeff (last (p # smods q r))) (gcd p q)", "by simp"], ["proof (state)\nthis:\n  last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<noteq> 0 \\<Longrightarrow>\n  last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       last (smods x xa) =\n                       smult (lead_coeff (last (smods x xa))) (gcd x xa));\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> last (smods p q) =\n                         smult (lead_coeff (last (smods p q))) (gcd p q)", "ultimately"], ["proof (chain)\npicking this:\n  q = 0 \\<Longrightarrow>\n  last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)\n  q \\<noteq> 0 \\<Longrightarrow>\n  last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "show ?case"], ["proof (prove)\nusing this:\n  q = 0 \\<Longrightarrow>\n  last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)\n  q \\<noteq> 0 \\<Longrightarrow>\n  last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)\n\ngoal (1 subgoal):\n 1. last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)", "by argo"], ["proof (state)\nthis:\n  last (smods p q) = smult (lead_coeff (last (smods p q))) (gcd p q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma last_smods_nzero:\n  assumes \"p\\<noteq>0\"\n  shows \"last (smods p q) \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (smods p q) \\<noteq> 0", "by (metis assms last_in_set no_0_in_smods smods_nil_eq)"], ["", "subsection \\<open>Alternative signed remainder sequences\\<close>"], ["", "function smods_ext::\"real poly \\<Rightarrow> real poly \\<Rightarrow> real poly list\" where \n  \"smods_ext p q = (if p=0 then [] else\n                      (if p mod q \\<noteq> 0  \n                        then Cons p (smods_ext q (-(p mod q))) \n                        else Cons p (smods_ext q (pderiv q)))\n                   )\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>p q. x = (p, q) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>p q pa qa.\n       (p, q) = (pa, qa) \\<Longrightarrow>\n       (if p = 0 then []\n        else if p mod q \\<noteq> 0 then p # smods_ext_sumC (q, - (p mod q))\n             else p # smods_ext_sumC (q, pderiv q)) =\n       (if pa = 0 then []\n        else if pa mod qa \\<noteq> 0\n             then pa # smods_ext_sumC (qa, - (pa mod qa))\n             else pa # smods_ext_sumC (qa, pderiv qa))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All smods_ext_dom", "apply (relation \"measure (\\<lambda>(p,q).if p=0 then 0 else if q=0 then 1 else 2+degree q)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (measure\n         (\\<lambda>(p, q).\n             if p = 0 then 0 else if q = 0 then 1 else 2 + degree q))\n 2. \\<And>p q.\n       \\<lbrakk>p \\<noteq> 0; p mod q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> ((q, - (p mod q)), p, q)\n                         \\<in> measure\n                                (\\<lambda>(p, q).\n                                    if p = 0 then 0\n                                    else if q = 0 then 1 else 2 + degree q)\n 3. \\<And>p q.\n       \\<lbrakk>p \\<noteq> 0; \\<not> p mod q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> ((q, pderiv q), p, q)\n                         \\<in> measure\n                                (\\<lambda>(p, q).\n                                    if p = 0 then 0\n                                    else if q = 0 then 1 else 2 + degree q)", "using degree_mod_less"], ["proof (prove)\nusing this:\n  ?y \\<noteq> 0 \\<Longrightarrow>\n  ?x mod ?y = 0 \\<or> degree (?x mod ?y) < degree ?y\n\ngoal (3 subgoals):\n 1. wf (measure\n         (\\<lambda>(p, q).\n             if p = 0 then 0 else if q = 0 then 1 else 2 + degree q))\n 2. \\<And>p q.\n       \\<lbrakk>p \\<noteq> 0; p mod q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> ((q, - (p mod q)), p, q)\n                         \\<in> measure\n                                (\\<lambda>(p, q).\n                                    if p = 0 then 0\n                                    else if q = 0 then 1 else 2 + degree q)\n 3. \\<And>p q.\n       \\<lbrakk>p \\<noteq> 0; \\<not> p mod q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> ((q, pderiv q), p, q)\n                         \\<in> measure\n                                (\\<lambda>(p, q).\n                                    if p = 0 then 0\n                                    else if q = 0 then 1 else 2 + degree q)", "by (auto simp add:degree_pderiv pderiv_eq_0_iff)"], ["", "lemma smods_ext_prefix:\n  fixes p q::\"real poly\"\n  defines \"pp \\<equiv> last (smods p q)\" \n  assumes \"p\\<noteq>0\" \"q\\<noteq>0\"\n  shows \"smods_ext p q = smods p q @ tl (smods_ext pp (pderiv pp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext p q = smods p q @ tl (smods_ext pp (pderiv pp))", "unfolding pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "using assms(2,3)"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "proof (induct \"smods_ext p q\" arbitrary:p q rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods_ext p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods_ext x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       xa \\<noteq> 0 \\<longrightarrow>\n                       smods_ext x xa =\n                       smods x xa @\n                       tl (smods_ext (last (smods x xa))\n                            (pderiv (last (smods x xa)))));\n        p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> smods_ext p q =\n                         smods p q @\n                         tl (smods_ext (last (smods p q))\n                              (pderiv (last (smods p q))))", "case 1"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length (smods_ext p q) \\<longrightarrow>\n     (\\<forall>x xa.\n         ys = smods_ext x xa \\<longrightarrow>\n         x \\<noteq> 0 \\<longrightarrow>\n         xa \\<noteq> 0 \\<longrightarrow>\n         smods_ext x xa =\n         smods x xa @\n         tl (smods_ext (last (smods x xa)) (pderiv (last (smods x xa)))))\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods_ext p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods_ext x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       xa \\<noteq> 0 \\<longrightarrow>\n                       smods_ext x xa =\n                       smods x xa @\n                       tl (smods_ext (last (smods x xa))\n                            (pderiv (last (smods x xa)))));\n        p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> smods_ext p q =\n                         smods p q @\n                         tl (smods_ext (last (smods p q))\n                              (pderiv (last (smods p q))))", "have ?case when \"p mod q \\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "define pp where \"pp=last (smods q (- (p mod q)))\""], ["proof (state)\nthis:\n  pp = last (smods q (- (p mod q)))\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "have smods_cons:\"smods p q = p# smods q (- (p mod q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods p q = p # smods q (- (p mod q))", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smods p q = p # smods q (- (p mod q))", "by auto"], ["proof (state)\nthis:\n  smods p q = p # smods q (- (p mod q))\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "then"], ["proof (chain)\npicking this:\n  smods p q = p # smods q (- (p mod q))", "have pp_last:\"pp=last (smods p q)\""], ["proof (prove)\nusing this:\n  smods p q = p # smods q (- (p mod q))\n\ngoal (1 subgoal):\n 1. pp = last (smods p q)", "unfolding pp_def"], ["proof (prove)\nusing this:\n  smods p q = p # smods q (- (p mod q))\n\ngoal (1 subgoal):\n 1. last (smods q (- (p mod q))) = last (smods p q)", "by (simp add: \"1.prems\"(2) pp_def)"], ["proof (state)\nthis:\n  pp = last (smods p q)\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "have smods_ext_cons:\"smods_ext p q = p # smods_ext q (- (p mod q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext p q = p # smods_ext q (- (p mod q))", "using that \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p mod q \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smods_ext p q = p # smods_ext q (- (p mod q))", "by auto"], ["proof (state)\nthis:\n  smods_ext p q = p # smods_ext q (- (p mod q))\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "have \"smods_ext q (- (p mod q)) = smods q (- (p mod q)) @ tl (smods_ext pp (pderiv pp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext q (- (p mod q)) =\n    smods q (- (p mod q)) @ tl (smods_ext pp (pderiv pp))", "apply (rule 1(1)[rule_format,of \"smods_ext q (- (p mod q))\" q \"- (p mod q)\",folded pp_def])"], ["proof (prove)\ngoal (4 subgoals):\n 1. length (smods_ext q (- (p mod q))) < length (smods_ext p q)\n 2. smods_ext q (- (p mod q)) = smods_ext q (- (p mod q))\n 3. q \\<noteq> 0\n 4. - (p mod q) \\<noteq> 0", "using smods_ext_cons \\<open>q\\<noteq>0\\<close> that"], ["proof (prove)\nusing this:\n  smods_ext p q = p # smods_ext q (- (p mod q))\n  q \\<noteq> 0\n  p mod q \\<noteq> 0\n\ngoal (4 subgoals):\n 1. length (smods_ext q (- (p mod q))) < length (smods_ext p q)\n 2. smods_ext q (- (p mod q)) = smods_ext q (- (p mod q))\n 3. q \\<noteq> 0\n 4. - (p mod q) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  smods_ext q (- (p mod q)) =\n  smods q (- (p mod q)) @ tl (smods_ext pp (pderiv pp))\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "then"], ["proof (chain)\npicking this:\n  smods_ext q (- (p mod q)) =\n  smods q (- (p mod q)) @ tl (smods_ext pp (pderiv pp))", "show ?thesis"], ["proof (prove)\nusing this:\n  smods_ext q (- (p mod q)) =\n  smods q (- (p mod q)) @ tl (smods_ext pp (pderiv pp))\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "unfolding pp_last"], ["proof (prove)\nusing this:\n  smods_ext q (- (p mod q)) =\n  smods q (- (p mod q)) @\n  tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "apply (subst smods_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext q (- (p mod q)) =\n    smods q (- (p mod q)) @\n    tl (smods_ext (last (smods p q))\n         (pderiv (last (smods p q)))) \\<Longrightarrow>\n    smods_ext p q =\n    (p # smods q (- (p mod q))) @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "apply (subst smods_ext_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext q (- (p mod q)) =\n    smods q (- (p mod q)) @\n    tl (smods_ext (last (smods p q))\n         (pderiv (last (smods p q)))) \\<Longrightarrow>\n    p # smods_ext q (- (p mod q)) =\n    (p # smods q (- (p mod q))) @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "by auto"], ["proof (state)\nthis:\n  smods_ext p q =\n  smods p q @ tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p mod q \\<noteq> 0 \\<Longrightarrow>\n  smods_ext p q =\n  smods p q @ tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods_ext p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods_ext x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       xa \\<noteq> 0 \\<longrightarrow>\n                       smods_ext x xa =\n                       smods x xa @\n                       tl (smods_ext (last (smods x xa))\n                            (pderiv (last (smods x xa)))));\n        p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> smods_ext p q =\n                         smods p q @\n                         tl (smods_ext (last (smods p q))\n                              (pderiv (last (smods p q))))", "moreover"], ["proof (state)\nthis:\n  p mod q \\<noteq> 0 \\<Longrightarrow>\n  smods_ext p q =\n  smods p q @ tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods_ext p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods_ext x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       xa \\<noteq> 0 \\<longrightarrow>\n                       smods_ext x xa =\n                       smods x xa @\n                       tl (smods_ext (last (smods x xa))\n                            (pderiv (last (smods x xa)))));\n        p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> smods_ext p q =\n                         smods p q @\n                         tl (smods_ext (last (smods p q))\n                              (pderiv (last (smods p q))))", "have ?case when \"p mod q =0\" \"pderiv q = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "have \"smods p q = [p,q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods p q = [p, q]", "using \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close> that"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  p mod q = 0\n  pderiv q = 0\n\ngoal (1 subgoal):\n 1. smods p q = [p, q]", "by auto"], ["proof (state)\nthis:\n  smods p q = [p, q]\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "moreover"], ["proof (state)\nthis:\n  smods p q = [p, q]\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "have \"smods_ext p q = [p,q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext p q = [p, q]", "using that \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p mod q = 0\n  pderiv q = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smods_ext p q = [p, q]", "by auto"], ["proof (state)\nthis:\n  smods_ext p q = [p, q]\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "ultimately"], ["proof (chain)\npicking this:\n  smods p q = [p, q]\n  smods_ext p q = [p, q]", "show ?case"], ["proof (prove)\nusing this:\n  smods p q = [p, q]\n  smods_ext p q = [p, q]\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "using \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close> that(1)"], ["proof (prove)\nusing this:\n  smods p q = [p, q]\n  smods_ext p q = [p, q]\n  p \\<noteq> 0\n  q \\<noteq> 0\n  p mod q = 0\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "by auto"], ["proof (state)\nthis:\n  smods_ext p q =\n  smods p q @ tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p mod q = 0; pderiv q = 0\\<rbrakk>\n  \\<Longrightarrow> smods_ext p q =\n                    smods p q @\n                    tl (smods_ext (last (smods p q))\n                         (pderiv (last (smods p q))))\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods_ext p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods_ext x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       xa \\<noteq> 0 \\<longrightarrow>\n                       smods_ext x xa =\n                       smods x xa @\n                       tl (smods_ext (last (smods x xa))\n                            (pderiv (last (smods x xa)))));\n        p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> smods_ext p q =\n                         smods p q @\n                         tl (smods_ext (last (smods p q))\n                              (pderiv (last (smods p q))))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>p mod q = 0; pderiv q = 0\\<rbrakk>\n  \\<Longrightarrow> smods_ext p q =\n                    smods p q @\n                    tl (smods_ext (last (smods p q))\n                         (pderiv (last (smods p q))))\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods_ext p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods_ext x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       xa \\<noteq> 0 \\<longrightarrow>\n                       smods_ext x xa =\n                       smods x xa @\n                       tl (smods_ext (last (smods x xa))\n                            (pderiv (last (smods x xa)))));\n        p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> smods_ext p q =\n                         smods p q @\n                         tl (smods_ext (last (smods p q))\n                              (pderiv (last (smods p q))))", "have ?case when \"p mod q =0\" \"pderiv q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "have smods_cons:\"smods p q = [p,q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods p q = [p, q]", "using \\<open>p\\<noteq>0\\<close> \\<open>q\\<noteq>0\\<close> that"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  p mod q = 0\n  pderiv q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smods p q = [p, q]", "by auto"], ["proof (state)\nthis:\n  smods p q = [p, q]\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "have smods_ext_cons:\"smods_ext p q = p#smods_ext q (pderiv q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext p q = p # smods_ext q (pderiv q)", "using that \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p mod q = 0\n  pderiv q \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smods_ext p q = p # smods_ext q (pderiv q)", "by auto"], ["proof (state)\nthis:\n  smods_ext p q = p # smods_ext q (pderiv q)\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "unfolding smods_cons smods_ext_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. p # smods_ext q (pderiv q) =\n    [p, q] @ tl (smods_ext (last [p, q]) (pderiv (last [p, q])))", "apply (simp del:smods_ext.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext q (pderiv q) = q # tl (smods_ext q (pderiv q))", "by (simp add: \"1.prems\"(2))"], ["proof (state)\nthis:\n  smods_ext p q =\n  smods p q @ tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>p mod q = 0; pderiv q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> smods_ext p q =\n                    smods p q @\n                    tl (smods_ext (last (smods p q))\n                         (pderiv (last (smods p q))))\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length (smods_ext p q) \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ys = smods_ext x xa \\<longrightarrow>\n                       x \\<noteq> 0 \\<longrightarrow>\n                       xa \\<noteq> 0 \\<longrightarrow>\n                       smods_ext x xa =\n                       smods x xa @\n                       tl (smods_ext (last (smods x xa))\n                            (pderiv (last (smods x xa)))));\n        p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> smods_ext p q =\n                         smods p q @\n                         tl (smods_ext (last (smods p q))\n                              (pderiv (last (smods p q))))", "ultimately"], ["proof (chain)\npicking this:\n  p mod q \\<noteq> 0 \\<Longrightarrow>\n  smods_ext p q =\n  smods p q @ tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))\n  \\<lbrakk>p mod q = 0; pderiv q = 0\\<rbrakk>\n  \\<Longrightarrow> smods_ext p q =\n                    smods p q @\n                    tl (smods_ext (last (smods p q))\n                         (pderiv (last (smods p q))))\n  \\<lbrakk>p mod q = 0; pderiv q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> smods_ext p q =\n                    smods p q @\n                    tl (smods_ext (last (smods p q))\n                         (pderiv (last (smods p q))))", "show ?case"], ["proof (prove)\nusing this:\n  p mod q \\<noteq> 0 \\<Longrightarrow>\n  smods_ext p q =\n  smods p q @ tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))\n  \\<lbrakk>p mod q = 0; pderiv q = 0\\<rbrakk>\n  \\<Longrightarrow> smods_ext p q =\n                    smods p q @\n                    tl (smods_ext (last (smods p q))\n                         (pderiv (last (smods p q))))\n  \\<lbrakk>p mod q = 0; pderiv q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> smods_ext p q =\n                    smods p q @\n                    tl (smods_ext (last (smods p q))\n                         (pderiv (last (smods p q))))\n\ngoal (1 subgoal):\n 1. smods_ext p q =\n    smods p q @\n    tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))", "by argo"], ["proof (state)\nthis:\n  smods_ext p q =\n  smods p q @ tl (smods_ext (last (smods p q)) (pderiv (last (smods p q))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_0_in_smods_ext: \"0\\<notin>set (smods_ext p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> set (smods_ext p q)", "apply (induct \"smods_ext p q\" arbitrary:p q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q.\n       [] = smods_ext p q \\<Longrightarrow> 0 \\<notin> set (smods_ext p q)\n 2. \\<And>a x p q.\n       \\<lbrakk>\\<And>p q.\n                   x = smods_ext p q \\<Longrightarrow>\n                   0 \\<notin> set (smods_ext p q);\n        a # x = smods_ext p q\\<rbrakk>\n       \\<Longrightarrow> 0 \\<notin> set (smods_ext p q)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x p q.\n       \\<lbrakk>\\<And>p q.\n                   x = smods_ext p q \\<Longrightarrow>\n                   0 \\<notin> set (smods_ext p q);\n        a # x = smods_ext p q\\<rbrakk>\n       \\<Longrightarrow> 0 \\<notin> set (smods_ext p q)", "by (metis list.distinct(1) list.inject set_ConsD smods_ext.simps)"], ["", "subsection \\<open>Sign variations on the alternative signed remainder sequences\\<close>"], ["", "definition changes_itv_smods_ext:: \"real \\<Rightarrow> real \\<Rightarrow>real poly \\<Rightarrow> real poly \\<Rightarrow>  int\" where\n  \"changes_itv_smods_ext a b p q= (let ps= smods_ext p q in changes_poly_at ps a \n        - changes_poly_at ps b)\""], ["", "definition changes_gt_smods_ext:: \"real \\<Rightarrow>real poly \\<Rightarrow> real poly \\<Rightarrow>  int\" where\n  \"changes_gt_smods_ext a p q= (let ps= smods_ext p q in changes_poly_at ps a \n        - changes_poly_pos_inf ps)\""], ["", "definition changes_le_smods_ext:: \"real \\<Rightarrow>real poly \\<Rightarrow> real poly \\<Rightarrow>  int\" where\n  \"changes_le_smods_ext b p q= (let ps= smods_ext p q in changes_poly_neg_inf ps \n        - changes_poly_at ps b)\""], ["", "definition changes_R_smods_ext:: \"real poly \\<Rightarrow> real poly \\<Rightarrow>  int\" where\n  \"changes_R_smods_ext p q= (let ps= smods_ext p q in changes_poly_neg_inf ps \n        - changes_poly_pos_inf ps)\""], ["", "subsection \\<open>Extension of Sturm's theorem for multiple roots\\<close>"], ["", "theorem sturm_ext_interval:\n  assumes \"a<b\" \"poly p a\\<noteq>0\" \"poly p b\\<noteq>0\"\n  shows \"proots_count p {x. a<x \\<and> x<b} = changes_itv_smods_ext a b p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "using assms(2,3)"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "proof (induct \"smods_ext p (pderiv p)\" arbitrary:p rule:length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>ys.\n                   length ys\n                   < length (smods_ext p (pderiv p)) \\<longrightarrow>\n                   (\\<forall>x.\n                       ys = smods_ext x (pderiv x) \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       poly x b \\<noteq> 0 \\<longrightarrow>\n                       int (proots_count x {x. a < x \\<and> x < b}) =\n                       changes_itv_smods_ext a b x (pderiv x));\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x < b}) =\n                         changes_itv_smods_ext a b p (pderiv p)", "case 1"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length (smods_ext p (pderiv p)) \\<longrightarrow>\n     (\\<forall>x.\n         ys = smods_ext x (pderiv x) \\<longrightarrow>\n         poly x a \\<noteq> 0 \\<longrightarrow>\n         poly x b \\<noteq> 0 \\<longrightarrow>\n         int (proots_count x {x. a < x \\<and> x < b}) =\n         changes_itv_smods_ext a b x (pderiv x))\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>ys.\n                   length ys\n                   < length (smods_ext p (pderiv p)) \\<longrightarrow>\n                   (\\<forall>x.\n                       ys = smods_ext x (pderiv x) \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       poly x b \\<noteq> 0 \\<longrightarrow>\n                       int (proots_count x {x. a < x \\<and> x < b}) =\n                       changes_itv_smods_ext a b x (pderiv x));\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x < b}) =\n                         changes_itv_smods_ext a b p (pderiv p)", "have \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using \\<open>poly p a \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>ys.\n                   length ys\n                   < length (smods_ext p (pderiv p)) \\<longrightarrow>\n                   (\\<forall>x.\n                       ys = smods_ext x (pderiv x) \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       poly x b \\<noteq> 0 \\<longrightarrow>\n                       int (proots_count x {x. a < x \\<and> x < b}) =\n                       changes_itv_smods_ext a b x (pderiv x));\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x < b}) =\n                         changes_itv_smods_ext a b p (pderiv p)", "have ?case when \"pderiv p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "obtain c where \"p=[:c:]\" \"c\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>p = [:c:]; c \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>p\\<noteq>0\\<close> \\<open>pderiv p = 0\\<close> pderiv_iszero"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  pderiv p = 0\n  pderiv ?p = 0 \\<Longrightarrow> \\<exists>h. ?p = [:h:]\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>p = [:c:]; c \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  p = [:c:]\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "then"], ["proof (chain)\npicking this:\n  p = [:c:]\n  c \\<noteq> 0", "have \"proots_count p {x. a < x \\<and> x < b} = 0\""], ["proof (prove)\nusing this:\n  p = [:c:]\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x < b} = 0", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  p = [:c:]\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p {x. a < x \\<and> x < b}. order r p) = 0", "by auto"], ["proof (state)\nthis:\n  proots_count p {x. a < x \\<and> x < b} = 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  proots_count p {x. a < x \\<and> x < b} = 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "have \"changes_itv_smods_ext a b p (pderiv p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_smods_ext a b p (pderiv p) = 0", "unfolding changes_itv_smods_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ps = smods_ext p (pderiv p)\n     in changes_poly_at ps a - changes_poly_at ps b) =\n    0", "using \\<open>p=[:c:]\\<close> \\<open>c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p = [:c:]\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (let ps = smods_ext p (pderiv p)\n     in changes_poly_at ps a - changes_poly_at ps b) =\n    0", "by auto"], ["proof (state)\nthis:\n  changes_itv_smods_ext a b p (pderiv p) = 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "ultimately"], ["proof (chain)\npicking this:\n  proots_count p {x. a < x \\<and> x < b} = 0\n  changes_itv_smods_ext a b p (pderiv p) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count p {x. a < x \\<and> x < b} = 0\n  changes_itv_smods_ext a b p (pderiv p) = 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "by auto"], ["proof (state)\nthis:\n  int (proots_count p {x. a < x \\<and> x < b}) =\n  changes_itv_smods_ext a b p (pderiv p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pderiv p = 0 \\<Longrightarrow>\n  int (proots_count p {x. a < x \\<and> x < b}) =\n  changes_itv_smods_ext a b p (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>ys.\n                   length ys\n                   < length (smods_ext p (pderiv p)) \\<longrightarrow>\n                   (\\<forall>x.\n                       ys = smods_ext x (pderiv x) \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       poly x b \\<noteq> 0 \\<longrightarrow>\n                       int (proots_count x {x. a < x \\<and> x < b}) =\n                       changes_itv_smods_ext a b x (pderiv x));\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x < b}) =\n                         changes_itv_smods_ext a b p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  pderiv p = 0 \\<Longrightarrow>\n  int (proots_count p {x. a < x \\<and> x < b}) =\n  changes_itv_smods_ext a b p (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>ys.\n                   length ys\n                   < length (smods_ext p (pderiv p)) \\<longrightarrow>\n                   (\\<forall>x.\n                       ys = smods_ext x (pderiv x) \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       poly x b \\<noteq> 0 \\<longrightarrow>\n                       int (proots_count x {x. a < x \\<and> x < b}) =\n                       changes_itv_smods_ext a b x (pderiv x));\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x < b}) =\n                         changes_itv_smods_ext a b p (pderiv p)", "have ?case when \"pderiv p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "define pp where \"pp = last (smods p (pderiv p))\""], ["proof (state)\nthis:\n  pp = last (smods p (pderiv p))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "define lp where \"lp = lead_coeff pp\""], ["proof (state)\nthis:\n  lp = lead_coeff pp\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "define S where \"S={x. a < x \\<and> x< b}\""], ["proof (state)\nthis:\n  S = {x. a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "have prefix:\"smods_ext p (pderiv p) = smods p (pderiv p) @ tl (smods_ext pp (pderiv pp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext p (pderiv p) =\n    smods p (pderiv p) @ tl (smods_ext pp (pderiv pp))", "using smods_ext_prefix[OF \\<open>p\\<noteq>0\\<close> \\<open>pderiv p\\<noteq>0\\<close>,folded pp_def]"], ["proof (prove)\nusing this:\n  smods_ext p (pderiv p) =\n  smods p (pderiv p) @ tl (smods_ext pp (pderiv pp))\n\ngoal (1 subgoal):\n 1. smods_ext p (pderiv p) =\n    smods p (pderiv p) @ tl (smods_ext pp (pderiv pp))", "."], ["proof (state)\nthis:\n  smods_ext p (pderiv p) =\n  smods p (pderiv p) @ tl (smods_ext pp (pderiv pp))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "have pp_gcd:\"pp = smult lp (gcd p (pderiv p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp = smult lp (gcd p (pderiv p))", "using last_smods_gcd[OF \\<open>p\\<noteq>0\\<close>,of \"pderiv p\",folded pp_def lp_def]"], ["proof (prove)\nusing this:\n  pp = smult lp (gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. pp = smult lp (gcd p (pderiv p))", "."], ["proof (state)\nthis:\n  pp = smult lp (gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "have \"pp\\<noteq>0\" \"lp\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp \\<noteq> 0 &&& lp \\<noteq> 0", "unfolding pp_def lp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (smods p (pderiv p)) \\<noteq> 0 &&&\n    lead_coeff (last (smods p (pderiv p))) \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (smods p (pderiv p)) \\<noteq> 0", "by (rule last_smods_nzero[OF \\<open>p\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (last (smods p (pderiv p))) \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (last (smods p (pderiv p))) \\<noteq> 0", "using \\<open>last (smods p (pderiv p)) \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  last (smods p (pderiv p)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (last (smods p (pderiv p))) \\<noteq> 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pp \\<noteq> 0\n  lp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "have \"poly pp a\\<noteq>0\" \"poly pp b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly pp a \\<noteq> 0 &&& poly pp b \\<noteq> 0", "unfolding pp_gcd"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (smult lp (gcd p (pderiv p))) a \\<noteq> 0 &&&\n    poly (smult lp (gcd p (pderiv p))) b \\<noteq> 0", "using \\<open>poly p a\\<noteq>0\\<close> \\<open>poly p b\\<noteq>0\\<close> \\<open>lp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n  poly p b \\<noteq> 0\n  lp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (smult lp (gcd p (pderiv p))) a \\<noteq> 0 &&&\n    poly (smult lp (gcd p (pderiv p))) b \\<noteq> 0", "by (simp_all add:poly_gcd_0_iff)"], ["proof (state)\nthis:\n  poly pp a \\<noteq> 0\n  poly pp b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "have \"proots_count pp S = changes_itv_smods_ext a b pp (pderiv pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count pp S) = changes_itv_smods_ext a b pp (pderiv pp)", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count pp {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b pp (pderiv pp)", "proof (rule 1(1)[rule_format,of \"smods_ext pp (pderiv pp)\" pp])"], ["proof (state)\ngoal (4 subgoals):\n 1. length (smods_ext pp (pderiv pp)) < length (smods_ext p (pderiv p))\n 2. smods_ext pp (pderiv pp) = smods_ext pp (pderiv pp)\n 3. poly pp a \\<noteq> 0\n 4. poly pp b \\<noteq> 0", "show \"length (smods_ext pp (pderiv pp)) < length (smods_ext p (pderiv p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (smods_ext pp (pderiv pp)) < length (smods_ext p (pderiv p))", "unfolding prefix"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (smods_ext pp (pderiv pp))\n    < length (smods p (pderiv p) @ tl (smods_ext pp (pderiv pp)))", "by (simp add: \\<open>p \\<noteq> 0\\<close> that)"], ["proof (state)\nthis:\n  length (smods_ext pp (pderiv pp)) < length (smods_ext p (pderiv p))\n\ngoal (3 subgoals):\n 1. smods_ext pp (pderiv pp) = smods_ext pp (pderiv pp)\n 2. poly pp a \\<noteq> 0\n 3. poly pp b \\<noteq> 0", "qed (use \\<open>poly pp a\\<noteq>0\\<close> \\<open>poly pp b\\<noteq>0\\<close> in simp_all)"], ["proof (state)\nthis:\n  int (proots_count pp S) = changes_itv_smods_ext a b pp (pderiv pp)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  int (proots_count pp S) = changes_itv_smods_ext a b pp (pderiv pp)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "have \"proots_count p S = card (proots_within p S) + proots_count pp S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p S = card (proots_within p S) + proots_count pp S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count p S = card (proots_within p S) + proots_count pp S", "have \"(\\<Sum>r\\<in>proots_within p S. order r p) = (\\<Sum>r\\<in> proots_within p S. order r pp + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p S. order r p) =\n    (\\<Sum>r\\<in>proots_within p S. order r pp + 1)", "proof (rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. proots_within p S = proots_within p S\n 2. \\<And>x.\n       x \\<in> proots_within p S \\<Longrightarrow>\n       order x p = order x pp + 1", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. proots_within p S = proots_within p S\n 2. \\<And>x.\n       x \\<in> proots_within p S \\<Longrightarrow>\n       order x p = order x pp + 1", "assume \"x \\<in> proots_within p S\""], ["proof (state)\nthis:\n  x \\<in> proots_within p S\n\ngoal (2 subgoals):\n 1. proots_within p S = proots_within p S\n 2. \\<And>x.\n       x \\<in> proots_within p S \\<Longrightarrow>\n       order x p = order x pp + 1", "have \"order x pp = order x (gcd p (pderiv p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x pp = order x (gcd p (pderiv p))", "unfolding pp_gcd"], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (smult lp (gcd p (pderiv p))) = order x (gcd p (pderiv p))", "using \\<open>lp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  lp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x (smult lp (gcd p (pderiv p))) = order x (gcd p (pderiv p))", "by (simp add:order_smult)"], ["proof (state)\nthis:\n  order x pp = order x (gcd p (pderiv p))\n\ngoal (2 subgoals):\n 1. proots_within p S = proots_within p S\n 2. \\<And>x.\n       x \\<in> proots_within p S \\<Longrightarrow>\n       order x p = order x pp + 1", "also"], ["proof (state)\nthis:\n  order x pp = order x (gcd p (pderiv p))\n\ngoal (2 subgoals):\n 1. proots_within p S = proots_within p S\n 2. \\<And>x.\n       x \\<in> proots_within p S \\<Longrightarrow>\n       order x p = order x pp + 1", "have \"... = min (order x p) (order x (pderiv p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (gcd p (pderiv p)) = min (order x p) (order x (pderiv p))", "apply (subst order_gcd)"], ["proof (prove)\ngoal (3 subgoals):\n 1. p \\<noteq> 0\n 2. pderiv p \\<noteq> 0\n 3. min (order x p) (order x (pderiv p)) =\n    min (order x p) (order x (pderiv p))", "using \\<open>p\\<noteq>0\\<close> \\<open>pderiv p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  pderiv p \\<noteq> 0\n\ngoal (3 subgoals):\n 1. p \\<noteq> 0\n 2. pderiv p \\<noteq> 0\n 3. min (order x p) (order x (pderiv p)) =\n    min (order x p) (order x (pderiv p))", "by simp_all"], ["proof (state)\nthis:\n  order x (gcd p (pderiv p)) = min (order x p) (order x (pderiv p))\n\ngoal (2 subgoals):\n 1. proots_within p S = proots_within p S\n 2. \\<And>x.\n       x \\<in> proots_within p S \\<Longrightarrow>\n       order x p = order x pp + 1", "also"], ["proof (state)\nthis:\n  order x (gcd p (pderiv p)) = min (order x p) (order x (pderiv p))\n\ngoal (2 subgoals):\n 1. proots_within p S = proots_within p S\n 2. \\<And>x.\n       x \\<in> proots_within p S \\<Longrightarrow>\n       order x p = order x pp + 1", "have \"... = order x (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (order x p) (order x (pderiv p)) = order x (pderiv p)", "apply (subst order_pderiv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. order x p \\<noteq> 0\n 3. min (Suc (order x (pderiv p))) (order x (pderiv p)) = order x (pderiv p)", "using \\<open>pderiv p\\<noteq>0\\<close> \\<open>p \\<noteq> 0\\<close> \\<open>x \\<in> proots_within p S\\<close> order_root"], ["proof (prove)\nusing this:\n  pderiv p \\<noteq> 0\n  p \\<noteq> 0\n  x \\<in> proots_within p S\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (3 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. order x p \\<noteq> 0\n 3. min (Suc (order x (pderiv p))) (order x (pderiv p)) = order x (pderiv p)", "by auto"], ["proof (state)\nthis:\n  min (order x p) (order x (pderiv p)) = order x (pderiv p)\n\ngoal (2 subgoals):\n 1. proots_within p S = proots_within p S\n 2. \\<And>x.\n       x \\<in> proots_within p S \\<Longrightarrow>\n       order x p = order x pp + 1", "finally"], ["proof (chain)\npicking this:\n  order x pp = order x (pderiv p)", "have \"order x pp = order x (pderiv p)\""], ["proof (prove)\nusing this:\n  order x pp = order x (pderiv p)\n\ngoal (1 subgoal):\n 1. order x pp = order x (pderiv p)", "."], ["proof (state)\nthis:\n  order x pp = order x (pderiv p)\n\ngoal (2 subgoals):\n 1. proots_within p S = proots_within p S\n 2. \\<And>x.\n       x \\<in> proots_within p S \\<Longrightarrow>\n       order x p = order x pp + 1", "moreover"], ["proof (state)\nthis:\n  order x pp = order x (pderiv p)\n\ngoal (2 subgoals):\n 1. proots_within p S = proots_within p S\n 2. \\<And>x.\n       x \\<in> proots_within p S \\<Longrightarrow>\n       order x p = order x pp + 1", "have \"order x p = order x (pderiv p) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = order x (pderiv p) + 1", "apply (subst order_pderiv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. order x p \\<noteq> 0\n 3. Suc (order x (pderiv p)) = order x (pderiv p) + 1", "using \\<open>pderiv p\\<noteq>0\\<close> \\<open>p \\<noteq> 0\\<close> \\<open>x \\<in> proots_within p S\\<close> order_root"], ["proof (prove)\nusing this:\n  pderiv p \\<noteq> 0\n  p \\<noteq> 0\n  x \\<in> proots_within p S\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (3 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. order x p \\<noteq> 0\n 3. Suc (order x (pderiv p)) = order x (pderiv p) + 1", "by auto"], ["proof (state)\nthis:\n  order x p = order x (pderiv p) + 1\n\ngoal (2 subgoals):\n 1. proots_within p S = proots_within p S\n 2. \\<And>x.\n       x \\<in> proots_within p S \\<Longrightarrow>\n       order x p = order x pp + 1", "ultimately"], ["proof (chain)\npicking this:\n  order x pp = order x (pderiv p)\n  order x p = order x (pderiv p) + 1", "show \"order x p = order x pp + 1\""], ["proof (prove)\nusing this:\n  order x pp = order x (pderiv p)\n  order x p = order x (pderiv p) + 1\n\ngoal (1 subgoal):\n 1. order x p = order x pp + 1", "by auto"], ["proof (state)\nthis:\n  order x p = order x pp + 1\n\ngoal (1 subgoal):\n 1. proots_within p S = proots_within p S", "qed simp"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>proots_within p S. order r p) =\n  (\\<Sum>r\\<in>proots_within p S. order r pp + 1)\n\ngoal (1 subgoal):\n 1. proots_count p S = card (proots_within p S) + proots_count pp S", "also"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>proots_within p S. order r p) =\n  (\\<Sum>r\\<in>proots_within p S. order r pp + 1)\n\ngoal (1 subgoal):\n 1. proots_count p S = card (proots_within p S) + proots_count pp S", "have \"... = card (proots_within p S) + (\\<Sum>r\\<in> proots_within p S. order r pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p S. order r pp + 1) =\n    card (proots_within p S) + (\\<Sum>r\\<in>proots_within p S. order r pp)", "apply (subst sum.distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p S. order r pp) +\n    (\\<Sum>r\\<in>proots_within p S. 1) =\n    card (proots_within p S) + (\\<Sum>r\\<in>proots_within p S. order r pp)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>proots_within p S. order r pp + 1) =\n  card (proots_within p S) + (\\<Sum>r\\<in>proots_within p S. order r pp)\n\ngoal (1 subgoal):\n 1. proots_count p S = card (proots_within p S) + proots_count pp S", "also"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>proots_within p S. order r pp + 1) =\n  card (proots_within p S) + (\\<Sum>r\\<in>proots_within p S. order r pp)\n\ngoal (1 subgoal):\n 1. proots_count p S = card (proots_within p S) + proots_count pp S", "have \"... = card (proots_within p S) + (\\<Sum>r\\<in> proots_within pp S. order r pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (proots_within p S) + (\\<Sum>r\\<in>proots_within p S. order r pp) =\n    card (proots_within p S) + (\\<Sum>r\\<in>proots_within pp S. order r pp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (proots_within p S) + (\\<Sum>r\\<in>proots_within p S. order r pp) =\n    card (proots_within p S) + (\\<Sum>r\\<in>proots_within pp S. order r pp)", "have \"(\\<Sum>r\\<in>proots_within p S. order r pp) = (\\<Sum>r\\<in>proots_within pp S. order r pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p S. order r pp) =\n    (\\<Sum>r\\<in>proots_within pp S. order r pp)", "apply (rule sum.mono_neutral_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (proots_within p S)\n 2. proots_within pp S \\<subseteq> proots_within p S\n 3. \\<forall>i\\<in>proots_within p S - proots_within pp S. order i pp = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (proots_within p S)", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite (proots_within p S)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. proots_within pp S \\<subseteq> proots_within p S\n 2. \\<forall>i\\<in>proots_within p S - proots_within pp S. order i pp = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within pp S \\<subseteq> proots_within p S", "unfolding pp_gcd"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within (smult lp (gcd p (pderiv p))) S\n    \\<subseteq> proots_within p S", "using \\<open>lp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  lp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_within (smult lp (gcd p (pderiv p))) S\n    \\<subseteq> proots_within p S", "by (auto simp:poly_gcd_0_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>proots_within p S - proots_within pp S. order i pp = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>proots_within p S - proots_within pp S. order i pp = 0", "unfolding pp_gcd"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>proots_within p S -\n                   proots_within (smult lp (gcd p (pderiv p))) S.\n       order i (smult lp (gcd p (pderiv p))) = 0", "using \\<open>lp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  lp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>proots_within p S -\n                   proots_within (smult lp (gcd p (pderiv p))) S.\n       order i (smult lp (gcd p (pderiv p))) = 0", "apply (auto simp:poly_gcd_0_iff order_smult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>lp \\<noteq> 0; poly (pderiv p) i \\<noteq> 0; poly p i = 0;\n        i \\<in> S\\<rbrakk>\n       \\<Longrightarrow> order i (gcd p (pderiv p)) = 0", "apply (subst order_gcd)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lp \\<noteq> 0; poly (pderiv p) i \\<noteq> 0; poly p i = 0;\n        i \\<in> S\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0\n 2. \\<And>i.\n       \\<lbrakk>lp \\<noteq> 0; poly (pderiv p) i \\<noteq> 0; poly p i = 0;\n        i \\<in> S\\<rbrakk>\n       \\<Longrightarrow> pderiv p \\<noteq> 0\n 3. \\<And>i.\n       \\<lbrakk>lp \\<noteq> 0; poly (pderiv p) i \\<noteq> 0; poly p i = 0;\n        i \\<in> S\\<rbrakk>\n       \\<Longrightarrow> min (order i p) (order i (pderiv p)) = 0", "by (auto simp add: order_root)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>proots_within p S. order r pp) =\n  (\\<Sum>r\\<in>proots_within pp S. order r pp)\n\ngoal (1 subgoal):\n 1. card (proots_within p S) + (\\<Sum>r\\<in>proots_within p S. order r pp) =\n    card (proots_within p S) + (\\<Sum>r\\<in>proots_within pp S. order r pp)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>r\\<in>proots_within p S. order r pp) =\n  (\\<Sum>r\\<in>proots_within pp S. order r pp)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>r\\<in>proots_within p S. order r pp) =\n  (\\<Sum>r\\<in>proots_within pp S. order r pp)\n\ngoal (1 subgoal):\n 1. card (proots_within p S) + (\\<Sum>r\\<in>proots_within p S. order r pp) =\n    card (proots_within p S) + (\\<Sum>r\\<in>proots_within pp S. order r pp)", "by simp"], ["proof (state)\nthis:\n  card (proots_within p S) + (\\<Sum>r\\<in>proots_within p S. order r pp) =\n  card (proots_within p S) + (\\<Sum>r\\<in>proots_within pp S. order r pp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (proots_within p S) + (\\<Sum>r\\<in>proots_within p S. order r pp) =\n  card (proots_within p S) + (\\<Sum>r\\<in>proots_within pp S. order r pp)\n\ngoal (1 subgoal):\n 1. proots_count p S = card (proots_within p S) + proots_count pp S", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>r\\<in>proots_within p S. order r p) =\n  card (proots_within p S) + (\\<Sum>r\\<in>proots_within pp S. order r pp)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>r\\<in>proots_within p S. order r p) =\n  card (proots_within p S) + (\\<Sum>r\\<in>proots_within pp S. order r pp)\n\ngoal (1 subgoal):\n 1. proots_count p S = card (proots_within p S) + proots_count pp S", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  (\\<Sum>r\\<in>proots_within p S. order r p) =\n  card (proots_within p S) + (\\<Sum>r\\<in>proots_within pp S. order r pp)\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p S. order r p) =\n    card (proots_within p S) + (\\<Sum>r\\<in>proots_within pp S. order r pp)", "."], ["proof (state)\nthis:\n  proots_count p S = card (proots_within p S) + proots_count pp S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count p S = card (proots_within p S) + proots_count pp S\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  proots_count p S = card (proots_within p S) + proots_count pp S\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "have \"card (proots_within p S) = changes_itv_smods a b p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (card (proots_within p S)) = changes_itv_smods a b p (pderiv p)", "using sturm_interval[OF \\<open>a<b\\<close> \\<open>poly p a\\<noteq>0\\<close> \\<open>poly p b\\<noteq>0\\<close>,symmetric]"], ["proof (prove)\nusing this:\n  changes_itv_smods a b p (pderiv p) =\n  int (card {x. poly p x = 0 \\<and> a < x \\<and> x < b})\n\ngoal (1 subgoal):\n 1. int (card (proots_within p S)) = changes_itv_smods a b p (pderiv p)", "unfolding S_def proots_within_def"], ["proof (prove)\nusing this:\n  changes_itv_smods a b p (pderiv p) =\n  int (card {x. poly p x = 0 \\<and> a < x \\<and> x < b})\n\ngoal (1 subgoal):\n 1. int (card {x \\<in> {x. a < x \\<and> x < b}. poly p x = 0}) =\n    changes_itv_smods a b p (pderiv p)", "by (auto intro!:arg_cong[where f=card])"], ["proof (state)\nthis:\n  int (card (proots_within p S)) = changes_itv_smods a b p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  int (card (proots_within p S)) = changes_itv_smods a b p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "have \"changes_itv_smods_ext a b p (pderiv p) \n            = changes_itv_smods a b p (pderiv p) + changes_itv_smods_ext a b pp (pderiv pp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_smods_ext a b p (pderiv p) =\n    changes_itv_smods a b p (pderiv p) +\n    changes_itv_smods_ext a b pp (pderiv pp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_itv_smods_ext a b p (pderiv p) =\n    changes_itv_smods a b p (pderiv p) +\n    changes_itv_smods_ext a b pp (pderiv pp)", "define xs ys where \"xs=smods p (pderiv p)\" and \"ys=smods_ext pp (pderiv pp)\""], ["proof (state)\nthis:\n  xs = smods p (pderiv p)\n  ys = smods_ext pp (pderiv pp)\n\ngoal (1 subgoal):\n 1. changes_itv_smods_ext a b p (pderiv p) =\n    changes_itv_smods a b p (pderiv p) +\n    changes_itv_smods_ext a b pp (pderiv pp)", "have xys: \"xs\\<noteq>[]\" \"ys\\<noteq>[]\" \"last xs=hd ys\" \"poly (last xs) a\\<noteq>0\" \"poly (last xs) b\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> [] &&& ys \\<noteq> []) &&&\n    last xs = hd ys &&&\n    poly (last xs) a \\<noteq> 0 &&& poly (last xs) b \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "unfolding xs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. smods p (pderiv p) \\<noteq> []", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smods p (pderiv p) \\<noteq> []", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. ys \\<noteq> []\n 2. last xs = hd ys\n 3. poly (last xs) a \\<noteq> 0\n 4. poly (last xs) b \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "unfolding ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. smods_ext pp (pderiv pp) \\<noteq> []", "using \\<open>pp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  pp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. smods_ext pp (pderiv pp) \\<noteq> []", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. last xs = hd ys\n 2. poly (last xs) a \\<noteq> 0\n 3. poly (last xs) b \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. last xs = hd ys", "using \\<open>pp\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  pp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. last xs = hd ys", "unfolding xs_def ys_def"], ["proof (prove)\nusing this:\n  pp \\<noteq> 0\n\ngoal (1 subgoal):\n 1. last (smods p (pderiv p)) = hd (smods_ext pp (pderiv pp))", "apply (fold pp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp \\<noteq> 0 \\<Longrightarrow> pp = hd (smods_ext pp (pderiv pp))", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly (last xs) a \\<noteq> 0\n 2. poly (last xs) b \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (last xs) a \\<noteq> 0", "using \\<open>poly pp a\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly pp a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (last xs) a \\<noteq> 0", "unfolding pp_def xs_def"], ["proof (prove)\nusing this:\n  poly (last (smods p (pderiv p))) a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (last (smods p (pderiv p))) a \\<noteq> 0", "."], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (last xs) b \\<noteq> 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (last xs) b \\<noteq> 0", "using \\<open>poly pp b\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly pp b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (last xs) b \\<noteq> 0", "unfolding pp_def xs_def"], ["proof (prove)\nusing this:\n  poly (last (smods p (pderiv p))) b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (last (smods p (pderiv p))) b \\<noteq> 0", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  last xs = hd ys\n  poly (last xs) a \\<noteq> 0\n  poly (last xs) b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_itv_smods_ext a b p (pderiv p) =\n    changes_itv_smods a b p (pderiv p) +\n    changes_itv_smods_ext a b pp (pderiv pp)", "have \"changes_poly_at (xs @ tl ys) a = changes_poly_at xs a + changes_poly_at ys a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) a =\n    changes_poly_at xs a + changes_poly_at ys a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) a =\n    changes_poly_at xs a + changes_poly_at ys a", "have \"changes_poly_at (xs @ tl ys) a  = changes_poly_at (xs @ ys) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) a = changes_poly_at (xs @ ys) a", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p a) (xs @ tl ys)) =\n    changes (map (\\<lambda>p. poly p a) (xs @ ys))", "apply (simp add:map_tl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes\n     (map (\\<lambda>p. poly p a) xs @ tl (map (\\<lambda>p. poly p a) ys)) =\n    changes (map (\\<lambda>p. poly p a) xs @ map (\\<lambda>p. poly p a) ys)", "apply (subst changes_drop_dup[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. map (\\<lambda>p. poly p a) xs \\<noteq> []\n 2. map (\\<lambda>p. poly p a) ys \\<noteq> [] \\<longrightarrow>\n    last (map (\\<lambda>p. poly p a) xs) =\n    hd (map (\\<lambda>p. poly p a) ys)\n 3. changes\n     (map (\\<lambda>p. poly p a) xs @ map (\\<lambda>p. poly p a) ys) =\n    changes (map (\\<lambda>p. poly p a) xs @ map (\\<lambda>p. poly p a) ys)", "using that xys"], ["proof (prove)\nusing this:\n  pderiv p \\<noteq> 0\n  xs \\<noteq> []\n  ys \\<noteq> []\n  last xs = hd ys\n  poly (last xs) a \\<noteq> 0\n  poly (last xs) b \\<noteq> 0\n\ngoal (3 subgoals):\n 1. map (\\<lambda>p. poly p a) xs \\<noteq> []\n 2. map (\\<lambda>p. poly p a) ys \\<noteq> [] \\<longrightarrow>\n    last (map (\\<lambda>p. poly p a) xs) =\n    hd (map (\\<lambda>p. poly p a) ys)\n 3. changes\n     (map (\\<lambda>p. poly p a) xs @ map (\\<lambda>p. poly p a) ys) =\n    changes (map (\\<lambda>p. poly p a) xs @ map (\\<lambda>p. poly p a) ys)", "by (auto simp add: hd_map last_map)"], ["proof (state)\nthis:\n  changes_poly_at (xs @ tl ys) a = changes_poly_at (xs @ ys) a\n\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) a =\n    changes_poly_at xs a + changes_poly_at ys a", "also"], ["proof (state)\nthis:\n  changes_poly_at (xs @ tl ys) a = changes_poly_at (xs @ ys) a\n\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) a =\n    changes_poly_at xs a + changes_poly_at ys a", "have \"... = changes_poly_at xs a + changes_poly_at ys a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ ys) a =\n    changes_poly_at xs a + changes_poly_at ys a", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p a) (xs @ ys)) =\n    changes (map (\\<lambda>p. poly p a) xs) +\n    changes (map (\\<lambda>p. poly p a) ys)", "apply (subst changes_append[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. map (\\<lambda>p. poly p a) xs \\<noteq> [] \\<and>\n    map (\\<lambda>p. poly p a) ys \\<noteq> [] \\<longrightarrow>\n    last (map (\\<lambda>p. poly p a) xs) =\n    hd (map (\\<lambda>p. poly p a) ys) \\<and>\n    last (map (\\<lambda>p. poly p a) xs) \\<noteq> 0\n 2. changes (map (\\<lambda>p. poly p a) (xs @ ys)) =\n    changes (map (\\<lambda>p. poly p a) xs @ map (\\<lambda>p. poly p a) ys)", "using xys"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  last xs = hd ys\n  poly (last xs) a \\<noteq> 0\n  poly (last xs) b \\<noteq> 0\n\ngoal (2 subgoals):\n 1. map (\\<lambda>p. poly p a) xs \\<noteq> [] \\<and>\n    map (\\<lambda>p. poly p a) ys \\<noteq> [] \\<longrightarrow>\n    last (map (\\<lambda>p. poly p a) xs) =\n    hd (map (\\<lambda>p. poly p a) ys) \\<and>\n    last (map (\\<lambda>p. poly p a) xs) \\<noteq> 0\n 2. changes (map (\\<lambda>p. poly p a) (xs @ ys)) =\n    changes (map (\\<lambda>p. poly p a) xs @ map (\\<lambda>p. poly p a) ys)", "by (auto simp add: hd_map last_map)"], ["proof (state)\nthis:\n  changes_poly_at (xs @ ys) a = changes_poly_at xs a + changes_poly_at ys a\n\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) a =\n    changes_poly_at xs a + changes_poly_at ys a", "finally"], ["proof (chain)\npicking this:\n  changes_poly_at (xs @ tl ys) a =\n  changes_poly_at xs a + changes_poly_at ys a", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at (xs @ tl ys) a =\n  changes_poly_at xs a + changes_poly_at ys a\n\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) a =\n    changes_poly_at xs a + changes_poly_at ys a", "."], ["proof (state)\nthis:\n  changes_poly_at (xs @ tl ys) a =\n  changes_poly_at xs a + changes_poly_at ys a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_poly_at (xs @ tl ys) a =\n  changes_poly_at xs a + changes_poly_at ys a\n\ngoal (1 subgoal):\n 1. changes_itv_smods_ext a b p (pderiv p) =\n    changes_itv_smods a b p (pderiv p) +\n    changes_itv_smods_ext a b pp (pderiv pp)", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (xs @ tl ys) a =\n  changes_poly_at xs a + changes_poly_at ys a\n\ngoal (1 subgoal):\n 1. changes_itv_smods_ext a b p (pderiv p) =\n    changes_itv_smods a b p (pderiv p) +\n    changes_itv_smods_ext a b pp (pderiv pp)", "have \"changes_poly_at (xs @ tl ys) b = changes_poly_at xs b + changes_poly_at ys b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) b =\n    changes_poly_at xs b + changes_poly_at ys b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) b =\n    changes_poly_at xs b + changes_poly_at ys b", "have \"changes_poly_at (xs @ tl ys) b  = changes_poly_at (xs @ ys) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) b = changes_poly_at (xs @ ys) b", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p b) (xs @ tl ys)) =\n    changes (map (\\<lambda>p. poly p b) (xs @ ys))", "apply (simp add:map_tl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes\n     (map (\\<lambda>p. poly p b) xs @ tl (map (\\<lambda>p. poly p b) ys)) =\n    changes (map (\\<lambda>p. poly p b) xs @ map (\\<lambda>p. poly p b) ys)", "apply (subst changes_drop_dup[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. map (\\<lambda>p. poly p b) xs \\<noteq> []\n 2. map (\\<lambda>p. poly p b) ys \\<noteq> [] \\<longrightarrow>\n    last (map (\\<lambda>p. poly p b) xs) =\n    hd (map (\\<lambda>p. poly p b) ys)\n 3. changes\n     (map (\\<lambda>p. poly p b) xs @ map (\\<lambda>p. poly p b) ys) =\n    changes (map (\\<lambda>p. poly p b) xs @ map (\\<lambda>p. poly p b) ys)", "using that xys"], ["proof (prove)\nusing this:\n  pderiv p \\<noteq> 0\n  xs \\<noteq> []\n  ys \\<noteq> []\n  last xs = hd ys\n  poly (last xs) a \\<noteq> 0\n  poly (last xs) b \\<noteq> 0\n\ngoal (3 subgoals):\n 1. map (\\<lambda>p. poly p b) xs \\<noteq> []\n 2. map (\\<lambda>p. poly p b) ys \\<noteq> [] \\<longrightarrow>\n    last (map (\\<lambda>p. poly p b) xs) =\n    hd (map (\\<lambda>p. poly p b) ys)\n 3. changes\n     (map (\\<lambda>p. poly p b) xs @ map (\\<lambda>p. poly p b) ys) =\n    changes (map (\\<lambda>p. poly p b) xs @ map (\\<lambda>p. poly p b) ys)", "by (auto simp add: hd_map last_map)"], ["proof (state)\nthis:\n  changes_poly_at (xs @ tl ys) b = changes_poly_at (xs @ ys) b\n\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) b =\n    changes_poly_at xs b + changes_poly_at ys b", "also"], ["proof (state)\nthis:\n  changes_poly_at (xs @ tl ys) b = changes_poly_at (xs @ ys) b\n\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) b =\n    changes_poly_at xs b + changes_poly_at ys b", "have \"... = changes_poly_at xs b + changes_poly_at ys b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ ys) b =\n    changes_poly_at xs b + changes_poly_at ys b", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p b) (xs @ ys)) =\n    changes (map (\\<lambda>p. poly p b) xs) +\n    changes (map (\\<lambda>p. poly p b) ys)", "apply (subst changes_append[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. map (\\<lambda>p. poly p b) xs \\<noteq> [] \\<and>\n    map (\\<lambda>p. poly p b) ys \\<noteq> [] \\<longrightarrow>\n    last (map (\\<lambda>p. poly p b) xs) =\n    hd (map (\\<lambda>p. poly p b) ys) \\<and>\n    last (map (\\<lambda>p. poly p b) xs) \\<noteq> 0\n 2. changes (map (\\<lambda>p. poly p b) (xs @ ys)) =\n    changes (map (\\<lambda>p. poly p b) xs @ map (\\<lambda>p. poly p b) ys)", "using xys"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ys \\<noteq> []\n  last xs = hd ys\n  poly (last xs) a \\<noteq> 0\n  poly (last xs) b \\<noteq> 0\n\ngoal (2 subgoals):\n 1. map (\\<lambda>p. poly p b) xs \\<noteq> [] \\<and>\n    map (\\<lambda>p. poly p b) ys \\<noteq> [] \\<longrightarrow>\n    last (map (\\<lambda>p. poly p b) xs) =\n    hd (map (\\<lambda>p. poly p b) ys) \\<and>\n    last (map (\\<lambda>p. poly p b) xs) \\<noteq> 0\n 2. changes (map (\\<lambda>p. poly p b) (xs @ ys)) =\n    changes (map (\\<lambda>p. poly p b) xs @ map (\\<lambda>p. poly p b) ys)", "by (auto simp add: hd_map last_map)"], ["proof (state)\nthis:\n  changes_poly_at (xs @ ys) b = changes_poly_at xs b + changes_poly_at ys b\n\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) b =\n    changes_poly_at xs b + changes_poly_at ys b", "finally"], ["proof (chain)\npicking this:\n  changes_poly_at (xs @ tl ys) b =\n  changes_poly_at xs b + changes_poly_at ys b", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at (xs @ tl ys) b =\n  changes_poly_at xs b + changes_poly_at ys b\n\ngoal (1 subgoal):\n 1. changes_poly_at (xs @ tl ys) b =\n    changes_poly_at xs b + changes_poly_at ys b", "."], ["proof (state)\nthis:\n  changes_poly_at (xs @ tl ys) b =\n  changes_poly_at xs b + changes_poly_at ys b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_poly_at (xs @ tl ys) b =\n  changes_poly_at xs b + changes_poly_at ys b\n\ngoal (1 subgoal):\n 1. changes_itv_smods_ext a b p (pderiv p) =\n    changes_itv_smods a b p (pderiv p) +\n    changes_itv_smods_ext a b pp (pderiv pp)", "ultimately"], ["proof (chain)\npicking this:\n  changes_poly_at (xs @ tl ys) a =\n  changes_poly_at xs a + changes_poly_at ys a\n  changes_poly_at (xs @ tl ys) b =\n  changes_poly_at xs b + changes_poly_at ys b", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at (xs @ tl ys) a =\n  changes_poly_at xs a + changes_poly_at ys a\n  changes_poly_at (xs @ tl ys) b =\n  changes_poly_at xs b + changes_poly_at ys b\n\ngoal (1 subgoal):\n 1. changes_itv_smods_ext a b p (pderiv p) =\n    changes_itv_smods a b p (pderiv p) +\n    changes_itv_smods_ext a b pp (pderiv pp)", "unfolding changes_itv_smods_ext_def changes_itv_smods_def"], ["proof (prove)\nusing this:\n  changes_poly_at (xs @ tl ys) a =\n  changes_poly_at xs a + changes_poly_at ys a\n  changes_poly_at (xs @ tl ys) b =\n  changes_poly_at xs b + changes_poly_at ys b\n\ngoal (1 subgoal):\n 1. (let ps = smods_ext p (pderiv p)\n     in changes_poly_at ps a - changes_poly_at ps b) =\n    (let ps = smods p (pderiv p)\n     in changes_poly_at ps a - changes_poly_at ps b) +\n    (let ps = smods_ext pp (pderiv pp)\n     in changes_poly_at ps a - changes_poly_at ps b)", "apply (fold xs_def ys_def,unfold prefix[folded xs_def ys_def] Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes_poly_at (xs @ tl ys) a =\n             changes_poly_at xs a + changes_poly_at ys a;\n     changes_poly_at (xs @ tl ys) b =\n     changes_poly_at xs b + changes_poly_at ys b;\n     changes_poly_at (xs @ tl ys) a =\n     changes_poly_at xs a + changes_poly_at ys a;\n     changes_poly_at (xs @ tl ys) b =\n     changes_poly_at xs b + changes_poly_at ys b\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (xs @ tl ys) a -\n                      changes_poly_at (xs @ tl ys) b =\n                      changes_poly_at xs a - changes_poly_at xs b +\n                      (changes_poly_at ys a - changes_poly_at ys b)", "by auto"], ["proof (state)\nthis:\n  changes_itv_smods_ext a b p (pderiv p) =\n  changes_itv_smods a b p (pderiv p) +\n  changes_itv_smods_ext a b pp (pderiv pp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_itv_smods_ext a b p (pderiv p) =\n  changes_itv_smods a b p (pderiv p) +\n  changes_itv_smods_ext a b pp (pderiv pp)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "ultimately"], ["proof (chain)\npicking this:\n  int (proots_count pp S) = changes_itv_smods_ext a b pp (pderiv pp)\n  proots_count p S = card (proots_within p S) + proots_count pp S\n  int (card (proots_within p S)) = changes_itv_smods a b p (pderiv p)\n  changes_itv_smods_ext a b p (pderiv p) =\n  changes_itv_smods a b p (pderiv p) +\n  changes_itv_smods_ext a b pp (pderiv pp)", "show \"proots_count p S = changes_itv_smods_ext a b p (pderiv p)\""], ["proof (prove)\nusing this:\n  int (proots_count pp S) = changes_itv_smods_ext a b pp (pderiv pp)\n  proots_count p S = card (proots_within p S) + proots_count pp S\n  int (card (proots_within p S)) = changes_itv_smods a b p (pderiv p)\n  changes_itv_smods_ext a b p (pderiv p) =\n  changes_itv_smods a b p (pderiv p) +\n  changes_itv_smods_ext a b pp (pderiv pp)\n\ngoal (1 subgoal):\n 1. int (proots_count p S) = changes_itv_smods_ext a b p (pderiv p)", "by auto"], ["proof (state)\nthis:\n  int (proots_count p S) = changes_itv_smods_ext a b p (pderiv p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0 \\<Longrightarrow>\n  int (proots_count p {x. a < x \\<and> x < b}) =\n  changes_itv_smods_ext a b p (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>ys.\n                   length ys\n                   < length (smods_ext p (pderiv p)) \\<longrightarrow>\n                   (\\<forall>x.\n                       ys = smods_ext x (pderiv x) \\<longrightarrow>\n                       poly x a \\<noteq> 0 \\<longrightarrow>\n                       poly x b \\<noteq> 0 \\<longrightarrow>\n                       int (proots_count x {x. a < x \\<and> x < b}) =\n                       changes_itv_smods_ext a b x (pderiv x));\n        poly p a \\<noteq> 0; poly p b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x < b}) =\n                         changes_itv_smods_ext a b p (pderiv p)", "ultimately"], ["proof (chain)\npicking this:\n  pderiv p = 0 \\<Longrightarrow>\n  int (proots_count p {x. a < x \\<and> x < b}) =\n  changes_itv_smods_ext a b p (pderiv p)\n  pderiv p \\<noteq> 0 \\<Longrightarrow>\n  int (proots_count p {x. a < x \\<and> x < b}) =\n  changes_itv_smods_ext a b p (pderiv p)", "show ?case"], ["proof (prove)\nusing this:\n  pderiv p = 0 \\<Longrightarrow>\n  int (proots_count p {x. a < x \\<and> x < b}) =\n  changes_itv_smods_ext a b p (pderiv p)\n  pderiv p \\<noteq> 0 \\<Longrightarrow>\n  int (proots_count p {x. a < x \\<and> x < b}) =\n  changes_itv_smods_ext a b p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x < b}) =\n    changes_itv_smods_ext a b p (pderiv p)", "by argo"], ["proof (state)\nthis:\n  int (proots_count p {x. a < x \\<and> x < b}) =\n  changes_itv_smods_ext a b p (pderiv p)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sturm_ext_above:\n  assumes \"poly p a\\<noteq>0\" \n  shows \"proots_count p {x. a<x} = changes_gt_smods_ext a p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "define ps where \"ps\\<equiv>smods_ext p (pderiv p)\""], ["proof (state)\nthis:\n  ps \\<equiv> smods_ext p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "have \"p\\<noteq>0\" and \"p\\<in>set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& p \\<in> set ps", "using \\<open>poly p a\\<noteq>0\\<close> ps_def"], ["proof (prove)\nusing this:\n  poly p a \\<noteq> 0\n  ps \\<equiv> smods_ext p (pderiv p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& p \\<in> set ps", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "obtain ub where ub:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x<ub\"\n    and ub_sgn:\"\\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\"\n    and \"ub>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         a < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_ub[OF no_0_in_smods_ext,of p \"pderiv p\",folded ps_def]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n       \\<forall>x\\<ge>ub.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n       ?a < ub\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         a < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  \\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\n  a < ub\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "have \"proots_count p {x. a<x} = proots_count p {x. a<x \\<and> x<ub}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x < ub}", "unfolding proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p (Collect ((<) a)). order r p) =\n    (\\<Sum>r\\<in>proots_within p {x. a < x \\<and> x < ub}. order r p)", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proots_within p (Collect ((<) a)) =\n    proots_within p {x. a < x \\<and> x < ub}\n 2. \\<And>x.\n       x \\<in> proots_within p {x. a < x \\<and> x < ub} \\<Longrightarrow>\n       order x p = order x p", "by (use ub \\<open>p\\<in>set ps\\<close> in auto)"], ["proof (state)\nthis:\n  proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x < ub}\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x < ub}\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "have \"changes_gt_smods_ext a p (pderiv p) = changes_itv_smods_ext a ub p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_gt_smods_ext a p (pderiv p) =\n    changes_itv_smods_ext a ub p (pderiv p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_gt_smods_ext a p (pderiv p) =\n    changes_itv_smods_ext a ub p (pderiv p)", "have \"map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps", "using ub_sgn[THEN spec,of ub,simplified]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. sgn (poly p ub) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps", "by (metis (mono_tags, lifting) comp_def list.map_cong0)"], ["proof (state)\nthis:\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_gt_smods_ext a p (pderiv p) =\n    changes_itv_smods_ext a ub p (pderiv p)", "hence \"changes_poly_at ps ub=changes_poly_pos_inf ps\""], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_poly_at ps ub = changes_poly_pos_inf ps", "unfolding changes_poly_pos_inf_def changes_poly_at_def"], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p ub) ps) = changes (map sgn_pos_inf ps)", "by (subst changes_map_sgn_eq,metis map_map)"], ["proof (state)\nthis:\n  changes_poly_at ps ub = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_gt_smods_ext a p (pderiv p) =\n    changes_itv_smods_ext a ub p (pderiv p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at ps ub = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_gt_smods_ext a p (pderiv p) =\n    changes_itv_smods_ext a ub p (pderiv p)", "unfolding changes_gt_smods_ext_def changes_itv_smods_ext_def ps_def"], ["proof (prove)\nusing this:\n  changes_poly_at (smods_ext p (pderiv p)) ub =\n  changes_poly_pos_inf (smods_ext p (pderiv p))\n\ngoal (1 subgoal):\n 1. (let ps = smods_ext p (pderiv p)\n     in changes_poly_at ps a - changes_poly_pos_inf ps) =\n    (let ps = smods_ext p (pderiv p)\n     in changes_poly_at ps a - changes_poly_at ps ub)", "by metis"], ["proof (state)\nthis:\n  changes_gt_smods_ext a p (pderiv p) =\n  changes_itv_smods_ext a ub p (pderiv p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_gt_smods_ext a p (pderiv p) =\n  changes_itv_smods_ext a ub p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  changes_gt_smods_ext a p (pderiv p) =\n  changes_itv_smods_ext a ub p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "have \"poly p ub\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p ub \\<noteq> 0", "using ub \\<open>p\\<in>set ps\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. poly p ub \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p ub \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "ultimately"], ["proof (chain)\npicking this:\n  proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x < ub}\n  changes_gt_smods_ext a p (pderiv p) =\n  changes_itv_smods_ext a ub p (pderiv p)\n  poly p ub \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x < ub}\n  changes_gt_smods_ext a p (pderiv p) =\n  changes_itv_smods_ext a ub p (pderiv p)\n  poly p ub \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "using sturm_ext_interval[OF \\<open>ub>a\\<close> assms]"], ["proof (prove)\nusing this:\n  proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x < ub}\n  changes_gt_smods_ext a p (pderiv p) =\n  changes_itv_smods_ext a ub p (pderiv p)\n  poly p ub \\<noteq> 0\n  poly p ub \\<noteq> 0 \\<Longrightarrow>\n  int (proots_count p {x. a < x \\<and> x < ub}) =\n  changes_itv_smods_ext a ub p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)", "by auto"], ["proof (state)\nthis:\n  int (proots_count p {x. a < x}) = changes_gt_smods_ext a p (pderiv p)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sturm_ext_below:\n  assumes \"poly p b\\<noteq>0\" \n  shows \"proots_count p {x. x<b} = changes_le_smods_ext b p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "define ps where \"ps\\<equiv>smods_ext p (pderiv p)\""], ["proof (state)\nthis:\n  ps \\<equiv> smods_ext p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "have \"p\\<noteq>0\" and \"p\\<in>set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& p \\<in> set ps", "using \\<open>poly p b\\<noteq>0\\<close> ps_def"], ["proof (prove)\nusing this:\n  poly p b \\<noteq> 0\n  ps \\<equiv> smods_ext p (pderiv p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& p \\<in> set ps", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "obtain lb where lb:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x>lb\"\n    and lb_sgn:\"\\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\"\n    and \"lb<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_lb[OF no_0_in_smods_ext,of p \"pderiv p\",folded ps_def]"], ["proof (prove)\nusing this:\n  (\\<And>lb.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n       \\<forall>x\\<le>lb.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n       lb < ?b\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\n  lb < b\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "have \"proots_count p {x. x<b} = proots_count p {x. lb<x \\<and> x<b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {x. x < b} = proots_count p {x. lb < x \\<and> x < b}", "unfolding proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p {x. x < b}. order r p) =\n    (\\<Sum>r\\<in>proots_within p {x. lb < x \\<and> x < b}. order r p)", "by (rule sum.cong,insert lb \\<open>p\\<in>set ps\\<close>,auto)"], ["proof (state)\nthis:\n  proots_count p {x. x < b} = proots_count p {x. lb < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  proots_count p {x. x < b} = proots_count p {x. lb < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "have \"changes_le_smods_ext b p (pderiv p) = changes_itv_smods_ext lb b p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_le_smods_ext b p (pderiv p) =\n    changes_itv_smods_ext lb b p (pderiv p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_le_smods_ext b p (pderiv p) =\n    changes_itv_smods_ext lb b p (pderiv p)", "have \"map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps", "using lb_sgn[THEN spec,of lb,simplified]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. sgn (poly p lb) = sgn_neg_inf p\n\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps", "by (metis (mono_tags, lifting) comp_def list.map_cong0)"], ["proof (state)\nthis:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_le_smods_ext b p (pderiv p) =\n    changes_itv_smods_ext lb b p (pderiv p)", "hence \"changes_poly_at ps lb=changes_poly_neg_inf ps\""], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_poly_at ps lb = changes_poly_neg_inf ps", "unfolding changes_poly_neg_inf_def changes_poly_at_def"], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p lb) ps) = changes (map sgn_neg_inf ps)", "by (subst changes_map_sgn_eq,metis map_map)"], ["proof (state)\nthis:\n  changes_poly_at ps lb = changes_poly_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_le_smods_ext b p (pderiv p) =\n    changes_itv_smods_ext lb b p (pderiv p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at ps lb = changes_poly_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_le_smods_ext b p (pderiv p) =\n    changes_itv_smods_ext lb b p (pderiv p)", "unfolding changes_le_smods_ext_def changes_itv_smods_ext_def ps_def"], ["proof (prove)\nusing this:\n  changes_poly_at (smods_ext p (pderiv p)) lb =\n  changes_poly_neg_inf (smods_ext p (pderiv p))\n\ngoal (1 subgoal):\n 1. (let ps = smods_ext p (pderiv p)\n     in changes_poly_neg_inf ps - changes_poly_at ps b) =\n    (let ps = smods_ext p (pderiv p)\n     in changes_poly_at ps lb - changes_poly_at ps b)", "by metis"], ["proof (state)\nthis:\n  changes_le_smods_ext b p (pderiv p) =\n  changes_itv_smods_ext lb b p (pderiv p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_le_smods_ext b p (pderiv p) =\n  changes_itv_smods_ext lb b p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  changes_le_smods_ext b p (pderiv p) =\n  changes_itv_smods_ext lb b p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "have \"poly p lb\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p lb \\<noteq> 0", "using lb \\<open>p\\<in>set ps\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. poly p lb \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p lb \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "ultimately"], ["proof (chain)\npicking this:\n  proots_count p {x. x < b} = proots_count p {x. lb < x \\<and> x < b}\n  changes_le_smods_ext b p (pderiv p) =\n  changes_itv_smods_ext lb b p (pderiv p)\n  poly p lb \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count p {x. x < b} = proots_count p {x. lb < x \\<and> x < b}\n  changes_le_smods_ext b p (pderiv p) =\n  changes_itv_smods_ext lb b p (pderiv p)\n  poly p lb \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "using sturm_ext_interval[OF \\<open>lb<b\\<close> _ assms]"], ["proof (prove)\nusing this:\n  proots_count p {x. x < b} = proots_count p {x. lb < x \\<and> x < b}\n  changes_le_smods_ext b p (pderiv p) =\n  changes_itv_smods_ext lb b p (pderiv p)\n  poly p lb \\<noteq> 0\n  poly p lb \\<noteq> 0 \\<Longrightarrow>\n  int (proots_count p {x. lb < x \\<and> x < b}) =\n  changes_itv_smods_ext lb b p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)", "by auto"], ["proof (state)\nthis:\n  int (proots_count p {x. x < b}) = changes_le_smods_ext b p (pderiv p)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sturm_ext_R: \n  assumes \"p\\<noteq>0\"\n  shows \"proots_count p UNIV = changes_R_smods_ext p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "define ps where \"ps\\<equiv>smods_ext p (pderiv p)\""], ["proof (state)\nthis:\n  ps \\<equiv> smods_ext p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "have \"p\\<in>set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set ps", "using ps_def \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  ps \\<equiv> smods_ext p (pderiv p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<in> set ps", "by auto"], ["proof (state)\nthis:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "obtain lb where lb:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x>lb\"\n    and lb_sgn:\"\\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\"\n    and \"lb<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_lb[OF no_0_in_smods_ext,of p \"pderiv p\",folded ps_def]"], ["proof (prove)\nusing this:\n  (\\<And>lb.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n       \\<forall>x\\<le>lb.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n       lb < ?b\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\n  lb < 0\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "obtain ub where ub:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x=0 \\<longrightarrow> x<ub\"\n    and ub_sgn:\"\\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\"\n    and \"ub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         0 < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_ub[OF no_0_in_smods_ext,of p \"pderiv p\",folded ps_def]"], ["proof (prove)\nusing this:\n  (\\<And>ub.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n       \\<forall>x\\<ge>ub.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n       ?a < ub\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         0 < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  \\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\n  0 < ub\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "have \"proots_count p UNIV = proots_count p {x. lb<x \\<and> x<ub}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p UNIV = proots_count p {x. lb < x \\<and> x < ub}", "unfolding proots_count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots p. order r p) =\n    (\\<Sum>r\\<in>proots_within p {x. lb < x \\<and> x < ub}. order r p)", "by (rule sum.cong,insert lb ub \\<open>p\\<in>set ps\\<close>,auto)"], ["proof (state)\nthis:\n  proots_count p UNIV = proots_count p {x. lb < x \\<and> x < ub}\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  proots_count p UNIV = proots_count p {x. lb < x \\<and> x < ub}\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "have \"changes_R_smods_ext p (pderiv p) = changes_itv_smods_ext lb ub p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_R_smods_ext p (pderiv p) =\n    changes_itv_smods_ext lb ub p (pderiv p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_R_smods_ext p (pderiv p) =\n    changes_itv_smods_ext lb ub p (pderiv p)", "have \"map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\"\n      and \"map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps &&&\n    map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps", "using lb_sgn[THEN spec,of lb,simplified] ub_sgn[THEN spec,of ub,simplified]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. sgn (poly p lb) = sgn_neg_inf p\n  \\<forall>p\\<in>set ps. sgn (poly p ub) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps &&&\n    map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps", "by (metis (mono_tags, lifting) comp_def list.map_cong0)+"], ["proof (state)\nthis:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_R_smods_ext p (pderiv p) =\n    changes_itv_smods_ext lb ub p (pderiv p)", "hence \"changes_poly_at ps lb=changes_poly_neg_inf ps\n          \\<and> changes_poly_at ps ub=changes_poly_pos_inf ps\""], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_poly_at ps lb = changes_poly_neg_inf ps \\<and>\n    changes_poly_at ps ub = changes_poly_pos_inf ps", "unfolding changes_poly_neg_inf_def changes_poly_at_def changes_poly_pos_inf_def"], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p lb) ps) =\n    changes (map sgn_neg_inf ps) \\<and>\n    changes (map (\\<lambda>p. poly p ub) ps) = changes (map sgn_pos_inf ps)", "by (subst (1 3)  changes_map_sgn_eq,metis map_map)"], ["proof (state)\nthis:\n  changes_poly_at ps lb = changes_poly_neg_inf ps \\<and>\n  changes_poly_at ps ub = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_R_smods_ext p (pderiv p) =\n    changes_itv_smods_ext lb ub p (pderiv p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at ps lb = changes_poly_neg_inf ps \\<and>\n  changes_poly_at ps ub = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_R_smods_ext p (pderiv p) =\n    changes_itv_smods_ext lb ub p (pderiv p)", "unfolding changes_R_smods_ext_def changes_itv_smods_ext_def ps_def"], ["proof (prove)\nusing this:\n  changes_poly_at (smods_ext p (pderiv p)) lb =\n  changes_poly_neg_inf (smods_ext p (pderiv p)) \\<and>\n  changes_poly_at (smods_ext p (pderiv p)) ub =\n  changes_poly_pos_inf (smods_ext p (pderiv p))\n\ngoal (1 subgoal):\n 1. (let ps = smods_ext p (pderiv p)\n     in changes_poly_neg_inf ps - changes_poly_pos_inf ps) =\n    (let ps = smods_ext p (pderiv p)\n     in changes_poly_at ps lb - changes_poly_at ps ub)", "by metis"], ["proof (state)\nthis:\n  changes_R_smods_ext p (pderiv p) =\n  changes_itv_smods_ext lb ub p (pderiv p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_R_smods_ext p (pderiv p) =\n  changes_itv_smods_ext lb ub p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  changes_R_smods_ext p (pderiv p) =\n  changes_itv_smods_ext lb ub p (pderiv p)\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "have \"poly p lb\\<noteq>0\" and \"poly p ub\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p lb \\<noteq> 0 &&& poly p ub \\<noteq> 0", "using lb ub \\<open>p\\<in>set ps\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. poly p lb \\<noteq> 0 &&& poly p ub \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly p lb \\<noteq> 0\n  poly p ub \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "moreover"], ["proof (state)\nthis:\n  poly p lb \\<noteq> 0\n  poly p ub \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "have \"lb<ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lb < ub", "using \\<open>lb<0\\<close> \\<open>0<ub\\<close>"], ["proof (prove)\nusing this:\n  lb < 0\n  0 < ub\n\ngoal (1 subgoal):\n 1. lb < ub", "by auto"], ["proof (state)\nthis:\n  lb < ub\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "ultimately"], ["proof (chain)\npicking this:\n  proots_count p UNIV = proots_count p {x. lb < x \\<and> x < ub}\n  changes_R_smods_ext p (pderiv p) =\n  changes_itv_smods_ext lb ub p (pderiv p)\n  poly p lb \\<noteq> 0\n  poly p ub \\<noteq> 0\n  lb < ub", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count p UNIV = proots_count p {x. lb < x \\<and> x < ub}\n  changes_R_smods_ext p (pderiv p) =\n  changes_itv_smods_ext lb ub p (pderiv p)\n  poly p lb \\<noteq> 0\n  poly p ub \\<noteq> 0\n  lb < ub\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "using sturm_ext_interval"], ["proof (prove)\nusing this:\n  proots_count p UNIV = proots_count p {x. lb < x \\<and> x < ub}\n  changes_R_smods_ext p (pderiv p) =\n  changes_itv_smods_ext lb ub p (pderiv p)\n  poly p lb \\<noteq> 0\n  poly p ub \\<noteq> 0\n  lb < ub\n  \\<lbrakk>?a < ?b; poly ?p ?a \\<noteq> 0; poly ?p ?b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> int (proots_count ?p {x. ?a < x \\<and> x < ?b}) =\n                    changes_itv_smods_ext ?a ?b ?p (pderiv ?p)\n\ngoal (1 subgoal):\n 1. int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)", "by auto"], ["proof (state)\nthis:\n  int (proots_count p UNIV) = changes_R_smods_ext p (pderiv p)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}