{"file_name": "/home/qj213/afp-2021-10-22/thys/Budan_Fourier/Budan_Fourier.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Budan_Fourier", "problem_names": ["lemma sign_r_pos_nzero_right:\n  assumes nzero:\"\\<forall>x. c<x \\<and> x\\<le>d \\<longrightarrow> poly p x \\<noteq>0\" and \"c<d\"\n  shows \"if sign_r_pos p c then poly p d>0 else poly p d<0\"", "lemma sign_r_pos_at_left:\n  assumes \"p\\<noteq>0\"\n  shows \"if even (order c p) \\<longleftrightarrow>sign_r_pos p c then eventually (\\<lambda>x. poly p x>0) (at_left c)\n         else eventually (\\<lambda>x. poly p x<0) (at_left c)\"", "lemma sign_r_pos_nzero_left:\n  assumes nzero:\"\\<forall>x. d\\<le>x \\<and> x<c \\<longrightarrow> poly p x \\<noteq>0\" and \"d<c\"\n  shows \"if even (order c p) \\<longleftrightarrow>sign_r_pos p c then poly p d>0 else poly p d<0\"", "lemma set_pders_nzero:\n  assumes \"p\\<noteq>0\" \"q\\<in>set (pders p)\"\n  shows \"q\\<noteq>0\"", "lemma changes_poly_pos_inf_pders[simp]:\"changes_poly_pos_inf (pders p) = 0\"", "lemma changes_poly_neg_inf_pders[simp]: \"changes_poly_neg_inf (pders p) = degree p\"", "lemma pders_coeffs_sgn_eq:\"map (\\<lambda>p. sgn(poly p 0)) (pders p) = map sgn (coeffs p)\"", "lemma changes_poly_at_pders_0:\"changes_poly_at (pders p) 0 = changes (coeffs p)\"", "lemma budan_fourier_aux_right:\n  assumes \"c<d2\" and \"p\\<noteq>0\"\n  assumes \"\\<forall>x. c<x\\<and> x\\<le>d2 \\<longrightarrow> (\\<forall>q\\<in>set (pders p). poly q x\\<noteq>0)\"  \n  shows \"changes_itv_der c d2 p=0\"", "lemma budan_fourier_aux_left':\n  assumes \"d1<c\" and \"p\\<noteq>0\"\n  assumes \"\\<forall>x. d1\\<le>x\\<and> x<c \\<longrightarrow> (\\<forall>q\\<in>set (pders p). poly q x\\<noteq>0)\"\n  shows \"changes_itv_der d1 c p \\<ge> order c p \\<and> even (changes_itv_der d1 c p - order c p)\"", "lemma budan_fourier_aux_left:\n  assumes \"d1<c\" and \"p\\<noteq>0\"\n  assumes nzero:\"\\<forall>x. d1<x\\<and> x<c \\<longrightarrow> (\\<forall>q\\<in>set (pders p). poly q x\\<noteq>0)\"\n  shows \"changes_itv_der d1 c p \\<ge> order c p\" \"even (changes_itv_der d1 c p - order c p)\"", "theorem budan_fourier_interval: \n  assumes \"a<b\" \"p\\<noteq>0\"\n  shows \"changes_itv_der a b p \\<ge> proots_count p {x. a< x \\<and> x\\<le> b} \\<and> \n          even (changes_itv_der a b p - proots_count p {x. a< x \\<and> x\\<le> b})\"", "theorem budan_fourier_gt: \n  assumes \"p\\<noteq>0\"\n  shows \"changes_gt_der a p \\<ge> proots_count p {x. a< x} \\<and> \n          even (changes_gt_der a p - proots_count p {x. a< x})\"", "theorem descartes_sign:\n  fixes p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \" changes (coeffs p) \\<ge> proots_count p {x. 0 < x} \\<and> \n          even (changes (coeffs p) - proots_count p {x. 0< x})\"", "theorem budan_fourier_le: \n  assumes \"p\\<noteq>0\"\n  shows \"changes_le_der b p \\<ge> proots_count p {x. x \\<le>b} \\<and> \n          even (changes_le_der b p - proots_count p {x. x \\<le>b})\"", "lemma all_roots_real_mult[simp]:\n  \"all_roots_real (p*q) \\<longleftrightarrow> all_roots_real p \\<and> all_roots_real q\"", "lemma all_roots_real_const_iff:\n  assumes all_real:\"all_roots_real p\"\n  shows \"degree p\\<noteq>0 \\<longleftrightarrow> (\\<exists>x. poly p x=0)\"", "lemma all_roots_real_degree:\n  assumes \"all_roots_real p\" \n  shows \"proots_count p UNIV =degree p\"", "lemma all_real_roots_mobius:\n  fixes a b::real \n  assumes \"all_roots_real p\" and \"a<b\"\n  shows \"all_roots_real (fcompose p [:a,b:] [:1,1:])\""], "translations": [["", "lemma sign_r_pos_nzero_right:\n  assumes nzero:\"\\<forall>x. c<x \\<and> x\\<le>d \\<longrightarrow> poly p x \\<noteq>0\" and \"c<d\"\n  shows \"if sign_r_pos p c then poly p d>0 else poly p d<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if sign_r_pos p c then 0 < poly p d else poly p d < 0", "proof (cases \"sign_r_pos p c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0\n 2. \\<not> sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0", "case True"], ["proof (state)\nthis:\n  sign_r_pos p c\n\ngoal (2 subgoals):\n 1. sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0\n 2. \\<not> sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0", "then"], ["proof (chain)\npicking this:\n  sign_r_pos p c", "obtain d' where \"d'>c\" and d'_pos:\"\\<forall>y>c. y < d' \\<longrightarrow> 0 < poly p y\""], ["proof (prove)\nusing this:\n  sign_r_pos p c\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>c < d';\n         \\<forall>y>c. y < d' \\<longrightarrow> 0 < poly p y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<exists>b>c. \\<forall>y>c. y < b \\<longrightarrow> 0 < poly p y\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>c < d';\n         \\<forall>y>c. y < d' \\<longrightarrow> 0 < poly p y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c < d'\n  \\<forall>y>c. y < d' \\<longrightarrow> 0 < poly p y\n\ngoal (2 subgoals):\n 1. sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0\n 2. \\<not> sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0", "have False when \"\\<not> poly p d>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0", "apply (rule poly_IVT_neg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (c + min d d') / 2 < d\n 2. 0 < poly p ((c + min d d') / 2)\n 3. poly p d < 0", "using \\<open>d'>c\\<close> \\<open>c<d\\<close> that nzero[rule_format,of d,simplified]"], ["proof (prove)\nusing this:\n  c < d'\n  c < d\n  \\<not> 0 < poly p d\n  c < d \\<Longrightarrow> poly p d \\<noteq> 0\n\ngoal (3 subgoals):\n 1. (c + min d d') / 2 < d\n 2. 0 < poly p ((c + min d d') / 2)\n 3. poly p d < 0", "by (auto intro:d'_pos[rule_format])"], ["proof (state)\nthis:\n  \\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "using nzero \\<open>c < d'\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0\n  \\<forall>x. c < x \\<and> x \\<le> d \\<longrightarrow> poly p x \\<noteq> 0\n  c < d'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> 0 < poly p d \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0\n 2. \\<not> sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < poly p d \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 < poly p d \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. if sign_r_pos p c then 0 < poly p d else poly p d < 0", "using True"], ["proof (prove)\nusing this:\n  \\<not> 0 < poly p d \\<Longrightarrow> False\n  sign_r_pos p c\n\ngoal (1 subgoal):\n 1. if sign_r_pos p c then 0 < poly p d else poly p d < 0", "by auto"], ["proof (state)\nthis:\n  if sign_r_pos p c then 0 < poly p d else poly p d < 0\n\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0", "case False"], ["proof (state)\nthis:\n  \\<not> sign_r_pos p c\n\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0", "then"], ["proof (chain)\npicking this:\n  \\<not> sign_r_pos p c", "have \"sign_r_pos (-p) c\""], ["proof (prove)\nusing this:\n  \\<not> sign_r_pos p c\n\ngoal (1 subgoal):\n 1. sign_r_pos (- p) c", "using sign_r_pos_minus[of p c] nzero[rule_format,of d,simplified] \\<open>c<d\\<close>"], ["proof (prove)\nusing this:\n  \\<not> sign_r_pos p c\n  p \\<noteq> 0 \\<Longrightarrow>\n  sign_r_pos p c = (\\<not> sign_r_pos (- p) c)\n  c < d \\<Longrightarrow> poly p d \\<noteq> 0\n  c < d\n\ngoal (1 subgoal):\n 1. sign_r_pos (- p) c", "by fastforce"], ["proof (state)\nthis:\n  sign_r_pos (- p) c\n\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0", "then"], ["proof (chain)\npicking this:\n  sign_r_pos (- p) c", "obtain d' where \"d'>c\" and d'_neg:\"\\<forall>y>c. y < d' \\<longrightarrow> 0 > poly p y\""], ["proof (prove)\nusing this:\n  sign_r_pos (- p) c\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>c < d';\n         \\<forall>y>c. y < d' \\<longrightarrow> poly p y < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sign_r_pos_def eventually_at_right"], ["proof (prove)\nusing this:\n  \\<exists>b>c. \\<forall>y>c. y < b \\<longrightarrow> 0 < poly (- p) y\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>c < d';\n         \\<forall>y>c. y < d' \\<longrightarrow> poly p y < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c < d'\n  \\<forall>y>c. y < d' \\<longrightarrow> poly p y < 0\n\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0", "have False when \"\\<not> poly p d<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0", "apply (rule poly_IVT_pos)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (c + min d d') / 2 < d\n 2. poly p ((c + min d d') / 2) < 0\n 3. 0 < poly p d", "using \\<open>d'>c\\<close> \\<open>c<d\\<close> that nzero[rule_format,of d,simplified]"], ["proof (prove)\nusing this:\n  c < d'\n  c < d\n  \\<not> poly p d < 0\n  c < d \\<Longrightarrow> poly p d \\<noteq> 0\n\ngoal (3 subgoals):\n 1. (c + min d d') / 2 < d\n 2. poly p ((c + min d d') / 2) < 0\n 3. 0 < poly p d", "by (auto intro:d'_neg[rule_format])"], ["proof (state)\nthis:\n  \\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "using nzero \\<open>c < d'\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x>(c + min d d') / 2. x < d \\<and> poly p x = 0\n  \\<forall>x. c < x \\<and> x \\<le> d \\<longrightarrow> poly p x \\<noteq> 0\n  c < d'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> poly p d < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos p c \\<Longrightarrow>\n    if sign_r_pos p c then 0 < poly p d else poly p d < 0", "then"], ["proof (chain)\npicking this:\n  \\<not> poly p d < 0 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> poly p d < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. if sign_r_pos p c then 0 < poly p d else poly p d < 0", "using False"], ["proof (prove)\nusing this:\n  \\<not> poly p d < 0 \\<Longrightarrow> False\n  \\<not> sign_r_pos p c\n\ngoal (1 subgoal):\n 1. if sign_r_pos p c then 0 < poly p d else poly p d < 0", "by auto"], ["proof (state)\nthis:\n  if sign_r_pos p c then 0 < poly p d else poly p d < 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_r_pos_at_left:\n  assumes \"p\\<noteq>0\"\n  shows \"if even (order c p) \\<longleftrightarrow>sign_r_pos p c then eventually (\\<lambda>x. poly p x>0) (at_left c)\n         else eventually (\\<lambda>x. poly p x<0) (at_left c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    if even (order c 0) = sign_r_pos 0 c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly 0 x\n    else \\<forall>\\<^sub>F x in at_left c. poly 0 x < 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c p) = sign_r_pos p c\n                         then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                         else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "case 0"], ["proof (state)\nthis:\n  0 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow>\n    if even (order c 0) = sign_r_pos 0 c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly 0 x\n    else \\<forall>\\<^sub>F x in at_left c. poly 0 x < 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c p) = sign_r_pos p c\n                         then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                         else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 3. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. if even (order c 0) = sign_r_pos 0 c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly 0 x\n    else \\<forall>\\<^sub>F x in at_left c. poly 0 x < 0", "by simp"], ["proof (state)\nthis:\n  if even (order c 0) = sign_r_pos 0 c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly 0 x\n  else \\<forall>\\<^sub>F x in at_left c. poly 0 x < 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c p) = sign_r_pos p c\n                         then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                         else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c p) = sign_r_pos p c\n                         then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                         else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c p) = sign_r_pos p c\n                         then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                         else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "then"], ["proof (chain)\npicking this:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0", "have [simp]:\"order c p = 0\""], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order c p = 0", "using order_root"], ["proof (prove)\nusing this:\n  poly p ?a \\<noteq> 0\n  p \\<noteq> 0\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. order c p = 0", "by blast"], ["proof (state)\nthis:\n  order c p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c p) = sign_r_pos p c\n                         then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                         else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "have ?case when \"poly p c >0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "have \"\\<forall>\\<^sub>F x in at c. 0 < poly p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at c. 0 < poly p x", "using that"], ["proof (prove)\nusing this:\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at c. 0 < poly p x", "by (metis (no_types, lifting) less_linear no_proots.hyps not_eventuallyD \n          poly_IVT_neg poly_IVT_pos)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at c. 0 < poly p x\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at c. 0 < poly p x", "have \"\\<forall>\\<^sub>F x in at_left c. 0 < poly p x\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at c. 0 < poly p x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. 0 < poly p x", "using eventually_at_split"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at c. 0 < poly p x\n  eventually ?P (at ?x) =\n  (eventually ?P (at_left ?x) \\<and> eventually ?P (at_right ?x))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. 0 < poly p x", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "have \"sign_r_pos p c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos p c", "using sign_r_pos_rec[OF \\<open>p\\<noteq>0\\<close>] that"], ["proof (prove)\nusing this:\n  sign_r_pos p ?x =\n  (if poly p ?x = 0 then sign_r_pos (pderiv p) ?x else 0 < poly p ?x)\n  0 < poly p c\n\ngoal (1 subgoal):\n 1. sign_r_pos p c", "by auto"], ["proof (state)\nthis:\n  sign_r_pos p c\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  sign_r_pos p c", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  sign_r_pos p c\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "by simp"], ["proof (state)\nthis:\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < poly p c \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c p) = sign_r_pos p c\n                         then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                         else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "moreover"], ["proof (state)\nthis:\n  0 < poly p c \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c p) = sign_r_pos p c\n                         then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                         else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "have ?case when \"poly p c <0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "have \"\\<forall>\\<^sub>F x in at c. poly p x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at c. poly p x < 0", "using that"], ["proof (prove)\nusing this:\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at c. poly p x < 0", "by (metis (no_types, lifting) less_linear no_proots.hyps not_eventuallyD \n          poly_IVT_neg poly_IVT_pos)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at c. poly p x < 0\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at c. poly p x < 0", "have \"\\<forall>\\<^sub>F x in at_left c. poly p x < 0\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at c. poly p x < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "using eventually_at_split"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at c. poly p x < 0\n  eventually ?P (at ?x) =\n  (eventually ?P (at_left ?x) \\<and> eventually ?P (at_right ?x))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "have \"\\<not> sign_r_pos p c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos p c", "using sign_r_pos_rec[OF \\<open>p\\<noteq>0\\<close>] that"], ["proof (prove)\nusing this:\n  sign_r_pos p ?x =\n  (if poly p ?x = 0 then sign_r_pos (pderiv p) ?x else 0 < poly p ?x)\n  poly p c < 0\n\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos p c", "by auto"], ["proof (state)\nthis:\n  \\<not> sign_r_pos p c\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n  \\<not> sign_r_pos p c", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n  \\<not> sign_r_pos p c\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "by simp"], ["proof (state)\nthis:\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p c < 0 \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c p) = sign_r_pos p c\n                         then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                         else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 2. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "ultimately"], ["proof (chain)\npicking this:\n  0 < poly p c \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n  poly p c < 0 \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "show ?case"], ["proof (prove)\nusing this:\n  0 < poly p c \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n  poly p c < 0 \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "using no_proots(1)[of c]"], ["proof (prove)\nusing this:\n  0 < poly p c \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n  poly p c < 0 \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n  poly p c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "by argo"], ["proof (state)\nthis:\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "case (root a p)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n  [:- a, 1:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "define aa where \"aa=[:-a,1:]\""], ["proof (state)\nthis:\n  aa = [:- a, 1:]\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "have [simp]:\"aa\\<noteq>0\" \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aa \\<noteq> 0 &&& p \\<noteq> 0", "using \\<open>[:- a, 1:] * p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  [:- a, 1:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. aa \\<noteq> 0 &&& p \\<noteq> 0", "unfolding aa_def"], ["proof (prove)\nusing this:\n  [:- a, 1:] * p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:- a, 1:] \\<noteq> 0 &&& p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  aa \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "have ?case when \"c>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "have \"?thesis = (if even (order c p) = sign_r_pos p c \n            then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n            else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)", "have \"order c aa=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c aa = 0", "unfolding aa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order c [:- a, 1:] = 0", "using order_0I that"], ["proof (prove)\nusing this:\n  poly ?p ?a \\<noteq> (0::?'a) \\<Longrightarrow> order ?a ?p = 0\n  a < c\n\ngoal (1 subgoal):\n 1. order c [:- a, 1:] = 0", "by force"], ["proof (state)\nthis:\n  order c aa = 0\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)", "then"], ["proof (chain)\npicking this:\n  order c aa = 0", "have \"even (order c (aa * p)) = even (order c p)\""], ["proof (prove)\nusing this:\n  order c aa = 0\n\ngoal (1 subgoal):\n 1. even (order c (aa * p)) = even (order c p)", "by (subst order_mult) auto"], ["proof (state)\nthis:\n  even (order c (aa * p)) = even (order c p)\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)", "moreover"], ["proof (state)\nthis:\n  even (order c (aa * p)) = even (order c p)\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)", "have \"sign_r_pos aa c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos aa c", "unfolding aa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos [:- a, 1:] c", "using that"], ["proof (prove)\nusing this:\n  a < c\n\ngoal (1 subgoal):\n 1. sign_r_pos [:- a, 1:] c", "by (auto simp: sign_r_pos_rec)"], ["proof (state)\nthis:\n  sign_r_pos aa c\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)", "then"], ["proof (chain)\npicking this:\n  sign_r_pos aa c", "have \"sign_r_pos (aa * p) c = sign_r_pos p c\""], ["proof (prove)\nusing this:\n  sign_r_pos aa c\n\ngoal (1 subgoal):\n 1. sign_r_pos (aa * p) c = sign_r_pos p c", "by (subst sign_r_pos_mult) auto"], ["proof (state)\nthis:\n  sign_r_pos (aa * p) c = sign_r_pos p c\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)", "ultimately"], ["proof (chain)\npicking this:\n  even (order c (aa * p)) = even (order c p)\n  sign_r_pos (aa * p) c = sign_r_pos p c", "show ?thesis"], ["proof (prove)\nusing this:\n  even (order c (aa * p)) = even (order c p)\n  sign_r_pos (aa * p) c = sign_r_pos p c\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)", "by (fold aa_def) auto"], ["proof (state)\nthis:\n  (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "also"], ["proof (state)\nthis:\n  (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "have \"... = (if even (order c p) = sign_r_pos p c \n            then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n            else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "have \"\\<forall>\\<^sub>F x in at_left c. 0 < poly aa x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. 0 < poly aa x", "apply (simp add:aa_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually ((<) a) (at_left c)", "using that eventually_at_left_field"], ["proof (prove)\nusing this:\n  a < c\n  eventually ?P (at_left ?x) =\n  (\\<exists>b<?x. \\<forall>y>b. y < ?x \\<longrightarrow> ?P y)\n\ngoal (1 subgoal):\n 1. eventually ((<) a) (at_left c)", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left c. 0 < poly aa x\n\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left c. 0 < poly aa x", "have \"(\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) \\<longleftrightarrow> (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)\"\n        \"(\\<forall>\\<^sub>F x in at_left c. 0 > poly (aa * p) x) \\<longleftrightarrow> (\\<forall>\\<^sub>F x in at_left c. 0 > poly p x)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left c. 0 < poly aa x\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x) &&&\n    (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n    (\\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. 0 < poly aa x;\n     \\<forall>\\<^sub>F x in at_left c. 0 < poly aa x * poly p x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n 2. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. 0 < poly aa x;\n     \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c.\n                         0 < poly aa x * poly p x\n 3. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. 0 < poly aa x;\n     \\<forall>\\<^sub>F x in at_left c. poly aa x * poly p x < 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 4. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. 0 < poly aa x;\n     \\<forall>\\<^sub>F x in at_left c. poly p x < 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c.\n                         poly aa x * poly p x < 0", "by (erule (1) eventually_elim2,simp add: zero_less_mult_iff mult_less_0_iff)+"], ["proof (state)\nthis:\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)\n  (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (\\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "then"], ["proof (chain)\npicking this:\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)\n  (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (\\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)\n  (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (\\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "by simp"], ["proof (state)\nthis:\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n   else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n   else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "also"], ["proof (state)\nthis:\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n   else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "using root.hyps"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "by simp"], ["proof (state)\nthis:\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "finally"], ["proof (chain)\npicking this:\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "."], ["proof (state)\nthis:\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < c \\<Longrightarrow>\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "moreover"], ["proof (state)\nthis:\n  a < c \\<Longrightarrow>\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "have ?case when \"c<a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "have \"?thesis = (if even (order c p) = sign_r_pos p c \n            then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n            else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "have \"order c aa=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c aa = 0", "unfolding aa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order c [:- a, 1:] = 0", "using order_0I that"], ["proof (prove)\nusing this:\n  poly ?p ?a \\<noteq> (0::?'a) \\<Longrightarrow> order ?a ?p = 0\n  c < a\n\ngoal (1 subgoal):\n 1. order c [:- a, 1:] = 0", "by force"], ["proof (state)\nthis:\n  order c aa = 0\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "then"], ["proof (chain)\npicking this:\n  order c aa = 0", "have \"even (order c (aa * p)) = even (order c p)\""], ["proof (prove)\nusing this:\n  order c aa = 0\n\ngoal (1 subgoal):\n 1. even (order c (aa * p)) = even (order c p)", "by (subst order_mult) auto"], ["proof (state)\nthis:\n  even (order c (aa * p)) = even (order c p)\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "moreover"], ["proof (state)\nthis:\n  even (order c (aa * p)) = even (order c p)\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "have \"\\<not> sign_r_pos aa c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos aa c", "unfolding aa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos [:- a, 1:] c", "using that"], ["proof (prove)\nusing this:\n  c < a\n\ngoal (1 subgoal):\n 1. \\<not> sign_r_pos [:- a, 1:] c", "by (auto simp: sign_r_pos_rec)"], ["proof (state)\nthis:\n  \\<not> sign_r_pos aa c\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "then"], ["proof (chain)\npicking this:\n  \\<not> sign_r_pos aa c", "have \"sign_r_pos (aa * p) c = (\\<not> sign_r_pos p c)\""], ["proof (prove)\nusing this:\n  \\<not> sign_r_pos aa c\n\ngoal (1 subgoal):\n 1. sign_r_pos (aa * p) c = (\\<not> sign_r_pos p c)", "by (subst sign_r_pos_mult) auto"], ["proof (state)\nthis:\n  sign_r_pos (aa * p) c = (\\<not> sign_r_pos p c)\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "ultimately"], ["proof (chain)\npicking this:\n  even (order c (aa * p)) = even (order c p)\n  sign_r_pos (aa * p) c = (\\<not> sign_r_pos p c)", "show ?thesis"], ["proof (prove)\nusing this:\n  even (order c (aa * p)) = even (order c p)\n  sign_r_pos (aa * p) c = (\\<not> sign_r_pos p c)\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "by (fold aa_def) auto"], ["proof (state)\nthis:\n  (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "also"], ["proof (state)\nthis:\n  (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "have \"... = (if even (order c p) = sign_r_pos p c \n            then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n            else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "have \"\\<forall>\\<^sub>F x in at_left c. poly aa x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. poly aa x < 0", "apply (simp add:aa_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. x < a", "using that eventually_at_filter"], ["proof (prove)\nusing this:\n  c < a\n  eventually ?P (at ?a within ?s) =\n  (\\<forall>\\<^sub>F x in nhds ?a.\n      x \\<noteq> ?a \\<longrightarrow> x \\<in> ?s \\<longrightarrow> ?P x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. x < a", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left c. poly aa x < 0\n\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left c. poly aa x < 0", "have \"(\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) \\<longleftrightarrow> (\\<forall>\\<^sub>F x in at_left c. poly p x < 0)\"\n        \"(\\<forall>\\<^sub>F x in at_left c. 0 > poly (aa * p) x) \\<longleftrightarrow> (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left c. poly aa x < 0\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (\\<forall>\\<^sub>F x in at_left c. poly p x < 0) &&&\n    (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n    (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. poly aa x < 0;\n     \\<forall>\\<^sub>F x in at_left c. 0 < poly aa x * poly p x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 2. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. poly aa x < 0;\n     \\<forall>\\<^sub>F x in at_left c. poly p x < 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c.\n                         0 < poly aa x * poly p x\n 3. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. poly aa x < 0;\n     \\<forall>\\<^sub>F x in at_left c. poly aa x * poly p x < 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n 4. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. poly aa x < 0;\n     \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c.\n                         poly aa x * poly p x < 0", "by (erule (1) eventually_elim2,simp add: zero_less_mult_iff mult_less_0_iff)+"], ["proof (state)\nthis:\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (\\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n  (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)\n\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "then"], ["proof (chain)\npicking this:\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (\\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n  (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (\\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n  (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)\n\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "by simp"], ["proof (state)\nthis:\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n   else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n   else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "also"], ["proof (state)\nthis:\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n   else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "using root.hyps"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "by simp"], ["proof (state)\nthis:\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "finally"], ["proof (chain)\npicking this:\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "."], ["proof (state)\nthis:\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c < a \\<Longrightarrow>\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "moreover"], ["proof (state)\nthis:\n  c < a \\<Longrightarrow>\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "have ?case when \"c=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "have \"?thesis = (if even (order c p) = sign_r_pos p c \n            then \\<forall>\\<^sub>F x in at_left c. 0 > poly (aa * p) x\n            else \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "have \"order c aa=1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c aa = 1", "unfolding aa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order c [:- a, 1:] = 1", "using that"], ["proof (prove)\nusing this:\n  c = a\n\ngoal (1 subgoal):\n 1. order c [:- a, 1:] = 1", "by (metis order_power_n_n power_one_right)"], ["proof (state)\nthis:\n  order c aa = 1\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "then"], ["proof (chain)\npicking this:\n  order c aa = 1", "have \"even (order c (aa * p)) = odd (order c p)\""], ["proof (prove)\nusing this:\n  order c aa = 1\n\ngoal (1 subgoal):\n 1. even (order c (aa * p)) = odd (order c p)", "by (subst order_mult) auto"], ["proof (state)\nthis:\n  even (order c (aa * p)) = odd (order c p)\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "moreover"], ["proof (state)\nthis:\n  even (order c (aa * p)) = odd (order c p)\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "have \"sign_r_pos aa c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos aa c", "unfolding aa_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_r_pos [:- a, 1:] c", "using that"], ["proof (prove)\nusing this:\n  c = a\n\ngoal (1 subgoal):\n 1. sign_r_pos [:- a, 1:] c", "by (auto simp: sign_r_pos_rec pderiv_pCons)"], ["proof (state)\nthis:\n  sign_r_pos aa c\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "then"], ["proof (chain)\npicking this:\n  sign_r_pos aa c", "have \"sign_r_pos (aa * p) c = sign_r_pos p c\""], ["proof (prove)\nusing this:\n  sign_r_pos aa c\n\ngoal (1 subgoal):\n 1. sign_r_pos (aa * p) c = sign_r_pos p c", "by (subst sign_r_pos_mult) auto"], ["proof (state)\nthis:\n  sign_r_pos (aa * p) c = sign_r_pos p c\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "ultimately"], ["proof (chain)\npicking this:\n  even (order c (aa * p)) = odd (order c p)\n  sign_r_pos (aa * p) c = sign_r_pos p c", "show ?thesis"], ["proof (prove)\nusing this:\n  even (order c (aa * p)) = odd (order c p)\n  sign_r_pos (aa * p) c = sign_r_pos p c\n\ngoal (1 subgoal):\n 1. (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n     else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)", "by (fold aa_def) auto"], ["proof (state)\nthis:\n  (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "also"], ["proof (state)\nthis:\n  (if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n   else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "have \"... = (if even (order c p) = sign_r_pos p c \n            then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n            else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "have \"\\<forall>\\<^sub>F x in at_left c. 0 > poly aa x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. poly aa x < 0", "apply (simp add:aa_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. x < a", "using that"], ["proof (prove)\nusing this:\n  c = a\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. x < a", "by (simp add: eventually_at_filter)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left c. poly aa x < 0\n\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left c. poly aa x < 0", "have \"(\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) \\<longleftrightarrow> (\\<forall>\\<^sub>F x in at_left c. 0 > poly p x)\"\n        \"(\\<forall>\\<^sub>F x in at_left c. 0 > poly (aa * p) x) \\<longleftrightarrow> (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left c. poly aa x < 0\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (\\<forall>\\<^sub>F x in at_left c. poly p x < 0) &&&\n    (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n    (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. poly aa x < 0;\n     \\<forall>\\<^sub>F x in at_left c. 0 < poly aa x * poly p x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n 2. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. poly aa x < 0;\n     \\<forall>\\<^sub>F x in at_left c. poly p x < 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c.\n                         0 < poly aa x * poly p x\n 3. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. poly aa x < 0;\n     \\<forall>\\<^sub>F x in at_left c. poly aa x * poly p x < 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n 4. \\<lbrakk>\\<forall>\\<^sub>F x in at_left c. poly aa x < 0;\n     \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<^sub>F x in at_left c.\n                         poly aa x * poly p x < 0", "by (erule (1) eventually_elim2,simp add: zero_less_mult_iff mult_less_0_iff)+"], ["proof (state)\nthis:\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (\\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n  (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)\n\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "then"], ["proof (chain)\npicking this:\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (\\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n  (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (\\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n  (\\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0) =\n  (\\<forall>\\<^sub>F x in at_left c. 0 < poly p x)\n\ngoal (1 subgoal):\n 1. (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n     else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n    (if even (order c p) = sign_r_pos p c\n     then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n     else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)", "by simp"], ["proof (state)\nthis:\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n   else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n   else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "also"], ["proof (state)\nthis:\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. poly (aa * p) x < 0\n   else \\<forall>\\<^sub>F x in at_left c. 0 < poly (aa * p) x) =\n  (if even (order c p) = sign_r_pos p c\n   then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n   else \\<forall>\\<^sub>F x in at_left c. poly p x < 0)\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "using root.hyps"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n    else \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "by simp"], ["proof (state)\nthis:\n  if even (order c p) = sign_r_pos p c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n  else \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "finally"], ["proof (chain)\npicking this:\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "."], ["proof (state)\nthis:\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c = a \\<Longrightarrow>\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>p \\<noteq> 0 \\<Longrightarrow>\n                if even (order c p) = sign_r_pos p c\n                then \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n                else \\<forall>\\<^sub>F x in at_left c. poly p x < 0;\n        [:- a, 1:] * p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if even (order c ([:- a, 1:] * p)) =\n                            sign_r_pos ([:- a, 1:] * p) c\n                         then \\<forall>\\<^sub>F x in at_left c.\n                                 0 < poly ([:- a, 1:] * p) x\n                         else \\<forall>\\<^sub>F x in at_left c.\n                                 poly ([:- a, 1:] * p) x < 0", "ultimately"], ["proof (chain)\npicking this:\n  a < c \\<Longrightarrow>\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n  c < a \\<Longrightarrow>\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n  c = a \\<Longrightarrow>\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "show ?case"], ["proof (prove)\nusing this:\n  a < c \\<Longrightarrow>\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n  c < a \\<Longrightarrow>\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n  c = a \\<Longrightarrow>\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal (1 subgoal):\n 1. if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n    then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n    else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0", "by argo"], ["proof (state)\nthis:\n  if even (order c ([:- a, 1:] * p)) = sign_r_pos ([:- a, 1:] * p) c\n  then \\<forall>\\<^sub>F x in at_left c. 0 < poly ([:- a, 1:] * p) x\n  else \\<forall>\\<^sub>F x in at_left c. poly ([:- a, 1:] * p) x < 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_r_pos_nzero_left:\n  assumes nzero:\"\\<forall>x. d\\<le>x \\<and> x<c \\<longrightarrow> poly p x \\<noteq>0\" and \"d<c\"\n  shows \"if even (order c p) \\<longleftrightarrow>sign_r_pos p c then poly p d>0 else poly p d<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "proof (cases \"even (order c p) \\<longleftrightarrow>sign_r_pos p c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even (order c p) = sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0\n 2. even (order c p) \\<noteq> sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "case True"], ["proof (state)\nthis:\n  even (order c p) = sign_r_pos p c\n\ngoal (2 subgoals):\n 1. even (order c p) = sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0\n 2. even (order c p) \\<noteq> sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "then"], ["proof (chain)\npicking this:\n  even (order c p) = sign_r_pos p c", "have \"eventually (\\<lambda>x. poly p x>0) (at_left c)\""], ["proof (prove)\nusing this:\n  even (order c p) = sign_r_pos p c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. 0 < poly p x", "using nzero[rule_format,of d,simplified] \\<open>d<c\\<close> sign_r_pos_at_left"], ["proof (prove)\nusing this:\n  even (order c p) = sign_r_pos p c\n  d < c \\<Longrightarrow> poly p d \\<noteq> 0\n  d < c\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  if even (order ?c ?p) = sign_r_pos ?p ?c\n  then \\<forall>\\<^sub>F x in at_left ?c. 0 < poly ?p x\n  else \\<forall>\\<^sub>F x in at_left ?c. poly ?p x < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. 0 < poly p x", "by (simp add: order_root)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n\ngoal (2 subgoals):\n 1. even (order c p) = sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0\n 2. even (order c p) \\<noteq> sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left c. 0 < poly p x", "obtain d' where \"d'<c\" and d'_pos:\"\\<forall>y>d'. y < c \\<longrightarrow> 0 < poly p y\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left c. 0 < poly p x\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>d' < c;\n         \\<forall>y>d'. y < c \\<longrightarrow> 0 < poly p y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_at_left"], ["proof (prove)\nusing this:\n  \\<exists>b<c. \\<forall>y>b. y < c \\<longrightarrow> 0 < poly p y\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>d' < c;\n         \\<forall>y>d'. y < c \\<longrightarrow> 0 < poly p y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d' < c\n  \\<forall>y>d'. y < c \\<longrightarrow> 0 < poly p y\n\ngoal (2 subgoals):\n 1. even (order c p) = sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0\n 2. even (order c p) \\<noteq> sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "have False when \"\\<not> poly p d>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0", "apply (rule poly_IVT_pos)"], ["proof (prove)\ngoal (3 subgoals):\n 1. d < (c + max d d') / 2\n 2. poly p d < 0\n 3. 0 < poly p ((c + max d d') / 2)", "using \\<open>d'<c\\<close> \\<open>c>d\\<close> that nzero[rule_format,of d,simplified]"], ["proof (prove)\nusing this:\n  d' < c\n  d < c\n  \\<not> 0 < poly p d\n  d < c \\<Longrightarrow> poly p d \\<noteq> 0\n\ngoal (3 subgoals):\n 1. d < (c + max d d') / 2\n 2. poly p d < 0\n 3. 0 < poly p ((c + max d d') / 2)", "by (auto intro:d'_pos[rule_format])"], ["proof (state)\nthis:\n  \\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "using nzero \\<open>c > d'\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0\n  \\<forall>x. d \\<le> x \\<and> x < c \\<longrightarrow> poly p x \\<noteq> 0\n  d' < c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> 0 < poly p d \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. even (order c p) = sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0\n 2. even (order c p) \\<noteq> sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < poly p d \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 < poly p d \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "using True"], ["proof (prove)\nusing this:\n  \\<not> 0 < poly p d \\<Longrightarrow> False\n  even (order c p) = sign_r_pos p c\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "by auto"], ["proof (state)\nthis:\n  if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0\n\ngoal (1 subgoal):\n 1. even (order c p) \\<noteq> sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. even (order c p) \\<noteq> sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "case False"], ["proof (state)\nthis:\n  even (order c p) \\<noteq> sign_r_pos p c\n\ngoal (1 subgoal):\n 1. even (order c p) \\<noteq> sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "then"], ["proof (chain)\npicking this:\n  even (order c p) \\<noteq> sign_r_pos p c", "have \"eventually (\\<lambda>x. poly p x<0) (at_left c)\""], ["proof (prove)\nusing this:\n  even (order c p) \\<noteq> sign_r_pos p c\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "using nzero[rule_format,of d,simplified] \\<open>d<c\\<close> sign_r_pos_at_left"], ["proof (prove)\nusing this:\n  even (order c p) \\<noteq> sign_r_pos p c\n  d < c \\<Longrightarrow> poly p d \\<noteq> 0\n  d < c\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  if even (order ?c ?p) = sign_r_pos ?p ?c\n  then \\<forall>\\<^sub>F x in at_left ?c. 0 < poly ?p x\n  else \\<forall>\\<^sub>F x in at_left ?c. poly ?p x < 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "by (simp add: order_root)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. even (order c p) \\<noteq> sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left c. poly p x < 0", "obtain d' where \"d'<c\" and d'_neg:\"\\<forall>y>d'. y < c \\<longrightarrow> 0 > poly p y\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left c. poly p x < 0\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>d' < c;\n         \\<forall>y>d'. y < c \\<longrightarrow> poly p y < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_at_left"], ["proof (prove)\nusing this:\n  \\<exists>b<c. \\<forall>y>b. y < c \\<longrightarrow> poly p y < 0\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>d' < c;\n         \\<forall>y>d'. y < c \\<longrightarrow> poly p y < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d' < c\n  \\<forall>y>d'. y < c \\<longrightarrow> poly p y < 0\n\ngoal (1 subgoal):\n 1. even (order c p) \\<noteq> sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "have False when \"\\<not> poly p d<0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0", "apply (rule poly_IVT_neg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. d < (c + max d d') / 2\n 2. 0 < poly p d\n 3. poly p ((c + max d d') / 2) < 0", "using \\<open>d'<c\\<close> \\<open>c>d\\<close> that nzero[rule_format,of d,simplified]"], ["proof (prove)\nusing this:\n  d' < c\n  d < c\n  \\<not> poly p d < 0\n  d < c \\<Longrightarrow> poly p d \\<noteq> 0\n\ngoal (3 subgoals):\n 1. d < (c + max d d') / 2\n 2. 0 < poly p d\n 3. poly p ((c + max d d') / 2) < 0", "by (auto intro:d'_neg[rule_format])"], ["proof (state)\nthis:\n  \\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0\n\ngoal (1 subgoal):\n 1. False", "using nzero \\<open>c > d'\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x>d. x < (c + max d d') / 2 \\<and> poly p x = 0\n  \\<forall>x. d \\<le> x \\<and> x < c \\<longrightarrow> poly p x \\<noteq> 0\n  d' < c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> poly p d < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. even (order c p) \\<noteq> sign_r_pos p c \\<Longrightarrow>\n    if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "then"], ["proof (chain)\npicking this:\n  \\<not> poly p d < 0 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> poly p d < 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "using False"], ["proof (prove)\nusing this:\n  \\<not> poly p d < 0 \\<Longrightarrow> False\n  even (order c p) \\<noteq> sign_r_pos p c\n\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0", "by auto"], ["proof (state)\nthis:\n  if even (order c p) = sign_r_pos p c then 0 < poly p d else poly p d < 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Fourier sequences\\<close>"], ["", "function pders::\"real poly \\<Rightarrow> real poly list\" where\n  \"pders p = (if p =0 then [] else Cons p (pders (pderiv p)))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>p. x = p \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>p pa.\n       p = pa \\<Longrightarrow>\n       (if p = 0 then [] else p # pders_sumC (pderiv p)) =\n       (if pa = 0 then [] else pa # pders_sumC (pderiv pa))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All pders_dom", "apply (relation \"measure (\\<lambda>p. if p=0 then 0 else degree p + 1)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>p. if p = 0 then 0 else degree p + 1))\n 2. \\<And>p.\n       p \\<noteq> 0 \\<Longrightarrow>\n       (pderiv p, p)\n       \\<in> measure (\\<lambda>p. if p = 0 then 0 else degree p + 1)", "by (auto simp:degree_pderiv pderiv_eq_0_iff)"], ["", "declare pders.simps[simp del]"], ["", "lemma set_pders_nzero:\n  assumes \"p\\<noteq>0\" \"q\\<in>set (pders p)\"\n  shows \"q\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<in> set (pders p)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "proof (induct p rule:pders.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n                 q \\<in> set (pders (pderiv p))\\<rbrakk>\n                \\<Longrightarrow> q \\<noteq> 0;\n        p \\<noteq> 0; q \\<in> set (pders p)\\<rbrakk>\n       \\<Longrightarrow> q \\<noteq> 0", "case (1 p)"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n   q \\<in> set (pders (pderiv p))\\<rbrakk>\n  \\<Longrightarrow> q \\<noteq> 0\n  p \\<noteq> 0\n  q \\<in> set (pders p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n                 q \\<in> set (pders (pderiv p))\\<rbrakk>\n                \\<Longrightarrow> q \\<noteq> 0;\n        p \\<noteq> 0; q \\<in> set (pders p)\\<rbrakk>\n       \\<Longrightarrow> q \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n   q \\<in> set (pders (pderiv p))\\<rbrakk>\n  \\<Longrightarrow> q \\<noteq> 0\n  p \\<noteq> 0\n  q \\<in> set (pders p)", "have \"q \\<in> set (p # pders (pderiv p))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n   q \\<in> set (pders (pderiv p))\\<rbrakk>\n  \\<Longrightarrow> q \\<noteq> 0\n  p \\<noteq> 0\n  q \\<in> set (pders p)\n\ngoal (1 subgoal):\n 1. q \\<in> set (p # pders (pderiv p))", "by (simp add: pders.simps)"], ["proof (state)\nthis:\n  q \\<in> set (p # pders (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n                 q \\<in> set (pders (pderiv p))\\<rbrakk>\n                \\<Longrightarrow> q \\<noteq> 0;\n        p \\<noteq> 0; q \\<in> set (pders p)\\<rbrakk>\n       \\<Longrightarrow> q \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  q \\<in> set (p # pders (pderiv p))", "have \"q=p \\<or> q\\<in>set (pders (pderiv p))\""], ["proof (prove)\nusing this:\n  q \\<in> set (p # pders (pderiv p))\n\ngoal (1 subgoal):\n 1. q = p \\<or> q \\<in> set (pders (pderiv p))", "by auto"], ["proof (state)\nthis:\n  q = p \\<or> q \\<in> set (pders (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n                 q \\<in> set (pders (pderiv p))\\<rbrakk>\n                \\<Longrightarrow> q \\<noteq> 0;\n        p \\<noteq> 0; q \\<in> set (pders p)\\<rbrakk>\n       \\<Longrightarrow> q \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  q = p \\<or> q \\<in> set (pders (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n                 q \\<in> set (pders (pderiv p))\\<rbrakk>\n                \\<Longrightarrow> q \\<noteq> 0;\n        p \\<noteq> 0; q \\<in> set (pders p)\\<rbrakk>\n       \\<Longrightarrow> q \\<noteq> 0", "have ?case when \"q=p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using that \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q = p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q = p \\<Longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n                 q \\<in> set (pders (pderiv p))\\<rbrakk>\n                \\<Longrightarrow> q \\<noteq> 0;\n        p \\<noteq> 0; q \\<in> set (pders p)\\<rbrakk>\n       \\<Longrightarrow> q \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  q = p \\<Longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n                 q \\<in> set (pders (pderiv p))\\<rbrakk>\n                \\<Longrightarrow> q \\<noteq> 0;\n        p \\<noteq> 0; q \\<in> set (pders p)\\<rbrakk>\n       \\<Longrightarrow> q \\<noteq> 0", "have ?case when \"q\\<in>set (pders (pderiv p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using 1 pders.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n   q \\<in> set (pders (pderiv p))\\<rbrakk>\n  \\<Longrightarrow> q \\<noteq> 0\n  p \\<noteq> 0\n  q \\<in> set (pders p)\n  pders ?p = (if ?p = 0 then [] else ?p # pders (pderiv ?p))\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  q \\<in> set (pders (pderiv p)) \\<Longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0;\n                 q \\<in> set (pders (pderiv p))\\<rbrakk>\n                \\<Longrightarrow> q \\<noteq> 0;\n        p \\<noteq> 0; q \\<in> set (pders p)\\<rbrakk>\n       \\<Longrightarrow> q \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  q = p \\<or> q \\<in> set (pders (pderiv p))\n  q = p \\<Longrightarrow> q \\<noteq> 0\n  q \\<in> set (pders (pderiv p)) \\<Longrightarrow> q \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  q = p \\<or> q \\<in> set (pders (pderiv p))\n  q = p \\<Longrightarrow> q \\<noteq> 0\n  q \\<in> set (pders (pderiv p)) \\<Longrightarrow> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Sign variations for Fourier sequences\\<close>"], ["", "definition changes_itv_der:: \"real \\<Rightarrow> real \\<Rightarrow>real poly \\<Rightarrow>  int\" where\n  \"changes_itv_der a b p= (let ps= pders p in changes_poly_at ps a - changes_poly_at ps b)\""], ["", "definition changes_gt_der:: \"real \\<Rightarrow>real poly \\<Rightarrow> int\" where\n  \"changes_gt_der a p= changes_poly_at (pders p) a\""], ["", "definition changes_le_der:: \"real \\<Rightarrow>real poly \\<Rightarrow> int\" where\n  \"changes_le_der b p= (degree p - changes_poly_at (pders p) b)\""], ["", "lemma changes_poly_pos_inf_pders[simp]:\"changes_poly_pos_inf (pders p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_pos_inf (pders p) = 0", "proof (induct \"degree p\" arbitrary:p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       0 = degree p \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "case 0"], ["proof (state)\nthis:\n  0 = degree p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       0 = degree p \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "then"], ["proof (chain)\npicking this:\n  0 = degree p", "obtain a where \"p=[:a:]\""], ["proof (prove)\nusing this:\n  0 = degree p\n\ngoal (1 subgoal):\n 1. (\\<And>a. p = [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using degree_eq_zeroE"], ["proof (prove)\nusing this:\n  0 = degree p\n  \\<lbrakk>degree ?p = 0;\n   \\<And>a. ?p = [:a:] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a. p = [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = [:a:]\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       0 = degree p \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "then"], ["proof (chain)\npicking this:\n  p = [:a:]", "show ?case"], ["proof (prove)\nusing this:\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. changes_poly_pos_inf (pders p) = 0", "apply (cases \"a=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = [:a:]; a = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0\n 2. \\<lbrakk>p = [:a:]; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "by (auto simp:changes_poly_pos_inf_def pders.simps)"], ["proof (state)\nthis:\n  changes_poly_pos_inf (pders p) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "case (Suc x)"], ["proof (state)\nthis:\n  x = degree ?p \\<Longrightarrow> changes_poly_pos_inf (pders ?p) = 0\n  Suc x = degree p\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "then"], ["proof (chain)\npicking this:\n  x = degree ?p \\<Longrightarrow> changes_poly_pos_inf (pders ?p) = 0\n  Suc x = degree p", "have \"pderiv p\\<noteq>0\" \"p\\<noteq>0\""], ["proof (prove)\nusing this:\n  x = degree ?p \\<Longrightarrow> changes_poly_pos_inf (pders ?p) = 0\n  Suc x = degree p\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 &&& p \\<noteq> 0", "using pderiv_eq_0_iff"], ["proof (prove)\nusing this:\n  x = degree ?p \\<Longrightarrow> changes_poly_pos_inf (pders ?p) = 0\n  Suc x = degree p\n  (pderiv ?p = 0) = (degree ?p = 0)\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 &&& p \\<noteq> 0", "by force+"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "define ps where \"ps=pders (pderiv (pderiv p))\""], ["proof (state)\nthis:\n  ps = pders (pderiv (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "have ps:\"pders p = p# pderiv p #ps\" \"pders (pderiv p) = pderiv p#ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pders p = p # pderiv p # ps &&& pders (pderiv p) = pderiv p # ps", "unfolding ps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pders p = p # pderiv p # pders (pderiv (pderiv p)) &&&\n    pders (pderiv p) = pderiv p # pders (pderiv (pderiv p))", "by (simp_all add: \\<open>p \\<noteq> 0\\<close> \\<open>pderiv p \\<noteq> 0\\<close> pders.simps)"], ["proof (state)\nthis:\n  pders p = p # pderiv p # ps\n  pders (pderiv p) = pderiv p # ps\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "have hyps:\"changes_poly_pos_inf (pders (pderiv p)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_pos_inf (pders (pderiv p)) = 0", "apply (rule Suc(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = degree (pderiv p)", "using \\<open>Suc x = degree p\\<close>"], ["proof (prove)\nusing this:\n  Suc x = degree p\n\ngoal (1 subgoal):\n 1. x = degree (pderiv p)", "by (metis degree_pderiv diff_Suc_1)"], ["proof (state)\nthis:\n  changes_poly_pos_inf (pders (pderiv p)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "moreover"], ["proof (state)\nthis:\n  changes_poly_pos_inf (pders (pderiv p)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "have \"sgn_pos_inf p * sgn_pos_inf (pderiv p) >0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sgn_pos_inf p * sgn_pos_inf (pderiv p)", "unfolding sgn_pos_inf_def lead_coeff_pderiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sgn (lead_coeff p) * sgn (real (degree p) * lead_coeff p)", "apply (simp add:algebra_simps sgn_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow> 0 < degree p) \\<and> p \\<noteq> 0", "using Suc.hyps(2) \\<open>p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  Suc x = degree p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow> 0 < degree p) \\<and> p \\<noteq> 0", "by linarith"], ["proof (state)\nthis:\n  0 < sgn_pos_inf p * sgn_pos_inf (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_pos_inf (pders p) = 0;\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_pos_inf (pders p) = 0", "ultimately"], ["proof (chain)\npicking this:\n  changes_poly_pos_inf (pders (pderiv p)) = 0\n  0 < sgn_pos_inf p * sgn_pos_inf (pderiv p)", "show ?case"], ["proof (prove)\nusing this:\n  changes_poly_pos_inf (pders (pderiv p)) = 0\n  0 < sgn_pos_inf p * sgn_pos_inf (pderiv p)\n\ngoal (1 subgoal):\n 1. changes_poly_pos_inf (pders p) = 0", "unfolding changes_poly_pos_inf_def ps"], ["proof (prove)\nusing this:\n  changes (map sgn_pos_inf (pderiv p # ps)) = 0\n  0 < sgn_pos_inf p * sgn_pos_inf (pderiv p)\n\ngoal (1 subgoal):\n 1. changes (map sgn_pos_inf (p # pderiv p # ps)) = 0", "by auto"], ["proof (state)\nthis:\n  changes_poly_pos_inf (pders p) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma changes_poly_neg_inf_pders[simp]: \"changes_poly_neg_inf (pders p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_neg_inf (pders p) = int (degree p)", "proof (induct \"degree p\" arbitrary:p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       0 = degree p \\<Longrightarrow>\n       changes_poly_neg_inf (pders p) = int (degree p)\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "case 0"], ["proof (state)\nthis:\n  0 = degree p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       0 = degree p \\<Longrightarrow>\n       changes_poly_neg_inf (pders p) = int (degree p)\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "then"], ["proof (chain)\npicking this:\n  0 = degree p", "obtain a where \"p=[:a:]\""], ["proof (prove)\nusing this:\n  0 = degree p\n\ngoal (1 subgoal):\n 1. (\\<And>a. p = [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using degree_eq_zeroE"], ["proof (prove)\nusing this:\n  0 = degree p\n  \\<lbrakk>degree ?p = 0;\n   \\<And>a. ?p = [:a:] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a. p = [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = [:a:]\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       0 = degree p \\<Longrightarrow>\n       changes_poly_neg_inf (pders p) = int (degree p)\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "then"], ["proof (chain)\npicking this:\n  p = [:a:]", "show ?case"], ["proof (prove)\nusing this:\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. changes_poly_neg_inf (pders p) = int (degree p)", "unfolding changes_poly_neg_inf_def"], ["proof (prove)\nusing this:\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. changes (map sgn_neg_inf (pders p)) = int (degree p)", "by (auto simp: pders.simps)"], ["proof (state)\nthis:\n  changes_poly_neg_inf (pders p) = int (degree p)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "case (Suc x)"], ["proof (state)\nthis:\n  x = degree ?p \\<Longrightarrow>\n  changes_poly_neg_inf (pders ?p) = int (degree ?p)\n  Suc x = degree p\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "then"], ["proof (chain)\npicking this:\n  x = degree ?p \\<Longrightarrow>\n  changes_poly_neg_inf (pders ?p) = int (degree ?p)\n  Suc x = degree p", "have \"pderiv p\\<noteq>0\" \"p\\<noteq>0\""], ["proof (prove)\nusing this:\n  x = degree ?p \\<Longrightarrow>\n  changes_poly_neg_inf (pders ?p) = int (degree ?p)\n  Suc x = degree p\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 &&& p \\<noteq> 0", "using pderiv_eq_0_iff"], ["proof (prove)\nusing this:\n  x = degree ?p \\<Longrightarrow>\n  changes_poly_neg_inf (pders ?p) = int (degree ?p)\n  Suc x = degree p\n  (pderiv ?p = 0) = (degree ?p = 0)\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 &&& p \\<noteq> 0", "by force+"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "then"], ["proof (chain)\npicking this:\n  pderiv p \\<noteq> 0\n  p \\<noteq> 0", "have \"changes_poly_neg_inf (pders p)   \n                  = changes_poly_neg_inf (p # pderiv p#pders (pderiv (pderiv p)))\""], ["proof (prove)\nusing this:\n  pderiv p \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_neg_inf (pders p) =\n    changes_poly_neg_inf (p # pderiv p # pders (pderiv (pderiv p)))", "by (simp add:pders.simps)"], ["proof (state)\nthis:\n  changes_poly_neg_inf (pders p) =\n  changes_poly_neg_inf (p # pderiv p # pders (pderiv (pderiv p)))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "also"], ["proof (state)\nthis:\n  changes_poly_neg_inf (pders p) =\n  changes_poly_neg_inf (p # pderiv p # pders (pderiv (pderiv p)))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "have \"... = 1 +  changes_poly_neg_inf (pderiv p#pders (pderiv (pderiv p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_neg_inf (p # pderiv p # pders (pderiv (pderiv p))) =\n    1 + changes_poly_neg_inf (pderiv p # pders (pderiv (pderiv p)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_neg_inf (p # pderiv p # pders (pderiv (pderiv p))) =\n    1 + changes_poly_neg_inf (pderiv p # pders (pderiv (pderiv p)))", "have \"sgn_neg_inf p * sgn_neg_inf (pderiv p) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn_neg_inf p * sgn_neg_inf (pderiv p) < 0", "unfolding sgn_neg_inf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (degree p) then sgn (lead_coeff p) else - sgn (lead_coeff p)) *\n    (if even (degree (pderiv p)) then sgn (lead_coeff (pderiv p))\n     else - sgn (lead_coeff (pderiv p)))\n    < 0", "using \\<open>p\\<noteq>0\\<close> \\<open>pderiv p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if even (degree p) then sgn (lead_coeff p) else - sgn (lead_coeff p)) *\n    (if even (degree (pderiv p)) then sgn (lead_coeff (pderiv p))\n     else - sgn (lead_coeff (pderiv p)))\n    < 0", "by (auto simp add:lead_coeff_pderiv degree_pderiv coeff_pderiv sgn_mult pderiv_eq_0_iff)"], ["proof (state)\nthis:\n  sgn_neg_inf p * sgn_neg_inf (pderiv p) < 0\n\ngoal (1 subgoal):\n 1. changes_poly_neg_inf (p # pderiv p # pders (pderiv (pderiv p))) =\n    1 + changes_poly_neg_inf (pderiv p # pders (pderiv (pderiv p)))", "then"], ["proof (chain)\npicking this:\n  sgn_neg_inf p * sgn_neg_inf (pderiv p) < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  sgn_neg_inf p * sgn_neg_inf (pderiv p) < 0\n\ngoal (1 subgoal):\n 1. changes_poly_neg_inf (p # pderiv p # pders (pderiv (pderiv p))) =\n    1 + changes_poly_neg_inf (pderiv p # pders (pderiv (pderiv p)))", "unfolding changes_poly_neg_inf_def"], ["proof (prove)\nusing this:\n  sgn_neg_inf p * sgn_neg_inf (pderiv p) < 0\n\ngoal (1 subgoal):\n 1. changes (map sgn_neg_inf (p # pderiv p # pders (pderiv (pderiv p)))) =\n    1 + changes (map sgn_neg_inf (pderiv p # pders (pderiv (pderiv p))))", "by auto"], ["proof (state)\nthis:\n  changes_poly_neg_inf (p # pderiv p # pders (pderiv (pderiv p))) =\n  1 + changes_poly_neg_inf (pderiv p # pders (pderiv (pderiv p)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_poly_neg_inf (p # pderiv p # pders (pderiv (pderiv p))) =\n  1 + changes_poly_neg_inf (pderiv p # pders (pderiv (pderiv p)))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "also"], ["proof (state)\nthis:\n  changes_poly_neg_inf (p # pderiv p # pders (pderiv (pderiv p))) =\n  1 + changes_poly_neg_inf (pderiv p # pders (pderiv (pderiv p)))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "have \"... = 1 +  changes_poly_neg_inf (pders (pderiv p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + changes_poly_neg_inf (pderiv p # pders (pderiv (pderiv p))) =\n    1 + changes_poly_neg_inf (pders (pderiv p))", "using \\<open>pderiv p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 + changes_poly_neg_inf (pderiv p # pders (pderiv (pderiv p))) =\n    1 + changes_poly_neg_inf (pders (pderiv p))", "by (simp add:pders.simps)"], ["proof (state)\nthis:\n  1 + changes_poly_neg_inf (pderiv p # pders (pderiv (pderiv p))) =\n  1 + changes_poly_neg_inf (pders (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "also"], ["proof (state)\nthis:\n  1 + changes_poly_neg_inf (pderiv p # pders (pderiv (pderiv p))) =\n  1 + changes_poly_neg_inf (pders (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "have \"... = 1 + degree (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + changes_poly_neg_inf (pders (pderiv p)) =\n    int (1 + degree (pderiv p))", "apply (subst Suc(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = degree (pderiv p)\n 2. 1 + int (degree (pderiv p)) = int (1 + degree (pderiv p))", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc x = degree p\n\ngoal (2 subgoals):\n 1. x = degree (pderiv p)\n 2. 1 + int (degree (pderiv p)) = int (1 + degree (pderiv p))", "by (auto simp add: degree_pderiv)"], ["proof (state)\nthis:\n  1 + changes_poly_neg_inf (pders (pderiv p)) = int (1 + degree (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "also"], ["proof (state)\nthis:\n  1 + changes_poly_neg_inf (pders (pderiv p)) = int (1 + degree (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "have \"... = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (1 + degree (pderiv p)) = int (degree p)", "by (metis Suc.hyps(2) degree_pderiv diff_Suc_1 plus_1_eq_Suc)"], ["proof (state)\nthis:\n  int (1 + degree (pderiv p)) = int (degree p)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   changes_poly_neg_inf (pders p) = int (degree p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> changes_poly_neg_inf (pders p) = int (degree p)", "finally"], ["proof (chain)\npicking this:\n  changes_poly_neg_inf (pders p) = int (degree p)", "show ?case"], ["proof (prove)\nusing this:\n  changes_poly_neg_inf (pders p) = int (degree p)\n\ngoal (1 subgoal):\n 1. changes_poly_neg_inf (pders p) = int (degree p)", "."], ["proof (state)\nthis:\n  changes_poly_neg_inf (pders p) = int (degree p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pders_coeffs_sgn_eq:\"map (\\<lambda>p. sgn(poly p 0)) (pders p) = map sgn (coeffs p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p 0)) (pders p) = map sgn (coeffs p)", "proof (induct \"degree p\" arbitrary:p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       0 = degree p \\<Longrightarrow>\n       map (\\<lambda>p. sgn (poly p 0)) (pders p) = map sgn (coeffs p)\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "case 0"], ["proof (state)\nthis:\n  0 = degree p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       0 = degree p \\<Longrightarrow>\n       map (\\<lambda>p. sgn (poly p 0)) (pders p) = map sgn (coeffs p)\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "then"], ["proof (chain)\npicking this:\n  0 = degree p", "obtain a where \"p=[:a:]\""], ["proof (prove)\nusing this:\n  0 = degree p\n\ngoal (1 subgoal):\n 1. (\\<And>a. p = [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using degree_eq_zeroE"], ["proof (prove)\nusing this:\n  0 = degree p\n  \\<lbrakk>degree ?p = 0;\n   \\<And>a. ?p = [:a:] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a. p = [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = [:a:]\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       0 = degree p \\<Longrightarrow>\n       map (\\<lambda>p. sgn (poly p 0)) (pders p) = map sgn (coeffs p)\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "then"], ["proof (chain)\npicking this:\n  p = [:a:]", "show ?case"], ["proof (prove)\nusing this:\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p 0)) (pders p) = map sgn (coeffs p)", "by (auto simp: pders.simps)"], ["proof (state)\nthis:\n  map (\\<lambda>p. sgn (poly p 0)) (pders p) = map sgn (coeffs p)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "case (Suc x)"], ["proof (state)\nthis:\n  x = degree ?p \\<Longrightarrow>\n  map (\\<lambda>p. sgn (poly p 0)) (pders ?p) = map sgn (coeffs ?p)\n  Suc x = degree p\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "then"], ["proof (chain)\npicking this:\n  x = degree ?p \\<Longrightarrow>\n  map (\\<lambda>p. sgn (poly p 0)) (pders ?p) = map sgn (coeffs ?p)\n  Suc x = degree p", "have \"pderiv p\\<noteq>0\" \"p\\<noteq>0\""], ["proof (prove)\nusing this:\n  x = degree ?p \\<Longrightarrow>\n  map (\\<lambda>p. sgn (poly p 0)) (pders ?p) = map sgn (coeffs ?p)\n  Suc x = degree p\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 &&& p \\<noteq> 0", "using pderiv_eq_0_iff"], ["proof (prove)\nusing this:\n  x = degree ?p \\<Longrightarrow>\n  map (\\<lambda>p. sgn (poly p 0)) (pders ?p) = map sgn (coeffs ?p)\n  Suc x = degree p\n  (pderiv ?p = 0) = (degree ?p = 0)\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0 &&& p \\<noteq> 0", "by force+"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "have \"map (\\<lambda>p. sgn (poly p 0)) (pders p)  \n          = sgn (poly p 0)# map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n    sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p))", "apply (subst pders.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p 0))\n     (if p = 0 then [] else p # pders (pderiv p)) =\n    sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p))", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p 0))\n     (if p = 0 then [] else p # pders (pderiv p)) =\n    sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p))", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n  sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "also"], ["proof (state)\nthis:\n  map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n  sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "have \"... = sgn (coeff p 0) # map sgn (coeffs (pderiv p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p)) =\n    sgn (coeff p 0) # map sgn (coeffs (pderiv p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p)) =\n    sgn (coeff p 0) # map sgn (coeffs (pderiv p))", "have \"sgn (poly p 0) = sgn (coeff p 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly p 0) = sgn (coeff p 0)", "by (simp add: poly_0_coeff_0)"], ["proof (state)\nthis:\n  sgn (poly p 0) = sgn (coeff p 0)\n\ngoal (1 subgoal):\n 1. sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p)) =\n    sgn (coeff p 0) # map sgn (coeffs (pderiv p))", "then"], ["proof (chain)\npicking this:\n  sgn (poly p 0) = sgn (coeff p 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  sgn (poly p 0) = sgn (coeff p 0)\n\ngoal (1 subgoal):\n 1. sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p)) =\n    sgn (coeff p 0) # map sgn (coeffs (pderiv p))", "apply (subst Suc(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. sgn (poly p 0) = sgn (coeff p 0) \\<Longrightarrow> x = degree (pderiv p)\n 2. sgn (poly p 0) = sgn (coeff p 0) \\<Longrightarrow>\n    sgn (poly p 0) # map sgn (coeffs (pderiv p)) =\n    sgn (coeff p 0) # map sgn (coeffs (pderiv p))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly p 0) = sgn (coeff p 0) \\<Longrightarrow> x = degree (pderiv p)", "by (metis Suc.hyps(2) degree_pderiv diff_Suc_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly p 0) = sgn (coeff p 0) \\<Longrightarrow>\n    sgn (poly p 0) # map sgn (coeffs (pderiv p)) =\n    sgn (coeff p 0) # map sgn (coeffs (pderiv p))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly p 0) = sgn (coeff p 0) \\<Longrightarrow>\n    sgn (poly p 0) # map sgn (coeffs (pderiv p)) =\n    sgn (coeff p 0) # map sgn (coeffs (pderiv p))", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p)) =\n  sgn (coeff p 0) # map sgn (coeffs (pderiv p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p)) =\n  sgn (coeff p 0) # map sgn (coeffs (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "also"], ["proof (state)\nthis:\n  sgn (poly p 0) # map (\\<lambda>p. sgn (poly p 0)) (pders (pderiv p)) =\n  sgn (coeff p 0) # map sgn (coeffs (pderiv p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "have \"... =  map sgn (coeffs p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (coeff p 0) # map sgn (coeffs (pderiv p)) = map sgn (coeffs p)", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) =\n    length (map sgn (coeffs p))\n 2. \\<And>i.\n       i < length\n            (sgn (coeff p 0) #\n             map sgn (coeffs (pderiv p))) \\<Longrightarrow>\n       (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n       map sgn (coeffs p) ! i", "show p_length:\"length (sgn (coeff p 0) # map sgn (coeffs (pderiv p)))\n                         = length (map sgn (coeffs p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) =\n    length (map sgn (coeffs p))", "by (metis Suc.hyps(2) \\<open>p \\<noteq> 0\\<close> \\<open>pderiv p \\<noteq> 0\\<close> degree_pderiv diff_Suc_1 length_Cons \n          length_coeffs_degree length_map)"], ["proof (state)\nthis:\n  length (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) =\n  length (map sgn (coeffs p))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (sgn (coeff p 0) #\n             map sgn (coeffs (pderiv p))) \\<Longrightarrow>\n       (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n       map sgn (coeffs p) ! i", "show \"(sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i = map sgn (coeffs p) ! i\"\n      if \"i < length (sgn (coeff p 0) # map sgn (coeffs (pderiv p)))\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n    map sgn (coeffs p) ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n    map sgn (coeffs p) ! i", "show \"(sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i = map sgn (coeffs p) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n    map sgn (coeffs p) ! i", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n    map sgn (coeffs p) ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n       map sgn (coeffs p) ! i", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n    map sgn (coeffs p) ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n       map sgn (coeffs p) ! i", "then"], ["proof (chain)\npicking this:\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n    map sgn (coeffs p) ! i", "by (simp add: \\<open>p \\<noteq> 0\\<close> coeffs_nth)"], ["proof (state)\nthis:\n  (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n  map sgn (coeffs p) ! i\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n       map sgn (coeffs p) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n       map sgn (coeffs p) ! i", "case (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n       map sgn (coeffs p) ! i", "then"], ["proof (chain)\npicking this:\n  i = Suc i'", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n    map sgn (coeffs p) ! i", "using that p_length"], ["proof (prove)\nusing this:\n  i = Suc i'\n  i < length (sgn (coeff p 0) # map sgn (coeffs (pderiv p)))\n  length (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) =\n  length (map sgn (coeffs p))\n\ngoal (1 subgoal):\n 1. (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n    map sgn (coeffs p) ! i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = Suc i'; i' < length (coeffs (pderiv p));\n     Suc (length (coeffs (pderiv p))) = length (coeffs p)\\<rbrakk>\n    \\<Longrightarrow> sgn (coeffs (pderiv p) ! i') = sgn (coeffs p ! Suc i')", "apply (subst (1 2) coeffs_nth)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>i = Suc i'; i' < length (coeffs (pderiv p));\n     Suc (length (coeffs (pderiv p))) = length (coeffs p)\\<rbrakk>\n    \\<Longrightarrow> p \\<noteq> 0\n 2. \\<lbrakk>i = Suc i'; i' < length (coeffs (pderiv p));\n     Suc (length (coeffs (pderiv p))) = length (coeffs p)\\<rbrakk>\n    \\<Longrightarrow> Suc i' \\<le> degree p\n 3. \\<lbrakk>i = Suc i'; i' < length (coeffs (pderiv p));\n     Suc (length (coeffs (pderiv p))) = length (coeffs p)\\<rbrakk>\n    \\<Longrightarrow> pderiv p \\<noteq> 0\n 4. \\<lbrakk>i = Suc i'; i' < length (coeffs (pderiv p));\n     Suc (length (coeffs (pderiv p))) = length (coeffs p)\\<rbrakk>\n    \\<Longrightarrow> i' \\<le> degree (pderiv p)\n 5. \\<lbrakk>i = Suc i'; i' < length (coeffs (pderiv p));\n     Suc (length (coeffs (pderiv p))) = length (coeffs p)\\<rbrakk>\n    \\<Longrightarrow> sgn (coeff (pderiv p) i') = sgn (coeff p (Suc i'))", "by (auto simp add: \\<open>p \\<noteq> 0\\<close> \\<open>pderiv p \\<noteq> 0\\<close> length_coeffs_degree coeff_pderiv sgn_mult)"], ["proof (state)\nthis:\n  (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n  map sgn (coeffs p) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! i =\n  map sgn (coeffs p) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length\n        (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) \\<Longrightarrow>\n  (sgn (coeff p 0) # map sgn (coeffs (pderiv p))) ! ?i =\n  map sgn (coeffs p) ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn (coeff p 0) # map sgn (coeffs (pderiv p)) = map sgn (coeffs p)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   x = degree p \\<Longrightarrow>\n                   map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                   map sgn (coeffs p);\n        Suc x = degree p\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>p. sgn (poly p 0)) (pders p) =\n                         map sgn (coeffs p)", "finally"], ["proof (chain)\npicking this:\n  map (\\<lambda>p. sgn (poly p 0)) (pders p) = map sgn (coeffs p)", "show ?case"], ["proof (prove)\nusing this:\n  map (\\<lambda>p. sgn (poly p 0)) (pders p) = map sgn (coeffs p)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>p. sgn (poly p 0)) (pders p) = map sgn (coeffs p)", "."], ["proof (state)\nthis:\n  map (\\<lambda>p. sgn (poly p 0)) (pders p) = map sgn (coeffs p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma changes_poly_at_pders_0:\"changes_poly_at (pders p) 0 = changes (coeffs p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) 0 = changes (coeffs p)", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p 0) (pders p)) = changes (coeffs p)", "apply (subst (1 2) changes_map_sgn_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map sgn (map (\\<lambda>p. poly p 0) (pders p))) =\n    changes (map sgn (coeffs p))", "by (auto simp add:pders_coeffs_sgn_eq comp_def)"], ["", "subsection \\<open>Budan-Fourier theorem\\<close>"], ["", "lemma budan_fourier_aux_right:\n  assumes \"c<d2\" and \"p\\<noteq>0\"\n  assumes \"\\<forall>x. c<x\\<and> x\\<le>d2 \\<longrightarrow> (\\<forall>q\\<in>set (pders p). poly q x\\<noteq>0)\"  \n  shows \"changes_itv_der c d2 p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "using assms(2-3)"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<forall>x.\n     c < x \\<and> x \\<le> d2 \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "proof (induct \"degree p\" arbitrary:p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "case 0"], ["proof (state)\nthis:\n  0 = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     c < x \\<and> x \\<le> d2 \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "then"], ["proof (chain)\npicking this:\n  0 = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     c < x \\<and> x \\<le> d2 \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "obtain a where \"p=[:a:]\" \"a\\<noteq>0\""], ["proof (prove)\nusing this:\n  0 = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     c < x \\<and> x \\<le> d2 \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>p = [:a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis degree_eq_zeroE pCons_0_0)"], ["proof (state)\nthis:\n  p = [:a:]\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "then"], ["proof (chain)\npicking this:\n  p = [:a:]\n  a \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  p = [:a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "by (auto simp add:changes_itv_der_def pders.simps intro:order_0I)"], ["proof (state)\nthis:\n  changes_itv_der c d2 p = 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = degree ?p; ?p \\<noteq> 0;\n   \\<forall>x.\n      c < x \\<and> x \\<le> d2 \\<longrightarrow>\n      (\\<forall>q\\<in>set (pders ?p). poly q x \\<noteq> 0)\\<rbrakk>\n  \\<Longrightarrow> changes_itv_der c d2 ?p = 0\n  Suc n = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     c < x \\<and> x \\<le> d2 \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = degree ?p; ?p \\<noteq> 0;\n   \\<forall>x.\n      c < x \\<and> x \\<le> d2 \\<longrightarrow>\n      (\\<forall>q\\<in>set (pders ?p). poly q x \\<noteq> 0)\\<rbrakk>\n  \\<Longrightarrow> changes_itv_der c d2 ?p = 0\n  Suc n = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     c < x \\<and> x \\<le> d2 \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "have [simp]:\"pderiv p\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = degree ?p; ?p \\<noteq> 0;\n   \\<forall>x.\n      c < x \\<and> x \\<le> d2 \\<longrightarrow>\n      (\\<forall>q\\<in>set (pders ?p). poly q x \\<noteq> 0)\\<rbrakk>\n  \\<Longrightarrow> changes_itv_der c d2 ?p = 0\n  Suc n = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     c < x \\<and> x \\<le> d2 \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "by (metis nat.distinct(1) pderiv_eq_0_iff)"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "note nzero=\\<open>\\<forall>x. c < x \\<and> x \\<le> d2 \\<longrightarrow> (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<close>"], ["proof (state)\nthis:\n  \\<forall>x.\n     c < x \\<and> x \\<le> d2 \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "have hyps:\"changes_itv_der c d2 (pderiv p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_der c d2 (pderiv p) = 0", "apply (rule Suc(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. n = degree (pderiv p)\n 2. pderiv p \\<noteq> 0\n 3. \\<forall>x.\n       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders (pderiv p)). poly q x \\<noteq> 0)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = degree (pderiv p)", "by (metis Suc.hyps(2) degree_pderiv diff_Suc_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. \\<forall>x.\n       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders (pderiv p)). poly q x \\<noteq> 0)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "by (simp add: Suc.prems(1) Suc.prems(2) pders.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders (pderiv p)). poly q x \\<noteq> 0)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders (pderiv p)). poly q x \\<noteq> 0)", "by (simp add: Suc.prems(1) nzero pders.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  changes_itv_der c d2 (pderiv p) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "have pders_changes_c:\"changes_poly_at (r# pders q) c = (if sign_r_pos q c \\<longleftrightarrow> poly r c>0\n          then changes_poly_at (pders q) c else 1+changes_poly_at (pders q) c)\"\n    when \"poly r c\\<noteq>0\" \"q\\<noteq>0\" for q r"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "proof (induct q rule:pders.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> changes_poly_at (r # pders (pderiv p)) c =\n                                  (if sign_r_pos (pderiv p) c =\n(0 < poly r c)\n                                   then changes_poly_at (pders (pderiv p)) c\n                                   else 1 +\n  changes_poly_at (pders (pderiv p)) c);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (r # pders p) c =\n                         (if sign_r_pos p c = (0 < poly r c)\n                          then changes_poly_at (pders p) c\n                          else 1 + changes_poly_at (pders p) c)", "case (1 q)"], ["proof (state)\nthis:\n  \\<lbrakk>q \\<noteq> 0; pderiv q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (r # pders (pderiv q)) c =\n                    (if sign_r_pos (pderiv q) c = (0 < poly r c)\n                     then changes_poly_at (pders (pderiv q)) c\n                     else 1 + changes_poly_at (pders (pderiv q)) c)\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> changes_poly_at (r # pders (pderiv p)) c =\n                                  (if sign_r_pos (pderiv p) c =\n(0 < poly r c)\n                                   then changes_poly_at (pders (pderiv p)) c\n                                   else 1 +\n  changes_poly_at (pders (pderiv p)) c);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (r # pders p) c =\n                         (if sign_r_pos p c = (0 < poly r c)\n                          then changes_poly_at (pders p) c\n                          else 1 + changes_poly_at (pders p) c)", "have ?case when \"pderiv q=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "have \"degree q=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = 0", "using that pderiv_eq_0_iff"], ["proof (prove)\nusing this:\n  pderiv q = 0\n  (pderiv ?p = 0) = (degree ?p = 0)\n\ngoal (1 subgoal):\n 1. degree q = 0", "by blast"], ["proof (state)\nthis:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "then"], ["proof (chain)\npicking this:\n  degree q = 0", "obtain a where \"q=[:a:]\" \"a\\<noteq>0\""], ["proof (prove)\nusing this:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>q = [:a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  degree q = 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>q = [:a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis degree_eq_zeroE pCons_0_0)"], ["proof (state)\nthis:\n  q = [:a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "then"], ["proof (chain)\npicking this:\n  q = [:a:]\n  a \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  q = [:a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "using \\<open>poly r c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q = [:a:]\n  a \\<noteq> 0\n  poly r c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "by (auto simp add:sign_r_pos_rec changes_poly_at_def mult_less_0_iff pders.simps)"], ["proof (state)\nthis:\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pderiv q = 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> changes_poly_at (r # pders (pderiv p)) c =\n                                  (if sign_r_pos (pderiv p) c =\n(0 < poly r c)\n                                   then changes_poly_at (pders (pderiv p)) c\n                                   else 1 +\n  changes_poly_at (pders (pderiv p)) c);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (r # pders p) c =\n                         (if sign_r_pos p c = (0 < poly r c)\n                          then changes_poly_at (pders p) c\n                          else 1 + changes_poly_at (pders p) c)", "moreover"], ["proof (state)\nthis:\n  pderiv q = 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> changes_poly_at (r # pders (pderiv p)) c =\n                                  (if sign_r_pos (pderiv p) c =\n(0 < poly r c)\n                                   then changes_poly_at (pders (pderiv p)) c\n                                   else 1 +\n  changes_poly_at (pders (pderiv p)) c);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (r # pders p) c =\n                         (if sign_r_pos p c = (0 < poly r c)\n                          then changes_poly_at (pders p) c\n                          else 1 + changes_poly_at (pders p) c)", "have ?case when \"pderiv q\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "obtain qs where qs:\"pders q=q#qs\" \"pders (pderiv q) = qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>pders q = q # qs; pders (pderiv q) = qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>pders q = q # qs; pders (pderiv q) = qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add:pders.simps)"], ["proof (state)\nthis:\n  pders q = q # qs\n  pders (pderiv q) = qs\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "have \"changes_poly_at (r # qs) c = (if sign_r_pos (pderiv q) c = (0 < poly r c) \n              then changes_poly_at qs c else 1 + changes_poly_at qs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (r # qs) c =\n    (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n     else 1 + changes_poly_at qs c)", "using 1 \\<open>pderiv q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>q \\<noteq> 0; pderiv q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (r # pders (pderiv q)) c =\n                    (if sign_r_pos (pderiv q) c = (0 < poly r c)\n                     then changes_poly_at (pders (pderiv q)) c\n                     else 1 + changes_poly_at (pders (pderiv q)) c)\n  q \\<noteq> 0\n  pderiv q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # qs) c =\n    (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n     else 1 + changes_poly_at qs c)", "unfolding qs"], ["proof (prove)\nusing this:\n  \\<lbrakk>q \\<noteq> 0; pderiv q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (r # qs) c =\n                    (if sign_r_pos (pderiv q) c = (0 < poly r c)\n                     then changes_poly_at qs c\n                     else 1 + changes_poly_at qs c)\n  q \\<noteq> 0\n  pderiv q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # qs) c =\n    (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n     else 1 + changes_poly_at qs c)", "by simp"], ["proof (state)\nthis:\n  changes_poly_at (r # qs) c =\n  (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n   else 1 + changes_poly_at qs c)\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "then"], ["proof (chain)\npicking this:\n  changes_poly_at (r # qs) c =\n  (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n   else 1 + changes_poly_at qs c)", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at (r # qs) c =\n  (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n   else 1 + changes_poly_at qs c)\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "unfolding qs"], ["proof (prove)\nusing this:\n  changes_poly_at (r # qs) c =\n  (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n   else 1 + changes_poly_at qs c)\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # q # qs) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (q # qs) c\n     else 1 + changes_poly_at (q # qs) c)", "apply (cases \"poly q c=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>changes_poly_at (r # qs) c =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes_poly_at qs c else 1 + changes_poly_at qs c);\n     poly q c = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (r # q # qs) c =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes_poly_at (q # qs) c\n                       else 1 + changes_poly_at (q # qs) c)\n 2. \\<lbrakk>changes_poly_at (r # qs) c =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes_poly_at qs c else 1 + changes_poly_at qs c);\n     poly q c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (r # q # qs) c =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes_poly_at (q # qs) c\n                       else 1 + changes_poly_at (q # qs) c)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes_poly_at (r # qs) c =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes_poly_at qs c else 1 + changes_poly_at qs c);\n     poly q c = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (r # q # qs) c =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes_poly_at (q # qs) c\n                       else 1 + changes_poly_at (q # qs) c)", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes (map (\\<lambda>p. poly p c) (r # qs)) =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes (map (\\<lambda>p. poly p c) qs)\n              else 1 + changes (map (\\<lambda>p. poly p c) qs));\n     poly q c = 0\\<rbrakk>\n    \\<Longrightarrow> changes (map (\\<lambda>p. poly p c) (r # q # qs)) =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes (map (\\<lambda>p. poly p c) (q # qs))\n                       else 1 +\n                            changes (map (\\<lambda>p. poly p c) (q # qs)))", "by (auto simp:sign_r_pos_rec[OF \\<open>q\\<noteq>0\\<close>,of c])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes_poly_at (r # qs) c =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes_poly_at qs c else 1 + changes_poly_at qs c);\n     poly q c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (r # q # qs) c =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes_poly_at (q # qs) c\n                       else 1 + changes_poly_at (q # qs) c)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes_poly_at (r # qs) c =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes_poly_at qs c else 1 + changes_poly_at qs c);\n     poly q c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (r # q # qs) c =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes_poly_at (q # qs) c\n                       else 1 + changes_poly_at (q # qs) c)", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes (map (\\<lambda>p. poly p c) (r # qs)) =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes (map (\\<lambda>p. poly p c) qs)\n              else 1 + changes (map (\\<lambda>p. poly p c) qs));\n     poly q c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes (map (\\<lambda>p. poly p c) (r # q # qs)) =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes (map (\\<lambda>p. poly p c) (q # qs))\n                       else 1 +\n                            changes (map (\\<lambda>p. poly p c) (q # qs)))", "using \\<open>poly r c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly r c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>changes (map (\\<lambda>p. poly p c) (r # qs)) =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes (map (\\<lambda>p. poly p c) qs)\n              else 1 + changes (map (\\<lambda>p. poly p c) qs));\n     poly q c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes (map (\\<lambda>p. poly p c) (r # q # qs)) =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes (map (\\<lambda>p. poly p c) (q # qs))\n                       else 1 +\n                            changes (map (\\<lambda>p. poly p c) (q # qs)))", "by (auto simp:sign_r_pos_rec[OF \\<open>q\\<noteq>0\\<close>,of c] mult_less_0_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pderiv q \\<noteq> 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> changes_poly_at (r # pders (pderiv p)) c =\n                                  (if sign_r_pos (pderiv p) c =\n(0 < poly r c)\n                                   then changes_poly_at (pders (pderiv p)) c\n                                   else 1 +\n  changes_poly_at (pders (pderiv p)) c);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (r # pders p) c =\n                         (if sign_r_pos p c = (0 < poly r c)\n                          then changes_poly_at (pders p) c\n                          else 1 + changes_poly_at (pders p) c)", "ultimately"], ["proof (chain)\npicking this:\n  pderiv q = 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n  pderiv q \\<noteq> 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)", "show ?case"], ["proof (prove)\nusing this:\n  pderiv q = 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n  pderiv q \\<noteq> 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "by blast"], ["proof (state)\nthis:\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly ?r c \\<noteq> 0; ?q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (?r # pders ?q) c =\n                    (if sign_r_pos ?q c = (0 < poly ?r c)\n                     then changes_poly_at (pders ?q) c\n                     else 1 + changes_poly_at (pders ?q) c)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "have pders_changes_d2:\"changes_poly_at (r# pders q) d2 = (if sign_r_pos q c \\<longleftrightarrow> poly r c>0\n          then changes_poly_at (pders q) d2 else 1+changes_poly_at (pders q) d2)\"\n    when \"poly r c\\<noteq>0\" \"q\\<noteq>0\" and qr_nzero:\"\\<forall>x. c < x \\<and> x \\<le> d2 \\<longrightarrow> poly r x \\<noteq> 0 \\<and> poly q x\\<noteq>0\" \n    for q r"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d2 =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) d2\n     else 1 + changes_poly_at (pders q) d2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d2 =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) d2\n     else 1 + changes_poly_at (pders q) d2)", "have \"r\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "using that(1)"], ["proof (prove)\nusing this:\n  poly r c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "using poly_0"], ["proof (prove)\nusing this:\n  poly r c \\<noteq> 0\n  poly 0 ?x = (0::?'a)\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d2 =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) d2\n     else 1 + changes_poly_at (pders q) d2)", "obtain qs where qs:\"pders q=q#qs\" \"pders (pderiv q) = qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>pders q = q # qs; pders (pderiv q) = qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>pders q = q # qs; pders (pderiv q) = qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add:pders.simps)"], ["proof (state)\nthis:\n  pders q = q # qs\n  pders (pderiv q) = qs\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d2 =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) d2\n     else 1 + changes_poly_at (pders q) d2)", "have \"if sign_r_pos r c then 0 < poly r d2 else poly r d2 < 0\"\n      \"if sign_r_pos q c then 0 < poly q d2 else poly q d2 < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if sign_r_pos r c then 0 < poly r d2 else poly r d2 < 0 &&&\n    if sign_r_pos q c then 0 < poly q d2 else poly q d2 < 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. if sign_r_pos r c then 0 < poly r d2 else poly r d2 < 0", "by (rule sign_r_pos_nzero_right[of c d2 r]) (use qr_nzero \\<open>c<d2\\<close> in auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. if sign_r_pos q c then 0 < poly q d2 else poly q d2 < 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. if sign_r_pos q c then 0 < poly q d2 else poly q d2 < 0", "by (rule sign_r_pos_nzero_right[of c d2 q]) (use qr_nzero \\<open>c<d2\\<close> in auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  if sign_r_pos r c then 0 < poly r d2 else poly r d2 < 0\n  if sign_r_pos q c then 0 < poly q d2 else poly q d2 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d2 =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) d2\n     else 1 + changes_poly_at (pders q) d2)", "then"], ["proof (chain)\npicking this:\n  if sign_r_pos r c then 0 < poly r d2 else poly r d2 < 0\n  if sign_r_pos q c then 0 < poly q d2 else poly q d2 < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  if sign_r_pos r c then 0 < poly r d2 else poly r d2 < 0\n  if sign_r_pos q c then 0 < poly q d2 else poly q d2 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d2 =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) d2\n     else 1 + changes_poly_at (pders q) d2)", "unfolding qs changes_poly_at_def"], ["proof (prove)\nusing this:\n  if sign_r_pos r c then 0 < poly r d2 else poly r d2 < 0\n  if sign_r_pos q c then 0 < poly q d2 else poly q d2 < 0\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p d2) (r # q # qs)) =\n    (if sign_r_pos q c = (0 < poly r c)\n     then changes (map (\\<lambda>p. poly p d2) (q # qs))\n     else 1 + changes (map (\\<lambda>p. poly p d2) (q # qs)))", "using \\<open>poly r c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  if sign_r_pos r c then 0 < poly r d2 else poly r d2 < 0\n  if sign_r_pos q c then 0 < poly q d2 else poly q d2 < 0\n  poly r c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p d2) (r # q # qs)) =\n    (if sign_r_pos q c = (0 < poly r c)\n     then changes (map (\\<lambda>p. poly p d2) (q # qs))\n     else 1 + changes (map (\\<lambda>p. poly p d2) (q # qs)))", "by (auto split:if_splits simp:mult_less_0_iff sign_r_pos_rec[OF \\<open>r\\<noteq>0\\<close>])"], ["proof (state)\nthis:\n  changes_poly_at (r # pders q) d2 =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) d2\n   else 1 + changes_poly_at (pders q) d2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly ?r c \\<noteq> 0; ?q \\<noteq> 0;\n   \\<forall>x.\n      c < x \\<and> x \\<le> d2 \\<longrightarrow>\n      poly ?r x \\<noteq> 0 \\<and> poly ?q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (?r # pders ?q) d2 =\n                    (if sign_r_pos ?q c = (0 < poly ?r c)\n                     then changes_poly_at (pders ?q) d2\n                     else 1 + changes_poly_at (pders ?q) d2)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "have  d2c_nzero:\"\\<forall>x. c<x \\<and> x\\<le>d2 \\<longrightarrow> poly p x\\<noteq>0 \\<and> poly (pderiv p) x \\<noteq>0\"\n    and p_cons:\"pders p = p#pders(pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n       poly p x \\<noteq> 0 \\<and> poly (pderiv p) x \\<noteq> 0 &&&\n    pders p = p # pders (pderiv p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n       poly p x \\<noteq> 0 \\<and> poly (pderiv p) x \\<noteq> 0", "by (simp add: nzero Suc.prems(1) pders.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pders p = p # pders (pderiv p)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pders p = p # pders (pderiv p)", "by (simp add: Suc.prems(1) pders.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>x.\n     c < x \\<and> x \\<le> d2 \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and> poly (pderiv p) x \\<noteq> 0\n  pders p = p # pders (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "have ?case when \"poly p c=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "define ps where \"ps=pders (pderiv (pderiv p))\""], ["proof (state)\nthis:\n  ps = pders (pderiv (pderiv p))\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "have ps_cons:\"p#pderiv p#ps = pders p\" \"pderiv p#ps=pders (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p # pderiv p # ps = pders p &&& pderiv p # ps = pders (pderiv p)", "unfolding ps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p # pderiv p # pders (pderiv (pderiv p)) = pders p &&&\n    pderiv p # pders (pderiv (pderiv p)) = pders (pderiv p)", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p # pderiv p # pders (pderiv (pderiv p)) = pders p &&&\n    pderiv p # pders (pderiv (pderiv p)) = pders (pderiv p)", "by (auto simp:pders.simps)"], ["proof (state)\nthis:\n  p # pderiv p # ps = pders p\n  pderiv p # ps = pders (pderiv p)\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "have \"changes_poly_at (p # pderiv p # ps) c =  changes_poly_at (pderiv p # ps) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) c =\n    changes_poly_at (pderiv p # ps) c", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p c) (p # pderiv p # ps)) =\n    changes (map (\\<lambda>p. poly p c) (pderiv p # ps))", "using that"], ["proof (prove)\nusing this:\n  poly p c = 0\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p c) (p # pderiv p # ps)) =\n    changes (map (\\<lambda>p. poly p c) (pderiv p # ps))", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (p # pderiv p # ps) c = changes_poly_at (pderiv p # ps) c\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (p # pderiv p # ps) c = changes_poly_at (pderiv p # ps) c\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "have \"changes_poly_at (p # pderiv p # ps) d2 = changes_poly_at (pderiv p # ps) d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d2 =\n    changes_poly_at (pderiv p # ps) d2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d2 =\n    changes_poly_at (pderiv p # ps) d2", "have \"if sign_r_pos p c then 0 < poly p d2 else poly p d2 < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if sign_r_pos p c then 0 < poly p d2 else poly p d2 < 0", "apply (rule sign_r_pos_nzero_right[OF _ \\<open>c<d2\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       c < x \\<and> x \\<le> d2 \\<longrightarrow> poly p x \\<noteq> 0", "using nzero[folded ps_cons] assms(1-2)"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     c < x \\<and> x \\<le> d2 \\<longrightarrow>\n     (\\<forall>q\\<in>set (p # pderiv p # ps). poly q x \\<noteq> 0)\n  c < d2\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       c < x \\<and> x \\<le> d2 \\<longrightarrow> poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  if sign_r_pos p c then 0 < poly p d2 else poly p d2 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d2 =\n    changes_poly_at (pderiv p # ps) d2", "moreover"], ["proof (state)\nthis:\n  if sign_r_pos p c then 0 < poly p d2 else poly p d2 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d2 =\n    changes_poly_at (pderiv p # ps) d2", "have \"if sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d2 \n                     else poly (pderiv p) d2 < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d2\n    else poly (pderiv p) d2 < 0", "apply (rule sign_r_pos_nzero_right[OF _ \\<open>c<d2\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n       poly (pderiv p) x \\<noteq> 0", "using nzero[folded ps_cons] assms(1-2)"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     c < x \\<and> x \\<le> d2 \\<longrightarrow>\n     (\\<forall>q\\<in>set (p # pderiv p # ps). poly q x \\<noteq> 0)\n  c < d2\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n       poly (pderiv p) x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  if sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d2\n  else poly (pderiv p) d2 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d2 =\n    changes_poly_at (pderiv p # ps) d2", "ultimately"], ["proof (chain)\npicking this:\n  if sign_r_pos p c then 0 < poly p d2 else poly p d2 < 0\n  if sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d2\n  else poly (pderiv p) d2 < 0", "have \"poly p d2 * poly (pderiv p) d2 > 0\""], ["proof (prove)\nusing this:\n  if sign_r_pos p c then 0 < poly p d2 else poly p d2 < 0\n  if sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d2\n  else poly (pderiv p) d2 < 0\n\ngoal (1 subgoal):\n 1. 0 < poly p d2 * poly (pderiv p) d2", "unfolding zero_less_mult_iff sign_r_pos_rec[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  if if poly p c = 0 then sign_r_pos (pderiv p) c else 0 < poly p c\n  then 0 < poly p d2 else poly p d2 < 0\n  if sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d2\n  else poly (pderiv p) d2 < 0\n\ngoal (1 subgoal):\n 1. 0 < poly p d2 \\<and> 0 < poly (pderiv p) d2 \\<or>\n    poly p d2 < 0 \\<and> poly (pderiv p) d2 < 0", "using \\<open>poly p c=0\\<close>"], ["proof (prove)\nusing this:\n  if if poly p c = 0 then sign_r_pos (pderiv p) c else 0 < poly p c\n  then 0 < poly p d2 else poly p d2 < 0\n  if sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d2\n  else poly (pderiv p) d2 < 0\n  poly p c = 0\n\ngoal (1 subgoal):\n 1. 0 < poly p d2 \\<and> 0 < poly (pderiv p) d2 \\<or>\n    poly p d2 < 0 \\<and> poly (pderiv p) d2 < 0", "by (auto split:if_splits)"], ["proof (state)\nthis:\n  0 < poly p d2 * poly (pderiv p) d2\n\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d2 =\n    changes_poly_at (pderiv p # ps) d2", "then"], ["proof (chain)\npicking this:\n  0 < poly p d2 * poly (pderiv p) d2", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < poly p d2 * poly (pderiv p) d2\n\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d2 =\n    changes_poly_at (pderiv p # ps) d2", "unfolding changes_poly_at_def"], ["proof (prove)\nusing this:\n  0 < poly p d2 * poly (pderiv p) d2\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p d2) (p # pderiv p # ps)) =\n    changes (map (\\<lambda>p. poly p d2) (pderiv p # ps))", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (p # pderiv p # ps) d2 =\n  changes_poly_at (pderiv p # ps) d2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_poly_at (p # pderiv p # ps) d2 =\n  changes_poly_at (pderiv p # ps) d2\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "ultimately"], ["proof (chain)\npicking this:\n  changes_poly_at (p # pderiv p # ps) c = changes_poly_at (pderiv p # ps) c\n  changes_poly_at (p # pderiv p # ps) d2 =\n  changes_poly_at (pderiv p # ps) d2", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at (p # pderiv p # ps) c = changes_poly_at (pderiv p # ps) c\n  changes_poly_at (p # pderiv p # ps) d2 =\n  changes_poly_at (pderiv p # ps) d2\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "using hyps"], ["proof (prove)\nusing this:\n  changes_poly_at (p # pderiv p # ps) c = changes_poly_at (pderiv p # ps) c\n  changes_poly_at (p # pderiv p # ps) d2 =\n  changes_poly_at (pderiv p # ps) d2\n  changes_itv_der c d2 (pderiv p) = 0\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "unfolding changes_itv_der_def"], ["proof (prove)\nusing this:\n  changes_poly_at (p # pderiv p # ps) c = changes_poly_at (pderiv p # ps) c\n  changes_poly_at (p # pderiv p # ps) d2 =\n  changes_poly_at (pderiv p # ps) d2\n  (let ps = pders (pderiv p)\n   in changes_poly_at ps c - changes_poly_at ps d2) =\n  0\n\ngoal (1 subgoal):\n 1. (let ps = pders p in changes_poly_at ps c - changes_poly_at ps d2) = 0", "apply (fold ps_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes_poly_at (p # pderiv p # ps) c =\n             changes_poly_at (pderiv p # ps) c;\n     changes_poly_at (p # pderiv p # ps) d2 =\n     changes_poly_at (pderiv p # ps) d2;\n     (let ps = pderiv p # ps\n      in changes_poly_at ps c - changes_poly_at ps d2) =\n     0\\<rbrakk>\n    \\<Longrightarrow> (let ps = p # pderiv p # ps\n                       in changes_poly_at ps c - changes_poly_at ps d2) =\n                      0", "by (auto simp:Let_def)"], ["proof (state)\nthis:\n  changes_itv_der c d2 p = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p c = 0 \\<Longrightarrow> changes_itv_der c d2 p = 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "moreover"], ["proof (state)\nthis:\n  poly p c = 0 \\<Longrightarrow> changes_itv_der c d2 p = 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "have ?case when \"poly p c\\<noteq>0\" \"sign_r_pos (pderiv p) c \\<longleftrightarrow> poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "have \"changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) c =\n    changes_poly_at (pders (pderiv p)) c", "apply (subst pders_changes_c[OF \\<open>poly p c\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  sign_r_pos (pderiv p) c = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "have \"changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) d2 =\n    changes_poly_at (pders (pderiv p)) d2", "apply (subst pders_changes_d2[OF \\<open>poly p c\\<noteq>0\\<close> _ d2c_nzero])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) d2\n     else 1 + changes_poly_at (pders (pderiv p)) d2) =\n    changes_poly_at (pders (pderiv p)) d2", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  sign_r_pos (pderiv p) c = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) d2\n     else 1 + changes_poly_at (pders (pderiv p)) d2) =\n    changes_poly_at (pders (pderiv p)) d2", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "ultimately"], ["proof (chain)\npicking this:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n  changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n  changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "using hyps"], ["proof (prove)\nusing this:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n  changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2\n  changes_itv_der c d2 (pderiv p) = 0\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "unfolding changes_itv_der_def Let_def"], ["proof (prove)\nusing this:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n  changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2\n  changes_poly_at (pders (pderiv p)) c -\n  changes_poly_at (pders (pderiv p)) d2 =\n  0\n\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) c - changes_poly_at (pders p) d2 = 0", "by auto"], ["proof (state)\nthis:\n  changes_itv_der c d2 p = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p c \\<noteq> 0;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> changes_itv_der c d2 p = 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p c \\<noteq> 0;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> changes_itv_der c d2 p = 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "have ?case when \"poly p c\\<noteq>0\" \"\\<not> sign_r_pos (pderiv p) c \\<longleftrightarrow> poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "have \"changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c +1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) c =\n    changes_poly_at (pders (pderiv p)) c + 1", "apply (subst pders_changes_c[OF \\<open>poly p c\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c + 1", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c + 1", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "have \"changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2 + 1", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) d2 =\n    changes_poly_at (pders (pderiv p)) d2 + 1", "apply (subst pders_changes_d2[OF \\<open>poly p c\\<noteq>0\\<close> _ d2c_nzero])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) d2\n     else 1 + changes_poly_at (pders (pderiv p)) d2) =\n    changes_poly_at (pders (pderiv p)) d2 + 1", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) d2\n     else 1 + changes_poly_at (pders (pderiv p)) d2) =\n    changes_poly_at (pders (pderiv p)) d2 + 1", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2 + 1\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "ultimately"], ["proof (chain)\npicking this:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n  changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2 + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n  changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2 + 1\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "using hyps"], ["proof (prove)\nusing this:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n  changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2 + 1\n  changes_itv_der c d2 (pderiv p) = 0\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "unfolding changes_itv_der_def Let_def"], ["proof (prove)\nusing this:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n  changes_poly_at (pders p) d2 = changes_poly_at (pders (pderiv p)) d2 + 1\n  changes_poly_at (pders (pderiv p)) c -\n  changes_poly_at (pders (pderiv p)) d2 =\n  0\n\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) c - changes_poly_at (pders p) d2 = 0", "by auto"], ["proof (state)\nthis:\n  changes_itv_der c d2 p = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p c \\<noteq> 0;\n   (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> changes_itv_der c d2 p = 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       c < x \\<and> x \\<le> d2 \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> changes_itv_der c d2 p = 0;\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           c < x \\<and> x \\<le> d2 \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> changes_itv_der c d2 p = 0", "ultimately"], ["proof (chain)\npicking this:\n  poly p c = 0 \\<Longrightarrow> changes_itv_der c d2 p = 0\n  \\<lbrakk>poly p c \\<noteq> 0;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> changes_itv_der c d2 p = 0\n  \\<lbrakk>poly p c \\<noteq> 0;\n   (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> changes_itv_der c d2 p = 0", "show ?case"], ["proof (prove)\nusing this:\n  poly p c = 0 \\<Longrightarrow> changes_itv_der c d2 p = 0\n  \\<lbrakk>poly p c \\<noteq> 0;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> changes_itv_der c d2 p = 0\n  \\<lbrakk>poly p c \\<noteq> 0;\n   (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> changes_itv_der c d2 p = 0\n\ngoal (1 subgoal):\n 1. changes_itv_der c d2 p = 0", "by blast"], ["proof (state)\nthis:\n  changes_itv_der c d2 p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma budan_fourier_aux_left':\n  assumes \"d1<c\" and \"p\\<noteq>0\"\n  assumes \"\\<forall>x. d1\\<le>x\\<and> x<c \\<longrightarrow> (\\<forall>q\\<in>set (pders p). poly q x\\<noteq>0)\"\n  shows \"changes_itv_der d1 c p \\<ge> order c p \\<and> even (changes_itv_der d1 c p - order c p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "using assms(2-3)"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<forall>x.\n     d1 \\<le> x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "proof (induct \"degree p\" arbitrary:p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "case 0"], ["proof (state)\nthis:\n  0 = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     d1 \\<le> x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "then"], ["proof (chain)\npicking this:\n  0 = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     d1 \\<le> x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "obtain a where \"p=[:a:]\" \"a\\<noteq>0\""], ["proof (prove)\nusing this:\n  0 = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     d1 \\<le> x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>p = [:a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis degree_eq_zeroE pCons_0_0)"], ["proof (state)\nthis:\n  p = [:a:]\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>0 = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))\n 2. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "then"], ["proof (chain)\npicking this:\n  p = [:a:]\n  a \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  p = [:a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "apply (auto simp add:changes_itv_der_def pders.simps intro:order_0I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = [:a:]; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> even (order c [:a:])", "by (metis add.right_neutral dvd_0_right mult_zero_right order_root poly_pCons)"], ["proof (state)\nthis:\n  int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n  even (changes_itv_der d1 c p - int (order c p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = degree ?p; ?p \\<noteq> 0;\n   \\<forall>x.\n      d1 \\<le> x \\<and> x < c \\<longrightarrow>\n      (\\<forall>q\\<in>set (pders ?p). poly q x \\<noteq> 0)\\<rbrakk>\n  \\<Longrightarrow> int (order c ?p) \\<le> changes_itv_der d1 c ?p \\<and>\n                    even (changes_itv_der d1 c ?p - int (order c ?p))\n  Suc n = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     d1 \\<le> x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = degree ?p; ?p \\<noteq> 0;\n   \\<forall>x.\n      d1 \\<le> x \\<and> x < c \\<longrightarrow>\n      (\\<forall>q\\<in>set (pders ?p). poly q x \\<noteq> 0)\\<rbrakk>\n  \\<Longrightarrow> int (order c ?p) \\<le> changes_itv_der d1 c ?p \\<and>\n                    even (changes_itv_der d1 c ?p - int (order c ?p))\n  Suc n = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     d1 \\<le> x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "have [simp]:\"pderiv p\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = degree ?p; ?p \\<noteq> 0;\n   \\<forall>x.\n      d1 \\<le> x \\<and> x < c \\<longrightarrow>\n      (\\<forall>q\\<in>set (pders ?p). poly q x \\<noteq> 0)\\<rbrakk>\n  \\<Longrightarrow> int (order c ?p) \\<le> changes_itv_der d1 c ?p \\<and>\n                    even (changes_itv_der d1 c ?p - int (order c ?p))\n  Suc n = degree p\n  p \\<noteq> 0\n  \\<forall>x.\n     d1 \\<le> x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "by (metis nat.distinct(1) pderiv_eq_0_iff)"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "note nzero=\\<open>\\<forall>x. d1 \\<le> x \\<and> x < c \\<longrightarrow> (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<close>"], ["proof (state)\nthis:\n  \\<forall>x.\n     d1 \\<le> x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "define v where \"v=order c (pderiv p)\""], ["proof (state)\nthis:\n  v = order c (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "have hyps:\"v \\<le> changes_itv_der d1 c (pderiv p) \\<and> even (changes_itv_der d1 c (pderiv p) - v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int v \\<le> changes_itv_der d1 c (pderiv p) \\<and>\n    even (changes_itv_der d1 c (pderiv p) - int v)", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (order c (pderiv p)) \\<le> changes_itv_der d1 c (pderiv p) \\<and>\n    even (changes_itv_der d1 c (pderiv p) - int (order c (pderiv p)))", "apply (rule Suc(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. n = degree (pderiv p)\n 2. pderiv p \\<noteq> 0\n 3. \\<forall>x.\n       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders (pderiv p)). poly q x \\<noteq> 0)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = degree (pderiv p)", "by (metis Suc.hyps(2) degree_pderiv diff_Suc_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. \\<forall>x.\n       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders (pderiv p)). poly q x \\<noteq> 0)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p \\<noteq> 0", "by (simp add: Suc.prems(1) Suc.prems(2) pders.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders (pderiv p)). poly q x \\<noteq> 0)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders (pderiv p)). poly q x \\<noteq> 0)", "by (simp add: Suc.prems(1) nzero pders.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  int v \\<le> changes_itv_der d1 c (pderiv p) \\<and>\n  even (changes_itv_der d1 c (pderiv p) - int v)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "have pders_changes_c:\"changes_poly_at (r# pders q) c = (if sign_r_pos q c \\<longleftrightarrow> poly r c>0\n          then changes_poly_at (pders q) c else 1+changes_poly_at (pders q) c)\"\n    when \"poly r c\\<noteq>0\" \"q\\<noteq>0\" for q r"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "proof (induct q rule:pders.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> changes_poly_at (r # pders (pderiv p)) c =\n                                  (if sign_r_pos (pderiv p) c =\n(0 < poly r c)\n                                   then changes_poly_at (pders (pderiv p)) c\n                                   else 1 +\n  changes_poly_at (pders (pderiv p)) c);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (r # pders p) c =\n                         (if sign_r_pos p c = (0 < poly r c)\n                          then changes_poly_at (pders p) c\n                          else 1 + changes_poly_at (pders p) c)", "case (1 q)"], ["proof (state)\nthis:\n  \\<lbrakk>q \\<noteq> 0; pderiv q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (r # pders (pderiv q)) c =\n                    (if sign_r_pos (pderiv q) c = (0 < poly r c)\n                     then changes_poly_at (pders (pderiv q)) c\n                     else 1 + changes_poly_at (pders (pderiv q)) c)\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> changes_poly_at (r # pders (pderiv p)) c =\n                                  (if sign_r_pos (pderiv p) c =\n(0 < poly r c)\n                                   then changes_poly_at (pders (pderiv p)) c\n                                   else 1 +\n  changes_poly_at (pders (pderiv p)) c);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (r # pders p) c =\n                         (if sign_r_pos p c = (0 < poly r c)\n                          then changes_poly_at (pders p) c\n                          else 1 + changes_poly_at (pders p) c)", "have ?case when \"pderiv q=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "have \"degree q=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q = 0", "using that pderiv_eq_0_iff"], ["proof (prove)\nusing this:\n  pderiv q = 0\n  (pderiv ?p = 0) = (degree ?p = 0)\n\ngoal (1 subgoal):\n 1. degree q = 0", "by blast"], ["proof (state)\nthis:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "then"], ["proof (chain)\npicking this:\n  degree q = 0", "obtain a where \"q=[:a:]\" \"a\\<noteq>0\""], ["proof (prove)\nusing this:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>q = [:a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  degree q = 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>q = [:a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis degree_eq_zeroE pCons_0_0)"], ["proof (state)\nthis:\n  q = [:a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "then"], ["proof (chain)\npicking this:\n  q = [:a:]\n  a \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  q = [:a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "using \\<open>poly r c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q = [:a:]\n  a \\<noteq> 0\n  poly r c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "by (auto simp add:sign_r_pos_rec changes_poly_at_def mult_less_0_iff pders.simps)"], ["proof (state)\nthis:\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pderiv q = 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> changes_poly_at (r # pders (pderiv p)) c =\n                                  (if sign_r_pos (pderiv p) c =\n(0 < poly r c)\n                                   then changes_poly_at (pders (pderiv p)) c\n                                   else 1 +\n  changes_poly_at (pders (pderiv p)) c);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (r # pders p) c =\n                         (if sign_r_pos p c = (0 < poly r c)\n                          then changes_poly_at (pders p) c\n                          else 1 + changes_poly_at (pders p) c)", "moreover"], ["proof (state)\nthis:\n  pderiv q = 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> changes_poly_at (r # pders (pderiv p)) c =\n                                  (if sign_r_pos (pderiv p) c =\n(0 < poly r c)\n                                   then changes_poly_at (pders (pderiv p)) c\n                                   else 1 +\n  changes_poly_at (pders (pderiv p)) c);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (r # pders p) c =\n                         (if sign_r_pos p c = (0 < poly r c)\n                          then changes_poly_at (pders p) c\n                          else 1 + changes_poly_at (pders p) c)", "have ?case when \"pderiv q\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "obtain qs where qs:\"pders q=q#qs\" \"pders (pderiv q) = qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>pders q = q # qs; pders (pderiv q) = qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>pders q = q # qs; pders (pderiv q) = qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add:pders.simps)"], ["proof (state)\nthis:\n  pders q = q # qs\n  pders (pderiv q) = qs\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "have \"changes_poly_at (r # qs) c = (if sign_r_pos (pderiv q) c = (0 < poly r c) \n              then changes_poly_at qs c else 1 + changes_poly_at qs c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (r # qs) c =\n    (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n     else 1 + changes_poly_at qs c)", "using 1 \\<open>pderiv q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>q \\<noteq> 0; pderiv q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (r # pders (pderiv q)) c =\n                    (if sign_r_pos (pderiv q) c = (0 < poly r c)\n                     then changes_poly_at (pders (pderiv q)) c\n                     else 1 + changes_poly_at (pders (pderiv q)) c)\n  q \\<noteq> 0\n  pderiv q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # qs) c =\n    (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n     else 1 + changes_poly_at qs c)", "unfolding qs"], ["proof (prove)\nusing this:\n  \\<lbrakk>q \\<noteq> 0; pderiv q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (r # qs) c =\n                    (if sign_r_pos (pderiv q) c = (0 < poly r c)\n                     then changes_poly_at qs c\n                     else 1 + changes_poly_at qs c)\n  q \\<noteq> 0\n  pderiv q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # qs) c =\n    (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n     else 1 + changes_poly_at qs c)", "by simp"], ["proof (state)\nthis:\n  changes_poly_at (r # qs) c =\n  (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n   else 1 + changes_poly_at qs c)\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "then"], ["proof (chain)\npicking this:\n  changes_poly_at (r # qs) c =\n  (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n   else 1 + changes_poly_at qs c)", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at (r # qs) c =\n  (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n   else 1 + changes_poly_at qs c)\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "unfolding qs"], ["proof (prove)\nusing this:\n  changes_poly_at (r # qs) c =\n  (if sign_r_pos (pderiv q) c = (0 < poly r c) then changes_poly_at qs c\n   else 1 + changes_poly_at qs c)\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # q # qs) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (q # qs) c\n     else 1 + changes_poly_at (q # qs) c)", "apply (cases \"poly q c=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>changes_poly_at (r # qs) c =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes_poly_at qs c else 1 + changes_poly_at qs c);\n     poly q c = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (r # q # qs) c =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes_poly_at (q # qs) c\n                       else 1 + changes_poly_at (q # qs) c)\n 2. \\<lbrakk>changes_poly_at (r # qs) c =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes_poly_at qs c else 1 + changes_poly_at qs c);\n     poly q c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (r # q # qs) c =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes_poly_at (q # qs) c\n                       else 1 + changes_poly_at (q # qs) c)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes_poly_at (r # qs) c =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes_poly_at qs c else 1 + changes_poly_at qs c);\n     poly q c = 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (r # q # qs) c =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes_poly_at (q # qs) c\n                       else 1 + changes_poly_at (q # qs) c)", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes (map (\\<lambda>p. poly p c) (r # qs)) =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes (map (\\<lambda>p. poly p c) qs)\n              else 1 + changes (map (\\<lambda>p. poly p c) qs));\n     poly q c = 0\\<rbrakk>\n    \\<Longrightarrow> changes (map (\\<lambda>p. poly p c) (r # q # qs)) =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes (map (\\<lambda>p. poly p c) (q # qs))\n                       else 1 +\n                            changes (map (\\<lambda>p. poly p c) (q # qs)))", "by (auto simp:sign_r_pos_rec[OF \\<open>q\\<noteq>0\\<close>,of c])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes_poly_at (r # qs) c =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes_poly_at qs c else 1 + changes_poly_at qs c);\n     poly q c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (r # q # qs) c =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes_poly_at (q # qs) c\n                       else 1 + changes_poly_at (q # qs) c)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes_poly_at (r # qs) c =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes_poly_at qs c else 1 + changes_poly_at qs c);\n     poly q c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes_poly_at (r # q # qs) c =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes_poly_at (q # qs) c\n                       else 1 + changes_poly_at (q # qs) c)", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>changes (map (\\<lambda>p. poly p c) (r # qs)) =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes (map (\\<lambda>p. poly p c) qs)\n              else 1 + changes (map (\\<lambda>p. poly p c) qs));\n     poly q c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes (map (\\<lambda>p. poly p c) (r # q # qs)) =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes (map (\\<lambda>p. poly p c) (q # qs))\n                       else 1 +\n                            changes (map (\\<lambda>p. poly p c) (q # qs)))", "using \\<open>poly r c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  poly r c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>changes (map (\\<lambda>p. poly p c) (r # qs)) =\n             (if sign_r_pos (pderiv q) c = (0 < poly r c)\n              then changes (map (\\<lambda>p. poly p c) qs)\n              else 1 + changes (map (\\<lambda>p. poly p c) qs));\n     poly q c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> changes (map (\\<lambda>p. poly p c) (r # q # qs)) =\n                      (if sign_r_pos q c = (0 < poly r c)\n                       then changes (map (\\<lambda>p. poly p c) (q # qs))\n                       else 1 +\n                            changes (map (\\<lambda>p. poly p c) (q # qs)))", "by (auto simp:sign_r_pos_rec[OF \\<open>q\\<noteq>0\\<close>,of c] mult_less_0_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pderiv q \\<noteq> 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>p \\<noteq> 0; pderiv p \\<noteq> 0\\<rbrakk>\n                \\<Longrightarrow> changes_poly_at (r # pders (pderiv p)) c =\n                                  (if sign_r_pos (pderiv p) c =\n(0 < poly r c)\n                                   then changes_poly_at (pders (pderiv p)) c\n                                   else 1 +\n  changes_poly_at (pders (pderiv p)) c);\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> changes_poly_at (r # pders p) c =\n                         (if sign_r_pos p c = (0 < poly r c)\n                          then changes_poly_at (pders p) c\n                          else 1 + changes_poly_at (pders p) c)", "ultimately"], ["proof (chain)\npicking this:\n  pderiv q = 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n  pderiv q \\<noteq> 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)", "show ?case"], ["proof (prove)\nusing this:\n  pderiv q = 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n  pderiv q \\<noteq> 0 \\<Longrightarrow>\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) c =\n    (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n     else 1 + changes_poly_at (pders q) c)", "by blast"], ["proof (state)\nthis:\n  changes_poly_at (r # pders q) c =\n  (if sign_r_pos q c = (0 < poly r c) then changes_poly_at (pders q) c\n   else 1 + changes_poly_at (pders q) c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly ?r c \\<noteq> 0; ?q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (?r # pders ?q) c =\n                    (if sign_r_pos ?q c = (0 < poly ?r c)\n                     then changes_poly_at (pders ?q) c\n                     else 1 + changes_poly_at (pders ?q) c)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "have pders_changes_d1:\"changes_poly_at (r# pders q) d1 = (if even (order c q) \\<longleftrightarrow> sign_r_pos q c \\<longleftrightarrow> poly r c>0\n          then changes_poly_at (pders q) d1 else 1+changes_poly_at (pders q) d1)\"\n    when \"poly r c\\<noteq>0\" \"q\\<noteq>0\" and qr_nzero:\"\\<forall>x. d1 \\<le> x \\<and> x < c \\<longrightarrow> poly r x \\<noteq> 0 \\<and> poly q x\\<noteq>0\" \n    for q r"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d1 =\n    (if even (order c q) = (sign_r_pos q c = (0 < poly r c))\n     then changes_poly_at (pders q) d1\n     else 1 + changes_poly_at (pders q) d1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d1 =\n    (if even (order c q) = (sign_r_pos q c = (0 < poly r c))\n     then changes_poly_at (pders q) d1\n     else 1 + changes_poly_at (pders q) d1)", "have \"r\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "using that(1)"], ["proof (prove)\nusing this:\n  poly r c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "using poly_0"], ["proof (prove)\nusing this:\n  poly r c \\<noteq> 0\n  poly 0 ?x = (0::?'a)\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d1 =\n    (if even (order c q) = (sign_r_pos q c = (0 < poly r c))\n     then changes_poly_at (pders q) d1\n     else 1 + changes_poly_at (pders q) d1)", "obtain qs where qs:\"pders q=q#qs\" \"pders (pderiv q) = qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>pders q = q # qs; pders (pderiv q) = qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>q\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>pders q = q # qs; pders (pderiv q) = qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add:pders.simps)"], ["proof (state)\nthis:\n  pders q = q # qs\n  pders (pderiv q) = qs\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d1 =\n    (if even (order c q) = (sign_r_pos q c = (0 < poly r c))\n     then changes_poly_at (pders q) d1\n     else 1 + changes_poly_at (pders q) d1)", "have \"if even (order c r) = sign_r_pos r c then 0 < poly r d1 else poly r d1 < 0\"\n      \"if even (order c q) = sign_r_pos q c then 0 < poly q d1 else poly q d1 < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c r) = sign_r_pos r c then 0 < poly r d1\n    else poly r d1 < 0 &&&\n    if even (order c q) = sign_r_pos q c then 0 < poly q d1\n    else poly q d1 < 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c r) = sign_r_pos r c then 0 < poly r d1\n    else poly r d1 < 0", "by (rule sign_r_pos_nzero_left[of d1 c r]) (use qr_nzero \\<open>d1<c\\<close> in auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c q) = sign_r_pos q c then 0 < poly q d1\n    else poly q d1 < 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c q) = sign_r_pos q c then 0 < poly q d1\n    else poly q d1 < 0", "by (rule sign_r_pos_nzero_left[of d1 c q]) (use qr_nzero \\<open>d1<c\\<close> in auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  if even (order c r) = sign_r_pos r c then 0 < poly r d1 else poly r d1 < 0\n  if even (order c q) = sign_r_pos q c then 0 < poly q d1 else poly q d1 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d1 =\n    (if even (order c q) = (sign_r_pos q c = (0 < poly r c))\n     then changes_poly_at (pders q) d1\n     else 1 + changes_poly_at (pders q) d1)", "moreover"], ["proof (state)\nthis:\n  if even (order c r) = sign_r_pos r c then 0 < poly r d1 else poly r d1 < 0\n  if even (order c q) = sign_r_pos q c then 0 < poly q d1 else poly q d1 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d1 =\n    (if even (order c q) = (sign_r_pos q c = (0 < poly r c))\n     then changes_poly_at (pders q) d1\n     else 1 + changes_poly_at (pders q) d1)", "have \"order c r=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c r = 0", "by (simp add: order_0I that(1))"], ["proof (state)\nthis:\n  order c r = 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d1 =\n    (if even (order c q) = (sign_r_pos q c = (0 < poly r c))\n     then changes_poly_at (pders q) d1\n     else 1 + changes_poly_at (pders q) d1)", "ultimately"], ["proof (chain)\npicking this:\n  if even (order c r) = sign_r_pos r c then 0 < poly r d1 else poly r d1 < 0\n  if even (order c q) = sign_r_pos q c then 0 < poly q d1 else poly q d1 < 0\n  order c r = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  if even (order c r) = sign_r_pos r c then 0 < poly r d1 else poly r d1 < 0\n  if even (order c q) = sign_r_pos q c then 0 < poly q d1 else poly q d1 < 0\n  order c r = 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (r # pders q) d1 =\n    (if even (order c q) = (sign_r_pos q c = (0 < poly r c))\n     then changes_poly_at (pders q) d1\n     else 1 + changes_poly_at (pders q) d1)", "unfolding qs changes_poly_at_def"], ["proof (prove)\nusing this:\n  if even (order c r) = sign_r_pos r c then 0 < poly r d1 else poly r d1 < 0\n  if even (order c q) = sign_r_pos q c then 0 < poly q d1 else poly q d1 < 0\n  order c r = 0\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p d1) (r # q # qs)) =\n    (if even (order c q) = (sign_r_pos q c = (0 < poly r c))\n     then changes (map (\\<lambda>p. poly p d1) (q # qs))\n     else 1 + changes (map (\\<lambda>p. poly p d1) (q # qs)))", "using \\<open>poly r c\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  if even (order c r) = sign_r_pos r c then 0 < poly r d1 else poly r d1 < 0\n  if even (order c q) = sign_r_pos q c then 0 < poly q d1 else poly q d1 < 0\n  order c r = 0\n  poly r c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p d1) (r # q # qs)) =\n    (if even (order c q) = (sign_r_pos q c = (0 < poly r c))\n     then changes (map (\\<lambda>p. poly p d1) (q # qs))\n     else 1 + changes (map (\\<lambda>p. poly p d1) (q # qs)))", "by (auto split:if_splits simp:mult_less_0_iff sign_r_pos_rec[OF \\<open>r\\<noteq>0\\<close>])"], ["proof (state)\nthis:\n  changes_poly_at (r # pders q) d1 =\n  (if even (order c q) = (sign_r_pos q c = (0 < poly r c))\n   then changes_poly_at (pders q) d1 else 1 + changes_poly_at (pders q) d1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly ?r c \\<noteq> 0; ?q \\<noteq> 0;\n   \\<forall>x.\n      d1 \\<le> x \\<and> x < c \\<longrightarrow>\n      poly ?r x \\<noteq> 0 \\<and> poly ?q x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> changes_poly_at (?r # pders ?q) d1 =\n                    (if even (order c ?q) =\n                        (sign_r_pos ?q c = (0 < poly ?r c))\n                     then changes_poly_at (pders ?q) d1\n                     else 1 + changes_poly_at (pders ?q) d1)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "have d1c_nzero:\"\\<forall>x. d1 \\<le> x \\<and> x < c \\<longrightarrow> poly p x \\<noteq> 0 \\<and> poly (pderiv p) x \\<noteq> 0\"\n    and p_cons:\"pders p = p#pders(pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n       poly p x \\<noteq> 0 \\<and> poly (pderiv p) x \\<noteq> 0 &&&\n    pders p = p # pders (pderiv p)", "by (simp_all add: nzero Suc.prems(1) pders.simps)"], ["proof (state)\nthis:\n  \\<forall>x.\n     d1 \\<le> x \\<and> x < c \\<longrightarrow>\n     poly p x \\<noteq> 0 \\<and> poly (pderiv p) x \\<noteq> 0\n  pders p = p # pders (pderiv p)\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "have ?case when \"poly p c=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "define ps where \"ps=pders (pderiv (pderiv p))\""], ["proof (state)\nthis:\n  ps = pders (pderiv (pderiv p))\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have ps_cons:\"p#pderiv p#ps = pders p\" \"pderiv p#ps=pders (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p # pderiv p # ps = pders p &&& pderiv p # ps = pders (pderiv p)", "unfolding ps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p # pderiv p # pders (pderiv (pderiv p)) = pders p &&&\n    pderiv p # pders (pderiv (pderiv p)) = pders (pderiv p)", "using \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p # pderiv p # pders (pderiv (pderiv p)) = pders p &&&\n    pderiv p # pders (pderiv (pderiv p)) = pders (pderiv p)", "by (auto simp:pders.simps)"], ["proof (state)\nthis:\n  p # pderiv p # ps = pders p\n  pderiv p # ps = pders (pderiv p)\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have p_order:\"order c p = Suc v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c p = Suc v", "apply (subst order_pderiv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. order c p \\<noteq> 0\n 3. Suc (order c (pderiv p)) = Suc v", "using Suc.prems(1) order_root that"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n  poly p c = 0\n\ngoal (3 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. order c p \\<noteq> 0\n 3. Suc (order c (pderiv p)) = Suc v", "unfolding v_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n  poly p c = 0\n\ngoal (3 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. order c p \\<noteq> 0\n 3. Suc (order c (pderiv p)) = Suc (order c (pderiv p))", "by auto"], ["proof (state)\nthis:\n  order c p = Suc v\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  order c p = Suc v\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"changes_poly_at (p#pderiv p # ps) d1 = changes_poly_at (pderiv p#ps) d1 +1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d1 =\n    changes_poly_at (pderiv p # ps) d1 + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d1 =\n    changes_poly_at (pderiv p # ps) d1 + 1", "have \"if even (order c p) = sign_r_pos p c then 0 < poly p d1 else poly p d1 < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c p) = sign_r_pos p c then 0 < poly p d1\n    else poly p d1 < 0", "apply (rule sign_r_pos_nzero_left[OF _ \\<open>d1<c\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       d1 \\<le> x \\<and> x < c \\<longrightarrow> poly p x \\<noteq> 0", "using nzero[folded ps_cons] assms(1-2)"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     d1 \\<le> x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (p # pderiv p # ps). poly q x \\<noteq> 0)\n  d1 < c\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       d1 \\<le> x \\<and> x < c \\<longrightarrow> poly p x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  if even (order c p) = sign_r_pos p c then 0 < poly p d1 else poly p d1 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d1 =\n    changes_poly_at (pderiv p # ps) d1 + 1", "moreover"], ["proof (state)\nthis:\n  if even (order c p) = sign_r_pos p c then 0 < poly p d1 else poly p d1 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d1 =\n    changes_poly_at (pderiv p # ps) d1 + 1", "have \"if even v = sign_r_pos (pderiv p) c \n                      then 0 < poly (pderiv p) d1 else poly (pderiv p) d1 < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if even v = sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d1\n    else poly (pderiv p) d1 < 0", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if even (order c (pderiv p)) = sign_r_pos (pderiv p) c\n    then 0 < poly (pderiv p) d1 else poly (pderiv p) d1 < 0", "apply (rule sign_r_pos_nzero_left[OF _ \\<open>d1<c\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n       poly (pderiv p) x \\<noteq> 0", "using nzero[folded ps_cons] assms(1-2)"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     d1 \\<le> x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (p # pderiv p # ps). poly q x \\<noteq> 0)\n  d1 < c\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n       poly (pderiv p) x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  if even v = sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d1\n  else poly (pderiv p) d1 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d1 =\n    changes_poly_at (pderiv p # ps) d1 + 1", "ultimately"], ["proof (chain)\npicking this:\n  if even (order c p) = sign_r_pos p c then 0 < poly p d1 else poly p d1 < 0\n  if even v = sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d1\n  else poly (pderiv p) d1 < 0", "have \"poly p d1 * poly (pderiv p) d1 < 0\""], ["proof (prove)\nusing this:\n  if even (order c p) = sign_r_pos p c then 0 < poly p d1 else poly p d1 < 0\n  if even v = sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d1\n  else poly (pderiv p) d1 < 0\n\ngoal (1 subgoal):\n 1. poly p d1 * poly (pderiv p) d1 < 0", "unfolding mult_less_0_iff sign_r_pos_rec[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  if even (order c p) =\n     (if poly p c = 0 then sign_r_pos (pderiv p) c else 0 < poly p c)\n  then 0 < poly p d1 else poly p d1 < 0\n  if even v = sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d1\n  else poly (pderiv p) d1 < 0\n\ngoal (1 subgoal):\n 1. 0 < poly p d1 \\<and> poly (pderiv p) d1 < 0 \\<or>\n    poly p d1 < 0 \\<and> 0 < poly (pderiv p) d1", "using \\<open>poly p c=0\\<close> p_order"], ["proof (prove)\nusing this:\n  if even (order c p) =\n     (if poly p c = 0 then sign_r_pos (pderiv p) c else 0 < poly p c)\n  then 0 < poly p d1 else poly p d1 < 0\n  if even v = sign_r_pos (pderiv p) c then 0 < poly (pderiv p) d1\n  else poly (pderiv p) d1 < 0\n  poly p c = 0\n  order c p = Suc v\n\ngoal (1 subgoal):\n 1. 0 < poly p d1 \\<and> poly (pderiv p) d1 < 0 \\<or>\n    poly p d1 < 0 \\<and> 0 < poly (pderiv p) d1", "by (auto split:if_splits)"], ["proof (state)\nthis:\n  poly p d1 * poly (pderiv p) d1 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d1 =\n    changes_poly_at (pderiv p # ps) d1 + 1", "then"], ["proof (chain)\npicking this:\n  poly p d1 * poly (pderiv p) d1 < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  poly p d1 * poly (pderiv p) d1 < 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) d1 =\n    changes_poly_at (pderiv p # ps) d1 + 1", "unfolding changes_poly_at_def"], ["proof (prove)\nusing this:\n  poly p d1 * poly (pderiv p) d1 < 0\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p d1) (p # pderiv p # ps)) =\n    changes (map (\\<lambda>p. poly p d1) (pderiv p # ps)) + 1", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (p # pderiv p # ps) d1 =\n  changes_poly_at (pderiv p # ps) d1 + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_poly_at (p # pderiv p # ps) d1 =\n  changes_poly_at (pderiv p # ps) d1 + 1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (p # pderiv p # ps) d1 =\n  changes_poly_at (pderiv p # ps) d1 + 1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"changes_poly_at (p # pderiv p # ps) c =  changes_poly_at (pderiv p # ps) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pderiv p # ps) c =\n    changes_poly_at (pderiv p # ps) c", "unfolding changes_poly_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p c) (p # pderiv p # ps)) =\n    changes (map (\\<lambda>p. poly p c) (pderiv p # ps))", "using that"], ["proof (prove)\nusing this:\n  poly p c = 0\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p c) (p # pderiv p # ps)) =\n    changes (map (\\<lambda>p. poly p c) (pderiv p # ps))", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (p # pderiv p # ps) c = changes_poly_at (pderiv p # ps) c\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "ultimately"], ["proof (chain)\npicking this:\n  order c p = Suc v\n  changes_poly_at (p # pderiv p # ps) d1 =\n  changes_poly_at (pderiv p # ps) d1 + 1\n  changes_poly_at (p # pderiv p # ps) c = changes_poly_at (pderiv p # ps) c", "show ?thesis"], ["proof (prove)\nusing this:\n  order c p = Suc v\n  changes_poly_at (p # pderiv p # ps) d1 =\n  changes_poly_at (pderiv p # ps) d1 + 1\n  changes_poly_at (p # pderiv p # ps) c = changes_poly_at (pderiv p # ps) c\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "using hyps"], ["proof (prove)\nusing this:\n  order c p = Suc v\n  changes_poly_at (p # pderiv p # ps) d1 =\n  changes_poly_at (pderiv p # ps) d1 + 1\n  changes_poly_at (p # pderiv p # ps) c = changes_poly_at (pderiv p # ps) c\n  int v \\<le> changes_itv_der d1 c (pderiv p) \\<and>\n  even (changes_itv_der d1 c (pderiv p) - int v)\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "unfolding changes_itv_der_def"], ["proof (prove)\nusing this:\n  order c p = Suc v\n  changes_poly_at (p # pderiv p # ps) d1 =\n  changes_poly_at (pderiv p # ps) d1 + 1\n  changes_poly_at (p # pderiv p # ps) c = changes_poly_at (pderiv p # ps) c\n  int v\n  \\<le> (let ps = pders (pderiv p)\n         in changes_poly_at ps d1 - changes_poly_at ps c) \\<and>\n  even\n   ((let ps = pders (pderiv p)\n     in changes_poly_at ps d1 - changes_poly_at ps c) -\n    int v)\n\ngoal (1 subgoal):\n 1. int (order c p)\n    \\<le> (let ps = pders p\n           in changes_poly_at ps d1 - changes_poly_at ps c) \\<and>\n    even\n     ((let ps = pders p in changes_poly_at ps d1 - changes_poly_at ps c) -\n      int (order c p))", "apply (fold ps_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order c p = Suc v;\n     changes_poly_at (p # pderiv p # ps) d1 =\n     changes_poly_at (pderiv p # ps) d1 + 1;\n     changes_poly_at (p # pderiv p # ps) c =\n     changes_poly_at (pderiv p # ps) c;\n     int v\n     \\<le> (let ps = pderiv p # ps\n            in changes_poly_at ps d1 - changes_poly_at ps c) \\<and>\n     even\n      ((let ps = pderiv p # ps\n        in changes_poly_at ps d1 - changes_poly_at ps c) -\n       int v)\\<rbrakk>\n    \\<Longrightarrow> int (order c p)\n                      \\<le> (let ps = p # pderiv p # ps\n                             in changes_poly_at ps d1 -\n                                changes_poly_at ps c) \\<and>\n                      even\n                       ((let ps = p # pderiv p # ps\n                         in changes_poly_at ps d1 - changes_poly_at ps c) -\n                        int (order c p))", "by (auto simp:Let_def)"], ["proof (state)\nthis:\n  int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n  even (changes_itv_der d1 c p - int (order c p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p c = 0 \\<Longrightarrow>\n  int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n  even (changes_itv_der d1 c p - int (order c p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  poly p c = 0 \\<Longrightarrow>\n  int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n  even (changes_itv_der d1 c p - int (order c p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "have ?case when \"poly p c\\<noteq>0\" \"odd v\" \"sign_r_pos (pderiv p) c \\<longleftrightarrow> poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"order c p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c p = 0", "by (simp add: order_0I that(1))"], ["proof (state)\nthis:\n  order c p = 0\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  order c p = 0\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 +1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) d1 =\n    changes_poly_at (pders (pderiv p)) d1 + 1", "apply (subst pders_changes_d1[OF \\<open>poly p c\\<noteq>0\\<close> _ d1c_nzero])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1 + 1", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  odd v\n  sign_r_pos (pderiv p) c = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1 + 1", "unfolding v_def"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  odd (order c (pderiv p))\n  sign_r_pos (pderiv p) c = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1 + 1", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) c =\n    changes_poly_at (pders (pderiv p)) c", "apply (subst pders_changes_c[OF \\<open>poly p c\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  odd v\n  sign_r_pos (pderiv p) c = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c", "unfolding v_def"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  odd (order c (pderiv p))\n  sign_r_pos (pderiv p) c = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "ultimately"], ["proof (chain)\npicking this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c", "show ?thesis"], ["proof (prove)\nusing this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "using hyps \\<open>odd v\\<close>"], ["proof (prove)\nusing this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n  int v \\<le> changes_itv_der d1 c (pderiv p) \\<and>\n  even (changes_itv_der d1 c (pderiv p) - int v)\n  odd v\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "unfolding changes_itv_der_def Let_def"], ["proof (prove)\nusing this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n  int v\n  \\<le> changes_poly_at (pders (pderiv p)) d1 -\n        changes_poly_at (pders (pderiv p)) c \\<and>\n  even\n   (changes_poly_at (pders (pderiv p)) d1 -\n    changes_poly_at (pders (pderiv p)) c -\n    int v)\n  odd v\n\ngoal (1 subgoal):\n 1. int (order c p)\n    \\<le> changes_poly_at (pders p) d1 - changes_poly_at (pders p) c \\<and>\n    even\n     (changes_poly_at (pders p) d1 - changes_poly_at (pders p) c -\n      int (order c p))", "by auto"], ["proof (state)\nthis:\n  int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n  even (changes_itv_der d1 c p - int (order c p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p c \\<noteq> 0; odd v;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p c \\<noteq> 0; odd v;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "have ?case when \"poly p c\\<noteq>0\" \"odd v\" \"\\<not> sign_r_pos (pderiv p) c \\<longleftrightarrow> poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"v\\<ge>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> v", "using \\<open>odd v\\<close>"], ["proof (prove)\nusing this:\n  odd v\n\ngoal (1 subgoal):\n 1. 1 \\<le> v", "using not_less_eq_eq"], ["proof (prove)\nusing this:\n  odd v\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n\ngoal (1 subgoal):\n 1. 1 \\<le> v", "by auto"], ["proof (state)\nthis:\n  1 \\<le> v\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  1 \\<le> v\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"order c p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c p = 0", "by (simp add: order_0I that(1))"], ["proof (state)\nthis:\n  order c p = 0\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  order c p = 0\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) d1 =\n    changes_poly_at (pders (pderiv p)) d1", "apply (subst pders_changes_d1[OF \\<open>poly p c\\<noteq>0\\<close> _ d1c_nzero])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  odd v\n  (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1", "unfolding v_def"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  odd (order c (pderiv p))\n  (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) c =\n    changes_poly_at (pders (pderiv p)) c + 1", "apply (subst pders_changes_c[OF \\<open>poly p c\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c + 1", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  odd v\n  (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c + 1", "unfolding v_def"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  odd (order c (pderiv p))\n  (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c + 1", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "ultimately"], ["proof (chain)\npicking this:\n  1 \\<le> v\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> v\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "using hyps \\<open>odd v\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> v\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n  int v \\<le> changes_itv_der d1 c (pderiv p) \\<and>\n  even (changes_itv_der d1 c (pderiv p) - int v)\n  odd v\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "unfolding changes_itv_der_def Let_def"], ["proof (prove)\nusing this:\n  1 \\<le> v\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n  int v\n  \\<le> changes_poly_at (pders (pderiv p)) d1 -\n        changes_poly_at (pders (pderiv p)) c \\<and>\n  even\n   (changes_poly_at (pders (pderiv p)) d1 -\n    changes_poly_at (pders (pderiv p)) c -\n    int v)\n  odd v\n\ngoal (1 subgoal):\n 1. int (order c p)\n    \\<le> changes_poly_at (pders p) d1 - changes_poly_at (pders p) c \\<and>\n    even\n     (changes_poly_at (pders p) d1 - changes_poly_at (pders p) c -\n      int (order c p))", "by auto"], ["proof (state)\nthis:\n  int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n  even (changes_itv_der d1 c p - int (order c p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p c \\<noteq> 0; odd v;\n   (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p c \\<noteq> 0; odd v;\n   (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "have ?case when \"poly p c\\<noteq>0\" \"even v\" \"sign_r_pos (pderiv p) c \\<longleftrightarrow> poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"order c p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c p = 0", "by (simp add: order_0I that(1))"], ["proof (state)\nthis:\n  order c p = 0\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  order c p = 0\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) d1 =\n    changes_poly_at (pders (pderiv p)) d1", "apply (subst pders_changes_d1[OF \\<open>poly p c\\<noteq>0\\<close> _ d1c_nzero])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  even v\n  sign_r_pos (pderiv p) c = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1", "unfolding v_def"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  even (order c (pderiv p))\n  sign_r_pos (pderiv p) c = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) c =\n    changes_poly_at (pders (pderiv p)) c", "apply (subst pders_changes_c[OF \\<open>poly p c\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  even v\n  sign_r_pos (pderiv p) c = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c", "unfolding v_def"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  even (order c (pderiv p))\n  sign_r_pos (pderiv p) c = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "ultimately"], ["proof (chain)\npicking this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c", "show ?thesis"], ["proof (prove)\nusing this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "using hyps \\<open>even v\\<close>"], ["proof (prove)\nusing this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n  int v \\<le> changes_itv_der d1 c (pderiv p) \\<and>\n  even (changes_itv_der d1 c (pderiv p) - int v)\n  even v\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "unfolding changes_itv_der_def Let_def"], ["proof (prove)\nusing this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c\n  int v\n  \\<le> changes_poly_at (pders (pderiv p)) d1 -\n        changes_poly_at (pders (pderiv p)) c \\<and>\n  even\n   (changes_poly_at (pders (pderiv p)) d1 -\n    changes_poly_at (pders (pderiv p)) c -\n    int v)\n  even v\n\ngoal (1 subgoal):\n 1. int (order c p)\n    \\<le> changes_poly_at (pders p) d1 - changes_poly_at (pders p) c \\<and>\n    even\n     (changes_poly_at (pders p) d1 - changes_poly_at (pders p) c -\n      int (order c p))", "by auto"], ["proof (state)\nthis:\n  int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n  even (changes_itv_der d1 c p - int (order c p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p c \\<noteq> 0; even v;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>poly p c \\<noteq> 0; even v;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "have ?case when \"poly p c\\<noteq>0\" \"even v\" \"\\<not> sign_r_pos (pderiv p) c \\<longleftrightarrow> poly p c>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"order c p=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order c p = 0", "by (simp add: order_0I that(1))"], ["proof (state)\nthis:\n  order c p = 0\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  order c p = 0\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) d1 =\n    changes_poly_at (pders (pderiv p)) d1 + 1", "apply (subst pders_changes_d1[OF \\<open>poly p c\\<noteq>0\\<close> _ d1c_nzero])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1 + 1", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  even v\n  (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1 + 1", "unfolding v_def"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  even (order c (pderiv p))\n  (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if even (order c (pderiv p)) =\n        (sign_r_pos (pderiv p) c = (0 < poly p c))\n     then changes_poly_at (pders (pderiv p)) d1\n     else 1 + changes_poly_at (pders (pderiv p)) d1) =\n    changes_poly_at (pders (pderiv p)) d1 + 1", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "have \"changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c +1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1", "unfolding p_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_poly_at (p # pders (pderiv p)) c =\n    changes_poly_at (pders (pderiv p)) c + 1", "apply (subst pders_changes_c[OF \\<open>poly p c\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c + 1", "using that"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  even v\n  (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c + 1", "unfolding v_def"], ["proof (prove)\nusing this:\n  poly p c \\<noteq> 0\n  even (order c (pderiv p))\n  (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\n\ngoal (2 subgoals):\n 1. pderiv p \\<noteq> 0\n 2. (if sign_r_pos (pderiv p) c = (0 < poly p c)\n     then changes_poly_at (pders (pderiv p)) c\n     else 1 + changes_poly_at (pders (pderiv p)) c) =\n    changes_poly_at (pders (pderiv p)) c + 1", "by auto"], ["proof (state)\nthis:\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "ultimately"], ["proof (chain)\npicking this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "using hyps \\<open>even v\\<close>"], ["proof (prove)\nusing this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n  int v \\<le> changes_itv_der d1 c (pderiv p) \\<and>\n  even (changes_itv_der d1 c (pderiv p) - int v)\n  even v\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "unfolding changes_itv_der_def Let_def"], ["proof (prove)\nusing this:\n  order c p = 0\n  changes_poly_at (pders p) d1 = changes_poly_at (pders (pderiv p)) d1 + 1\n  changes_poly_at (pders p) c = changes_poly_at (pders (pderiv p)) c + 1\n  int v\n  \\<le> changes_poly_at (pders (pderiv p)) d1 -\n        changes_poly_at (pders (pderiv p)) c \\<and>\n  even\n   (changes_poly_at (pders (pderiv p)) d1 -\n    changes_poly_at (pders (pderiv p)) c -\n    int v)\n  even v\n\ngoal (1 subgoal):\n 1. int (order c p)\n    \\<le> changes_poly_at (pders p) d1 - changes_poly_at (pders p) c \\<and>\n    even\n     (changes_poly_at (pders p) d1 - changes_poly_at (pders p) c -\n      int (order c p))", "by auto"], ["proof (state)\nthis:\n  int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n  even (changes_itv_der d1 c p - int (order c p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p c \\<noteq> 0; even v;\n   (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n\ngoal (1 subgoal):\n 1. \\<And>x p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>x = degree p; p \\<noteq> 0;\n                    \\<forall>x.\n                       d1 \\<le> x \\<and> x < c \\<longrightarrow>\n                       (\\<forall>q\\<in>set (pders p).\n                           poly q x \\<noteq> 0)\\<rbrakk>\n                   \\<Longrightarrow> int (order c p)\n                                     \\<le> changes_itv_der d1 c p \\<and>\n                                     even\n(changes_itv_der d1 c p - int (order c p));\n        Suc x = degree p; p \\<noteq> 0;\n        \\<forall>x.\n           d1 \\<le> x \\<and> x < c \\<longrightarrow>\n           (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\\<rbrakk>\n       \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                         even (changes_itv_der d1 c p - int (order c p))", "ultimately"], ["proof (chain)\npicking this:\n  poly p c = 0 \\<Longrightarrow>\n  int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n  even (changes_itv_der d1 c p - int (order c p))\n  \\<lbrakk>poly p c \\<noteq> 0; odd v;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n  \\<lbrakk>poly p c \\<noteq> 0; odd v;\n   (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n  \\<lbrakk>poly p c \\<noteq> 0; even v;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n  \\<lbrakk>poly p c \\<noteq> 0; even v;\n   (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))", "show ?case"], ["proof (prove)\nusing this:\n  poly p c = 0 \\<Longrightarrow>\n  int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n  even (changes_itv_der d1 c p - int (order c p))\n  \\<lbrakk>poly p c \\<noteq> 0; odd v;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n  \\<lbrakk>poly p c \\<noteq> 0; odd v;\n   (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n  \\<lbrakk>poly p c \\<noteq> 0; even v;\n   sign_r_pos (pderiv p) c = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n  \\<lbrakk>poly p c \\<noteq> 0; even v;\n   (\\<not> sign_r_pos (pderiv p) c) = (0 < poly p c)\\<rbrakk>\n  \\<Longrightarrow> int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n                    even (changes_itv_der d1 c p - int (order c p))\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n    even (changes_itv_der d1 c p - int (order c p))", "by blast"], ["proof (state)\nthis:\n  int (order c p) \\<le> changes_itv_der d1 c p \\<and>\n  even (changes_itv_der d1 c p - int (order c p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma budan_fourier_aux_left:\n  assumes \"d1<c\" and \"p\\<noteq>0\"\n  assumes nzero:\"\\<forall>x. d1<x\\<and> x<c \\<longrightarrow> (\\<forall>q\\<in>set (pders p). poly q x\\<noteq>0)\"\n  shows \"changes_itv_der d1 c p \\<ge> order c p\" \"even (changes_itv_der d1 c p - order c p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p &&&\n    even (changes_itv_der d1 c p - int (order c p))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. int (order c p) \\<le> changes_itv_der d1 c p\n 2. even (changes_itv_der d1 c p - int (order c p))", "define d where \"d=(d1+c)/2\""], ["proof (state)\nthis:\n  d = (d1 + c) / 2\n\ngoal (2 subgoals):\n 1. int (order c p) \\<le> changes_itv_der d1 c p\n 2. even (changes_itv_der d1 c p - int (order c p))", "have \"d1<d\" \"d<c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d1 < d &&& d < c", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d1 < (d1 + c) / 2 &&& (d1 + c) / 2 < c", "using \\<open>d1<c\\<close>"], ["proof (prove)\nusing this:\n  d1 < c\n\ngoal (1 subgoal):\n 1. d1 < (d1 + c) / 2 &&& (d1 + c) / 2 < c", "by auto"], ["proof (state)\nthis:\n  d1 < d\n  d < c\n\ngoal (2 subgoals):\n 1. int (order c p) \\<le> changes_itv_der d1 c p\n 2. even (changes_itv_der d1 c p - int (order c p))", "have \"changes_itv_der d1 d p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_itv_der d1 d p = 0", "apply (rule budan_fourier_aux_right[OF \\<open>d1<d\\<close> \\<open>p\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       d1 < x \\<and> x \\<le> d \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "using nzero \\<open>d1<d\\<close> \\<open>d<c\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     d1 < x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n  d1 < d\n  d < c\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       d1 < x \\<and> x \\<le> d \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  changes_itv_der d1 d p = 0\n\ngoal (2 subgoals):\n 1. int (order c p) \\<le> changes_itv_der d1 c p\n 2. even (changes_itv_der d1 c p - int (order c p))", "moreover"], ["proof (state)\nthis:\n  changes_itv_der d1 d p = 0\n\ngoal (2 subgoals):\n 1. int (order c p) \\<le> changes_itv_der d1 c p\n 2. even (changes_itv_der d1 c p - int (order c p))", "have \"order c p \\<le> changes_itv_der d c p \\<and> even (changes_itv_der d c p - order c p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d c p \\<and>\n    even (changes_itv_der d c p - int (order c p))", "apply (rule budan_fourier_aux_left'[OF \\<open>d<c\\<close> \\<open>p\\<noteq>0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       d \\<le> x \\<and> x < c \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "using nzero \\<open>d1<d\\<close> \\<open>d<c\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     d1 < x \\<and> x < c \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n  d1 < d\n  d < c\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       d \\<le> x \\<and> x < c \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  int (order c p) \\<le> changes_itv_der d c p \\<and>\n  even (changes_itv_der d c p - int (order c p))\n\ngoal (2 subgoals):\n 1. int (order c p) \\<le> changes_itv_der d1 c p\n 2. even (changes_itv_der d1 c p - int (order c p))", "ultimately"], ["proof (chain)\npicking this:\n  changes_itv_der d1 d p = 0\n  int (order c p) \\<le> changes_itv_der d c p \\<and>\n  even (changes_itv_der d c p - int (order c p))", "show \"changes_itv_der d1 c p \\<ge> order c p\" \"even (changes_itv_der d1 c p - order c p)\""], ["proof (prove)\nusing this:\n  changes_itv_der d1 d p = 0\n  int (order c p) \\<le> changes_itv_der d c p \\<and>\n  even (changes_itv_der d c p - int (order c p))\n\ngoal (1 subgoal):\n 1. int (order c p) \\<le> changes_itv_der d1 c p &&&\n    even (changes_itv_der d1 c p - int (order c p))", "unfolding changes_itv_der_def Let_def"], ["proof (prove)\nusing this:\n  changes_poly_at (pders p) d1 - changes_poly_at (pders p) d = 0\n  int (order c p)\n  \\<le> changes_poly_at (pders p) d - changes_poly_at (pders p) c \\<and>\n  even\n   (changes_poly_at (pders p) d - changes_poly_at (pders p) c -\n    int (order c p))\n\ngoal (1 subgoal):\n 1. int (order c p)\n    \\<le> changes_poly_at (pders p) d1 - changes_poly_at (pders p) c &&&\n    even\n     (changes_poly_at (pders p) d1 - changes_poly_at (pders p) c -\n      int (order c p))", "by auto"], ["proof (state)\nthis:\n  int (order c p) \\<le> changes_itv_der d1 c p\n  even (changes_itv_der d1 c p - int (order c p))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem budan_fourier_interval: \n  assumes \"a<b\" \"p\\<noteq>0\"\n  shows \"changes_itv_der a b p \\<ge> proots_count p {x. a< x \\<and> x\\<le> b} \\<and> \n          even (changes_itv_der a b p - proots_count p {x. a< x \\<and> x\\<le> b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x \\<le> b})\n    \\<le> changes_itv_der a b p \\<and>\n    even\n     (changes_itv_der a b p -\n      int (proots_count p {x. a < x \\<and> x \\<le> b}))", "using \\<open>a<b\\<close>"], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x \\<le> b})\n    \\<le> changes_itv_der a b p \\<and>\n    even\n     (changes_itv_der a b p -\n      int (proots_count p {x. a < x \\<and> x \\<le> b}))", "proof (induct \"card {x. \\<exists>p\\<in>set (pders p). poly p x=0 \\<and> a<x \\<and> x<b}\" arbitrary:b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>0 =\n                card\n                 {x. \\<exists>p\\<in>set (pders p).\n                        poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))\n 2. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "case 0"], ["proof (state)\nthis:\n  0 =\n  card\n   {x. \\<exists>p\\<in>set (pders p). poly p x = 0 \\<and> a < x \\<and> x < b}\n  a < b\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>0 =\n                card\n                 {x. \\<exists>p\\<in>set (pders p).\n                        poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))\n 2. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "have nzero:\"\\<forall>x. a<x \\<and> x<b \\<longrightarrow> (\\<forall>q\\<in>set (pders p). poly q x\\<noteq>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x < b \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x < b \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "define S where \"S={x. \\<exists>p\\<in>set (pders p). poly p x = 0 \\<and> a < x \\<and> x < b}\""], ["proof (state)\nthis:\n  S =\n  {x. \\<exists>p\\<in>set (pders p). poly p x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x < b \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "have \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite S", "have \"S \\<subseteq> (\\<Union>p\\<in>set (pders p). proots p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> \\<Union> (proots ` set (pders p))", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>p\\<in>set (pders p).\n           poly p x = 0 \\<and> a < x \\<and> x < b}\n    \\<subseteq> \\<Union> (proots ` set (pders p))", "by auto"], ["proof (state)\nthis:\n  S \\<subseteq> \\<Union> (proots ` set (pders p))\n\ngoal (1 subgoal):\n 1. finite S", "moreover"], ["proof (state)\nthis:\n  S \\<subseteq> \\<Union> (proots ` set (pders p))\n\ngoal (1 subgoal):\n 1. finite S", "have \"finite (\\<Union>p\\<in>set (pders p). proots p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (proots ` set (pders p)))", "apply (subst finite_UN)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (set (pders p))\n 2. \\<forall>x\\<in>set (pders p). finite (proots x)", "using set_pders_nzero[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  ?q \\<in> set (pders p) \\<Longrightarrow> ?q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. finite (set (pders p))\n 2. \\<forall>x\\<in>set (pders p). finite (proots x)", "by auto"], ["proof (state)\nthis:\n  finite (\\<Union> (proots ` set (pders p)))\n\ngoal (1 subgoal):\n 1. finite S", "ultimately"], ["proof (chain)\npicking this:\n  S \\<subseteq> \\<Union> (proots ` set (pders p))\n  finite (\\<Union> (proots ` set (pders p)))", "show ?thesis"], ["proof (prove)\nusing this:\n  S \\<subseteq> \\<Union> (proots ` set (pders p))\n  finite (\\<Union> (proots ` set (pders p)))\n\ngoal (1 subgoal):\n 1. finite S", "by (simp add: finite_subset)"], ["proof (state)\nthis:\n  finite S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x < b \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "moreover"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x < b \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "have \"card S = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card S = 0", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {x. \\<exists>p\\<in>set (pders p).\n            poly p x = 0 \\<and> a < x \\<and> x < b} =\n    0", "using 0"], ["proof (prove)\nusing this:\n  0 =\n  card\n   {x. \\<exists>p\\<in>set (pders p). poly p x = 0 \\<and> a < x \\<and> x < b}\n  a < b\n\ngoal (1 subgoal):\n 1. card\n     {x. \\<exists>p\\<in>set (pders p).\n            poly p x = 0 \\<and> a < x \\<and> x < b} =\n    0", "by auto"], ["proof (state)\nthis:\n  card S = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x < b \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "ultimately"], ["proof (chain)\npicking this:\n  finite S\n  card S = 0", "have \"S={}\""], ["proof (prove)\nusing this:\n  finite S\n  card S = 0\n\ngoal (1 subgoal):\n 1. S = {}", "by auto"], ["proof (state)\nthis:\n  S = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x < b \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "then"], ["proof (chain)\npicking this:\n  S = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  S = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x < b \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "unfolding S_def"], ["proof (prove)\nusing this:\n  {x. \\<exists>p\\<in>set (pders p).\n         poly p x = 0 \\<and> a < x \\<and> x < b} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x < b \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "using \\<open>a<b\\<close> assms(2) pders.simps"], ["proof (prove)\nusing this:\n  {x. \\<exists>p\\<in>set (pders p).\n         poly p x = 0 \\<and> a < x \\<and> x < b} =\n  {}\n  a < b\n  p \\<noteq> 0\n  pders ?p = (if ?p = 0 then [] else ?p # pders (pderiv ?p))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       a < x \\<and> x < b \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x.\n     a < x \\<and> x < b \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     a < x \\<and> x < b \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>0 =\n                card\n                 {x. \\<exists>p\\<in>set (pders p).\n                        poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))\n 2. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "from budan_fourier_aux_left[OF \\<open>a<b\\<close> \\<open>p\\<noteq>0\\<close> this]"], ["proof (chain)\npicking this:\n  int (order b p) \\<le> changes_itv_der a b p\n  even (changes_itv_der a b p - int (order b p))", "have \"order b p \\<le> changes_itv_der a b p\" \"even (changes_itv_der a b p - order b p)\""], ["proof (prove)\nusing this:\n  int (order b p) \\<le> changes_itv_der a b p\n  even (changes_itv_der a b p - int (order b p))\n\ngoal (1 subgoal):\n 1. int (order b p) \\<le> changes_itv_der a b p &&&\n    even (changes_itv_der a b p - int (order b p))", "by simp_all"], ["proof (state)\nthis:\n  int (order b p) \\<le> changes_itv_der a b p\n  even (changes_itv_der a b p - int (order b p))\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>0 =\n                card\n                 {x. \\<exists>p\\<in>set (pders p).\n                        poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))\n 2. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "moreover"], ["proof (state)\nthis:\n  int (order b p) \\<le> changes_itv_der a b p\n  even (changes_itv_der a b p - int (order b p))\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>0 =\n                card\n                 {x. \\<exists>p\\<in>set (pders p).\n                        poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))\n 2. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "have \"proots_count p {x. a< x \\<and> x\\<le> b} = order b p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} = order b p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} = order b p", "have p_cons:\"pders p=p#pders (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pders p = p # pders (pderiv p)", "by (simp add: assms(2) pders.simps)"], ["proof (state)\nthis:\n  pders p = p # pders (pderiv p)\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} = order b p", "have \"proots_within p {x. a < x \\<and> x \\<le> b} = (if poly p b=0 then {b} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p {x. a < x \\<and> x \\<le> b} =\n    (if poly p b = 0 then {b} else {})", "using nzero \\<open>a< b\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     a < x \\<and> x < b \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n  a < b\n\ngoal (1 subgoal):\n 1. proots_within p {x. a < x \\<and> x \\<le> b} =\n    (if poly p b = 0 then {b} else {})", "unfolding p_cons"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     a < x \\<and> x < b \\<longrightarrow>\n     (\\<forall>q\\<in>set (p # pders (pderiv p)). poly q x \\<noteq> 0)\n  a < b\n\ngoal (1 subgoal):\n 1. proots_within p {x. a < x \\<and> x \\<le> b} =\n    (if poly p b = 0 then {b} else {})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   a < x \\<and> x < b \\<longrightarrow>\n                   poly p x \\<noteq> 0 \\<and>\n                   (\\<forall>q\\<in>set (pders (pderiv p)).\n                       poly q x \\<noteq> 0);\n        poly p b \\<noteq> 0; poly p x = 0; a < x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> False", "using not_le"], ["proof (prove)\nusing this:\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   a < x \\<and> x < b \\<longrightarrow>\n                   poly p x \\<noteq> 0 \\<and>\n                   (\\<forall>q\\<in>set (pders (pderiv p)).\n                       poly q x \\<noteq> 0);\n        poly p b \\<noteq> 0; poly p x = 0; a < x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  proots_within p {x. a < x \\<and> x \\<le> b} =\n  (if poly p b = 0 then {b} else {})\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} = order b p", "then"], ["proof (chain)\npicking this:\n  proots_within p {x. a < x \\<and> x \\<le> b} =\n  (if poly p b = 0 then {b} else {})", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within p {x. a < x \\<and> x \\<le> b} =\n  (if poly p b = 0 then {b} else {})\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} = order b p", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within p {x. a < x \\<and> x \\<le> b} =\n  (if poly p b = 0 then {b} else {})\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p {x. a < x \\<and> x \\<le> b}. order r p) =\n    order b p", "using order_root"], ["proof (prove)\nusing this:\n  proots_within p {x. a < x \\<and> x \\<le> b} =\n  (if poly p b = 0 then {b} else {})\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p {x. a < x \\<and> x \\<le> b}. order r p) =\n    order b p", "by auto"], ["proof (state)\nthis:\n  proots_count p {x. a < x \\<and> x \\<le> b} = order b p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count p {x. a < x \\<and> x \\<le> b} = order b p\n\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>0 =\n                card\n                 {x. \\<exists>p\\<in>set (pders p).\n                        poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))\n 2. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "ultimately"], ["proof (chain)\npicking this:\n  int (order b p) \\<le> changes_itv_der a b p\n  even (changes_itv_der a b p - int (order b p))\n  proots_count p {x. a < x \\<and> x \\<le> b} = order b p", "show ?case"], ["proof (prove)\nusing this:\n  int (order b p) \\<le> changes_itv_der a b p\n  even (changes_itv_der a b p - int (order b p))\n  proots_count p {x. a < x \\<and> x \\<le> b} = order b p\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x \\<le> b})\n    \\<le> changes_itv_der a b p \\<and>\n    even\n     (changes_itv_der a b p -\n      int (proots_count p {x. a < x \\<and> x \\<le> b}))", "by auto"], ["proof (state)\nthis:\n  int (proots_count p {x. a < x \\<and> x \\<le> b})\n  \\<le> changes_itv_der a b p \\<and>\n  even\n   (changes_itv_der a b p -\n    int (proots_count p {x. a < x \\<and> x \\<le> b}))\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n =\n           card\n            {x. \\<exists>p\\<in>set (pders p).\n                   poly p x = 0 \\<and> a < x \\<and> x < ?b};\n   a < ?b\\<rbrakk>\n  \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> ?b})\n                    \\<le> changes_itv_der a ?b p \\<and>\n                    even\n                     (changes_itv_der a ?b p -\n                      int (proots_count p {x. a < x \\<and> x \\<le> ?b}))\n  Suc n =\n  card\n   {x. \\<exists>p\\<in>set (pders p). poly p x = 0 \\<and> a < x \\<and> x < b}\n  a < b\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "define P where \"P=(\\<lambda>x. \\<exists>p\\<in>set (pders p). poly p x = 0)\""], ["proof (state)\nthis:\n  P = (\\<lambda>x. \\<exists>p\\<in>set (pders p). poly p x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "define S where \"S=(\\<lambda>b. {x. P x \\<and> a < x \\<and> x < b})\""], ["proof (state)\nthis:\n  S = (\\<lambda>b. {x. P x \\<and> a < x \\<and> x < b})\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "define b' where \"b'=Max (S b)\""], ["proof (state)\nthis:\n  b' = Max (S b)\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "have f_S:\"finite (S x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (S x)", "have \"S x \\<subseteq> (\\<Union>p\\<in>set (pders p). proots p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S x \\<subseteq> \\<Union> (proots ` set (pders p))", "unfolding S_def P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa.\n     (\\<exists>p\\<in>set (pders p). poly p xa = 0) \\<and>\n     a < xa \\<and> xa < x}\n    \\<subseteq> \\<Union> (proots ` set (pders p))", "by auto"], ["proof (state)\nthis:\n  S x \\<subseteq> \\<Union> (proots ` set (pders p))\n\ngoal (1 subgoal):\n 1. finite (S x)", "moreover"], ["proof (state)\nthis:\n  S x \\<subseteq> \\<Union> (proots ` set (pders p))\n\ngoal (1 subgoal):\n 1. finite (S x)", "have \"finite (\\<Union>p\\<in>set (pders p). proots p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (proots ` set (pders p)))", "apply (subst finite_UN)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (set (pders p))\n 2. \\<forall>x\\<in>set (pders p). finite (proots x)", "using set_pders_nzero[OF \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  ?q \\<in> set (pders p) \\<Longrightarrow> ?q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. finite (set (pders p))\n 2. \\<forall>x\\<in>set (pders p). finite (proots x)", "by auto"], ["proof (state)\nthis:\n  finite (\\<Union> (proots ` set (pders p)))\n\ngoal (1 subgoal):\n 1. finite (S x)", "ultimately"], ["proof (chain)\npicking this:\n  S x \\<subseteq> \\<Union> (proots ` set (pders p))\n  finite (\\<Union> (proots ` set (pders p)))", "show ?thesis"], ["proof (prove)\nusing this:\n  S x \\<subseteq> \\<Union> (proots ` set (pders p))\n  finite (\\<Union> (proots ` set (pders p)))\n\ngoal (1 subgoal):\n 1. finite (S x)", "by (simp add: finite_subset)"], ["proof (state)\nthis:\n  finite (S x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (S ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "have \"b'\\<in>S b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' \\<in> S b", "unfolding b'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (S b) \\<in> S b", "apply (rule Max_in[OF f_S])"], ["proof (prove)\ngoal (1 subgoal):\n 1. S b \\<noteq> {}", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc n =\n  card\n   {x. \\<exists>p\\<in>set (pders p). poly p x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. S b \\<noteq> {}", "unfolding S_def P_def"], ["proof (prove)\nusing this:\n  Suc n =\n  card\n   {x. \\<exists>p\\<in>set (pders p). poly p x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. {x. (\\<exists>p\\<in>set (pders p). poly p x = 0) \\<and>\n        a < x \\<and> x < b} \\<noteq>\n    {}", "by force"], ["proof (state)\nthis:\n  b' \\<in> S b\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "then"], ["proof (chain)\npicking this:\n  b' \\<in> S b", "have \"a<b'\" \"b'<b\""], ["proof (prove)\nusing this:\n  b' \\<in> S b\n\ngoal (1 subgoal):\n 1. a < b' &&& b' < b", "unfolding S_def"], ["proof (prove)\nusing this:\n  b' \\<in> {x. P x \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. a < b' &&& b' < b", "by auto"], ["proof (state)\nthis:\n  a < b'\n  b' < b\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "have b'_nzero:\"\\<forall>x. b'<x \\<and> x<b \\<longrightarrow> (\\<forall>q\\<in>set (pders p). poly q x\\<noteq>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       b' < x \\<and> x < b \\<longrightarrow>\n       (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               b' < x \\<and> x < b \\<longrightarrow>\n               (\\<forall>q\\<in>set (pders p).\n                   poly q x \\<noteq> 0)) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>x. b' < x \\<and> x < b \\<longrightarrow> (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0))\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x.\n             b' < x \\<and> x < b \\<longrightarrow>\n             (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               b' < x \\<and> x < b \\<longrightarrow>\n               (\\<forall>q\\<in>set (pders p).\n                   poly q x \\<noteq> 0)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x.\n             b' < x \\<and> x < b \\<longrightarrow>\n             (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0))", "obtain bb where \"P bb\" \"b'<bb\" \"bb<b\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x.\n             b' < x \\<and> x < b \\<longrightarrow>\n             (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. (\\<And>bb.\n        \\<lbrakk>P bb; b' < bb; bb < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding P_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x.\n             b' < x \\<and> x < b \\<longrightarrow>\n             (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. (\\<And>bb.\n        \\<lbrakk>\\<exists>p\\<in>set (pders p). poly p bb = 0; b' < bb;\n         bb < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P bb\n  b' < bb\n  bb < b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               b' < x \\<and> x < b \\<longrightarrow>\n               (\\<forall>q\\<in>set (pders p).\n                   poly q x \\<noteq> 0)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  P bb\n  b' < bb\n  bb < b", "have \"bb\\<in>S b\""], ["proof (prove)\nusing this:\n  P bb\n  b' < bb\n  bb < b\n\ngoal (1 subgoal):\n 1. bb \\<in> S b", "unfolding S_def"], ["proof (prove)\nusing this:\n  P bb\n  b' < bb\n  bb < b\n\ngoal (1 subgoal):\n 1. bb \\<in> {x. P x \\<and> a < x \\<and> x < b}", "using \\<open>a<b'\\<close> \\<open>b'<b\\<close>"], ["proof (prove)\nusing this:\n  P bb\n  b' < bb\n  bb < b\n  a < b'\n  b' < b\n\ngoal (1 subgoal):\n 1. bb \\<in> {x. P x \\<and> a < x \\<and> x < b}", "by auto"], ["proof (state)\nthis:\n  bb \\<in> S b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               b' < x \\<and> x < b \\<longrightarrow>\n               (\\<forall>q\\<in>set (pders p).\n                   poly q x \\<noteq> 0)) \\<Longrightarrow>\n    False", "from Max_ge[OF f_S this, folded b'_def]"], ["proof (chain)\npicking this:\n  bb \\<le> b'", "have \"bb \\<le> b'\""], ["proof (prove)\nusing this:\n  bb \\<le> b'\n\ngoal (1 subgoal):\n 1. bb \\<le> b'", "."], ["proof (state)\nthis:\n  bb \\<le> b'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x.\n               b' < x \\<and> x < b \\<longrightarrow>\n               (\\<forall>q\\<in>set (pders p).\n                   poly q x \\<noteq> 0)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  bb \\<le> b'", "show False"], ["proof (prove)\nusing this:\n  bb \\<le> b'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>b'<bb\\<close>"], ["proof (prove)\nusing this:\n  bb \\<le> b'\n  b' < bb\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     b' < x \\<and> x < b \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "have hyps:\"proots_count p {x. a < x \\<and> x \\<le> b'} \\<le> changes_itv_der a b' p \\<and>\n                even (changes_itv_der a b' p - proots_count p {x. a < x \\<and> x \\<le> b'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x \\<le> b'})\n    \\<le> changes_itv_der a b' p \\<and>\n    even\n     (changes_itv_der a b' p -\n      int (proots_count p {x. a < x \\<and> x \\<le> b'}))", "proof (rule Suc(1)[OF _ \\<open>a<b'\\<close>])"], ["proof (state)\ngoal (1 subgoal):\n 1. n =\n    card\n     {x. \\<exists>p\\<in>set (pders p).\n            poly p x = 0 \\<and> a < x \\<and> x < b'}", "have \"S b= {b'} \\<union> S b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S b = {b'} \\<union> S b'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S b = {b'} \\<union> S b'", "have \"{x. P x \\<and> b' < x \\<and> x < b} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. P x \\<and> b' < x \\<and> x < b} = {}", "using b'_nzero"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     b' < x \\<and> x < b \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. {x. P x \\<and> b' < x \\<and> x < b} = {}", "unfolding P_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     b' < x \\<and> x < b \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. {x. (\\<exists>p\\<in>set (pders p). poly p x = 0) \\<and>\n        b' < x \\<and> x < b} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {x. P x \\<and> b' < x \\<and> x < b} = {}\n\ngoal (1 subgoal):\n 1. S b = {b'} \\<union> S b'", "then"], ["proof (chain)\npicking this:\n  {x. P x \\<and> b' < x \\<and> x < b} = {}", "have \"{x. P x\\<and> b' \\<le> x \\<and> x < b} = {b'}\""], ["proof (prove)\nusing this:\n  {x. P x \\<and> b' < x \\<and> x < b} = {}\n\ngoal (1 subgoal):\n 1. {x. P x \\<and> b' \\<le> x \\<and> x < b} = {b'}", "using \\<open>b'\\<in>S b\\<close>"], ["proof (prove)\nusing this:\n  {x. P x \\<and> b' < x \\<and> x < b} = {}\n  b' \\<in> S b\n\ngoal (1 subgoal):\n 1. {x. P x \\<and> b' \\<le> x \\<and> x < b} = {b'}", "unfolding S_def"], ["proof (prove)\nusing this:\n  {x. P x \\<and> b' < x \\<and> x < b} = {}\n  b' \\<in> {x. P x \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. {x. P x \\<and> b' \\<le> x \\<and> x < b} = {b'}", "by force"], ["proof (state)\nthis:\n  {x. P x \\<and> b' \\<le> x \\<and> x < b} = {b'}\n\ngoal (1 subgoal):\n 1. S b = {b'} \\<union> S b'", "moreover"], ["proof (state)\nthis:\n  {x. P x \\<and> b' \\<le> x \\<and> x < b} = {b'}\n\ngoal (1 subgoal):\n 1. S b = {b'} \\<union> S b'", "have \"S b= S b' \\<union>  {x. P x \\<and> b' \\<le> x \\<and> x < b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S b = S b' \\<union> {x. P x \\<and> b' \\<le> x \\<and> x < b}", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. P x \\<and> a < x \\<and> x < b} =\n    {x. P x \\<and> a < x \\<and> x < b'} \\<union>\n    {x. P x \\<and> b' \\<le> x \\<and> x < b}", "using \\<open>a<b'\\<close> \\<open>b'<b\\<close>"], ["proof (prove)\nusing this:\n  a < b'\n  b' < b\n\ngoal (1 subgoal):\n 1. {x. P x \\<and> a < x \\<and> x < b} =\n    {x. P x \\<and> a < x \\<and> x < b'} \\<union>\n    {x. P x \\<and> b' \\<le> x \\<and> x < b}", "by auto"], ["proof (state)\nthis:\n  S b = S b' \\<union> {x. P x \\<and> b' \\<le> x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. S b = {b'} \\<union> S b'", "ultimately"], ["proof (chain)\npicking this:\n  {x. P x \\<and> b' \\<le> x \\<and> x < b} = {b'}\n  S b = S b' \\<union> {x. P x \\<and> b' \\<le> x \\<and> x < b}", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. P x \\<and> b' \\<le> x \\<and> x < b} = {b'}\n  S b = S b' \\<union> {x. P x \\<and> b' \\<le> x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. S b = {b'} \\<union> S b'", "by auto"], ["proof (state)\nthis:\n  S b = {b'} \\<union> S b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S b = {b'} \\<union> S b'\n\ngoal (1 subgoal):\n 1. n =\n    card\n     {x. \\<exists>p\\<in>set (pders p).\n            poly p x = 0 \\<and> a < x \\<and> x < b'}", "moreover"], ["proof (state)\nthis:\n  S b = {b'} \\<union> S b'\n\ngoal (1 subgoal):\n 1. n =\n    card\n     {x. \\<exists>p\\<in>set (pders p).\n            poly p x = 0 \\<and> a < x \\<and> x < b'}", "have \"Suc n = card (S b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n = card (S b)", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc n =\n  card\n   {x. \\<exists>p\\<in>set (pders p). poly p x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. Suc n = card (S b)", "unfolding S_def P_def"], ["proof (prove)\nusing this:\n  Suc n =\n  card\n   {x. \\<exists>p\\<in>set (pders p). poly p x = 0 \\<and> a < x \\<and> x < b}\n\ngoal (1 subgoal):\n 1. Suc n =\n    card\n     {x. (\\<exists>p\\<in>set (pders p). poly p x = 0) \\<and>\n         a < x \\<and> x < b}", "by simp"], ["proof (state)\nthis:\n  Suc n = card (S b)\n\ngoal (1 subgoal):\n 1. n =\n    card\n     {x. \\<exists>p\\<in>set (pders p).\n            poly p x = 0 \\<and> a < x \\<and> x < b'}", "moreover"], ["proof (state)\nthis:\n  Suc n = card (S b)\n\ngoal (1 subgoal):\n 1. n =\n    card\n     {x. \\<exists>p\\<in>set (pders p).\n            poly p x = 0 \\<and> a < x \\<and> x < b'}", "have \"b'\\<notin>S b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' \\<notin> S b'", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b' \\<notin> {x. P x \\<and> a < x \\<and> x < b'}", "by auto"], ["proof (state)\nthis:\n  b' \\<notin> S b'\n\ngoal (1 subgoal):\n 1. n =\n    card\n     {x. \\<exists>p\\<in>set (pders p).\n            poly p x = 0 \\<and> a < x \\<and> x < b'}", "ultimately"], ["proof (chain)\npicking this:\n  S b = {b'} \\<union> S b'\n  Suc n = card (S b)\n  b' \\<notin> S b'", "have \"n=card (S b')\""], ["proof (prove)\nusing this:\n  S b = {b'} \\<union> S b'\n  Suc n = card (S b)\n  b' \\<notin> S b'\n\ngoal (1 subgoal):\n 1. n = card (S b')", "using f_S"], ["proof (prove)\nusing this:\n  S b = {b'} \\<union> S b'\n  Suc n = card (S b)\n  b' \\<notin> S b'\n  finite (S ?x)\n\ngoal (1 subgoal):\n 1. n = card (S b')", "by auto"], ["proof (state)\nthis:\n  n = card (S b')\n\ngoal (1 subgoal):\n 1. n =\n    card\n     {x. \\<exists>p\\<in>set (pders p).\n            poly p x = 0 \\<and> a < x \\<and> x < b'}", "then"], ["proof (chain)\npicking this:\n  n = card (S b')", "show \"n = card {x. \\<exists>p\\<in>set (pders p). poly p x = 0 \\<and> a < x \\<and> x < b'}\""], ["proof (prove)\nusing this:\n  n = card (S b')\n\ngoal (1 subgoal):\n 1. n =\n    card\n     {x. \\<exists>p\\<in>set (pders p).\n            poly p x = 0 \\<and> a < x \\<and> x < b'}", "unfolding S_def P_def"], ["proof (prove)\nusing this:\n  n =\n  card\n   {x. (\\<exists>p\\<in>set (pders p). poly p x = 0) \\<and>\n       a < x \\<and> x < b'}\n\ngoal (1 subgoal):\n 1. n =\n    card\n     {x. \\<exists>p\\<in>set (pders p).\n            poly p x = 0 \\<and> a < x \\<and> x < b'}", "by simp"], ["proof (state)\nthis:\n  n =\n  card\n   {x. \\<exists>p\\<in>set (pders p).\n          poly p x = 0 \\<and> a < x \\<and> x < b'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (proots_count p {x. a < x \\<and> x \\<le> b'})\n  \\<le> changes_itv_der a b' p \\<and>\n  even\n   (changes_itv_der a b' p -\n    int (proots_count p {x. a < x \\<and> x \\<le> b'}))\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "moreover"], ["proof (state)\nthis:\n  int (proots_count p {x. a < x \\<and> x \\<le> b'})\n  \\<le> changes_itv_der a b' p \\<and>\n  even\n   (changes_itv_der a b' p -\n    int (proots_count p {x. a < x \\<and> x \\<le> b'}))\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "have \"proots_count p {x. a < x \\<and> x \\<le> b} \n                    = proots_count p {x. a < x \\<and> x \\<le> b'} + order b p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} =\n    proots_count p {x. a < x \\<and> x \\<le> b'} + order b p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} =\n    proots_count p {x. a < x \\<and> x \\<le> b'} + order b p", "have p_cons:\"pders p=p#pders (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pders p = p # pders (pderiv p)", "by (simp add: assms(2) pders.simps)"], ["proof (state)\nthis:\n  pders p = p # pders (pderiv p)\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} =\n    proots_count p {x. a < x \\<and> x \\<le> b'} + order b p", "have \"proots_within p {x. b' < x \\<and> x \\<le> b} = (if poly p b=0 then {b} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_within p {x. b' < x \\<and> x \\<le> b} =\n    (if poly p b = 0 then {b} else {})", "using b'_nzero \\<open>b' < b\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     b' < x \\<and> x < b \\<longrightarrow>\n     (\\<forall>q\\<in>set (pders p). poly q x \\<noteq> 0)\n  b' < b\n\ngoal (1 subgoal):\n 1. proots_within p {x. b' < x \\<and> x \\<le> b} =\n    (if poly p b = 0 then {b} else {})", "unfolding p_cons"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     b' < x \\<and> x < b \\<longrightarrow>\n     (\\<forall>q\\<in>set (p # pders (pderiv p)). poly q x \\<noteq> 0)\n  b' < b\n\ngoal (1 subgoal):\n 1. proots_within p {x. b' < x \\<and> x \\<le> b} =\n    (if poly p b = 0 then {b} else {})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   b' < x \\<and> x < b \\<longrightarrow>\n                   poly p x \\<noteq> 0 \\<and>\n                   (\\<forall>q\\<in>set (pders (pderiv p)).\n                       poly q x \\<noteq> 0);\n        poly p b \\<noteq> 0; poly p x = 0; b' < x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> False", "using not_le"], ["proof (prove)\nusing this:\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   b' < x \\<and> x < b \\<longrightarrow>\n                   poly p x \\<noteq> 0 \\<and>\n                   (\\<forall>q\\<in>set (pders (pderiv p)).\n                       poly q x \\<noteq> 0);\n        poly p b \\<noteq> 0; poly p x = 0; b' < x; x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  proots_within p {x. b' < x \\<and> x \\<le> b} =\n  (if poly p b = 0 then {b} else {})\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} =\n    proots_count p {x. a < x \\<and> x \\<le> b'} + order b p", "then"], ["proof (chain)\npicking this:\n  proots_within p {x. b' < x \\<and> x \\<le> b} =\n  (if poly p b = 0 then {b} else {})", "have \"proots_count p {x. b' < x \\<and> x \\<le> b} = order b p\""], ["proof (prove)\nusing this:\n  proots_within p {x. b' < x \\<and> x \\<le> b} =\n  (if poly p b = 0 then {b} else {})\n\ngoal (1 subgoal):\n 1. proots_count p {x. b' < x \\<and> x \\<le> b} = order b p", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within p {x. b' < x \\<and> x \\<le> b} =\n  (if poly p b = 0 then {b} else {})\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p {x. b' < x \\<and> x \\<le> b}. order r p) =\n    order b p", "using order_root"], ["proof (prove)\nusing this:\n  proots_within p {x. b' < x \\<and> x \\<le> b} =\n  (if poly p b = 0 then {b} else {})\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> order ?a ?p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p {x. b' < x \\<and> x \\<le> b}. order r p) =\n    order b p", "by auto"], ["proof (state)\nthis:\n  proots_count p {x. b' < x \\<and> x \\<le> b} = order b p\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} =\n    proots_count p {x. a < x \\<and> x \\<le> b'} + order b p", "moreover"], ["proof (state)\nthis:\n  proots_count p {x. b' < x \\<and> x \\<le> b} = order b p\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} =\n    proots_count p {x. a < x \\<and> x \\<le> b'} + order b p", "have \"proots_count p {x. a < x \\<and> x \\<le> b} = proots_count p {x. a < x \\<and> x \\<le> b'} +\n            proots_count p {x. b' < x \\<and> x \\<le> b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} =\n    proots_count p {x. a < x \\<and> x \\<le> b'} +\n    proots_count p {x. b' < x \\<and> x \\<le> b}", "apply (subst proots_count_union_disjoint[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. {x. a < x \\<and> x \\<le> b'} \\<inter> {x. b' < x \\<and> x \\<le> b} = {}\n 2. p \\<noteq> 0\n 3. proots_count p {x. a < x \\<and> x \\<le> b} =\n    proots_count p\n     ({x. a < x \\<and> x \\<le> b'} \\<union> {x. b' < x \\<and> x \\<le> b})", "using \\<open>a<b'\\<close> \\<open>b'<b\\<close> \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  a < b'\n  b' < b\n  p \\<noteq> 0\n\ngoal (3 subgoals):\n 1. {x. a < x \\<and> x \\<le> b'} \\<inter> {x. b' < x \\<and> x \\<le> b} = {}\n 2. p \\<noteq> 0\n 3. proots_count p {x. a < x \\<and> x \\<le> b} =\n    proots_count p\n     ({x. a < x \\<and> x \\<le> b'} \\<union> {x. b' < x \\<and> x \\<le> b})", "by (auto intro:arg_cong2[where f=proots_count])"], ["proof (state)\nthis:\n  proots_count p {x. a < x \\<and> x \\<le> b} =\n  proots_count p {x. a < x \\<and> x \\<le> b'} +\n  proots_count p {x. b' < x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} =\n    proots_count p {x. a < x \\<and> x \\<le> b'} + order b p", "ultimately"], ["proof (chain)\npicking this:\n  proots_count p {x. b' < x \\<and> x \\<le> b} = order b p\n  proots_count p {x. a < x \\<and> x \\<le> b} =\n  proots_count p {x. a < x \\<and> x \\<le> b'} +\n  proots_count p {x. b' < x \\<and> x \\<le> b}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count p {x. b' < x \\<and> x \\<le> b} = order b p\n  proots_count p {x. a < x \\<and> x \\<le> b} =\n  proots_count p {x. a < x \\<and> x \\<le> b'} +\n  proots_count p {x. b' < x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x \\<and> x \\<le> b} =\n    proots_count p {x. a < x \\<and> x \\<le> b'} + order b p", "by auto"], ["proof (state)\nthis:\n  proots_count p {x. a < x \\<and> x \\<le> b} =\n  proots_count p {x. a < x \\<and> x \\<le> b'} + order b p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count p {x. a < x \\<and> x \\<le> b} =\n  proots_count p {x. a < x \\<and> x \\<le> b'} + order b p\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "moreover"], ["proof (state)\nthis:\n  proots_count p {x. a < x \\<and> x \\<le> b} =\n  proots_count p {x. a < x \\<and> x \\<le> b'} + order b p\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "note budan_fourier_aux_left[OF \\<open>b'<b\\<close> \\<open>p\\<noteq>0\\<close> b'_nzero]"], ["proof (state)\nthis:\n  int (order b p) \\<le> changes_itv_der b' b p\n  even (changes_itv_der b' b p - int (order b p))\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>x =\n                            card\n                             {x. \\<exists>p\\<in>set (pders p).\n                                    poly p x = 0 \\<and> a < x \\<and> x < b};\n                    a < b\\<rbrakk>\n                   \\<Longrightarrow> int\n(proots_count p {x. a < x \\<and> x \\<le> b})\n                                     \\<le> changes_itv_der a b p \\<and>\n                                     even\n(changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}));\n        Suc x =\n        card\n         {x. \\<exists>p\\<in>set (pders p).\n                poly p x = 0 \\<and> a < x \\<and> x < b};\n        a < b\\<rbrakk>\n       \\<Longrightarrow> int (proots_count p {x. a < x \\<and> x \\<le> b})\n                         \\<le> changes_itv_der a b p \\<and>\n                         even\n                          (changes_itv_der a b p -\n                           int (proots_count p {x. a < x \\<and> x \\<le> b}))", "ultimately"], ["proof (chain)\npicking this:\n  int (proots_count p {x. a < x \\<and> x \\<le> b'})\n  \\<le> changes_itv_der a b' p \\<and>\n  even\n   (changes_itv_der a b' p -\n    int (proots_count p {x. a < x \\<and> x \\<le> b'}))\n  proots_count p {x. a < x \\<and> x \\<le> b} =\n  proots_count p {x. a < x \\<and> x \\<le> b'} + order b p\n  int (order b p) \\<le> changes_itv_der b' b p\n  even (changes_itv_der b' b p - int (order b p))", "show ?case"], ["proof (prove)\nusing this:\n  int (proots_count p {x. a < x \\<and> x \\<le> b'})\n  \\<le> changes_itv_der a b' p \\<and>\n  even\n   (changes_itv_der a b' p -\n    int (proots_count p {x. a < x \\<and> x \\<le> b'}))\n  proots_count p {x. a < x \\<and> x \\<le> b} =\n  proots_count p {x. a < x \\<and> x \\<le> b'} + order b p\n  int (order b p) \\<le> changes_itv_der b' b p\n  even (changes_itv_der b' b p - int (order b p))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x \\<le> b})\n    \\<le> changes_itv_der a b p \\<and>\n    even\n     (changes_itv_der a b p -\n      int (proots_count p {x. a < x \\<and> x \\<le> b}))", "unfolding changes_itv_der_def Let_def"], ["proof (prove)\nusing this:\n  int (proots_count p {x. a < x \\<and> x \\<le> b'})\n  \\<le> changes_poly_at (pders p) a - changes_poly_at (pders p) b' \\<and>\n  even\n   (changes_poly_at (pders p) a - changes_poly_at (pders p) b' -\n    int (proots_count p {x. a < x \\<and> x \\<le> b'}))\n  proots_count p {x. a < x \\<and> x \\<le> b} =\n  proots_count p {x. a < x \\<and> x \\<le> b'} + order b p\n  int (order b p)\n  \\<le> changes_poly_at (pders p) b' - changes_poly_at (pders p) b\n  even\n   (changes_poly_at (pders p) b' - changes_poly_at (pders p) b -\n    int (order b p))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x \\<le> b})\n    \\<le> changes_poly_at (pders p) a - changes_poly_at (pders p) b \\<and>\n    even\n     (changes_poly_at (pders p) a - changes_poly_at (pders p) b -\n      int (proots_count p {x. a < x \\<and> x \\<le> b}))", "by auto"], ["proof (state)\nthis:\n  int (proots_count p {x. a < x \\<and> x \\<le> b})\n  \\<le> changes_itv_der a b p \\<and>\n  even\n   (changes_itv_der a b p -\n    int (proots_count p {x. a < x \\<and> x \\<le> b}))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem budan_fourier_gt: \n  assumes \"p\\<noteq>0\"\n  shows \"changes_gt_der a p \\<ge> proots_count p {x. a< x} \\<and> \n          even (changes_gt_der a p - proots_count p {x. a< x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) \\<le> changes_gt_der a p \\<and>\n    even (changes_gt_der a p - int (proots_count p {x. a < x}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) \\<le> changes_gt_der a p \\<and>\n    even (changes_gt_der a p - int (proots_count p {x. a < x}))", "define ps where \"ps=pders p\""], ["proof (state)\nthis:\n  ps = pders p\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) \\<le> changes_gt_der a p \\<and>\n    even (changes_gt_der a p - int (proots_count p {x. a < x}))", "obtain ub where ub_root:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\"\n    and ub_sgn:\"\\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\"\n    and \"a < ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         a < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_ub[of ps a] set_pders_nzero[OF \\<open>p\\<noteq>0\\<close>,folded ps_def]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<notin> set ps;\n   \\<And>ub.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n       \\<forall>x\\<ge>ub.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n       a < ub\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ?q \\<in> set ps \\<Longrightarrow> ?q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>ub.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub;\n         \\<forall>x\\<ge>ub.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p;\n         a < ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n  \\<forall>x\\<ge>ub. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_pos_inf p\n  a < ub\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) \\<le> changes_gt_der a p \\<and>\n    even (changes_gt_der a p - int (proots_count p {x. a < x}))", "have \"proots_count p {x. a< x} = proots_count p {x. a< x \\<and> x \\<le> ub}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x \\<le> ub}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x \\<le> ub}", "have \"p\\<in>set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set ps", "unfolding ps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set (pders p)", "by (simp add: assms pders.simps)"], ["proof (state)\nthis:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x \\<le> ub}", "then"], ["proof (chain)\npicking this:\n  p \\<in> set ps", "have \"proots_within p {x. a< x} = proots_within p {x. a< x \\<and> x\\<le>ub}\""], ["proof (prove)\nusing this:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. proots_within p {x. a < x} =\n    proots_within p {x. a < x \\<and> x \\<le> ub}", "using ub_root"], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x < ub\n\ngoal (1 subgoal):\n 1. proots_within p {x. a < x} =\n    proots_within p {x. a < x \\<and> x \\<le> ub}", "by fastforce"], ["proof (state)\nthis:\n  proots_within p {x. a < x} = proots_within p {x. a < x \\<and> x \\<le> ub}\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x \\<le> ub}", "then"], ["proof (chain)\npicking this:\n  proots_within p {x. a < x} = proots_within p {x. a < x \\<and> x \\<le> ub}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within p {x. a < x} = proots_within p {x. a < x \\<and> x \\<le> ub}\n\ngoal (1 subgoal):\n 1. proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x \\<le> ub}", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within p {x. a < x} = proots_within p {x. a < x \\<and> x \\<le> ub}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p (Collect ((<) a)). order r p) =\n    (\\<Sum>r\\<in>proots_within p {x. a < x \\<and> x \\<le> ub}. order r p)", "by auto"], ["proof (state)\nthis:\n  proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x \\<le> ub}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x \\<le> ub}\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) \\<le> changes_gt_der a p \\<and>\n    even (changes_gt_der a p - int (proots_count p {x. a < x}))", "moreover"], ["proof (state)\nthis:\n  proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x \\<le> ub}\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) \\<le> changes_gt_der a p \\<and>\n    even (changes_gt_der a p - int (proots_count p {x. a < x}))", "have \"changes_gt_der a p = changes_itv_der a ub p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_gt_der a p = changes_itv_der a ub p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_gt_der a p = changes_itv_der a ub p", "have \"map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps", "using ub_sgn[THEN spec,of ub,simplified]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. sgn (poly p ub) = sgn_pos_inf p\n\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps", "by (metis (mono_tags, lifting) comp_def list.map_cong0)"], ["proof (state)\nthis:\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_gt_der a p = changes_itv_der a ub p", "hence \"changes_poly_at ps ub=changes_poly_pos_inf ps\""], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_poly_at ps ub = changes_poly_pos_inf ps", "unfolding changes_poly_pos_inf_def changes_poly_at_def"], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p ub)) ps = map sgn_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p ub) ps) = changes (map sgn_pos_inf ps)", "by (subst changes_map_sgn_eq,metis map_map)"], ["proof (state)\nthis:\n  changes_poly_at ps ub = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_gt_der a p = changes_itv_der a ub p", "then"], ["proof (chain)\npicking this:\n  changes_poly_at ps ub = changes_poly_pos_inf ps", "have \"changes_poly_at ps ub=0\""], ["proof (prove)\nusing this:\n  changes_poly_at ps ub = changes_poly_pos_inf ps\n\ngoal (1 subgoal):\n 1. changes_poly_at ps ub = 0", "unfolding ps_def"], ["proof (prove)\nusing this:\n  changes_poly_at (pders p) ub = changes_poly_pos_inf (pders p)\n\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) ub = 0", "by simp"], ["proof (state)\nthis:\n  changes_poly_at ps ub = 0\n\ngoal (1 subgoal):\n 1. changes_gt_der a p = changes_itv_der a ub p", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at ps ub = 0\n\ngoal (1 subgoal):\n 1. changes_gt_der a p = changes_itv_der a ub p", "unfolding changes_gt_der_def changes_itv_der_def ps_def"], ["proof (prove)\nusing this:\n  changes_poly_at (pders p) ub = 0\n\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) a =\n    (let ps = pders p in changes_poly_at ps a - changes_poly_at ps ub)", "by (simp add:Let_def)"], ["proof (state)\nthis:\n  changes_gt_der a p = changes_itv_der a ub p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_gt_der a p = changes_itv_der a ub p\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) \\<le> changes_gt_der a p \\<and>\n    even (changes_gt_der a p - int (proots_count p {x. a < x}))", "moreover"], ["proof (state)\nthis:\n  changes_gt_der a p = changes_itv_der a ub p\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) \\<le> changes_gt_der a p \\<and>\n    even (changes_gt_der a p - int (proots_count p {x. a < x}))", "have \"proots_count p {x. a < x \\<and> x \\<le> ub} \\<le> changes_itv_der a ub p \\<and>\n      even (changes_itv_der a ub p - proots_count p {x. a < x \\<and> x \\<le> ub})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x \\<le> ub})\n    \\<le> changes_itv_der a ub p \\<and>\n    even\n     (changes_itv_der a ub p -\n      int (proots_count p {x. a < x \\<and> x \\<le> ub}))", "using budan_fourier_interval[OF \\<open>a<ub\\<close> \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  int (proots_count p {x. a < x \\<and> x \\<le> ub})\n  \\<le> changes_itv_der a ub p \\<and>\n  even\n   (changes_itv_der a ub p -\n    int (proots_count p {x. a < x \\<and> x \\<le> ub}))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x \\<le> ub})\n    \\<le> changes_itv_der a ub p \\<and>\n    even\n     (changes_itv_der a ub p -\n      int (proots_count p {x. a < x \\<and> x \\<le> ub}))", "."], ["proof (state)\nthis:\n  int (proots_count p {x. a < x \\<and> x \\<le> ub})\n  \\<le> changes_itv_der a ub p \\<and>\n  even\n   (changes_itv_der a ub p -\n    int (proots_count p {x. a < x \\<and> x \\<le> ub}))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) \\<le> changes_gt_der a p \\<and>\n    even (changes_gt_der a p - int (proots_count p {x. a < x}))", "ultimately"], ["proof (chain)\npicking this:\n  proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x \\<le> ub}\n  changes_gt_der a p = changes_itv_der a ub p\n  int (proots_count p {x. a < x \\<and> x \\<le> ub})\n  \\<le> changes_itv_der a ub p \\<and>\n  even\n   (changes_itv_der a ub p -\n    int (proots_count p {x. a < x \\<and> x \\<le> ub}))", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count p {x. a < x} = proots_count p {x. a < x \\<and> x \\<le> ub}\n  changes_gt_der a p = changes_itv_der a ub p\n  int (proots_count p {x. a < x \\<and> x \\<le> ub})\n  \\<le> changes_itv_der a ub p \\<and>\n  even\n   (changes_itv_der a ub p -\n    int (proots_count p {x. a < x \\<and> x \\<le> ub}))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x}) \\<le> changes_gt_der a p \\<and>\n    even (changes_gt_der a p - int (proots_count p {x. a < x}))", "by auto"], ["proof (state)\nthis:\n  int (proots_count p {x. a < x}) \\<le> changes_gt_der a p \\<and>\n  even (changes_gt_der a p - int (proots_count p {x. a < x}))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Descartes' rule of signs is a direct consequence of the Budan-Fourier theorem\\<close>"], ["", "theorem descartes_sign:\n  fixes p::\"real poly\"\n  assumes \"p\\<noteq>0\"\n  shows \" changes (coeffs p) \\<ge> proots_count p {x. 0 < x} \\<and> \n          even (changes (coeffs p) - proots_count p {x. 0< x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. 0 < x}) \\<le> changes (coeffs p) \\<and>\n    even (changes (coeffs p) - int (proots_count p {x. 0 < x}))", "using budan_fourier_gt[OF \\<open>p\\<noteq>0\\<close>,of 0]"], ["proof (prove)\nusing this:\n  int (proots_count p {x. 0 < x}) \\<le> changes_gt_der 0 p \\<and>\n  even (changes_gt_der 0 p - int (proots_count p {x. 0 < x}))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. 0 < x}) \\<le> changes (coeffs p) \\<and>\n    even (changes (coeffs p) - int (proots_count p {x. 0 < x}))", "unfolding changes_gt_der_def"], ["proof (prove)\nusing this:\n  int (proots_count p {x. 0 < x}) \\<le> changes_poly_at (pders p) 0 \\<and>\n  even (changes_poly_at (pders p) 0 - int (proots_count p {x. 0 < x}))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. 0 < x}) \\<le> changes (coeffs p) \\<and>\n    even (changes (coeffs p) - int (proots_count p {x. 0 < x}))", "by (simp add:changes_poly_at_pders_0)"], ["", "theorem budan_fourier_le: \n  assumes \"p\\<noteq>0\"\n  shows \"changes_le_der b p \\<ge> proots_count p {x. x \\<le>b} \\<and> \n          even (changes_le_der b p - proots_count p {x. x \\<le>b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> b}) \\<le> changes_le_der b p \\<and>\n    even (changes_le_der b p - int (proots_count p {x. x \\<le> b}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> b}) \\<le> changes_le_der b p \\<and>\n    even (changes_le_der b p - int (proots_count p {x. x \\<le> b}))", "define ps where \"ps=pders p\""], ["proof (state)\nthis:\n  ps = pders p\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> b}) \\<le> changes_le_der b p \\<and>\n    even (changes_le_der b p - int (proots_count p {x. x \\<le> b}))", "obtain lb where lb_root:\"\\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> x > lb\"\n    and lb_sgn:\"\\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\"\n    and \"lb < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using root_list_lb[of ps b] set_pders_nzero[OF \\<open>p\\<noteq>0\\<close>,folded ps_def]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<notin> set ps;\n   \\<And>lb.\n      \\<lbrakk>\\<forall>p\\<in>set ps.\n                  \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n       \\<forall>x\\<le>lb.\n          \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n       lb < b\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ?q \\<in> set ps \\<Longrightarrow> ?q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>lb.\n        \\<lbrakk>\\<forall>p\\<in>set ps.\n                    \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x;\n         \\<forall>x\\<le>lb.\n            \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p;\n         lb < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n  \\<forall>x\\<le>lb. \\<forall>p\\<in>set ps. sgn (poly p x) = sgn_neg_inf p\n  lb < b\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> b}) \\<le> changes_le_der b p \\<and>\n    even (changes_le_der b p - int (proots_count p {x. x \\<le> b}))", "have \"proots_count p {x. x \\<le>b} = proots_count p {x. lb< x \\<and> x \\<le> b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {x. x \\<le> b} =\n    proots_count p {x. lb < x \\<and> x \\<le> b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count p {x. x \\<le> b} =\n    proots_count p {x. lb < x \\<and> x \\<le> b}", "have \"p\\<in>set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set ps", "unfolding ps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set (pders p)", "by (simp add: assms pders.simps)"], ["proof (state)\nthis:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. proots_count p {x. x \\<le> b} =\n    proots_count p {x. lb < x \\<and> x \\<le> b}", "then"], ["proof (chain)\npicking this:\n  p \\<in> set ps", "have \"proots_within p {x. x \\<le>b} = proots_within p {x. lb< x \\<and> x\\<le>b}\""], ["proof (prove)\nusing this:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. proots_within p {x. x \\<le> b} =\n    proots_within p {x. lb < x \\<and> x \\<le> b}", "using lb_root"], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  \\<forall>p\\<in>set ps. \\<forall>x. poly p x = 0 \\<longrightarrow> lb < x\n\ngoal (1 subgoal):\n 1. proots_within p {x. x \\<le> b} =\n    proots_within p {x. lb < x \\<and> x \\<le> b}", "by fastforce"], ["proof (state)\nthis:\n  proots_within p {x. x \\<le> b} =\n  proots_within p {x. lb < x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. proots_count p {x. x \\<le> b} =\n    proots_count p {x. lb < x \\<and> x \\<le> b}", "then"], ["proof (chain)\npicking this:\n  proots_within p {x. x \\<le> b} =\n  proots_within p {x. lb < x \\<and> x \\<le> b}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_within p {x. x \\<le> b} =\n  proots_within p {x. lb < x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. proots_count p {x. x \\<le> b} =\n    proots_count p {x. lb < x \\<and> x \\<le> b}", "unfolding proots_count_def"], ["proof (prove)\nusing this:\n  proots_within p {x. x \\<le> b} =\n  proots_within p {x. lb < x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>proots_within p {x. x \\<le> b}. order r p) =\n    (\\<Sum>r\\<in>proots_within p {x. lb < x \\<and> x \\<le> b}. order r p)", "by auto"], ["proof (state)\nthis:\n  proots_count p {x. x \\<le> b} =\n  proots_count p {x. lb < x \\<and> x \\<le> b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count p {x. x \\<le> b} =\n  proots_count p {x. lb < x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> b}) \\<le> changes_le_der b p \\<and>\n    even (changes_le_der b p - int (proots_count p {x. x \\<le> b}))", "moreover"], ["proof (state)\nthis:\n  proots_count p {x. x \\<le> b} =\n  proots_count p {x. lb < x \\<and> x \\<le> b}\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> b}) \\<le> changes_le_der b p \\<and>\n    even (changes_le_der b p - int (proots_count p {x. x \\<le> b}))", "have \"changes_le_der b p = changes_itv_der lb b p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_le_der b p = changes_itv_der lb b p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. changes_le_der b p = changes_itv_der lb b p", "have \"map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps", "using lb_sgn[THEN spec,of lb,simplified]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps. sgn (poly p lb) = sgn_neg_inf p\n\ngoal (1 subgoal):\n 1. map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps", "by (metis (mono_tags, lifting) comp_def list.map_cong0)"], ["proof (state)\nthis:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_le_der b p = changes_itv_der lb b p", "hence \"changes_poly_at ps lb=changes_poly_neg_inf ps\""], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_poly_at ps lb = changes_poly_neg_inf ps", "unfolding changes_poly_neg_inf_def changes_poly_at_def"], ["proof (prove)\nusing this:\n  map (sgn \\<circ> (\\<lambda>p. poly p lb)) ps = map sgn_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes (map (\\<lambda>p. poly p lb) ps) = changes (map sgn_neg_inf ps)", "by (subst changes_map_sgn_eq,metis map_map)"], ["proof (state)\nthis:\n  changes_poly_at ps lb = changes_poly_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_le_der b p = changes_itv_der lb b p", "then"], ["proof (chain)\npicking this:\n  changes_poly_at ps lb = changes_poly_neg_inf ps", "have \"changes_poly_at ps lb=degree p\""], ["proof (prove)\nusing this:\n  changes_poly_at ps lb = changes_poly_neg_inf ps\n\ngoal (1 subgoal):\n 1. changes_poly_at ps lb = int (degree p)", "unfolding ps_def"], ["proof (prove)\nusing this:\n  changes_poly_at (pders p) lb = changes_poly_neg_inf (pders p)\n\ngoal (1 subgoal):\n 1. changes_poly_at (pders p) lb = int (degree p)", "by simp"], ["proof (state)\nthis:\n  changes_poly_at ps lb = int (degree p)\n\ngoal (1 subgoal):\n 1. changes_le_der b p = changes_itv_der lb b p", "thus ?thesis"], ["proof (prove)\nusing this:\n  changes_poly_at ps lb = int (degree p)\n\ngoal (1 subgoal):\n 1. changes_le_der b p = changes_itv_der lb b p", "unfolding changes_le_der_def changes_itv_der_def ps_def"], ["proof (prove)\nusing this:\n  changes_poly_at (pders p) lb = int (degree p)\n\ngoal (1 subgoal):\n 1. int (degree p) - changes_poly_at (pders p) b =\n    (let ps = pders p in changes_poly_at ps lb - changes_poly_at ps b)", "by (simp add:Let_def)"], ["proof (state)\nthis:\n  changes_le_der b p = changes_itv_der lb b p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  changes_le_der b p = changes_itv_der lb b p\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> b}) \\<le> changes_le_der b p \\<and>\n    even (changes_le_der b p - int (proots_count p {x. x \\<le> b}))", "moreover"], ["proof (state)\nthis:\n  changes_le_der b p = changes_itv_der lb b p\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> b}) \\<le> changes_le_der b p \\<and>\n    even (changes_le_der b p - int (proots_count p {x. x \\<le> b}))", "have \"proots_count p {x. lb < x \\<and> x \\<le> b} \\<le> changes_itv_der lb b p \\<and>\n      even (changes_itv_der lb b p - proots_count p {x. lb < x \\<and> x \\<le> b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. lb < x \\<and> x \\<le> b})\n    \\<le> changes_itv_der lb b p \\<and>\n    even\n     (changes_itv_der lb b p -\n      int (proots_count p {x. lb < x \\<and> x \\<le> b}))", "using budan_fourier_interval[OF \\<open>lb<b\\<close> \\<open>p\\<noteq>0\\<close>]"], ["proof (prove)\nusing this:\n  int (proots_count p {x. lb < x \\<and> x \\<le> b})\n  \\<le> changes_itv_der lb b p \\<and>\n  even\n   (changes_itv_der lb b p -\n    int (proots_count p {x. lb < x \\<and> x \\<le> b}))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. lb < x \\<and> x \\<le> b})\n    \\<le> changes_itv_der lb b p \\<and>\n    even\n     (changes_itv_der lb b p -\n      int (proots_count p {x. lb < x \\<and> x \\<le> b}))", "."], ["proof (state)\nthis:\n  int (proots_count p {x. lb < x \\<and> x \\<le> b})\n  \\<le> changes_itv_der lb b p \\<and>\n  even\n   (changes_itv_der lb b p -\n    int (proots_count p {x. lb < x \\<and> x \\<le> b}))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> b}) \\<le> changes_le_der b p \\<and>\n    even (changes_le_der b p - int (proots_count p {x. x \\<le> b}))", "ultimately"], ["proof (chain)\npicking this:\n  proots_count p {x. x \\<le> b} =\n  proots_count p {x. lb < x \\<and> x \\<le> b}\n  changes_le_der b p = changes_itv_der lb b p\n  int (proots_count p {x. lb < x \\<and> x \\<le> b})\n  \\<le> changes_itv_der lb b p \\<and>\n  even\n   (changes_itv_der lb b p -\n    int (proots_count p {x. lb < x \\<and> x \\<le> b}))", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count p {x. x \\<le> b} =\n  proots_count p {x. lb < x \\<and> x \\<le> b}\n  changes_le_der b p = changes_itv_der lb b p\n  int (proots_count p {x. lb < x \\<and> x \\<le> b})\n  \\<le> changes_itv_der lb b p \\<and>\n  even\n   (changes_itv_der lb b p -\n    int (proots_count p {x. lb < x \\<and> x \\<le> b}))\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> b}) \\<le> changes_le_der b p \\<and>\n    even (changes_le_der b p - int (proots_count p {x. x \\<le> b}))", "by auto"], ["proof (state)\nthis:\n  int (proots_count p {x. x \\<le> b}) \\<le> changes_le_der b p \\<and>\n  even (changes_le_der b p - int (proots_count p {x. x \\<le> b}))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Count exactly when all roots are real\\<close>"], ["", "definition all_roots_real:: \"real poly \\<Rightarrow> bool \" where \n  \"all_roots_real p = (\\<forall>r\\<in>proots (map_poly of_real p). Im r=0)\""], ["", "lemma all_roots_real_mult[simp]:\n  \"all_roots_real (p*q) \\<longleftrightarrow> all_roots_real p \\<and> all_roots_real q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_roots_real (p * q) = (all_roots_real p \\<and> all_roots_real q)", "unfolding all_roots_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>r\\<in>proots (map_poly complex_of_real (p * q)). Im r = 0) =\n    ((\\<forall>r\\<in>proots (map_poly complex_of_real p). Im r = 0) \\<and>\n     (\\<forall>r\\<in>proots (map_poly complex_of_real q). Im r = 0))", "by auto"], ["", "lemma all_roots_real_const_iff:\n  assumes all_real:\"all_roots_real p\"\n  shows \"degree p\\<noteq>0 \\<longleftrightarrow> (\\<exists>x. poly p x=0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (degree p \\<noteq> 0) = (\\<exists>x. poly p x = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p \\<noteq> 0 \\<Longrightarrow> \\<exists>x. poly p x = 0\n 2. \\<exists>x. poly p x = 0 \\<Longrightarrow> degree p \\<noteq> 0", "assume \"degree p \\<noteq> 0\""], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree p \\<noteq> 0 \\<Longrightarrow> \\<exists>x. poly p x = 0\n 2. \\<exists>x. poly p x = 0 \\<Longrightarrow> degree p \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree p \\<noteq> 0 \\<Longrightarrow> \\<exists>x. poly p x = 0\n 2. \\<exists>x. poly p x = 0 \\<Longrightarrow> degree p \\<noteq> 0", "have \"degree p=0\" when \"\\<forall>x. poly p x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p = 0", "define pp where \"pp=map_poly complex_of_real p\""], ["proof (state)\nthis:\n  pp = map_poly complex_of_real p\n\ngoal (1 subgoal):\n 1. degree p = 0", "have \"\\<forall>x. poly pp x\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. poly pp x \\<noteq> 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. poly pp x \\<noteq> 0) \\<Longrightarrow> False", "assume \"\\<not> (\\<forall>x. poly pp x \\<noteq> 0)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x. poly pp x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. poly pp x \\<noteq> 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x. poly pp x \\<noteq> 0)", "obtain x where \"poly pp x=0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x. poly pp x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>x. poly pp x = 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly pp x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. poly pp x \\<noteq> 0) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  poly pp x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. poly pp x \\<noteq> 0) \\<Longrightarrow> False", "have \"Im x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x = 0", "using all_real[unfolded all_roots_real_def, rule_format,of x,folded pp_def] \\<open>poly pp x=0\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> proots pp \\<Longrightarrow> Im x = 0\n  poly pp x = 0\n\ngoal (1 subgoal):\n 1. Im x = 0", "by auto"], ["proof (state)\nthis:\n  Im x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. poly pp x \\<noteq> 0) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  poly pp x = 0\n  Im x = 0", "have \"poly pp (of_real (Re x)) = 0\""], ["proof (prove)\nusing this:\n  poly pp x = 0\n  Im x = 0\n\ngoal (1 subgoal):\n 1. poly pp (complex_of_real (Re x)) = 0", "by (simp add: complex_is_Real_iff)"], ["proof (state)\nthis:\n  poly pp (complex_of_real (Re x)) = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. poly pp x \\<noteq> 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly pp (complex_of_real (Re x)) = 0", "have \"poly p (Re x) = 0\""], ["proof (prove)\nusing this:\n  poly pp (complex_of_real (Re x)) = 0\n\ngoal (1 subgoal):\n 1. poly p (Re x) = 0", "unfolding pp_def"], ["proof (prove)\nusing this:\n  poly (map_poly complex_of_real p) (complex_of_real (Re x)) = 0\n\ngoal (1 subgoal):\n 1. poly p (Re x) = 0", "by (metis Re_complex_of_real of_real_poly_map_poly zero_complex.simps(1))"], ["proof (state)\nthis:\n  poly p (Re x) = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. poly pp x \\<noteq> 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly p (Re x) = 0", "show False"], ["proof (prove)\nusing this:\n  poly p (Re x) = 0\n\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  poly p (Re x) = 0\n  \\<forall>x. poly p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x. poly pp x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. poly pp x \\<noteq> 0", "obtain a where \"pp=[:of_real a:]\" \"a\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<forall>x. poly pp x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>pp = [:complex_of_real a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>degree p \\<noteq> 0\\<close> constant_degree degree_map_poly \n            fundamental_theorem_of_algebra of_real_eq_0_iff pp_def)"], ["proof (state)\nthis:\n  pp = [:complex_of_real a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = 0", "then"], ["proof (chain)\npicking this:\n  pp = [:complex_of_real a:]\n  a \\<noteq> 0", "have \"p=[:a:]\""], ["proof (prove)\nusing this:\n  pp = [:complex_of_real a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p = [:a:]", "unfolding pp_def"], ["proof (prove)\nusing this:\n  map_poly complex_of_real p = [:complex_of_real a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p = [:a:]", "by (metis map_poly_0 map_poly_pCons of_real_0 of_real_poly_eq_iff)"], ["proof (state)\nthis:\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. degree p = 0", "then"], ["proof (chain)\npicking this:\n  p = [:a:]", "show ?thesis"], ["proof (prove)\nusing this:\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. degree p = 0", "by auto"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x. poly p x \\<noteq> 0 \\<Longrightarrow> degree p = 0\n\ngoal (2 subgoals):\n 1. degree p \\<noteq> 0 \\<Longrightarrow> \\<exists>x. poly p x = 0\n 2. \\<exists>x. poly p x = 0 \\<Longrightarrow> degree p \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 0\n  \\<forall>x. poly p x \\<noteq> 0 \\<Longrightarrow> degree p = 0", "show \"\\<exists>x. poly p x = 0\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n  \\<forall>x. poly p x \\<noteq> 0 \\<Longrightarrow> degree p = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0 \\<Longrightarrow> degree p \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0 \\<Longrightarrow> degree p \\<noteq> 0", "assume \"\\<exists>x. poly p x = 0\""], ["proof (state)\nthis:\n  \\<exists>x. poly p x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = 0 \\<Longrightarrow> degree p \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. poly p x = 0", "show \"degree p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>x. poly p x = 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "by (metis UNIV_I all_roots_real_def assms degree_pCons_eq_if \n        imaginary_unit.sel(2) map_poly_0 nat.simps(3) order_root pCons_eq_0_iff \n        proots_within_iff synthetic_div_eq_0_iff synthetic_div_pCons zero_neq_one)"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_roots_real_degree:\n  assumes \"all_roots_real p\" \n  shows \"proots_count p UNIV =degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p UNIV = degree p", "using assms"], ["proof (prove)\nusing this:\n  all_roots_real p\n\ngoal (1 subgoal):\n 1. proots_count p UNIV = degree p", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. all_roots_real 0 \\<Longrightarrow> proots_count 0 UNIV = degree 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> proots_count p UNIV = degree p\n 3. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "case 0"], ["proof (state)\nthis:\n  all_roots_real 0\n\ngoal (3 subgoals):\n 1. all_roots_real 0 \\<Longrightarrow> proots_count 0 UNIV = degree 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> proots_count p UNIV = degree p\n 3. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "then"], ["proof (chain)\npicking this:\n  all_roots_real 0", "have False"], ["proof (prove)\nusing this:\n  all_roots_real 0\n\ngoal (1 subgoal):\n 1. False", "using imaginary_unit.sel(2)"], ["proof (prove)\nusing this:\n  all_roots_real 0\n  Im \\<i> = 1\n\ngoal (1 subgoal):\n 1. False", "unfolding all_roots_real_def"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>proots (map_poly complex_of_real 0). Im r = 0\n  Im \\<i> = 1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. all_roots_real 0 \\<Longrightarrow> proots_count 0 UNIV = degree 0\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> proots_count p UNIV = degree p\n 3. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "then"], ["proof (chain)\npicking this:\n  False", "show ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. proots_count 0 UNIV = degree 0", "by simp"], ["proof (state)\nthis:\n  proots_count 0 UNIV = degree 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> proots_count p UNIV = degree p\n 2. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> proots_count p UNIV = degree p\n 2. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> 0\n  all_roots_real p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> proots_count p UNIV = degree p\n 2. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "from all_roots_real_const_iff[OF this(2)] this(1)"], ["proof (chain)\npicking this:\n  (degree p \\<noteq> 0) = (\\<exists>x. poly p x = 0)\n  poly p ?a \\<noteq> 0", "have \"degree p=0\""], ["proof (prove)\nusing this:\n  (degree p \\<noteq> 0) = (\\<exists>x. poly p x = 0)\n  poly p ?a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = 0", "by auto"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> proots_count p UNIV = degree p\n 2. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "then"], ["proof (chain)\npicking this:\n  degree p = 0", "obtain a where \"p=[:a:]\" \"a\\<noteq>0\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>p = [:a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis degree_eq_zeroE no_proots.hyps poly_const_conv)"], ["proof (state)\nthis:\n  p = [:a:]\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> proots_count p UNIV = degree p\n 2. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "then"], ["proof (chain)\npicking this:\n  p = [:a:]\n  a \\<noteq> 0", "have \"proots p={}\""], ["proof (prove)\nusing this:\n  p = [:a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots p = {}", "by auto"], ["proof (state)\nthis:\n  proots p = {}\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> proots_count p UNIV = degree p\n 2. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "then"], ["proof (chain)\npicking this:\n  proots p = {}", "show ?case"], ["proof (prove)\nusing this:\n  proots p = {}\n\ngoal (1 subgoal):\n 1. proots_count p UNIV = degree p", "using \\<open>p=[:a:]\\<close>"], ["proof (prove)\nusing this:\n  proots p = {}\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. proots_count p UNIV = degree p", "by (simp add:proots_count_def)"], ["proof (state)\nthis:\n  proots_count p UNIV = degree p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "case (root a p)"], ["proof (state)\nthis:\n  all_roots_real p \\<Longrightarrow> proots_count p UNIV = degree p\n  all_roots_real ([:- a, 1:] * p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "define a1 where \"a1=[:- a, 1:]\""], ["proof (state)\nthis:\n  a1 = [:- a, 1:]\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "have \"p\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using root.prems"], ["proof (prove)\nusing this:\n  all_roots_real ([:- a, 1:] * p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_roots_real 0; p = 0\\<rbrakk> \\<Longrightarrow> False", "using imaginary_unit.sel(2)"], ["proof (prove)\nusing this:\n  Im \\<i> = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>all_roots_real 0; p = 0\\<rbrakk> \\<Longrightarrow> False", "unfolding all_roots_real_def"], ["proof (prove)\nusing this:\n  Im \\<i> = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r\\<in>proots (map_poly complex_of_real 0). Im r = 0;\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "have \"a1\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a1 \\<noteq> 0", "unfolding a1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- a, 1:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "have \"proots_count (a1 * p) UNIV = proots_count a1 UNIV + proots_count p UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count (a1 * p) UNIV = proots_count a1 UNIV + proots_count p UNIV", "using \\<open>p\\<noteq>0\\<close> \\<open>a1\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  a1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proots_count (a1 * p) UNIV = proots_count a1 UNIV + proots_count p UNIV", "by (subst proots_count_times,auto)"], ["proof (state)\nthis:\n  proots_count (a1 * p) UNIV = proots_count a1 UNIV + proots_count p UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "also"], ["proof (state)\nthis:\n  proots_count (a1 * p) UNIV = proots_count a1 UNIV + proots_count p UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "have \"... = 1 + degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count a1 UNIV + proots_count p UNIV = 1 + degree p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proots_count a1 UNIV + proots_count p UNIV = 1 + degree p", "have \"proots_count a1 UNIV = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count a1 UNIV = 1", "unfolding a1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count [:- a, 1:] UNIV = 1", "by (simp add: proots_count_pCons_1_iff)"], ["proof (state)\nthis:\n  proots_count a1 UNIV = 1\n\ngoal (1 subgoal):\n 1. proots_count a1 UNIV + proots_count p UNIV = 1 + degree p", "moreover"], ["proof (state)\nthis:\n  proots_count a1 UNIV = 1\n\ngoal (1 subgoal):\n 1. proots_count a1 UNIV + proots_count p UNIV = 1 + degree p", "have hyps:\"proots_count p UNIV = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p UNIV = degree p", "apply (rule root.hyps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_roots_real p", "using root.prems[folded a1_def]"], ["proof (prove)\nusing this:\n  all_roots_real (a1 * p)\n\ngoal (1 subgoal):\n 1. all_roots_real p", "unfolding all_roots_real_def"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>proots (map_poly complex_of_real (a1 * p)). Im r = 0\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>proots (map_poly complex_of_real p). Im r = 0", "by auto"], ["proof (state)\nthis:\n  proots_count p UNIV = degree p\n\ngoal (1 subgoal):\n 1. proots_count a1 UNIV + proots_count p UNIV = 1 + degree p", "ultimately"], ["proof (chain)\npicking this:\n  proots_count a1 UNIV = 1\n  proots_count p UNIV = degree p", "show ?thesis"], ["proof (prove)\nusing this:\n  proots_count a1 UNIV = 1\n  proots_count p UNIV = degree p\n\ngoal (1 subgoal):\n 1. proots_count a1 UNIV + proots_count p UNIV = 1 + degree p", "by auto"], ["proof (state)\nthis:\n  proots_count a1 UNIV + proots_count p UNIV = 1 + degree p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proots_count a1 UNIV + proots_count p UNIV = 1 + degree p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "also"], ["proof (state)\nthis:\n  proots_count a1 UNIV + proots_count p UNIV = 1 + degree p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "have \"... = degree (a1*p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + degree p = degree (a1 * p)", "apply (subst degree_mult_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. a1 \\<noteq> 0\n 2. p \\<noteq> 0\n 3. 1 + degree p = degree a1 + degree p", "using \\<open>a1\\<noteq>0\\<close> \\<open>p\\<noteq>0\\<close>"], ["proof (prove)\nusing this:\n  a1 \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (3 subgoals):\n 1. a1 \\<noteq> 0\n 2. p \\<noteq> 0\n 3. 1 + degree p = degree a1 + degree p", "unfolding a1_def"], ["proof (prove)\nusing this:\n  [:- a, 1:] \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (3 subgoals):\n 1. [:- a, 1:] \\<noteq> 0\n 2. p \\<noteq> 0\n 3. 1 + degree p = degree [:- a, 1:] + degree p", "by auto"], ["proof (state)\nthis:\n  1 + degree p = degree (a1 * p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                proots_count p UNIV = degree p;\n        all_roots_real ([:- a, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> proots_count ([:- a, 1:] * p) UNIV =\n                         degree ([:- a, 1:] * p)", "finally"], ["proof (chain)\npicking this:\n  proots_count (a1 * p) UNIV = degree (a1 * p)", "show ?case"], ["proof (prove)\nusing this:\n  proots_count (a1 * p) UNIV = degree (a1 * p)\n\ngoal (1 subgoal):\n 1. proots_count ([:- a, 1:] * p) UNIV = degree ([:- a, 1:] * p)", "unfolding a1_def"], ["proof (prove)\nusing this:\n  proots_count ([:- a, 1:] * p) UNIV = degree ([:- a, 1:] * p)\n\ngoal (1 subgoal):\n 1. proots_count ([:- a, 1:] * p) UNIV = degree ([:- a, 1:] * p)", "."], ["proof (state)\nthis:\n  proots_count ([:- a, 1:] * p) UNIV = degree ([:- a, 1:] * p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_real_roots_mobius:\n  fixes a b::real \n  assumes \"all_roots_real p\" and \"a<b\"\n  shows \"all_roots_real (fcompose p [:a,b:] [:1,1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_roots_real (fcompose p [:a, b:] [:1, 1:])", "using assms(1)"], ["proof (prove)\nusing this:\n  all_roots_real p\n\ngoal (1 subgoal):\n 1. all_roots_real (fcompose p [:a, b:] [:1, 1:])", "proof (induct p rule:poly_root_induct_alt)"], ["proof (state)\ngoal (3 subgoals):\n 1. all_roots_real 0 \\<Longrightarrow>\n    all_roots_real (fcompose 0 [:a, b:] [:1, 1:])\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> all_roots_real (fcompose p [:a, b:] [:1, 1:])\n 3. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "case 0"], ["proof (state)\nthis:\n  all_roots_real 0\n\ngoal (3 subgoals):\n 1. all_roots_real 0 \\<Longrightarrow>\n    all_roots_real (fcompose 0 [:a, b:] [:1, 1:])\n 2. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> all_roots_real (fcompose p [:a, b:] [:1, 1:])\n 3. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "then"], ["proof (chain)\npicking this:\n  all_roots_real 0", "show ?case"], ["proof (prove)\nusing this:\n  all_roots_real 0\n\ngoal (1 subgoal):\n 1. all_roots_real (fcompose 0 [:a, b:] [:1, 1:])", "by simp"], ["proof (state)\nthis:\n  all_roots_real (fcompose 0 [:a, b:] [:1, 1:])\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> all_roots_real (fcompose p [:a, b:] [:1, 1:])\n 2. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> all_roots_real (fcompose p [:a, b:] [:1, 1:])\n 2. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "case (no_proots p)"], ["proof (state)\nthis:\n  poly p ?a \\<noteq> 0\n  all_roots_real p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> all_roots_real (fcompose p [:a, b:] [:1, 1:])\n 2. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "from all_roots_real_const_iff[OF this(2)] this(1)"], ["proof (chain)\npicking this:\n  (degree p \\<noteq> 0) = (\\<exists>x. poly p x = 0)\n  poly p ?a \\<noteq> 0", "have \"degree p=0\""], ["proof (prove)\nusing this:\n  (degree p \\<noteq> 0) = (\\<exists>x. poly p x = 0)\n  poly p ?a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = 0", "by auto"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> all_roots_real (fcompose p [:a, b:] [:1, 1:])\n 2. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "then"], ["proof (chain)\npicking this:\n  degree p = 0", "obtain a where \"p=[:a:]\" \"a\\<noteq>0\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>p = [:a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis degree_eq_zeroE no_proots.hyps poly_const_conv)"], ["proof (state)\nthis:\n  p = [:a:]\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>a. poly p a \\<noteq> 0; all_roots_real p\\<rbrakk>\n       \\<Longrightarrow> all_roots_real (fcompose p [:a, b:] [:1, 1:])\n 2. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "then"], ["proof (chain)\npicking this:\n  p = [:a:]\n  a \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  p = [:a:]\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. all_roots_real (fcompose p [:a, b:] [:1, 1:])", "by (auto simp add:all_roots_real_def)"], ["proof (state)\nthis:\n  all_roots_real (fcompose p [:a, b:] [:1, 1:])\n\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "case (root x p)"], ["proof (state)\nthis:\n  all_roots_real p \\<Longrightarrow>\n  all_roots_real (fcompose p [:a, b:] [:1, 1:])\n  all_roots_real ([:- x, 1:] * p)\n\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "define x1 where \"x1=[:- x, 1:]\""], ["proof (state)\nthis:\n  x1 = [:- x, 1:]\n\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "define fx where \"fx=fcompose x1 [:a, b:] [:1, 1:]\""], ["proof (state)\nthis:\n  fx = fcompose x1 [:a, b:] [:1, 1:]\n\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "have \"all_roots_real fx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_roots_real fx", "proof (cases \"x=b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = b \\<Longrightarrow> all_roots_real fx\n 2. x \\<noteq> b \\<Longrightarrow> all_roots_real fx", "case True"], ["proof (state)\nthis:\n  x = b\n\ngoal (2 subgoals):\n 1. x = b \\<Longrightarrow> all_roots_real fx\n 2. x \\<noteq> b \\<Longrightarrow> all_roots_real fx", "then"], ["proof (chain)\npicking this:\n  x = b", "have \"fx = [:a-x:]\" \"a\\<noteq>x\""], ["proof (prove)\nusing this:\n  x = b\n\ngoal (1 subgoal):\n 1. fx = [:a - x:] &&& a \\<noteq> x", "subgoal"], ["proof (prove)\nusing this:\n  x = b\n\ngoal (1 subgoal):\n 1. fx = [:a - x:]", "unfolding fx_def"], ["proof (prove)\nusing this:\n  x = b\n\ngoal (1 subgoal):\n 1. fcompose x1 [:a, b:] [:1, 1:] = [:a - x:]", "by (simp add:fcompose_def smult_add_right x1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> x", "using \\<open>a<b\\<close> True"], ["proof (prove)\nusing this:\n  a < b\n  x = b\n\ngoal (1 subgoal):\n 1. a \\<noteq> x", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fx = [:a - x:]\n  a \\<noteq> x\n\ngoal (2 subgoals):\n 1. x = b \\<Longrightarrow> all_roots_real fx\n 2. x \\<noteq> b \\<Longrightarrow> all_roots_real fx", "then"], ["proof (chain)\npicking this:\n  fx = [:a - x:]\n  a \\<noteq> x", "have \"proots (map_poly complex_of_real fx) = {}\""], ["proof (prove)\nusing this:\n  fx = [:a - x:]\n  a \\<noteq> x\n\ngoal (1 subgoal):\n 1. proots (map_poly complex_of_real fx) = {}", "by auto"], ["proof (state)\nthis:\n  proots (map_poly complex_of_real fx) = {}\n\ngoal (2 subgoals):\n 1. x = b \\<Longrightarrow> all_roots_real fx\n 2. x \\<noteq> b \\<Longrightarrow> all_roots_real fx", "then"], ["proof (chain)\npicking this:\n  proots (map_poly complex_of_real fx) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots (map_poly complex_of_real fx) = {}\n\ngoal (1 subgoal):\n 1. all_roots_real fx", "unfolding all_roots_real_def"], ["proof (prove)\nusing this:\n  proots (map_poly complex_of_real fx) = {}\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>proots (map_poly complex_of_real fx). Im r = 0", "by auto"], ["proof (state)\nthis:\n  all_roots_real fx\n\ngoal (1 subgoal):\n 1. x \\<noteq> b \\<Longrightarrow> all_roots_real fx", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> b \\<Longrightarrow> all_roots_real fx", "case False"], ["proof (state)\nthis:\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. x \\<noteq> b \\<Longrightarrow> all_roots_real fx", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> b", "have \"fx = [:a-x,b-x:]\""], ["proof (prove)\nusing this:\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. fx = [:a - x, b - x:]", "unfolding fx_def"], ["proof (prove)\nusing this:\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. fcompose x1 [:a, b:] [:1, 1:] = [:a - x, b - x:]", "by (simp add:fcompose_def smult_add_right x1_def)"], ["proof (state)\nthis:\n  fx = [:a - x, b - x:]\n\ngoal (1 subgoal):\n 1. x \\<noteq> b \\<Longrightarrow> all_roots_real fx", "then"], ["proof (chain)\npicking this:\n  fx = [:a - x, b - x:]", "have \"proots (map_poly complex_of_real fx) = {of_real ((x-a)/(b-x))}\""], ["proof (prove)\nusing this:\n  fx = [:a - x, b - x:]\n\ngoal (1 subgoal):\n 1. proots (map_poly complex_of_real fx) =\n    {complex_of_real ((x - a) / (b - x))}", "using False"], ["proof (prove)\nusing this:\n  fx = [:a - x, b - x:]\n  x \\<noteq> b\n\ngoal (1 subgoal):\n 1. proots (map_poly complex_of_real fx) =\n    {complex_of_real ((x - a) / (b - x))}", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  proots (map_poly complex_of_real fx) =\n  {complex_of_real ((x - a) / (b - x))}\n\ngoal (1 subgoal):\n 1. x \\<noteq> b \\<Longrightarrow> all_roots_real fx", "then"], ["proof (chain)\npicking this:\n  proots (map_poly complex_of_real fx) =\n  {complex_of_real ((x - a) / (b - x))}", "show ?thesis"], ["proof (prove)\nusing this:\n  proots (map_poly complex_of_real fx) =\n  {complex_of_real ((x - a) / (b - x))}\n\ngoal (1 subgoal):\n 1. all_roots_real fx", "unfolding all_roots_real_def"], ["proof (prove)\nusing this:\n  proots (map_poly complex_of_real fx) =\n  {complex_of_real ((x - a) / (b - x))}\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>proots (map_poly complex_of_real fx). Im r = 0", "by auto"], ["proof (state)\nthis:\n  all_roots_real fx\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  all_roots_real fx\n\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "moreover"], ["proof (state)\nthis:\n  all_roots_real fx\n\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "have \"all_roots_real (fcompose p [:a, b:] [:1, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_roots_real (fcompose p [:a, b:] [:1, 1:])", "using root[folded x1_def] all_roots_real_mult"], ["proof (prove)\nusing this:\n  all_roots_real p \\<Longrightarrow>\n  all_roots_real (fcompose p [:a, b:] [:1, 1:])\n  all_roots_real (x1 * p)\n  all_roots_real (?p * ?q) = (all_roots_real ?p \\<and> all_roots_real ?q)\n\ngoal (1 subgoal):\n 1. all_roots_real (fcompose p [:a, b:] [:1, 1:])", "by auto"], ["proof (state)\nthis:\n  all_roots_real (fcompose p [:a, b:] [:1, 1:])\n\ngoal (1 subgoal):\n 1. \\<And>aa p.\n       \\<lbrakk>all_roots_real p \\<Longrightarrow>\n                all_roots_real (fcompose p [:a, b:] [:1, 1:]);\n        all_roots_real ([:- aa, 1:] * p)\\<rbrakk>\n       \\<Longrightarrow> all_roots_real\n                          (fcompose ([:- aa, 1:] * p) [:a, b:] [:1, 1:])", "ultimately"], ["proof (chain)\npicking this:\n  all_roots_real fx\n  all_roots_real (fcompose p [:a, b:] [:1, 1:])", "show ?case"], ["proof (prove)\nusing this:\n  all_roots_real fx\n  all_roots_real (fcompose p [:a, b:] [:1, 1:])\n\ngoal (1 subgoal):\n 1. all_roots_real (fcompose ([:- x, 1:] * p) [:a, b:] [:1, 1:])", "apply (fold x1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>all_roots_real fx;\n     all_roots_real (fcompose p [:a, b:] [:1, 1:])\\<rbrakk>\n    \\<Longrightarrow> all_roots_real (fcompose (x1 * p) [:a, b:] [:1, 1:])", "by (auto simp add:fcompose_mult fx_def)"], ["proof (state)\nthis:\n  all_roots_real (fcompose ([:- x, 1:] * p) [:a, b:] [:1, 1:])\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If all roots are real, we can use the \n      Budan-Fourier theorem to EXACTLY count the number of real roots.\\<close>"], ["", "corollary budan_fourier_real:\n  assumes \"p\\<noteq>0\" \n  assumes \"all_roots_real p\"\n  shows \"proots_count p {x. x \\<le>a} = changes_le_der a p\"\n        \"a<b \\<Longrightarrow> proots_count p {x. a <x \\<and> x \\<le>b} = changes_itv_der a b p\"\n        \"proots_count p {x. b <x} = changes_gt_der b p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p &&&\n    (a < b \\<Longrightarrow>\n     int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n     changes_itv_der a b p) &&&\n    int (proots_count p {x. b < x}) = changes_gt_der b p", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p\n 2. a < b \\<Longrightarrow>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) = changes_itv_der a b p\n 3. int (proots_count p {x. b < x}) = changes_gt_der b p", "have *:\"proots_count p {x. x \\<le>a} = changes_le_der a p\n        \\<and> proots_count p {x. a <x \\<and> x \\<le>b} = changes_itv_der a b p\n        \\<and> proots_count p {x. b <x} = changes_gt_der b p\"\n    when \"a<b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n    changes_itv_der a b p \\<and>\n    int (proots_count p {x. b < x}) = changes_gt_der b p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n    changes_itv_der a b p \\<and>\n    int (proots_count p {x. b < x}) = changes_gt_der b p", "define c1 c2 c3 where \n      \"c1=changes_le_der a p - proots_count p {x. x \\<le>a}\" and\n      \"c2=changes_itv_der a b p - proots_count p {x. a <x \\<and> x \\<le>b}\" and\n      \"c3=changes_gt_der b p - proots_count p {x. b <x}\""], ["proof (state)\nthis:\n  c1 = changes_le_der a p - int (proots_count p {x. x \\<le> a})\n  c2 =\n  changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b})\n  c3 = changes_gt_der b p - int (proots_count p {x. b < x})\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n    changes_itv_der a b p \\<and>\n    int (proots_count p {x. b < x}) = changes_gt_der b p", "have \"c1\\<ge>0\" \"c2\\<ge>0\" \"c3\\<ge>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> c1 &&& 0 \\<le> c2 &&& 0 \\<le> c3", "using budan_fourier_interval[OF \\<open>a<b\\<close> \\<open>p\\<noteq>0\\<close>] budan_fourier_gt[OF \\<open>p\\<noteq>0\\<close>,of b]\n          budan_fourier_le[OF \\<open>p\\<noteq>0\\<close>,of a]"], ["proof (prove)\nusing this:\n  int (proots_count p {x. a < x \\<and> x \\<le> b})\n  \\<le> changes_itv_der a b p \\<and>\n  even\n   (changes_itv_der a b p -\n    int (proots_count p {x. a < x \\<and> x \\<le> b}))\n  int (proots_count p {x. b < x}) \\<le> changes_gt_der b p \\<and>\n  even (changes_gt_der b p - int (proots_count p {x. b < x}))\n  int (proots_count p {x. x \\<le> a}) \\<le> changes_le_der a p \\<and>\n  even (changes_le_der a p - int (proots_count p {x. x \\<le> a}))\n\ngoal (1 subgoal):\n 1. 0 \\<le> c1 &&& 0 \\<le> c2 &&& 0 \\<le> c3", "unfolding c1_def c2_def c3_def"], ["proof (prove)\nusing this:\n  int (proots_count p {x. a < x \\<and> x \\<le> b})\n  \\<le> changes_itv_der a b p \\<and>\n  even\n   (changes_itv_der a b p -\n    int (proots_count p {x. a < x \\<and> x \\<le> b}))\n  int (proots_count p {x. b < x}) \\<le> changes_gt_der b p \\<and>\n  even (changes_gt_der b p - int (proots_count p {x. b < x}))\n  int (proots_count p {x. x \\<le> a}) \\<le> changes_le_der a p \\<and>\n  even (changes_le_der a p - int (proots_count p {x. x \\<le> a}))\n\ngoal (1 subgoal):\n 1. 0 \\<le> changes_le_der a p - int (proots_count p {x. x \\<le> a}) &&&\n    0 \\<le> changes_itv_der a b p -\n            int (proots_count p {x. a < x \\<and> x \\<le> b}) &&&\n    0 \\<le> changes_gt_der b p - int (proots_count p (Collect ((<) b)))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> c1\n  0 \\<le> c2\n  0 \\<le> c3\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n    changes_itv_der a b p \\<and>\n    int (proots_count p {x. b < x}) = changes_gt_der b p", "moreover"], ["proof (state)\nthis:\n  0 \\<le> c1\n  0 \\<le> c2\n  0 \\<le> c3\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n    changes_itv_der a b p \\<and>\n    int (proots_count p {x. b < x}) = changes_gt_der b p", "have \"c1+c2+c3=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 + c2 + c3 = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c1 + c2 + c3 = 0", "have proots_deg:\"proots_count p UNIV =degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p UNIV = degree p", "using all_roots_real_degree[OF \\<open>all_roots_real p\\<close>]"], ["proof (prove)\nusing this:\n  proots_count p UNIV = degree p\n\ngoal (1 subgoal):\n 1. proots_count p UNIV = degree p", "."], ["proof (state)\nthis:\n  proots_count p UNIV = degree p\n\ngoal (1 subgoal):\n 1. c1 + c2 + c3 = 0", "have \"changes_le_der a p + changes_itv_der a b p + changes_gt_der b p = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. changes_le_der a p + changes_itv_der a b p + changes_gt_der b p =\n    int (degree p)", "unfolding changes_le_der_def changes_itv_der_def changes_gt_der_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (degree p) - changes_poly_at (pders p) a +\n    (let ps = pders p in changes_poly_at ps a - changes_poly_at ps b) +\n    changes_poly_at (pders p) b =\n    int (degree p)", "by (auto simp add:Let_def)"], ["proof (state)\nthis:\n  changes_le_der a p + changes_itv_der a b p + changes_gt_der b p =\n  int (degree p)\n\ngoal (1 subgoal):\n 1. c1 + c2 + c3 = 0", "moreover"], ["proof (state)\nthis:\n  changes_le_der a p + changes_itv_der a b p + changes_gt_der b p =\n  int (degree p)\n\ngoal (1 subgoal):\n 1. c1 + c2 + c3 = 0", "have \"proots_count p {x. x \\<le>a} + proots_count p {x. a <x \\<and> x \\<le>b} \n          + proots_count p {x. b <x} = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proots_count p {x. x \\<le> a} +\n    proots_count p {x. a < x \\<and> x \\<le> b} +\n    proots_count p {x. b < x} =\n    degree p", "using \\<open>p\\<noteq>0\\<close> \\<open>a<b\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  a < b\n\ngoal (1 subgoal):\n 1. proots_count p {x. x \\<le> a} +\n    proots_count p {x. a < x \\<and> x \\<le> b} +\n    proots_count p {x. b < x} =\n    degree p", "apply (subst proots_count_union_disjoint[symmetric],auto)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; a < b\\<rbrakk>\n    \\<Longrightarrow> proots_count p\n                       ({x. x \\<le> a} \\<union>\n                        {x. a < x \\<and> x \\<le> b} \\<union>\n                        Collect ((<) b)) =\n                      degree p", "apply (subst proots_deg[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; a < b\\<rbrakk>\n    \\<Longrightarrow> proots_count p\n                       ({x. x \\<le> a} \\<union>\n                        {x. a < x \\<and> x \\<le> b} \\<union>\n                        Collect ((<) b)) =\n                      proots_count p UNIV", "by (auto intro!:arg_cong2[where f=proots_count])"], ["proof (state)\nthis:\n  proots_count p {x. x \\<le> a} +\n  proots_count p {x. a < x \\<and> x \\<le> b} +\n  proots_count p {x. b < x} =\n  degree p\n\ngoal (1 subgoal):\n 1. c1 + c2 + c3 = 0", "ultimately"], ["proof (chain)\npicking this:\n  changes_le_der a p + changes_itv_der a b p + changes_gt_der b p =\n  int (degree p)\n  proots_count p {x. x \\<le> a} +\n  proots_count p {x. a < x \\<and> x \\<le> b} +\n  proots_count p {x. b < x} =\n  degree p", "show ?thesis"], ["proof (prove)\nusing this:\n  changes_le_der a p + changes_itv_der a b p + changes_gt_der b p =\n  int (degree p)\n  proots_count p {x. x \\<le> a} +\n  proots_count p {x. a < x \\<and> x \\<le> b} +\n  proots_count p {x. b < x} =\n  degree p\n\ngoal (1 subgoal):\n 1. c1 + c2 + c3 = 0", "unfolding c1_def c2_def c3_def"], ["proof (prove)\nusing this:\n  changes_le_der a p + changes_itv_der a b p + changes_gt_der b p =\n  int (degree p)\n  proots_count p {x. x \\<le> a} +\n  proots_count p {x. a < x \\<and> x \\<le> b} +\n  proots_count p {x. b < x} =\n  degree p\n\ngoal (1 subgoal):\n 1. changes_le_der a p - int (proots_count p {x. x \\<le> a}) +\n    (changes_itv_der a b p -\n     int (proots_count p {x. a < x \\<and> x \\<le> b})) +\n    (changes_gt_der b p - int (proots_count p (Collect ((<) b)))) =\n    0", "by (auto simp add:algebra_simps)"], ["proof (state)\nthis:\n  c1 + c2 + c3 = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c1 + c2 + c3 = 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n    changes_itv_der a b p \\<and>\n    int (proots_count p {x. b < x}) = changes_gt_der b p", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> c1\n  0 \\<le> c2\n  0 \\<le> c3\n  c1 + c2 + c3 = 0", "have \"c1 =0 \\<and> c2=0 \\<and> c3=0\""], ["proof (prove)\nusing this:\n  0 \\<le> c1\n  0 \\<le> c2\n  0 \\<le> c3\n  c1 + c2 + c3 = 0\n\ngoal (1 subgoal):\n 1. c1 = 0 \\<and> c2 = 0 \\<and> c3 = 0", "by auto"], ["proof (state)\nthis:\n  c1 = 0 \\<and> c2 = 0 \\<and> c3 = 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n    changes_itv_der a b p \\<and>\n    int (proots_count p {x. b < x}) = changes_gt_der b p", "then"], ["proof (chain)\npicking this:\n  c1 = 0 \\<and> c2 = 0 \\<and> c3 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c1 = 0 \\<and> c2 = 0 \\<and> c3 = 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n    changes_itv_der a b p \\<and>\n    int (proots_count p {x. b < x}) = changes_gt_der b p", "unfolding c1_def c2_def c3_def"], ["proof (prove)\nusing this:\n  changes_le_der a p - int (proots_count p {x. x \\<le> a}) = 0 \\<and>\n  changes_itv_der a b p - int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n  0 \\<and>\n  changes_gt_der b p - int (proots_count p (Collect ((<) b))) = 0\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n    changes_itv_der a b p \\<and>\n    int (proots_count p {x. b < x}) = changes_gt_der b p", "by auto"], ["proof (state)\nthis:\n  int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n  int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n  changes_itv_der a b p \\<and>\n  int (proots_count p {x. b < x}) = changes_gt_der b p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a < ?b \\<Longrightarrow>\n  int (proots_count p {x. x \\<le> ?a}) = changes_le_der ?a p \\<and>\n  int (proots_count p {x. ?a < x \\<and> x \\<le> ?b}) =\n  changes_itv_der ?a ?b p \\<and>\n  int (proots_count p {x. ?b < x}) = changes_gt_der ?b p\n\ngoal (3 subgoals):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p\n 2. a < b \\<Longrightarrow>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) = changes_itv_der a b p\n 3. int (proots_count p {x. b < x}) = changes_gt_der b p", "show \"proots_count p {x. x \\<le>a} = changes_le_der a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p", "using *[of a \"a+1\"]"], ["proof (prove)\nusing this:\n  a < a + 1 \\<Longrightarrow>\n  int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n  int (proots_count p {x. a < x \\<and> x \\<le> a + 1}) =\n  changes_itv_der a (a + 1) p \\<and>\n  int (proots_count p {x. a + 1 < x}) = changes_gt_der (a + 1) p\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. x \\<le> a}) = changes_le_der a p", "by auto"], ["proof (state)\nthis:\n  int (proots_count p {x. x \\<le> a}) = changes_le_der a p\n\ngoal (2 subgoals):\n 1. a < b \\<Longrightarrow>\n    int (proots_count p {x. a < x \\<and> x \\<le> b}) = changes_itv_der a b p\n 2. int (proots_count p {x. b < x}) = changes_gt_der b p", "show \"proots_count p {x. a <x \\<and> x \\<le>b} = changes_itv_der a b p\" when \"a<b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x \\<le> b}) = changes_itv_der a b p", "using *[OF that]"], ["proof (prove)\nusing this:\n  int (proots_count p {x. x \\<le> a}) = changes_le_der a p \\<and>\n  int (proots_count p {x. a < x \\<and> x \\<le> b}) =\n  changes_itv_der a b p \\<and>\n  int (proots_count p {x. b < x}) = changes_gt_der b p\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. a < x \\<and> x \\<le> b}) = changes_itv_der a b p", "by auto"], ["proof (state)\nthis:\n  a < b \\<Longrightarrow>\n  int (proots_count p {x. a < x \\<and> x \\<le> b}) = changes_itv_der a b p\n\ngoal (2 subgoals):\n 1. a < b \\<Longrightarrow> a < b\n 2. int (proots_count p {x. b < x}) = changes_gt_der b p", "show \"proots_count p {x. b <x} = changes_gt_der b p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. b < x}) = changes_gt_der b p", "using *[of \"b-1\" b]"], ["proof (prove)\nusing this:\n  b - 1 < b \\<Longrightarrow>\n  int (proots_count p {x. x \\<le> b - 1}) = changes_le_der (b - 1) p \\<and>\n  int (proots_count p {x. b - 1 < x \\<and> x \\<le> b}) =\n  changes_itv_der (b - 1) b p \\<and>\n  int (proots_count p {x. b < x}) = changes_gt_der b p\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. b < x}) = changes_gt_der b p", "by auto"], ["proof (state)\nthis:\n  int (proots_count p {x. b < x}) = changes_gt_der b p\n\ngoal (1 subgoal):\n 1. a < b \\<Longrightarrow> a < b", "qed"], ["", "text \\<open>Similarly, Descartes' rule of sign counts exactly when all roots are real.\\<close>"], ["", "corollary descartes_sign_real:\n  fixes p::\"real poly\" and a b::real\n  assumes \"p\\<noteq>0\" \n  assumes \"all_roots_real p\"\n  shows \"proots_count p {x. 0 < x} = changes (coeffs p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (proots_count p {x. 0 < x}) = changes (coeffs p)", "using budan_fourier_real(3)[OF \\<open>p\\<noteq>0\\<close> \\<open>all_roots_real p\\<close>]"], ["proof (prove)\nusing this:\n  int (proots_count p {x. ?b < x}) = changes_gt_der ?b p\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. 0 < x}) = changes (coeffs p)", "unfolding changes_gt_der_def"], ["proof (prove)\nusing this:\n  int (proots_count p {x. ?b < x}) = changes_poly_at (pders p) ?b\n\ngoal (1 subgoal):\n 1. int (proots_count p {x. 0 < x}) = changes (coeffs p)", "by (simp add:changes_poly_at_pders_0)"], ["", "end"]]}