{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Algebra/ex/capDL/Separation_D.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Algebra", "problem_names": ["lemma sep_map_general_def2:\n  \"sep_map_general p obj gs s =\n   (dom (sep_heap s) = {p} \\<and> ko_at obj p (sep_heap s) \\<and> sep_ghost_state s p = gs)\""], "translations": [["", "lemma sep_map_general_def2:\n  \"sep_map_general p obj gs s =\n   (dom (sep_heap s) = {p} \\<and> ko_at obj p (sep_heap s) \\<and> sep_ghost_state s p = gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sep_map_general p obj gs s =\n    (dom (sep_heap s) = {p} \\<and>\n     ko_at obj p (sep_heap s) \\<and> sep_ghost_state s p = gs)", "apply (clarsimp simp: sep_map_general_def object_at_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sep_heap s = [p \\<mapsto> obj] \\<and> sep_ghost_state s p = gs) =\n    (dom (sep_heap s) = {p} \\<and>\n     sep_heap s p = Some obj \\<and> sep_ghost_state s p = gs)", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sep_heap s = [p \\<mapsto> obj] \\<and>\n    sep_ghost_state s p = gs \\<Longrightarrow>\n    dom (sep_heap s) = {p} \\<and>\n    sep_heap s p = Some obj \\<and> sep_ghost_state s p = gs\n 2. dom (sep_heap s) = {p} \\<and>\n    sep_heap s p = Some obj \\<and>\n    sep_ghost_state s p = gs \\<Longrightarrow>\n    sep_heap s = [p \\<mapsto> obj] \\<and> sep_ghost_state s p = gs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (sep_heap s) = {p} \\<and>\n    sep_heap s p = Some obj \\<and>\n    sep_ghost_state s p = gs \\<Longrightarrow>\n    sep_heap s = [p \\<mapsto> obj] \\<and> sep_ghost_state s p = gs", "apply (clarsimp simp: fun_upd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom (sep_heap s) = {p}; sep_heap s p = Some obj;\n     gs = sep_ghost_state s p\\<rbrakk>\n    \\<Longrightarrow> sep_heap s =\n                      (\\<lambda>x. if x = p then Some obj else None)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dom (sep_heap s) = {p}; sep_heap s p = Some obj;\n        gs = sep_ghost_state s p\\<rbrakk>\n       \\<Longrightarrow> sep_heap s x = (if x = p then Some obj else None)", "apply (fastforce simp: dom_def split:if_split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* There is an object there. *)"], ["", "definition\n  sep_map_i :: \"cdl_object_id \\<Rightarrow> cdl_object \\<Rightarrow> sep_pred\" (\"_ \\<mapsto>i _\" [76,71] 76)\nwhere\n  \"p \\<mapsto>i obj \\<equiv> sep_map_general p obj UNIV\""], ["", "(* The fields are there (and there are no caps). *)"], ["", "definition\n  sep_map_f :: \"cdl_object_id \\<Rightarrow> cdl_object \\<Rightarrow> sep_pred\" (\"_ \\<mapsto>f _\" [76,71] 76)\nwhere\n  \"p \\<mapsto>f obj \\<equiv> sep_map_general p (update_slots Map.empty obj) {None}\""], ["", "(* There is that cap there. *)"], ["", "definition\n  sep_map_c :: \"cdl_cap_ref \\<Rightarrow> cdl_cap \\<Rightarrow> sep_pred\" (\"_ \\<mapsto>c _\" [76,71] 76)\nwhere\n  \"p \\<mapsto>c cap \\<equiv> \\<lambda>s. let (obj_id, slot) = p; heap = sep_heap s in\n  \\<exists>obj. sep_map_general obj_id obj {Some slot} s \\<and> object_slots obj = [slot \\<mapsto> cap]\""], ["", "definition\n  sep_any :: \"('a \\<Rightarrow> 'b \\<Rightarrow> sep_pred) \\<Rightarrow> ('a \\<Rightarrow> sep_pred)\" where\n  \"sep_any m \\<equiv> (\\<lambda>p s. \\<exists>v. (m p v) s)\""], ["", "abbreviation \"sep_any_map_i \\<equiv> sep_any sep_map_i\""], ["", "notation sep_any_map_i (\"_ \\<mapsto>i -\" 76)"], ["", "abbreviation \"sep_any_map_c \\<equiv> sep_any sep_map_c\""], ["", "notation sep_any_map_c (\"_ \\<mapsto>c -\" 76)"], ["", "end"]]}