{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Algebra/ex/Sep_Tactics_Test.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Algebra", "problem_names": ["lemma\n  \"\\<lbrakk> Q2 (val h p); (K ** T ** blub ** P ** points_to p v ** P ** J) h \\<rbrakk>\n   \\<Longrightarrow> Q (val h p) (val h p)\"", "lemma\n  \"\\<lbrakk> Q2 (val h p); (K ** T ** blub ** P ** points_to p v ** P ** J) h \\<rbrakk>\n   \\<Longrightarrow> Q (val h p) (val h p)\"", "lemma\n  \"\\<lbrakk> Q2 (val h p); (K ** T ** blub ** P ** points_to p v ** P ** J) h \\<rbrakk>\n   \\<Longrightarrow> Q (val h p) (val h p)\"", "lemma \"\\<lbrakk> unrelated s ; (P ** Q ** R) s \\<rbrakk> \\<Longrightarrow> (A ** B ** Q ** P) s\"", "lemma \"(A ** B ** Q ** P) s\"", "lemma \"\\<lbrakk> also unrelated; (A ** B ** Q ** P) s \\<rbrakk> \\<Longrightarrow> unrelated\"", "lemma\n  assumes forward: \"\\<And>s g p v. A g p v s \\<Longrightarrow> AA g p s \"\n  shows \"\\<And>xv yv P s y x s. (A g x yv ** A g y yv ** P) s \\<Longrightarrow> (AA g y ** sep_true) s\"", "lemma\n  assumes forward: \"\\<And>s. generic s \\<Longrightarrow> instance s\"\n  shows \"(A ** generic ** B) s \\<Longrightarrow> (instance ** sep_true) s\"", "lemma \"\\<lbrakk> (A ** B) sa ; (A ** Y) s \\<rbrakk> \\<Longrightarrow> (A ** X) s\"", "lemma \"\\<lbrakk> (A ** B) sa ; (A ** Y) s \\<rbrakk> \\<Longrightarrow> (\\<lambda>s. (A ** X) s) s\"", "lemma\n  assumes forward: \"\\<And>s. generic s \\<Longrightarrow> instance s\"\n  shows \"\\<lbrakk> (A ** B) s ; (generic ** Y) s \\<rbrakk> \\<Longrightarrow> (X ** instance) s\"", "lemma\n  assumes forward: \"\\<And>s. generic s \\<Longrightarrow> instance s\"\n  shows \"generic s \\<Longrightarrow> instance s\"", "lemma\n  assumes forward: \"\\<And>s. generic s \\<Longrightarrow> instance s\"\n  assumes forward2: \"\\<And>s. instance s \\<Longrightarrow> instance2 s\"\n  shows \"generic s \\<Longrightarrow> (instance2 ** sep_true) s\""], "translations": [["", "lemma\n  \"\\<lbrakk> Q2 (val h p); (K ** T ** blub ** P ** points_to p v ** P ** J) h \\<rbrakk>\n   \\<Longrightarrow> Q (val h p) (val h p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q2 (val h p);\n     (K \\<and>*\n      T \\<and>* blub \\<and>* P \\<and>* points_to p v \\<and>* P \\<and>* J)\n      h\\<rbrakk>\n    \\<Longrightarrow> Q (val h p) (val h p)", "apply (sep_subst (2) points_to)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q2 (val h p);\n     (K \\<and>*\n      T \\<and>* blub \\<and>* P \\<and>* points_to p v \\<and>* P \\<and>* J)\n      h\\<rbrakk>\n    \\<Longrightarrow> Q (val h p) v", "apply (sep_subst (asm) points_to)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q2 v;\n     (K \\<and>*\n      T \\<and>* blub \\<and>* P \\<and>* points_to p v \\<and>* P \\<and>* J)\n      h\\<rbrakk>\n    \\<Longrightarrow> Q (val h p) v", "apply (sep_subst points_to)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q2 v;\n     (K \\<and>*\n      T \\<and>* blub \\<and>* P \\<and>* points_to p v \\<and>* P \\<and>* J)\n      h\\<rbrakk>\n    \\<Longrightarrow> Q v v", "oops"], ["", "lemma\n  \"\\<lbrakk> Q2 (val h p); (K ** T ** blub ** P ** points_to p v ** P ** J) h \\<rbrakk>\n   \\<Longrightarrow> Q (val h p) (val h p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q2 (val h p);\n     (K \\<and>*\n      T \\<and>* blub \\<and>* P \\<and>* points_to p v \\<and>* P \\<and>* J)\n      h\\<rbrakk>\n    \\<Longrightarrow> Q (val h p) (val h p)", "apply (sep_drule points_to)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q2 (val h p); val h p = v\\<rbrakk>\n    \\<Longrightarrow> Q (val h p) (val h p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q2 v; val h p = v\\<rbrakk> \\<Longrightarrow> Q v v", "oops"], ["", "lemma\n  \"\\<lbrakk> Q2 (val h p); (K ** T ** blub ** P ** points_to p v ** P ** J) h \\<rbrakk>\n   \\<Longrightarrow> Q (val h p) (val h p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q2 (val h p);\n     (K \\<and>*\n      T \\<and>* blub \\<and>* P \\<and>* points_to p v \\<and>* P \\<and>* J)\n      h\\<rbrakk>\n    \\<Longrightarrow> Q (val h p) (val h p)", "apply (sep_frule points_to)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q2 (val h p);\n     (points_to p v \\<and>*\n      K \\<and>* T \\<and>* blub \\<and>* P \\<and>* P \\<and>* J)\n      h;\n     val h p = v\\<rbrakk>\n    \\<Longrightarrow> Q (val h p) (val h p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q2 v;\n     (points_to p v \\<and>*\n      K \\<and>* T \\<and>* blub \\<and>* P \\<and>* P \\<and>* J)\n      h;\n     val h p = v\\<rbrakk>\n    \\<Longrightarrow> Q v v", "oops"], ["", "consts\n  update :: \"p \\<Rightarrow> val \\<Rightarrow> heap \\<Rightarrow> heap\""], ["", "schematic_goal\n  assumes a: \"\\<And>P. (stuff p ** P) H \\<Longrightarrow> (other_stuff p v ** P) (update p v H)\"\n  shows \"(X ** Y ** other_stuff p ?v) (update p v H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<and>* Y \\<and>* other_stuff p ?v) (update p v H)", "apply (sep_rule a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (stuff p \\<and>* X \\<and>* Y) H", "oops"], ["", "text \\<open>Example of low-level rewrites\\<close>"], ["", "lemma \"\\<lbrakk> unrelated s ; (P ** Q ** R) s \\<rbrakk> \\<Longrightarrow> (A ** B ** Q ** P) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unrelated s; (P \\<and>* Q \\<and>* R) s\\<rbrakk>\n    \\<Longrightarrow> (A \\<and>* B \\<and>* Q \\<and>* P) s", "apply (tactic \\<open>dresolve_tac @{context} [mk_sep_select_rule @{context} true (3, 1)] 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unrelated s; (Q \\<and>* P \\<and>* R) s\\<rbrakk>\n    \\<Longrightarrow> (A \\<and>* B \\<and>* Q \\<and>* P) s", "apply (tactic \\<open>resolve_tac @{context} [mk_sep_select_rule @{context} false (4, 2)] 1\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unrelated s; (Q \\<and>* P \\<and>* R) s\\<rbrakk>\n    \\<Longrightarrow> (Q \\<and>* A \\<and>* B \\<and>* P) s", "(* now sep_conj_impl1 can be used *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unrelated s; (Q \\<and>* P \\<and>* R) s\\<rbrakk>\n    \\<Longrightarrow> (Q \\<and>* A \\<and>* B \\<and>* P) s", "apply (erule (1) sep_conj_impl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>unrelated s; (P \\<and>* R) h\\<rbrakk>\n       \\<Longrightarrow> (A \\<and>* B \\<and>* P) h", "oops"], ["", "text \\<open>Conjunct selection\\<close>"], ["", "lemma \"(A ** B ** Q ** P) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<and>* B \\<and>* Q \\<and>* P) s", "apply (sep_select 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<and>* B \\<and>* Q \\<and>* P) s", "apply (sep_select 3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q \\<and>* A \\<and>* B \\<and>* P) s", "apply (sep_select 4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* A \\<and>* B) s", "oops"], ["", "lemma \"\\<lbrakk> also unrelated; (A ** B ** Q ** P) s \\<rbrakk> \\<Longrightarrow> unrelated\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>also unrelated; (A \\<and>* B \\<and>* Q \\<and>* P) s\\<rbrakk>\n    \\<Longrightarrow> unrelated", "apply (sep_select_asm 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>also unrelated; (B \\<and>* A \\<and>* Q \\<and>* P) s\\<rbrakk>\n    \\<Longrightarrow> unrelated", "oops"], ["", "section \\<open>Test cases for \\<open>sep_cancel\\<close>.\\<close>"], ["", "lemma\n  assumes forward: \"\\<And>s g p v. A g p v s \\<Longrightarrow> AA g p s \"\n  shows \"\\<And>xv yv P s y x s. (A g x yv ** A g y yv ** P) s \\<Longrightarrow> (AA g y ** sep_true) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xv yv P s y x sa.\n       (A g x yv \\<and>* A g y yv \\<and>* P) sa \\<Longrightarrow>\n       (AA g y \\<and>* (\\<lambda>s. True)) sa", "by (sep_cancel add: forward)"], ["", "lemma\n  assumes forward: \"\\<And>s. generic s \\<Longrightarrow> instance s\"\n  shows \"(A ** generic ** B) s \\<Longrightarrow> (instance ** sep_true) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<and>* generic \\<and>* B) s \\<Longrightarrow>\n    (instance \\<and>* (\\<lambda>s. True)) s", "by (sep_cancel add: forward)"], ["", "lemma \"\\<lbrakk> (A ** B) sa ; (A ** Y) s \\<rbrakk> \\<Longrightarrow> (A ** X) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(A \\<and>* B) sa; (A \\<and>* Y) s\\<rbrakk>\n    \\<Longrightarrow> (A \\<and>* X) s", "apply (sep_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>(A \\<and>* B) sa; Y h\\<rbrakk> \\<Longrightarrow> X h", "oops"], ["", "lemma \"\\<lbrakk> (A ** B) sa ; (A ** Y) s \\<rbrakk> \\<Longrightarrow> (\\<lambda>s. (A ** X) s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(A \\<and>* B) sa; (A \\<and>* Y) s\\<rbrakk>\n    \\<Longrightarrow> (A \\<and>* X) s", "apply (sep_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>(A \\<and>* B) sa; Y h\\<rbrakk> \\<Longrightarrow> X h", "oops"], ["", "schematic_goal \"\\<lbrakk> (B ** A ** C) s \\<rbrakk> \\<Longrightarrow> (\\<lambda>s. (A ** ?X) s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B \\<and>* A \\<and>* C) s \\<Longrightarrow> (A \\<and>* ?X) s", "by (sep_cancel)"], ["", "(* test backtracking on premises with same state *)"], ["", "lemma\n  assumes forward: \"\\<And>s. generic s \\<Longrightarrow> instance s\"\n  shows \"\\<lbrakk> (A ** B) s ; (generic ** Y) s \\<rbrakk> \\<Longrightarrow> (X ** instance) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(A \\<and>* B) s; (generic \\<and>* Y) s\\<rbrakk>\n    \\<Longrightarrow> (X \\<and>* instance) s", "apply (sep_cancel add: forward)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. \\<lbrakk>(A \\<and>* B) s; Y h\\<rbrakk> \\<Longrightarrow> X h", "oops"], ["", "lemma\n  assumes forward: \"\\<And>s. generic s \\<Longrightarrow> instance s\"\n  shows \"generic s \\<Longrightarrow> instance s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generic s \\<Longrightarrow> instance s", "by (sep_cancel add: forward)"], ["", "lemma\n  assumes forward: \"\\<And>s. generic s \\<Longrightarrow> instance s\"\n  assumes forward2: \"\\<And>s. instance s \\<Longrightarrow> instance2 s\"\n  shows \"generic s \\<Longrightarrow> (instance2 ** sep_true) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generic s \\<Longrightarrow> (instance2 \\<and>* (\\<lambda>s. True)) s", "by (sep_cancel_blast add: forward forward2)"], ["", "end"]]}