{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Algebra/Map_Extra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Algebra", "problem_names": ["lemma None_not_eq: \"(None \\<noteq> x) = (\\<exists>y. x = Some y)\"", "lemma None_com: \"(None = x) = (x = None)\"", "lemma Some_com: \"(Some y = x) = (x = Some y)\"", "lemma empty_forall_equiv: \"(m = Map.empty) = (\\<forall>x. m x = None)\"", "lemma map_le_empty2 [simp]:\n  \"(m \\<subseteq>\\<^sub>m Map.empty) = (m = Map.empty)\"", "lemma dom_iff:\n  \"(\\<exists>y. m x = Some y) = (x \\<in> dom m)\"", "lemma non_dom_eval:\n  \"x \\<notin> dom m \\<Longrightarrow> m x = None\"", "lemma non_dom_eval_eq:\n  \"x \\<notin> dom m = (m x = None)\"", "lemma map_add_same_left_eq:\n  \"m\\<^sub>1 = m\\<^sub>1' \\<Longrightarrow> (m\\<^sub>0 ++ m\\<^sub>1 = m\\<^sub>0 ++ m\\<^sub>1')\"", "lemma map_add_left_cancelI [intro!]:\n  \"m\\<^sub>1 = m\\<^sub>1' \\<Longrightarrow> m\\<^sub>0 ++ m\\<^sub>1 = m\\<^sub>0 ++ m\\<^sub>1'\"", "lemma dom_empty_is_empty:\n  \"(dom m = {}) = (m = Map.empty)\"", "lemma map_add_dom_eq:\n  \"dom m = dom m' \\<Longrightarrow> m ++ m' = m'\"", "lemma map_add_right_dom_eq:\n  \"\\<lbrakk> m\\<^sub>0 ++ m\\<^sub>1 = m\\<^sub>0' ++ m\\<^sub>1'; dom m\\<^sub>1 = dom m\\<^sub>1' \\<rbrakk> \\<Longrightarrow> m\\<^sub>1 = m\\<^sub>1'\"", "lemma map_le_same_dom_eq:\n  \"\\<lbrakk> m\\<^sub>0 \\<subseteq>\\<^sub>m m\\<^sub>1 ; dom m\\<^sub>0 = dom m\\<^sub>1 \\<rbrakk> \\<Longrightarrow> m\\<^sub>0 = m\\<^sub>1\"", "lemma restrict_map_cancel:\n  \"(m |` S = m |` T) = (dom m \\<inter> S = dom m \\<inter> T)\"", "lemma map_add_restricted_self [simp]:\n  \"m ++ m |` S = m\"", "lemma map_add_restrict_dom_right [simp]:\n  \"(m ++ m') |` dom m' = m'\"", "lemma restrict_map_UNIV [simp]:\n  \"m |` UNIV = m\"", "lemma restrict_map_dom:\n  \"S = dom m \\<Longrightarrow> m |` S = m\"", "lemma restrict_map_subdom:\n  \"dom m \\<subseteq> S \\<Longrightarrow> m |` S = m\"", "lemma map_add_restrict:\n  \"(m\\<^sub>0 ++ m\\<^sub>1) |` S = ((m\\<^sub>0 |` S) ++ (m\\<^sub>1 |` S))\"", "lemma map_le_restrict:\n  \"m \\<subseteq>\\<^sub>m m' \\<Longrightarrow> m = m' |` dom m\"", "lemma restrict_map_le:\n  \"m |` S \\<subseteq>\\<^sub>m m\"", "lemma restrict_map_remerge:\n  \"\\<lbrakk> S \\<inter> T = {} \\<rbrakk> \\<Longrightarrow> m |` S ++ m |` T = m |` (S \\<union> T)\"", "lemma restrict_map_empty:\n  \"dom m \\<inter> S = {} \\<Longrightarrow> m |` S = Map.empty\"", "lemma map_add_restrict_comp_right [simp]:\n  \"(m |` S ++ m |` (UNIV - S)) = m\"", "lemma map_add_restrict_comp_right_dom [simp]:\n  \"(m |` S ++ m |` (dom m - S)) = m\"", "lemma map_add_restrict_comp_left [simp]:\n  \"(m |` (UNIV - S) ++ m |` S) = m\"", "lemma restrict_self_UNIV:\n  \"m |` (dom m - S) = m |` (UNIV - S)\"", "lemma map_add_restrict_nonmember_right:\n  \"x \\<notin> dom m' \\<Longrightarrow> (m ++ m') |` {x} = m |` {x}\"", "lemma map_add_restrict_nonmember_left:\n  \"x \\<notin> dom m \\<Longrightarrow> (m ++ m') |` {x} = m' |` {x}\"", "lemma map_add_restrict_right:\n  \"x \\<subseteq> dom m' \\<Longrightarrow> (m ++ m') |` x = m' |` x\"", "lemma restrict_map_compose:\n  \"\\<lbrakk> S \\<union> T = dom m ; S \\<inter> T = {} \\<rbrakk> \\<Longrightarrow> m |` S ++ m |` T = m\"", "lemma map_le_dom_subset_restrict:\n  \"\\<lbrakk> m' \\<subseteq>\\<^sub>m m; dom m' \\<subseteq> S \\<rbrakk> \\<Longrightarrow> m' \\<subseteq>\\<^sub>m (m |` S)\"", "lemma map_le_dom_restrict_sub_add:\n  \"m' \\<subseteq>\\<^sub>m m \\<Longrightarrow> m |` (dom m - dom m') ++ m' = m\"", "lemma subset_map_restrict_sub_add:\n  \"T \\<subseteq> S \\<Longrightarrow> m |` (S - T) ++ m |` T = m |` S\"", "lemma restrict_map_sub_union:\n  \"m |` (dom m - (S \\<union> T)) = (m |` (dom m - T)) |` (dom m - S)\"", "lemma prod_restrict_map_add:\n  \"\\<lbrakk> S \\<union> T = U; S \\<inter> T = {} \\<rbrakk> \\<Longrightarrow> m |` (X \\<times> S) ++ m |` (X \\<times> T) = m |` (X \\<times> U)\"", "lemma restrict_map_sub_disj: \"h |` S \\<bottom> h `- S\"", "lemma restrict_map_sub_add: \"h |` S ++ h `- S = h\"", "lemma map_disj_empty_right [simp]:\n  \"h \\<bottom> Map.empty\"", "lemma map_disj_empty_left [simp]:\n  \"Map.empty \\<bottom> h\"", "lemma map_disj_com:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 = h\\<^sub>1 \\<bottom> h\\<^sub>0\"", "lemma map_disjD:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> dom h\\<^sub>0 \\<inter> dom h\\<^sub>1 = {}\"", "lemma map_disjI:\n  \"dom h\\<^sub>0 \\<inter> dom h\\<^sub>1 = {} \\<Longrightarrow> h\\<^sub>0 \\<bottom> h\\<^sub>1\"", "lemma map_add_com:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>1 ++ h\\<^sub>0\"", "lemma map_add_left_commute:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 ++ (h\\<^sub>1 ++ h\\<^sub>2) = h\\<^sub>1 ++ (h\\<^sub>0 ++ h\\<^sub>2)\"", "lemma map_add_disj:\n  \"h\\<^sub>0 \\<bottom> (h\\<^sub>1 ++ h\\<^sub>2) = (h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<and> h\\<^sub>0 \\<bottom> h\\<^sub>2)\"", "lemma map_add_disj':\n  \"(h\\<^sub>1 ++ h\\<^sub>2) \\<bottom> h\\<^sub>0 = (h\\<^sub>1 \\<bottom> h\\<^sub>0 \\<and> h\\<^sub>2 \\<bottom> h\\<^sub>0)\"", "lemmas map_add_ac =\n  map_add_assoc[symmetric] map_add_com map_disj_com\n  map_add_left_commute map_add_disj map_add_disj'", "lemma map_disj_None_right:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; x \\<in> dom h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>1 x = None\"", "lemma map_disj_None_left:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; x \\<in> dom h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 x = None\"", "lemma map_disj_None_left':\n  \"\\<lbrakk> h\\<^sub>0 x = Some y ; h\\<^sub>1 \\<bottom> h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>1 x = None \"", "lemma map_disj_None_right':\n  \"\\<lbrakk> h\\<^sub>1 x = Some y ; h\\<^sub>1 \\<bottom> h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 x = None \"", "lemma map_disj_common:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; h\\<^sub>0 p = Some v ; h\\<^sub>1 p = Some v' \\<rbrakk> \\<Longrightarrow> False\"", "lemma map_disj_eq_dom_left:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; dom h\\<^sub>0' = dom h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0' \\<bottom> h\\<^sub>1\"", "lemma map_add_eval_left:\n  \"\\<lbrakk> x \\<in> dom h ; h \\<bottom> h' \\<rbrakk> \\<Longrightarrow> (h ++ h') x = h x\"", "lemma map_add_eval_right:\n  \"\\<lbrakk> x \\<in> dom h' ; h \\<bottom> h' \\<rbrakk> \\<Longrightarrow> (h ++ h') x = h' x\"", "lemma map_add_eval_left':\n  \"\\<lbrakk> x \\<notin> dom h' ; h \\<bottom> h' \\<rbrakk> \\<Longrightarrow> (h ++ h') x = h x\"", "lemma map_add_eval_right':\n  \"\\<lbrakk> x \\<notin> dom h ; h \\<bottom> h' \\<rbrakk> \\<Longrightarrow> (h ++ h') x = h' x\"", "lemma map_add_left_dom_eq:\n  assumes eq: \"h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'\"\n  assumes etc: \"h\\<^sub>0 \\<bottom> h\\<^sub>1\" \"h\\<^sub>0' \\<bottom> h\\<^sub>1'\" \"dom h\\<^sub>0 = dom h\\<^sub>0'\"\n  shows \"h\\<^sub>0 = h\\<^sub>0'\"", "lemma map_add_left_eq:\n  assumes eq: \"h\\<^sub>0 ++ h = h\\<^sub>1 ++ h\"\n  assumes disj: \"h\\<^sub>0 \\<bottom> h\" \"h\\<^sub>1 \\<bottom> h\"\n  shows \"h\\<^sub>0 = h\\<^sub>1\"", "lemma map_add_right_eq:\n  \"\\<lbrakk>h ++ h\\<^sub>0 = h ++ h\\<^sub>1; h\\<^sub>0 \\<bottom> h; h\\<^sub>1 \\<bottom> h\\<rbrakk> \\<Longrightarrow> h\\<^sub>0 = h\\<^sub>1\"", "lemma map_disj_add_eq_dom_right_eq:\n  assumes merge: \"h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'\" and d: \"dom h\\<^sub>0 = dom h\\<^sub>0'\" and\n      ab_disj: \"h\\<^sub>0 \\<bottom> h\\<^sub>1\" and cd_disj: \"h\\<^sub>0' \\<bottom> h\\<^sub>1'\"\n  shows \"h\\<^sub>1 = h\\<^sub>1'\"", "lemma map_disj_add_eq_dom_left_eq:\n  assumes add: \"h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'\" and\n          dom: \"dom h\\<^sub>1 = dom h\\<^sub>1'\" and\n          disj: \"h\\<^sub>0 \\<bottom> h\\<^sub>1\" \"h\\<^sub>0' \\<bottom> h\\<^sub>1'\"\n  shows \"h\\<^sub>0 = h\\<^sub>0'\"", "lemma map_add_left_cancel:\n  assumes disj: \"h\\<^sub>0 \\<bottom> h\\<^sub>1\" \"h\\<^sub>0 \\<bottom> h\\<^sub>1'\"\n  shows \"(h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1') = (h\\<^sub>1 = h\\<^sub>1')\"", "lemma map_add_lr_disj:\n  \"\\<lbrakk> h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'; h\\<^sub>1 \\<bottom> h\\<^sub>1'  \\<rbrakk> \\<Longrightarrow> dom h\\<^sub>1 \\<subseteq> dom h\\<^sub>0'\"", "lemma map_disj_update_left [simp]:\n  \"p \\<in> dom h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 \\<bottom> h\\<^sub>1(p \\<mapsto> v) = h\\<^sub>0 \\<bottom> h\\<^sub>1\"", "lemma map_disj_update_right [simp]:\n  \"p \\<in> dom h\\<^sub>1 \\<Longrightarrow> h\\<^sub>1(p \\<mapsto> v) \\<bottom> h\\<^sub>0 = h\\<^sub>1 \\<bottom> h\\<^sub>0\"", "lemma map_add_update_left:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; p \\<in> dom h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> (h\\<^sub>0 ++ h\\<^sub>1)(p \\<mapsto> v) = (h\\<^sub>0(p \\<mapsto> v) ++ h\\<^sub>1)\"", "lemma map_add_update_right:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; p \\<in> dom h\\<^sub>1  \\<rbrakk> \\<Longrightarrow> (h\\<^sub>0 ++ h\\<^sub>1)(p \\<mapsto> v) = (h\\<^sub>0 ++ h\\<^sub>1 (p \\<mapsto> v))\"", "lemma map_add3_update:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; h\\<^sub>1  \\<bottom> h\\<^sub>2 ; h\\<^sub>0 \\<bottom> h\\<^sub>2 ; p \\<in> dom h\\<^sub>0 \\<rbrakk>\n  \\<Longrightarrow> (h\\<^sub>0 ++ h\\<^sub>1 ++ h\\<^sub>2)(p \\<mapsto> v) = h\\<^sub>0(p \\<mapsto> v) ++ h\\<^sub>1 ++ h\\<^sub>2\"", "lemma map_le_override [simp]:\n  \"\\<lbrakk> h \\<bottom> h' \\<rbrakk> \\<Longrightarrow> h \\<subseteq>\\<^sub>m h ++ h'\"", "lemma map_leI_left:\n  \"\\<lbrakk> h = h\\<^sub>0 ++ h\\<^sub>1 ; h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m h\"", "lemma map_leI_right:\n  \"\\<lbrakk> h = h\\<^sub>0 ++ h\\<^sub>1 ; h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>1 \\<subseteq>\\<^sub>m h\"", "lemma map_disj_map_le:\n  \"\\<lbrakk> h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0; h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0' \\<bottom> h\\<^sub>1\"", "lemma map_le_on_disj_left:\n  \"\\<lbrakk> h' \\<subseteq>\\<^sub>m h ; h\\<^sub>0 \\<bottom> h\\<^sub>1 ; h' = h\\<^sub>0 ++ h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m h\"", "lemma map_le_on_disj_right:\n  \"\\<lbrakk> h' \\<subseteq>\\<^sub>m h ; h\\<^sub>0 \\<bottom> h\\<^sub>1 ; h' = h\\<^sub>1 ++ h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m h\"", "lemma map_le_add_cancel:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0' ++ h\\<^sub>1 \\<subseteq>\\<^sub>m h\\<^sub>0 ++ h\\<^sub>1\"", "lemma map_le_override_bothD:\n  assumes subm: \"h\\<^sub>0' ++ h\\<^sub>1 \\<subseteq>\\<^sub>m h\\<^sub>0 ++ h\\<^sub>1\"\n  assumes disj': \"h\\<^sub>0' \\<bottom> h\\<^sub>1\"\n  assumes disj: \"h\\<^sub>0 \\<bottom> h\\<^sub>1\"\n  shows \"h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0\"", "lemma map_le_conv:\n  \"(h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0 \\<and> h\\<^sub>0' \\<noteq> h\\<^sub>0) = (\\<exists>h\\<^sub>1. h\\<^sub>0 = h\\<^sub>0' ++ h\\<^sub>1 \\<and> h\\<^sub>0' \\<bottom> h\\<^sub>1 \\<and> h\\<^sub>0' \\<noteq> h\\<^sub>0)\"", "lemma map_le_conv2:\n  \"h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0 = (\\<exists>h\\<^sub>1. h\\<^sub>0 = h\\<^sub>0' ++ h\\<^sub>1 \\<and> h\\<^sub>0' \\<bottom> h\\<^sub>1)\"", "lemma map_disj_comp [simp]:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 |` (UNIV - dom h\\<^sub>0)\"", "lemma restrict_map_disj:\n  \"S \\<inter> T = {} \\<Longrightarrow> h |` S \\<bottom> h |` T\"", "lemma map_disj_restrict_dom [simp]:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 |` (dom h\\<^sub>1 - dom h\\<^sub>0)\"", "lemma restrict_map_disj_dom_empty:\n  \"h \\<bottom> h' \\<Longrightarrow> h |` dom h' = Map.empty\"", "lemma restrict_map_univ_disj_eq:\n  \"h \\<bottom> h' \\<Longrightarrow> h |` (UNIV - dom h') = h\"", "lemma restrict_map_disj_dom:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h |` dom h\\<^sub>0 \\<bottom> h |` dom h\\<^sub>1\"", "lemma map_add_restrict_dom_left:\n  \"h \\<bottom> h' \\<Longrightarrow> (h ++ h') |` dom h = h\"", "lemma map_add_restrict_dom_left':\n  \"h \\<bottom> h' \\<Longrightarrow> S = dom h \\<Longrightarrow> (h ++ h') |` S = h\"", "lemma restrict_map_disj_left:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 |` S \\<bottom> h\\<^sub>1\"", "lemma restrict_map_disj_right:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 \\<bottom> h\\<^sub>1 |` S\"", "lemmas restrict_map_disj_both = restrict_map_disj_right restrict_map_disj_left", "lemma map_dom_disj_restrict_right:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> (h\\<^sub>0 ++ h\\<^sub>0') |` dom h\\<^sub>1 = h\\<^sub>0' |` dom h\\<^sub>1\"", "lemma restrict_map_on_disj:\n  \"h\\<^sub>0' \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 |` dom h\\<^sub>0' \\<bottom> h\\<^sub>1\"", "lemma restrict_map_on_disj':\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 \\<bottom> h\\<^sub>1 |` S\"", "lemma map_le_sub_dom:\n  \"\\<lbrakk> h\\<^sub>0 ++ h\\<^sub>1 \\<subseteq>\\<^sub>m h ; h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m h |` (dom h - dom h\\<^sub>1)\"", "lemma map_submap_break:\n  \"\\<lbrakk> h \\<subseteq>\\<^sub>m h' \\<rbrakk> \\<Longrightarrow> h' = (h' |` (UNIV - dom h)) ++ h\"", "lemma map_add_disj_restrict_both:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1; S \\<inter> S' = {}; T \\<inter> T' = {} \\<rbrakk>\n   \\<Longrightarrow> (h\\<^sub>0 |` S) ++ (h\\<^sub>1 |` T) \\<bottom> (h\\<^sub>0 |` S') ++ (h\\<^sub>1 |` T')\""], "translations": [["", "lemma None_not_eq: \"(None \\<noteq> x) = (\\<exists>y. x = Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (None \\<noteq> x) = (\\<exists>y. x = Some y)", "by (cases x) auto"], ["", "lemma None_com: \"(None = x) = (x = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (None = x) = (x = None)", "by fast"], ["", "lemma Some_com: \"(Some y = x) = (x = Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Some y = x) = (x = Some y)", "by fast"], ["", "section \\<open>Things that go into Map.thy\\<close>"], ["", "text \\<open>Map intersection: set of all keys for which the maps agree.\\<close>"], ["", "definition\n  map_inter :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> ('a \\<rightharpoonup> 'b) \\<Rightarrow> 'a set\" (infixl \"\\<inter>\\<^sub>m\" 70) where\n  \"m\\<^sub>1 \\<inter>\\<^sub>m m\\<^sub>2 \\<equiv> {x \\<in> dom m\\<^sub>1. m\\<^sub>1 x = m\\<^sub>2 x}\""], ["", "text \\<open>Map restriction via domain subtraction\\<close>"], ["", "definition\n  sub_restrict_map :: \"('a \\<rightharpoonup> 'b) => 'a set => ('a \\<rightharpoonup> 'b)\" (infixl \"`-\"  110)\n  where\n  \"m `- S \\<equiv> (\\<lambda>x. if x \\<in> S then None else m x)\""], ["", "subsection \\<open>Properties of maps not related to restriction\\<close>"], ["", "lemma empty_forall_equiv: \"(m = Map.empty) = (\\<forall>x. m x = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m = Map.empty) = (\\<forall>x. m x = None)", "by (fastforce intro!: ext)"], ["", "lemma map_le_empty2 [simp]:\n  \"(m \\<subseteq>\\<^sub>m Map.empty) = (m = Map.empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<subseteq>\\<^sub>m Map.empty) = (m = Map.empty)", "by (auto simp: map_le_def intro: ext)"], ["", "lemma dom_iff:\n  \"(\\<exists>y. m x = Some y) = (x \\<in> dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y. m x = Some y) = (x \\<in> dom m)", "by auto"], ["", "lemma non_dom_eval:\n  \"x \\<notin> dom m \\<Longrightarrow> m x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom m \\<Longrightarrow> m x = None", "by auto"], ["", "lemma non_dom_eval_eq:\n  \"x \\<notin> dom m = (m x = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> dom m) = (m x = None)", "by auto"], ["", "lemma map_add_same_left_eq:\n  \"m\\<^sub>1 = m\\<^sub>1' \\<Longrightarrow> (m\\<^sub>0 ++ m\\<^sub>1 = m\\<^sub>0 ++ m\\<^sub>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m\\<^sub>1 = m\\<^sub>1' \\<Longrightarrow>\n    m\\<^sub>0 ++ m\\<^sub>1 = m\\<^sub>0 ++ m\\<^sub>1'", "by simp"], ["", "lemma map_add_left_cancelI [intro!]:\n  \"m\\<^sub>1 = m\\<^sub>1' \\<Longrightarrow> m\\<^sub>0 ++ m\\<^sub>1 = m\\<^sub>0 ++ m\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m\\<^sub>1 = m\\<^sub>1' \\<Longrightarrow>\n    m\\<^sub>0 ++ m\\<^sub>1 = m\\<^sub>0 ++ m\\<^sub>1'", "by simp"], ["", "lemma dom_empty_is_empty:\n  \"(dom m = {}) = (m = Map.empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dom m = {}) = (m = Map.empty)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. dom m = {} \\<Longrightarrow> m = Map.empty\n 2. m = Map.empty \\<Longrightarrow> dom m = {}", "assume a: \"dom m = {}\""], ["proof (state)\nthis:\n  dom m = {}\n\ngoal (2 subgoals):\n 1. dom m = {} \\<Longrightarrow> m = Map.empty\n 2. m = Map.empty \\<Longrightarrow> dom m = {}", "{"], ["proof (state)\nthis:\n  dom m = {}\n\ngoal (2 subgoals):\n 1. dom m = {} \\<Longrightarrow> m = Map.empty\n 2. m = Map.empty \\<Longrightarrow> dom m = {}", "assume \"m \\<noteq> Map.empty\""], ["proof (state)\nthis:\n  m \\<noteq> Map.empty\n\ngoal (2 subgoals):\n 1. dom m = {} \\<Longrightarrow> m = Map.empty\n 2. m = Map.empty \\<Longrightarrow> dom m = {}", "hence \"dom m \\<noteq> {}\""], ["proof (prove)\nusing this:\n  m \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. dom m \\<noteq> {}", "by - (subst (asm) empty_forall_equiv, simp add: dom_def)"], ["proof (state)\nthis:\n  dom m \\<noteq> {}\n\ngoal (2 subgoals):\n 1. dom m = {} \\<Longrightarrow> m = Map.empty\n 2. m = Map.empty \\<Longrightarrow> dom m = {}", "hence False"], ["proof (prove)\nusing this:\n  dom m \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "using a"], ["proof (prove)\nusing this:\n  dom m \\<noteq> {}\n  dom m = {}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. dom m = {} \\<Longrightarrow> m = Map.empty\n 2. m = Map.empty \\<Longrightarrow> dom m = {}", "}"], ["proof (state)\nthis:\n  m \\<noteq> Map.empty \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. dom m = {} \\<Longrightarrow> m = Map.empty\n 2. m = Map.empty \\<Longrightarrow> dom m = {}", "thus \"m = Map.empty\""], ["proof (prove)\nusing this:\n  m \\<noteq> Map.empty \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. m = Map.empty", "by blast"], ["proof (state)\nthis:\n  m = Map.empty\n\ngoal (1 subgoal):\n 1. m = Map.empty \\<Longrightarrow> dom m = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m = Map.empty \\<Longrightarrow> dom m = {}", "assume a: \"m = Map.empty\""], ["proof (state)\nthis:\n  m = Map.empty\n\ngoal (1 subgoal):\n 1. m = Map.empty \\<Longrightarrow> dom m = {}", "thus \"dom m = {}\""], ["proof (prove)\nusing this:\n  m = Map.empty\n\ngoal (1 subgoal):\n 1. dom m = {}", "by simp"], ["proof (state)\nthis:\n  dom m = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_add_dom_eq:\n  \"dom m = dom m' \\<Longrightarrow> m ++ m' = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom m = dom m' \\<Longrightarrow> m ++ m' = m'", "by (rule ext) (auto simp: map_add_def split: option.splits)"], ["", "lemma map_add_right_dom_eq:\n  \"\\<lbrakk> m\\<^sub>0 ++ m\\<^sub>1 = m\\<^sub>0' ++ m\\<^sub>1'; dom m\\<^sub>1 = dom m\\<^sub>1' \\<rbrakk> \\<Longrightarrow> m\\<^sub>1 = m\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m\\<^sub>0 ++ m\\<^sub>1 = m\\<^sub>0' ++ m\\<^sub>1';\n     dom m\\<^sub>1 = dom m\\<^sub>1'\\<rbrakk>\n    \\<Longrightarrow> m\\<^sub>1 = m\\<^sub>1'", "unfolding map_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>x.\n                 case m\\<^sub>1 x of None \\<Rightarrow> m\\<^sub>0 x\n                 | Some x \\<Rightarrow> Some x) =\n             (\\<lambda>x.\n                 case m\\<^sub>1' x of None \\<Rightarrow> m\\<^sub>0' x\n                 | Some x \\<Rightarrow> Some x);\n     dom m\\<^sub>1 = dom m\\<^sub>1'\\<rbrakk>\n    \\<Longrightarrow> m\\<^sub>1 = m\\<^sub>1'", "by (rule ext, rule ccontr,\n      drule_tac x=x in fun_cong, clarsimp split: option.splits,\n      drule sym, drule sym, force+)"], ["", "lemma map_le_same_dom_eq:\n  \"\\<lbrakk> m\\<^sub>0 \\<subseteq>\\<^sub>m m\\<^sub>1 ; dom m\\<^sub>0 = dom m\\<^sub>1 \\<rbrakk> \\<Longrightarrow> m\\<^sub>0 = m\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m\\<^sub>0 \\<subseteq>\\<^sub>m m\\<^sub>1;\n     dom m\\<^sub>0 = dom m\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> m\\<^sub>0 = m\\<^sub>1", "by (auto intro!: ext simp: map_le_def elim!: ballE)"], ["", "subsection \\<open>Properties of map restriction\\<close>"], ["", "lemma restrict_map_cancel:\n  \"(m |` S = m |` T) = (dom m \\<inter> S = dom m \\<inter> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m |` S = m |` T) = (dom m \\<inter> S = dom m \\<inter> T)", "by (fastforce intro: ext dest: fun_cong\n               simp: restrict_map_def None_not_eq\n               split: if_split_asm)"], ["", "lemma map_add_restricted_self [simp]:\n  \"m ++ m |` S = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m ++ m |` S = m", "by (auto intro: ext simp: restrict_map_def map_add_def split: option.splits)"], ["", "lemma map_add_restrict_dom_right [simp]:\n  \"(m ++ m') |` dom m' = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m ++ m') |` dom m' = m'", "by (rule ext, auto simp: restrict_map_def map_add_def split: option.splits)"], ["", "lemma restrict_map_UNIV [simp]:\n  \"m |` UNIV = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m |` UNIV = m", "by (simp add: restrict_map_def)"], ["", "lemma restrict_map_dom:\n  \"S = dom m \\<Longrightarrow> m |` S = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = dom m \\<Longrightarrow> m |` S = m", "by (auto intro!: ext simp: restrict_map_def None_not_eq)"], ["", "lemma restrict_map_subdom:\n  \"dom m \\<subseteq> S \\<Longrightarrow> m |` S = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom m \\<subseteq> S \\<Longrightarrow> m |` S = m", "by (fastforce simp: restrict_map_def None_com intro: ext)"], ["", "lemma map_add_restrict:\n  \"(m\\<^sub>0 ++ m\\<^sub>1) |` S = ((m\\<^sub>0 |` S) ++ (m\\<^sub>1 |` S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m\\<^sub>0 ++ m\\<^sub>1) |` S = m\\<^sub>0 |` S ++ m\\<^sub>1 |` S", "by (force simp: map_add_def restrict_map_def intro: ext)"], ["", "lemma map_le_restrict:\n  \"m \\<subseteq>\\<^sub>m m' \\<Longrightarrow> m = m' |` dom m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<subseteq>\\<^sub>m m' \\<Longrightarrow> m = m' |` dom m", "by (force simp: map_le_def restrict_map_def None_com intro: ext)"], ["", "lemma restrict_map_le:\n  \"m |` S \\<subseteq>\\<^sub>m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m |` S \\<subseteq>\\<^sub>m m", "by (auto simp: map_le_def)"], ["", "lemma restrict_map_remerge:\n  \"\\<lbrakk> S \\<inter> T = {} \\<rbrakk> \\<Longrightarrow> m |` S ++ m |` T = m |` (S \\<union> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<inter> T = {} \\<Longrightarrow>\n    m |` S ++ m |` T = m |` (S \\<union> T)", "by (rule ext, clarsimp simp: restrict_map_def map_add_def\n                         split: option.splits)"], ["", "lemma restrict_map_empty:\n  \"dom m \\<inter> S = {} \\<Longrightarrow> m |` S = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom m \\<inter> S = {} \\<Longrightarrow> m |` S = Map.empty", "by (fastforce simp: restrict_map_def intro: ext)"], ["", "lemma map_add_restrict_comp_right [simp]:\n  \"(m |` S ++ m |` (UNIV - S)) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m |` S ++ m |` (UNIV - S) = m", "by (force simp: map_add_def restrict_map_def split: option.splits intro: ext)"], ["", "lemma map_add_restrict_comp_right_dom [simp]:\n  \"(m |` S ++ m |` (dom m - S)) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m |` S ++ m |` (dom m - S) = m", "by (auto simp: map_add_def restrict_map_def split: option.splits intro!: ext)"], ["", "lemma map_add_restrict_comp_left [simp]:\n  \"(m |` (UNIV - S) ++ m |` S) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m |` (UNIV - S) ++ m |` S = m", "by (subst map_add_comm, auto)"], ["", "lemma restrict_self_UNIV:\n  \"m |` (dom m - S) = m |` (UNIV - S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m |` (dom m - S) = m |` (UNIV - S)", "by (auto intro!: ext simp: restrict_map_def)"], ["", "lemma map_add_restrict_nonmember_right:\n  \"x \\<notin> dom m' \\<Longrightarrow> (m ++ m') |` {x} = m |` {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom m' \\<Longrightarrow> (m ++ m') |` {x} = m |` {x}", "by (rule ext, auto simp: restrict_map_def map_add_def split: option.splits)"], ["", "lemma map_add_restrict_nonmember_left:\n  \"x \\<notin> dom m \\<Longrightarrow> (m ++ m') |` {x} = m' |` {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom m \\<Longrightarrow> (m ++ m') |` {x} = m' |` {x}", "by (rule ext, auto simp: restrict_map_def map_add_def split: option.splits)"], ["", "lemma map_add_restrict_right:\n  \"x \\<subseteq> dom m' \\<Longrightarrow> (m ++ m') |` x = m' |` x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<subseteq> dom m' \\<Longrightarrow> (m ++ m') |` x = m' |` x", "by (rule ext, auto simp: restrict_map_def map_add_def split: option.splits)"], ["", "lemma restrict_map_compose:\n  \"\\<lbrakk> S \\<union> T = dom m ; S \\<inter> T = {} \\<rbrakk> \\<Longrightarrow> m |` S ++ m |` T = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<union> T = dom m; S \\<inter> T = {}\\<rbrakk>\n    \\<Longrightarrow> m |` S ++ m |` T = m", "by (fastforce intro: ext simp: map_add_def restrict_map_def)"], ["", "lemma map_le_dom_subset_restrict:\n  \"\\<lbrakk> m' \\<subseteq>\\<^sub>m m; dom m' \\<subseteq> S \\<rbrakk> \\<Longrightarrow> m' \\<subseteq>\\<^sub>m (m |` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' \\<subseteq>\\<^sub>m m; dom m' \\<subseteq> S\\<rbrakk>\n    \\<Longrightarrow> m' \\<subseteq>\\<^sub>m m |` S", "by (force simp: restrict_map_def map_le_def)"], ["", "lemma map_le_dom_restrict_sub_add:\n  \"m' \\<subseteq>\\<^sub>m m \\<Longrightarrow> m |` (dom m - dom m') ++ m' = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<subseteq>\\<^sub>m m \\<Longrightarrow>\n    m |` (dom m - dom m') ++ m' = m", "by (auto simp: None_com map_add_def restrict_map_def map_le_def\n           split: option.splits\n           intro!: ext)\n     (force simp: Some_com)+"], ["", "lemma subset_map_restrict_sub_add:\n  \"T \\<subseteq> S \\<Longrightarrow> m |` (S - T) ++ m |` T = m |` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<subseteq> S \\<Longrightarrow> m |` (S - T) ++ m |` T = m |` S", "by (auto simp: restrict_map_def map_add_def intro!: ext split: option.splits)"], ["", "lemma restrict_map_sub_union:\n  \"m |` (dom m - (S \\<union> T)) = (m |` (dom m - T)) |` (dom m - S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m |` (dom m - (S \\<union> T)) = m |` (dom m - T) |` (dom m - S)", "by (auto intro!: ext simp: restrict_map_def)"], ["", "lemma prod_restrict_map_add:\n  \"\\<lbrakk> S \\<union> T = U; S \\<inter> T = {} \\<rbrakk> \\<Longrightarrow> m |` (X \\<times> S) ++ m |` (X \\<times> T) = m |` (X \\<times> U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<union> T = U; S \\<inter> T = {}\\<rbrakk>\n    \\<Longrightarrow> m |` (X \\<times> S) ++ m |` (X \\<times> T) =\n                      m |` (X \\<times> U)", "by (auto simp: map_add_def restrict_map_def intro!: ext split: option.splits)"], ["", "section \\<open>Things that should not go into Map.thy (separation logic)\\<close>"], ["", "subsection \\<open>Definitions\\<close>"], ["", "text \\<open>Map disjuction\\<close>"], ["", "definition\n  map_disj :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> ('a \\<rightharpoonup> 'b) \\<Rightarrow> bool\" (infix \"\\<bottom>\" 51) where\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<equiv> dom h\\<^sub>0 \\<inter> dom h\\<^sub>1 = {}\""], ["", "declare None_not_eq [simp]"], ["", "subsection \\<open>Properties of @{term \"sub_restrict_map\"}\\<close>"], ["", "lemma restrict_map_sub_disj: \"h |` S \\<bottom> h `- S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h |` S \\<bottom> h `- S", "by (fastforce simp: sub_restrict_map_def restrict_map_def map_disj_def\n               split: option.splits if_split_asm)"], ["", "lemma restrict_map_sub_add: \"h |` S ++ h `- S = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h |` S ++ h `- S = h", "by (fastforce simp: sub_restrict_map_def restrict_map_def map_add_def\n               split: option.splits if_split\n               intro: ext)"], ["", "subsection \\<open>Properties of map disjunction\\<close>"], ["", "lemma map_disj_empty_right [simp]:\n  \"h \\<bottom> Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<bottom> Map.empty", "by (simp add: map_disj_def)"], ["", "lemma map_disj_empty_left [simp]:\n  \"Map.empty \\<bottom> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map.empty \\<bottom> h", "by (simp add: map_disj_def)"], ["", "lemma map_disj_com:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 = h\\<^sub>1 \\<bottom> h\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 = h\\<^sub>1 \\<bottom> h\\<^sub>0", "by (simp add: map_disj_def, fast)"], ["", "lemma map_disjD:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> dom h\\<^sub>0 \\<inter> dom h\\<^sub>1 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow>\n    dom h\\<^sub>0 \\<inter> dom h\\<^sub>1 = {}", "by (simp add: map_disj_def)"], ["", "lemma map_disjI:\n  \"dom h\\<^sub>0 \\<inter> dom h\\<^sub>1 = {} \\<Longrightarrow> h\\<^sub>0 \\<bottom> h\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom h\\<^sub>0 \\<inter> dom h\\<^sub>1 = {} \\<Longrightarrow>\n    h\\<^sub>0 \\<bottom> h\\<^sub>1", "by (simp add: map_disj_def)"], ["", "subsection \\<open>Map associativity-commutativity based on map disjuction\\<close>"], ["", "lemma map_add_com:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>1 ++ h\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow>\n    h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>1 ++ h\\<^sub>0", "by (drule map_disjD, rule map_add_comm, force)"], ["", "lemma map_add_left_commute:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 ++ (h\\<^sub>1 ++ h\\<^sub>2) = h\\<^sub>1 ++ (h\\<^sub>0 ++ h\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow>\n    h\\<^sub>0 ++ (h\\<^sub>1 ++ h\\<^sub>2) =\n    h\\<^sub>1 ++ (h\\<^sub>0 ++ h\\<^sub>2)", "by (simp add: map_add_com map_disj_com map_add_assoc)"], ["", "lemma map_add_disj:\n  \"h\\<^sub>0 \\<bottom> (h\\<^sub>1 ++ h\\<^sub>2) = (h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<and> h\\<^sub>0 \\<bottom> h\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 ++ h\\<^sub>2 =\n    (h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<and> h\\<^sub>0 \\<bottom> h\\<^sub>2)", "by (simp add: map_disj_def, fast)"], ["", "lemma map_add_disj':\n  \"(h\\<^sub>1 ++ h\\<^sub>2) \\<bottom> h\\<^sub>0 = (h\\<^sub>1 \\<bottom> h\\<^sub>0 \\<and> h\\<^sub>2 \\<bottom> h\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>1 ++ h\\<^sub>2 \\<bottom> h\\<^sub>0 =\n    (h\\<^sub>1 \\<bottom> h\\<^sub>0 \\<and> h\\<^sub>2 \\<bottom> h\\<^sub>0)", "by (simp add: map_disj_def, fast)"], ["", "text \\<open>\n  We redefine @{term \"map_add\"} associativity to bind to the right, which\n  seems to be the more common case.\n  Note that when a theory includes Map again, \\<open>map_add_assoc\\<close> will\n  return to the simpset and will cause infinite loops if its symmetric\n  counterpart is added (e.g. via \\<open>map_add_ac\\<close>)\n\\<close>"], ["", "declare map_add_assoc [simp del]"], ["", "text \\<open>\n  Since the associativity-commutativity of @{term \"map_add\"} relies on\n  map disjunction, we include some basic rules into the ac set.\n\\<close>"], ["", "lemmas map_add_ac =\n  map_add_assoc[symmetric] map_add_com map_disj_com\n  map_add_left_commute map_add_disj map_add_disj'"], ["", "subsection \\<open>Basic properties\\<close>"], ["", "lemma map_disj_None_right:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; x \\<in> dom h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>1 x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 \\<bottom> h\\<^sub>1; x \\<in> dom h\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>1 x = None", "by (auto simp: map_disj_def dom_def)"], ["", "lemma map_disj_None_left:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; x \\<in> dom h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 \\<bottom> h\\<^sub>1; x \\<in> dom h\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>0 x = None", "by (auto simp: map_disj_def dom_def)"], ["", "lemma map_disj_None_left':\n  \"\\<lbrakk> h\\<^sub>0 x = Some y ; h\\<^sub>1 \\<bottom> h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>1 x = None \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 x = Some y; h\\<^sub>1 \\<bottom> h\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>1 x = None", "by (auto simp: map_disj_def)"], ["", "lemma map_disj_None_right':\n  \"\\<lbrakk> h\\<^sub>1 x = Some y ; h\\<^sub>1 \\<bottom> h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 x = None \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>1 x = Some y; h\\<^sub>1 \\<bottom> h\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>0 x = None", "by (auto simp: map_disj_def)"], ["", "lemma map_disj_common:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; h\\<^sub>0 p = Some v ; h\\<^sub>1 p = Some v' \\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 \\<bottom> h\\<^sub>1; h\\<^sub>0 p = Some v;\n     h\\<^sub>1 p = Some v'\\<rbrakk>\n    \\<Longrightarrow> False", "by (frule (1) map_disj_None_left', simp)"], ["", "lemma map_disj_eq_dom_left:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; dom h\\<^sub>0' = dom h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0' \\<bottom> h\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 \\<bottom> h\\<^sub>1;\n     dom h\\<^sub>0' = dom h\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>0' \\<bottom> h\\<^sub>1", "by (auto simp: map_disj_def)"], ["", "subsection \\<open>Map disjunction and addition\\<close>"], ["", "lemma map_add_eval_left:\n  \"\\<lbrakk> x \\<in> dom h ; h \\<bottom> h' \\<rbrakk> \\<Longrightarrow> (h ++ h') x = h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom h; h \\<bottom> h'\\<rbrakk>\n    \\<Longrightarrow> (h ++ h') x = h x", "by (auto dest!: map_disj_None_right simp: map_add_def cong: option.case_cong)"], ["", "lemma map_add_eval_right:\n  \"\\<lbrakk> x \\<in> dom h' ; h \\<bottom> h' \\<rbrakk> \\<Longrightarrow> (h ++ h') x = h' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom h'; h \\<bottom> h'\\<rbrakk>\n    \\<Longrightarrow> (h ++ h') x = h' x", "by (auto elim!: map_disjD simp: map_add_comm map_add_eval_left map_disj_com)"], ["", "lemma map_add_eval_left':\n  \"\\<lbrakk> x \\<notin> dom h' ; h \\<bottom> h' \\<rbrakk> \\<Longrightarrow> (h ++ h') x = h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom h'; h \\<bottom> h'\\<rbrakk>\n    \\<Longrightarrow> (h ++ h') x = h x", "by (clarsimp simp: map_disj_def map_add_def split: option.splits)"], ["", "lemma map_add_eval_right':\n  \"\\<lbrakk> x \\<notin> dom h ; h \\<bottom> h' \\<rbrakk> \\<Longrightarrow> (h ++ h') x = h' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom h; h \\<bottom> h'\\<rbrakk>\n    \\<Longrightarrow> (h ++ h') x = h' x", "by (clarsimp simp: map_disj_def map_add_def split: option.splits)"], ["", "lemma map_add_left_dom_eq:\n  assumes eq: \"h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'\"\n  assumes etc: \"h\\<^sub>0 \\<bottom> h\\<^sub>1\" \"h\\<^sub>0' \\<bottom> h\\<^sub>1'\" \"dom h\\<^sub>0 = dom h\\<^sub>0'\"\n  shows \"h\\<^sub>0 = h\\<^sub>0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 = h\\<^sub>0'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. h\\<^sub>0 = h\\<^sub>0'", "from eq"], ["proof (chain)\npicking this:\n  h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'", "have \"h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'\""], ["proof (prove)\nusing this:\n  h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'\n\ngoal (1 subgoal):\n 1. h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'", "using etc"], ["proof (prove)\nusing this:\n  h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'\n  h\\<^sub>0 \\<bottom> h\\<^sub>1\n  h\\<^sub>0' \\<bottom> h\\<^sub>1'\n  dom h\\<^sub>0 = dom h\\<^sub>0'\n\ngoal (1 subgoal):\n 1. h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'", "by (simp add: map_add_ac)"], ["proof (state)\nthis:\n  h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'\n\ngoal (1 subgoal):\n 1. h\\<^sub>0 = h\\<^sub>0'", "thus ?thesis"], ["proof (prove)\nusing this:\n  h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'\n\ngoal (1 subgoal):\n 1. h\\<^sub>0 = h\\<^sub>0'", "using etc"], ["proof (prove)\nusing this:\n  h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'\n  h\\<^sub>0 \\<bottom> h\\<^sub>1\n  h\\<^sub>0' \\<bottom> h\\<^sub>1'\n  dom h\\<^sub>0 = dom h\\<^sub>0'\n\ngoal (1 subgoal):\n 1. h\\<^sub>0 = h\\<^sub>0'", "by (fastforce elim!: map_add_right_dom_eq simp: map_add_ac)"], ["proof (state)\nthis:\n  h\\<^sub>0 = h\\<^sub>0'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_add_left_eq:\n  assumes eq: \"h\\<^sub>0 ++ h = h\\<^sub>1 ++ h\"\n  assumes disj: \"h\\<^sub>0 \\<bottom> h\" \"h\\<^sub>1 \\<bottom> h\"\n  shows \"h\\<^sub>0 = h\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 = h\\<^sub>1", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "from eq"], ["proof (chain)\npicking this:\n  h\\<^sub>0 ++ h = h\\<^sub>1 ++ h", "have eq': \"(h\\<^sub>0 ++ h) x = (h\\<^sub>1 ++ h) x\""], ["proof (prove)\nusing this:\n  h\\<^sub>0 ++ h = h\\<^sub>1 ++ h\n\ngoal (1 subgoal):\n 1. (h\\<^sub>0 ++ h) x = (h\\<^sub>1 ++ h) x", "by (auto intro!: ext)"], ["proof (state)\nthis:\n  (h\\<^sub>0 ++ h) x = (h\\<^sub>1 ++ h) x\n\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "{"], ["proof (state)\nthis:\n  (h\\<^sub>0 ++ h) x = (h\\<^sub>1 ++ h) x\n\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "assume \"x \\<in> dom h\""], ["proof (state)\nthis:\n  x \\<in> dom h\n\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "hence \"h\\<^sub>0 x = h\\<^sub>1 x\""], ["proof (prove)\nusing this:\n  x \\<in> dom h\n\ngoal (1 subgoal):\n 1. h\\<^sub>0 x = h\\<^sub>1 x", "using disj"], ["proof (prove)\nusing this:\n  x \\<in> dom h\n  h\\<^sub>0 \\<bottom> h\n  h\\<^sub>1 \\<bottom> h\n\ngoal (1 subgoal):\n 1. h\\<^sub>0 x = h\\<^sub>1 x", "by (simp add: map_disj_None_left)"], ["proof (state)\nthis:\n  h\\<^sub>0 x = h\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "}"], ["proof (state)\nthis:\n  x \\<in> dom h \\<Longrightarrow> h\\<^sub>0 x = h\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "moreover"], ["proof (state)\nthis:\n  x \\<in> dom h \\<Longrightarrow> h\\<^sub>0 x = h\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "{"], ["proof (state)\nthis:\n  x \\<in> dom h \\<Longrightarrow> h\\<^sub>0 x = h\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "assume \"x \\<notin> dom h\""], ["proof (state)\nthis:\n  x \\<notin> dom h\n\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "hence \"h\\<^sub>0 x = h\\<^sub>1 x\""], ["proof (prove)\nusing this:\n  x \\<notin> dom h\n\ngoal (1 subgoal):\n 1. h\\<^sub>0 x = h\\<^sub>1 x", "using disj eq'"], ["proof (prove)\nusing this:\n  x \\<notin> dom h\n  h\\<^sub>0 \\<bottom> h\n  h\\<^sub>1 \\<bottom> h\n  (h\\<^sub>0 ++ h) x = (h\\<^sub>1 ++ h) x\n\ngoal (1 subgoal):\n 1. h\\<^sub>0 x = h\\<^sub>1 x", "by (simp add: map_add_eval_left')"], ["proof (state)\nthis:\n  h\\<^sub>0 x = h\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "}"], ["proof (state)\nthis:\n  x \\<notin> dom h \\<Longrightarrow> h\\<^sub>0 x = h\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>0 x = h\\<^sub>1 x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> dom h \\<Longrightarrow> h\\<^sub>0 x = h\\<^sub>1 x\n  x \\<notin> dom h \\<Longrightarrow> h\\<^sub>0 x = h\\<^sub>1 x", "show \"h\\<^sub>0 x = h\\<^sub>1 x\""], ["proof (prove)\nusing this:\n  x \\<in> dom h \\<Longrightarrow> h\\<^sub>0 x = h\\<^sub>1 x\n  x \\<notin> dom h \\<Longrightarrow> h\\<^sub>0 x = h\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. h\\<^sub>0 x = h\\<^sub>1 x", "by cases"], ["proof (state)\nthis:\n  h\\<^sub>0 x = h\\<^sub>1 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_add_right_eq:\n  \"\\<lbrakk>h ++ h\\<^sub>0 = h ++ h\\<^sub>1; h\\<^sub>0 \\<bottom> h; h\\<^sub>1 \\<bottom> h\\<rbrakk> \\<Longrightarrow> h\\<^sub>0 = h\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h ++ h\\<^sub>0 = h ++ h\\<^sub>1; h\\<^sub>0 \\<bottom> h;\n     h\\<^sub>1 \\<bottom> h\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>0 = h\\<^sub>1", "by (rule_tac h=h in map_add_left_eq, auto simp: map_add_ac)"], ["", "lemma map_disj_add_eq_dom_right_eq:\n  assumes merge: \"h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'\" and d: \"dom h\\<^sub>0 = dom h\\<^sub>0'\" and\n      ab_disj: \"h\\<^sub>0 \\<bottom> h\\<^sub>1\" and cd_disj: \"h\\<^sub>0' \\<bottom> h\\<^sub>1'\"\n  shows \"h\\<^sub>1 = h\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>1 = h\\<^sub>1'", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>1 x = h\\<^sub>1' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>1 x = h\\<^sub>1' x", "from merge"], ["proof (chain)\npicking this:\n  h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'", "have merge_x: \"(h\\<^sub>0 ++ h\\<^sub>1) x = (h\\<^sub>0' ++ h\\<^sub>1') x\""], ["proof (prove)\nusing this:\n  h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'\n\ngoal (1 subgoal):\n 1. (h\\<^sub>0 ++ h\\<^sub>1) x = (h\\<^sub>0' ++ h\\<^sub>1') x", "by simp"], ["proof (state)\nthis:\n  (h\\<^sub>0 ++ h\\<^sub>1) x = (h\\<^sub>0' ++ h\\<^sub>1') x\n\ngoal (1 subgoal):\n 1. \\<And>x. h\\<^sub>1 x = h\\<^sub>1' x", "with d ab_disj cd_disj"], ["proof (chain)\npicking this:\n  dom h\\<^sub>0 = dom h\\<^sub>0'\n  h\\<^sub>0 \\<bottom> h\\<^sub>1\n  h\\<^sub>0' \\<bottom> h\\<^sub>1'\n  (h\\<^sub>0 ++ h\\<^sub>1) x = (h\\<^sub>0' ++ h\\<^sub>1') x", "show  \"h\\<^sub>1 x = h\\<^sub>1' x\""], ["proof (prove)\nusing this:\n  dom h\\<^sub>0 = dom h\\<^sub>0'\n  h\\<^sub>0 \\<bottom> h\\<^sub>1\n  h\\<^sub>0' \\<bottom> h\\<^sub>1'\n  (h\\<^sub>0 ++ h\\<^sub>1) x = (h\\<^sub>0' ++ h\\<^sub>1') x\n\ngoal (1 subgoal):\n 1. h\\<^sub>1 x = h\\<^sub>1' x", "by - (case_tac \"h\\<^sub>1 x\", case_tac \"h\\<^sub>1' x\", simp, fastforce simp: map_disj_def,\n          case_tac \"h\\<^sub>1' x\", clarsimp, simp add: Some_com,\n          force simp: map_disj_def, simp)"], ["proof (state)\nthis:\n  h\\<^sub>1 x = h\\<^sub>1' x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_disj_add_eq_dom_left_eq:\n  assumes add: \"h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'\" and\n          dom: \"dom h\\<^sub>1 = dom h\\<^sub>1'\" and\n          disj: \"h\\<^sub>0 \\<bottom> h\\<^sub>1\" \"h\\<^sub>0' \\<bottom> h\\<^sub>1'\"\n  shows \"h\\<^sub>0 = h\\<^sub>0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 = h\\<^sub>0'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. h\\<^sub>0 = h\\<^sub>0'", "have \"h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'", "using add disj"], ["proof (prove)\nusing this:\n  h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'\n  h\\<^sub>0 \\<bottom> h\\<^sub>1\n  h\\<^sub>0' \\<bottom> h\\<^sub>1'\n\ngoal (1 subgoal):\n 1. h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'", "by (simp add: map_add_ac)"], ["proof (state)\nthis:\n  h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'\n\ngoal (1 subgoal):\n 1. h\\<^sub>0 = h\\<^sub>0'", "thus ?thesis"], ["proof (prove)\nusing this:\n  h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'\n\ngoal (1 subgoal):\n 1. h\\<^sub>0 = h\\<^sub>0'", "using dom disj"], ["proof (prove)\nusing this:\n  h\\<^sub>1 ++ h\\<^sub>0 = h\\<^sub>1' ++ h\\<^sub>0'\n  dom h\\<^sub>1 = dom h\\<^sub>1'\n  h\\<^sub>0 \\<bottom> h\\<^sub>1\n  h\\<^sub>0' \\<bottom> h\\<^sub>1'\n\ngoal (1 subgoal):\n 1. h\\<^sub>0 = h\\<^sub>0'", "by - (rule map_disj_add_eq_dom_right_eq, auto simp: map_disj_com)"], ["proof (state)\nthis:\n  h\\<^sub>0 = h\\<^sub>0'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_add_left_cancel:\n  assumes disj: \"h\\<^sub>0 \\<bottom> h\\<^sub>1\" \"h\\<^sub>0 \\<bottom> h\\<^sub>1'\"\n  shows \"(h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1') = (h\\<^sub>1 = h\\<^sub>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1') =\n    (h\\<^sub>1 = h\\<^sub>1')", "proof (rule iffI, rule ext)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1' \\<Longrightarrow>\n       h\\<^sub>1 x = h\\<^sub>1' x\n 2. h\\<^sub>1 = h\\<^sub>1' \\<Longrightarrow>\n    h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1'", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1' \\<Longrightarrow>\n       h\\<^sub>1 x = h\\<^sub>1' x\n 2. h\\<^sub>1 = h\\<^sub>1' \\<Longrightarrow>\n    h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1'", "assume \"(h\\<^sub>0 ++ h\\<^sub>1) = (h\\<^sub>0 ++ h\\<^sub>1')\""], ["proof (state)\nthis:\n  h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1' \\<Longrightarrow>\n       h\\<^sub>1 x = h\\<^sub>1' x\n 2. h\\<^sub>1 = h\\<^sub>1' \\<Longrightarrow>\n    h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1'", "hence \"(h\\<^sub>0 ++ h\\<^sub>1) x = (h\\<^sub>0 ++ h\\<^sub>1') x\""], ["proof (prove)\nusing this:\n  h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1'\n\ngoal (1 subgoal):\n 1. (h\\<^sub>0 ++ h\\<^sub>1) x = (h\\<^sub>0 ++ h\\<^sub>1') x", "by (auto intro!: ext)"], ["proof (state)\nthis:\n  (h\\<^sub>0 ++ h\\<^sub>1) x = (h\\<^sub>0 ++ h\\<^sub>1') x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1' \\<Longrightarrow>\n       h\\<^sub>1 x = h\\<^sub>1' x\n 2. h\\<^sub>1 = h\\<^sub>1' \\<Longrightarrow>\n    h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1'", "hence \"h\\<^sub>1 x = h\\<^sub>1' x\""], ["proof (prove)\nusing this:\n  (h\\<^sub>0 ++ h\\<^sub>1) x = (h\\<^sub>0 ++ h\\<^sub>1') x\n\ngoal (1 subgoal):\n 1. h\\<^sub>1 x = h\\<^sub>1' x", "using disj"], ["proof (prove)\nusing this:\n  (h\\<^sub>0 ++ h\\<^sub>1) x = (h\\<^sub>0 ++ h\\<^sub>1') x\n  h\\<^sub>0 \\<bottom> h\\<^sub>1\n  h\\<^sub>0 \\<bottom> h\\<^sub>1'\n\ngoal (1 subgoal):\n 1. h\\<^sub>1 x = h\\<^sub>1' x", "by - (cases \"x \\<in> dom h\\<^sub>0\",\n          simp_all add: map_disj_None_right map_add_eval_right')"], ["proof (state)\nthis:\n  h\\<^sub>1 x = h\\<^sub>1' x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1' \\<Longrightarrow>\n       h\\<^sub>1 x = h\\<^sub>1' x\n 2. h\\<^sub>1 = h\\<^sub>1' \\<Longrightarrow>\n    h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1'", "thus \"h\\<^sub>1 x = h\\<^sub>1' x\""], ["proof (prove)\nusing this:\n  h\\<^sub>1 x = h\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. h\\<^sub>1 x = h\\<^sub>1' x", "by (auto intro!: ext)"], ["proof (state)\nthis:\n  h\\<^sub>1 x = h\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. h\\<^sub>1 = h\\<^sub>1' \\<Longrightarrow>\n    h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0 ++ h\\<^sub>1'", "qed auto"], ["", "lemma map_add_lr_disj:\n  \"\\<lbrakk> h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1'; h\\<^sub>1 \\<bottom> h\\<^sub>1'  \\<rbrakk> \\<Longrightarrow> dom h\\<^sub>1 \\<subseteq> dom h\\<^sub>0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 ++ h\\<^sub>1 = h\\<^sub>0' ++ h\\<^sub>1';\n     h\\<^sub>1 \\<bottom> h\\<^sub>1'\\<rbrakk>\n    \\<Longrightarrow> dom h\\<^sub>1 \\<subseteq> dom h\\<^sub>0'", "by (clarsimp simp: map_disj_def map_add_def, drule_tac x=x in fun_cong)\n     (auto split: option.splits)"], ["", "subsection \\<open>Map disjunction and map updates\\<close>"], ["", "lemma map_disj_update_left [simp]:\n  \"p \\<in> dom h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 \\<bottom> h\\<^sub>1(p \\<mapsto> v) = h\\<^sub>0 \\<bottom> h\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> dom h\\<^sub>1 \\<Longrightarrow>\n    h\\<^sub>0 \\<bottom> h\\<^sub>1(p \\<mapsto> v) =\n    h\\<^sub>0 \\<bottom> h\\<^sub>1", "by (clarsimp simp add: map_disj_def, blast)"], ["", "lemma map_disj_update_right [simp]:\n  \"p \\<in> dom h\\<^sub>1 \\<Longrightarrow> h\\<^sub>1(p \\<mapsto> v) \\<bottom> h\\<^sub>0 = h\\<^sub>1 \\<bottom> h\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> dom h\\<^sub>1 \\<Longrightarrow>\n    h\\<^sub>1(p \\<mapsto> v) \\<bottom> h\\<^sub>0 =\n    h\\<^sub>1 \\<bottom> h\\<^sub>0", "by (simp add: map_disj_com)"], ["", "lemma map_add_update_left:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; p \\<in> dom h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> (h\\<^sub>0 ++ h\\<^sub>1)(p \\<mapsto> v) = (h\\<^sub>0(p \\<mapsto> v) ++ h\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 \\<bottom> h\\<^sub>1; p \\<in> dom h\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (h\\<^sub>0 ++ h\\<^sub>1)(p \\<mapsto> v) =\n                      h\\<^sub>0(p \\<mapsto> v) ++ h\\<^sub>1", "by (drule (1) map_disj_None_right)\n     (auto intro: ext simp: map_add_def cong: option.case_cong)"], ["", "lemma map_add_update_right:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; p \\<in> dom h\\<^sub>1  \\<rbrakk> \\<Longrightarrow> (h\\<^sub>0 ++ h\\<^sub>1)(p \\<mapsto> v) = (h\\<^sub>0 ++ h\\<^sub>1 (p \\<mapsto> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 \\<bottom> h\\<^sub>1; p \\<in> dom h\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> (h\\<^sub>0 ++ h\\<^sub>1)(p \\<mapsto> v) =\n                      h\\<^sub>0 ++ h\\<^sub>1(p \\<mapsto> v)", "by (drule (1) map_disj_None_left)\n     (auto intro: ext simp: map_add_def cong: option.case_cong)"], ["", "lemma map_add3_update:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; h\\<^sub>1  \\<bottom> h\\<^sub>2 ; h\\<^sub>0 \\<bottom> h\\<^sub>2 ; p \\<in> dom h\\<^sub>0 \\<rbrakk>\n  \\<Longrightarrow> (h\\<^sub>0 ++ h\\<^sub>1 ++ h\\<^sub>2)(p \\<mapsto> v) = h\\<^sub>0(p \\<mapsto> v) ++ h\\<^sub>1 ++ h\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 \\<bottom> h\\<^sub>1; h\\<^sub>1 \\<bottom> h\\<^sub>2;\n     h\\<^sub>0 \\<bottom> h\\<^sub>2; p \\<in> dom h\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (h\\<^sub>0 ++ h\\<^sub>1 ++ h\\<^sub>2)(p \\<mapsto> v) =\n                      h\\<^sub>0(p \\<mapsto> v) ++ h\\<^sub>1 ++ h\\<^sub>2", "by (auto simp: map_add_update_left[symmetric] map_add_ac)"], ["", "subsection \\<open>Map disjunction and @{term \"map_le\"}\\<close>"], ["", "lemma map_le_override [simp]:\n  \"\\<lbrakk> h \\<bottom> h' \\<rbrakk> \\<Longrightarrow> h \\<subseteq>\\<^sub>m h ++ h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<bottom> h' \\<Longrightarrow> h \\<subseteq>\\<^sub>m h ++ h'", "by (auto simp: map_le_def map_add_def map_disj_def split: option.splits)"], ["", "lemma map_leI_left:\n  \"\\<lbrakk> h = h\\<^sub>0 ++ h\\<^sub>1 ; h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h = h\\<^sub>0 ++ h\\<^sub>1;\n     h\\<^sub>0 \\<bottom> h\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m h", "by auto"], ["", "lemma map_leI_right:\n  \"\\<lbrakk> h = h\\<^sub>0 ++ h\\<^sub>1 ; h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>1 \\<subseteq>\\<^sub>m h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h = h\\<^sub>0 ++ h\\<^sub>1;\n     h\\<^sub>0 \\<bottom> h\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>1 \\<subseteq>\\<^sub>m h", "by auto"], ["", "lemma map_disj_map_le:\n  \"\\<lbrakk> h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0; h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0' \\<bottom> h\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0;\n     h\\<^sub>0 \\<bottom> h\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>0' \\<bottom> h\\<^sub>1", "by (force simp: map_disj_def map_le_def)"], ["", "lemma map_le_on_disj_left:\n  \"\\<lbrakk> h' \\<subseteq>\\<^sub>m h ; h\\<^sub>0 \\<bottom> h\\<^sub>1 ; h' = h\\<^sub>0 ++ h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h' \\<subseteq>\\<^sub>m h; h\\<^sub>0 \\<bottom> h\\<^sub>1;\n     h' = h\\<^sub>0 ++ h\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m h", "unfolding map_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>dom h'. h' a = h a;\n     h\\<^sub>0 \\<bottom> h\\<^sub>1; h' = h\\<^sub>0 ++ h\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>dom h\\<^sub>0. h\\<^sub>0 a = h a", "by (rule ballI, erule_tac x=a in ballE, auto simp: map_add_eval_left)+"], ["", "lemma map_le_on_disj_right:\n  \"\\<lbrakk> h' \\<subseteq>\\<^sub>m h ; h\\<^sub>0 \\<bottom> h\\<^sub>1 ; h' = h\\<^sub>1 ++ h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h' \\<subseteq>\\<^sub>m h; h\\<^sub>0 \\<bottom> h\\<^sub>1;\n     h' = h\\<^sub>1 ++ h\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m h", "by (auto simp: map_le_on_disj_left map_add_ac)"], ["", "lemma map_le_add_cancel:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1 ; h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0' ++ h\\<^sub>1 \\<subseteq>\\<^sub>m h\\<^sub>0 ++ h\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 \\<bottom> h\\<^sub>1;\n     h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>0' ++ h\\<^sub>1 \\<subseteq>\\<^sub>m\n                      h\\<^sub>0 ++ h\\<^sub>1", "by (auto simp: map_le_def map_add_def map_disj_def split: option.splits)"], ["", "lemma map_le_override_bothD:\n  assumes subm: \"h\\<^sub>0' ++ h\\<^sub>1 \\<subseteq>\\<^sub>m h\\<^sub>0 ++ h\\<^sub>1\"\n  assumes disj': \"h\\<^sub>0' \\<bottom> h\\<^sub>1\"\n  assumes disj: \"h\\<^sub>0 \\<bottom> h\\<^sub>1\"\n  shows \"h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0", "unfolding map_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>dom h\\<^sub>0'. h\\<^sub>0' a = h\\<^sub>0 a", "proof (rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> dom h\\<^sub>0' \\<Longrightarrow> h\\<^sub>0' a = h\\<^sub>0 a", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> dom h\\<^sub>0' \\<Longrightarrow> h\\<^sub>0' a = h\\<^sub>0 a", "assume a: \"a \\<in> dom h\\<^sub>0'\""], ["proof (state)\nthis:\n  a \\<in> dom h\\<^sub>0'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> dom h\\<^sub>0' \\<Longrightarrow> h\\<^sub>0' a = h\\<^sub>0 a", "hence sumeq: \"(h\\<^sub>0' ++ h\\<^sub>1) a = (h\\<^sub>0 ++ h\\<^sub>1) a\""], ["proof (prove)\nusing this:\n  a \\<in> dom h\\<^sub>0'\n\ngoal (1 subgoal):\n 1. (h\\<^sub>0' ++ h\\<^sub>1) a = (h\\<^sub>0 ++ h\\<^sub>1) a", "using subm"], ["proof (prove)\nusing this:\n  a \\<in> dom h\\<^sub>0'\n  h\\<^sub>0' ++ h\\<^sub>1 \\<subseteq>\\<^sub>m h\\<^sub>0 ++ h\\<^sub>1\n\ngoal (1 subgoal):\n 1. (h\\<^sub>0' ++ h\\<^sub>1) a = (h\\<^sub>0 ++ h\\<^sub>1) a", "unfolding map_le_def"], ["proof (prove)\nusing this:\n  a \\<in> dom h\\<^sub>0'\n  \\<forall>a\\<in>dom (h\\<^sub>0' ++ h\\<^sub>1).\n     (h\\<^sub>0' ++ h\\<^sub>1) a = (h\\<^sub>0 ++ h\\<^sub>1) a\n\ngoal (1 subgoal):\n 1. (h\\<^sub>0' ++ h\\<^sub>1) a = (h\\<^sub>0 ++ h\\<^sub>1) a", "by auto"], ["proof (state)\nthis:\n  (h\\<^sub>0' ++ h\\<^sub>1) a = (h\\<^sub>0 ++ h\\<^sub>1) a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> dom h\\<^sub>0' \\<Longrightarrow> h\\<^sub>0' a = h\\<^sub>0 a", "from a"], ["proof (chain)\npicking this:\n  a \\<in> dom h\\<^sub>0'", "have \"a \\<notin> dom h\\<^sub>1\""], ["proof (prove)\nusing this:\n  a \\<in> dom h\\<^sub>0'\n\ngoal (1 subgoal):\n 1. a \\<notin> dom h\\<^sub>1", "using disj'"], ["proof (prove)\nusing this:\n  a \\<in> dom h\\<^sub>0'\n  h\\<^sub>0' \\<bottom> h\\<^sub>1\n\ngoal (1 subgoal):\n 1. a \\<notin> dom h\\<^sub>1", "by (auto dest!: map_disj_None_right)"], ["proof (state)\nthis:\n  a \\<notin> dom h\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> dom h\\<^sub>0' \\<Longrightarrow> h\\<^sub>0' a = h\\<^sub>0 a", "thus \"h\\<^sub>0' a = h\\<^sub>0 a\""], ["proof (prove)\nusing this:\n  a \\<notin> dom h\\<^sub>1\n\ngoal (1 subgoal):\n 1. h\\<^sub>0' a = h\\<^sub>0 a", "using a sumeq disj disj'"], ["proof (prove)\nusing this:\n  a \\<notin> dom h\\<^sub>1\n  a \\<in> dom h\\<^sub>0'\n  (h\\<^sub>0' ++ h\\<^sub>1) a = (h\\<^sub>0 ++ h\\<^sub>1) a\n  h\\<^sub>0 \\<bottom> h\\<^sub>1\n  h\\<^sub>0' \\<bottom> h\\<^sub>1\n\ngoal (1 subgoal):\n 1. h\\<^sub>0' a = h\\<^sub>0 a", "by (simp add: map_add_eval_left map_add_eval_left')"], ["proof (state)\nthis:\n  h\\<^sub>0' a = h\\<^sub>0 a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_le_conv:\n  \"(h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0 \\<and> h\\<^sub>0' \\<noteq> h\\<^sub>0) = (\\<exists>h\\<^sub>1. h\\<^sub>0 = h\\<^sub>0' ++ h\\<^sub>1 \\<and> h\\<^sub>0' \\<bottom> h\\<^sub>1 \\<and> h\\<^sub>0' \\<noteq> h\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0 \\<and>\n     h\\<^sub>0' \\<noteq> h\\<^sub>0) =\n    (\\<exists>h\\<^sub>1.\n        h\\<^sub>0 = h\\<^sub>0' ++ h\\<^sub>1 \\<and>\n        h\\<^sub>0' \\<bottom> h\\<^sub>1 \\<and> h\\<^sub>0' \\<noteq> h\\<^sub>0)", "unfolding map_le_def map_disj_def map_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>a\\<in>dom h\\<^sub>0'. h\\<^sub>0' a = h\\<^sub>0 a) \\<and>\n     h\\<^sub>0' \\<noteq> h\\<^sub>0) =\n    (\\<exists>h\\<^sub>1.\n        h\\<^sub>0 =\n        (\\<lambda>x.\n            case h\\<^sub>1 x of None \\<Rightarrow> h\\<^sub>0' x\n            | Some x \\<Rightarrow> Some x) \\<and>\n        dom h\\<^sub>0' \\<inter> dom h\\<^sub>1 = {} \\<and>\n        h\\<^sub>0' \\<noteq> h\\<^sub>0)", "by (rule iffI,\n      clarsimp intro!: exI[where x=\"\\<lambda>x. if x \\<notin> dom h\\<^sub>0' then h\\<^sub>0 x else None\"])\n     (fastforce intro: ext intro: split: option.splits if_split_asm)+"], ["", "lemma map_le_conv2:\n  \"h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0 = (\\<exists>h\\<^sub>1. h\\<^sub>0 = h\\<^sub>0' ++ h\\<^sub>1 \\<and> h\\<^sub>0' \\<bottom> h\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h\\<^sub>0' \\<subseteq>\\<^sub>m h\\<^sub>0) =\n    (\\<exists>h\\<^sub>1.\n        h\\<^sub>0 = h\\<^sub>0' ++ h\\<^sub>1 \\<and>\n        h\\<^sub>0' \\<bottom> h\\<^sub>1)", "by (case_tac \"h\\<^sub>0'=h\\<^sub>0\", insert map_le_conv, auto intro: exI[where x=Map.empty])"], ["", "subsection \\<open>Map disjunction and restriction\\<close>"], ["", "lemma map_disj_comp [simp]:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 |` (UNIV - dom h\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 |` (UNIV - dom h\\<^sub>0)", "by (force simp: map_disj_def)"], ["", "lemma restrict_map_disj:\n  \"S \\<inter> T = {} \\<Longrightarrow> h |` S \\<bottom> h |` T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<inter> T = {} \\<Longrightarrow> h |` S \\<bottom> h |` T", "by (auto simp: map_disj_def restrict_map_def dom_def)"], ["", "lemma map_disj_restrict_dom [simp]:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 |` (dom h\\<^sub>1 - dom h\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 |` (dom h\\<^sub>1 - dom h\\<^sub>0)", "by (force simp: map_disj_def)"], ["", "lemma restrict_map_disj_dom_empty:\n  \"h \\<bottom> h' \\<Longrightarrow> h |` dom h' = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<bottom> h' \\<Longrightarrow> h |` dom h' = Map.empty", "by (fastforce simp: map_disj_def restrict_map_def intro: ext)"], ["", "lemma restrict_map_univ_disj_eq:\n  \"h \\<bottom> h' \\<Longrightarrow> h |` (UNIV - dom h') = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<bottom> h' \\<Longrightarrow> h |` (UNIV - dom h') = h", "by (rule ext, auto simp: map_disj_def restrict_map_def)"], ["", "lemma restrict_map_disj_dom:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h |` dom h\\<^sub>0 \\<bottom> h |` dom h\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow>\n    h |` dom h\\<^sub>0 \\<bottom> h |` dom h\\<^sub>1", "by (auto simp: map_disj_def restrict_map_def dom_def)"], ["", "lemma map_add_restrict_dom_left:\n  \"h \\<bottom> h' \\<Longrightarrow> (h ++ h') |` dom h = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<bottom> h' \\<Longrightarrow> (h ++ h') |` dom h = h", "by (rule ext, auto simp: restrict_map_def map_add_def dom_def map_disj_def\n                     split: option.splits)"], ["", "lemma map_add_restrict_dom_left':\n  \"h \\<bottom> h' \\<Longrightarrow> S = dom h \\<Longrightarrow> (h ++ h') |` S = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<bottom> h'; S = dom h\\<rbrakk>\n    \\<Longrightarrow> (h ++ h') |` S = h", "by (rule ext, auto simp: restrict_map_def map_add_def dom_def map_disj_def\n                     split: option.splits)"], ["", "lemma restrict_map_disj_left:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 |` S \\<bottom> h\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow>\n    h\\<^sub>0 |` S \\<bottom> h\\<^sub>1", "by (auto simp: map_disj_def)"], ["", "lemma restrict_map_disj_right:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 \\<bottom> h\\<^sub>1 |` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow>\n    h\\<^sub>0 \\<bottom> h\\<^sub>1 |` S", "by (auto simp: map_disj_def)"], ["", "lemmas restrict_map_disj_both = restrict_map_disj_right restrict_map_disj_left"], ["", "lemma map_dom_disj_restrict_right:\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> (h\\<^sub>0 ++ h\\<^sub>0') |` dom h\\<^sub>1 = h\\<^sub>0' |` dom h\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow>\n    (h\\<^sub>0 ++ h\\<^sub>0') |` dom h\\<^sub>1 = h\\<^sub>0' |` dom h\\<^sub>1", "by (simp add: map_add_restrict restrict_map_empty map_disj_def)"], ["", "lemma restrict_map_on_disj:\n  \"h\\<^sub>0' \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 |` dom h\\<^sub>0' \\<bottom> h\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0' \\<bottom> h\\<^sub>1 \\<Longrightarrow>\n    h\\<^sub>0 |` dom h\\<^sub>0' \\<bottom> h\\<^sub>1", "unfolding map_disj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom h\\<^sub>0' \\<inter> dom h\\<^sub>1 = {} \\<Longrightarrow>\n    dom (h\\<^sub>0 |` dom h\\<^sub>0') \\<inter> dom h\\<^sub>1 = {}", "by auto"], ["", "lemma restrict_map_on_disj':\n  \"h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow> h\\<^sub>0 \\<bottom> h\\<^sub>1 |` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<Longrightarrow>\n    h\\<^sub>0 \\<bottom> h\\<^sub>1 |` S", "by (auto simp: map_disj_def map_add_def)"], ["", "lemma map_le_sub_dom:\n  \"\\<lbrakk> h\\<^sub>0 ++ h\\<^sub>1 \\<subseteq>\\<^sub>m h ; h\\<^sub>0 \\<bottom> h\\<^sub>1 \\<rbrakk> \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m h |` (dom h - dom h\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 ++ h\\<^sub>1 \\<subseteq>\\<^sub>m h;\n     h\\<^sub>0 \\<bottom> h\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>0 \\<subseteq>\\<^sub>m\n                      h |` (dom h - dom h\\<^sub>1)", "by (rule map_le_override_bothD, subst map_le_dom_restrict_sub_add)\n     (auto elim: map_add_le_mapE simp: map_add_ac)"], ["", "lemma map_submap_break:\n  \"\\<lbrakk> h \\<subseteq>\\<^sub>m h' \\<rbrakk> \\<Longrightarrow> h' = (h' |` (UNIV - dom h)) ++ h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<subseteq>\\<^sub>m h' \\<Longrightarrow>\n    h' = h' |` (UNIV - dom h) ++ h", "by (fastforce intro!: ext split: option.splits\n               simp: map_le_restrict restrict_map_def map_le_def map_add_def\n                     dom_def)"], ["", "lemma map_add_disj_restrict_both:\n  \"\\<lbrakk> h\\<^sub>0 \\<bottom> h\\<^sub>1; S \\<inter> S' = {}; T \\<inter> T' = {} \\<rbrakk>\n   \\<Longrightarrow> (h\\<^sub>0 |` S) ++ (h\\<^sub>1 |` T) \\<bottom> (h\\<^sub>0 |` S') ++ (h\\<^sub>1 |` T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h\\<^sub>0 \\<bottom> h\\<^sub>1; S \\<inter> S' = {};\n     T \\<inter> T' = {}\\<rbrakk>\n    \\<Longrightarrow> h\\<^sub>0 |` S ++ h\\<^sub>1 |` T \\<bottom>\n                      h\\<^sub>0 |` S' ++ h\\<^sub>1 |` T'", "by (auto simp: map_add_ac intro!: restrict_map_disj_both restrict_map_disj)"], ["", "end"]]}