{"file_name": "/home/qj213/afp-2021-10-22/thys/Separation_Algebra/Separation_Algebra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Separation_Algebra", "problem_names": ["lemma sep_disj_commute: \"x ## y = y ## x\"", "lemma sep_add_left_commute:\n  assumes a: \"a ## b\" \"b ## c\" \"a ## c\"\n  shows \"b + (a + c) = a + (b + c)\" (is \"?lhs = ?rhs\")", "lemmas sep_add_ac = sep_add_assoc sep_add_commute sep_add_left_commute\n                    sep_disj_commute", "lemma disjoint_zero_sym [simp]: \"0 ## x\"", "lemma sep_add_zero_sym [simp]: \"0 + x = x\"", "lemma sep_disj_addD2: \"\\<lbrakk> x ## y + z; y ## z \\<rbrakk> \\<Longrightarrow> x ## z\"", "lemma sep_disj_addD: \"\\<lbrakk> x ## y + z; y ## z \\<rbrakk> \\<Longrightarrow> x ## y \\<and> x ## z\"", "lemma sep_add_disjD: \"\\<lbrakk> x + y ## z; x ## y \\<rbrakk> \\<Longrightarrow> x ## z \\<and> y ## z\"", "lemma sep_disj_addI2:\n  \"\\<lbrakk> x ## y + z; y ## z \\<rbrakk> \\<Longrightarrow> x + z ## y\"", "lemma sep_add_disjI1:\n  \"\\<lbrakk> x + y ## z; x ## y \\<rbrakk> \\<Longrightarrow> x + z ## y\"", "lemma sep_add_disjI2:\n  \"\\<lbrakk> x + y ## z; x ## y \\<rbrakk> \\<Longrightarrow> z + y ## x\"", "lemma sep_disj_addI3:\n   \"x + y ## z \\<Longrightarrow> x ## y \\<Longrightarrow> x ## y + z\"", "lemma sep_disj_add:\n  \"\\<lbrakk> y ## z; x ## y \\<rbrakk> \\<Longrightarrow> x ## y + z = x + y ## z\"", "lemma sep_substate_disj_add:\n  \"x ## y \\<Longrightarrow> x \\<preceq> x + y\"", "lemma sep_substate_disj_add':\n  \"x ## y \\<Longrightarrow> x \\<preceq> y + x\"", "lemma sep_conjD:\n  \"(P \\<and>* Q) h \\<Longrightarrow> \\<exists>x y. x ## y \\<and> h = x + y \\<and> P x \\<and> Q y\"", "lemma sep_conjE:\n  \"\\<lbrakk> (P ** Q) h; \\<And>x y. \\<lbrakk> P x; Q y; x ## y; h = x + y \\<rbrakk> \\<Longrightarrow> X \\<rbrakk> \\<Longrightarrow> X\"", "lemma sep_conjI:\n  \"\\<lbrakk> P x; Q y; x ## y; h = x + y \\<rbrakk> \\<Longrightarrow> (P ** Q) h\"", "lemma sep_conj_commuteI:\n  \"(P ** Q) h \\<Longrightarrow> (Q ** P) h\"", "lemma sep_conj_commute:\n  \"(P ** Q) = (Q ** P)\"", "lemma sep_conj_assoc:\n  \"((P ** Q) ** R) = (P ** Q ** R)\" (is \"?lhs = ?rhs\")", "lemma sep_conj_impl:\n  \"\\<lbrakk> (P ** Q) h; \\<And>h. P h \\<Longrightarrow> P' h; \\<And>h. Q h \\<Longrightarrow> Q' h \\<rbrakk> \\<Longrightarrow> (P' ** Q') h\"", "lemma sep_conj_impl1:\n  assumes P: \"\\<And>h. P h \\<Longrightarrow> I h\"\n  shows \"(P ** R) h \\<Longrightarrow> (I ** R) h\"", "lemma sep_globalise:\n  \"\\<lbrakk> (P ** R) h; (\\<And>h. P h \\<Longrightarrow> Q h) \\<rbrakk> \\<Longrightarrow> (Q ** R) h\"", "lemma sep_conj_trivial_strip2:\n  \"Q = R \\<Longrightarrow> (Q ** P) = (R ** P)\"", "lemma disjoint_subheaps_exist:\n  \"\\<exists>x y. x ## y \\<and> h = x + y\"", "lemma sep_conj_left_commute: (* for permutative rewriting *)\n  \"(P ** (Q ** R)) = (Q ** (P ** R))\" (is \"?x = ?y\")", "lemmas sep_conj_ac = sep_conj_commute sep_conj_assoc sep_conj_left_commute", "lemma ab_semigroup_mult_sep_conj: \"class.ab_semigroup_mult (**)\"", "lemma sep_empty_zero [simp,intro!]: \"\\<box> 0\"", "lemma sep_conj_sep_true:\n  \"P h \\<Longrightarrow> (P ** sep_true) h\"", "lemma sep_conj_sep_true':\n  \"P h \\<Longrightarrow> (sep_true ** P) h\"", "lemma sep_conj_true [simp]:\n  \"(sep_true ** sep_true) = sep_true\"", "lemma sep_conj_false_right [simp]:\n  \"(P ** sep_false) = sep_false\"", "lemma sep_conj_false_left [simp]:\n  \"(sep_false ** P) = sep_false\"", "lemma sep_conj_empty [simp]:\n  \"(P ** \\<box>) = P\"", "lemma sep_conj_empty'[simp]:\n  \"(\\<box> ** P) = P\"", "lemma sep_conj_sep_emptyI:\n  \"P h \\<Longrightarrow> (P ** \\<box>) h\"", "lemma sep_conj_sep_emptyE:\n  \"\\<lbrakk> P s; (P ** \\<box>) s \\<Longrightarrow> (Q ** R) s \\<rbrakk> \\<Longrightarrow> (Q ** R) s\"", "lemma monoid_add: \"class.monoid_add ((**)) \\<box>\"", "lemma comm_monoid_add: \"class.comm_monoid_add (**) \\<box>\"", "lemma sep_conj_true_P [simp]:\n  \"(sep_true ** (sep_true ** P)) = (sep_true ** P)\"", "lemma sep_conj_disj:\n  \"((P or Q) ** R) = ((P ** R) or (Q ** R))\"", "lemma sep_conj_sep_true_left:\n  \"(P ** Q) h \\<Longrightarrow> (sep_true ** Q) h\"", "lemma sep_conj_sep_true_right:\n  \"(P ** Q) h \\<Longrightarrow> (P ** sep_true) h\"", "lemma sep_conj_conj:\n  \"((P and Q) ** R) h \\<Longrightarrow> ((P ** R) and (Q ** R)) h\"", "lemma sep_conj_exists1:\n  \"((EXS x. P x) ** Q) = (EXS x. (P x ** Q))\"", "lemma sep_conj_exists2:\n  \"(P ** (EXS x. Q x)) = (EXS x. P ** Q x)\"", "lemmas sep_conj_exists = sep_conj_exists1 sep_conj_exists2", "lemma sep_conj_spec:\n  \"((ALLS x. P x) ** Q) h \\<Longrightarrow> (P x ** Q) h\"", "lemma sep_implI:\n  assumes a: \"\\<And>h'. \\<lbrakk> h ## h'; P h' \\<rbrakk> \\<Longrightarrow> Q (h + h')\"\n  shows \"(P \\<longrightarrow>* Q) h\"", "lemma sep_implD:\n  \"(x \\<longrightarrow>* y) h \\<Longrightarrow> \\<forall>h'. h ## h' \\<and> x h' \\<longrightarrow> y (h + h')\"", "lemma sep_implE:\n  \"(x \\<longrightarrow>* y) h \\<Longrightarrow> (\\<forall>h'. h ## h' \\<and> x h' \\<longrightarrow> y (h + h') \\<Longrightarrow> Q) \\<Longrightarrow> Q\"", "lemma sep_impl_sep_true [simp]:\n  \"(P \\<longrightarrow>* sep_true) = sep_true\"", "lemma sep_impl_sep_false [simp]:\n  \"(sep_false \\<longrightarrow>* P) = sep_true\"", "lemma sep_impl_sep_true_P:\n  \"(sep_true \\<longrightarrow>* P) h \\<Longrightarrow> P h\"", "lemma sep_impl_sep_true_false [simp]:\n  \"(sep_true \\<longrightarrow>* sep_false) = sep_false\"", "lemma sep_conj_sep_impl:\n  \"\\<lbrakk> P h; \\<And>h. (P ** Q) h \\<Longrightarrow> R h \\<rbrakk> \\<Longrightarrow> (Q \\<longrightarrow>* R) h\"", "lemma sep_conj_sep_impl2:\n  \"\\<lbrakk> (P ** Q) h; \\<And>h. P h \\<Longrightarrow> (Q \\<longrightarrow>* R) h \\<rbrakk> \\<Longrightarrow> R h\"", "lemma sep_conj_sep_impl_sep_conj2:\n  \"(P ** R) h \\<Longrightarrow> (P ** (Q \\<longrightarrow>* (Q ** R))) h\"", "lemma pure_sep_true:\n  \"pure sep_true\"", "lemma pure_sep_false:\n  \"pure sep_true\"", "lemma pure_split:\n  \"pure P = (P = sep_true \\<or> P = sep_false)\"", "lemma pure_sep_conj:\n  \"\\<lbrakk> pure P; pure Q \\<rbrakk> \\<Longrightarrow> pure (P \\<and>* Q)\"", "lemma pure_sep_impl:\n  \"\\<lbrakk> pure P; pure Q \\<rbrakk> \\<Longrightarrow> pure (P \\<longrightarrow>* Q)\"", "lemma pure_conj_sep_conj:\n  \"\\<lbrakk> (P and Q) h; pure P \\<or> pure Q \\<rbrakk> \\<Longrightarrow> (P \\<and>* Q) h\"", "lemma pure_sep_conj_conj:\n  \"\\<lbrakk> (P \\<and>* Q) h; pure P; pure Q \\<rbrakk> \\<Longrightarrow> (P and Q) h\"", "lemma pure_conj_sep_conj_assoc:\n  \"pure P \\<Longrightarrow> ((P and Q) \\<and>* R) = (P and (Q \\<and>* R))\"", "lemma pure_sep_impl_impl:\n  \"\\<lbrakk> (P \\<longrightarrow>* Q) h; pure P \\<rbrakk> \\<Longrightarrow> P h \\<longrightarrow> Q h\"", "lemma pure_impl_sep_impl:\n  \"\\<lbrakk> P h \\<longrightarrow> Q h; pure P; pure Q \\<rbrakk> \\<Longrightarrow> (P \\<longrightarrow>* Q) h\"", "lemma pure_conj_right: \"(Q \\<and>* (\\<langle>P'\\<rangle> and Q')) = (\\<langle>P'\\<rangle> and (Q \\<and>* Q'))\"", "lemma pure_conj_right': \"(Q \\<and>* (P' and \\<langle>Q'\\<rangle>)) = (\\<langle>Q'\\<rangle> and (Q \\<and>* P'))\"", "lemma pure_conj_left: \"((\\<langle>P'\\<rangle> and Q') \\<and>* Q) = (\\<langle>P'\\<rangle> and (Q' \\<and>* Q))\"", "lemma pure_conj_left': \"((P' and \\<langle>Q'\\<rangle>) \\<and>* Q) = (\\<langle>Q'\\<rangle> and (P' \\<and>* Q))\"", "lemmas pure_conj = pure_conj_right pure_conj_right' pure_conj_left\n    pure_conj_left'", "lemma intuitionisticI:\n  \"(\\<And>h h'. \\<lbrakk> P h; h \\<preceq> h' \\<rbrakk> \\<Longrightarrow> P h') \\<Longrightarrow> intuitionistic P\"", "lemma intuitionisticD:\n  \"\\<lbrakk> intuitionistic P; P h; h \\<preceq> h' \\<rbrakk> \\<Longrightarrow> P h'\"", "lemma pure_intuitionistic:\n  \"pure P \\<Longrightarrow> intuitionistic P\"", "lemma intuitionistic_conj:\n  \"\\<lbrakk> intuitionistic P; intuitionistic Q \\<rbrakk> \\<Longrightarrow> intuitionistic (P and Q)\"", "lemma intuitionistic_disj:\n  \"\\<lbrakk> intuitionistic P; intuitionistic Q \\<rbrakk> \\<Longrightarrow> intuitionistic (P or Q)\"", "lemma intuitionistic_forall:\n  \"(\\<And>x. intuitionistic (P x)) \\<Longrightarrow> intuitionistic (ALLS x. P x)\"", "lemma intuitionistic_exists:\n  \"(\\<And>x. intuitionistic (P x)) \\<Longrightarrow> intuitionistic (EXS x. P x)\"", "lemma intuitionistic_sep_conj_sep_true:\n  \"intuitionistic (sep_true \\<and>* P)\"", "lemma intuitionistic_sep_impl_sep_true:\n  \"intuitionistic (sep_true \\<longrightarrow>* P)\"", "lemma intuitionistic_sep_conj:\n  assumes ip: \"intuitionistic (P::('a \\<Rightarrow> bool))\"\n  shows \"intuitionistic (P \\<and>* Q)\"", "lemma intuitionistic_sep_impl:\n  assumes iq: \"intuitionistic Q\"\n  shows \"intuitionistic (P \\<longrightarrow>* Q)\"", "lemma strongest_intuitionistic:\n  \"\\<not> (\\<exists>Q. (\\<forall>h. (Q h \\<longrightarrow> (P \\<and>* sep_true) h)) \\<and> intuitionistic Q \\<and>\n      Q \\<noteq> (P \\<and>* sep_true) \\<and> (\\<forall>h. P h \\<longrightarrow> Q h))\"", "lemma weakest_intuitionistic:\n  \"\\<not> (\\<exists>Q. (\\<forall>h. ((sep_true \\<longrightarrow>* P) h \\<longrightarrow> Q h)) \\<and> intuitionistic Q \\<and>\n      Q \\<noteq> (sep_true \\<longrightarrow>* P) \\<and> (\\<forall>h. Q h \\<longrightarrow> P h))\"", "lemma intuitionistic_sep_conj_sep_true_P:\n  \"\\<lbrakk> (P \\<and>* sep_true) s; intuitionistic P \\<rbrakk> \\<Longrightarrow> P s\"", "lemma intuitionistic_sep_conj_sep_true_simp:\n  \"intuitionistic P \\<Longrightarrow> (P \\<and>* sep_true) = P\"", "lemma intuitionistic_sep_impl_sep_true_P:\n  \"\\<lbrakk> P h; intuitionistic P \\<rbrakk> \\<Longrightarrow> (sep_true \\<longrightarrow>* P) h\"", "lemma intuitionistic_sep_impl_sep_true_simp:\n  \"intuitionistic P \\<Longrightarrow> (sep_true \\<longrightarrow>* P) = P\"", "lemma strictly_exactD:\n  \"\\<lbrakk> strictly_exact P; P h; P h' \\<rbrakk> \\<Longrightarrow> h = h'\"", "lemma strictly_exactI:\n  \"(\\<And>h h'. \\<lbrakk> P h; P h' \\<rbrakk> \\<Longrightarrow> h = h') \\<Longrightarrow> strictly_exact P\"", "lemma strictly_exact_sep_conj:\n  \"\\<lbrakk> strictly_exact P; strictly_exact Q \\<rbrakk> \\<Longrightarrow> strictly_exact (P \\<and>* Q)\"", "lemma strictly_exact_conj_impl:\n  \"\\<lbrakk> (Q \\<and>* sep_true) h; P h; strictly_exact Q \\<rbrakk> \\<Longrightarrow> (Q \\<and>* (Q \\<longrightarrow>* P)) h\"", "lemma sep_disj_add_eq [simp]: \"x ## y \\<Longrightarrow> x + y ## z = (x ## z \\<and> y ## z)\"", "lemma sep_list_conj_Nil [simp]: \"\\<And>* [] = \\<box>\"", "lemma (in semigroup_add) foldl_assoc:\nshows \"foldl (+) (x+y) zs = x + (foldl (+) y zs)\"", "lemma (in monoid_add) foldl_absorb0:\nshows \"x + (foldl (+) 0 zs) = foldl (+) x zs\"", "lemma sep_list_conj_Cons [simp]: \"\\<And>* (x#xs) = (x ** \\<And>* xs)\"", "lemma sep_list_conj_append [simp]: \"\\<And>* (xs @ ys) = (\\<And>* xs ** \\<And>* ys)\"", "lemma (in comm_monoid_add) foldl_map_filter:\n  \"foldl (+) 0 (map f (filter P xs)) +\n     foldl (+) 0 (map f (filter (not P) xs))\n   = foldl (+) 0 (map f xs)\"", "lemma \"precise ((=) s)\"", "lemma sep_add_cancel:\n  \"x ## z \\<Longrightarrow> y ## z \\<Longrightarrow> (x + z = y + z) = (x = y)\"", "lemma precise_distribute:\n  \"precise P = (\\<forall>Q R. ((Q and R) \\<and>* P) = ((Q \\<and>* P) and (R \\<and>* P)))\"", "lemma strictly_precise: \"strictly_exact P \\<Longrightarrow> precise P\""], "translations": [["", "lemma sep_disj_commute: \"x ## y = y ## x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ## y = y ## x", "by (blast intro: sep_disj_commuteI)"], ["", "lemma sep_add_left_commute:\n  assumes a: \"a ## b\" \"b ## c\" \"a ## c\"\n  shows \"b + (a + c) = a + (b + c)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. b + (a + c) = a + (b + c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b + (a + c) = a + (b + c)", "have \"?lhs = b + a + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b + (a + c) = b + a + c", "using a"], ["proof (prove)\nusing this:\n  a ## b\n  b ## c\n  a ## c\n\ngoal (1 subgoal):\n 1. b + (a + c) = b + a + c", "by (simp add: sep_add_assoc[symmetric] sep_disj_commute)"], ["proof (state)\nthis:\n  b + (a + c) = b + a + c\n\ngoal (1 subgoal):\n 1. b + (a + c) = a + (b + c)", "also"], ["proof (state)\nthis:\n  b + (a + c) = b + a + c\n\ngoal (1 subgoal):\n 1. b + (a + c) = a + (b + c)", "have \"... = a + b + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b + a + c = a + b + c", "using a"], ["proof (prove)\nusing this:\n  a ## b\n  b ## c\n  a ## c\n\ngoal (1 subgoal):\n 1. b + a + c = a + b + c", "by (simp add: sep_add_commute sep_disj_commute)"], ["proof (state)\nthis:\n  b + a + c = a + b + c\n\ngoal (1 subgoal):\n 1. b + (a + c) = a + (b + c)", "also"], ["proof (state)\nthis:\n  b + a + c = a + b + c\n\ngoal (1 subgoal):\n 1. b + (a + c) = a + (b + c)", "have \"... = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "using a"], ["proof (prove)\nusing this:\n  a ## b\n  b ## c\n  a ## c\n\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "by (simp add: sep_add_assoc sep_disj_commute)"], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal (1 subgoal):\n 1. b + (a + c) = a + (b + c)", "finally"], ["proof (chain)\npicking this:\n  b + (a + c) = a + (b + c)", "show ?thesis"], ["proof (prove)\nusing this:\n  b + (a + c) = a + (b + c)\n\ngoal (1 subgoal):\n 1. b + (a + c) = a + (b + c)", "."], ["proof (state)\nthis:\n  b + (a + c) = a + (b + c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas sep_add_ac = sep_add_assoc sep_add_commute sep_add_left_commute\n                    sep_disj_commute"], ["", "(* nearly always necessary *)"], ["", "end"], ["", "section \\<open>Separation Algebra as Defined by Calcagno et al.\\<close>"], ["", "class sep_algebra = pre_sep_algebra +\n  assumes sep_disj_addD1: \"\\<lbrakk> x ## y + z; y ## z \\<rbrakk> \\<Longrightarrow> x ## y\"\n  assumes sep_disj_addI1: \"\\<lbrakk> x ## y + z; y ## z \\<rbrakk> \\<Longrightarrow> x + y ##  z\"\nbegin"], ["", "subsection \\<open>Basic Construct Definitions and Abbreviations\\<close>"], ["", "definition\n  sep_conj :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool)\" (infixr \"**\" 35)\n  where\n  \"P ** Q \\<equiv> \\<lambda>h. \\<exists>x y. x ## y \\<and> h = x + y \\<and> P x \\<and> Q y\""], ["", "notation\n  sep_conj (infixr \"\\<and>*\" 35)"], ["", "definition\n  sep_empty :: \"'a \\<Rightarrow> bool\" (\"\\<box>\") where\n  \"\\<box> \\<equiv> \\<lambda>h. h = 0\""], ["", "definition\n  sep_impl :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> bool)\" (infixr \"\\<longrightarrow>*\" 25)\n  where\n  \"P \\<longrightarrow>* Q \\<equiv> \\<lambda>h. \\<forall>h'. h ## h' \\<and> P h' \\<longrightarrow> Q (h + h')\""], ["", "definition\n  sep_substate :: \"'a => 'a => bool\" (infix \"\\<preceq>\" 60) where\n  \"x \\<preceq> y \\<equiv> \\<exists>z. x ## z \\<and> x + z = y\""], ["", "(* We want these to be abbreviations not definitions, because basic True and\n   False will occur by simplification in sep_conj terms *)"], ["", "abbreviation\n  \"sep_true \\<equiv> \\<langle>True\\<rangle>\""], ["", "abbreviation\n  \"sep_false \\<equiv> \\<langle>False\\<rangle>\""], ["", "definition\n  sep_list_conj :: \"('a \\<Rightarrow> bool) list \\<Rightarrow> ('a \\<Rightarrow> bool)\"  (\"\\<And>* _\" [60] 90) where\n  \"sep_list_conj Ps \\<equiv> foldl (**) \\<box> Ps\""], ["", "subsection \\<open>Disjunction/Addition Properties\\<close>"], ["", "lemma disjoint_zero_sym [simp]: \"0 ## x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) ## x", "by (simp add: sep_disj_commute)"], ["", "lemma sep_add_zero_sym [simp]: \"0 + x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) + x = x", "by (simp add: sep_add_commute)"], ["", "lemma sep_disj_addD2: \"\\<lbrakk> x ## y + z; y ## z \\<rbrakk> \\<Longrightarrow> x ## z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x ## y + z; y ## z\\<rbrakk> \\<Longrightarrow> x ## z", "by (metis sep_disj_addD1 sep_add_ac)"], ["", "lemma sep_disj_addD: \"\\<lbrakk> x ## y + z; y ## z \\<rbrakk> \\<Longrightarrow> x ## y \\<and> x ## z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x ## y + z; y ## z\\<rbrakk>\n    \\<Longrightarrow> x ## y \\<and> x ## z", "by (metis sep_disj_addD1 sep_disj_addD2)"], ["", "lemma sep_add_disjD: \"\\<lbrakk> x + y ## z; x ## y \\<rbrakk> \\<Longrightarrow> x ## z \\<and> y ## z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x + y ## z; x ## y\\<rbrakk>\n    \\<Longrightarrow> x ## z \\<and> y ## z", "by (metis sep_disj_addD sep_disj_commuteI)"], ["", "lemma sep_disj_addI2:\n  \"\\<lbrakk> x ## y + z; y ## z \\<rbrakk> \\<Longrightarrow> x + z ## y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x ## y + z; y ## z\\<rbrakk> \\<Longrightarrow> x + z ## y", "by (metis sep_add_ac sep_disj_addI1)"], ["", "lemma sep_add_disjI1:\n  \"\\<lbrakk> x + y ## z; x ## y \\<rbrakk> \\<Longrightarrow> x + z ## y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x + y ## z; x ## y\\<rbrakk> \\<Longrightarrow> x + z ## y", "by (metis sep_add_ac sep_add_disjD sep_disj_addI2)"], ["", "lemma sep_add_disjI2:\n  \"\\<lbrakk> x + y ## z; x ## y \\<rbrakk> \\<Longrightarrow> z + y ## x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x + y ## z; x ## y\\<rbrakk> \\<Longrightarrow> z + y ## x", "by (metis sep_add_ac sep_add_disjD sep_disj_addI2)"], ["", "lemma sep_disj_addI3:\n   \"x + y ## z \\<Longrightarrow> x ## y \\<Longrightarrow> x ## y + z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x + y ## z; x ## y\\<rbrakk> \\<Longrightarrow> x ## y + z", "by (metis sep_add_ac sep_add_disjD sep_add_disjI2)"], ["", "lemma sep_disj_add:\n  \"\\<lbrakk> y ## z; x ## y \\<rbrakk> \\<Longrightarrow> x ## y + z = x + y ## z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y ## z; x ## y\\<rbrakk>\n    \\<Longrightarrow> x ## y + z = x + y ## z", "by (metis sep_disj_addI1 sep_disj_addI3)"], ["", "subsection \\<open>Substate Properties\\<close>"], ["", "lemma sep_substate_disj_add:\n  \"x ## y \\<Longrightarrow> x \\<preceq> x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ## y \\<Longrightarrow> x \\<preceq> x + y", "unfolding sep_substate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ## y \\<Longrightarrow> \\<exists>z. x ## z \\<and> x + z = x + y", "by blast"], ["", "lemma sep_substate_disj_add':\n  \"x ## y \\<Longrightarrow> x \\<preceq> y + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ## y \\<Longrightarrow> x \\<preceq> y + x", "by (simp add: sep_add_ac sep_substate_disj_add)"], ["", "subsection \\<open>Separating Conjunction Properties\\<close>"], ["", "lemma sep_conjD:\n  \"(P \\<and>* Q) h \\<Longrightarrow> \\<exists>x y. x ## y \\<and> h = x + y \\<and> P x \\<and> Q y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q) h \\<Longrightarrow>\n    \\<exists>x y. x ## y \\<and> h = x + y \\<and> P x \\<and> Q y", "by (simp add: sep_conj_def)"], ["", "lemma sep_conjE:\n  \"\\<lbrakk> (P ** Q) h; \\<And>x y. \\<lbrakk> P x; Q y; x ## y; h = x + y \\<rbrakk> \\<Longrightarrow> X \\<rbrakk> \\<Longrightarrow> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P \\<and>* Q) h;\n     \\<And>x y.\n        \\<lbrakk>P x; Q y; x ## y; h = x + y\\<rbrakk>\n        \\<Longrightarrow> X\\<rbrakk>\n    \\<Longrightarrow> X", "by (auto simp: sep_conj_def)"], ["", "lemma sep_conjI:\n  \"\\<lbrakk> P x; Q y; x ## y; h = x + y \\<rbrakk> \\<Longrightarrow> (P ** Q) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P x; Q y; x ## y; h = x + y\\<rbrakk>\n    \\<Longrightarrow> (P \\<and>* Q) h", "by (auto simp: sep_conj_def)"], ["", "lemma sep_conj_commuteI:\n  \"(P ** Q) h \\<Longrightarrow> (Q ** P) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q) h \\<Longrightarrow> (Q \\<and>* P) h", "by (auto intro!: sep_conjI elim!: sep_conjE simp: sep_add_ac)"], ["", "lemma sep_conj_commute:\n  \"(P ** Q) = (Q ** P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q) = (Q \\<and>* P)", "by (rule ext) (auto intro: sep_conj_commuteI)"], ["", "lemma sep_conj_assoc:\n  \"((P ** Q) ** R) = (P ** Q ** R)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<and>* Q) \\<and>* R) = (P \\<and>* Q \\<and>* R)", "proof (rule ext, rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((P \\<and>* Q) \\<and>* R) x \\<Longrightarrow>\n       (P \\<and>* Q \\<and>* R) x\n 2. \\<And>x.\n       (P \\<and>* Q \\<and>* R) x \\<Longrightarrow>\n       ((P \\<and>* Q) \\<and>* R) x", "fix h"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((P \\<and>* Q) \\<and>* R) x \\<Longrightarrow>\n       (P \\<and>* Q \\<and>* R) x\n 2. \\<And>x.\n       (P \\<and>* Q \\<and>* R) x \\<Longrightarrow>\n       ((P \\<and>* Q) \\<and>* R) x", "assume a: \"?lhs h\""], ["proof (state)\nthis:\n  ((P \\<and>* Q) \\<and>* R) h\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((P \\<and>* Q) \\<and>* R) x \\<Longrightarrow>\n       (P \\<and>* Q \\<and>* R) x\n 2. \\<And>x.\n       (P \\<and>* Q \\<and>* R) x \\<Longrightarrow>\n       ((P \\<and>* Q) \\<and>* R) x", "then"], ["proof (chain)\npicking this:\n  ((P \\<and>* Q) \\<and>* R) h", "obtain x y z where \"P x\" and \"Q y\" and \"R z\"\n                      and \"x ## y\" and \"x ## z\" and \"y ## z\" and \"x + y ## z\"\n                      and \"h = x + y + z\""], ["proof (prove)\nusing this:\n  ((P \\<and>* Q) \\<and>* R) h\n\ngoal (1 subgoal):\n 1. (\\<And>x y z.\n        \\<lbrakk>P x; Q y; R z; x ## y; x ## z; y ## z; x + y ## z;\n         h = x + y + z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: sep_conjD dest: sep_add_disjD)"], ["proof (state)\nthis:\n  P x\n  Q y\n  R z\n  x ## y\n  x ## z\n  y ## z\n  x + y ## z\n  h = x + y + z\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((P \\<and>* Q) \\<and>* R) x \\<Longrightarrow>\n       (P \\<and>* Q \\<and>* R) x\n 2. \\<And>x.\n       (P \\<and>* Q \\<and>* R) x \\<Longrightarrow>\n       ((P \\<and>* Q) \\<and>* R) x", "moreover"], ["proof (state)\nthis:\n  P x\n  Q y\n  R z\n  x ## y\n  x ## z\n  y ## z\n  x + y ## z\n  h = x + y + z\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((P \\<and>* Q) \\<and>* R) x \\<Longrightarrow>\n       (P \\<and>* Q \\<and>* R) x\n 2. \\<And>x.\n       (P \\<and>* Q \\<and>* R) x \\<Longrightarrow>\n       ((P \\<and>* Q) \\<and>* R) x", "then"], ["proof (chain)\npicking this:\n  P x\n  Q y\n  R z\n  x ## y\n  x ## z\n  y ## z\n  x + y ## z\n  h = x + y + z", "have \"x ## y + z\""], ["proof (prove)\nusing this:\n  P x\n  Q y\n  R z\n  x ## y\n  x ## z\n  y ## z\n  x + y ## z\n  h = x + y + z\n\ngoal (1 subgoal):\n 1. x ## y + z", "by (simp add: sep_disj_add)"], ["proof (state)\nthis:\n  x ## y + z\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((P \\<and>* Q) \\<and>* R) x \\<Longrightarrow>\n       (P \\<and>* Q \\<and>* R) x\n 2. \\<And>x.\n       (P \\<and>* Q \\<and>* R) x \\<Longrightarrow>\n       ((P \\<and>* Q) \\<and>* R) x", "ultimately"], ["proof (chain)\npicking this:\n  P x\n  Q y\n  R z\n  x ## y\n  x ## z\n  y ## z\n  x + y ## z\n  h = x + y + z\n  x ## y + z", "show \"?rhs h\""], ["proof (prove)\nusing this:\n  P x\n  Q y\n  R z\n  x ## y\n  x ## z\n  y ## z\n  x + y ## z\n  h = x + y + z\n  x ## y + z\n\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* R) h", "by (auto simp: sep_add_ac intro!: sep_conjI)"], ["proof (state)\nthis:\n  (P \\<and>* Q \\<and>* R) h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (P \\<and>* Q \\<and>* R) x \\<Longrightarrow>\n       ((P \\<and>* Q) \\<and>* R) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (P \\<and>* Q \\<and>* R) x \\<Longrightarrow>\n       ((P \\<and>* Q) \\<and>* R) x", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (P \\<and>* Q \\<and>* R) x \\<Longrightarrow>\n       ((P \\<and>* Q) \\<and>* R) x", "assume a: \"?rhs h\""], ["proof (state)\nthis:\n  (P \\<and>* Q \\<and>* R) h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (P \\<and>* Q \\<and>* R) x \\<Longrightarrow>\n       ((P \\<and>* Q) \\<and>* R) x", "then"], ["proof (chain)\npicking this:\n  (P \\<and>* Q \\<and>* R) h", "obtain x y z where \"P x\" and \"Q y\" and \"R z\"\n                      and \"x ## y\" and \"x ## z\" and \"y ## z\" and \"x ## y + z\"\n                      and \"h = x + y + z\""], ["proof (prove)\nusing this:\n  (P \\<and>* Q \\<and>* R) h\n\ngoal (1 subgoal):\n 1. (\\<And>x y z.\n        \\<lbrakk>P x; Q y; R z; x ## y; x ## z; y ## z; x ## y + z;\n         h = x + y + z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce elim!: sep_conjE simp: sep_add_ac dest: sep_disj_addD)"], ["proof (state)\nthis:\n  P x\n  Q y\n  R z\n  x ## y\n  x ## z\n  y ## z\n  x ## y + z\n  h = x + y + z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (P \\<and>* Q \\<and>* R) x \\<Longrightarrow>\n       ((P \\<and>* Q) \\<and>* R) x", "thus \"?lhs h\""], ["proof (prove)\nusing this:\n  P x\n  Q y\n  R z\n  x ## y\n  x ## z\n  y ## z\n  x ## y + z\n  h = x + y + z\n\ngoal (1 subgoal):\n 1. ((P \\<and>* Q) \\<and>* R) h", "by (metis sep_conj_def sep_disj_addI1)"], ["proof (state)\nthis:\n  ((P \\<and>* Q) \\<and>* R) h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sep_conj_impl:\n  \"\\<lbrakk> (P ** Q) h; \\<And>h. P h \\<Longrightarrow> P' h; \\<And>h. Q h \\<Longrightarrow> Q' h \\<rbrakk> \\<Longrightarrow> (P' ** Q') h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P \\<and>* Q) h; \\<And>h. P h \\<Longrightarrow> P' h;\n     \\<And>h. Q h \\<Longrightarrow> Q' h\\<rbrakk>\n    \\<Longrightarrow> (P' \\<and>* Q') h", "by (erule sep_conjE, auto intro!: sep_conjI)"], ["", "lemma sep_conj_impl1:\n  assumes P: \"\\<And>h. P h \\<Longrightarrow> I h\"\n  shows \"(P ** R) h \\<Longrightarrow> (I ** R) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* R) h \\<Longrightarrow> (I \\<and>* R) h", "by (auto intro: sep_conj_impl P)"], ["", "lemma sep_globalise:\n  \"\\<lbrakk> (P ** R) h; (\\<And>h. P h \\<Longrightarrow> Q h) \\<rbrakk> \\<Longrightarrow> (Q ** R) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P \\<and>* R) h; \\<And>h. P h \\<Longrightarrow> Q h\\<rbrakk>\n    \\<Longrightarrow> (Q \\<and>* R) h", "by (fast elim: sep_conj_impl)"], ["", "lemma sep_conj_trivial_strip2:\n  \"Q = R \\<Longrightarrow> (Q ** P) = (R ** P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q = R \\<Longrightarrow> (Q \\<and>* P) = (R \\<and>* P)", "by simp"], ["", "lemma disjoint_subheaps_exist:\n  \"\\<exists>x y. x ## y \\<and> h = x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x y. x ## y \\<and> h = x + y", "by (rule_tac x=0 in exI, auto)"], ["", "lemma sep_conj_left_commute: (* for permutative rewriting *)\n  \"(P ** (Q ** R)) = (Q ** (P ** R))\" (is \"?x = ?y\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* R) = (Q \\<and>* P \\<and>* R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* R) = (Q \\<and>* P \\<and>* R)", "have \"?x = ((Q ** R) ** P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* R) = ((Q \\<and>* R) \\<and>* P)", "by (simp add: sep_conj_commute)"], ["proof (state)\nthis:\n  (P \\<and>* Q \\<and>* R) = ((Q \\<and>* R) \\<and>* P)\n\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* R) = (Q \\<and>* P \\<and>* R)", "also"], ["proof (state)\nthis:\n  (P \\<and>* Q \\<and>* R) = ((Q \\<and>* R) \\<and>* P)\n\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* R) = (Q \\<and>* P \\<and>* R)", "have \"\\<dots> = (Q ** (R ** P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Q \\<and>* R) \\<and>* P) = (Q \\<and>* R \\<and>* P)", "by (subst sep_conj_assoc, simp)"], ["proof (state)\nthis:\n  ((Q \\<and>* R) \\<and>* P) = (Q \\<and>* R \\<and>* P)\n\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* R) = (Q \\<and>* P \\<and>* R)", "finally"], ["proof (chain)\npicking this:\n  (P \\<and>* Q \\<and>* R) = (Q \\<and>* R \\<and>* P)", "show ?thesis"], ["proof (prove)\nusing this:\n  (P \\<and>* Q \\<and>* R) = (Q \\<and>* R \\<and>* P)\n\ngoal (1 subgoal):\n 1. (P \\<and>* Q \\<and>* R) = (Q \\<and>* P \\<and>* R)", "by (simp add: sep_conj_commute)"], ["proof (state)\nthis:\n  (P \\<and>* Q \\<and>* R) = (Q \\<and>* P \\<and>* R)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas sep_conj_ac = sep_conj_commute sep_conj_assoc sep_conj_left_commute"], ["", "lemma ab_semigroup_mult_sep_conj: \"class.ab_semigroup_mult (**)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ab_semigroup_mult (\\<and>*)", "by (unfold_locales)\n     (auto simp: sep_conj_ac)"], ["", "lemma sep_empty_zero [simp,intro!]: \"\\<box> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box> (0::'a)", "by (simp add: sep_empty_def)"], ["", "subsection \\<open>Properties of \\<open>sep_true\\<close> and \\<open>sep_false\\<close>\\<close>"], ["", "lemma sep_conj_sep_true:\n  \"P h \\<Longrightarrow> (P ** sep_true) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P h \\<Longrightarrow> (P \\<and>* (\\<lambda>s. True)) h", "by (simp add: sep_conjI[where y=0])"], ["", "lemma sep_conj_sep_true':\n  \"P h \\<Longrightarrow> (sep_true ** P) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P h \\<Longrightarrow> ((\\<lambda>s. True) \\<and>* P) h", "by (simp add: sep_conjI[where x=0])"], ["", "lemma sep_conj_true [simp]:\n  \"(sep_true ** sep_true) = sep_true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. True) \\<and>* (\\<lambda>s. True)) = (\\<lambda>s. True)", "unfolding sep_conj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>h.\n        \\<exists>x y. x ## y \\<and> h = x + y \\<and> True \\<and> True) =\n    (\\<lambda>s. True)", "by (auto intro!: ext intro: disjoint_subheaps_exist)"], ["", "lemma sep_conj_false_right [simp]:\n  \"(P ** sep_false) = sep_false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* (\\<lambda>s. False)) = (\\<lambda>s. False)", "by (force elim: sep_conjE intro!: ext)"], ["", "lemma sep_conj_false_left [simp]:\n  \"(sep_false ** P) = sep_false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. False) \\<and>* P) = (\\<lambda>s. False)", "by (subst sep_conj_commute) (rule sep_conj_false_right)"], ["", "subsection \\<open>Properties of zero (@{const sep_empty})\\<close>"], ["", "lemma sep_conj_empty [simp]:\n  \"(P ** \\<box>) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* \\<box>) = P", "by (simp add: sep_conj_def sep_empty_def)"], ["", "lemma sep_conj_empty'[simp]:\n  \"(\\<box> ** P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<box> \\<and>* P) = P", "by (subst sep_conj_commute, rule sep_conj_empty)"], ["", "lemma sep_conj_sep_emptyI:\n  \"P h \\<Longrightarrow> (P ** \\<box>) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P h \\<Longrightarrow> (P \\<and>* \\<box>) h", "by simp"], ["", "lemma sep_conj_sep_emptyE:\n  \"\\<lbrakk> P s; (P ** \\<box>) s \\<Longrightarrow> (Q ** R) s \\<rbrakk> \\<Longrightarrow> (Q ** R) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P s;\n     (P \\<and>* \\<box>) s \\<Longrightarrow> (Q \\<and>* R) s\\<rbrakk>\n    \\<Longrightarrow> (Q \\<and>* R) s", "by simp"], ["", "lemma monoid_add: \"class.monoid_add ((**)) \\<box>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.monoid_add (\\<and>*) \\<box>", "by (unfold_locales) (auto simp: sep_conj_ac)"], ["", "lemma comm_monoid_add: \"class.comm_monoid_add (**) \\<box>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_monoid_add (\\<and>*) \\<box>", "by (unfold_locales) (auto simp: sep_conj_ac)"], ["", "subsection \\<open>Properties of top (\\<open>sep_true\\<close>)\\<close>"], ["", "lemma sep_conj_true_P [simp]:\n  \"(sep_true ** (sep_true ** P)) = (sep_true ** P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. True) \\<and>* (\\<lambda>s. True) \\<and>* P) =\n    ((\\<lambda>s. True) \\<and>* P)", "by (simp add: sep_conj_assoc[symmetric])"], ["", "lemma sep_conj_disj:\n  \"((P or Q) ** R) = ((P ** R) or (Q ** R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. P s \\<or> Q s) \\<and>* R) =\n    (\\<lambda>s. (P \\<and>* R) s \\<or> (Q \\<and>* R) s)", "by (auto simp: sep_conj_def intro!: ext)"], ["", "lemma sep_conj_sep_true_left:\n  \"(P ** Q) h \\<Longrightarrow> (sep_true ** Q) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q) h \\<Longrightarrow> ((\\<lambda>s. True) \\<and>* Q) h", "by (erule sep_conj_impl, simp+)"], ["", "lemma sep_conj_sep_true_right:\n  \"(P ** Q) h \\<Longrightarrow> (P ** sep_true) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* Q) h \\<Longrightarrow> (P \\<and>* (\\<lambda>s. True)) h", "by (subst (asm) sep_conj_commute, drule sep_conj_sep_true_left,\n      simp add: sep_conj_ac)"], ["", "subsection \\<open>Separating Conjunction with Quantifiers\\<close>"], ["", "lemma sep_conj_conj:\n  \"((P and Q) ** R) h \\<Longrightarrow> ((P ** R) and (Q ** R)) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. P s \\<and> Q s) \\<and>* R) h \\<Longrightarrow>\n    (P \\<and>* R) h \\<and> (Q \\<and>* R) h", "by (force intro: sep_conjI elim!: sep_conjE)"], ["", "lemma sep_conj_exists1:\n  \"((EXS x. P x) ** Q) = (EXS x. (P x ** Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. \\<exists>x. P x s) \\<and>* Q) =\n    (\\<lambda>s. \\<exists>x. (P x \\<and>* Q) s)", "by (force intro!: ext intro: sep_conjI elim: sep_conjE)"], ["", "lemma sep_conj_exists2:\n  \"(P ** (EXS x. Q x)) = (EXS x. P ** Q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* (\\<lambda>s. \\<exists>x. Q x s)) =\n    (\\<lambda>s. \\<exists>x. (P \\<and>* Q x) s)", "by (force intro!: sep_conjI ext elim!: sep_conjE)"], ["", "lemmas sep_conj_exists = sep_conj_exists1 sep_conj_exists2"], ["", "lemma sep_conj_spec:\n  \"((ALLS x. P x) ** Q) h \\<Longrightarrow> (P x ** Q) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. \\<forall>x. P x s) \\<and>* Q) h \\<Longrightarrow>\n    (P x \\<and>* Q) h", "by (force intro: sep_conjI elim: sep_conjE)"], ["", "subsection \\<open>Properties of Separating Implication\\<close>"], ["", "lemma sep_implI:\n  assumes a: \"\\<And>h'. \\<lbrakk> h ## h'; P h' \\<rbrakk> \\<Longrightarrow> Q (h + h')\"\n  shows \"(P \\<longrightarrow>* Q) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<longrightarrow>* Q) h", "unfolding sep_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h'. h ## h' \\<and> P h' \\<longrightarrow> Q (h + h')", "by (auto elim: a)"], ["", "lemma sep_implD:\n  \"(x \\<longrightarrow>* y) h \\<Longrightarrow> \\<forall>h'. h ## h' \\<and> x h' \\<longrightarrow> y (h + h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<longrightarrow>* y) h \\<Longrightarrow>\n    \\<forall>h'. h ## h' \\<and> x h' \\<longrightarrow> y (h + h')", "by (force simp: sep_impl_def)"], ["", "lemma sep_implE:\n  \"(x \\<longrightarrow>* y) h \\<Longrightarrow> (\\<forall>h'. h ## h' \\<and> x h' \\<longrightarrow> y (h + h') \\<Longrightarrow> Q) \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x \\<longrightarrow>* y) h;\n     \\<forall>h'.\n        h ## h' \\<and> x h' \\<longrightarrow> y (h + h') \\<Longrightarrow>\n     Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by (auto dest: sep_implD)"], ["", "lemma sep_impl_sep_true [simp]:\n  \"(P \\<longrightarrow>* sep_true) = sep_true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<longrightarrow>* (\\<lambda>s. True)) = (\\<lambda>s. True)", "by (force intro!: sep_implI ext)"], ["", "lemma sep_impl_sep_false [simp]:\n  \"(sep_false \\<longrightarrow>* P) = sep_true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. False) \\<longrightarrow>* P) = (\\<lambda>s. True)", "by (force intro!: sep_implI ext)"], ["", "lemma sep_impl_sep_true_P:\n  \"(sep_true \\<longrightarrow>* P) h \\<Longrightarrow> P h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. True) \\<longrightarrow>* P) h \\<Longrightarrow> P h", "by (clarsimp dest!: sep_implD elim!: allE[where x=0])"], ["", "lemma sep_impl_sep_true_false [simp]:\n  \"(sep_true \\<longrightarrow>* sep_false) = sep_false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. True) \\<longrightarrow>* (\\<lambda>s. False)) =\n    (\\<lambda>s. False)", "by (force intro!: ext dest: sep_impl_sep_true_P)"], ["", "lemma sep_conj_sep_impl:\n  \"\\<lbrakk> P h; \\<And>h. (P ** Q) h \\<Longrightarrow> R h \\<rbrakk> \\<Longrightarrow> (Q \\<longrightarrow>* R) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P h; \\<And>h. (P \\<and>* Q) h \\<Longrightarrow> R h\\<rbrakk>\n    \\<Longrightarrow> (Q \\<longrightarrow>* R) h", "proof (rule sep_implI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h'.\n       \\<lbrakk>P h; \\<And>h. (P \\<and>* Q) h \\<Longrightarrow> R h;\n        h ## h'; Q h'\\<rbrakk>\n       \\<Longrightarrow> R (h + h')", "fix h' h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h'.\n       \\<lbrakk>P h; \\<And>h. (P \\<and>* Q) h \\<Longrightarrow> R h;\n        h ## h'; Q h'\\<rbrakk>\n       \\<Longrightarrow> R (h + h')", "assume \"P h\" and \"h ## h'\" and \"Q h'\""], ["proof (state)\nthis:\n  P h\n  h ## h'\n  Q h'\n\ngoal (1 subgoal):\n 1. \\<And>h'.\n       \\<lbrakk>P h; \\<And>h. (P \\<and>* Q) h \\<Longrightarrow> R h;\n        h ## h'; Q h'\\<rbrakk>\n       \\<Longrightarrow> R (h + h')", "hence \"(P ** Q) (h + h')\""], ["proof (prove)\nusing this:\n  P h\n  h ## h'\n  Q h'\n\ngoal (1 subgoal):\n 1. (P \\<and>* Q) (h + h')", "by (force intro: sep_conjI)"], ["proof (state)\nthis:\n  (P \\<and>* Q) (h + h')\n\ngoal (1 subgoal):\n 1. \\<And>h'.\n       \\<lbrakk>P h; \\<And>h. (P \\<and>* Q) h \\<Longrightarrow> R h;\n        h ## h'; Q h'\\<rbrakk>\n       \\<Longrightarrow> R (h + h')", "moreover"], ["proof (state)\nthis:\n  (P \\<and>* Q) (h + h')\n\ngoal (1 subgoal):\n 1. \\<And>h'.\n       \\<lbrakk>P h; \\<And>h. (P \\<and>* Q) h \\<Longrightarrow> R h;\n        h ## h'; Q h'\\<rbrakk>\n       \\<Longrightarrow> R (h + h')", "assume \"\\<And>h. (P ** Q) h \\<Longrightarrow> R h\""], ["proof (state)\nthis:\n  (P \\<and>* Q) ?h \\<Longrightarrow> R ?h\n\ngoal (1 subgoal):\n 1. \\<And>h'.\n       \\<lbrakk>P h; \\<And>h. (P \\<and>* Q) h \\<Longrightarrow> R h;\n        h ## h'; Q h'\\<rbrakk>\n       \\<Longrightarrow> R (h + h')", "ultimately"], ["proof (chain)\npicking this:\n  (P \\<and>* Q) (h + h')\n  (P \\<and>* Q) ?h \\<Longrightarrow> R ?h", "show \"R (h + h')\""], ["proof (prove)\nusing this:\n  (P \\<and>* Q) (h + h')\n  (P \\<and>* Q) ?h \\<Longrightarrow> R ?h\n\ngoal (1 subgoal):\n 1. R (h + h')", "by simp"], ["proof (state)\nthis:\n  R (h + h')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sep_conj_sep_impl2:\n  \"\\<lbrakk> (P ** Q) h; \\<And>h. P h \\<Longrightarrow> (Q \\<longrightarrow>* R) h \\<rbrakk> \\<Longrightarrow> R h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P \\<and>* Q) h;\n     \\<And>h. P h \\<Longrightarrow> (Q \\<longrightarrow>* R) h\\<rbrakk>\n    \\<Longrightarrow> R h", "by (force dest: sep_implD elim: sep_conjE)"], ["", "lemma sep_conj_sep_impl_sep_conj2:\n  \"(P ** R) h \\<Longrightarrow> (P ** (Q \\<longrightarrow>* (Q ** R))) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* R) h \\<Longrightarrow>\n    (P \\<and>* (Q \\<longrightarrow>* Q \\<and>* R)) h", "by (erule (1) sep_conj_impl, erule sep_conj_sep_impl, simp add: sep_conj_ac)"], ["", "subsection \\<open>Pure assertions\\<close>"], ["", "definition\n  pure :: \"('a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"pure P \\<equiv> \\<forall>h h'. P h = P h'\""], ["", "lemma pure_sep_true:\n  \"pure sep_true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<lambda>s. True)", "by (simp add: pure_def)"], ["", "lemma pure_sep_false:\n  \"pure sep_true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<lambda>s. True)", "by (simp add: pure_def)"], ["", "lemma pure_split:\n  \"pure P = (P = sep_true \\<or> P = sep_false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure P = (P = (\\<lambda>s. True) \\<or> P = (\\<lambda>s. False))", "by (force simp: pure_def intro!: ext)"], ["", "lemma pure_sep_conj:\n  \"\\<lbrakk> pure P; pure Q \\<rbrakk> \\<Longrightarrow> pure (P \\<and>* Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure P; pure Q\\<rbrakk> \\<Longrightarrow> pure (P \\<and>* Q)", "by (force simp: pure_split)"], ["", "lemma pure_sep_impl:\n  \"\\<lbrakk> pure P; pure Q \\<rbrakk> \\<Longrightarrow> pure (P \\<longrightarrow>* Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure P; pure Q\\<rbrakk>\n    \\<Longrightarrow> pure (P \\<longrightarrow>* Q)", "by (force simp: pure_split)"], ["", "lemma pure_conj_sep_conj:\n  \"\\<lbrakk> (P and Q) h; pure P \\<or> pure Q \\<rbrakk> \\<Longrightarrow> (P \\<and>* Q) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P h \\<and> Q h; pure P \\<or> pure Q\\<rbrakk>\n    \\<Longrightarrow> (P \\<and>* Q) h", "by (metis pure_def sep_add_zero sep_conjI sep_conj_commute sep_disj_zero)"], ["", "lemma pure_sep_conj_conj:\n  \"\\<lbrakk> (P \\<and>* Q) h; pure P; pure Q \\<rbrakk> \\<Longrightarrow> (P and Q) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P \\<and>* Q) h; pure P; pure Q\\<rbrakk>\n    \\<Longrightarrow> P h \\<and> Q h", "by (force simp: pure_split)"], ["", "lemma pure_conj_sep_conj_assoc:\n  \"pure P \\<Longrightarrow> ((P and Q) \\<and>* R) = (P and (Q \\<and>* R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure P \\<Longrightarrow>\n    ((\\<lambda>s. P s \\<and> Q s) \\<and>* R) =\n    (\\<lambda>s. P s \\<and> (Q \\<and>* R) s)", "by (auto simp: pure_split)"], ["", "lemma pure_sep_impl_impl:\n  \"\\<lbrakk> (P \\<longrightarrow>* Q) h; pure P \\<rbrakk> \\<Longrightarrow> P h \\<longrightarrow> Q h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P \\<longrightarrow>* Q) h; pure P\\<rbrakk>\n    \\<Longrightarrow> P h \\<longrightarrow> Q h", "by (force simp: pure_split dest: sep_impl_sep_true_P)"], ["", "lemma pure_impl_sep_impl:\n  \"\\<lbrakk> P h \\<longrightarrow> Q h; pure P; pure Q \\<rbrakk> \\<Longrightarrow> (P \\<longrightarrow>* Q) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P h \\<longrightarrow> Q h; pure P; pure Q\\<rbrakk>\n    \\<Longrightarrow> (P \\<longrightarrow>* Q) h", "by (force simp: pure_split)"], ["", "lemma pure_conj_right: \"(Q \\<and>* (\\<langle>P'\\<rangle> and Q')) = (\\<langle>P'\\<rangle> and (Q \\<and>* Q'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q \\<and>* (\\<lambda>s. P' \\<and> Q' s)) =\n    (\\<lambda>s. P' \\<and> (Q \\<and>* Q') s)", "by (rule ext, rule, rule, clarsimp elim!: sep_conjE)\n     (erule sep_conj_impl, auto)"], ["", "lemma pure_conj_right': \"(Q \\<and>* (P' and \\<langle>Q'\\<rangle>)) = (\\<langle>Q'\\<rangle> and (Q \\<and>* P'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q \\<and>* (\\<lambda>s. P' s \\<and> Q')) =\n    (\\<lambda>s. Q' \\<and> (Q \\<and>* P') s)", "by (simp add: conj_comms pure_conj_right)"], ["", "lemma pure_conj_left: \"((\\<langle>P'\\<rangle> and Q') \\<and>* Q) = (\\<langle>P'\\<rangle> and (Q' \\<and>* Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. P' \\<and> Q' s) \\<and>* Q) =\n    (\\<lambda>s. P' \\<and> (Q' \\<and>* Q) s)", "by (simp add: pure_conj_right sep_conj_ac)"], ["", "lemma pure_conj_left': \"((P' and \\<langle>Q'\\<rangle>) \\<and>* Q) = (\\<langle>Q'\\<rangle> and (P' \\<and>* Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. P' s \\<and> Q') \\<and>* Q) =\n    (\\<lambda>s. Q' \\<and> (P' \\<and>* Q) s)", "by (subst conj_comms, subst pure_conj_left, simp)"], ["", "lemmas pure_conj = pure_conj_right pure_conj_right' pure_conj_left\n    pure_conj_left'"], ["", "declare pure_conj[simp add]"], ["", "subsection \\<open>Intuitionistic assertions\\<close>"], ["", "definition intuitionistic :: \"('a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"intuitionistic P \\<equiv> \\<forall>h h'. P h \\<and> h \\<preceq> h' \\<longrightarrow> P h'\""], ["", "lemma intuitionisticI:\n  \"(\\<And>h h'. \\<lbrakk> P h; h \\<preceq> h' \\<rbrakk> \\<Longrightarrow> P h') \\<Longrightarrow> intuitionistic P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h h'.\n        \\<lbrakk>P h; h \\<preceq> h'\\<rbrakk>\n        \\<Longrightarrow> P h') \\<Longrightarrow>\n    intuitionistic P", "by (unfold intuitionistic_def, fast)"], ["", "lemma intuitionisticD:\n  \"\\<lbrakk> intuitionistic P; P h; h \\<preceq> h' \\<rbrakk> \\<Longrightarrow> P h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>intuitionistic P; P h; h \\<preceq> h'\\<rbrakk>\n    \\<Longrightarrow> P h'", "by (unfold intuitionistic_def, fast)"], ["", "lemma pure_intuitionistic:\n  \"pure P \\<Longrightarrow> intuitionistic P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure P \\<Longrightarrow> intuitionistic P", "by (clarsimp simp: intuitionistic_def pure_def, fast)"], ["", "lemma intuitionistic_conj:\n  \"\\<lbrakk> intuitionistic P; intuitionistic Q \\<rbrakk> \\<Longrightarrow> intuitionistic (P and Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>intuitionistic P; intuitionistic Q\\<rbrakk>\n    \\<Longrightarrow> intuitionistic (\\<lambda>s. P s \\<and> Q s)", "by (force intro: intuitionisticI dest: intuitionisticD)"], ["", "lemma intuitionistic_disj:\n  \"\\<lbrakk> intuitionistic P; intuitionistic Q \\<rbrakk> \\<Longrightarrow> intuitionistic (P or Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>intuitionistic P; intuitionistic Q\\<rbrakk>\n    \\<Longrightarrow> intuitionistic (\\<lambda>s. P s \\<or> Q s)", "by (force intro: intuitionisticI dest: intuitionisticD)"], ["", "lemma intuitionistic_forall:\n  \"(\\<And>x. intuitionistic (P x)) \\<Longrightarrow> intuitionistic (ALLS x. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. intuitionistic (P x)) \\<Longrightarrow>\n    intuitionistic (\\<lambda>s. \\<forall>x. P x s)", "by (force intro: intuitionisticI dest: intuitionisticD)"], ["", "lemma intuitionistic_exists:\n  \"(\\<And>x. intuitionistic (P x)) \\<Longrightarrow> intuitionistic (EXS x. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. intuitionistic (P x)) \\<Longrightarrow>\n    intuitionistic (\\<lambda>s. \\<exists>x. P x s)", "by (force intro: intuitionisticI dest: intuitionisticD)"], ["", "lemma intuitionistic_sep_conj_sep_true:\n  \"intuitionistic (sep_true \\<and>* P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intuitionistic ((\\<lambda>s. True) \\<and>* P)", "proof (rule intuitionisticI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<and>* P) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<and>* P) h'", "fix h h' r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<and>* P) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<and>* P) h'", "assume a: \"(sep_true \\<and>* P) h\""], ["proof (state)\nthis:\n  ((\\<lambda>s. True) \\<and>* P) h\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<and>* P) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<and>* P) h'", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>s. True) \\<and>* P) h", "obtain x y where P: \"P y\" and h: \"h = x + y\" and xyd: \"x ## y\""], ["proof (prove)\nusing this:\n  ((\\<lambda>s. True) \\<and>* P) h\n\ngoal (1 subgoal):\n 1. (\\<And>y x.\n        \\<lbrakk>P y; h = x + y; x ## y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (drule sep_conjD, clarsimp)"], ["proof (state)\nthis:\n  P y\n  h = x + y\n  x ## y\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<and>* P) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<and>* P) h'", "moreover"], ["proof (state)\nthis:\n  P y\n  h = x + y\n  x ## y\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<and>* P) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<and>* P) h'", "assume a2: \"h \\<preceq> h'\""], ["proof (state)\nthis:\n  h \\<preceq> h'\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<and>* P) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<and>* P) h'", "then"], ["proof (chain)\npicking this:\n  h \\<preceq> h'", "obtain z where h': \"h' = h + z\" and hzd: \"h ## z\""], ["proof (prove)\nusing this:\n  h \\<preceq> h'\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>h' = h + z; h ## z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: sep_substate_def)"], ["proof (state)\nthis:\n  h' = h + z\n  h ## z\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<and>* P) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<and>* P) h'", "moreover"], ["proof (state)\nthis:\n  h' = h + z\n  h ## z\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<and>* P) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<and>* P) h'", "have \"(P \\<and>* sep_true) (y + (x + z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and>* (\\<lambda>s. True)) (y + (x + z))", "using P h hzd xyd"], ["proof (prove)\nusing this:\n  P y\n  h = x + y\n  h ## z\n  x ## y\n\ngoal (1 subgoal):\n 1. (P \\<and>* (\\<lambda>s. True)) (y + (x + z))", "by (metis sep_add_disjI1 sep_disj_commute sep_conjI)"], ["proof (state)\nthis:\n  (P \\<and>* (\\<lambda>s. True)) (y + (x + z))\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<and>* P) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<and>* P) h'", "ultimately"], ["proof (chain)\npicking this:\n  P y\n  h = x + y\n  x ## y\n  h' = h + z\n  h ## z\n  (P \\<and>* (\\<lambda>s. True)) (y + (x + z))", "show \"(sep_true \\<and>* P) h'\""], ["proof (prove)\nusing this:\n  P y\n  h = x + y\n  x ## y\n  h' = h + z\n  h ## z\n  (P \\<and>* (\\<lambda>s. True)) (y + (x + z))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. True) \\<and>* P) h'", "using hzd"], ["proof (prove)\nusing this:\n  P y\n  h = x + y\n  x ## y\n  h' = h + z\n  h ## z\n  (P \\<and>* (\\<lambda>s. True)) (y + (x + z))\n  h ## z\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. True) \\<and>* P) h'", "by (auto simp: sep_conj_commute sep_add_ac dest!: sep_disj_addD)"], ["proof (state)\nthis:\n  ((\\<lambda>s. True) \\<and>* P) h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intuitionistic_sep_impl_sep_true:\n  \"intuitionistic (sep_true \\<longrightarrow>* P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intuitionistic ((\\<lambda>s. True) \\<longrightarrow>* P)", "proof (rule intuitionisticI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<longrightarrow>* P) h;\n        h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<longrightarrow>* P) h'", "fix h h'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<longrightarrow>* P) h;\n        h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<longrightarrow>* P) h'", "assume imp: \"(sep_true \\<longrightarrow>* P) h\" and hh': \"h \\<preceq> h'\""], ["proof (state)\nthis:\n  ((\\<lambda>s. True) \\<longrightarrow>* P) h\n  h \\<preceq> h'\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<longrightarrow>* P) h;\n        h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<longrightarrow>* P) h'", "from hh'"], ["proof (chain)\npicking this:\n  h \\<preceq> h'", "obtain z where h': \"h' = h + z\" and hzd: \"h ## z\""], ["proof (prove)\nusing this:\n  h \\<preceq> h'\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>h' = h + z; h ## z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: sep_substate_def)"], ["proof (state)\nthis:\n  h' = h + z\n  h ## z\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>((\\<lambda>s. True) \\<longrightarrow>* P) h;\n        h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<longrightarrow>* P) h'", "show \"(sep_true \\<longrightarrow>* P) h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>s. True) \\<longrightarrow>* P) h'", "using imp h' hzd"], ["proof (prove)\nusing this:\n  ((\\<lambda>s. True) \\<longrightarrow>* P) h\n  h' = h + z\n  h ## z\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. True) \\<longrightarrow>* P) h'", "apply (clarsimp dest!: sep_implD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h' = h + z; h ## z;\n     \\<forall>h'. h ## h' \\<longrightarrow> P (h + h')\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>s. True) \\<longrightarrow>* P) (h + z)", "apply (metis sep_add_assoc sep_add_disjD sep_disj_addI3 sep_implI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>s. True) \\<longrightarrow>* P) h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intuitionistic_sep_conj:\n  assumes ip: \"intuitionistic (P::('a \\<Rightarrow> bool))\"\n  shows \"intuitionistic (P \\<and>* Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intuitionistic (P \\<and>* Q)", "proof (rule intuitionisticI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<and>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<and>* Q) h'", "fix h h'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<and>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<and>* Q) h'", "assume sc: \"(P \\<and>* Q) h\" and hh': \"h \\<preceq> h'\""], ["proof (state)\nthis:\n  (P \\<and>* Q) h\n  h \\<preceq> h'\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<and>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<and>* Q) h'", "from hh'"], ["proof (chain)\npicking this:\n  h \\<preceq> h'", "obtain z where h': \"h' = h + z\" and hzd: \"h ## z\""], ["proof (prove)\nusing this:\n  h \\<preceq> h'\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>h' = h + z; h ## z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: sep_substate_def)"], ["proof (state)\nthis:\n  h' = h + z\n  h ## z\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<and>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<and>* Q) h'", "from sc"], ["proof (chain)\npicking this:\n  (P \\<and>* Q) h", "obtain x y where px: \"P x\" and qy: \"Q y\"\n                       and h: \"h = x + y\" and xyd: \"x ## y\""], ["proof (prove)\nusing this:\n  (P \\<and>* Q) h\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>P x; Q y; h = x + y; x ## y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: sep_conj_def)"], ["proof (state)\nthis:\n  P x\n  Q y\n  h = x + y\n  x ## y\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<and>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<and>* Q) h'", "have \"x ## z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ## z", "using hzd h xyd"], ["proof (prove)\nusing this:\n  h ## z\n  h = x + y\n  x ## y\n\ngoal (1 subgoal):\n 1. x ## z", "by (metis sep_add_disjD)"], ["proof (state)\nthis:\n  x ## z\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<and>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<and>* Q) h'", "with ip px"], ["proof (chain)\npicking this:\n  intuitionistic P\n  P x\n  x ## z", "have \"P (x + z)\""], ["proof (prove)\nusing this:\n  intuitionistic P\n  P x\n  x ## z\n\ngoal (1 subgoal):\n 1. P (x + z)", "by (fastforce elim: intuitionisticD sep_substate_disj_add)"], ["proof (state)\nthis:\n  P (x + z)\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<and>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<and>* Q) h'", "thus \"(P \\<and>* Q) h'\""], ["proof (prove)\nusing this:\n  P (x + z)\n\ngoal (1 subgoal):\n 1. (P \\<and>* Q) h'", "using h' h hzd qy xyd"], ["proof (prove)\nusing this:\n  P (x + z)\n  h' = h + z\n  h = x + y\n  h ## z\n  Q y\n  x ## y\n\ngoal (1 subgoal):\n 1. (P \\<and>* Q) h'", "by (metis (full_types) sep_add_commute sep_add_disjD sep_add_disjI2\n              sep_add_left_commute sep_conjI)"], ["proof (state)\nthis:\n  (P \\<and>* Q) h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intuitionistic_sep_impl:\n  assumes iq: \"intuitionistic Q\"\n  shows \"intuitionistic (P \\<longrightarrow>* Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intuitionistic (P \\<longrightarrow>* Q)", "proof (rule intuitionisticI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<longrightarrow>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<longrightarrow>* Q) h'", "fix h h'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<longrightarrow>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<longrightarrow>* Q) h'", "assume imp: \"(P \\<longrightarrow>* Q) h\" and hh': \"h \\<preceq> h'\""], ["proof (state)\nthis:\n  (P \\<longrightarrow>* Q) h\n  h \\<preceq> h'\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<longrightarrow>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<longrightarrow>* Q) h'", "from hh'"], ["proof (chain)\npicking this:\n  h \\<preceq> h'", "obtain z where h': \"h' = h + z\" and hzd: \"h ## z\""], ["proof (prove)\nusing this:\n  h \\<preceq> h'\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>h' = h + z; h ## z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: sep_substate_def)"], ["proof (state)\nthis:\n  h' = h + z\n  h ## z\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<longrightarrow>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<longrightarrow>* Q) h'", "{"], ["proof (state)\nthis:\n  h' = h + z\n  h ## z\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<longrightarrow>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<longrightarrow>* Q) h'", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<longrightarrow>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<longrightarrow>* Q) h'", "assume px: \"P x\" and hzx: \"h + z ## x\""], ["proof (state)\nthis:\n  P x\n  h + z ## x\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<longrightarrow>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<longrightarrow>* Q) h'", "have \"h + x \\<preceq> h + x + z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h + x \\<preceq> h + x + z", "using hzx hzd"], ["proof (prove)\nusing this:\n  h + z ## x\n  h ## z\n\ngoal (1 subgoal):\n 1. h + x \\<preceq> h + x + z", "by (metis sep_add_disjI1 sep_substate_def)"], ["proof (state)\nthis:\n  h + x \\<preceq> h + x + z\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<longrightarrow>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<longrightarrow>* Q) h'", "with imp hzd iq px hzx"], ["proof (chain)\npicking this:\n  (P \\<longrightarrow>* Q) h\n  h ## z\n  intuitionistic Q\n  P x\n  h + z ## x\n  h + x \\<preceq> h + x + z", "have \"Q (h + z + x)\""], ["proof (prove)\nusing this:\n  (P \\<longrightarrow>* Q) h\n  h ## z\n  intuitionistic Q\n  P x\n  h + z ## x\n  h + x \\<preceq> h + x + z\n\ngoal (1 subgoal):\n 1. Q (h + z + x)", "by (metis intuitionisticD sep_add_assoc sep_add_ac sep_add_disjD sep_implE)"], ["proof (state)\nthis:\n  Q (h + z + x)\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<longrightarrow>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<longrightarrow>* Q) h'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>P ?x2; h + z ## ?x2\\<rbrakk> \\<Longrightarrow> Q (h + z + ?x2)\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>(P \\<longrightarrow>* Q) h; h \\<preceq> h'\\<rbrakk>\n       \\<Longrightarrow> (P \\<longrightarrow>* Q) h'", "with imp h' hzd iq"], ["proof (chain)\npicking this:\n  (P \\<longrightarrow>* Q) h\n  h' = h + z\n  h ## z\n  intuitionistic Q\n  \\<lbrakk>P ?x2; h + z ## ?x2\\<rbrakk> \\<Longrightarrow> Q (h + z + ?x2)", "show \"(P \\<longrightarrow>* Q) h'\""], ["proof (prove)\nusing this:\n  (P \\<longrightarrow>* Q) h\n  h' = h + z\n  h ## z\n  intuitionistic Q\n  \\<lbrakk>P ?x2; h + z ## ?x2\\<rbrakk> \\<Longrightarrow> Q (h + z + ?x2)\n\ngoal (1 subgoal):\n 1. (P \\<longrightarrow>* Q) h'", "by (fastforce intro: sep_implI)"], ["proof (state)\nthis:\n  (P \\<longrightarrow>* Q) h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strongest_intuitionistic:\n  \"\\<not> (\\<exists>Q. (\\<forall>h. (Q h \\<longrightarrow> (P \\<and>* sep_true) h)) \\<and> intuitionistic Q \\<and>\n      Q \\<noteq> (P \\<and>* sep_true) \\<and> (\\<forall>h. P h \\<longrightarrow> Q h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       (\\<forall>h.\n           Q h \\<longrightarrow> (P \\<and>* (\\<lambda>s. True)) h) \\<and>\n       intuitionistic Q \\<and>\n       Q \\<noteq> (P \\<and>* (\\<lambda>s. True)) \\<and>\n       (\\<forall>h. P h \\<longrightarrow> Q h)", "by (fastforce intro!: ext sep_substate_disj_add\n                dest!: sep_conjD intuitionisticD)"], ["", "lemma weakest_intuitionistic:\n  \"\\<not> (\\<exists>Q. (\\<forall>h. ((sep_true \\<longrightarrow>* P) h \\<longrightarrow> Q h)) \\<and> intuitionistic Q \\<and>\n      Q \\<noteq> (sep_true \\<longrightarrow>* P) \\<and> (\\<forall>h. Q h \\<longrightarrow> P h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>Q.\n       (\\<forall>h.\n           ((\\<lambda>s. True) \\<longrightarrow>* P) h \\<longrightarrow>\n           Q h) \\<and>\n       intuitionistic Q \\<and>\n       Q \\<noteq> ((\\<lambda>s. True) \\<longrightarrow>* P) \\<and>\n       (\\<forall>h. Q h \\<longrightarrow> P h)", "apply (clarsimp intro!: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>intuitionistic Q;\n        \\<forall>h.\n           ((\\<lambda>s. True) \\<longrightarrow>* P) h \\<longrightarrow>\n           Q h;\n        \\<forall>h. Q h \\<longrightarrow> P h\\<rbrakk>\n       \\<Longrightarrow> Q x = ((\\<lambda>s. True) \\<longrightarrow>* P) x", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Q x.\n       \\<lbrakk>intuitionistic Q;\n        \\<forall>h.\n           ((\\<lambda>s. True) \\<longrightarrow>* P) h \\<longrightarrow>\n           Q h;\n        \\<forall>h. Q h \\<longrightarrow> P h; Q x\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>s. True) \\<longrightarrow>* P) x\n 2. \\<And>Q x.\n       \\<lbrakk>intuitionistic Q;\n        \\<forall>h.\n           ((\\<lambda>s. True) \\<longrightarrow>* P) h \\<longrightarrow>\n           Q h;\n        \\<forall>h. Q h \\<longrightarrow> P h;\n        ((\\<lambda>s. True) \\<longrightarrow>* P) x\\<rbrakk>\n       \\<Longrightarrow> Q x", "apply (rule sep_implI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Q x h'.\n       \\<lbrakk>intuitionistic Q;\n        \\<forall>h.\n           ((\\<lambda>s. True) \\<longrightarrow>* P) h \\<longrightarrow>\n           Q h;\n        \\<forall>h. Q h \\<longrightarrow> P h; Q x; x ## h'; True\\<rbrakk>\n       \\<Longrightarrow> P (x + h')\n 2. \\<And>Q x.\n       \\<lbrakk>intuitionistic Q;\n        \\<forall>h.\n           ((\\<lambda>s. True) \\<longrightarrow>* P) h \\<longrightarrow>\n           Q h;\n        \\<forall>h. Q h \\<longrightarrow> P h;\n        ((\\<lambda>s. True) \\<longrightarrow>* P) x\\<rbrakk>\n       \\<Longrightarrow> Q x", "apply (drule_tac h=\"x\" and h'=\"x + h'\" in intuitionisticD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Q x h'.\n       \\<lbrakk>\\<forall>h.\n                   ((\\<lambda>s. True) \\<longrightarrow>* P)\n                    h \\<longrightarrow>\n                   Q h;\n        \\<forall>h. Q h \\<longrightarrow> P h; Q x; x ## h'; True\\<rbrakk>\n       \\<Longrightarrow> Q x\n 2. \\<And>Q x h'.\n       \\<lbrakk>\\<forall>h.\n                   ((\\<lambda>s. True) \\<longrightarrow>* P)\n                    h \\<longrightarrow>\n                   Q h;\n        \\<forall>h. Q h \\<longrightarrow> P h; Q x; x ## h'; True\\<rbrakk>\n       \\<Longrightarrow> x \\<preceq> x + h'\n 3. \\<And>Q x h'.\n       \\<lbrakk>\\<forall>h.\n                   ((\\<lambda>s. True) \\<longrightarrow>* P)\n                    h \\<longrightarrow>\n                   Q h;\n        \\<forall>h. Q h \\<longrightarrow> P h; Q x; x ## h'; True;\n        Q (x + h')\\<rbrakk>\n       \\<Longrightarrow> P (x + h')\n 4. \\<And>Q x.\n       \\<lbrakk>intuitionistic Q;\n        \\<forall>h.\n           ((\\<lambda>s. True) \\<longrightarrow>* P) h \\<longrightarrow>\n           Q h;\n        \\<forall>h. Q h \\<longrightarrow> P h;\n        ((\\<lambda>s. True) \\<longrightarrow>* P) x\\<rbrakk>\n       \\<Longrightarrow> Q x", "apply (clarsimp simp: sep_add_ac sep_substate_disj_add)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma intuitionistic_sep_conj_sep_true_P:\n  \"\\<lbrakk> (P \\<and>* sep_true) s; intuitionistic P \\<rbrakk> \\<Longrightarrow> P s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P \\<and>* (\\<lambda>s. True)) s; intuitionistic P\\<rbrakk>\n    \\<Longrightarrow> P s", "by (force dest: intuitionisticD elim: sep_conjE sep_substate_disj_add)"], ["", "lemma intuitionistic_sep_conj_sep_true_simp:\n  \"intuitionistic P \\<Longrightarrow> (P \\<and>* sep_true) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intuitionistic P \\<Longrightarrow> (P \\<and>* (\\<lambda>s. True)) = P", "by (fast intro!: sep_conj_sep_true ext\n           elim: intuitionistic_sep_conj_sep_true_P)"], ["", "lemma intuitionistic_sep_impl_sep_true_P:\n  \"\\<lbrakk> P h; intuitionistic P \\<rbrakk> \\<Longrightarrow> (sep_true \\<longrightarrow>* P) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P h; intuitionistic P\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>s. True) \\<longrightarrow>* P) h", "by (force intro!: sep_implI dest: intuitionisticD\n            intro: sep_substate_disj_add)"], ["", "lemma intuitionistic_sep_impl_sep_true_simp:\n  \"intuitionistic P \\<Longrightarrow> (sep_true \\<longrightarrow>* P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intuitionistic P \\<Longrightarrow>\n    ((\\<lambda>s. True) \\<longrightarrow>* P) = P", "by (fast intro!: ext\n           elim: sep_impl_sep_true_P intuitionistic_sep_impl_sep_true_P)"], ["", "subsection \\<open>Strictly exact assertions\\<close>"], ["", "definition strictly_exact :: \"('a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"strictly_exact P \\<equiv> \\<forall>h h'. P h \\<and> P h' \\<longrightarrow> h = h'\""], ["", "lemma strictly_exactD:\n  \"\\<lbrakk> strictly_exact P; P h; P h' \\<rbrakk> \\<Longrightarrow> h = h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strictly_exact P; P h; P h'\\<rbrakk> \\<Longrightarrow> h = h'", "by (unfold strictly_exact_def, fast)"], ["", "lemma strictly_exactI:\n  \"(\\<And>h h'. \\<lbrakk> P h; P h' \\<rbrakk> \\<Longrightarrow> h = h') \\<Longrightarrow> strictly_exact P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h h'.\n        \\<lbrakk>P h; P h'\\<rbrakk>\n        \\<Longrightarrow> h = h') \\<Longrightarrow>\n    strictly_exact P", "by (unfold strictly_exact_def, fast)"], ["", "lemma strictly_exact_sep_conj:\n  \"\\<lbrakk> strictly_exact P; strictly_exact Q \\<rbrakk> \\<Longrightarrow> strictly_exact (P \\<and>* Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strictly_exact P; strictly_exact Q\\<rbrakk>\n    \\<Longrightarrow> strictly_exact (P \\<and>* Q)", "apply (rule strictly_exactI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<lbrakk>strictly_exact P; strictly_exact Q; (P \\<and>* Q) h;\n        (P \\<and>* Q) h'\\<rbrakk>\n       \\<Longrightarrow> h = h'", "apply (erule sep_conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' x y xa ya.\n       \\<lbrakk>strictly_exact P; strictly_exact Q; P x; Q y; x ## y;\n        h = x + y; P xa; Q ya; xa ## ya; h' = xa + ya\\<rbrakk>\n       \\<Longrightarrow> h = h'", "apply (drule_tac h=\"x\" and h'=\"xa\" in strictly_exactD, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' x y xa ya.\n       \\<lbrakk>strictly_exact Q; P x; Q y; x ## y; h = x + y; P xa; Q ya;\n        xa ## ya; h' = xa + ya; x = xa\\<rbrakk>\n       \\<Longrightarrow> h = h'", "apply (drule_tac h=\"y\" and h'=\"ya\" in strictly_exactD, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' x y xa ya.\n       \\<lbrakk>P x; Q y; x ## y; h = x + y; P xa; Q ya; xa ## ya;\n        h' = xa + ya; x = xa; y = ya\\<rbrakk>\n       \\<Longrightarrow> h = h'", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma strictly_exact_conj_impl:\n  \"\\<lbrakk> (Q \\<and>* sep_true) h; P h; strictly_exact Q \\<rbrakk> \\<Longrightarrow> (Q \\<and>* (Q \\<longrightarrow>* P)) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Q \\<and>* (\\<lambda>s. True)) h; P h;\n     strictly_exact Q\\<rbrakk>\n    \\<Longrightarrow> (Q \\<and>* (Q \\<longrightarrow>* P)) h", "by (force intro: sep_conjI sep_implI dest: strictly_exactD elim!: sep_conjE\n            simp: sep_add_commute sep_add_assoc)"], ["", "end"], ["", "interpretation sep: ab_semigroup_mult \"(**)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ab_semigroup_mult (\\<and>*)", "by (rule ab_semigroup_mult_sep_conj)"], ["", "interpretation sep: comm_monoid_add \"(**)\" \\<box>"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_monoid_add (\\<and>*) \\<box>", "by (rule comm_monoid_add)"], ["", "section \\<open>Separation Algebra with Stronger, but More Intuitive Disjunction Axiom\\<close>"], ["", "class stronger_sep_algebra = pre_sep_algebra +\n  assumes sep_add_disj_eq [simp]: \"y ## z \\<Longrightarrow> x ## y + z = (x ## y \\<and> x ## z)\"\nbegin"], ["", "lemma sep_disj_add_eq [simp]: \"x ## y \\<Longrightarrow> x + y ## z = (x ## z \\<and> y ## z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ## y \\<Longrightarrow> x + y ## z = (x ## z \\<and> y ## z)", "by (metis sep_add_disj_eq sep_disj_commute)"], ["", "subclass sep_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.sep_algebra (+) (0::'a) (##)", "by standard auto"], ["", "end"], ["", "section \\<open>Folding separating conjunction over lists of predicates\\<close>"], ["", "lemma sep_list_conj_Nil [simp]: \"\\<And>* [] = \\<box>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>* [] = \\<box>", "by (simp add: sep_list_conj_def)"], ["", "(* apparently these two are rarely used and had to be removed from List.thy *)"], ["", "lemma (in semigroup_add) foldl_assoc:\nshows \"foldl (+) (x+y) zs = x + (foldl (+) y zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) (x + y) zs = x + foldl (+) y zs", "by (induct zs arbitrary: y) (simp_all add:add.assoc)"], ["", "lemma (in monoid_add) foldl_absorb0:\nshows \"x + (foldl (+) 0 zs) = foldl (+) x zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + foldl (+) (0::'a) zs = foldl (+) x zs", "by (induct zs) (simp_all add:foldl_assoc)"], ["", "lemma sep_list_conj_Cons [simp]: \"\\<And>* (x#xs) = (x ** \\<And>* xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>* x # xs = (x \\<and>* \\<And>* xs)", "by (simp add: sep_list_conj_def sep.foldl_absorb0)"], ["", "lemma sep_list_conj_append [simp]: \"\\<And>* (xs @ ys) = (\\<And>* xs ** \\<And>* ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>* xs @ ys = (\\<And>* xs \\<and>* \\<And>* ys)", "by (simp add: sep_list_conj_def sep.foldl_absorb0)"], ["", "lemma (in comm_monoid_add) foldl_map_filter:\n  \"foldl (+) 0 (map f (filter P xs)) +\n     foldl (+) 0 (map f (filter (not P) xs))\n   = foldl (+) 0 (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) (0::'a) (map f (filter P xs)) +\n    foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n    foldl (+) (0::'a) (map f xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. foldl (+) (0::'a) (map f (filter P [])) +\n    foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) [])) =\n    foldl (+) (0::'a) (map f [])\n 2. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. foldl (+) (0::'a) (map f (filter P [])) +\n    foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) [])) =\n    foldl (+) (0::'a) (map f [])\n 2. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (+) (0::'a) (map f (filter P [])) +\n    foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) [])) =\n    foldl (+) (0::'a) (map f [])", "by clarsimp"], ["proof (state)\nthis:\n  foldl (+) (0::'a) (map f (filter P [])) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) [])) =\n  foldl (+) (0::'a) (map f [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  foldl (+) (0::'a) (map f (filter P xs)) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n  foldl (+) (0::'a) (map f xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "hence IH: \"foldl (+) 0 (map f xs) =\n               foldl (+) 0 (map f (filter P xs)) +\n               foldl (+) 0 (map f [x\\<leftarrow>xs . \\<not> P x])\""], ["proof (prove)\nusing this:\n  foldl (+) (0::'a) (map f (filter P xs)) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n  foldl (+) (0::'a) (map f xs)\n\ngoal (1 subgoal):\n 1. foldl (+) (0::'a) (map f xs) =\n    foldl (+) (0::'a) (map f (filter P xs)) +\n    foldl (+) (0::'a) (map f (filter (\\<lambda>x. \\<not> P x) xs))", "by (simp only: eq_commute)"], ["proof (state)\nthis:\n  foldl (+) (0::'a) (map f xs) =\n  foldl (+) (0::'a) (map f (filter P xs)) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>x. \\<not> P x) xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "have foldl_Cons':\n    \"\\<And>x xs. foldl (+) 0 (x # xs) = x + (foldl (+) 0 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs. foldl (+) (0::'a) (x # xs) = x + foldl (+) (0::'a) xs", "by (simp, subst foldl_absorb0[symmetric], rule refl)"], ["proof (state)\nthis:\n  foldl (+) (0::'a) (?x1 # ?xs1) = ?x1 + foldl (+) (0::'a) ?xs1\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "{"], ["proof (state)\nthis:\n  foldl (+) (0::'a) (?x1 # ?xs1) = ?x1 + foldl (+) (0::'a) ?xs1\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "assume \"P x\""], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "hence ?case"], ["proof (prove)\nusing this:\n  P x\n\ngoal (1 subgoal):\n 1. foldl (+) (0::'a) (map f (filter P (x # xs))) +\n    foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n    foldl (+) (0::'a) (map f (x # xs))", "by (auto simp del: foldl_Cons simp add: foldl_Cons' IH ac_simps)"], ["proof (state)\nthis:\n  foldl (+) (0::'a) (map f (filter P (x # xs))) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n  foldl (+) (0::'a) (map f (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "}"], ["proof (state)\nthis:\n  P x \\<Longrightarrow>\n  foldl (+) (0::'a) (map f (filter P (x # xs))) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n  foldl (+) (0::'a) (map f (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "moreover"], ["proof (state)\nthis:\n  P x \\<Longrightarrow>\n  foldl (+) (0::'a) (map f (filter P (x # xs))) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n  foldl (+) (0::'a) (map f (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "{"], ["proof (state)\nthis:\n  P x \\<Longrightarrow>\n  foldl (+) (0::'a) (map f (filter P (x # xs))) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n  foldl (+) (0::'a) (map f (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "assume \"\\<not> P x\""], ["proof (state)\nthis:\n  \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "hence ?case"], ["proof (prove)\nusing this:\n  \\<not> P x\n\ngoal (1 subgoal):\n 1. foldl (+) (0::'a) (map f (filter P (x # xs))) +\n    foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n    foldl (+) (0::'a) (map f (x # xs))", "by (auto simp del: foldl_Cons simp add: foldl_Cons' IH ac_simps)"], ["proof (state)\nthis:\n  foldl (+) (0::'a) (map f (filter P (x # xs))) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n  foldl (+) (0::'a) (map f (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "}"], ["proof (state)\nthis:\n  \\<not> P x \\<Longrightarrow>\n  foldl (+) (0::'a) (map f (filter P (x # xs))) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n  foldl (+) (0::'a) (map f (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       foldl (+) (0::'a) (map f (filter P xs)) +\n       foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) xs)) =\n       foldl (+) (0::'a) (map f xs) \\<Longrightarrow>\n       foldl (+) (0::'a) (map f (filter P (a # xs))) +\n       foldl (+) (0::'a)\n        (map f (filter (\\<lambda>s. \\<not> P s) (a # xs))) =\n       foldl (+) (0::'a) (map f (a # xs))", "ultimately"], ["proof (chain)\npicking this:\n  P x \\<Longrightarrow>\n  foldl (+) (0::'a) (map f (filter P (x # xs))) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n  foldl (+) (0::'a) (map f (x # xs))\n  \\<not> P x \\<Longrightarrow>\n  foldl (+) (0::'a) (map f (filter P (x # xs))) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n  foldl (+) (0::'a) (map f (x # xs))", "show ?case"], ["proof (prove)\nusing this:\n  P x \\<Longrightarrow>\n  foldl (+) (0::'a) (map f (filter P (x # xs))) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n  foldl (+) (0::'a) (map f (x # xs))\n  \\<not> P x \\<Longrightarrow>\n  foldl (+) (0::'a) (map f (filter P (x # xs))) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n  foldl (+) (0::'a) (map f (x # xs))\n\ngoal (1 subgoal):\n 1. foldl (+) (0::'a) (map f (filter P (x # xs))) +\n    foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n    foldl (+) (0::'a) (map f (x # xs))", "by blast"], ["proof (state)\nthis:\n  foldl (+) (0::'a) (map f (filter P (x # xs))) +\n  foldl (+) (0::'a) (map f (filter (\\<lambda>s. \\<not> P s) (x # xs))) =\n  foldl (+) (0::'a) (map f (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Separation Algebra with a Cancellative Monoid (for completeness)\\<close>"], ["", "text \\<open>\n  Separation algebra with a cancellative monoid. The results of being a precise\n  assertion (distributivity over separating conjunction) require this.\n  although we never actually use this property in our developments, we keep\n  it here for completeness.\n\\<close>"], ["", "class cancellative_sep_algebra = sep_algebra +\n  assumes sep_add_cancelD: \"\\<lbrakk> x + z = y + z ; x ## z ; y ## z \\<rbrakk> \\<Longrightarrow> x = y\"\nbegin"], ["", "definition\n  (* In any heap, there exists at most one subheap for which P holds *)\n  precise :: \"('a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"precise P = (\\<forall>h hp hp'. hp \\<preceq> h \\<and> P hp \\<and> hp' \\<preceq> h \\<and> P hp' \\<longrightarrow> hp = hp')\""], ["", "lemma \"precise ((=) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise ((=) s)", "by (metis (full_types) precise_def)"], ["", "lemma sep_add_cancel:\n  \"x ## z \\<Longrightarrow> y ## z \\<Longrightarrow> (x + z = y + z) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x ## z; y ## z\\<rbrakk>\n    \\<Longrightarrow> (x + z = y + z) = (x = y)", "by (metis sep_add_cancelD)"], ["", "lemma precise_distribute:\n  \"precise P = (\\<forall>Q R. ((Q and R) \\<and>* P) = ((Q \\<and>* P) and (R \\<and>* P)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise P =\n    (\\<forall>Q R.\n        ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n        (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s))", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "assume pp: \"precise P\""], ["proof (state)\nthis:\n  precise P\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "{"], ["proof (state)\nthis:\n  precise P\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "fix Q R"], ["proof (state)\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "fix h hp hp' s"], ["proof (state)\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "assume a: \"((Q and R) \\<and>* P) s\""], ["proof (state)\nthis:\n  ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "hence \"((Q \\<and>* P) and (R \\<and>* P)) s\""], ["proof (prove)\nusing this:\n  ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s\n\ngoal (1 subgoal):\n 1. (Q \\<and>* P) s \\<and> (R \\<and>* P) s", "by (fastforce dest!: sep_conjD elim: sep_conjI)"], ["proof (state)\nthis:\n  (Q \\<and>* P) s \\<and> (R \\<and>* P) s\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "}"], ["proof (state)\nthis:\n  ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s \\<Longrightarrow>\n  (Q \\<and>* P) s \\<and> (R \\<and>* P) s\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s \\<Longrightarrow>\n  (Q \\<and>* P) s \\<and> (R \\<and>* P) s\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "{"], ["proof (state)\nthis:\n  ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s \\<Longrightarrow>\n  (Q \\<and>* P) s \\<and> (R \\<and>* P) s\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "assume qs: \"(Q \\<and>* P) s\" and qr: \"(R \\<and>* P) s\""], ["proof (state)\nthis:\n  (Q \\<and>* P) s\n  (R \\<and>* P) s\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "from qs"], ["proof (chain)\npicking this:\n  (Q \\<and>* P) s", "obtain x y where sxy: \"s = x + y\" and xy: \"x ## y\"\n                           and x: \"Q x\" and y: \"P y\""], ["proof (prove)\nusing this:\n  (Q \\<and>* P) s\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>s = x + y; x ## y; Q x; P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest!: sep_conjD)"], ["proof (state)\nthis:\n  s = x + y\n  x ## y\n  Q x\n  P y\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "from qr"], ["proof (chain)\npicking this:\n  (R \\<and>* P) s", "obtain x' y' where sxy': \"s = x' + y'\" and xy': \"x' ## y'\"\n                           and x': \"R x'\" and y': \"P y'\""], ["proof (prove)\nusing this:\n  (R \\<and>* P) s\n\ngoal (1 subgoal):\n 1. (\\<And>x' y'.\n        \\<lbrakk>s = x' + y'; x' ## y'; R x'; P y'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest!: sep_conjD)"], ["proof (state)\nthis:\n  s = x' + y'\n  x' ## y'\n  R x'\n  P y'\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "from sxy"], ["proof (chain)\npicking this:\n  s = x + y", "have ys: \"y \\<preceq> x + y\""], ["proof (prove)\nusing this:\n  s = x + y\n\ngoal (1 subgoal):\n 1. y \\<preceq> x + y", "using xy"], ["proof (prove)\nusing this:\n  s = x + y\n  x ## y\n\ngoal (1 subgoal):\n 1. y \\<preceq> x + y", "by (fastforce simp: sep_substate_disj_add' sep_disj_commute)"], ["proof (state)\nthis:\n  y \\<preceq> x + y\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "from sxy'"], ["proof (chain)\npicking this:\n  s = x' + y'", "have ys': \"y' \\<preceq> x' + y'\""], ["proof (prove)\nusing this:\n  s = x' + y'\n\ngoal (1 subgoal):\n 1. y' \\<preceq> x' + y'", "using xy'"], ["proof (prove)\nusing this:\n  s = x' + y'\n  x' ## y'\n\ngoal (1 subgoal):\n 1. y' \\<preceq> x' + y'", "by (fastforce simp: sep_substate_disj_add' sep_disj_commute)"], ["proof (state)\nthis:\n  y' \\<preceq> x' + y'\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "from pp"], ["proof (chain)\npicking this:\n  precise P", "have yy: \"y = y'\""], ["proof (prove)\nusing this:\n  precise P\n\ngoal (1 subgoal):\n 1. y = y'", "using sxy sxy' xy xy' y y' ys ys'"], ["proof (prove)\nusing this:\n  precise P\n  s = x + y\n  s = x' + y'\n  x ## y\n  x' ## y'\n  P y\n  P y'\n  y \\<preceq> x + y\n  y' \\<preceq> x' + y'\n\ngoal (1 subgoal):\n 1. y = y'", "by (fastforce simp: precise_def)"], ["proof (state)\nthis:\n  y = y'\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "hence \"x = x'\""], ["proof (prove)\nusing this:\n  y = y'\n\ngoal (1 subgoal):\n 1. x = x'", "using sxy sxy' xy xy'"], ["proof (prove)\nusing this:\n  y = y'\n  s = x + y\n  s = x' + y'\n  x ## y\n  x' ## y'\n\ngoal (1 subgoal):\n 1. x = x'", "by (fastforce dest!: sep_add_cancelD)"], ["proof (state)\nthis:\n  x = x'\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "hence \"((Q and R) \\<and>* P) s\""], ["proof (prove)\nusing this:\n  x = x'\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s", "using sxy x x' yy y' xy'"], ["proof (prove)\nusing this:\n  x = x'\n  s = x + y\n  Q x\n  R x'\n  y = y'\n  P y'\n  x' ## y'\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s", "by (fastforce intro: sep_conjI)"], ["proof (state)\nthis:\n  ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(Q \\<and>* P) s; (R \\<and>* P) s\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s \\<Longrightarrow>\n  (Q \\<and>* P) s \\<and> (R \\<and>* P) s\n  \\<lbrakk>(Q \\<and>* P) s; (R \\<and>* P) s\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s", "have \"((Q and R) \\<and>* P) s = ((Q \\<and>* P) and (R \\<and>* P)) s\""], ["proof (prove)\nusing this:\n  ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s \\<Longrightarrow>\n  (Q \\<and>* P) s \\<and> (R \\<and>* P) s\n  \\<lbrakk>(Q \\<and>* P) s; (R \\<and>* P) s\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s =\n    ((Q \\<and>* P) s \\<and> (R \\<and>* P) s)", "using pp"], ["proof (prove)\nusing this:\n  ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s \\<Longrightarrow>\n  (Q \\<and>* P) s \\<and> (R \\<and>* P) s\n  \\<lbrakk>(Q \\<and>* P) s; (R \\<and>* P) s\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s\n  precise P\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s =\n    ((Q \\<and>* P) s \\<and> (R \\<and>* P) s)", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) s =\n  ((Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "}"], ["proof (state)\nthis:\n  ((\\<lambda>s. ?Q2 s \\<and> ?R2 s) \\<and>* P) ?s2 =\n  ((?Q2 \\<and>* P) ?s2 \\<and> (?R2 \\<and>* P) ?s2)\n\ngoal (2 subgoals):\n 1. precise P \\<Longrightarrow>\n    \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n 2. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "thus \"\\<forall>Q R. ((Q and R) \\<and>* P) = ((Q \\<and>* P) and (R \\<and>* P))\""], ["proof (prove)\nusing this:\n  ((\\<lambda>s. ?Q2 s \\<and> ?R2 s) \\<and>* P) ?s2 =\n  ((?Q2 \\<and>* P) ?s2 \\<and> (?R2 \\<and>* P) ?s2)\n\ngoal (1 subgoal):\n 1. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)", "by (blast intro!: ext)"], ["proof (state)\nthis:\n  \\<forall>Q R.\n     ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n     (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n\ngoal (1 subgoal):\n 1. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "assume a: \"\\<forall>Q R. ((Q and R) \\<and>* P) = ((Q \\<and>* P) and (R \\<and>* P))\""], ["proof (state)\nthis:\n  \\<forall>Q R.\n     ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n     (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n\ngoal (1 subgoal):\n 1. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n       (\\<lambda>s.\n           (Q \\<and>* P) s \\<and> (R \\<and>* P) s) \\<Longrightarrow>\n    precise P", "thus \"precise P\""], ["proof (prove)\nusing this:\n  \\<forall>Q R.\n     ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n     (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n\ngoal (1 subgoal):\n 1. precise P", "proof (clarsimp simp: precise_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h hp hp'.\n       \\<lbrakk>\\<forall>Q R.\n                   ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n                   (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s);\n        hp \\<preceq> h; P hp; hp' \\<preceq> h; P hp'\\<rbrakk>\n       \\<Longrightarrow> hp = hp'", "fix h hp hp' Q R"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h hp hp'.\n       \\<lbrakk>\\<forall>Q R.\n                   ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n                   (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s);\n        hp \\<preceq> h; P hp; hp' \\<preceq> h; P hp'\\<rbrakk>\n       \\<Longrightarrow> hp = hp'", "assume hp: \"hp \\<preceq> h\" and hp': \"hp' \\<preceq> h\" and php: \"P hp\" and php': \"P hp'\""], ["proof (state)\nthis:\n  hp \\<preceq> h\n  hp' \\<preceq> h\n  P hp\n  P hp'\n\ngoal (1 subgoal):\n 1. \\<And>h hp hp'.\n       \\<lbrakk>\\<forall>Q R.\n                   ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n                   (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s);\n        hp \\<preceq> h; P hp; hp' \\<preceq> h; P hp'\\<rbrakk>\n       \\<Longrightarrow> hp = hp'", "obtain z where hhp: \"h = hp + z\" and hpz: \"hp ## z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>h = hp + z; hp ## z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hp"], ["proof (prove)\nusing this:\n  hp \\<preceq> h\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>h = hp + z; hp ## z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: sep_substate_def)"], ["proof (state)\nthis:\n  h = hp + z\n  hp ## z\n\ngoal (1 subgoal):\n 1. \\<And>h hp hp'.\n       \\<lbrakk>\\<forall>Q R.\n                   ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n                   (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s);\n        hp \\<preceq> h; P hp; hp' \\<preceq> h; P hp'\\<rbrakk>\n       \\<Longrightarrow> hp = hp'", "obtain z' where hhp': \"h = hp' + z'\" and hpz': \"hp' ## z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>h = hp' + z'; hp' ## z'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hp'"], ["proof (prove)\nusing this:\n  hp' \\<preceq> h\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>h = hp' + z'; hp' ## z'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: sep_substate_def)"], ["proof (state)\nthis:\n  h = hp' + z'\n  hp' ## z'\n\ngoal (1 subgoal):\n 1. \\<And>h hp hp'.\n       \\<lbrakk>\\<forall>Q R.\n                   ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n                   (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s);\n        hp \\<preceq> h; P hp; hp' \\<preceq> h; P hp'\\<rbrakk>\n       \\<Longrightarrow> hp = hp'", "have h_eq: \"z' + hp' = z + hp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z' + hp' = z + hp", "using hhp hhp' hpz hpz'"], ["proof (prove)\nusing this:\n  h = hp + z\n  h = hp' + z'\n  hp ## z\n  hp' ## z'\n\ngoal (1 subgoal):\n 1. z' + hp' = z + hp", "by (fastforce simp: sep_add_ac)"], ["proof (state)\nthis:\n  z' + hp' = z + hp\n\ngoal (1 subgoal):\n 1. \\<And>h hp hp'.\n       \\<lbrakk>\\<forall>Q R.\n                   ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n                   (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s);\n        hp \\<preceq> h; P hp; hp' \\<preceq> h; P hp'\\<rbrakk>\n       \\<Longrightarrow> hp = hp'", "from hhp hhp' a hpz hpz' h_eq"], ["proof (chain)\npicking this:\n  h = hp + z\n  h = hp' + z'\n  \\<forall>Q R.\n     ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n     (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n  hp ## z\n  hp' ## z'\n  z' + hp' = z + hp", "have \"\\<forall>Q R. ((Q and R) \\<and>* P) (z + hp) = ((Q \\<and>* P) and (R \\<and>* P)) (z' + hp')\""], ["proof (prove)\nusing this:\n  h = hp + z\n  h = hp' + z'\n  \\<forall>Q R.\n     ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n     (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s)\n  hp ## z\n  hp' ## z'\n  z' + hp' = z + hp\n\ngoal (1 subgoal):\n 1. \\<forall>Q R.\n       ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) (z + hp) =\n       ((Q \\<and>* P) (z' + hp') \\<and> (R \\<and>* P) (z' + hp'))", "by (fastforce simp: h_eq sep_add_ac sep_conj_commute)"], ["proof (state)\nthis:\n  \\<forall>Q R.\n     ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) (z + hp) =\n     ((Q \\<and>* P) (z' + hp') \\<and> (R \\<and>* P) (z' + hp'))\n\ngoal (1 subgoal):\n 1. \\<And>h hp hp'.\n       \\<lbrakk>\\<forall>Q R.\n                   ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n                   (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s);\n        hp \\<preceq> h; P hp; hp' \\<preceq> h; P hp'\\<rbrakk>\n       \\<Longrightarrow> hp = hp'", "hence \"(((=) z and (=) z') \\<and>* P) (z + hp) =\n           (((=) z \\<and>* P) and ((=) z' \\<and>* P)) (z' + hp')\""], ["proof (prove)\nusing this:\n  \\<forall>Q R.\n     ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) (z + hp) =\n     ((Q \\<and>* P) (z' + hp') \\<and> (R \\<and>* P) (z' + hp'))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>s. z = s \\<and> z' = s) \\<and>* P) (z + hp) =\n    (((=) z \\<and>* P) (z' + hp') \\<and> ((=) z' \\<and>* P) (z' + hp'))", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>s. z = s \\<and> z' = s) \\<and>* P) (z + hp) =\n  (((=) z \\<and>* P) (z' + hp') \\<and> ((=) z' \\<and>* P) (z' + hp'))\n\ngoal (1 subgoal):\n 1. \\<And>h hp hp'.\n       \\<lbrakk>\\<forall>Q R.\n                   ((\\<lambda>s. Q s \\<and> R s) \\<and>* P) =\n                   (\\<lambda>s. (Q \\<and>* P) s \\<and> (R \\<and>* P) s);\n        hp \\<preceq> h; P hp; hp' \\<preceq> h; P hp'\\<rbrakk>\n       \\<Longrightarrow> hp = hp'", "thus  \"hp = hp'\""], ["proof (prove)\nusing this:\n  ((\\<lambda>s. z = s \\<and> z' = s) \\<and>* P) (z + hp) =\n  (((=) z \\<and>* P) (z' + hp') \\<and> ((=) z' \\<and>* P) (z' + hp'))\n\ngoal (1 subgoal):\n 1. hp = hp'", "using php php' hpz hpz' h_eq"], ["proof (prove)\nusing this:\n  ((\\<lambda>s. z = s \\<and> z' = s) \\<and>* P) (z + hp) =\n  (((=) z \\<and>* P) (z' + hp') \\<and> ((=) z' \\<and>* P) (z' + hp'))\n  P hp\n  P hp'\n  hp ## z\n  hp' ## z'\n  z' + hp' = z + hp\n\ngoal (1 subgoal):\n 1. hp = hp'", "by (fastforce dest!: iffD2 cong: conj_cong\n                    simp: sep_add_ac sep_add_cancel sep_conj_def)"], ["proof (state)\nthis:\n  hp = hp'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  precise P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strictly_precise: \"strictly_exact P \\<Longrightarrow> precise P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictly_exact P \\<Longrightarrow> precise P", "by (metis precise_def strictly_exactD)"], ["", "end"], ["", "end"]]}