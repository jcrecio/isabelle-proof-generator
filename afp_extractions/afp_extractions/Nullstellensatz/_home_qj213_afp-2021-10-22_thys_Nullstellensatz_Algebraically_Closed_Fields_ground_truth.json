{"file_name": "/home/qj213/afp-2021-10-22/thys/Nullstellensatz/Algebraically_Closed_Fields.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nullstellensatz", "problem_names": ["lemma prod_eq_zeroE:\n  assumes \"prod f I = (0::'a::{semiring_no_zero_divisors,comm_monoid_mult,zero_neq_one})\"\n  obtains i where \"finite I\" and \"i \\<in> I\" and \"f i = 0\"", "lemma degree_prod_eq:\n  assumes \"finite I\" and \"\\<And>i. i \\<in> I \\<Longrightarrow> f i \\<noteq> 0\"\n  shows \"Polynomial.degree (prod f I :: _::semiring_no_zero_divisors poly) = (\\<Sum>i\\<in>I. Polynomial.degree (f i))\"", "lemma rootE:\n  assumes \"0 < Polynomial.degree p\"\n  obtains z where \"poly p z = (0::'a)\"", "lemma infinite_UNIV: \"infinite (UNIV::'a set)\"", "lemma linear_factorsE:\n  fixes p :: \"'a poly\"\n  obtains c A m where \"finite A\" and \"p = Polynomial.smult c (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a)\"\n    and \"\\<And>a. m a = 0 \\<longleftrightarrow> a \\<notin> A\" and \"c = 0 \\<longleftrightarrow> p = 0\" and \"\\<And>z. poly p z = 0 \\<longleftrightarrow> (c = 0 \\<or> z \\<in> A)\""], "translations": [["", "lemma prod_eq_zeroE:\n  assumes \"prod f I = (0::'a::{semiring_no_zero_divisors,comm_monoid_mult,zero_neq_one})\"\n  obtains i where \"finite I\" and \"i \\<in> I\" and \"f i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>finite I; i \\<in> I; f i = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>finite I; i \\<in> I; f i = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"finite I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow> False", "assume \"infinite I\""], ["proof (state)\nthis:\n  infinite I\n\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  prod f I = (0::'a)\n  infinite I", "show False"], ["proof (prove)\nusing this:\n  prod f I = (0::'a)\n  infinite I\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite I\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>finite I; i \\<in> I; f i = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  finite I\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>finite I; i \\<in> I; f i = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this assms"], ["proof (chain)\npicking this:\n  finite I\n  prod f I = (0::'a)", "obtain i where \"i \\<in> I\" and \"f i = 0\""], ["proof (prove)\nusing this:\n  finite I\n  prod f I = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> I; f i = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct I arbitrary: thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<in> {}; f i = (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        prod f {} = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>i.\n                       \\<lbrakk>i \\<in> F; f i = (0::'a)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            prod f F = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>i \\<in> insert x F; f i = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        prod f (insert x F) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case empty"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<in> {}; f ?i = (0::'a)\\<rbrakk> \\<Longrightarrow> thesis\n  prod f {} = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i \\<in> {}; f i = (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        prod f {} = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>i.\n                       \\<lbrakk>i \\<in> F; f i = (0::'a)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            prod f F = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>i \\<in> insert x F; f i = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        prod f (insert x F) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> thesis", "from empty(2)"], ["proof (chain)\npicking this:\n  prod f {} = (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  prod f {} = (0::'a)\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>i.\n                       \\<lbrakk>i \\<in> F; f i = (0::'a)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            prod f F = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>i \\<in> insert x F; f i = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        prod f (insert x F) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>i.\n                       \\<lbrakk>i \\<in> F; f i = (0::'a)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            prod f F = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>i \\<in> insert x F; f i = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        prod f (insert x F) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (insert j I)"], ["proof (state)\nthis:\n  finite I\n  j \\<notin> I\n  \\<lbrakk>\\<And>i.\n              \\<lbrakk>i \\<in> I; f i = (0::'a)\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   prod f I = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>?i \\<in> insert j I; f ?i = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  prod f (insert j I) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>i.\n                       \\<lbrakk>i \\<in> F; f i = (0::'a)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            prod f F = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>i \\<in> insert x F; f i = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        prod f (insert x F) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> thesis", "from insert.hyps(1, 2)"], ["proof (chain)\npicking this:\n  finite I\n  j \\<notin> I", "have \"f j * prod f I = prod f (insert j I)\""], ["proof (prove)\nusing this:\n  finite I\n  j \\<notin> I\n\ngoal (1 subgoal):\n 1. f j * prod f I = prod f (insert j I)", "by simp"], ["proof (state)\nthis:\n  f j * prod f I = prod f (insert j I)\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>i.\n                       \\<lbrakk>i \\<in> F; f i = (0::'a)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            prod f F = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>i \\<in> insert x F; f i = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        prod f (insert x F) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  f j * prod f I = prod f (insert j I)\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>i.\n                       \\<lbrakk>i \\<in> F; f i = (0::'a)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            prod f F = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>i \\<in> insert x F; f i = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        prod f (insert x F) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f (insert j I) = (0::'a)", "by fact"], ["proof (state)\nthis:\n  prod f (insert j I) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>i.\n                       \\<lbrakk>i \\<in> F; f i = (0::'a)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            prod f F = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>i \\<in> insert x F; f i = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        prod f (insert x F) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  f j * prod f I = (0::'a)", "have \"f j = 0 \\<or> prod f I = 0\""], ["proof (prove)\nusing this:\n  f j * prod f I = (0::'a)\n\ngoal (1 subgoal):\n 1. f j = (0::'a) \\<or> prod f I = (0::'a)", "by simp"], ["proof (state)\nthis:\n  f j = (0::'a) \\<or> prod f I = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>i.\n                       \\<lbrakk>i \\<in> F; f i = (0::'a)\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            prod f F = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>i \\<in> insert x F; f i = (0::'a)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        prod f (insert x F) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  f j = (0::'a) \\<or> prod f I = (0::'a)\n\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. f j = (0::'a) \\<Longrightarrow> thesis\n 2. prod f I = (0::'a) \\<Longrightarrow> thesis", "assume \"f j = 0\""], ["proof (state)\nthis:\n  f j = (0::'a)\n\ngoal (2 subgoals):\n 1. f j = (0::'a) \\<Longrightarrow> thesis\n 2. prod f I = (0::'a) \\<Longrightarrow> thesis", "with _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  f j = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  f j = (0::'a)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule insert.prems) simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. prod f I = (0::'a) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. prod f I = (0::'a) \\<Longrightarrow> thesis", "assume \"prod f I = 0\""], ["proof (state)\nthis:\n  prod f I = (0::'a)\n\ngoal (1 subgoal):\n 1. prod f I = (0::'a) \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  prod f I = (0::'a)", "obtain i where \"i \\<in> I\" and \"f i = 0\""], ["proof (prove)\nusing this:\n  prod f I = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> I; f i = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert.hyps(3)"], ["proof (prove)\nusing this:\n  prod f I = (0::'a)\n  \\<lbrakk>\\<And>i.\n              \\<lbrakk>i \\<in> I; f i = (0::'a)\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   prod f I = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> I; f i = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<in> I\n  f i = (0::'a)\n\ngoal (1 subgoal):\n 1. prod f I = (0::'a) \\<Longrightarrow> thesis", "from _ this(2)"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  f i = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  f i = (0::'a)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule insert.prems) (simp add: \\<open>i \\<in> I\\<close>)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<in> I\n  f i = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>finite I; i \\<in> I; f i = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  finite I\n  i \\<in> I\n  f i = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite I\n  i \\<in> I\n  f i = (0::'a)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_prod_eq:\n  assumes \"finite I\" and \"\\<And>i. i \\<in> I \\<Longrightarrow> f i \\<noteq> 0\"\n  shows \"Polynomial.degree (prod f I :: _::semiring_no_zero_divisors poly) = (\\<Sum>i\\<in>I. Polynomial.degree (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod f I) = (\\<Sum>i\\<in>I. degree (f i))", "using assms"], ["proof (prove)\nusing this:\n  finite I\n  ?i \\<in> I \\<Longrightarrow> f ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (prod f I) = (\\<Sum>i\\<in>I. degree (f i))", "proof (induct I)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n    degree (prod f {}) = (\\<Sum>i\\<in>{}. degree (f i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "case empty"], ["proof (state)\nthis:\n  ?i \\<in> {} \\<Longrightarrow> f ?i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n    degree (prod f {}) = (\\<Sum>i\\<in>{}. degree (f i))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod f {}) = (\\<Sum>i\\<in>{}. degree (f i))", "by simp"], ["proof (state)\nthis:\n  degree (prod f {}) = (\\<Sum>i\\<in>{}. degree (f i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "case (insert j J)"], ["proof (state)\nthis:\n  finite J\n  j \\<notin> J\n  (\\<And>i. i \\<in> J \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n  degree (prod f J) = (\\<Sum>i\\<in>J. degree (f i))\n  ?i \\<in> insert j J \\<Longrightarrow> f ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "have 1: \"f i \\<noteq> 0\" if \"i \\<in> J\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<noteq> 0", "proof (rule insert.prems)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> insert j J", "from that"], ["proof (chain)\npicking this:\n  i \\<in> J", "show \"i \\<in> insert j J\""], ["proof (prove)\nusing this:\n  i \\<in> J\n\ngoal (1 subgoal):\n 1. i \\<in> insert j J", "by simp"], ["proof (state)\nthis:\n  i \\<in> insert j J\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> J \\<Longrightarrow> f ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "hence eq: \"Polynomial.degree (prod f J) = (\\<Sum>i\\<in>J. Polynomial.degree (f i))\""], ["proof (prove)\nusing this:\n  ?i \\<in> J \\<Longrightarrow> f ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (prod f J) = (\\<Sum>i\\<in>J. degree (f i))", "by (rule insert.hyps)"], ["proof (state)\nthis:\n  degree (prod f J) = (\\<Sum>i\\<in>J. degree (f i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "from insert.hyps(1, 2)"], ["proof (chain)\npicking this:\n  finite J\n  j \\<notin> J", "have \"Polynomial.degree (prod f (insert j J)) = Polynomial.degree (f j * prod f J)\""], ["proof (prove)\nusing this:\n  finite J\n  j \\<notin> J\n\ngoal (1 subgoal):\n 1. degree (prod f (insert j J)) = degree (f j * prod f J)", "by simp"], ["proof (state)\nthis:\n  degree (prod f (insert j J)) = degree (f j * prod f J)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "also"], ["proof (state)\nthis:\n  degree (prod f (insert j J)) = degree (f j * prod f J)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "have \"\\<dots> = Polynomial.degree (f j) + Polynomial.degree (prod f J)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f j * prod f J) = degree (f j) + degree (prod f J)", "proof (rule degree_mult_eq)"], ["proof (state)\ngoal (2 subgoals):\n 1. f j \\<noteq> 0\n 2. prod f J \\<noteq> 0", "show \"f j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f j \\<noteq> 0", "by (rule insert.prems) simp"], ["proof (state)\nthis:\n  f j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod f J \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. prod f J \\<noteq> 0", "show \"prod f J \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f J \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. prod f J = 0 \\<Longrightarrow> False", "assume \"prod f J = 0\""], ["proof (state)\nthis:\n  prod f J = 0\n\ngoal (1 subgoal):\n 1. prod f J = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  prod f J = 0", "obtain i where \"i \\<in> J\" and \"f i = 0\""], ["proof (prove)\nusing this:\n  prod f J = 0\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> J; f i = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule prod_eq_zeroE)"], ["proof (state)\nthis:\n  i \\<in> J\n  f i = 0\n\ngoal (1 subgoal):\n 1. prod f J = 0 \\<Longrightarrow> False", "from this(1)"], ["proof (chain)\npicking this:\n  i \\<in> J", "have \"f i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i \\<in> J\n\ngoal (1 subgoal):\n 1. f i \\<noteq> 0", "by (rule 1)"], ["proof (state)\nthis:\n  f i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prod f J = 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  f i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>f i = 0\\<close>"], ["proof (prove)\nusing this:\n  f i \\<noteq> 0\n  f i = 0\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod f J \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (f j * prod f J) = degree (f j) + degree (prod f J)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "also"], ["proof (state)\nthis:\n  degree (f j * prod f J) = degree (f j) + degree (prod f J)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "from insert.hyps(1, 2)"], ["proof (chain)\npicking this:\n  finite J\n  j \\<notin> J", "have \"\\<dots> = (\\<Sum>i\\<in>insert j J. Polynomial.degree (f i))\""], ["proof (prove)\nusing this:\n  finite J\n  j \\<notin> J\n\ngoal (1 subgoal):\n 1. degree (f j) + degree (prod f J) =\n    (\\<Sum>i\\<in>insert j J. degree (f i))", "by (simp add: eq)"], ["proof (state)\nthis:\n  degree (f j) + degree (prod f J) = (\\<Sum>i\\<in>insert j J. degree (f i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> f i \\<noteq> 0) \\<Longrightarrow>\n        degree (prod f F) = (\\<Sum>i\\<in>F. degree (f i));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> f i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> degree (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. degree (f i))", "finally"], ["proof (chain)\npicking this:\n  degree (prod f (insert j J)) = (\\<Sum>i\\<in>insert j J. degree (f i))", "show ?case"], ["proof (prove)\nusing this:\n  degree (prod f (insert j J)) = (\\<Sum>i\\<in>insert j J. degree (f i))\n\ngoal (1 subgoal):\n 1. degree (prod f (insert j J)) = (\\<Sum>i\\<in>insert j J. degree (f i))", "."], ["proof (state)\nthis:\n  degree (prod f (insert j J)) = (\\<Sum>i\\<in>insert j J. degree (f i))\n\ngoal:\nNo subgoals!", "qed"], ["", "class alg_closed_field =\n  assumes alg_closed_field_axiom: \"\\<And>p::'a::field poly. 0 < Polynomial.degree p \\<Longrightarrow> \\<exists>z. poly p z = 0\"\nbegin"], ["", "lemma rootE:\n  assumes \"0 < Polynomial.degree p\"\n  obtains z where \"poly p z = (0::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z. poly p z = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>z. poly p z = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  0 < degree p", "have \"\\<exists>z. poly p z = 0\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<exists>z. poly p z = (0::'a)", "by (rule alg_closed_field_axiom)"], ["proof (state)\nthis:\n  \\<exists>z. poly p z = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>z. poly p z = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>z. poly p z = (0::'a)", "obtain z where \"poly p z = 0\""], ["proof (prove)\nusing this:\n  \\<exists>z. poly p z = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>z. poly p z = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  poly p z = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>z. poly p z = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly p z = (0::'a)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_UNIV: \"infinite (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "assume fin: \"finite (UNIV::'a set)\""], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "define p where \"p = (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:]) + [:-1:]\""], ["proof (state)\nthis:\n  p = (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:]) + [:- (1::'a):]\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "have \"Polynomial.degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:]) = (\\<Sum>a\\<in>UNIV. Polynomial.degree [:- a, 1::'a:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:]) =\n    (\\<Sum>a\\<in>UNIV. degree [:- a, 1::'a:])", "using fin"], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:]) =\n    (\\<Sum>a\\<in>UNIV. degree [:- a, 1::'a:])", "by (rule degree_prod_eq) simp"], ["proof (state)\nthis:\n  degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:]) =\n  (\\<Sum>a\\<in>UNIV. degree [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:]) =\n  (\\<Sum>a\\<in>UNIV. degree [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>a\\<in>(UNIV::'a set). 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>UNIV. degree [:- a, 1::'a:]) = (\\<Sum>a\\<in>UNIV. 1)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>UNIV. degree [:- a, 1::'a:]) = (\\<Sum>a\\<in>UNIV. 1)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>UNIV. degree [:- a, 1::'a:]) = (\\<Sum>a\\<in>UNIV. 1)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "have \"\\<dots> = card (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>UNIV. 1) = card UNIV", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>UNIV. 1) = card UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>UNIV. 1) = card UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "from fin"], ["proof (chain)\npicking this:\n  finite UNIV", "have \"\\<dots> > 0\""], ["proof (prove)\nusing this:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. 0 < card UNIV", "by (rule finite_UNIV_card_ge_0)"], ["proof (state)\nthis:\n  0 < card UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 < degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])", "have \"0 < Polynomial.degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\""], ["proof (prove)\nusing this:\n  0 < degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. 0 < degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])", "."], ["proof (state)\nthis:\n  0 < degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "hence \"Polynomial.degree [:-1:] < Polynomial.degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\""], ["proof (prove)\nusing this:\n  0 < degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. degree [:- (1::'b):] < degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])", "by simp"], ["proof (state)\nthis:\n  degree [:- (1::?'b1):] < degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "hence \"Polynomial.degree p = Polynomial.degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\""], ["proof (prove)\nusing this:\n  degree [:- (1::?'b1):] < degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. degree p = degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])", "unfolding p_def"], ["proof (prove)\nusing this:\n  degree [:- (1::?'b1):] < degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. degree ((\\<Prod>a\\<in>UNIV. [:- a, 1::'a:]) + [:- (1::'a):]) =\n    degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])", "by (rule degree_add_eq_left)"], ["proof (state)\nthis:\n  degree p = degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree p = degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "have \"\\<dots> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])", "by fact"], ["proof (state)\nthis:\n  0 < degree (\\<Prod>a\\<in>UNIV. [:- a, 1::'a:])\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 < degree p", "have \"0 < Polynomial.degree p\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. 0 < degree p", "."], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < degree p", "obtain z where \"poly p z = 0\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. (\\<And>z. poly p z = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule rootE)"], ["proof (state)\nthis:\n  poly p z = (0::'a)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "hence \"(\\<Prod>a\\<in>UNIV. (z - a)) = 1\""], ["proof (prove)\nusing this:\n  poly p z = (0::'a)\n\ngoal (1 subgoal):\n 1. prod ((-) z) UNIV = (1::'a)", "by (simp add: p_def poly_prod)"], ["proof (state)\nthis:\n  prod ((-) z) UNIV = (1::'a)\n\ngoal (1 subgoal):\n 1. finite UNIV \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  prod ((-) z) UNIV = (1::'a)\n\ngoal (1 subgoal):\n 1. False", "by (metis UNIV_I cancel_comm_monoid_add_class.diff_cancel fin one_neq_zero prod_zero_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linear_factorsE:\n  fixes p :: \"'a poly\"\n  obtains c A m where \"finite A\" and \"p = Polynomial.smult c (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a)\"\n    and \"\\<And>a. m a = 0 \\<longleftrightarrow> a \\<notin> A\" and \"c = 0 \\<longleftrightarrow> p = 0\" and \"\\<And>z. poly p z = 0 \\<longleftrightarrow> (c = 0 \\<or> z \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>a. (m a = 0) = (a \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>a. (m a = 0) = (a \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain c A m where fin: \"finite A\" and p: \"p = Polynomial.smult c (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a)\"\n    and *: \"\\<And>x. m x = 0 \\<longleftrightarrow> x \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct p arbitrary: thesis rule: poly_root_induct[where P=\"\\<lambda>_. True\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>thesis.\n       (\\<And>A c m.\n           \\<lbrakk>finite A;\n            0 = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>p thesis.\n       \\<lbrakk>\\<And>a. True \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case 0"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?A; 0 = smult ?c (\\<Prod>a\\<in>?A. [:- a, 1::'a:] ^ ?m a);\n   \\<And>x. (?m x = 0) = (x \\<notin> ?A)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (3 subgoals):\n 1. \\<And>thesis.\n       (\\<And>A c m.\n           \\<lbrakk>finite A;\n            0 = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>p thesis.\n       \\<lbrakk>\\<And>a. True \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule 0)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite ?A\n 2. 0 = smult ?c (\\<Prod>a\\<in>?A. [:- a, 1::'a:] ^ ?m a)\n 3. \\<And>x. (?m x = 0) = (x \\<notin> ?A)", "show \"0 = Polynomial.smult 0 (\\<Prod>a\\<in>{}. [:- a, 1:] ^ (\\<lambda>_. 0) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = smult (0::'b) (\\<Prod>a\\<in>{}. [:- a, 1::'b:] ^ 0)", "by simp"], ["proof (state)\nthis:\n  0 = smult (0::?'b1) (\\<Prod>a\\<in>{}. [:- a, 1::?'b1:] ^ 0)\n\ngoal (2 subgoals):\n 1. finite {}\n 2. \\<And>x. (0 = 0) = (x \\<notin> {})", "qed simp_all"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>p thesis.\n       \\<lbrakk>\\<And>a. True \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p thesis.\n       \\<lbrakk>\\<And>a. True \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (no_roots p)"], ["proof (state)\nthis:\n  True \\<Longrightarrow> poly p ?a \\<noteq> (0::'a)\n  \\<lbrakk>finite ?A; p = smult ?c (\\<Prod>a\\<in>?A. [:- a, 1::'a:] ^ ?m a);\n   \\<And>x. (?m x = 0) = (x \\<notin> ?A)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>p thesis.\n       \\<lbrakk>\\<And>a. True \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"Polynomial.degree p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow> False", "assume \"Polynomial.degree p \\<noteq> 0\""], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow> False", "hence \"0 < Polynomial.degree p\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < degree p", "by simp"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < degree p", "obtain z where \"poly p z = 0\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. (\\<And>z. poly p z = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule rootE)"], ["proof (state)\nthis:\n  poly p z = (0::'a)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  poly p z = (0::'a)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow> False", "have \"poly p z \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p z \\<noteq> (0::'a)", "by (rule no_roots) blast"], ["proof (state)\nthis:\n  poly p z \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  poly p z = (0::'a)\n  poly p z \\<noteq> (0::'a)", "show False"], ["proof (prove)\nusing this:\n  poly p z = (0::'a)\n  poly p z \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (2 subgoals):\n 1. \\<And>p thesis.\n       \\<lbrakk>\\<And>a. True \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  degree p = 0", "obtain c where p: \"p = [:c:]\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>c. p = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (rule degree_eq_zeroE)"], ["proof (state)\nthis:\n  p = [:c:]\n\ngoal (2 subgoals):\n 1. \\<And>p thesis.\n       \\<lbrakk>\\<And>a. True \\<Longrightarrow> poly p a \\<noteq> (0::'a);\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule no_roots)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite ?A\n 2. p = smult ?c (\\<Prod>a\\<in>?A. [:- a, 1::'a:] ^ ?m a)\n 3. \\<And>x. (?m x = 0) = (x \\<notin> ?A)", "show \"p = Polynomial.smult c (\\<Prod>a\\<in>{}. [:- a, 1:] ^ (\\<lambda>_. 0) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>a\\<in>{}. [:- a, 1::'a:] ^ 0)", "by (simp add: p)"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>a\\<in>{}. [:- a, 1::'a:] ^ 0)\n\ngoal (2 subgoals):\n 1. finite {}\n 2. \\<And>x. (0 = 0) = (x \\<notin> {})", "qed simp_all"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (root a p)"], ["proof (state)\nthis:\n  True\n  (\\<And>A c m.\n      \\<lbrakk>finite A; p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n       \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<lbrakk>finite ?A;\n   [:a, - (1::'a):] * p = smult ?c (\\<Prod>a\\<in>?A. [:- a, 1::'a:] ^ ?m a);\n   \\<And>x. (?m x = 0) = (x \\<notin> ?A)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain A c m where 1: \"finite A\" and p: \"p = Polynomial.smult c (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a)\"\n      and 2: \"\\<And>x. m x = 0 \\<longleftrightarrow> x \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule root.hyps) blast"], ["proof (state)\nthis:\n  finite A\n  p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n  (m ?x = 0) = (?x \\<notin> A)\n\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "define m' where \"m' = (\\<lambda>x. if x = a then Suc (m x) else m x)\""], ["proof (state)\nthis:\n  m' = (\\<lambda>x. if x = a then Suc (m x) else m x)\n\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>True;\n        \\<And>thesis.\n           (\\<And>A c m.\n               \\<lbrakk>finite A;\n                p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n                \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n               \\<Longrightarrow> thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>A c m.\n           \\<lbrakk>finite A;\n            [:a, - (1::'a):] * p =\n            smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n            \\<And>x. (m x = 0) = (x \\<notin> A)\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule root.prems)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite ?A\n 2. [:a, - (1::'a):] * p = smult ?c (\\<Prod>a\\<in>?A. [:- a, 1::'a:] ^ ?m a)\n 3. \\<And>x. (?m x = 0) = (x \\<notin> ?A)", "from 1"], ["proof (chain)\npicking this:\n  finite A", "show \"finite (insert a A)\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (insert a A)", "by simp"], ["proof (state)\nthis:\n  finite (insert a A)\n\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p =\n    smult ?c (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ ?m a)\n 2. \\<And>x. (?m x = 0) = (x \\<notin> insert a A)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p =\n    smult ?c (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ ?m a)\n 2. \\<And>x. (?m x = 0) = (x \\<notin> insert a A)", "have \"[:a, - 1:] * p = [:- a, 1:] * (- p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:a, - (1::'a):] * p = [:- a, 1::'a:] * - p", "by simp"], ["proof (state)\nthis:\n  [:a, - (1::'a):] * p = [:- a, 1::'a:] * - p\n\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p =\n    smult ?c (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ ?m a)\n 2. \\<And>x. (?m x = 0) = (x \\<notin> insert a A)", "also"], ["proof (state)\nthis:\n  [:a, - (1::'a):] * p = [:- a, 1::'a:] * - p\n\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p =\n    smult ?c (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ ?m a)\n 2. \\<And>x. (?m x = 0) = (x \\<notin> insert a A)", "have \"\\<dots> = [:- a, 1:] * (Polynomial.smult (- c) (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * - p =\n    [:- a, 1::'a:] * smult (- c) (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)", "by (simp add: p)"], ["proof (state)\nthis:\n  [:- a, 1::'a:] * - p =\n  [:- a, 1::'a:] * smult (- c) (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p =\n    smult ?c (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ ?m a)\n 2. \\<And>x. (?m x = 0) = (x \\<notin> insert a A)", "also"], ["proof (state)\nthis:\n  [:- a, 1::'a:] * - p =\n  [:- a, 1::'a:] * smult (- c) (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p =\n    smult ?c (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ ?m a)\n 2. \\<And>x. (?m x = 0) = (x \\<notin> insert a A)", "have \"\\<dots> = Polynomial.smult (- c) ([:- a, 1:] * (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * smult (- c) (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    smult (- c) ([:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a))", "by (simp only: mult_smult_right ac_simps)"], ["proof (state)\nthis:\n  [:- a, 1::'a:] * smult (- c) (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  smult (- c) ([:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a))\n\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p =\n    smult ?c (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ ?m a)\n 2. \\<And>x. (?m x = 0) = (x \\<notin> insert a A)", "also"], ["proof (state)\nthis:\n  [:- a, 1::'a:] * smult (- c) (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  smult (- c) ([:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a))\n\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p =\n    smult ?c (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ ?m a)\n 2. \\<And>x. (?m x = 0) = (x \\<notin> insert a A)", "have \"[:- a, 1:] * (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a) = (\\<Prod>a\\<in>insert a A. [:- a, 1:] ^ m' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "proof (cases \"a \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n 2. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "case True"], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (2 subgoals):\n 1. a \\<in> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n 2. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "with 1"], ["proof (chain)\npicking this:\n  finite A\n  a \\<in> A", "have \"(\\<Prod>a\\<in>A. [:- a, 1:] ^ m a) = [:- a, 1:] ^ m a * (\\<Prod>a\\<in>A-{a}. [:- a, 1:] ^ m a)\""], ["proof (prove)\nusing this:\n  finite A\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    [:- a, 1::'a:] ^ m a * (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m a)", "by (simp add: prod.remove)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  [:- a, 1::'a:] ^ m a * (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m a)\n\ngoal (2 subgoals):\n 1. a \\<in> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n 2. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  [:- a, 1::'a:] ^ m a * (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m a)\n\ngoal (2 subgoals):\n 1. a \\<in> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n 2. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"(\\<Prod>a\\<in>A-{a}. [:- a, 1:] ^ m a) = (\\<Prod>a\\<in>A-{a}. [:- a, 1:] ^ m' a)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m' a)", "by (rule prod.cong) (simp add: m'_def)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m a) =\n  (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m' a)\n\ngoal (2 subgoals):\n 1. a \\<in> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n 2. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  [:- a, 1::'a:] ^ m a * (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m' a)", "have \"[:- a, 1:] * (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a) =\n                          ([:- a, 1:] * [:- a, 1:] ^ m a) * (\\<Prod>a\\<in>A - {a}. [:- a, 1:] ^ m' a)\""], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  [:- a, 1::'a:] ^ m a * (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m' a)\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    [:- a, 1::'a:] * [:- a, 1::'a:] ^ m a *\n    (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m' a)", "by (simp only: mult.assoc)"], ["proof (state)\nthis:\n  [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  [:- a, 1::'a:] * [:- a, 1::'a:] ^ m a *\n  (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m' a)\n\ngoal (2 subgoals):\n 1. a \\<in> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n 2. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "also"], ["proof (state)\nthis:\n  [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  [:- a, 1::'a:] * [:- a, 1::'a:] ^ m a *\n  (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m' a)\n\ngoal (2 subgoals):\n 1. a \\<in> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n 2. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "have \"[:- a, 1:] * [:- a, 1:] ^ m a = [:- a, 1:] ^ m' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * [:- a, 1::'a:] ^ m a = [:- a, 1::'a:] ^ m' a", "by (simp add: m'_def)"], ["proof (state)\nthis:\n  [:- a, 1::'a:] * [:- a, 1::'a:] ^ m a = [:- a, 1::'a:] ^ m' a\n\ngoal (2 subgoals):\n 1. a \\<in> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n 2. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "finally"], ["proof (chain)\npicking this:\n  [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  [:- a, 1::'a:] ^ m' a * (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m' a)", "show ?thesis"], ["proof (prove)\nusing this:\n  [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  [:- a, 1::'a:] ^ m' a * (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m' a)\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "using 1"], ["proof (prove)\nusing this:\n  [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  [:- a, 1::'a:] ^ m' a * (\\<Prod>a\\<in>A - {a}. [:- a, 1::'a:] ^ m' a)\n  finite A\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "by (simp add: prod.insert_remove)"], ["proof (state)\nthis:\n  [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n\ngoal (1 subgoal):\n 1. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "case False"], ["proof (state)\nthis:\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "with 1"], ["proof (chain)\npicking this:\n  finite A\n  a \\<notin> A", "have \"(\\<Prod>a\\<in>insert a A. [:- a, 1:] ^ m' a) = [:- a, 1:] ^ m' a * (\\<Prod>a\\<in>A. [:- a, 1:] ^ m' a)\""], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a) =\n    [:- a, 1::'a:] ^ m' a * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m' a)", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a) =\n  [:- a, 1::'a:] ^ m' a * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m' a)\n\ngoal (1 subgoal):\n 1. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a) =\n  [:- a, 1::'a:] ^ m' a * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m' a)\n\ngoal (1 subgoal):\n 1. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"(\\<Prod>a\\<in>A. [:- a, 1:] ^ m' a) = (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m' a) =\n    (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)", "proof (rule prod.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       [:- x, 1::'a:] ^ m' x = [:- x, 1::'a:] ^ m x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       [:- x, 1::'a:] ^ m' x = [:- x, 1::'a:] ^ m x", "assume \"x \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       [:- x, 1::'a:] ^ m' x = [:- x, 1::'a:] ^ m x", "with False"], ["proof (chain)\npicking this:\n  a \\<notin> A\n  x \\<in> A", "have \"x \\<noteq> a\""], ["proof (prove)\nusing this:\n  a \\<notin> A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<noteq> a", "by blast"], ["proof (state)\nthis:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A \\<Longrightarrow>\n       [:- x, 1::'a:] ^ m' x = [:- x, 1::'a:] ^ m x", "thus \"[:- x, 1:] ^ m' x = [:- x, 1:] ^ m x\""], ["proof (prove)\nusing this:\n  x \\<noteq> a\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] ^ m' x = [:- x, 1::'a:] ^ m x", "by (simp add: m'_def)"], ["proof (state)\nthis:\n  [:- x, 1::'a:] ^ m' x = [:- x, 1::'a:] ^ m x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m' a) =\n  (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n\ngoal (1 subgoal):\n 1. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a) =\n  [:- a, 1::'a:] ^ m' a * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)", "have \"(\\<Prod>a\\<in>insert a A. [:- a, 1:] ^ m' a) = [:- a, 1:] ^ m' a * (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a)\""], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a) =\n  [:- a, 1::'a:] ^ m' a * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a) =\n    [:- a, 1::'a:] ^ m' a * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)", "."], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a) =\n  [:- a, 1::'a:] ^ m' a * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n\ngoal (1 subgoal):\n 1. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a) =\n  [:- a, 1::'a:] ^ m' a * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n\ngoal (1 subgoal):\n 1. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "from False"], ["proof (chain)\npicking this:\n  a \\<notin> A", "have \"m' a = 1\""], ["proof (prove)\nusing this:\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. m' a = 1", "by (simp add: m'_def 2)"], ["proof (state)\nthis:\n  m' a = 1\n\ngoal (1 subgoal):\n 1. a \\<notin> A \\<Longrightarrow>\n    [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a) =\n  [:- a, 1::'a:] ^ 1 * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a) =\n  [:- a, 1::'a:] ^ 1 * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n\ngoal (1 subgoal):\n 1. [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "by simp"], ["proof (state)\nthis:\n  [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [:- a, 1::'a:] * (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n\ngoal (2 subgoals):\n 1. [:a, - (1::'a):] * p =\n    smult ?c (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ ?m a)\n 2. \\<And>x. (?m x = 0) = (x \\<notin> insert a A)", "finally"], ["proof (chain)\npicking this:\n  [:a, - (1::'a):] * p =\n  smult (- c) (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "show \"[:a, - 1:] * p = Polynomial.smult (- c) (\\<Prod>a\\<in>insert a A. [:- a, 1:] ^ m' a)\""], ["proof (prove)\nusing this:\n  [:a, - (1::'a):] * p =\n  smult (- c) (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n\ngoal (1 subgoal):\n 1. [:a, - (1::'a):] * p =\n    smult (- c) (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)", "."], ["proof (state)\nthis:\n  [:a, - (1::'a):] * p =\n  smult (- c) (\\<Prod>a\\<in>insert a A. [:- a, 1::'a:] ^ m' a)\n\ngoal (1 subgoal):\n 1. \\<And>x. (m' x = 0) = (x \\<notin> insert a A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (m' x = 0) = (x \\<notin> insert a A)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (m' x = 0) = (x \\<notin> insert a A)", "show \"m' x = 0 \\<longleftrightarrow> x \\<notin> insert a A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m' x = 0) = (x \\<notin> insert a A)", "by (simp add: m'_def 2)"], ["proof (state)\nthis:\n  (m' x = 0) = (x \\<notin> insert a A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite A\n  p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n  (m ?x = 0) = (?x \\<notin> A)\n\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>a. (m a = 0) = (a \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  finite A\n  p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n  (m ?x = 0) = (?x \\<notin> A)\n\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>a. (m a = 0) = (a \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"c = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c = (0::'a)) = (p = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. c = (0::'a) \\<Longrightarrow> p = 0\n 2. p = 0 \\<Longrightarrow> c = (0::'a)", "assume \"p = 0\""], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. c = (0::'a) \\<Longrightarrow> p = 0\n 2. p = 0 \\<Longrightarrow> c = (0::'a)", "hence \"[:c:] = 0 \\<or> (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a) = 0\""], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. [:c:] = 0 \\<or> (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0", "by (simp add: p)"], ["proof (state)\nthis:\n  [:c:] = 0 \\<or> (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0\n\ngoal (2 subgoals):\n 1. c = (0::'a) \\<Longrightarrow> p = 0\n 2. p = 0 \\<Longrightarrow> c = (0::'a)", "thus \"c = 0\""], ["proof (prove)\nusing this:\n  [:c:] = 0 \\<or> (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0\n\ngoal (1 subgoal):\n 1. c = (0::'a)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. [:c:] = 0 \\<Longrightarrow> c = (0::'a)\n 2. (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0 \\<Longrightarrow> c = (0::'a)", "assume \"[:c:] = 0\""], ["proof (state)\nthis:\n  [:c:] = 0\n\ngoal (2 subgoals):\n 1. [:c:] = 0 \\<Longrightarrow> c = (0::'a)\n 2. (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0 \\<Longrightarrow> c = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [:c:] = 0\n\ngoal (1 subgoal):\n 1. c = (0::'a)", "by simp"], ["proof (state)\nthis:\n  c = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0 \\<Longrightarrow> c = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0 \\<Longrightarrow> c = (0::'a)", "assume \"(\\<Prod>a\\<in>A. [:- a, 1:] ^ m a) = 0\""], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0 \\<Longrightarrow> c = (0::'a)", "then"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0", "obtain a where \"[:- a, 1:] ^ m a = 0\""], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        [:- a, 1::'a:] ^ m a = 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule prod_eq_zeroE)"], ["proof (state)\nthis:\n  [:- a, 1::'a:] ^ m a = 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) = 0 \\<Longrightarrow> c = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [:- a, 1::'a:] ^ m a = 0\n\ngoal (1 subgoal):\n 1. c = (0::'a)", "by simp"], ["proof (state)\nthis:\n  c = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c = (0::'a)\n\ngoal (1 subgoal):\n 1. c = (0::'a) \\<Longrightarrow> p = 0", "qed (simp add: p)"], ["proof (state)\nthis:\n  (c = (0::'a)) = (p = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>a. (m a = 0) = (a \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (c = (0::'a)) = (p = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>a. (m a = 0) = (a \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  (c = (0::'a)) = (p = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>a. (m a = 0) = (a \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>a. (m a = 0) = (a \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"0 < m z\" if \"z \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m z", "by (rule ccontr) (simp add: * that)"], ["proof (state)\nthis:\n  z \\<in> A \\<Longrightarrow> 0 < m z\n\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>a. (m a = 0) = (a \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"poly p z = 0 \\<longleftrightarrow> (c = 0 \\<or> z \\<in> A)\""], ["proof (prove)\nusing this:\n  z \\<in> A \\<Longrightarrow> 0 < m z\n\ngoal (1 subgoal):\n 1. (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)", "by (auto simp: p poly_prod * fin elim: prod_eq_zeroE)"], ["proof (state)\nthis:\n  (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\n\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>a. (m a = 0) = (a \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  (poly p ?z2 = (0::'a)) = (c = (0::'a) \\<or> ?z2 \\<in> A)\n\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>a. (m a = 0) = (a \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  finite A\n  p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n  (m ?x = 0) = (?x \\<notin> A)\n  (c = (0::'a)) = (p = 0)\n  (poly p ?z2 = (0::'a)) = (c = (0::'a) \\<or> ?z2 \\<in> A)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite A\n  p = smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n  (m ?x = 0) = (?x \\<notin> A)\n  (c = (0::'a)) = (p = 0)\n  (poly p ?z2 = (0::'a)) = (c = (0::'a) \\<or> ?z2 \\<in> A)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* alg_closed_field *)"], ["", "instance complex :: alg_closed_field"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(complex, alg_closed_field_class)", "by standard (rule fundamental_theorem_of_algebra, simp add: constant_degree)"], ["", "end"], ["", "(* theory *)"]]}