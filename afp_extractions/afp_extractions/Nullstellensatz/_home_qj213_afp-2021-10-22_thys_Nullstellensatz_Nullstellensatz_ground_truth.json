{"file_name": "/home/qj213/afp-2021-10-22/thys/Nullstellensatz/Nullstellensatz.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nullstellensatz", "problem_names": ["lemma finite_linorder_induct [consumes 1, case_names empty insert]:\n  assumes \"finite (A::'a::linorder set)\" and \"P {}\"\n    and \"\\<And>a A. finite A \\<Longrightarrow> A \\<subseteq> {..<a} \\<Longrightarrow> P A \\<Longrightarrow> P (insert a A)\"\n  shows \"P A\"", "lemma Fract_same: \"Fract a a = (1 when a \\<noteq> 0)\"", "lemma Fract_eq_zero_iff: \"Fract a b = 0 \\<longleftrightarrow> a = 0 \\<or> b = 0\"", "lemma poly_plus_rightE:\n  obtains c where \"poly p (x + y) = poly p x + c * y\"", "lemma poly_minus_rightE:\n  obtains c where \"poly p (x - y) = poly p x - c * (y::_::comm_ring)\"", "lemma map_poly_plus:\n  assumes \"f 0 = 0\" and \"\\<And>a b. f (a + b) = f a + f b\"\n  shows \"map_poly f (p + q) = map_poly f p + map_poly f q\"", "lemma map_poly_minus:\n  assumes \"f 0 = 0\" and \"\\<And>a b. f (a - b) = f a - f b\"\n  shows \"map_poly f (p - q) = map_poly f p - map_poly f q\"", "lemma map_poly_sum:\n  assumes \"f 0 = 0\" and \"\\<And>a b. f (a + b) = f a + f b\"\n  shows \"map_poly f (sum g A) = (\\<Sum>a\\<in>A. map_poly f (g a))\"", "lemma map_poly_times:\n  assumes \"f 0 = 0\" and \"\\<And>a b. f (a + b) = f a + f b\" and \"\\<And>a b. f (a * b) = f a * f b\"\n  shows \"map_poly f (p * q) = map_poly f p * map_poly f q\"", "lemma poly_Fract:\n  assumes \"set (Polynomial.coeffs p) \\<subseteq> range (\\<lambda>x. Fract x 1)\"\n  obtains q m where \"poly p (Fract a b) = Fract q (b ^ m)\"", "lemma (in ordered_term) lt_sum_le_Max: \"lt (sum f A) \\<preceq>\\<^sub>t ord_term_lin.Max {lt (f a) | a. a \\<in> A}\"", "lemma variety_ofI: \"(\\<And>f. f \\<in> F \\<Longrightarrow> poly_eval a f = 0) \\<Longrightarrow> a \\<in> \\<V> F\"", "lemma variety_ofI_alt: \"poly_eval a ` F \\<subseteq> {0} \\<Longrightarrow> a \\<in> \\<V> F\"", "lemma variety_ofD: \"a \\<in> \\<V> F \\<Longrightarrow> f \\<in> F \\<Longrightarrow> poly_eval a f = 0\"", "lemma variety_of_empty [simp]: \"\\<V> {} = UNIV\"", "lemma variety_of_UNIV [simp]: \"\\<V> UNIV = {}\"", "lemma variety_of_antimono: \"F \\<subseteq> G \\<Longrightarrow> \\<V> G \\<subseteq> \\<V> F\"", "lemma variety_of_ideal [simp]: \"\\<V> (ideal F) = \\<V> F\"", "lemma ideal_ofI: \"(\\<And>a. a \\<in> A \\<Longrightarrow> poly_eval a f = 0) \\<Longrightarrow> f \\<in> \\<I> A\"", "lemma ideal_ofD: \"f \\<in> \\<I> A \\<Longrightarrow> a \\<in> A \\<Longrightarrow> poly_eval a f = 0\"", "lemma ideal_of_empty [simp]: \"\\<I> {} = UNIV\"", "lemma ideal_of_antimono: \"A \\<subseteq> B \\<Longrightarrow> \\<I> B \\<subseteq> \\<I> A\"", "lemma ideal_ideal_of [simp]: \"ideal (\\<I> A) = \\<I> A\"", "lemma ideal_of_UN: \"\\<I> (\\<Union> (A ` J)) = (\\<Inter>j\\<in>J. \\<I> (A j))\"", "lemma variety_of_ideal_of_variety [simp]: \"\\<V> (\\<I> (\\<V> F)) = \\<V> F\" (is \"_ = ?V\")", "lemma ideal_of_inj_on: \"inj_on \\<I> (range (\\<V>::(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1) set \\<Rightarrow> _))\"", "lemma ideal_of_variety_of_ideal [simp]: \"\\<I> (\\<V> (\\<I> A)) = \\<I> A\" (is \"_ = ?I\")", "lemma variety_of_inj_on: \"inj_on \\<V> (range (\\<I>::('x \\<Rightarrow> 'a::comm_semiring_1) set \\<Rightarrow> _))\"", "lemma image_map_indets_ideal_of:\n  assumes \"inj f\"\n  shows \"map_indets f ` \\<I> A = \\<I> ((\\<lambda>a. a \\<circ> f) -` (A::('x \\<Rightarrow> 'a::comm_semiring_1) set)) \\<inter> P[range f]\"", "lemma variety_of_map_indets: \"\\<V> (map_indets f ` F) = (\\<lambda>a. a \\<circ> f) -` \\<V> F\"", "lemma radicalI: \"f ^ m \\<in> F \\<Longrightarrow> f \\<in> \\<surd>F\"", "lemma radicalE:\n  assumes \"f \\<in> \\<surd>F\"\n  obtains m where \"f ^ m \\<in> F\"", "lemma radical_empty [simp]: \"\\<surd>{} = {}\"", "lemma radical_UNIV [simp]: \"\\<surd>UNIV = UNIV\"", "lemma radical_ideal_eq_UNIV_iff: \"\\<surd>ideal F = UNIV \\<longleftrightarrow> ideal F = UNIV\"", "lemma zero_in_radical_ideal [simp]: \"0 \\<in> \\<surd>ideal F\"", "lemma radical_mono: \"F \\<subseteq> G \\<Longrightarrow> \\<surd>F \\<subseteq> \\<surd>G\"", "lemma radical_superset: \"F \\<subseteq> \\<surd>F\"", "lemma radical_idem [simp]: \"\\<surd>\\<surd>F = \\<surd>F\"", "lemma radical_Int_subset: \"\\<surd>(A \\<inter> B) \\<subseteq> \\<surd>A \\<inter> \\<surd>B\"", "lemma radical_ideal_Int: \"\\<surd>(ideal F \\<inter> ideal G) = \\<surd>ideal F \\<inter> \\<surd>ideal G\"", "lemma ideal_radical_ideal [simp]: \"ideal (\\<surd>ideal F) = \\<surd>ideal F\" (is \"_ = ?R\")", "lemma radical_ideal_of [simp]: \"\\<surd>\\<I> A = \\<I> (A::(_ \\<Rightarrow> _::semiring_1_no_zero_divisors) set)\"", "lemma variety_of_radical_ideal [simp]: \"\\<V> (\\<surd>ideal F) = \\<V> (F::(_ \\<Rightarrow>\\<^sub>0 _::semiring_1_no_zero_divisors) set)\"", "lemma image_map_indets_radical:\n  assumes \"inj f\"\n  shows \"map_indets f ` \\<surd>F = \\<surd>(map_indets f ` (F::(_ \\<Rightarrow>\\<^sub>0 'a::comm_ring_1) set)) \\<inter> P[range f]\"", "lemma weak_Nullstellensatz_aux_1:\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> g i \\<in> ideal B\"\n  obtains c where \"c \\<in> ideal B\" and \"(\\<Prod>i\\<in>I. (f i + g i) ^ m i) = (\\<Prod>i\\<in>I. f i ^ m i) + c\"", "lemma weak_Nullstellensatz_aux_2:\n  assumes \"finite X\" and \"F \\<subseteq> P[insert x X]\" and \"X \\<subseteq> {..<x::'x::{countable,linorder}}\"\n    and \"1 \\<notin> ideal F\" and \"ideal F \\<inter> P[{x}] \\<subseteq> {0}\"\n  obtains a::\"'a::alg_closed_field\" where \"1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\"", "lemma weak_Nullstellensatz_aux_3:\n  assumes \"F \\<subseteq> P[insert x X]\" and \"x \\<notin> X\" and \"1 \\<notin> ideal F\" and \"\\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\"\n  obtains a::\"'a::alg_closed_field\" where \"1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\"", "theorem weak_Nullstellensatz:\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\" and \"\\<V> F = ({}::('x::{countable,linorder} \\<Rightarrow> 'a::alg_closed_field) set)\"\n  shows \"ideal F = UNIV\"", "lemma radical_idealI:\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\" and \"f \\<in> P[X]\" and \"x \\<notin> X\"\n    and \"\\<V> (insert (1 - punit.monom_mult 1 (Poly_Mapping.single x 1) f) F) = {}\"\n  shows \"(f::('x::{countable,linorder} \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::alg_closed_field) \\<in> \\<surd>ideal F\"", "theorem Nullstellensatz:\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\"\n    and \"(f::(_::{countable,linorder} \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 _::alg_closed_field) \\<in> \\<I> (\\<V> F)\"\n  shows \"f \\<in> \\<surd>ideal F\"", "theorem strong_Nullstellensatz:\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\"\n  shows \"\\<I> (\\<V> F) = \\<surd>ideal (F::((_::{countable,linorder} \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 _::alg_closed_field) set)\"", "lemma radical_ideal_iff:\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\" and \"f \\<in> P[X]\" and \"x \\<notin> X\"\n  shows \"(f::(_::{countable,linorder} \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 _::alg_closed_field) \\<in> \\<surd>ideal F \\<longleftrightarrow>\n            1 \\<in> ideal (insert (1 - punit.monom_mult 1 (Poly_Mapping.single x 1) f) F)\""], "translations": [["", "lemma finite_linorder_induct [consumes 1, case_names empty insert]:\n  assumes \"finite (A::'a::linorder set)\" and \"P {}\"\n    and \"\\<And>a A. finite A \\<Longrightarrow> A \\<subseteq> {..<a} \\<Longrightarrow> P A \\<Longrightarrow> P (insert a A)\"\n  shows \"P A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P A", "define k where \"k = card A\""], ["proof (state)\nthis:\n  k = card A\n\ngoal (1 subgoal):\n 1. P A", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = card A\n\ngoal (1 subgoal):\n 1. P A", "using assms(1)"], ["proof (prove)\nusing this:\n  k = card A\n  finite A\n\ngoal (1 subgoal):\n 1. P A", "proof (induct k arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A. \\<lbrakk>0 = card A; finite A\\<rbrakk> \\<Longrightarrow> P A\n 2. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "case 0"], ["proof (state)\nthis:\n  0 = card A\n  finite A\n\ngoal (2 subgoals):\n 1. \\<And>A. \\<lbrakk>0 = card A; finite A\\<rbrakk> \\<Longrightarrow> P A\n 2. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "with assms(2)"], ["proof (chain)\npicking this:\n  P {}\n  0 = card A\n  finite A", "show ?case"], ["proof (prove)\nusing this:\n  P {}\n  0 = card A\n  finite A\n\ngoal (1 subgoal):\n 1. P A", "by simp"], ["proof (state)\nthis:\n  P A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>k = card ?A; finite ?A\\<rbrakk> \\<Longrightarrow> P ?A\n  Suc k = card A\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "define a where \"a = Max A\""], ["proof (state)\nthis:\n  a = Max A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "from Suc.prems(1)"], ["proof (chain)\npicking this:\n  Suc k = card A", "have \"A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Suc k = card A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "with Suc.prems(2)"], ["proof (chain)\npicking this:\n  finite A\n  A \\<noteq> {}", "have \"a \\<in> A\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. a \\<in> A", "unfolding a_def"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max A \\<in> A", "by (rule Max_in)"], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "with Suc.prems"], ["proof (chain)\npicking this:\n  Suc k = card A\n  finite A\n  a \\<in> A", "have \"k = card (A - {a})\""], ["proof (prove)\nusing this:\n  Suc k = card A\n  finite A\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. k = card (A - {a})", "by simp"], ["proof (state)\nthis:\n  k = card (A - {a})\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "moreover"], ["proof (state)\nthis:\n  k = card (A - {a})\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "from Suc.prems(2)"], ["proof (chain)\npicking this:\n  finite A", "have \"finite (A - {a})\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (A - {a})", "by simp"], ["proof (state)\nthis:\n  finite (A - {a})\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "ultimately"], ["proof (chain)\npicking this:\n  k = card (A - {a})\n  finite (A - {a})", "have \"P (A - {a})\""], ["proof (prove)\nusing this:\n  k = card (A - {a})\n  finite (A - {a})\n\ngoal (1 subgoal):\n 1. P (A - {a})", "by (rule Suc.hyps)"], ["proof (state)\nthis:\n  P (A - {a})\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "with \\<open>finite (A - {a})\\<close> _"], ["proof (chain)\npicking this:\n  finite (A - {a})\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  P (A - {a})", "have \"P (insert a (A - {a}))\""], ["proof (prove)\nusing this:\n  finite (A - {a})\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  P (A - {a})\n\ngoal (1 subgoal):\n 1. P (insert a (A - {a}))", "proof (rule assms(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. A - {a} \\<subseteq> {..<a}", "show \"A - {a} \\<subseteq> {..<a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - {a} \\<subseteq> {..<a}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A - {a} \\<Longrightarrow> x \\<in> {..<a}", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A - {a} \\<Longrightarrow> x \\<in> {..<a}", "assume \"b \\<in> A - {a}\""], ["proof (state)\nthis:\n  b \\<in> A - {a}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A - {a} \\<Longrightarrow> x \\<in> {..<a}", "hence \"b \\<in> A\" and \"b \\<noteq> a\""], ["proof (prove)\nusing this:\n  b \\<in> A - {a}\n\ngoal (1 subgoal):\n 1. b \\<in> A &&& b \\<noteq> a", "by simp_all"], ["proof (state)\nthis:\n  b \\<in> A\n  b \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A - {a} \\<Longrightarrow> x \\<in> {..<a}", "moreover"], ["proof (state)\nthis:\n  b \\<in> A\n  b \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A - {a} \\<Longrightarrow> x \\<in> {..<a}", "from Suc.prems(2) this(1)"], ["proof (chain)\npicking this:\n  finite A\n  b \\<in> A", "have \"b \\<le> a\""], ["proof (prove)\nusing this:\n  finite A\n  b \\<in> A\n\ngoal (1 subgoal):\n 1. b \\<le> a", "unfolding a_def"], ["proof (prove)\nusing this:\n  finite A\n  b \\<in> A\n\ngoal (1 subgoal):\n 1. b \\<le> Max A", "by (rule Max_ge)"], ["proof (state)\nthis:\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A - {a} \\<Longrightarrow> x \\<in> {..<a}", "ultimately"], ["proof (chain)\npicking this:\n  b \\<in> A\n  b \\<noteq> a\n  b \\<le> a", "show \"b \\<in> {..<a}\""], ["proof (prove)\nusing this:\n  b \\<in> A\n  b \\<noteq> a\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. b \\<in> {..<a}", "by simp"], ["proof (state)\nthis:\n  b \\<in> {..<a}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A - {a} \\<subseteq> {..<a}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (insert a (A - {a}))\n\ngoal (1 subgoal):\n 1. \\<And>k A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>k = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> P A;\n        Suc k = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> P A", "with \\<open>a \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> A\n  P (insert a (A - {a}))", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> A\n  P (insert a (A - {a}))\n\ngoal (1 subgoal):\n 1. P A", "by (simp add: insert_absorb)"], ["proof (state)\nthis:\n  P A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Fract_same: \"Fract a a = (1 when a \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fraction_Field.Fract a a = (1 when a \\<noteq> (0::'a))", "by (simp add: One_fract_def Zero_fract_def eq_fract when_def)"], ["", "lemma Fract_eq_zero_iff: \"Fract a b = 0 \\<longleftrightarrow> a = 0 \\<or> b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Fraction_Field.Fract a b = 0) = (a = (0::'a) \\<or> b = (0::'a))", "by (metis (no_types, lifting) Zero_fract_def eq_fract(1) eq_fract(2) mult_eq_0_iff one_neq_zero)"], ["", "lemma poly_plus_rightE:\n  obtains c where \"poly p (x + y) = poly p x + c * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (induct p arbitrary: thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>c.\n           poly 0 (x + y) = poly 0 x + c * y \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>a p thesis.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           (\\<And>c.\n               poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>c.\n           poly (pCons a p) (x + y) =\n           poly (pCons a p) x + c * y \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case 0"], ["proof (state)\nthis:\n  poly 0 (x + y) = poly 0 x + ?c * y \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>c.\n           poly 0 (x + y) = poly 0 x + c * y \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>a p thesis.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           (\\<And>c.\n               poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>c.\n           poly (pCons a p) (x + y) =\n           poly (pCons a p) x + c * y \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"poly 0 (x + y) = poly 0 x + 0 * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly 0 (x + y) = poly 0 x + (0::'a) * y", "by simp"], ["proof (state)\nthis:\n  poly 0 (x + y) = poly 0 x + (0::'a) * y\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>c.\n           poly 0 (x + y) = poly 0 x + c * y \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>a p thesis.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           (\\<And>c.\n               poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>c.\n           poly (pCons a p) (x + y) =\n           poly (pCons a p) x + c * y \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  poly 0 (x + y) = poly 0 x + (0::'a) * y\n\ngoal (1 subgoal):\n 1. thesis", "by (rule 0)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           (\\<And>c.\n               poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>c.\n           poly (pCons a p) (x + y) =\n           poly (pCons a p) x + c * y \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           (\\<And>c.\n               poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>c.\n           poly (pCons a p) (x + y) =\n           poly (pCons a p) x + c * y \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  (\\<And>c.\n      poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n  poly (pCons a p) (x + y) = poly (pCons a p) x + ?c * y \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           (\\<And>c.\n               poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>c.\n           poly (pCons a p) (x + y) =\n           poly (pCons a p) x + c * y \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain c where \"poly p (x + y) = poly p x + c * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule pCons.hyps)"], ["proof (state)\nthis:\n  poly p (x + y) = poly p x + c * y\n\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           (\\<And>c.\n               poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>c.\n           poly (pCons a p) (x + y) =\n           poly (pCons a p) x + c * y \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"poly (pCons a p) (x + y) = a + (x + y) * (poly p x + c * y)\""], ["proof (prove)\nusing this:\n  poly p (x + y) = poly p x + c * y\n\ngoal (1 subgoal):\n 1. poly (pCons a p) (x + y) = a + (x + y) * (poly p x + c * y)", "by simp"], ["proof (state)\nthis:\n  poly (pCons a p) (x + y) = a + (x + y) * (poly p x + c * y)\n\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           (\\<And>c.\n               poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>c.\n           poly (pCons a p) (x + y) =\n           poly (pCons a p) x + c * y \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  poly (pCons a p) (x + y) = a + (x + y) * (poly p x + c * y)\n\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           (\\<And>c.\n               poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>c.\n           poly (pCons a p) (x + y) =\n           poly (pCons a p) x + c * y \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<dots> = poly (pCons a p) x + (x * c + (poly p x + c * y)) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (x + y) * (poly p x + c * y) =\n    poly (pCons a p) x + (x * c + (poly p x + c * y)) * y", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  a + (x + y) * (poly p x + c * y) =\n  poly (pCons a p) x + (x * c + (poly p x + c * y)) * y\n\ngoal (1 subgoal):\n 1. \\<And>a p thesis.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           (\\<And>c.\n               poly p (x + y) = poly p x + c * y \\<Longrightarrow>\n               thesis) \\<Longrightarrow>\n           thesis;\n        \\<And>c.\n           poly (pCons a p) (x + y) =\n           poly (pCons a p) x + c * y \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  poly (pCons a p) (x + y) =\n  poly (pCons a p) x + (x * c + (poly p x + c * y)) * y", "show ?case"], ["proof (prove)\nusing this:\n  poly (pCons a p) (x + y) =\n  poly (pCons a p) x + (x * c + (poly p x + c * y)) * y\n\ngoal (1 subgoal):\n 1. thesis", "by (rule pCons.prems)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_minus_rightE:\n  obtains c where \"poly p (x - y) = poly p x - c * (y::_::comm_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        poly p (x - y) = poly p x - c * y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis add_diff_cancel_right' diff_add_cancel poly_plus_rightE)"], ["", "lemma map_poly_plus:\n  assumes \"f 0 = 0\" and \"\\<And>a b. f (a + b) = f a + f b\"\n  shows \"map_poly f (p + q) = map_poly f p + map_poly f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (p + q) = map_poly f p + map_poly f q", "by (rule Polynomial.poly_eqI) (simp add: coeff_map_poly assms)"], ["", "lemma map_poly_minus:\n  assumes \"f 0 = 0\" and \"\\<And>a b. f (a - b) = f a - f b\"\n  shows \"map_poly f (p - q) = map_poly f p - map_poly f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (p - q) = map_poly f p - map_poly f q", "by (rule Polynomial.poly_eqI) (simp add: coeff_map_poly assms)"], ["", "lemma map_poly_sum:\n  assumes \"f 0 = 0\" and \"\\<And>a b. f (a + b) = f a + f b\"\n  shows \"map_poly f (sum g A) = (\\<Sum>a\\<in>A. map_poly f (g a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (sum g A) = (\\<Sum>a\\<in>A. map_poly f (g a))", "by (induct A rule: infinite_finite_induct) (simp_all add: map_poly_plus assms)"], ["", "lemma map_poly_times:\n  assumes \"f 0 = 0\" and \"\\<And>a b. f (a + b) = f a + f b\" and \"\\<And>a b. f (a * b) = f a * f b\"\n  shows \"map_poly f (p * q) = map_poly f p * map_poly f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (p * q) = map_poly f p * map_poly f q", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. map_poly f (0 * q) = map_poly f 0 * map_poly f q\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        map_poly f (p * q) = map_poly f p * map_poly f q\\<rbrakk>\n       \\<Longrightarrow> map_poly f (pCons a p * q) =\n                         map_poly f (pCons a p) * map_poly f q", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. map_poly f (0 * q) = map_poly f 0 * map_poly f q\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        map_poly f (p * q) = map_poly f p * map_poly f q\\<rbrakk>\n       \\<Longrightarrow> map_poly f (pCons a p * q) =\n                         map_poly f (pCons a p) * map_poly f q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (0 * q) = map_poly f 0 * map_poly f q", "by simp"], ["proof (state)\nthis:\n  map_poly f (0 * q) = map_poly f 0 * map_poly f q\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        map_poly f (p * q) = map_poly f p * map_poly f q\\<rbrakk>\n       \\<Longrightarrow> map_poly f (pCons a p * q) =\n                         map_poly f (pCons a p) * map_poly f q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        map_poly f (p * q) = map_poly f p * map_poly f q\\<rbrakk>\n       \\<Longrightarrow> map_poly f (pCons a p * q) =\n                         map_poly f (pCons a p) * map_poly f q", "case (pCons c p)"], ["proof (state)\nthis:\n  c \\<noteq> (0::'b) \\<or> p \\<noteq> 0\n  map_poly f (p * q) = map_poly f p * map_poly f q\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        map_poly f (p * q) = map_poly f p * map_poly f q\\<rbrakk>\n       \\<Longrightarrow> map_poly f (pCons a p * q) =\n                         map_poly f (pCons a p) * map_poly f q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly f (pCons c p * q) = map_poly f (pCons c p) * map_poly f q", "by (simp add: assms map_poly_plus map_poly_smult map_poly_pCons pCons)"], ["proof (state)\nthis:\n  map_poly f (pCons c p * q) = map_poly f (pCons c p) * map_poly f q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_Fract:\n  assumes \"set (Polynomial.coeffs p) \\<subseteq> range (\\<lambda>x. Fract x 1)\"\n  obtains q m where \"poly p (Fract a b) = Fract q (b ^ m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q m.\n        poly p (Fraction_Field.Fract a b) =\n        Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  set (Polynomial.coeffs p)\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>q m.\n        poly p (Fraction_Field.Fract a b) =\n        Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (induct p arbitrary: thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>q m.\n                   poly 0 (Fraction_Field.Fract a b) =\n                   Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                   thesis;\n        set (Polynomial.coeffs 0)\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa p thesis.\n       \\<lbrakk>aa \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>q m.\n                       poly p (Fraction_Field.Fract a b) =\n                       Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                       thesis;\n            set (Polynomial.coeffs p)\n            \\<subseteq> range\n                         (\\<lambda>x.\n                             Fraction_Field.Fract x (1::'a))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>q m.\n           poly (pCons aa p) (Fraction_Field.Fract a b) =\n           Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n           thesis;\n        set (Polynomial.coeffs (pCons aa p))\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis", "case 0"], ["proof (state)\nthis:\n  poly 0 (Fraction_Field.Fract a b) =\n  Fraction_Field.Fract ?q (b ^ ?m) \\<Longrightarrow>\n  thesis\n  set (Polynomial.coeffs 0)\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>q m.\n                   poly 0 (Fraction_Field.Fract a b) =\n                   Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                   thesis;\n        set (Polynomial.coeffs 0)\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa p thesis.\n       \\<lbrakk>aa \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>q m.\n                       poly p (Fraction_Field.Fract a b) =\n                       Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                       thesis;\n            set (Polynomial.coeffs p)\n            \\<subseteq> range\n                         (\\<lambda>x.\n                             Fraction_Field.Fract x (1::'a))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>q m.\n           poly (pCons aa p) (Fraction_Field.Fract a b) =\n           Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n           thesis;\n        set (Polynomial.coeffs (pCons aa p))\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"poly 0 (Fract a b) = Fract 0 (b ^ 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly 0 (Fraction_Field.Fract a b) = Fraction_Field.Fract (0::'a) (b ^ 1)", "by (simp add: fract_collapse)"], ["proof (state)\nthis:\n  poly 0 (Fraction_Field.Fract a b) = Fraction_Field.Fract (0::'a) (b ^ 1)\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>q m.\n                   poly 0 (Fraction_Field.Fract a b) =\n                   Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                   thesis;\n        set (Polynomial.coeffs 0)\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa p thesis.\n       \\<lbrakk>aa \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>q m.\n                       poly p (Fraction_Field.Fract a b) =\n                       Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                       thesis;\n            set (Polynomial.coeffs p)\n            \\<subseteq> range\n                         (\\<lambda>x.\n                             Fraction_Field.Fract x (1::'a))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>q m.\n           poly (pCons aa p) (Fraction_Field.Fract a b) =\n           Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n           thesis;\n        set (Polynomial.coeffs (pCons aa p))\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  poly 0 (Fraction_Field.Fract a b) = Fraction_Field.Fract (0::'a) (b ^ 1)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule 0)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>aa p thesis.\n       \\<lbrakk>aa \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>q m.\n                       poly p (Fraction_Field.Fract a b) =\n                       Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                       thesis;\n            set (Polynomial.coeffs p)\n            \\<subseteq> range\n                         (\\<lambda>x.\n                             Fraction_Field.Fract x (1::'a))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>q m.\n           poly (pCons aa p) (Fraction_Field.Fract a b) =\n           Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n           thesis;\n        set (Polynomial.coeffs (pCons aa p))\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa p thesis.\n       \\<lbrakk>aa \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>q m.\n                       poly p (Fraction_Field.Fract a b) =\n                       Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                       thesis;\n            set (Polynomial.coeffs p)\n            \\<subseteq> range\n                         (\\<lambda>x.\n                             Fraction_Field.Fract x (1::'a))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>q m.\n           poly (pCons aa p) (Fraction_Field.Fract a b) =\n           Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n           thesis;\n        set (Polynomial.coeffs (pCons aa p))\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (pCons c p)"], ["proof (state)\nthis:\n  c \\<noteq> 0 \\<or> p \\<noteq> 0\n  \\<lbrakk>\\<And>q m.\n              poly p (Fraction_Field.Fract a b) =\n              Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n              ?thesis;\n   set (Polynomial.coeffs p)\n   \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  poly (pCons c p) (Fraction_Field.Fract a b) =\n  Fraction_Field.Fract ?q (b ^ ?m) \\<Longrightarrow>\n  thesis\n  set (Polynomial.coeffs (pCons c p))\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\n\ngoal (1 subgoal):\n 1. \\<And>aa p thesis.\n       \\<lbrakk>aa \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>q m.\n                       poly p (Fraction_Field.Fract a b) =\n                       Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                       thesis;\n            set (Polynomial.coeffs p)\n            \\<subseteq> range\n                         (\\<lambda>x.\n                             Fraction_Field.Fract x (1::'a))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>q m.\n           poly (pCons aa p) (Fraction_Field.Fract a b) =\n           Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n           thesis;\n        set (Polynomial.coeffs (pCons aa p))\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis", "from pCons.hyps(1)"], ["proof (chain)\npicking this:\n  c \\<noteq> 0 \\<or> p \\<noteq> 0", "have \"insert c (set (Polynomial.coeffs p)) = set (Polynomial.coeffs (pCons c p))\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<or> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. insert c (set (Polynomial.coeffs p)) =\n    set (Polynomial.coeffs (pCons c p))", "by auto"], ["proof (state)\nthis:\n  insert c (set (Polynomial.coeffs p)) = set (Polynomial.coeffs (pCons c p))\n\ngoal (1 subgoal):\n 1. \\<And>aa p thesis.\n       \\<lbrakk>aa \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>q m.\n                       poly p (Fraction_Field.Fract a b) =\n                       Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                       thesis;\n            set (Polynomial.coeffs p)\n            \\<subseteq> range\n                         (\\<lambda>x.\n                             Fraction_Field.Fract x (1::'a))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>q m.\n           poly (pCons aa p) (Fraction_Field.Fract a b) =\n           Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n           thesis;\n        set (Polynomial.coeffs (pCons aa p))\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis", "with pCons.prems(2)"], ["proof (chain)\npicking this:\n  set (Polynomial.coeffs (pCons c p))\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\n  insert c (set (Polynomial.coeffs p)) = set (Polynomial.coeffs (pCons c p))", "have \"c \\<in> range (\\<lambda>x. Fract x 1)\" and \"set (Polynomial.coeffs p) \\<subseteq> range (\\<lambda>x. Fract x 1)\""], ["proof (prove)\nusing this:\n  set (Polynomial.coeffs (pCons c p))\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\n  insert c (set (Polynomial.coeffs p)) = set (Polynomial.coeffs (pCons c p))\n\ngoal (1 subgoal):\n 1. c \\<in> range (\\<lambda>x. Fraction_Field.Fract x (1::'a)) &&&\n    set (Polynomial.coeffs p)\n    \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))", "by blast+"], ["proof (state)\nthis:\n  c \\<in> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\n  set (Polynomial.coeffs p)\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\n\ngoal (1 subgoal):\n 1. \\<And>aa p thesis.\n       \\<lbrakk>aa \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>q m.\n                       poly p (Fraction_Field.Fract a b) =\n                       Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                       thesis;\n            set (Polynomial.coeffs p)\n            \\<subseteq> range\n                         (\\<lambda>x.\n                             Fraction_Field.Fract x (1::'a))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>q m.\n           poly (pCons aa p) (Fraction_Field.Fract a b) =\n           Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n           thesis;\n        set (Polynomial.coeffs (pCons aa p))\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis", "from this(2)"], ["proof (chain)\npicking this:\n  set (Polynomial.coeffs p)\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))", "obtain q0 m0 where poly_p: \"poly p (Fract a b) = Fract q0 (b ^ m0)\""], ["proof (prove)\nusing this:\n  set (Polynomial.coeffs p)\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>q0 m0.\n        poly p (Fraction_Field.Fract a b) =\n        Fraction_Field.Fract q0 (b ^ m0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pCons.hyps(2)"], ["proof (prove)\nusing this:\n  set (Polynomial.coeffs p)\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\n  \\<lbrakk>\\<And>q m.\n              poly p (Fraction_Field.Fract a b) =\n              Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n              ?thesis;\n   set (Polynomial.coeffs p)\n   \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q0 m0.\n        poly p (Fraction_Field.Fract a b) =\n        Fraction_Field.Fract q0 (b ^ m0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  poly p (Fraction_Field.Fract a b) = Fraction_Field.Fract q0 (b ^ m0)\n\ngoal (1 subgoal):\n 1. \\<And>aa p thesis.\n       \\<lbrakk>aa \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>q m.\n                       poly p (Fraction_Field.Fract a b) =\n                       Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                       thesis;\n            set (Polynomial.coeffs p)\n            \\<subseteq> range\n                         (\\<lambda>x.\n                             Fraction_Field.Fract x (1::'a))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>q m.\n           poly (pCons aa p) (Fraction_Field.Fract a b) =\n           Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n           thesis;\n        set (Polynomial.coeffs (pCons aa p))\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis", "from \\<open>c \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))", "obtain c0 where c: \"c = Fract c0 1\""], ["proof (prove)\nusing this:\n  c \\<in> range (\\<lambda>x. Fraction_Field.Fract x (1::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>c0.\n        c = Fraction_Field.Fract c0 (1::'a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  c = Fraction_Field.Fract c0 (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>aa p thesis.\n       \\<lbrakk>aa \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>q m.\n                       poly p (Fraction_Field.Fract a b) =\n                       Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n                       thesis;\n            set (Polynomial.coeffs p)\n            \\<subseteq> range\n                         (\\<lambda>x.\n                             Fraction_Field.Fract x (1::'a))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>q m.\n           poly (pCons aa p) (Fraction_Field.Fract a b) =\n           Fraction_Field.Fract q (b ^ m) \\<Longrightarrow>\n           thesis;\n        set (Polynomial.coeffs (pCons aa p))\n        \\<subseteq> range\n                     (\\<lambda>x. Fraction_Field.Fract x (1::'a))\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow> thesis\n 2. b \\<noteq> (0::'a) \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  b = (0::'a)\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow> thesis\n 2. b \\<noteq> (0::'a) \\<Longrightarrow> thesis", "hence \"poly (pCons c p) (Fract a b) = Fract c0 (b ^ 0)\""], ["proof (prove)\nusing this:\n  b = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (pCons c p) (Fraction_Field.Fract a b) =\n    Fraction_Field.Fract c0 (b ^ 0)", "by (simp add: c fract_collapse)"], ["proof (state)\nthis:\n  poly (pCons c p) (Fraction_Field.Fract a b) =\n  Fraction_Field.Fract c0 (b ^ 0)\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow> thesis\n 2. b \\<noteq> (0::'a) \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly (pCons c p) (Fraction_Field.Fract a b) =\n  Fraction_Field.Fract c0 (b ^ 0)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule pCons.prems)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> thesis", "hence \"poly (pCons c p) (Fract a b) = Fract (c0 * b ^ Suc m0 + a * q0) (b ^ Suc m0)\""], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly (pCons c p) (Fraction_Field.Fract a b) =\n    Fraction_Field.Fract (c0 * b ^ Suc m0 + a * q0) (b ^ Suc m0)", "by (simp add: poly_p c)"], ["proof (state)\nthis:\n  poly (pCons c p) (Fraction_Field.Fract a b) =\n  Fraction_Field.Fract (c0 * b ^ Suc m0 + a * q0) (b ^ Suc m0)\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly (pCons c p) (Fraction_Field.Fract a b) =\n  Fraction_Field.Fract (c0 * b ^ Suc m0 + a * q0) (b ^ Suc m0)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule pCons.prems)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in ordered_term) lt_sum_le_Max: \"lt (sum f A) \\<preceq>\\<^sub>t ord_term_lin.Max {lt (f a) | a. a \\<in> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (sum f A) \\<preceq>\\<^sub>t ord_term_lin.Max {lt (f a) |a. a \\<in> A}", "proof (induct A rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       lt (sum f A) \\<preceq>\\<^sub>t\n       ord_term_lin.Max {lt (f a) |a. a \\<in> A}\n 2. lt (sum f {}) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f a) |a. a \\<in> {}}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        lt (sum f F) \\<preceq>\\<^sub>t\n        ord_term_lin.Max {lt (f a) |a. a \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> lt (sum f (insert x F)) \\<preceq>\\<^sub>t\n                         ord_term_lin.Max {lt (f a) |a. a \\<in> insert x F}", "case (infinite A)"], ["proof (state)\nthis:\n  infinite A\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       lt (sum f A) \\<preceq>\\<^sub>t\n       ord_term_lin.Max {lt (f a) |a. a \\<in> A}\n 2. lt (sum f {}) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f a) |a. a \\<in> {}}\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        lt (sum f F) \\<preceq>\\<^sub>t\n        ord_term_lin.Max {lt (f a) |a. a \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> lt (sum f (insert x F)) \\<preceq>\\<^sub>t\n                         ord_term_lin.Max {lt (f a) |a. a \\<in> insert x F}", "thus ?case"], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. lt (sum f A) \\<preceq>\\<^sub>t ord_term_lin.Max {lt (f a) |a. a \\<in> A}", "by (simp add: min_term_min)"], ["proof (state)\nthis:\n  lt (sum f A) \\<preceq>\\<^sub>t ord_term_lin.Max {lt (f a) |a. a \\<in> A}\n\ngoal (2 subgoals):\n 1. lt (sum f {}) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f a) |a. a \\<in> {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        lt (sum f F) \\<preceq>\\<^sub>t\n        ord_term_lin.Max {lt (f a) |a. a \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> lt (sum f (insert x F)) \\<preceq>\\<^sub>t\n                         ord_term_lin.Max {lt (f a) |a. a \\<in> insert x F}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. lt (sum f {}) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f a) |a. a \\<in> {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        lt (sum f F) \\<preceq>\\<^sub>t\n        ord_term_lin.Max {lt (f a) |a. a \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> lt (sum f (insert x F)) \\<preceq>\\<^sub>t\n                         ord_term_lin.Max {lt (f a) |a. a \\<in> insert x F}", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lt (sum f {}) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f a) |a. a \\<in> {}}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        lt (sum f F) \\<preceq>\\<^sub>t\n        ord_term_lin.Max {lt (f a) |a. a \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> lt (sum f (insert x F)) \\<preceq>\\<^sub>t\n                         ord_term_lin.Max {lt (f a) |a. a \\<in> insert x F}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (sum f {}) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f a) |a. a \\<in> {}}", "by (simp add: min_term_min)"], ["proof (state)\nthis:\n  lt (sum f {}) \\<preceq>\\<^sub>t ord_term_lin.Max {lt (f a) |a. a \\<in> {}}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        lt (sum f F) \\<preceq>\\<^sub>t\n        ord_term_lin.Max {lt (f a) |a. a \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> lt (sum f (insert x F)) \\<preceq>\\<^sub>t\n                         ord_term_lin.Max {lt (f a) |a. a \\<in> insert x F}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        lt (sum f F) \\<preceq>\\<^sub>t\n        ord_term_lin.Max {lt (f a) |a. a \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> lt (sum f (insert x F)) \\<preceq>\\<^sub>t\n                         ord_term_lin.Max {lt (f a) |a. a \\<in> insert x F}", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  lt (sum f A) \\<preceq>\\<^sub>t ord_term_lin.Max {lt (f a) |a. a \\<in> A}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        lt (sum f F) \\<preceq>\\<^sub>t\n        ord_term_lin.Max {lt (f a) |a. a \\<in> F}\\<rbrakk>\n       \\<Longrightarrow> lt (sum f (insert x F)) \\<preceq>\\<^sub>t\n                         ord_term_lin.Max {lt (f a) |a. a \\<in> insert x F}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "proof (cases \"A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}\n 2. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "case True"], ["proof (state)\nthis:\n  A = {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}\n 2. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "thus ?thesis"], ["proof (prove)\nusing this:\n  A = {}\n\ngoal (1 subgoal):\n 1. lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "by simp"], ["proof (state)\nthis:\n  lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n  ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "case False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "from insert.hyps(1, 2)"], ["proof (chain)\npicking this:\n  finite A\n  a \\<notin> A", "have \"lt (sum f (insert a A)) = lt (f a + sum f A)\""], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n\ngoal (1 subgoal):\n 1. lt (sum f (insert a A)) = lt (f a + sum f A)", "by simp"], ["proof (state)\nthis:\n  lt (sum f (insert a A)) = lt (f a + sum f A)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "also"], ["proof (state)\nthis:\n  lt (sum f (insert a A)) = lt (f a + sum f A)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "have \"\\<dots> \\<preceq>\\<^sub>t ord_term_lin.max (lt (f a)) (lt (sum f A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (f a + sum f A) \\<preceq>\\<^sub>t\n    ord_term_lin.max (lt (f a)) (lt (sum f A))", "by (rule lt_plus_le_max)"], ["proof (state)\nthis:\n  lt (f a + sum f A) \\<preceq>\\<^sub>t\n  ord_term_lin.max (lt (f a)) (lt (sum f A))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "also"], ["proof (state)\nthis:\n  lt (f a + sum f A) \\<preceq>\\<^sub>t\n  ord_term_lin.max (lt (f a)) (lt (sum f A))\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "have \"\\<dots> \\<preceq>\\<^sub>t ord_term_lin.max (lt (f a)) (ord_term_lin.Max {lt (f a) |a. a \\<in> A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_term_lin.max (lt (f a)) (lt (sum f A)) \\<preceq>\\<^sub>t\n    ord_term_lin.max (lt (f a)) (ord_term_lin.Max {lt (f a) |a. a \\<in> A})", "using insert.hyps(3) ord_term_lin.max.mono"], ["proof (prove)\nusing this:\n  lt (sum f A) \\<preceq>\\<^sub>t ord_term_lin.Max {lt (f a) |a. a \\<in> A}\n  \\<lbrakk>?c \\<preceq>\\<^sub>t ?a; ?d \\<preceq>\\<^sub>t ?b\\<rbrakk>\n  \\<Longrightarrow> ord_term_lin.max ?c ?d \\<preceq>\\<^sub>t\n                    ord_term_lin.max ?a ?b\n\ngoal (1 subgoal):\n 1. ord_term_lin.max (lt (f a)) (lt (sum f A)) \\<preceq>\\<^sub>t\n    ord_term_lin.max (lt (f a)) (ord_term_lin.Max {lt (f a) |a. a \\<in> A})", "by blast"], ["proof (state)\nthis:\n  ord_term_lin.max (lt (f a)) (lt (sum f A)) \\<preceq>\\<^sub>t\n  ord_term_lin.max (lt (f a)) (ord_term_lin.Max {lt (f a) |a. a \\<in> A})\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "also"], ["proof (state)\nthis:\n  ord_term_lin.max (lt (f a)) (lt (sum f A)) \\<preceq>\\<^sub>t\n  ord_term_lin.max (lt (f a)) (ord_term_lin.Max {lt (f a) |a. a \\<in> A})\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "from insert.hyps(1) False"], ["proof (chain)\npicking this:\n  finite A\n  A \\<noteq> {}", "have \"\\<dots> = ord_term_lin.Max (insert (lt (f a)) {lt (f x) |x. x \\<in> A})\""], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ord_term_lin.max (lt (f a))\n     (ord_term_lin.Max {lt (f a) |a. a \\<in> A}) =\n    ord_term_lin.Max (insert (lt (f a)) {lt (f x) |x. x \\<in> A})", "by simp"], ["proof (state)\nthis:\n  ord_term_lin.max (lt (f a)) (ord_term_lin.Max {lt (f a) |a. a \\<in> A}) =\n  ord_term_lin.Max (insert (lt (f a)) {lt (f x) |x. x \\<in> A})\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "also"], ["proof (state)\nthis:\n  ord_term_lin.max (lt (f a)) (ord_term_lin.Max {lt (f a) |a. a \\<in> A}) =\n  ord_term_lin.Max (insert (lt (f a)) {lt (f x) |x. x \\<in> A})\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "have \"\\<dots> = ord_term_lin.Max {lt (f x) |x. x \\<in> insert a A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_term_lin.Max (insert (lt (f a)) {lt (f x) |x. x \\<in> A}) =\n    ord_term_lin.Max {lt (f x) |x. x \\<in> insert a A}", "by (rule arg_cong[where f=ord_term_lin.Max]) blast"], ["proof (state)\nthis:\n  ord_term_lin.Max (insert (lt (f a)) {lt (f x) |x. x \\<in> A}) =\n  ord_term_lin.Max {lt (f x) |x. x \\<in> insert a A}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "finally"], ["proof (chain)\npicking this:\n  lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n  ord_term_lin.Max {lt (f x) |x. x \\<in> insert a A}", "show ?thesis"], ["proof (prove)\nusing this:\n  lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n  ord_term_lin.Max {lt (f x) |x. x \\<in> insert a A}\n\ngoal (1 subgoal):\n 1. lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n    ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}", "."], ["proof (state)\nthis:\n  lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n  ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt (sum f (insert a A)) \\<preceq>\\<^sub>t\n  ord_term_lin.Max {lt (f aa) |aa. aa \\<in> insert a A}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Ideals and Varieties\\<close>"], ["", "definition variety_of :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) set \\<Rightarrow> ('x \\<Rightarrow> 'a::comm_semiring_1) set\"\n  where \"variety_of F = {a. \\<forall>f\\<in>F. poly_eval a f = 0}\""], ["", "definition ideal_of :: \"('x \\<Rightarrow> 'a::comm_semiring_1) set \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) set\"\n  where \"ideal_of A = {f. \\<forall>a\\<in>A. poly_eval a f = 0}\""], ["", "abbreviation \"\\<V> \\<equiv> variety_of\""], ["", "abbreviation \"\\<I> \\<equiv> ideal_of\""], ["", "lemma variety_ofI: \"(\\<And>f. f \\<in> F \\<Longrightarrow> poly_eval a f = 0) \\<Longrightarrow> a \\<in> \\<V> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        f \\<in> F \\<Longrightarrow>\n        poly_eval a f = (0::'b)) \\<Longrightarrow>\n    a \\<in> \\<V> F", "by (simp add: variety_of_def)"], ["", "lemma variety_ofI_alt: \"poly_eval a ` F \\<subseteq> {0} \\<Longrightarrow> a \\<in> \\<V> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a ` F \\<subseteq> {0::'a} \\<Longrightarrow> a \\<in> \\<V> F", "by (auto intro: variety_ofI)"], ["", "lemma variety_ofD: \"a \\<in> \\<V> F \\<Longrightarrow> f \\<in> F \\<Longrightarrow> poly_eval a f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> \\<V> F; f \\<in> F\\<rbrakk>\n    \\<Longrightarrow> poly_eval a f = (0::'b)", "by (simp add: variety_of_def)"], ["", "lemma variety_of_empty [simp]: \"\\<V> {} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> {} = UNIV", "by (simp add: variety_of_def)"], ["", "lemma variety_of_UNIV [simp]: \"\\<V> UNIV = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> UNIV = {}", "by (metis (mono_tags, lifting) Collect_empty_eq UNIV_I one_neq_zero poly_eval_one variety_of_def)"], ["", "lemma variety_of_antimono: \"F \\<subseteq> G \\<Longrightarrow> \\<V> G \\<subseteq> \\<V> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> G \\<Longrightarrow> \\<V> G \\<subseteq> \\<V> F", "by (auto simp: variety_of_def)"], ["", "lemma variety_of_ideal [simp]: \"\\<V> (ideal F) = \\<V> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> (ideal F) = \\<V> F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<V> (ideal F) \\<subseteq> \\<V> F\n 2. \\<V> F \\<subseteq> \\<V> (ideal F)", "show \"\\<V> (ideal F) \\<subseteq> \\<V> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> (ideal F) \\<subseteq> \\<V> F", "by (intro variety_of_antimono ideal.span_superset)"], ["proof (state)\nthis:\n  \\<V> (ideal F) \\<subseteq> \\<V> F\n\ngoal (1 subgoal):\n 1. \\<V> F \\<subseteq> \\<V> (ideal F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<V> F \\<subseteq> \\<V> (ideal F)", "show \"\\<V> F \\<subseteq> \\<V> (ideal F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> F \\<subseteq> \\<V> (ideal F)", "proof (intro subsetI variety_ofI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>x \\<in> \\<V> F; f \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> poly_eval x f = (0::'b)", "fix a f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>x \\<in> \\<V> F; f \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> poly_eval x f = (0::'b)", "assume \"a \\<in> \\<V> F\" and \"f \\<in> ideal F\""], ["proof (state)\nthis:\n  a \\<in> \\<V> F\n  f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>x \\<in> \\<V> F; f \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> poly_eval x f = (0::'b)", "from this(2)"], ["proof (chain)\npicking this:\n  f \\<in> ideal F", "show \"poly_eval a f = 0\""], ["proof (prove)\nusing this:\n  f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. poly_eval a f = (0::'b)", "proof (induct f rule: ideal.span_induct_alt)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_eval a 0 = (0::'b)\n 2. \\<And>c x y.\n       \\<lbrakk>x \\<in> F; poly_eval a y = (0::'b)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a (c * x + y) = (0::'b)", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. poly_eval a 0 = (0::'b)\n 2. \\<And>c x y.\n       \\<lbrakk>x \\<in> F; poly_eval a y = (0::'b)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a (c * x + y) = (0::'b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a 0 = (0::'b)", "by simp"], ["proof (state)\nthis:\n  poly_eval a 0 = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>x \\<in> F; poly_eval a y = (0::'b)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a (c * x + y) = (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>x \\<in> F; poly_eval a y = (0::'b)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a (c * x + y) = (0::'b)", "case (step c f g)"], ["proof (state)\nthis:\n  f \\<in> F\n  poly_eval a g = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>x \\<in> F; poly_eval a y = (0::'b)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a (c * x + y) = (0::'b)", "with \\<open>a \\<in> \\<V> F\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> \\<V> F\n  f \\<in> F\n  poly_eval a g = (0::'b)", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> \\<V> F\n  f \\<in> F\n  poly_eval a g = (0::'b)\n\ngoal (1 subgoal):\n 1. poly_eval a (c * f + g) = (0::'b)", "by (auto simp: poly_eval_plus poly_eval_times dest: variety_ofD)"], ["proof (state)\nthis:\n  poly_eval a (c * f + g) = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_eval a f = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<V> F \\<subseteq> \\<V> (ideal F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ideal_ofI: \"(\\<And>a. a \\<in> A \\<Longrightarrow> poly_eval a f = 0) \\<Longrightarrow> f \\<in> \\<I> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a \\<in> A \\<Longrightarrow>\n        poly_eval a f = (0::'b)) \\<Longrightarrow>\n    f \\<in> \\<I> A", "by (simp add: ideal_of_def)"], ["", "lemma ideal_ofD: \"f \\<in> \\<I> A \\<Longrightarrow> a \\<in> A \\<Longrightarrow> poly_eval a f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> \\<I> A; a \\<in> A\\<rbrakk>\n    \\<Longrightarrow> poly_eval a f = (0::'b)", "by (simp add: ideal_of_def)"], ["", "lemma ideal_of_empty [simp]: \"\\<I> {} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> {} = UNIV", "by (simp add: ideal_of_def)"], ["", "lemma ideal_of_antimono: \"A \\<subseteq> B \\<Longrightarrow> \\<I> B \\<subseteq> \\<I> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B \\<Longrightarrow> \\<I> B \\<subseteq> \\<I> A", "by (auto simp: ideal_of_def)"], ["", "lemma ideal_ideal_of [simp]: \"ideal (\\<I> A) = \\<I> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (\\<I> A) = \\<I> A", "unfolding ideal.span_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal.subspace (\\<I> A)", "proof (rule ideal.subspaceI)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<in> \\<I> A\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<I> A; y \\<in> \\<I> A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<I> A\n 3. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "show \"0 \\<in> \\<I> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> \\<I> A", "by (rule ideal_ofI) simp"], ["proof (state)\nthis:\n  0 \\<in> \\<I> A\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<I> A; y \\<in> \\<I> A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<I> A\n 2. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<I> A; y \\<in> \\<I> A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<I> A\n 2. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "fix f g"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<I> A; y \\<in> \\<I> A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<I> A\n 2. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "assume \"f \\<in> \\<I> A\""], ["proof (state)\nthis:\n  f \\<in> \\<I> A\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<I> A; y \\<in> \\<I> A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<I> A\n 2. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "hence f: \"poly_eval a f = 0\" if \"a \\<in> A\" for a"], ["proof (prove)\nusing this:\n  f \\<in> \\<I> A\n\ngoal (1 subgoal):\n 1. poly_eval a f = (0::'b)", "using that"], ["proof (prove)\nusing this:\n  f \\<in> \\<I> A\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. poly_eval a f = (0::'b)", "by (rule ideal_ofD)"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Longrightarrow> poly_eval ?a f = (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<I> A; y \\<in> \\<I> A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<I> A\n 2. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "assume \"g \\<in> \\<I> A\""], ["proof (state)\nthis:\n  g \\<in> \\<I> A\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<I> A; y \\<in> \\<I> A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<I> A\n 2. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "hence g: \"poly_eval a g = 0\" if \"a \\<in> A\" for a"], ["proof (prove)\nusing this:\n  g \\<in> \\<I> A\n\ngoal (1 subgoal):\n 1. poly_eval a g = (0::'b)", "using that"], ["proof (prove)\nusing this:\n  g \\<in> \\<I> A\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. poly_eval a g = (0::'b)", "by (rule ideal_ofD)"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Longrightarrow> poly_eval ?a g = (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<I> A; y \\<in> \\<I> A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<I> A\n 2. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "show \"f + g \\<in> \\<I> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f + g \\<in> \\<I> A", "by (rule ideal_ofI) (simp add: poly_eval_plus f g)"], ["proof (state)\nthis:\n  f + g \\<in> \\<I> A\n\ngoal (1 subgoal):\n 1. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "fix c f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "assume \"f \\<in> \\<I> A\""], ["proof (state)\nthis:\n  f \\<in> \\<I> A\n\ngoal (1 subgoal):\n 1. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "hence f: \"poly_eval a f = 0\" if \"a \\<in> A\" for a"], ["proof (prove)\nusing this:\n  f \\<in> \\<I> A\n\ngoal (1 subgoal):\n 1. poly_eval a f = (0::'b)", "using that"], ["proof (prove)\nusing this:\n  f \\<in> \\<I> A\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. poly_eval a f = (0::'b)", "by (rule ideal_ofD)"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Longrightarrow> poly_eval ?a f = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>c x. x \\<in> \\<I> A \\<Longrightarrow> c * x \\<in> \\<I> A", "show \"c * f \\<in> \\<I> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * f \\<in> \\<I> A", "by (rule ideal_ofI) (simp add: poly_eval_times f)"], ["proof (state)\nthis:\n  c * f \\<in> \\<I> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ideal_of_UN: \"\\<I> (\\<Union> (A ` J)) = (\\<Inter>j\\<in>J. \\<I> (A j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> (\\<Union> (A ` J)) = (\\<Inter>j\\<in>J. \\<I> (A j))", "proof (intro set_eqI iffI ideal_ofI INT_I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x j a.\n       \\<lbrakk>x \\<in> \\<I> (\\<Union> (A ` J)); j \\<in> J;\n        a \\<in> A j\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)\n 2. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "fix p j a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x j a.\n       \\<lbrakk>x \\<in> \\<I> (\\<Union> (A ` J)); j \\<in> J;\n        a \\<in> A j\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)\n 2. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "assume \"p \\<in> \\<I> (\\<Union> (A ` J))\""], ["proof (state)\nthis:\n  p \\<in> \\<I> (\\<Union> (A ` J))\n\ngoal (2 subgoals):\n 1. \\<And>x j a.\n       \\<lbrakk>x \\<in> \\<I> (\\<Union> (A ` J)); j \\<in> J;\n        a \\<in> A j\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)\n 2. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "assume \"j \\<in> J\" and \"a \\<in> A j\""], ["proof (state)\nthis:\n  j \\<in> J\n  a \\<in> A j\n\ngoal (2 subgoals):\n 1. \\<And>x j a.\n       \\<lbrakk>x \\<in> \\<I> (\\<Union> (A ` J)); j \\<in> J;\n        a \\<in> A j\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)\n 2. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "hence \"a \\<in> \\<Union> (A ` J)\""], ["proof (prove)\nusing this:\n  j \\<in> J\n  a \\<in> A j\n\ngoal (1 subgoal):\n 1. a \\<in> \\<Union> (A ` J)", ".."], ["proof (state)\nthis:\n  a \\<in> \\<Union> (A ` J)\n\ngoal (2 subgoals):\n 1. \\<And>x j a.\n       \\<lbrakk>x \\<in> \\<I> (\\<Union> (A ` J)); j \\<in> J;\n        a \\<in> A j\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)\n 2. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "with \\<open>p \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> \\<I> (\\<Union> (A ` J))\n  a \\<in> \\<Union> (A ` J)", "show \"poly_eval a p = 0\""], ["proof (prove)\nusing this:\n  p \\<in> \\<I> (\\<Union> (A ` J))\n  a \\<in> \\<Union> (A ` J)\n\ngoal (1 subgoal):\n 1. poly_eval a p = (0::'b)", "by (rule ideal_ofD)"], ["proof (state)\nthis:\n  poly_eval a p = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "fix p a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "assume \"a \\<in> \\<Union> (A ` J)\""], ["proof (state)\nthis:\n  a \\<in> \\<Union> (A ` J)\n\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "then"], ["proof (chain)\npicking this:\n  a \\<in> \\<Union> (A ` J)", "obtain j where \"j \\<in> J\" and \"a \\<in> A j\""], ["proof (prove)\nusing this:\n  a \\<in> \\<Union> (A ` J)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> J; a \\<in> A j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  j \\<in> J\n  a \\<in> A j\n\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "assume \"p \\<in> (\\<Inter>j\\<in>J. \\<I> (A j))\""], ["proof (state)\nthis:\n  p \\<in> (\\<Inter>j\\<in>J. \\<I> (A j))\n\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "hence \"p \\<in> \\<I> (A j)\""], ["proof (prove)\nusing this:\n  p \\<in> (\\<Inter>j\\<in>J. \\<I> (A j))\n\ngoal (1 subgoal):\n 1. p \\<in> \\<I> (A j)", "using \\<open>j \\<in> J\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> (\\<Inter>j\\<in>J. \\<I> (A j))\n  j \\<in> J\n\ngoal (1 subgoal):\n 1. p \\<in> \\<I> (A j)", ".."], ["proof (state)\nthis:\n  p \\<in> \\<I> (A j)\n\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>x \\<in> (\\<Inter>j\\<in>J. \\<I> (A j));\n        a \\<in> \\<Union> (A ` J)\\<rbrakk>\n       \\<Longrightarrow> poly_eval a x = (0::'b)", "thus \"poly_eval a p = 0\""], ["proof (prove)\nusing this:\n  p \\<in> \\<I> (A j)\n\ngoal (1 subgoal):\n 1. poly_eval a p = (0::'b)", "using \\<open>a \\<in> A j\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> \\<I> (A j)\n  a \\<in> A j\n\ngoal (1 subgoal):\n 1. poly_eval a p = (0::'b)", "by (rule ideal_ofD)"], ["proof (state)\nthis:\n  poly_eval a p = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary ideal_of_Un: \"\\<I> (A \\<union> B) = \\<I> A \\<inter> \\<I> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> (A \\<union> B) = \\<I> A \\<inter> \\<I> B", "using ideal_of_UN[of id \"{A, B}\"]"], ["proof (prove)\nusing this:\n  \\<I> (\\<Union> (id ` {A, B})) = (\\<Inter>j\\<in>{A, B}. \\<I> (id j))\n\ngoal (1 subgoal):\n 1. \\<I> (A \\<union> B) = \\<I> A \\<inter> \\<I> B", "by simp"], ["", "lemma variety_of_ideal_of_variety [simp]: \"\\<V> (\\<I> (\\<V> F)) = \\<V> F\" (is \"_ = ?V\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> (\\<I> (\\<V> F)) = \\<V> F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<V> (\\<I> (\\<V> F)) \\<subseteq> \\<V> F\n 2. \\<V> F \\<subseteq> \\<V> (\\<I> (\\<V> F))", "have \"F \\<subseteq> \\<I> (\\<V> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> \\<I> (\\<V> F)", "by (auto intro!: ideal_ofI dest: variety_ofD)"], ["proof (state)\nthis:\n  F \\<subseteq> \\<I> (\\<V> F)\n\ngoal (2 subgoals):\n 1. \\<V> (\\<I> (\\<V> F)) \\<subseteq> \\<V> F\n 2. \\<V> F \\<subseteq> \\<V> (\\<I> (\\<V> F))", "thus \"\\<V> (\\<I> ?V) \\<subseteq> ?V\""], ["proof (prove)\nusing this:\n  F \\<subseteq> \\<I> (\\<V> F)\n\ngoal (1 subgoal):\n 1. \\<V> (\\<I> (\\<V> F)) \\<subseteq> \\<V> F", "by (rule variety_of_antimono)"], ["proof (state)\nthis:\n  \\<V> (\\<I> (\\<V> F)) \\<subseteq> \\<V> F\n\ngoal (1 subgoal):\n 1. \\<V> F \\<subseteq> \\<V> (\\<I> (\\<V> F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<V> F \\<subseteq> \\<V> (\\<I> (\\<V> F))", "show \"?V \\<subseteq> \\<V> (\\<I> ?V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> F \\<subseteq> \\<V> (\\<I> (\\<V> F))", "by (auto intro!: variety_ofI dest: ideal_ofD)"], ["proof (state)\nthis:\n  \\<V> F \\<subseteq> \\<V> (\\<I> (\\<V> F))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ideal_of_inj_on: \"inj_on \\<I> (range (\\<V>::(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1) set \\<Rightarrow> _))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<I> (range \\<V>)", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<V>; y \\<in> range \\<V>;\n        \\<I> x = \\<I> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix A B :: \"('x \\<Rightarrow> 'a) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<V>; y \\<in> range \\<V>;\n        \\<I> x = \\<I> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"A \\<in> range \\<V>\""], ["proof (state)\nthis:\n  A \\<in> range \\<V>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<V>; y \\<in> range \\<V>;\n        \\<I> x = \\<I> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  A \\<in> range \\<V>", "obtain F where A: \"A = \\<V> F\""], ["proof (prove)\nusing this:\n  A \\<in> range \\<V>\n\ngoal (1 subgoal):\n 1. (\\<And>F. A = \\<V> F \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  A = \\<V> F\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<V>; y \\<in> range \\<V>;\n        \\<I> x = \\<I> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"B \\<in> range \\<V>\""], ["proof (state)\nthis:\n  B \\<in> range \\<V>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<V>; y \\<in> range \\<V>;\n        \\<I> x = \\<I> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  B \\<in> range \\<V>", "obtain G where B: \"B = \\<V> G\""], ["proof (prove)\nusing this:\n  B \\<in> range \\<V>\n\ngoal (1 subgoal):\n 1. (\\<And>G. B = \\<V> G \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  B = \\<V> G\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<V>; y \\<in> range \\<V>;\n        \\<I> x = \\<I> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"\\<I> A = \\<I> B\""], ["proof (state)\nthis:\n  \\<I> A = \\<I> B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<V>; y \\<in> range \\<V>;\n        \\<I> x = \\<I> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"\\<V> (\\<I> A) = \\<V> (\\<I> B)\""], ["proof (prove)\nusing this:\n  \\<I> A = \\<I> B\n\ngoal (1 subgoal):\n 1. \\<V> (\\<I> A) = \\<V> (\\<I> B)", "by simp"], ["proof (state)\nthis:\n  \\<V> (\\<I> A) = \\<V> (\\<I> B)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<V>; y \\<in> range \\<V>;\n        \\<I> x = \\<I> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"A = B\""], ["proof (prove)\nusing this:\n  \\<V> (\\<I> A) = \\<V> (\\<I> B)\n\ngoal (1 subgoal):\n 1. A = B", "by (simp add: A B)"], ["proof (state)\nthis:\n  A = B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ideal_of_variety_of_ideal [simp]: \"\\<I> (\\<V> (\\<I> A)) = \\<I> A\" (is \"_ = ?I\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> (\\<V> (\\<I> A)) = \\<I> A", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<I> (\\<V> (\\<I> A)) \\<subseteq> \\<I> A\n 2. \\<I> A \\<subseteq> \\<I> (\\<V> (\\<I> A))", "have \"A \\<subseteq> \\<V> (\\<I> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> \\<V> (\\<I> A)", "by (auto intro!: variety_ofI dest: ideal_ofD)"], ["proof (state)\nthis:\n  A \\<subseteq> \\<V> (\\<I> A)\n\ngoal (2 subgoals):\n 1. \\<I> (\\<V> (\\<I> A)) \\<subseteq> \\<I> A\n 2. \\<I> A \\<subseteq> \\<I> (\\<V> (\\<I> A))", "thus \"\\<I> (\\<V> ?I) \\<subseteq> ?I\""], ["proof (prove)\nusing this:\n  A \\<subseteq> \\<V> (\\<I> A)\n\ngoal (1 subgoal):\n 1. \\<I> (\\<V> (\\<I> A)) \\<subseteq> \\<I> A", "by (rule ideal_of_antimono)"], ["proof (state)\nthis:\n  \\<I> (\\<V> (\\<I> A)) \\<subseteq> \\<I> A\n\ngoal (1 subgoal):\n 1. \\<I> A \\<subseteq> \\<I> (\\<V> (\\<I> A))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I> A \\<subseteq> \\<I> (\\<V> (\\<I> A))", "show \"?I \\<subseteq> \\<I> (\\<V> ?I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> A \\<subseteq> \\<I> (\\<V> (\\<I> A))", "by (auto intro!: ideal_ofI dest: variety_ofD)"], ["proof (state)\nthis:\n  \\<I> A \\<subseteq> \\<I> (\\<V> (\\<I> A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma variety_of_inj_on: \"inj_on \\<V> (range (\\<I>::('x \\<Rightarrow> 'a::comm_semiring_1) set \\<Rightarrow> _))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<V> (range \\<I>)", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<I>; y \\<in> range \\<I>;\n        \\<V> x = \\<V> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix F G :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<I>; y \\<in> range \\<I>;\n        \\<V> x = \\<V> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"F \\<in> range \\<I>\""], ["proof (state)\nthis:\n  F \\<in> range \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<I>; y \\<in> range \\<I>;\n        \\<V> x = \\<V> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  F \\<in> range \\<I>", "obtain A where F: \"F = \\<I> A\""], ["proof (prove)\nusing this:\n  F \\<in> range \\<I>\n\ngoal (1 subgoal):\n 1. (\\<And>A. F = \\<I> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  F = \\<I> A\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<I>; y \\<in> range \\<I>;\n        \\<V> x = \\<V> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"G \\<in> range \\<I>\""], ["proof (state)\nthis:\n  G \\<in> range \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<I>; y \\<in> range \\<I>;\n        \\<V> x = \\<V> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  G \\<in> range \\<I>", "obtain B where G: \"G = \\<I> B\""], ["proof (prove)\nusing this:\n  G \\<in> range \\<I>\n\ngoal (1 subgoal):\n 1. (\\<And>B. G = \\<I> B \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  G = \\<I> B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<I>; y \\<in> range \\<I>;\n        \\<V> x = \\<V> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"\\<V> F = \\<V> G\""], ["proof (state)\nthis:\n  \\<V> F = \\<V> G\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<I>; y \\<in> range \\<I>;\n        \\<V> x = \\<V> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"\\<I> (\\<V> F) = \\<I> (\\<V> G)\""], ["proof (prove)\nusing this:\n  \\<V> F = \\<V> G\n\ngoal (1 subgoal):\n 1. \\<I> (\\<V> F) = \\<I> (\\<V> G)", "by simp"], ["proof (state)\nthis:\n  \\<I> (\\<V> F) = \\<I> (\\<V> G)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range \\<I>; y \\<in> range \\<I>;\n        \\<V> x = \\<V> y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"F = G\""], ["proof (prove)\nusing this:\n  \\<I> (\\<V> F) = \\<I> (\\<V> G)\n\ngoal (1 subgoal):\n 1. F = G", "by (simp add: F G)"], ["proof (state)\nthis:\n  F = G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_map_indets_ideal_of:\n  assumes \"inj f\"\n  shows \"map_indets f ` \\<I> A = \\<I> ((\\<lambda>a. a \\<circ> f) -` (A::('x \\<Rightarrow> 'a::comm_semiring_1) set)) \\<inter> P[range f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "fix p and a::\"'x \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "assume \"\\<forall>a\\<in>(\\<lambda>a. a \\<circ> f) -` A. poly_eval (a \\<circ> f) p = 0\""], ["proof (state)\nthis:\n  \\<forall>a\\<in>(\\<lambda>a. a \\<circ> f) -` A.\n     poly_eval (a \\<circ> f) p = (0::'a)\n\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "hence eq: \"poly_eval (a \\<circ> f) p = 0\" if \"a \\<circ> f \\<in> A\" for a"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>(\\<lambda>a. a \\<circ> f) -` A.\n     poly_eval (a \\<circ> f) p = (0::'a)\n\ngoal (1 subgoal):\n 1. poly_eval (a \\<circ> f) p = (0::'a)", "using that"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>(\\<lambda>a. a \\<circ> f) -` A.\n     poly_eval (a \\<circ> f) p = (0::'a)\n  a \\<circ> f \\<in> A\n\ngoal (1 subgoal):\n 1. poly_eval (a \\<circ> f) p = (0::'a)", "by simp"], ["proof (state)\nthis:\n  ?a \\<circ> f \\<in> A \\<Longrightarrow>\n  poly_eval (?a \\<circ> f) p = (0::'a)\n\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "have \"the_inv f \\<circ> f = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv f \\<circ> f = id", "by (rule ext) (simp add: assms the_inv_f_f)"], ["proof (state)\nthis:\n  the_inv f \\<circ> f = id\n\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "hence a: \"a = a \\<circ> the_inv f \\<circ> f\""], ["proof (prove)\nusing this:\n  the_inv f \\<circ> f = id\n\ngoal (1 subgoal):\n 1. a = a \\<circ> the_inv f \\<circ> f", "by (simp add: comp_assoc)"], ["proof (state)\nthis:\n  a = a \\<circ> the_inv f \\<circ> f\n\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "moreover"], ["proof (state)\nthis:\n  a = a \\<circ> the_inv f \\<circ> f\n\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "assume \"a \\<in> A\""], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "ultimately"], ["proof (chain)\npicking this:\n  a = a \\<circ> the_inv f \\<circ> f\n  a \\<in> A", "have \"(a \\<circ> the_inv f) \\<circ> f \\<in> A\""], ["proof (prove)\nusing this:\n  a = a \\<circ> the_inv f \\<circ> f\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. a \\<circ> the_inv f \\<circ> f \\<in> A", "by simp"], ["proof (state)\nthis:\n  a \\<circ> the_inv f \\<circ> f \\<in> A\n\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "hence \"poly_eval ((a \\<circ> the_inv f) \\<circ> f) p = 0\""], ["proof (prove)\nusing this:\n  a \\<circ> the_inv f \\<circ> f \\<in> A\n\ngoal (1 subgoal):\n 1. poly_eval (a \\<circ> the_inv f \\<circ> f) p = (0::'a)", "by (rule eq)"], ["proof (state)\nthis:\n  poly_eval (a \\<circ> the_inv f \\<circ> f) p = (0::'a)\n\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "hence \"poly_eval a p = 0\""], ["proof (prove)\nusing this:\n  poly_eval (a \\<circ> the_inv f \\<circ> f) p = (0::'a)\n\ngoal (1 subgoal):\n 1. poly_eval a p = (0::'a)", "by (simp flip: a)"], ["proof (state)\nthis:\n  poly_eval a p = (0::'a)\n\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a\\<in>(\\<lambda>a. a \\<circ> f) -` A.\n              poly_eval (a \\<circ> f) ?p2 = (0::'a);\n   ?a2 \\<in> A\\<rbrakk>\n  \\<Longrightarrow> poly_eval ?a2 ?p2 = (0::'a)\n\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a\\<in>(\\<lambda>a. a \\<circ> f) -` A.\n              poly_eval (a \\<circ> f) ?p2 = (0::'a);\n   ?a2 \\<in> A\\<rbrakk>\n  \\<Longrightarrow> poly_eval ?a2 ?p2 = (0::'a)\n\ngoal (1 subgoal):\n 1. map_indets f ` \\<I> A =\n    \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]", "by (auto simp: ideal_of_def poly_eval_map_indets simp flip: range_map_indets intro!: imageI)"], ["proof (state)\nthis:\n  map_indets f ` \\<I> A =\n  \\<I> ((\\<lambda>a. a \\<circ> f) -` A) \\<inter> P[range f]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma variety_of_map_indets: \"\\<V> (map_indets f ` F) = (\\<lambda>a. a \\<circ> f) -` \\<V> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> (map_indets f ` F) = (\\<lambda>a. a \\<circ> f) -` \\<V> F", "by (auto simp: variety_of_def poly_eval_map_indets)"], ["", "subsection \\<open>Radical Ideals\\<close>"], ["", "definition radical :: \"'a::monoid_mult set \\<Rightarrow> 'a set\" (\"\\<surd>(_)\" [999] 999)\n  where \"radical F = {f. \\<exists>m. f ^ m \\<in> F}\""], ["", "lemma radicalI: \"f ^ m \\<in> F \\<Longrightarrow> f \\<in> \\<surd>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ^ m \\<in> F \\<Longrightarrow> f \\<in> \\<surd>F", "by (auto simp: radical_def)"], ["", "lemma radicalE:\n  assumes \"f \\<in> \\<surd>F\"\n  obtains m where \"f ^ m \\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. f ^ m \\<in> F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> \\<surd>F\n\ngoal (1 subgoal):\n 1. (\\<And>m. f ^ m \\<in> F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: radical_def)"], ["", "lemma radical_empty [simp]: \"\\<surd>{} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<surd>{} = {}", "by (simp add: radical_def)"], ["", "lemma radical_UNIV [simp]: \"\\<surd>UNIV = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<surd>UNIV = UNIV", "by (simp add: radical_def)"], ["", "lemma radical_ideal_eq_UNIV_iff: \"\\<surd>ideal F = UNIV \\<longleftrightarrow> ideal F = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<surd>ideal F = UNIV) = (ideal F = UNIV)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<surd>ideal F = UNIV \\<Longrightarrow> ideal F = UNIV\n 2. ideal F = UNIV \\<Longrightarrow> \\<surd>ideal F = UNIV", "assume \"\\<surd>ideal F = UNIV\""], ["proof (state)\nthis:\n  \\<surd>ideal F = UNIV\n\ngoal (2 subgoals):\n 1. \\<surd>ideal F = UNIV \\<Longrightarrow> ideal F = UNIV\n 2. ideal F = UNIV \\<Longrightarrow> \\<surd>ideal F = UNIV", "hence \"1 \\<in> \\<surd>ideal F\""], ["proof (prove)\nusing this:\n  \\<surd>ideal F = UNIV\n\ngoal (1 subgoal):\n 1. (1::'a) \\<in> \\<surd>ideal F", "by simp"], ["proof (state)\nthis:\n  (1::'a) \\<in> \\<surd>ideal F\n\ngoal (2 subgoals):\n 1. \\<surd>ideal F = UNIV \\<Longrightarrow> ideal F = UNIV\n 2. ideal F = UNIV \\<Longrightarrow> \\<surd>ideal F = UNIV", "then"], ["proof (chain)\npicking this:\n  (1::'a) \\<in> \\<surd>ideal F", "obtain m where \"1 ^ m \\<in> ideal F\""], ["proof (prove)\nusing this:\n  (1::'a) \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        (1::'a) ^ m \\<in> ideal F \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule radicalE)"], ["proof (state)\nthis:\n  (1::'a) ^ m \\<in> ideal F\n\ngoal (2 subgoals):\n 1. \\<surd>ideal F = UNIV \\<Longrightarrow> ideal F = UNIV\n 2. ideal F = UNIV \\<Longrightarrow> \\<surd>ideal F = UNIV", "thus \"ideal F = UNIV\""], ["proof (prove)\nusing this:\n  (1::'a) ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. ideal F = UNIV", "by (simp add: ideal_eq_UNIV_iff_contains_one)"], ["proof (state)\nthis:\n  ideal F = UNIV\n\ngoal (1 subgoal):\n 1. ideal F = UNIV \\<Longrightarrow> \\<surd>ideal F = UNIV", "qed simp"], ["", "lemma zero_in_radical_ideal [simp]: \"0 \\<in> \\<surd>ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> \\<surd>ideal F", "proof (rule radicalI)"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) ^ ?m \\<in> ideal F", "show \"0 ^ 1 \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) ^ 1 \\<in> ideal F", "by (simp add: ideal.span_zero)"], ["proof (state)\nthis:\n  (0::'a) ^ 1 \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma radical_mono: \"F \\<subseteq> G \\<Longrightarrow> \\<surd>F \\<subseteq> \\<surd>G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> G \\<Longrightarrow> \\<surd>F \\<subseteq> \\<surd>G", "by (auto elim!: radicalE intro: radicalI)"], ["", "lemma radical_superset: \"F \\<subseteq> \\<surd>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> \\<surd>F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> \\<surd>F", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> \\<surd>F", "assume \"f \\<in> F\""], ["proof (state)\nthis:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> \\<surd>F", "hence \"f ^ 1 \\<in> F\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. f ^ 1 \\<in> F", "by simp"], ["proof (state)\nthis:\n  f ^ 1 \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> \\<surd>F", "thus \"f \\<in> \\<surd>F\""], ["proof (prove)\nusing this:\n  f ^ 1 \\<in> F\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>F", "by (rule radicalI)"], ["proof (state)\nthis:\n  f \\<in> \\<surd>F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma radical_idem [simp]: \"\\<surd>\\<surd>F = \\<surd>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<surd>\\<surd>F = \\<surd>F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<surd>\\<surd>F \\<subseteq> \\<surd>F\n 2. \\<surd>F \\<subseteq> \\<surd>\\<surd>F", "show \"\\<surd>\\<surd>F \\<subseteq> \\<surd>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<surd>\\<surd>F \\<subseteq> \\<surd>F", "by (auto elim!: radicalE intro: radicalI simp flip: power_mult)"], ["proof (state)\nthis:\n  \\<surd>\\<surd>F \\<subseteq> \\<surd>F\n\ngoal (1 subgoal):\n 1. \\<surd>F \\<subseteq> \\<surd>\\<surd>F", "qed (fact radical_superset)"], ["", "lemma radical_Int_subset: \"\\<surd>(A \\<inter> B) \\<subseteq> \\<surd>A \\<inter> \\<surd>B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<surd>(A \\<inter> B) \\<subseteq> \\<surd>A \\<inter> \\<surd>B", "by (auto intro: radicalI elim: radicalE)"], ["", "lemma radical_ideal_Int: \"\\<surd>(ideal F \\<inter> ideal G) = \\<surd>ideal F \\<inter> \\<surd>ideal G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<surd>(ideal F \\<inter> ideal G) =\n    \\<surd>ideal F \\<inter> \\<surd>ideal G", "using radical_Int_subset"], ["proof (prove)\nusing this:\n  \\<surd>(?A \\<inter> ?B) \\<subseteq> \\<surd>?A \\<inter> \\<surd>?B\n\ngoal (1 subgoal):\n 1. \\<surd>(ideal F \\<inter> ideal G) =\n    \\<surd>ideal F \\<inter> \\<surd>ideal G", "proof (rule subset_antisym)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<surd>ideal F \\<inter> \\<surd>ideal G\n    \\<subseteq> \\<surd>(ideal F \\<inter> ideal G)", "show \"\\<surd>ideal F \\<inter> \\<surd>ideal G \\<subseteq> \\<surd>(ideal F \\<inter> ideal G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<surd>ideal F \\<inter> \\<surd>ideal G\n    \\<subseteq> \\<surd>(ideal F \\<inter> ideal G)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G \\<Longrightarrow>\n       x \\<in> \\<surd>(ideal F \\<inter> ideal G)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G \\<Longrightarrow>\n       x \\<in> \\<surd>(ideal F \\<inter> ideal G)", "assume \"p \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G\""], ["proof (state)\nthis:\n  p \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G \\<Longrightarrow>\n       x \\<in> \\<surd>(ideal F \\<inter> ideal G)", "hence \"p \\<in> \\<surd>ideal F\" and \"p \\<in> \\<surd>ideal G\""], ["proof (prove)\nusing this:\n  p \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G\n\ngoal (1 subgoal):\n 1. p \\<in> \\<surd>ideal F &&& p \\<in> \\<surd>ideal G", "by simp_all"], ["proof (state)\nthis:\n  p \\<in> \\<surd>ideal F\n  p \\<in> \\<surd>ideal G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G \\<Longrightarrow>\n       x \\<in> \\<surd>(ideal F \\<inter> ideal G)", "from this(1)"], ["proof (chain)\npicking this:\n  p \\<in> \\<surd>ideal F", "obtain m1 where p1: \"p ^ m1 \\<in> ideal F\""], ["proof (prove)\nusing this:\n  p \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>m1.\n        p ^ m1 \\<in> ideal F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule radicalE)"], ["proof (state)\nthis:\n  p ^ m1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G \\<Longrightarrow>\n       x \\<in> \\<surd>(ideal F \\<inter> ideal G)", "from \\<open>p \\<in> \\<surd>ideal G\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> \\<surd>ideal G", "obtain m2 where \"p ^ m2 \\<in> ideal G\""], ["proof (prove)\nusing this:\n  p \\<in> \\<surd>ideal G\n\ngoal (1 subgoal):\n 1. (\\<And>m2.\n        p ^ m2 \\<in> ideal G \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule radicalE)"], ["proof (state)\nthis:\n  p ^ m2 \\<in> ideal G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G \\<Longrightarrow>\n       x \\<in> \\<surd>(ideal F \\<inter> ideal G)", "hence \"p ^ m1 * p ^ m2 \\<in> ideal G\""], ["proof (prove)\nusing this:\n  p ^ m2 \\<in> ideal G\n\ngoal (1 subgoal):\n 1. p ^ m1 * p ^ m2 \\<in> ideal G", "by (rule ideal.span_scale)"], ["proof (state)\nthis:\n  p ^ m1 * p ^ m2 \\<in> ideal G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G \\<Longrightarrow>\n       x \\<in> \\<surd>(ideal F \\<inter> ideal G)", "moreover"], ["proof (state)\nthis:\n  p ^ m1 * p ^ m2 \\<in> ideal G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G \\<Longrightarrow>\n       x \\<in> \\<surd>(ideal F \\<inter> ideal G)", "from p1"], ["proof (chain)\npicking this:\n  p ^ m1 \\<in> ideal F", "have \"p ^ m2 * p ^ m1 \\<in> ideal F\""], ["proof (prove)\nusing this:\n  p ^ m1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p ^ m2 * p ^ m1 \\<in> ideal F", "by (rule ideal.span_scale)"], ["proof (state)\nthis:\n  p ^ m2 * p ^ m1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G \\<Longrightarrow>\n       x \\<in> \\<surd>(ideal F \\<inter> ideal G)", "ultimately"], ["proof (chain)\npicking this:\n  p ^ m1 * p ^ m2 \\<in> ideal G\n  p ^ m2 * p ^ m1 \\<in> ideal F", "have \"p ^ (m1 + m2) \\<in> ideal F \\<inter> ideal G\""], ["proof (prove)\nusing this:\n  p ^ m1 * p ^ m2 \\<in> ideal G\n  p ^ m2 * p ^ m1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p ^ (m1 + m2) \\<in> ideal F \\<inter> ideal G", "by (simp add: power_add mult.commute)"], ["proof (state)\nthis:\n  p ^ (m1 + m2) \\<in> ideal F \\<inter> ideal G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>ideal F \\<inter> \\<surd>ideal G \\<Longrightarrow>\n       x \\<in> \\<surd>(ideal F \\<inter> ideal G)", "thus \"p \\<in> \\<surd>(ideal F \\<inter> ideal G)\""], ["proof (prove)\nusing this:\n  p ^ (m1 + m2) \\<in> ideal F \\<inter> ideal G\n\ngoal (1 subgoal):\n 1. p \\<in> \\<surd>(ideal F \\<inter> ideal G)", "by (rule radicalI)"], ["proof (state)\nthis:\n  p \\<in> \\<surd>(ideal F \\<inter> ideal G)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<surd>ideal F \\<inter> \\<surd>ideal G\n  \\<subseteq> \\<surd>(ideal F \\<inter> ideal G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ideal_radical_ideal [simp]: \"ideal (\\<surd>ideal F) = \\<surd>ideal F\" (is \"_ = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (\\<surd>ideal F) = \\<surd>ideal F", "unfolding ideal.span_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal.subspace (\\<surd>ideal F)", "proof (rule ideal.subspaceI)"], ["proof (state)\ngoal (3 subgoals):\n 1. (0::'a) \\<in> \\<surd>ideal F\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 3. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "have \"0 ^ 1 \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) ^ 1 \\<in> ideal F", "by (simp add: ideal.span_zero)"], ["proof (state)\nthis:\n  (0::'a) ^ 1 \\<in> ideal F\n\ngoal (3 subgoals):\n 1. (0::'a) \\<in> \\<surd>ideal F\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 3. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "thus \"0 \\<in> ?R\""], ["proof (prove)\nusing this:\n  (0::'a) ^ 1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> \\<surd>ideal F", "by (rule radicalI)"], ["proof (state)\nthis:\n  (0::'a) \\<in> \\<surd>ideal F\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 2. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 2. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "fix a b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 2. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "assume \"a \\<in> ?R\""], ["proof (state)\nthis:\n  a \\<in> \\<surd>ideal F\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 2. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "then"], ["proof (chain)\npicking this:\n  a \\<in> \\<surd>ideal F", "obtain m where \"a ^ m \\<in> ideal F\""], ["proof (prove)\nusing this:\n  a \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        a ^ m \\<in> ideal F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule radicalE)"], ["proof (state)\nthis:\n  a ^ m \\<in> ideal F\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 2. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "have a: \"a ^ k \\<in> ideal F\" if \"m \\<le> k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. a ^ k \\<in> ideal F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a ^ k \\<in> ideal F", "from \\<open>a ^ m \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  a ^ m \\<in> ideal F", "have \"a ^ (k - m + m) \\<in> ideal F\""], ["proof (prove)\nusing this:\n  a ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. a ^ (k - m + m) \\<in> ideal F", "by (simp only: power_add ideal.span_scale)"], ["proof (state)\nthis:\n  a ^ (k - m + m) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. a ^ k \\<in> ideal F", "with that"], ["proof (chain)\npicking this:\n  m \\<le> k\n  a ^ (k - m + m) \\<in> ideal F", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<le> k\n  a ^ (k - m + m) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. a ^ k \\<in> ideal F", "by simp"], ["proof (state)\nthis:\n  a ^ k \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<le> ?k \\<Longrightarrow> a ^ ?k \\<in> ideal F\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 2. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "assume \"b \\<in> ?R\""], ["proof (state)\nthis:\n  b \\<in> \\<surd>ideal F\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 2. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "then"], ["proof (chain)\npicking this:\n  b \\<in> \\<surd>ideal F", "obtain n where \"b ^ n \\<in> ideal F\""], ["proof (prove)\nusing this:\n  b \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        b ^ n \\<in> ideal F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule radicalE)"], ["proof (state)\nthis:\n  b ^ n \\<in> ideal F\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 2. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "have b: \"b ^ k \\<in> ideal F\" if \"n \\<le> k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ k \\<in> ideal F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b ^ k \\<in> ideal F", "from \\<open>b ^ n \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  b ^ n \\<in> ideal F", "have \"b ^ (k - n + n) \\<in> ideal F\""], ["proof (prove)\nusing this:\n  b ^ n \\<in> ideal F\n\ngoal (1 subgoal):\n 1. b ^ (k - n + n) \\<in> ideal F", "by (simp only: power_add ideal.span_scale)"], ["proof (state)\nthis:\n  b ^ (k - n + n) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. b ^ k \\<in> ideal F", "with that"], ["proof (chain)\npicking this:\n  n \\<le> k\n  b ^ (k - n + n) \\<in> ideal F", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> k\n  b ^ (k - n + n) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. b ^ k \\<in> ideal F", "by simp"], ["proof (state)\nthis:\n  b ^ k \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<le> ?k \\<Longrightarrow> b ^ ?k \\<in> ideal F\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 2. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "have \"(a + b) ^ (m + n) \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b) ^ (m + n) \\<in> ideal F", "unfolding binomial_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>m + n. of_nat (m + n choose k) * a ^ k * b ^ (m + n - k))\n    \\<in> ideal F", "proof (rule ideal.span_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..m + n} \\<Longrightarrow>\n       of_nat (m + n choose x) * a ^ x * b ^ (m + n - x) \\<in> ideal F", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..m + n} \\<Longrightarrow>\n       of_nat (m + n choose x) * a ^ x * b ^ (m + n - x) \\<in> ideal F", "show \"of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "proof (cases \"k \\<le> m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F\n 2. \\<not> k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "case True"], ["proof (state)\nthis:\n  k \\<le> m\n\ngoal (2 subgoals):\n 1. k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F\n 2. \\<not> k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "hence \"n \\<le> m + n - k\""], ["proof (prove)\nusing this:\n  k \\<le> m\n\ngoal (1 subgoal):\n 1. n \\<le> m + n - k", "by simp"], ["proof (state)\nthis:\n  n \\<le> m + n - k\n\ngoal (2 subgoals):\n 1. k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F\n 2. \\<not> k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "hence \"b ^ (m + n - k) \\<in> ideal F\""], ["proof (prove)\nusing this:\n  n \\<le> m + n - k\n\ngoal (1 subgoal):\n 1. b ^ (m + n - k) \\<in> ideal F", "by (rule b)"], ["proof (state)\nthis:\n  b ^ (m + n - k) \\<in> ideal F\n\ngoal (2 subgoals):\n 1. k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F\n 2. \\<not> k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "thus ?thesis"], ["proof (prove)\nusing this:\n  b ^ (m + n - k) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "by (rule ideal.span_scale)"], ["proof (state)\nthis:\n  of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "case False"], ["proof (state)\nthis:\n  \\<not> k \\<le> m\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "hence \"m \\<le> k\""], ["proof (prove)\nusing this:\n  \\<not> k \\<le> m\n\ngoal (1 subgoal):\n 1. m \\<le> k", "by simp"], ["proof (state)\nthis:\n  m \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "hence \"a ^ k \\<in> ideal F\""], ["proof (prove)\nusing this:\n  m \\<le> k\n\ngoal (1 subgoal):\n 1. a ^ k \\<in> ideal F", "by (rule a)"], ["proof (state)\nthis:\n  a ^ k \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "hence \"of_nat (m + n choose k) * b ^ (m + n - k) * a ^ k \\<in> ideal F\""], ["proof (prove)\nusing this:\n  a ^ k \\<in> ideal F\n\ngoal (1 subgoal):\n 1. of_nat (m + n choose k) * b ^ (m + n - k) * a ^ k \\<in> ideal F", "by (rule ideal.span_scale)"], ["proof (state)\nthis:\n  of_nat (m + n choose k) * b ^ (m + n - k) * a ^ k \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> m \\<Longrightarrow>\n    of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "thus ?thesis"], ["proof (prove)\nusing this:\n  of_nat (m + n choose k) * b ^ (m + n - k) * a ^ k \\<in> ideal F\n\ngoal (1 subgoal):\n 1. of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F", "by (simp only: ac_simps)"], ["proof (state)\nthis:\n  of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_nat (m + n choose k) * a ^ k * b ^ (m + n - k) \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a + b) ^ (m + n) \\<in> ideal F\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> \\<surd>ideal F; y \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> \\<surd>ideal F\n 2. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "thus \"a + b \\<in> ?R\""], ["proof (prove)\nusing this:\n  (a + b) ^ (m + n) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. a + b \\<in> \\<surd>ideal F", "by (rule radicalI)"], ["proof (state)\nthis:\n  a + b \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "fix c a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "assume \"a \\<in> ?R\""], ["proof (state)\nthis:\n  a \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "then"], ["proof (chain)\npicking this:\n  a \\<in> \\<surd>ideal F", "obtain m where \"a ^ m \\<in> ideal F\""], ["proof (prove)\nusing this:\n  a \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        a ^ m \\<in> ideal F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule radicalE)"], ["proof (state)\nthis:\n  a ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "hence \"(c * a) ^ m \\<in> ideal F\""], ["proof (prove)\nusing this:\n  a ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. (c * a) ^ m \\<in> ideal F", "by (simp only: power_mult_distrib ideal.span_scale)"], ["proof (state)\nthis:\n  (c * a) ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>c x.\n       x \\<in> \\<surd>ideal F \\<Longrightarrow> c * x \\<in> \\<surd>ideal F", "thus \"c * a \\<in> ?R\""], ["proof (prove)\nusing this:\n  (c * a) ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. c * a \\<in> \\<surd>ideal F", "by (rule radicalI)"], ["proof (state)\nthis:\n  c * a \\<in> \\<surd>ideal F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma radical_ideal_of [simp]: \"\\<surd>\\<I> A = \\<I> (A::(_ \\<Rightarrow> _::semiring_1_no_zero_divisors) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<surd>\\<I> A = \\<I> A", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<surd>\\<I> A \\<subseteq> \\<I> A\n 2. \\<I> A \\<subseteq> \\<surd>\\<I> A", "show \"\\<surd>\\<I> A \\<subseteq> \\<I> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<surd>\\<I> A \\<subseteq> \\<I> A", "by (auto elim!: radicalE dest!: ideal_ofD intro!: ideal_ofI simp: poly_eval_power)"], ["proof (state)\nthis:\n  \\<surd>\\<I> A \\<subseteq> \\<I> A\n\ngoal (1 subgoal):\n 1. \\<I> A \\<subseteq> \\<surd>\\<I> A", "qed (fact radical_superset)"], ["", "lemma variety_of_radical_ideal [simp]: \"\\<V> (\\<surd>ideal F) = \\<V> (F::(_ \\<Rightarrow>\\<^sub>0 _::semiring_1_no_zero_divisors) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> (\\<surd>ideal F) = \\<V> F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<V> (\\<surd>ideal F) \\<subseteq> \\<V> F\n 2. \\<V> F \\<subseteq> \\<V> (\\<surd>ideal F)", "have \"F \\<subseteq> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> ideal F", "by (rule ideal.span_superset)"], ["proof (state)\nthis:\n  F \\<subseteq> ideal F\n\ngoal (2 subgoals):\n 1. \\<V> (\\<surd>ideal F) \\<subseteq> \\<V> F\n 2. \\<V> F \\<subseteq> \\<V> (\\<surd>ideal F)", "also"], ["proof (state)\nthis:\n  F \\<subseteq> ideal F\n\ngoal (2 subgoals):\n 1. \\<V> (\\<surd>ideal F) \\<subseteq> \\<V> F\n 2. \\<V> F \\<subseteq> \\<V> (\\<surd>ideal F)", "have \"\\<dots> \\<subseteq> \\<surd>ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal F \\<subseteq> \\<surd>ideal F", "by (rule radical_superset)"], ["proof (state)\nthis:\n  ideal F \\<subseteq> \\<surd>ideal F\n\ngoal (2 subgoals):\n 1. \\<V> (\\<surd>ideal F) \\<subseteq> \\<V> F\n 2. \\<V> F \\<subseteq> \\<V> (\\<surd>ideal F)", "finally"], ["proof (chain)\npicking this:\n  F \\<subseteq> \\<surd>ideal F", "show \"\\<V> (\\<surd>ideal F) \\<subseteq> \\<V> F\""], ["proof (prove)\nusing this:\n  F \\<subseteq> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. \\<V> (\\<surd>ideal F) \\<subseteq> \\<V> F", "by (rule variety_of_antimono)"], ["proof (state)\nthis:\n  \\<V> (\\<surd>ideal F) \\<subseteq> \\<V> F\n\ngoal (1 subgoal):\n 1. \\<V> F \\<subseteq> \\<V> (\\<surd>ideal F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<V> F \\<subseteq> \\<V> (\\<surd>ideal F)", "show \"\\<V> F \\<subseteq> \\<V> (\\<surd>ideal F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> F \\<subseteq> \\<V> (\\<surd>ideal F)", "proof (intro subsetI variety_ofI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>x \\<in> \\<V> F; f \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> poly_eval x f = (0::'b)", "fix a f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>x \\<in> \\<V> F; f \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> poly_eval x f = (0::'b)", "assume \"a \\<in> \\<V> F\""], ["proof (state)\nthis:\n  a \\<in> \\<V> F\n\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>x \\<in> \\<V> F; f \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> poly_eval x f = (0::'b)", "hence \"a \\<in> \\<V> (ideal F)\""], ["proof (prove)\nusing this:\n  a \\<in> \\<V> F\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V> (ideal F)", "by simp"], ["proof (state)\nthis:\n  a \\<in> \\<V> (ideal F)\n\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>x \\<in> \\<V> F; f \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> poly_eval x f = (0::'b)", "assume \"f \\<in> \\<surd>ideal F\""], ["proof (state)\nthis:\n  f \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>x \\<in> \\<V> F; f \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> poly_eval x f = (0::'b)", "then"], ["proof (chain)\npicking this:\n  f \\<in> \\<surd>ideal F", "obtain m where \"f ^ m \\<in> ideal F\""], ["proof (prove)\nusing this:\n  f \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        f ^ m \\<in> ideal F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule radicalE)"], ["proof (state)\nthis:\n  f ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>x \\<in> \\<V> F; f \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> poly_eval x f = (0::'b)", "with \\<open>a \\<in> \\<V> (ideal F)\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> \\<V> (ideal F)\n  f ^ m \\<in> ideal F", "have \"poly_eval a (f ^ m) = 0\""], ["proof (prove)\nusing this:\n  a \\<in> \\<V> (ideal F)\n  f ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. poly_eval a (f ^ m) = (0::'b)", "by (rule variety_ofD)"], ["proof (state)\nthis:\n  poly_eval a (f ^ m) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x f.\n       \\<lbrakk>x \\<in> \\<V> F; f \\<in> \\<surd>ideal F\\<rbrakk>\n       \\<Longrightarrow> poly_eval x f = (0::'b)", "thus \"poly_eval a f = 0\""], ["proof (prove)\nusing this:\n  poly_eval a (f ^ m) = (0::'b)\n\ngoal (1 subgoal):\n 1. poly_eval a f = (0::'b)", "by (simp add: poly_eval_power)"], ["proof (state)\nthis:\n  poly_eval a f = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<V> F \\<subseteq> \\<V> (\\<surd>ideal F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_map_indets_radical:\n  assumes \"inj f\"\n  shows \"map_indets f ` \\<surd>F = \\<surd>(map_indets f ` (F::(_ \\<Rightarrow>\\<^sub>0 'a::comm_ring_1) set)) \\<inter> P[range f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets f ` \\<surd>F = \\<surd>(map_indets f ` F) \\<inter> P[range f]", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. map_indets f ` \\<surd>F\n    \\<subseteq> \\<surd>(map_indets f ` F) \\<inter> P[range f]\n 2. \\<surd>(map_indets f ` F) \\<inter> P[range f]\n    \\<subseteq> map_indets f ` \\<surd>F", "show \"map_indets f ` \\<surd>F \\<subseteq> \\<surd>(map_indets f ` F) \\<inter> P[range f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets f ` \\<surd>F\n    \\<subseteq> \\<surd>(map_indets f ` F) \\<inter> P[range f]", "by (auto simp: radical_def simp flip: map_indets_power range_map_indets intro!: imageI)"], ["proof (state)\nthis:\n  map_indets f ` \\<surd>F\n  \\<subseteq> \\<surd>(map_indets f ` F) \\<inter> P[range f]\n\ngoal (1 subgoal):\n 1. \\<surd>(map_indets f ` F) \\<inter> P[range f]\n    \\<subseteq> map_indets f ` \\<surd>F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<surd>(map_indets f ` F) \\<inter> P[range f]\n    \\<subseteq> map_indets f ` \\<surd>F", "show \"\\<surd>(map_indets f ` F) \\<inter> P[range f] \\<subseteq> map_indets f ` \\<surd>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<surd>(map_indets f ` F) \\<inter> P[range f]\n    \\<subseteq> map_indets f ` \\<surd>F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "assume \"p \\<in> \\<surd>(map_indets f ` F) \\<inter> P[range f]\""], ["proof (state)\nthis:\n  p \\<in> \\<surd>(map_indets f ` F) \\<inter> P[range f]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "hence \"p \\<in> \\<surd>(map_indets f ` F)\" and \"p \\<in> range (map_indets f)\""], ["proof (prove)\nusing this:\n  p \\<in> \\<surd>(map_indets f ` F) \\<inter> P[range f]\n\ngoal (1 subgoal):\n 1. p \\<in> \\<surd>(map_indets f ` F) &&& p \\<in> range (map_indets f)", "by (simp_all add: range_map_indets)"], ["proof (state)\nthis:\n  p \\<in> \\<surd>(map_indets f ` F)\n  p \\<in> range (map_indets f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "from this(1)"], ["proof (chain)\npicking this:\n  p \\<in> \\<surd>(map_indets f ` F)", "obtain m where \"p ^ m \\<in> map_indets f ` F\""], ["proof (prove)\nusing this:\n  p \\<in> \\<surd>(map_indets f ` F)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        p ^ m \\<in> map_indets f ` F \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule radicalE)"], ["proof (state)\nthis:\n  p ^ m \\<in> map_indets f ` F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "then"], ["proof (chain)\npicking this:\n  p ^ m \\<in> map_indets f ` F", "obtain q where \"q \\<in> F\" and p_m: \"p ^ m = map_indets f q\""], ["proof (prove)\nusing this:\n  p ^ m \\<in> map_indets f ` F\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> F; p ^ m = map_indets f q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  q \\<in> F\n  p ^ m = map_indets f q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "from assms"], ["proof (chain)\npicking this:\n  inj f", "obtain g where \"g \\<circ> f = id\" and \"map_indets g \\<circ> map_indets f = (id::_ \\<Rightarrow> _ \\<Rightarrow>\\<^sub>0 'a)\""], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<circ> f = id;\n         map_indets g \\<circ> map_indets f = id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule map_indets_inverseE)"], ["proof (state)\nthis:\n  g \\<circ> f = id\n  map_indets g \\<circ> map_indets f = id\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "hence eq: \"map_indets g (map_indets f p') = p'\" for p'::\"_ \\<Rightarrow>\\<^sub>0 'a\""], ["proof (prove)\nusing this:\n  g \\<circ> f = id\n  map_indets g \\<circ> map_indets f = id\n\ngoal (1 subgoal):\n 1. map_indets g (map_indets f p') = p'", "by (simp add: pointfree_idE)"], ["proof (state)\nthis:\n  map_indets g (map_indets f ?p') = ?p'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "from p_m"], ["proof (chain)\npicking this:\n  p ^ m = map_indets f q", "have \"map_indets g (p ^ m) = map_indets g (map_indets f q)\""], ["proof (prove)\nusing this:\n  p ^ m = map_indets f q\n\ngoal (1 subgoal):\n 1. map_indets g (p ^ m) = map_indets g (map_indets f q)", "by (rule arg_cong)"], ["proof (state)\nthis:\n  map_indets g (p ^ m) = map_indets g (map_indets f q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "hence \"(map_indets g p) ^ m = q\""], ["proof (prove)\nusing this:\n  map_indets g (p ^ m) = map_indets g (map_indets f q)\n\ngoal (1 subgoal):\n 1. map_indets g p ^ m = q", "by (simp add: eq)"], ["proof (state)\nthis:\n  map_indets g p ^ m = q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "from \\<open>p \\<in> range _\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> range (map_indets f)", "obtain p' where \"p = map_indets f p'\""], ["proof (prove)\nusing this:\n  p \\<in> range (map_indets f)\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = map_indets f p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p = map_indets f p'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "hence \"p = map_indets f (map_indets g p)\""], ["proof (prove)\nusing this:\n  p = map_indets f p'\n\ngoal (1 subgoal):\n 1. p = map_indets f (map_indets g p)", "by (simp add: eq)"], ["proof (state)\nthis:\n  p = map_indets f (map_indets g p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "moreover"], ["proof (state)\nthis:\n  p = map_indets f (map_indets g p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "have \"map_indets g p \\<in> \\<surd>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_indets g p \\<in> \\<surd>F", "proof (rule radicalI)"], ["proof (state)\ngoal (1 subgoal):\n 1. map_indets g p ^ ?m \\<in> F", "from \\<open>q \\<in> F\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> F", "show \"map_indets g p ^ m \\<in> F\""], ["proof (prove)\nusing this:\n  q \\<in> F\n\ngoal (1 subgoal):\n 1. map_indets g p ^ m \\<in> F", "by (simp add: p_m eq flip: map_indets_power)"], ["proof (state)\nthis:\n  map_indets g p ^ m \\<in> F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_indets g p \\<in> \\<surd>F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<surd>(map_indets f ` F) \\<inter>\n               P[range f] \\<Longrightarrow>\n       x \\<in> map_indets f ` \\<surd>F", "ultimately"], ["proof (chain)\npicking this:\n  p = map_indets f (map_indets g p)\n  map_indets g p \\<in> \\<surd>F", "show \"p \\<in> map_indets f ` \\<surd>F\""], ["proof (prove)\nusing this:\n  p = map_indets f (map_indets g p)\n  map_indets g p \\<in> \\<surd>F\n\ngoal (1 subgoal):\n 1. p \\<in> map_indets f ` \\<surd>F", "by (rule image_eqI)"], ["proof (state)\nthis:\n  p \\<in> map_indets f ` \\<surd>F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<surd>(map_indets f ` F) \\<inter> P[range f]\n  \\<subseteq> map_indets f ` \\<surd>F\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Geometric Version of the Nullstellensatz\\<close>"], ["", "lemma weak_Nullstellensatz_aux_1:\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> g i \\<in> ideal B\"\n  obtains c where \"c \\<in> ideal B\" and \"(\\<Prod>i\\<in>I. (f i + g i) ^ m i) = (\\<Prod>i\\<in>I. f i ^ m i) + c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> ideal B;\n         (\\<Prod>i\\<in>I. (f i + g i) ^ m i) =\n         (\\<Prod>i\\<in>I. f i ^ m i) + c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> g ?i \\<in> ideal B\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> ideal B;\n         (\\<Prod>i\\<in>I. (f i + g i) ^ m i) =\n         (\\<Prod>i\\<in>I. f i ^ m i) + c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct I arbitrary: thesis rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A thesis.\n       \\<lbrakk>infinite A;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>A. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>A. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i. i \\<in> A \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>thesis.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>c \\<in> ideal B;\n                    (\\<Prod>i\\<in>{}. (f i + g i) ^ m i) =\n                    (\\<Prod>i\\<in>{}. f i ^ m i) + c\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i. i \\<in> {} \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (infinite I)"], ["proof (state)\nthis:\n  infinite I\n  \\<lbrakk>?c \\<in> ideal B;\n   (\\<Prod>i\\<in>I. (f i + g i) ^ m i) =\n   (\\<Prod>i\\<in>I. f i ^ m i) + ?c\\<rbrakk>\n  \\<Longrightarrow> thesis\n  ?i \\<in> I \\<Longrightarrow> g ?i \\<in> ideal B\n\ngoal (3 subgoals):\n 1. \\<And>A thesis.\n       \\<lbrakk>infinite A;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>A. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>A. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i. i \\<in> A \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>thesis.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>c \\<in> ideal B;\n                    (\\<Prod>i\\<in>{}. (f i + g i) ^ m i) =\n                    (\\<Prod>i\\<in>{}. f i ^ m i) + c\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i. i \\<in> {} \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "from ideal.span_zero"], ["proof (chain)\npicking this:\n  (0::?'a) \\<in> ideal ?S", "show ?case"], ["proof (prove)\nusing this:\n  (0::?'a) \\<in> ideal ?S\n\ngoal (1 subgoal):\n 1. thesis", "by (rule infinite) (simp add: infinite(1))"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>c \\<in> ideal B;\n                    (\\<Prod>i\\<in>{}. (f i + g i) ^ m i) =\n                    (\\<Prod>i\\<in>{}. f i ^ m i) + c\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i. i \\<in> {} \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>c \\<in> ideal B;\n                    (\\<Prod>i\\<in>{}. (f i + g i) ^ m i) =\n                    (\\<Prod>i\\<in>{}. f i ^ m i) + c\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i. i \\<in> {} \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "case empty"], ["proof (state)\nthis:\n  \\<lbrakk>?c \\<in> ideal B;\n   (\\<Prod>i\\<in>{}. (f i + g i) ^ m i) =\n   (\\<Prod>i\\<in>{}. f i ^ m i) + ?c\\<rbrakk>\n  \\<Longrightarrow> thesis\n  ?i \\<in> {} \\<Longrightarrow> g ?i \\<in> ideal B\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>c \\<in> ideal B;\n                    (\\<Prod>i\\<in>{}. (f i + g i) ^ m i) =\n                    (\\<Prod>i\\<in>{}. f i ^ m i) + c\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i. i \\<in> {} \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "from ideal.span_zero"], ["proof (chain)\npicking this:\n  (0::?'a) \\<in> ideal ?S", "show ?case"], ["proof (prove)\nusing this:\n  (0::?'a) \\<in> ideal ?S\n\ngoal (1 subgoal):\n 1. thesis", "by (rule empty) simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (insert j I)"], ["proof (state)\nthis:\n  finite I\n  j \\<notin> I\n  \\<lbrakk>\\<And>c.\n              \\<lbrakk>c \\<in> ideal B;\n               (\\<Prod>i\\<in>I. (f i + g i) ^ m i) =\n               (\\<Prod>i\\<in>I. f i ^ m i) + c\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>i. i \\<in> I \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>?c \\<in> ideal B;\n   (\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) =\n   (\\<Prod>i\\<in>insert j I. f i ^ m i) + ?c\\<rbrakk>\n  \\<Longrightarrow> thesis\n  ?i \\<in> insert j I \\<Longrightarrow> g ?i \\<in> ideal B\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"g i \\<in> ideal B\" if \"i \\<in> I\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. g i \\<in> ideal B", "by (rule insert.prems) (simp add: that)"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow> g ?i \\<in> ideal B\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "with insert.hyps(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>c.\n              \\<lbrakk>c \\<in> ideal B;\n               (\\<Prod>i\\<in>I. (f i + g i) ^ m i) =\n               (\\<Prod>i\\<in>I. f i ^ m i) + c\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>i. i \\<in> I \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ?i \\<in> I \\<Longrightarrow> g ?i \\<in> ideal B", "obtain c where c: \"c \\<in> ideal B\"\n    and 1: \"(\\<Prod>i\\<in>I. (f i + g i) ^ m i) = (\\<Prod>i\\<in>I. f i ^ m i) + c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>c.\n              \\<lbrakk>c \\<in> ideal B;\n               (\\<Prod>i\\<in>I. (f i + g i) ^ m i) =\n               (\\<Prod>i\\<in>I. f i ^ m i) + c\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>i. i \\<in> I \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ?i \\<in> I \\<Longrightarrow> g ?i \\<in> ideal B\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> ideal B;\n         (\\<Prod>i\\<in>I. (f i + g i) ^ m i) =\n         (\\<Prod>i\\<in>I. f i ^ m i) + c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c \\<in> ideal B\n  (\\<Prod>i\\<in>I. (f i + g i) ^ m i) = (\\<Prod>i\\<in>I. f i ^ m i) + c\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "define k where \"k = m j\""], ["proof (state)\nthis:\n  k = m j\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain d where 2: \"(f j + g j) ^ m j = f j ^ m j + d * g j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        (f j + g j) ^ m j = f j ^ m j + d * g j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding k_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (induct k arbitrary: thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>d.\n           (f j + g j) ^ 0 = f j ^ 0 + d * g j \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>k thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>d.\n                       (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>d.\n           (f j + g j) ^ Suc k = f j ^ Suc k + d * g j \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case 0"], ["proof (state)\nthis:\n  (f j + g j) ^ 0 = f j ^ 0 + ?d * g j \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>d.\n           (f j + g j) ^ 0 = f j ^ 0 + d * g j \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>k thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>d.\n                       (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>d.\n           (f j + g j) ^ Suc k = f j ^ Suc k + d * g j \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"(f j + g j) ^ 0 = f j ^ 0 + 0 * g j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f j + g j) ^ 0 = f j ^ 0 + (0::'b) * g j", "by simp"], ["proof (state)\nthis:\n  (f j + g j) ^ 0 = f j ^ 0 + (0::'b) * g j\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       (\\<And>d.\n           (f j + g j) ^ 0 = f j ^ 0 + d * g j \\<Longrightarrow>\n           thesis) \\<Longrightarrow>\n       thesis\n 2. \\<And>k thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>d.\n                       (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>d.\n           (f j + g j) ^ Suc k = f j ^ Suc k + d * g j \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  (f j + g j) ^ 0 = f j ^ 0 + (0::'b) * g j\n\ngoal (1 subgoal):\n 1. thesis", "by (rule 0)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>k thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>d.\n                       (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>d.\n           (f j + g j) ^ Suc k = f j ^ Suc k + d * g j \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>d.\n                       (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>d.\n           (f j + g j) ^ Suc k = f j ^ Suc k + d * g j \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Suc k)"], ["proof (state)\nthis:\n  (\\<And>d.\n      (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n  (f j + g j) ^ Suc k = f j ^ Suc k + ?d * g j \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>k thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>d.\n                       (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>d.\n           (f j + g j) ^ Suc k = f j ^ Suc k + d * g j \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain d where \"(f j + g j) ^ k = f j ^ k + d * g j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule Suc.hyps)"], ["proof (state)\nthis:\n  (f j + g j) ^ k = f j ^ k + d * g j\n\ngoal (1 subgoal):\n 1. \\<And>k thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>d.\n                       (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>d.\n           (f j + g j) ^ Suc k = f j ^ Suc k + d * g j \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"(f j + g j) ^ Suc k = (f j ^ k + d * g j) * (f j + g j)\""], ["proof (prove)\nusing this:\n  (f j + g j) ^ k = f j ^ k + d * g j\n\ngoal (1 subgoal):\n 1. (f j + g j) ^ Suc k = (f j ^ k + d * g j) * (f j + g j)", "by simp"], ["proof (state)\nthis:\n  (f j + g j) ^ Suc k = (f j ^ k + d * g j) * (f j + g j)\n\ngoal (1 subgoal):\n 1. \\<And>k thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>d.\n                       (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>d.\n           (f j + g j) ^ Suc k = f j ^ Suc k + d * g j \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  (f j + g j) ^ Suc k = (f j ^ k + d * g j) * (f j + g j)\n\ngoal (1 subgoal):\n 1. \\<And>k thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>d.\n                       (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>d.\n           (f j + g j) ^ Suc k = f j ^ Suc k + d * g j \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<dots> = f j ^ Suc k + (f j ^ k + d * (f j + g j)) * g j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f j ^ k + d * g j) * (f j + g j) =\n    f j ^ Suc k + (f j ^ k + d * (f j + g j)) * g j", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (f j ^ k + d * g j) * (f j + g j) =\n  f j ^ Suc k + (f j ^ k + d * (f j + g j)) * g j\n\ngoal (1 subgoal):\n 1. \\<And>k thesis.\n       \\<lbrakk>\\<And>thesis.\n                   (\\<And>d.\n                       (f j + g j) ^ k = f j ^ k + d * g j \\<Longrightarrow>\n                       thesis) \\<Longrightarrow>\n                   thesis;\n        \\<And>d.\n           (f j + g j) ^ Suc k = f j ^ Suc k + d * g j \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  (f j + g j) ^ Suc k = f j ^ Suc k + (f j ^ k + d * (f j + g j)) * g j", "show ?case"], ["proof (prove)\nusing this:\n  (f j + g j) ^ Suc k = f j ^ Suc k + (f j ^ k + d * (f j + g j)) * g j\n\ngoal (1 subgoal):\n 1. thesis", "by (rule Suc.prems)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f j + g j) ^ m j = f j ^ m j + d * g j\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "from c"], ["proof (chain)\npicking this:\n  c \\<in> ideal B", "have *: \"f j ^ m j * c + (((\\<Prod>i\\<in>I. f i ^ m i) + c) * d) * g j \\<in> ideal B\" (is \"?c \\<in> _\")"], ["proof (prove)\nusing this:\n  c \\<in> ideal B\n\ngoal (1 subgoal):\n 1. f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j\n    \\<in> ideal B", "by (intro ideal.span_add ideal.span_scale insert.prems insertI1)"], ["proof (state)\nthis:\n  f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j \\<in> ideal B\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "from insert.hyps(1, 2)"], ["proof (chain)\npicking this:\n  finite I\n  j \\<notin> I", "have \"(\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) =\n                                (f j ^ m j + d * g j) * ((\\<Prod>i\\<in>I. f i ^ m i) + c)\""], ["proof (prove)\nusing this:\n  finite I\n  j \\<notin> I\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) =\n    (f j ^ m j + d * g j) * ((\\<Prod>i\\<in>I. f i ^ m i) + c)", "by (simp add: 1 2)"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) =\n  (f j ^ m j + d * g j) * ((\\<Prod>i\\<in>I. f i ^ m i) + c)\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) =\n  (f j ^ m j + d * g j) * ((\\<Prod>i\\<in>I. f i ^ m i) + c)\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "from insert.hyps(1, 2)"], ["proof (chain)\npicking this:\n  finite I\n  j \\<notin> I", "have \"\\<dots> = (\\<Prod>i\\<in>insert j I. f i ^ m i) + ?c\""], ["proof (prove)\nusing this:\n  finite I\n  j \\<notin> I\n\ngoal (1 subgoal):\n 1. (f j ^ m j + d * g j) * ((\\<Prod>i\\<in>I. f i ^ m i) + c) =\n    (\\<Prod>i\\<in>insert j I. f i ^ m i) +\n    (f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (f j ^ m j + d * g j) * ((\\<Prod>i\\<in>I. f i ^ m i) + c) =\n  (\\<Prod>i\\<in>insert j I. f i ^ m i) +\n  (f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j)\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) =\n  (\\<Prod>i\\<in>insert j I. f i ^ m i) +\n  (f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j)", "have \"(\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) = (\\<Prod>i\\<in>insert j I. f i ^ m i) + ?c\""], ["proof (prove)\nusing this:\n  (\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) =\n  (\\<Prod>i\\<in>insert j I. f i ^ m i) +\n  (f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) =\n    (\\<Prod>i\\<in>insert j I. f i ^ m i) +\n    (f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j)", "."], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) =\n  (\\<Prod>i\\<in>insert j I. f i ^ m i) +\n  (f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j)\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>c.\n                       \\<lbrakk>c \\<in> ideal B;\n                        (\\<Prod>i\\<in>F. (f i + g i) ^ m i) =\n                        (\\<Prod>i\\<in>F. f i ^ m i) + c\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            \\<And>i. i \\<in> F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>c.\n           \\<lbrakk>c \\<in> ideal B;\n            (\\<Prod>i\\<in>insert x F. (f i + g i) ^ m i) =\n            (\\<Prod>i\\<in>insert x F. f i ^ m i) + c\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> g i \\<in> ideal B\\<rbrakk>\n       \\<Longrightarrow> thesis", "with *"], ["proof (chain)\npicking this:\n  f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j \\<in> ideal B\n  (\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) =\n  (\\<Prod>i\\<in>insert j I. f i ^ m i) +\n  (f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j)", "show ?case"], ["proof (prove)\nusing this:\n  f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j \\<in> ideal B\n  (\\<Prod>i\\<in>insert j I. (f i + g i) ^ m i) =\n  (\\<Prod>i\\<in>insert j I. f i ^ m i) +\n  (f j ^ m j * c + ((\\<Prod>i\\<in>I. f i ^ m i) + c) * d * g j)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule insert.prems)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma weak_Nullstellensatz_aux_2:\n  assumes \"finite X\" and \"F \\<subseteq> P[insert x X]\" and \"X \\<subseteq> {..<x::'x::{countable,linorder}}\"\n    and \"1 \\<notin> ideal F\" and \"ideal F \\<inter> P[{x}] \\<subseteq> {0}\"\n  obtains a::\"'a::alg_closed_field\" where \"1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?x = \"monomial 1 (Poly_Mapping.single x 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms(3)"], ["proof (chain)\npicking this:\n  X \\<subseteq> {..<x}", "have \"x \\<notin> X\""], ["proof (prove)\nusing this:\n  X \\<subseteq> {..<x}\n\ngoal (1 subgoal):\n 1. x \\<notin> X", "by blast"], ["proof (state)\nthis:\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "hence eq1: \"insert x X - {x} = X\" and eq2: \"insert x X - X = {x}\""], ["proof (prove)\nusing this:\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. insert x X - {x} = X &&& insert x X - X = {x}", "by blast+"], ["proof (state)\nthis:\n  insert x X - {x} = X\n  insert x X - X = {x}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "interpret i: pm_powerprod lex_pm \"lex_pm_strict::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_powerprod lex_pm lex_pm_strict", "unfolding lex_pm_def lex_pm_strict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_powerprod (\\<le>) (<)", "by standard (simp_all add: lex_pm_zero_min lex_pm_plus_monotone flip: lex_pm_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have lpp_focus: \"i.lpp (focus X g) = except (i.lpp g) {x}\" if \"g \\<in> P[insert x X]\" for g::\"_ \\<Rightarrow>\\<^sub>0 'a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i.lpp (focus X g) = except (i.lpp g) {x}", "proof (cases \"g = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g = 0 \\<Longrightarrow> i.lpp (focus X g) = except (i.lpp g) {x}\n 2. g \\<noteq> 0 \\<Longrightarrow> i.lpp (focus X g) = except (i.lpp g) {x}", "case True"], ["proof (state)\nthis:\n  g = 0\n\ngoal (2 subgoals):\n 1. g = 0 \\<Longrightarrow> i.lpp (focus X g) = except (i.lpp g) {x}\n 2. g \\<noteq> 0 \\<Longrightarrow> i.lpp (focus X g) = except (i.lpp g) {x}", "thus ?thesis"], ["proof (prove)\nusing this:\n  g = 0\n\ngoal (1 subgoal):\n 1. i.lpp (focus X g) = except (i.lpp g) {x}", "by simp"], ["proof (state)\nthis:\n  i.lpp (focus X g) = except (i.lpp g) {x}\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0 \\<Longrightarrow> i.lpp (focus X g) = except (i.lpp g) {x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<noteq> 0 \\<Longrightarrow> i.lpp (focus X g) = except (i.lpp g) {x}", "case False"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0 \\<Longrightarrow> i.lpp (focus X g) = except (i.lpp g) {x}", "have keys_focus_g: \"keys (focus X g) = (\\<lambda>t. except t {x}) ` keys g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (focus X g) = (\\<lambda>t. except t {x}) ` keys g", "unfolding keys_focus"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys g =\n    (\\<lambda>t. except t {x}) ` keys g", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. except t (- X)) ` keys g =\n    (\\<lambda>t. except t {x}) ` keys g", "proof (rule image_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys g \\<Longrightarrow> except xa (- X) = except xa {x}", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys g \\<Longrightarrow> except xa (- X) = except xa {x}", "assume \"t \\<in> keys g\""], ["proof (state)\nthis:\n  t \\<in> keys g\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys g \\<Longrightarrow> except xa (- X) = except xa {x}", "also"], ["proof (state)\nthis:\n  t \\<in> keys g\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys g \\<Longrightarrow> except xa (- X) = except xa {x}", "from that"], ["proof (chain)\npicking this:\n  g \\<in> P[insert x X]", "have \"\\<dots> \\<subseteq> .[insert x X]\""], ["proof (prove)\nusing this:\n  g \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. keys g \\<subseteq> .[insert x X]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys g \\<subseteq> .[insert x X]\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys g \\<Longrightarrow> except xa (- X) = except xa {x}", "finally"], ["proof (chain)\npicking this:\n  t \\<in> .[insert x X]", "have \"keys t \\<subseteq> insert x X\""], ["proof (prove)\nusing this:\n  t \\<in> .[insert x X]\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> insert x X", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys t \\<subseteq> insert x X\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys g \\<Longrightarrow> except xa (- X) = except xa {x}", "hence \"except t (- X) = except t (insert x X \\<inter> - X)\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> insert x X\n\ngoal (1 subgoal):\n 1. except t (- X) = except t (insert x X \\<inter> - X)", "by (metis (no_types, lifting) Int_commute except_keys_Int inf.orderE inf_left_commute)"], ["proof (state)\nthis:\n  except t (- X) = except t (insert x X \\<inter> - X)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys g \\<Longrightarrow> except xa (- X) = except xa {x}", "also"], ["proof (state)\nthis:\n  except t (- X) = except t (insert x X \\<inter> - X)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys g \\<Longrightarrow> except xa (- X) = except xa {x}", "from \\<open>x \\<notin> X\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> X", "have \"insert x X \\<inter> - X = {x}\""], ["proof (prove)\nusing this:\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. insert x X \\<inter> - X = {x}", "by simp"], ["proof (state)\nthis:\n  insert x X \\<inter> - X = {x}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> keys g \\<Longrightarrow> except xa (- X) = except xa {x}", "finally"], ["proof (chain)\npicking this:\n  except t (- X) = except t {x}", "show \"except t (- X) = except t {x}\""], ["proof (prove)\nusing this:\n  except t (- X) = except t {x}\n\ngoal (1 subgoal):\n 1. except t (- X) = except t {x}", "."], ["proof (state)\nthis:\n  except t (- X) = except t {x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (focus X g) = (\\<lambda>t. except t {x}) ` keys g\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0 \\<Longrightarrow> i.lpp (focus X g) = except (i.lpp g) {x}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. i.lpp (focus X g) = except (i.lpp g) {x}", "proof (rule i.punit.lt_eqI_keys)"], ["proof (state)\ngoal (2 subgoals):\n 1. except (i.lpp g) {x} \\<in> keys (focus X g)\n 2. \\<And>u.\n       u \\<in> keys (focus X g) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "from False"], ["proof (chain)\npicking this:\n  g \\<noteq> 0", "have \"i.lpp g \\<in> keys g\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i.lpp g \\<in> keys g", "by (rule i.punit.lt_in_keys)"], ["proof (state)\nthis:\n  i.lpp g \\<in> keys g\n\ngoal (2 subgoals):\n 1. except (i.lpp g) {x} \\<in> keys (focus X g)\n 2. \\<And>u.\n       u \\<in> keys (focus X g) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "thus \"except (i.lpp g) {x} \\<in> keys (focus X g)\""], ["proof (prove)\nusing this:\n  i.lpp g \\<in> keys g\n\ngoal (1 subgoal):\n 1. except (i.lpp g) {x} \\<in> keys (focus X g)", "unfolding keys_focus_g"], ["proof (prove)\nusing this:\n  i.lpp g \\<in> keys g\n\ngoal (1 subgoal):\n 1. except (i.lpp g) {x} \\<in> (\\<lambda>t. except t {x}) ` keys g", "by (rule imageI)"], ["proof (state)\nthis:\n  except (i.lpp g) {x} \\<in> keys (focus X g)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (focus X g) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (focus X g) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "assume \"t \\<in> keys (focus X g)\""], ["proof (state)\nthis:\n  t \\<in> keys (focus X g)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (focus X g) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "then"], ["proof (chain)\npicking this:\n  t \\<in> keys (focus X g)", "obtain s where \"s \\<in> keys g\" and t: \"t = except s {x}\""], ["proof (prove)\nusing this:\n  t \\<in> keys (focus X g)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys g; t = except s {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding keys_focus_g"], ["proof (prove)\nusing this:\n  t \\<in> (\\<lambda>t. except t {x}) ` keys g\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys g; t = except s {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> keys g\n  t = except s {x}\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (focus X g) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "from this(1)"], ["proof (chain)\npicking this:\n  s \\<in> keys g", "have \"lex_pm s (i.lpp g)\""], ["proof (prove)\nusing this:\n  s \\<in> keys g\n\ngoal (1 subgoal):\n 1. lex_pm s (i.lpp g)", "by (rule i.punit.lt_max_keys)"], ["proof (state)\nthis:\n  lex_pm s (i.lpp g)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (focus X g) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "moreover"], ["proof (state)\nthis:\n  lex_pm s (i.lpp g)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (focus X g) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "have \"keys s \\<union> keys (i.lpp g) \\<subseteq> {..x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys s \\<union> keys (i.lpp g) \\<subseteq> {..x}", "proof (rule Un_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys s \\<subseteq> {..x}\n 2. keys (i.lpp g) \\<subseteq> {..x}", "from \\<open>g \\<in> P[_]\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> P[insert x X]", "have \"keys g \\<subseteq> .[insert x X]\""], ["proof (prove)\nusing this:\n  g \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. keys g \\<subseteq> .[insert x X]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys g \\<subseteq> .[insert x X]\n\ngoal (2 subgoals):\n 1. keys s \\<subseteq> {..x}\n 2. keys (i.lpp g) \\<subseteq> {..x}", "with \\<open>s \\<in> keys g\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> keys g\n  keys g \\<subseteq> .[insert x X]", "have \"s \\<in> .[insert x X]\""], ["proof (prove)\nusing this:\n  s \\<in> keys g\n  keys g \\<subseteq> .[insert x X]\n\ngoal (1 subgoal):\n 1. s \\<in> .[insert x X]", ".."], ["proof (state)\nthis:\n  s \\<in> .[insert x X]\n\ngoal (2 subgoals):\n 1. keys s \\<subseteq> {..x}\n 2. keys (i.lpp g) \\<subseteq> {..x}", "hence \"keys s \\<subseteq> insert x X\""], ["proof (prove)\nusing this:\n  s \\<in> .[insert x X]\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> insert x X", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys s \\<subseteq> insert x X\n\ngoal (2 subgoals):\n 1. keys s \\<subseteq> {..x}\n 2. keys (i.lpp g) \\<subseteq> {..x}", "thus \"keys s \\<subseteq> {..x}\""], ["proof (prove)\nusing this:\n  keys s \\<subseteq> insert x X\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> {..x}", "using assms(3)"], ["proof (prove)\nusing this:\n  keys s \\<subseteq> insert x X\n  X \\<subseteq> {..<x}\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> {..x}", "by auto"], ["proof (state)\nthis:\n  keys s \\<subseteq> {..x}\n\ngoal (1 subgoal):\n 1. keys (i.lpp g) \\<subseteq> {..x}", "from \\<open>i.lpp g \\<in> keys g\\<close> \\<open>keys g \\<subseteq> _\\<close>"], ["proof (chain)\npicking this:\n  i.lpp g \\<in> keys g\n  keys g \\<subseteq> .[insert x X]", "have \"i.lpp g \\<in> .[insert x X]\""], ["proof (prove)\nusing this:\n  i.lpp g \\<in> keys g\n  keys g \\<subseteq> .[insert x X]\n\ngoal (1 subgoal):\n 1. i.lpp g \\<in> .[insert x X]", ".."], ["proof (state)\nthis:\n  i.lpp g \\<in> .[insert x X]\n\ngoal (1 subgoal):\n 1. keys (i.lpp g) \\<subseteq> {..x}", "hence \"keys (i.lpp g) \\<subseteq> insert x X\""], ["proof (prove)\nusing this:\n  i.lpp g \\<in> .[insert x X]\n\ngoal (1 subgoal):\n 1. keys (i.lpp g) \\<subseteq> insert x X", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys (i.lpp g) \\<subseteq> insert x X\n\ngoal (1 subgoal):\n 1. keys (i.lpp g) \\<subseteq> {..x}", "thus \"keys (i.lpp g) \\<subseteq> {..x}\""], ["proof (prove)\nusing this:\n  keys (i.lpp g) \\<subseteq> insert x X\n\ngoal (1 subgoal):\n 1. keys (i.lpp g) \\<subseteq> {..x}", "using assms(3)"], ["proof (prove)\nusing this:\n  keys (i.lpp g) \\<subseteq> insert x X\n  X \\<subseteq> {..<x}\n\ngoal (1 subgoal):\n 1. keys (i.lpp g) \\<subseteq> {..x}", "by auto"], ["proof (state)\nthis:\n  keys (i.lpp g) \\<subseteq> {..x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys s \\<union> keys (i.lpp g) \\<subseteq> {..x}\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (focus X g) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "ultimately"], ["proof (chain)\npicking this:\n  lex_pm s (i.lpp g)\n  keys s \\<union> keys (i.lpp g) \\<subseteq> {..x}", "show \"lex_pm t (except (i.lpp g) {x})\""], ["proof (prove)\nusing this:\n  lex_pm s (i.lpp g)\n  keys s \\<union> keys (i.lpp g) \\<subseteq> {..x}\n\ngoal (1 subgoal):\n 1. lex_pm t (except (i.lpp g) {x})", "unfolding t"], ["proof (prove)\nusing this:\n  lex_pm s (i.lpp g)\n  keys s \\<union> keys (i.lpp g) \\<subseteq> {..x}\n\ngoal (1 subgoal):\n 1. lex_pm (except s {x}) (except (i.lpp g) {x})", "by (rule lex_pm_except_max)"], ["proof (state)\nthis:\n  lex_pm t (except (i.lpp g) {x})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i.lpp (focus X g) = except (i.lpp g) {x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?g1 \\<in> P[insert x X] \\<Longrightarrow>\n  i.lpp (focus X ?g1) = except (i.lpp ?g1) {x}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define G where \"G = i.punit.reduced_GB F\""], ["proof (state)\nthis:\n  G = i.punit.reduced_GB F\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms(1)"], ["proof (chain)\npicking this:\n  finite X", "have \"finite (insert x X)\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. finite (insert x X)", "by simp"], ["proof (state)\nthis:\n  finite (insert x X)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "hence fin_G: \"finite G\" and G_sub: \"G \\<subseteq> P[insert x X]\" and ideal_G: \"ideal G = ideal F\"\n    and \"0 \\<notin> G\" and G_isGB: \"i.punit.is_Groebner_basis G\""], ["proof (prove)\nusing this:\n  finite (insert x X)\n\ngoal (1 subgoal):\n 1. (finite G &&& G \\<subseteq> P[insert x X]) &&&\n    ideal G = ideal F &&& 0 \\<notin> G &&& i.punit.is_Groebner_basis G", "unfolding G_def"], ["proof (prove)\nusing this:\n  finite (insert x X)\n\ngoal (1 subgoal):\n 1. (finite (i.punit.reduced_GB F) &&&\n     i.punit.reduced_GB F \\<subseteq> P[insert x X]) &&&\n    ideal (i.punit.reduced_GB F) = ideal F &&&\n    0 \\<notin> i.punit.reduced_GB F &&&\n    i.punit.is_Groebner_basis (i.punit.reduced_GB F)", "using assms(2)"], ["proof (prove)\nusing this:\n  finite (insert x X)\n  F \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. (finite (i.punit.reduced_GB F) &&&\n     i.punit.reduced_GB F \\<subseteq> P[insert x X]) &&&\n    ideal (i.punit.reduced_GB F) = ideal F &&&\n    0 \\<notin> i.punit.reduced_GB F &&&\n    i.punit.is_Groebner_basis (i.punit.reduced_GB F)", "by (rule i.finite_reduced_GB_Polys, rule i.reduced_GB_Polys, rule i.reduced_GB_ideal_Polys,\n        rule i.reduced_GB_nonzero_Polys, rule i.reduced_GB_is_GB_Polys)"], ["proof (state)\nthis:\n  finite G\n  G \\<subseteq> P[insert x X]\n  ideal G = ideal F\n  0 \\<notin> G\n  i.punit.is_Groebner_basis G\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define G' where \"G' = focus X ` G\""], ["proof (state)\nthis:\n  G' = focus X ` G\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from fin_G \\<open>0 \\<notin> G\\<close>"], ["proof (chain)\npicking this:\n  finite G\n  0 \\<notin> G", "have fin_G': \"finite G'\" and \"0 \\<notin> G'\""], ["proof (prove)\nusing this:\n  finite G\n  0 \\<notin> G\n\ngoal (1 subgoal):\n 1. finite G' &&& 0 \\<notin> G'", "by (auto simp: G'_def)"], ["proof (state)\nthis:\n  finite G'\n  0 \\<notin> G'\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have G'_sub: \"G' \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G' \\<subseteq> P[X]", "by (auto simp: G'_def intro: focus_in_Polys)"], ["proof (state)\nthis:\n  G' \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define G'' where \"G'' = i.lcf ` G'\""], ["proof (state)\nthis:\n  G'' = i.lcf ` G'\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from \\<open>0 \\<notin> G'\\<close>"], ["proof (chain)\npicking this:\n  0 \\<notin> G'", "have \"0 \\<notin> G''\""], ["proof (prove)\nusing this:\n  0 \\<notin> G'\n\ngoal (1 subgoal):\n 1. 0 \\<notin> G''", "by (auto simp: G''_def i.punit.lc_eq_zero_iff)"], ["proof (state)\nthis:\n  0 \\<notin> G''\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have lookup_focus_in: \"lookup (focus X g) t \\<in> P[{x}]\" if \"g \\<in> G\" for g t"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (focus X g) t \\<in> P[{x}]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (focus X g) t \\<in> P[{x}]", "have \"lookup (focus X g) t \\<in> range (lookup (focus X g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (focus X g) t \\<in> range (lookup (focus X g))", "by (rule rangeI)"], ["proof (state)\nthis:\n  lookup (focus X g) t \\<in> range (lookup (focus X g))\n\ngoal (1 subgoal):\n 1. lookup (focus X g) t \\<in> P[{x}]", "from that G_sub"], ["proof (chain)\npicking this:\n  g \\<in> G\n  G \\<subseteq> P[insert x X]", "have \"g \\<in> P[insert x X]\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  G \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. g \\<in> P[insert x X]", ".."], ["proof (state)\nthis:\n  g \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. lookup (focus X g) t \\<in> P[{x}]", "hence \"range (lookup (focus X g)) \\<subseteq> P[insert x X - X]\""], ["proof (prove)\nusing this:\n  g \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. range (lookup (focus X g)) \\<subseteq> P[insert x X - X]", "by (rule focus_coeffs_subset_Polys')"], ["proof (state)\nthis:\n  range (lookup (focus X g)) \\<subseteq> P[insert x X - X]\n\ngoal (1 subgoal):\n 1. lookup (focus X g) t \\<in> P[{x}]", "with \\<open>_ \\<in> range _\\<close>"], ["proof (chain)\npicking this:\n  lookup (focus X g) t \\<in> range (lookup (focus X g))\n  range (lookup (focus X g)) \\<subseteq> P[insert x X - X]", "have \"lookup (focus X g) t \\<in> P[insert x X - X]\""], ["proof (prove)\nusing this:\n  lookup (focus X g) t \\<in> range (lookup (focus X g))\n  range (lookup (focus X g)) \\<subseteq> P[insert x X - X]\n\ngoal (1 subgoal):\n 1. lookup (focus X g) t \\<in> P[insert x X - X]", ".."], ["proof (state)\nthis:\n  lookup (focus X g) t \\<in> P[insert x X - X]\n\ngoal (1 subgoal):\n 1. lookup (focus X g) t \\<in> P[{x}]", "also"], ["proof (state)\nthis:\n  lookup (focus X g) t \\<in> P[insert x X - X]\n\ngoal (1 subgoal):\n 1. lookup (focus X g) t \\<in> P[{x}]", "have \"insert x X - X = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x X - X = {x}", "by (simp only: eq2)"], ["proof (state)\nthis:\n  insert x X - X = {x}\n\ngoal (1 subgoal):\n 1. lookup (focus X g) t \\<in> P[{x}]", "finally"], ["proof (chain)\npicking this:\n  lookup (focus X g) t \\<in> P[{x}]", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (focus X g) t \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. lookup (focus X g) t \\<in> P[{x}]", "."], ["proof (state)\nthis:\n  lookup (focus X g) t \\<in> P[{x}]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?g1 \\<in> G \\<Longrightarrow> lookup (focus X ?g1) ?t1 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "hence lcf_in: \"i.lcf (focus X g) \\<in> P[{x}]\" if \"g \\<in> G\" for g"], ["proof (prove)\nusing this:\n  ?g1 \\<in> G \\<Longrightarrow> lookup (focus X ?g1) ?t1 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. i.lcf (focus X g) \\<in> P[{x}]", "unfolding i.punit.lc_def"], ["proof (prove)\nusing this:\n  ?g1 \\<in> G \\<Longrightarrow> lookup (focus X ?g1) ?t1 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. lookup (focus X g) (i.lpp (focus X g)) \\<in> P[{x}]", "using that"], ["proof (prove)\nusing this:\n  ?g1 \\<in> G \\<Longrightarrow> lookup (focus X ?g1) ?t1 \\<in> P[{x}]\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. lookup (focus X g) (i.lpp (focus X g)) \\<in> P[{x}]", "by blast"], ["proof (state)\nthis:\n  ?g1 \\<in> G \\<Longrightarrow> i.lcf (focus X ?g1) \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have G''_sub: \"G'' \\<subseteq> P[{x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G'' \\<subseteq> P[{x}]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> G'' \\<Longrightarrow> xa \\<in> P[{x}]", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> G'' \\<Longrightarrow> xa \\<in> P[{x}]", "assume \"c \\<in> G''\""], ["proof (state)\nthis:\n  c \\<in> G''\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> G'' \\<Longrightarrow> xa \\<in> P[{x}]", "then"], ["proof (chain)\npicking this:\n  c \\<in> G''", "obtain g' where \"g' \\<in> G'\" and c: \"c = i.lcf g'\""], ["proof (prove)\nusing this:\n  c \\<in> G''\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>g' \\<in> G'; c = i.lcf g'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding G''_def"], ["proof (prove)\nusing this:\n  c \\<in> i.lcf ` G'\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>g' \\<in> G'; c = i.lcf g'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  g' \\<in> G'\n  c = i.lcf g'\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> G'' \\<Longrightarrow> xa \\<in> P[{x}]", "from \\<open>g' \\<in> G'\\<close>"], ["proof (chain)\npicking this:\n  g' \\<in> G'", "obtain g where \"g \\<in> G\" and g': \"g' = focus X g\""], ["proof (prove)\nusing this:\n  g' \\<in> G'\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; g' = focus X g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding G'_def"], ["proof (prove)\nusing this:\n  g' \\<in> focus X ` G\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; g' = focus X g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  g \\<in> G\n  g' = focus X g\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> G'' \\<Longrightarrow> xa \\<in> P[{x}]", "from this(1)"], ["proof (chain)\npicking this:\n  g \\<in> G", "show \"c \\<in> P[{x}]\""], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. c \\<in> P[{x}]", "unfolding c g'"], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. i.lcf (focus X g) \\<in> P[{x}]", "by (rule lcf_in)"], ["proof (state)\nthis:\n  c \\<in> P[{x}]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G'' \\<subseteq> P[{x}]\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define P where \"P = poly_of_pm x ` G''\""], ["proof (state)\nthis:\n  P = poly_of_pm x ` G''\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from fin_G'"], ["proof (chain)\npicking this:\n  finite G'", "have fin_P: \"finite P\""], ["proof (prove)\nusing this:\n  finite G'\n\ngoal (1 subgoal):\n 1. finite P", "by (simp add: P_def G''_def)"], ["proof (state)\nthis:\n  finite P\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"0 \\<notin> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<in> P \\<Longrightarrow> False", "assume \"0 \\<in> P\""], ["proof (state)\nthis:\n  0 \\<in> P\n\ngoal (1 subgoal):\n 1. 0 \\<in> P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 \\<in> P", "obtain g'' where \"g'' \\<in> G''\" and \"0 = poly_of_pm x g''\""], ["proof (prove)\nusing this:\n  0 \\<in> P\n\ngoal (1 subgoal):\n 1. (\\<And>g''.\n        \\<lbrakk>g'' \\<in> G''; 0 = poly_of_pm x g''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding P_def"], ["proof (prove)\nusing this:\n  0 \\<in> poly_of_pm x ` G''\n\ngoal (1 subgoal):\n 1. (\\<And>g''.\n        \\<lbrakk>g'' \\<in> G''; 0 = poly_of_pm x g''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  g'' \\<in> G''\n  0 = poly_of_pm x g''\n\ngoal (1 subgoal):\n 1. 0 \\<in> P \\<Longrightarrow> False", "from this(2)"], ["proof (chain)\npicking this:\n  0 = poly_of_pm x g''", "have *: \"keys g'' \\<inter> .[{x}] = {}\""], ["proof (prove)\nusing this:\n  0 = poly_of_pm x g''\n\ngoal (1 subgoal):\n 1. keys g'' \\<inter> .[{x}] = {}", "by (simp add: poly_of_pm_eq_zero_iff)"], ["proof (state)\nthis:\n  keys g'' \\<inter> .[{x}] = {}\n\ngoal (1 subgoal):\n 1. 0 \\<in> P \\<Longrightarrow> False", "from \\<open>g'' \\<in> G''\\<close> G''_sub"], ["proof (chain)\npicking this:\n  g'' \\<in> G''\n  G'' \\<subseteq> P[{x}]", "have \"g'' \\<in> P[{x}]\""], ["proof (prove)\nusing this:\n  g'' \\<in> G''\n  G'' \\<subseteq> P[{x}]\n\ngoal (1 subgoal):\n 1. g'' \\<in> P[{x}]", ".."], ["proof (state)\nthis:\n  g'' \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. 0 \\<in> P \\<Longrightarrow> False", "hence \"keys g'' \\<subseteq> .[{x}]\""], ["proof (prove)\nusing this:\n  g'' \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. keys g'' \\<subseteq> .[{x}]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys g'' \\<subseteq> .[{x}]\n\ngoal (1 subgoal):\n 1. 0 \\<in> P \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  keys g'' \\<inter> .[{x}] = {}\n  keys g'' \\<subseteq> .[{x}]", "have \"keys g'' = {}\""], ["proof (prove)\nusing this:\n  keys g'' \\<inter> .[{x}] = {}\n  keys g'' \\<subseteq> .[{x}]\n\ngoal (1 subgoal):\n 1. keys g'' = {}", "by blast"], ["proof (state)\nthis:\n  keys g'' = {}\n\ngoal (1 subgoal):\n 1. 0 \\<in> P \\<Longrightarrow> False", "with \\<open>g'' \\<in> G''\\<close> \\<open>0 \\<notin> G''\\<close>"], ["proof (chain)\npicking this:\n  g'' \\<in> G''\n  0 \\<notin> G''\n  keys g'' = {}", "show False"], ["proof (prove)\nusing this:\n  g'' \\<in> G''\n  0 \\<notin> G''\n  keys g'' = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<notin> P\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define Z where \"Z = (\\<Union>p\\<in>P. {z. poly p z = 0})\""], ["proof (state)\nthis:\n  Z = (\\<Union>p\\<in>P. {z. poly p z = (0::'a)})\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"finite Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Z", "unfolding Z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>p\\<in>P. {z. poly p z = (0::'a)})", "using fin_P"], ["proof (prove)\nusing this:\n  finite P\n\ngoal (1 subgoal):\n 1. finite (\\<Union>p\\<in>P. {z. poly p z = (0::'a)})", "proof (rule finite_UN_I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> finite {z. poly p z = (0::'a)}", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> finite {z. poly p z = (0::'a)}", "assume \"p \\<in> P\""], ["proof (state)\nthis:\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> finite {z. poly p z = (0::'a)}", "with \\<open>0 \\<notin> P\\<close>"], ["proof (chain)\npicking this:\n  0 \\<notin> P\n  p \\<in> P", "have \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 \\<notin> P\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p. p \\<in> P \\<Longrightarrow> finite {z. poly p z = (0::'a)}", "thus \"finite {z. poly p z = 0}\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite {z. poly p z = (0::'a)}", "by (rule poly_roots_finite)"], ["proof (state)\nthis:\n  finite {z. poly p z = (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite Z\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with infinite_UNIV[where 'a='a]"], ["proof (chain)\npicking this:\n  infinite UNIV\n  finite Z", "have \"- Z \\<noteq> {}\""], ["proof (prove)\nusing this:\n  infinite UNIV\n  finite Z\n\ngoal (1 subgoal):\n 1. - Z \\<noteq> {}", "using finite_compl"], ["proof (prove)\nusing this:\n  infinite UNIV\n  finite Z\n  finite ?A \\<Longrightarrow> finite (- ?A) = finite UNIV\n\ngoal (1 subgoal):\n 1. - Z \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  - Z \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  - Z \\<noteq> {}", "obtain a where \"a \\<notin> Z\""], ["proof (prove)\nusing this:\n  - Z \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<notin> Z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<notin> Z\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have a_nz: \"poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> 0\" if \"g \\<in> G\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> (0::'a)", "from that G_sub"], ["proof (chain)\npicking this:\n  g \\<in> G\n  G \\<subseteq> P[insert x X]", "have \"g \\<in> P[insert x X]\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  G \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. g \\<in> P[insert x X]", ".."], ["proof (state)\nthis:\n  g \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> (0::'a)", "have \"poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) = poly (poly_of_pm x (i.lcf (focus X g))) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) =\n    poly (poly_of_pm x (i.lcf (focus X g))) a", "by (rule sym, intro poly_eq_poly_eval' lcf_in that)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) =\n  poly (poly_of_pm x (i.lcf (focus X g))) a\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> (0::'a)", "moreover"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) =\n  poly (poly_of_pm x (i.lcf (focus X g))) a\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> (0::'a)", "have \"poly_of_pm x (i.lcf (focus X g)) \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (i.lcf (focus X g)) \\<in> P", "by (auto simp: P_def G''_def G'_def that intro!: imageI)"], ["proof (state)\nthis:\n  poly_of_pm x (i.lcf (focus X g)) \\<in> P\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) =\n  poly (poly_of_pm x (i.lcf (focus X g))) a\n  poly_of_pm x (i.lcf (focus X g)) \\<in> P", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) =\n  poly (poly_of_pm x (i.lcf (focus X g))) a\n  poly_of_pm x (i.lcf (focus X g)) \\<in> P\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> (0::'a)", "using \\<open>a \\<notin> Z\\<close>"], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) =\n  poly (poly_of_pm x (i.lcf (focus X g))) a\n  poly_of_pm x (i.lcf (focus X g)) \\<in> P\n  a \\<notin> Z\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> (0::'a)", "by (simp add: Z_def)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?g1 \\<in> G \\<Longrightarrow>\n  poly_eval (\\<lambda>_. a) (i.lcf (focus X ?g1)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?e = \"poly_eval (\\<lambda>_. monomial a 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have lookup_e_focus: \"lookup (?e (focus {x} g)) t = poly_eval (\\<lambda>_. a) (lookup (focus X g) t)\"\n    if \"g \\<in> P[insert x X]\" for g t"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t =\n    poly_eval (\\<lambda>_. a) (lookup (focus X g) t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t =\n    poly_eval (\\<lambda>_. a) (lookup (focus X g) t)", "have \"focus (- {x}) g = focus (- {x} \\<inter> insert x X) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus (- {x}) g = focus (- {x} \\<inter> insert x X) g", "by (rule sym) (rule focus_Int, fact)"], ["proof (state)\nthis:\n  focus (- {x}) g = focus (- {x} \\<inter> insert x X) g\n\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t =\n    poly_eval (\\<lambda>_. a) (lookup (focus X g) t)", "also"], ["proof (state)\nthis:\n  focus (- {x}) g = focus (- {x} \\<inter> insert x X) g\n\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t =\n    poly_eval (\\<lambda>_. a) (lookup (focus X g) t)", "have \"\\<dots> = focus X g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus (- {x} \\<inter> insert x X) g = focus X g", "by (simp add: Int_commute eq1 flip: Diff_eq)"], ["proof (state)\nthis:\n  focus (- {x} \\<inter> insert x X) g = focus X g\n\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t =\n    poly_eval (\\<lambda>_. a) (lookup (focus X g) t)", "finally"], ["proof (chain)\npicking this:\n  focus (- {x}) g = focus X g", "show ?thesis"], ["proof (prove)\nusing this:\n  focus (- {x}) g = focus X g\n\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t =\n    poly_eval (\\<lambda>_. a) (lookup (focus X g) t)", "by (simp add: lookup_poly_eval_focus)"], ["proof (state)\nthis:\n  lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t =\n  poly_eval (\\<lambda>_. a) (lookup (focus X g) t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?g2 \\<in> P[insert x X] \\<Longrightarrow>\n  lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} ?g2)) ?t2 =\n  poly_eval (\\<lambda>_. a) (lookup (focus X ?g2) ?t2)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have lpp_e_focus: \"i.lpp (?e (focus {x} g)) = except (i.lpp g) {x}\" if \"g \\<in> G\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. i.lpp (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) =\n    except (i.lpp g) {x}", "proof (rule i.punit.lt_eqI_keys)"], ["proof (state)\ngoal (2 subgoals):\n 1. except (i.lpp g) {x}\n    \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n 2. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "from that G_sub"], ["proof (chain)\npicking this:\n  g \\<in> G\n  G \\<subseteq> P[insert x X]", "have \"g \\<in> P[insert x X]\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  G \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. g \\<in> P[insert x X]", ".."], ["proof (state)\nthis:\n  g \\<in> P[insert x X]\n\ngoal (2 subgoals):\n 1. except (i.lpp g) {x}\n    \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n 2. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "hence \"lookup (?e (focus {x} g)) (except (i.lpp g) {x}) = poly_eval (\\<lambda>_. a) (i.lcf (focus X g))\""], ["proof (prove)\nusing this:\n  g \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n     (except (i.lpp g) {x}) =\n    poly_eval (\\<lambda>_. a) (i.lcf (focus X g))", "by (simp only: lookup_e_focus lpp_focus i.punit.lc_def)"], ["proof (state)\nthis:\n  lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n   (except (i.lpp g) {x}) =\n  poly_eval (\\<lambda>_. a) (i.lcf (focus X g))\n\ngoal (2 subgoals):\n 1. except (i.lpp g) {x}\n    \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n 2. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "also"], ["proof (state)\nthis:\n  lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n   (except (i.lpp g) {x}) =\n  poly_eval (\\<lambda>_. a) (i.lcf (focus X g))\n\ngoal (2 subgoals):\n 1. except (i.lpp g) {x}\n    \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n 2. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "from that"], ["proof (chain)\npicking this:\n  g \\<in> G", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> (0::'a)", "by (rule a_nz)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. a) (i.lcf (focus X g)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. except (i.lpp g) {x}\n    \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n 2. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "finally"], ["proof (chain)\npicking this:\n  lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n   (except (i.lpp g) {x}) \\<noteq>\n  (0::'a)", "show \"except (i.lpp g) {x} \\<in> keys (?e (focus {x} g))\""], ["proof (prove)\nusing this:\n  lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n   (except (i.lpp g) {x}) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. except (i.lpp g) {x}\n    \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  except (i.lpp g) {x}\n  \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "assume \"t \\<in> keys (?e (focus {x} g))\""], ["proof (state)\nthis:\n  t \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "hence \"0 \\<noteq> lookup (?e (focus {x} g)) t\""], ["proof (prove)\nusing this:\n  t \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))\n\ngoal (1 subgoal):\n 1. (0::'a) \\<noteq>\n    lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (0::'a) \\<noteq>\n  lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "also"], ["proof (state)\nthis:\n  (0::'a) \\<noteq>\n  lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "from \\<open>g \\<in> P[_]\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> P[insert x X]", "have \"lookup (?e (focus {x} g)) t = poly_eval (\\<lambda>_. a) (lookup (focus X g) t)\""], ["proof (prove)\nusing this:\n  g \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t =\n    poly_eval (\\<lambda>_. a) (lookup (focus X g) t)", "by (rule lookup_e_focus)"], ["proof (state)\nthis:\n  lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)) t =\n  poly_eval (\\<lambda>_. a) (lookup (focus X g) t)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "finally"], ["proof (chain)\npicking this:\n  (0::'a) \\<noteq> poly_eval (\\<lambda>_. a) (lookup (focus X g) t)", "have \"t \\<in> keys (focus X g)\""], ["proof (prove)\nusing this:\n  (0::'a) \\<noteq> poly_eval (\\<lambda>_. a) (lookup (focus X g) t)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (focus X g)", "by (auto simp flip: lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  t \\<in> keys (focus X g)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "hence \"lex_pm t (i.lpp (focus X g))\""], ["proof (prove)\nusing this:\n  t \\<in> keys (focus X g)\n\ngoal (1 subgoal):\n 1. lex_pm t (i.lpp (focus X g))", "by (rule i.punit.lt_max_keys)"], ["proof (state)\nthis:\n  lex_pm t (i.lpp (focus X g))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys\n                (poly_eval (\\<lambda>_. monomial a 0)\n                  (focus {x} g)) \\<Longrightarrow>\n       lex_pm u (except (i.lpp g) {x})", "with \\<open>g \\<in> P[_]\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> P[insert x X]\n  lex_pm t (i.lpp (focus X g))", "show \"lex_pm t (except (i.lpp g) {x})\""], ["proof (prove)\nusing this:\n  g \\<in> P[insert x X]\n  lex_pm t (i.lpp (focus X g))\n\ngoal (1 subgoal):\n 1. lex_pm t (except (i.lpp g) {x})", "by (simp only: lpp_focus)"], ["proof (state)\nthis:\n  lex_pm t (except (i.lpp g) {x})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?g2 \\<in> G \\<Longrightarrow>\n  i.lpp (poly_eval (\\<lambda>_. monomial a 0) (focus {x} ?g2)) =\n  except (i.lpp ?g2) {x}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "define G3 where \"G3 = ?e ` focus {x} ` G\""], ["proof (state)\nthis:\n  G3 = poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` G\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "have \"G3 \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G3 \\<subseteq> P[X]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G3 \\<Longrightarrow> x \\<in> P[X]", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G3 \\<Longrightarrow> x \\<in> P[X]", "assume \"h \\<in> G3\""], ["proof (state)\nthis:\n  h \\<in> G3\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G3 \\<Longrightarrow> x \\<in> P[X]", "then"], ["proof (chain)\npicking this:\n  h \\<in> G3", "obtain h0 where \"h0 \\<in> G\" and h: \"h = ?e (focus {x} h0)\""], ["proof (prove)\nusing this:\n  h \\<in> G3\n\ngoal (1 subgoal):\n 1. (\\<And>h0.\n        \\<lbrakk>h0 \\<in> G;\n         h = poly_eval (\\<lambda>_. monomial a 0) (focus {x} h0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: G3_def)"], ["proof (state)\nthis:\n  h0 \\<in> G\n  h = poly_eval (\\<lambda>_. monomial a 0) (focus {x} h0)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G3 \\<Longrightarrow> x \\<in> P[X]", "from this(1) G_sub"], ["proof (chain)\npicking this:\n  h0 \\<in> G\n  G \\<subseteq> P[insert x X]", "have \"h0 \\<in> P[insert x X]\""], ["proof (prove)\nusing this:\n  h0 \\<in> G\n  G \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. h0 \\<in> P[insert x X]", ".."], ["proof (state)\nthis:\n  h0 \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G3 \\<Longrightarrow> x \\<in> P[X]", "hence \"h \\<in> P[insert x X - {x}]\""], ["proof (prove)\nusing this:\n  h0 \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. h \\<in> P[insert x X - {x}]", "unfolding h"], ["proof (prove)\nusing this:\n  h0 \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a 0) (focus {x} h0)\n    \\<in> P[insert x X - {x}]", "by (rule poly_eval_focus_in_Polys)"], ["proof (state)\nthis:\n  h \\<in> P[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G3 \\<Longrightarrow> x \\<in> P[X]", "thus \"h \\<in> P[X]\""], ["proof (prove)\nusing this:\n  h \\<in> P[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. h \\<in> P[X]", "by (simp only: eq1)"], ["proof (state)\nthis:\n  h \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G3 \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "from fin_G"], ["proof (chain)\npicking this:\n  finite G", "have \"finite G3\""], ["proof (prove)\nusing this:\n  finite G\n\ngoal (1 subgoal):\n 1. finite G3", "by (simp add: G3_def)"], ["proof (state)\nthis:\n  finite G3\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "have \"ideal G3 \\<inter> P[- {x}] = ?e ` focus {x} ` ideal G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal G3 \\<inter> P[- {x}] =\n    poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` ideal G", "by (simp only: G3_def image_poly_eval_focus_ideal)"], ["proof (state)\nthis:\n  ideal G3 \\<inter> P[- {x}] =\n  poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` ideal G\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "also"], ["proof (state)\nthis:\n  ideal G3 \\<inter> P[- {x}] =\n  poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` ideal G\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "have \"\\<dots> = ideal (?e ` focus {x} ` F) \\<inter> P[- {x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` ideal G =\n    ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F) \\<inter>\n    P[- {x}]", "by (simp only: ideal_G image_poly_eval_focus_ideal)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` ideal G =\n  ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F) \\<inter>\n  P[- {x}]\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "finally"], ["proof (chain)\npicking this:\n  ideal G3 \\<inter> P[- {x}] =\n  ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F) \\<inter>\n  P[- {x}]", "have eq3: \"ideal G3 \\<inter> P[- {x}] = ideal (?e ` focus {x} ` F) \\<inter> P[- {x}]\""], ["proof (prove)\nusing this:\n  ideal G3 \\<inter> P[- {x}] =\n  ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F) \\<inter>\n  P[- {x}]\n\ngoal (1 subgoal):\n 1. ideal G3 \\<inter> P[- {x}] =\n    ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F) \\<inter>\n    P[- {x}]", "."], ["proof (state)\nthis:\n  ideal G3 \\<inter> P[- {x}] =\n  ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F) \\<inter>\n  P[- {x}]\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "from assms(1) \\<open>G3 \\<subseteq> P[X]\\<close> \\<open>finite G3\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  G3 \\<subseteq> P[X]\n  finite G3", "have G3_isGB: \"i.punit.is_Groebner_basis G3\""], ["proof (prove)\nusing this:\n  finite X\n  G3 \\<subseteq> P[X]\n  finite G3\n\ngoal (1 subgoal):\n 1. i.punit.is_Groebner_basis G3", "proof (rule i.punit.isGB_I_spoly_rep[simplified, OF dickson_grading_varnum,\n                                          where m=0, simplified i.dgrad_p_set_varnum])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "fix g1 g2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "assume \"g1 \\<in> G3\""], ["proof (state)\nthis:\n  g1 \\<in> G3\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "then"], ["proof (chain)\npicking this:\n  g1 \\<in> G3", "obtain g1' where \"g1' \\<in> G\" and g1: \"g1 = ?e (focus {x} g1')\""], ["proof (prove)\nusing this:\n  g1 \\<in> G3\n\ngoal (1 subgoal):\n 1. (\\<And>g1'.\n        \\<lbrakk>g1' \\<in> G;\n         g1 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g1')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding G3_def"], ["proof (prove)\nusing this:\n  g1 \\<in> poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` G\n\ngoal (1 subgoal):\n 1. (\\<And>g1'.\n        \\<lbrakk>g1' \\<in> G;\n         g1 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g1')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g1' \\<in> G\n  g1 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g1')\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "from this(1)"], ["proof (chain)\npicking this:\n  g1' \\<in> G", "have lpp1: \"i.lpp g1 = except (i.lpp g1') {x}\""], ["proof (prove)\nusing this:\n  g1' \\<in> G\n\ngoal (1 subgoal):\n 1. i.lpp g1 = except (i.lpp g1') {x}", "unfolding g1"], ["proof (prove)\nusing this:\n  g1' \\<in> G\n\ngoal (1 subgoal):\n 1. i.lpp (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g1')) =\n    except (i.lpp g1') {x}", "by (rule lpp_e_focus)"], ["proof (state)\nthis:\n  i.lpp g1 = except (i.lpp g1') {x}\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "from \\<open>g1' \\<in> G\\<close> G_sub"], ["proof (chain)\npicking this:\n  g1' \\<in> G\n  G \\<subseteq> P[insert x X]", "have \"g1' \\<in> P[insert x X]\""], ["proof (prove)\nusing this:\n  g1' \\<in> G\n  G \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. g1' \\<in> P[insert x X]", ".."], ["proof (state)\nthis:\n  g1' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "assume \"g2 \\<in> G3\""], ["proof (state)\nthis:\n  g2 \\<in> G3\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "then"], ["proof (chain)\npicking this:\n  g2 \\<in> G3", "obtain g2' where \"g2' \\<in> G\" and g2: \"g2 = ?e (focus {x} g2')\""], ["proof (prove)\nusing this:\n  g2 \\<in> G3\n\ngoal (1 subgoal):\n 1. (\\<And>g2'.\n        \\<lbrakk>g2' \\<in> G;\n         g2 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g2')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding G3_def"], ["proof (prove)\nusing this:\n  g2 \\<in> poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` G\n\ngoal (1 subgoal):\n 1. (\\<And>g2'.\n        \\<lbrakk>g2' \\<in> G;\n         g2 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g2')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g2' \\<in> G\n  g2 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g2')\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "from this(1)"], ["proof (chain)\npicking this:\n  g2' \\<in> G", "have lpp2: \"i.lpp g2 = except (i.lpp g2') {x}\""], ["proof (prove)\nusing this:\n  g2' \\<in> G\n\ngoal (1 subgoal):\n 1. i.lpp g2 = except (i.lpp g2') {x}", "unfolding g2"], ["proof (prove)\nusing this:\n  g2' \\<in> G\n\ngoal (1 subgoal):\n 1. i.lpp (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g2')) =\n    except (i.lpp g2') {x}", "by (rule lpp_e_focus)"], ["proof (state)\nthis:\n  i.lpp g2 = except (i.lpp g2') {x}\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "from \\<open>g2' \\<in> G\\<close> G_sub"], ["proof (chain)\npicking this:\n  g2' \\<in> G\n  G \\<subseteq> P[insert x X]", "have \"g2' \\<in> P[insert x X]\""], ["proof (prove)\nusing this:\n  g2' \\<in> G\n  G \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. g2' \\<in> P[insert x X]", ".."], ["proof (state)\nthis:\n  g2' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "define l where \"l = lcs (except (i.lpp g1') {x}) (except (i.lpp g2') {x})\""], ["proof (state)\nthis:\n  l = lcs (except (i.lpp g1') {x}) (except (i.lpp g2') {x})\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "define c1 where \"c1 = i.lcf (focus X g1')\""], ["proof (state)\nthis:\n  c1 = i.lcf (focus X g1')\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "define c2 where \"c2 = i.lcf (focus X g2')\""], ["proof (state)\nthis:\n  c2 = i.lcf (focus X g2')\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "define c where \"c = poly_eval (\\<lambda>_. a) c1 * poly_eval (\\<lambda>_. a) c2\""], ["proof (state)\nthis:\n  c = poly_eval (\\<lambda>_. a) c1 * poly_eval (\\<lambda>_. a) c2\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "define s where \"s = c2 * punit.monom_mult 1 (l - except (i.lpp g1') {x}) g1' -\n                          c1 * punit.monom_mult 1 (l - except (i.lpp g2') {x}) g2'\""], ["proof (state)\nthis:\n  s =\n  c2 * punit.monom_mult (1::'a) (l - except (i.lpp g1') {x}) g1' -\n  c1 * punit.monom_mult (1::'a) (l - except (i.lpp g2') {x}) g2'\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "have \"c1 \\<in> P[{x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 \\<in> P[{x}]", "unfolding c1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i.lcf (focus X g1') \\<in> P[{x}]", "using \\<open>g1' \\<in> G\\<close>"], ["proof (prove)\nusing this:\n  g1' \\<in> G\n\ngoal (1 subgoal):\n 1. i.lcf (focus X g1') \\<in> P[{x}]", "by (rule lcf_in)"], ["proof (state)\nthis:\n  c1 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "hence eval_c1: \"poly_eval (\\<lambda>_. monomial a 0) (focus {x} c1) = monomial (poly_eval (\\<lambda>_. a) c1) 0\""], ["proof (prove)\nusing this:\n  c1 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a 0) (focus {x} c1) =\n    monomial (poly_eval (\\<lambda>_. a) c1) 0", "by (simp add: focus_Polys poly_eval_sum poly_eval_monomial monomial_power_map_scale\n                  times_monomial_monomial flip: punit.monomial_prod_sum monomial_sum)\n           (simp add: poly_eval_alt)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a 0) (focus {x} c1) =\n  monomial (poly_eval (\\<lambda>_. a) c1) 0\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "have \"c2 \\<in> P[{x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 \\<in> P[{x}]", "unfolding c2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i.lcf (focus X g2') \\<in> P[{x}]", "using \\<open>g2' \\<in> G\\<close>"], ["proof (prove)\nusing this:\n  g2' \\<in> G\n\ngoal (1 subgoal):\n 1. i.lcf (focus X g2') \\<in> P[{x}]", "by (rule lcf_in)"], ["proof (state)\nthis:\n  c2 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "hence eval_c2: \"poly_eval (\\<lambda>_. monomial a 0) (focus {x} c2) = monomial (poly_eval (\\<lambda>_. a) c2) 0\""], ["proof (prove)\nusing this:\n  c2 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a 0) (focus {x} c2) =\n    monomial (poly_eval (\\<lambda>_. a) c2) 0", "by (simp add: focus_Polys poly_eval_sum poly_eval_monomial monomial_power_map_scale\n                  times_monomial_monomial flip: punit.monomial_prod_sum monomial_sum)\n           (simp add: poly_eval_alt)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a 0) (focus {x} c2) =\n  monomial (poly_eval (\\<lambda>_. a) c2) 0\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "assume spoly_nz: \"i.punit.spoly g1 g2 \\<noteq> 0\""], ["proof (state)\nthis:\n  i.punit.spoly g1 g2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "assume \"g1 \\<noteq> 0\" and \"g2 \\<noteq> 0\""], ["proof (state)\nthis:\n  g1 \\<noteq> 0\n  g2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "hence \"g1' \\<noteq> 0\" and \"g2' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  g1 \\<noteq> 0\n  g2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g1' \\<noteq> 0 &&& g2' \\<noteq> 0", "by (auto simp: g1 g2)"], ["proof (state)\nthis:\n  g1' \\<noteq> 0\n  g2' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "have c1_nz: \"poly_eval (\\<lambda>_. a) c1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) c1 \\<noteq> (0::'a)", "unfolding c1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g1')) \\<noteq> (0::'a)", "using \\<open>g1' \\<in> G\\<close>"], ["proof (prove)\nusing this:\n  g1' \\<in> G\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g1')) \\<noteq> (0::'a)", "by (rule a_nz)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. a) c1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "moreover"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. a) c1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "have c2_nz: \"poly_eval (\\<lambda>_. a) c2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) c2 \\<noteq> (0::'a)", "unfolding c2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g2')) \\<noteq> (0::'a)", "using \\<open>g2' \\<in> G\\<close>"], ["proof (prove)\nusing this:\n  g2' \\<in> G\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. a) (i.lcf (focus X g2')) \\<noteq> (0::'a)", "by (rule a_nz)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. a) c2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "ultimately"], ["proof (chain)\npicking this:\n  poly_eval (\\<lambda>_. a) c1 \\<noteq> (0::'a)\n  poly_eval (\\<lambda>_. a) c2 \\<noteq> (0::'a)", "have \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>_. a) c1 \\<noteq> (0::'a)\n  poly_eval (\\<lambda>_. a) c2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a)", "by (simp add: c_def)"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "hence \"inverse c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. inverse c \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  inverse c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "from \\<open>g1' \\<in> P[_]\\<close>"], ["proof (chain)\npicking this:\n  g1' \\<in> P[insert x X]", "have \"except (i.lpp g1') {x} \\<in> .[insert x X - {x}]\""], ["proof (prove)\nusing this:\n  g1' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. except (i.lpp g1') {x} \\<in> .[insert x X - {x}]", "by (intro PPs_closed_except' i.PPs_closed_lpp)"], ["proof (state)\nthis:\n  except (i.lpp g1') {x} \\<in> .[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "moreover"], ["proof (state)\nthis:\n  except (i.lpp g1') {x} \\<in> .[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "from \\<open>g2' \\<in> P[_]\\<close>"], ["proof (chain)\npicking this:\n  g2' \\<in> P[insert x X]", "have \"except (i.lpp g2') {x} \\<in> .[insert x X - {x}]\""], ["proof (prove)\nusing this:\n  g2' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. except (i.lpp g2') {x} \\<in> .[insert x X - {x}]", "by (intro PPs_closed_except' i.PPs_closed_lpp)"], ["proof (state)\nthis:\n  except (i.lpp g2') {x} \\<in> .[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "ultimately"], ["proof (chain)\npicking this:\n  except (i.lpp g1') {x} \\<in> .[insert x X - {x}]\n  except (i.lpp g2') {x} \\<in> .[insert x X - {x}]", "have \"l \\<in> .[insert x X - {x}]\""], ["proof (prove)\nusing this:\n  except (i.lpp g1') {x} \\<in> .[insert x X - {x}]\n  except (i.lpp g2') {x} \\<in> .[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. l \\<in> .[insert x X - {x}]", "unfolding l_def"], ["proof (prove)\nusing this:\n  except (i.lpp g1') {x} \\<in> .[insert x X - {x}]\n  except (i.lpp g2') {x} \\<in> .[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. lcs (except (i.lpp g1') {x}) (except (i.lpp g2') {x})\n    \\<in> .[insert x X - {x}]", "by (rule PPs_closed_lcs)"], ["proof (state)\nthis:\n  l \\<in> .[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "hence \"l \\<in> .[X]\""], ["proof (prove)\nusing this:\n  l \\<in> .[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. l \\<in> .[X]", "by (simp only: eq1)"], ["proof (state)\nthis:\n  l \\<in> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "hence \"l \\<in> .[insert x X]\""], ["proof (prove)\nusing this:\n  l \\<in> .[X]\n\ngoal (1 subgoal):\n 1. l \\<in> .[insert x X]", "by rule (rule PPs_mono, blast)"], ["proof (state)\nthis:\n  l \\<in> .[insert x X]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "moreover"], ["proof (state)\nthis:\n  l \\<in> .[insert x X]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "from \\<open>c1 \\<in> P[{x}]\\<close>"], ["proof (chain)\npicking this:\n  c1 \\<in> P[{x}]", "have \"c1 \\<in> P[insert x X]\""], ["proof (prove)\nusing this:\n  c1 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. c1 \\<in> P[insert x X]", "by rule (intro Polys_mono, simp)"], ["proof (state)\nthis:\n  c1 \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "moreover"], ["proof (state)\nthis:\n  c1 \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "from \\<open>c2 \\<in> P[{x}]\\<close>"], ["proof (chain)\npicking this:\n  c2 \\<in> P[{x}]", "have \"c2 \\<in> P[insert x X]\""], ["proof (prove)\nusing this:\n  c2 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. c2 \\<in> P[insert x X]", "by rule (intro Polys_mono, simp)"], ["proof (state)\nthis:\n  c2 \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "ultimately"], ["proof (chain)\npicking this:\n  l \\<in> .[insert x X]\n  c1 \\<in> P[insert x X]\n  c2 \\<in> P[insert x X]", "have \"s \\<in> P[insert x X]\""], ["proof (prove)\nusing this:\n  l \\<in> .[insert x X]\n  c1 \\<in> P[insert x X]\n  c2 \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. s \\<in> P[insert x X]", "using \\<open>g1' \\<in> P[_]\\<close> \\<open>g2' \\<in> P[_]\\<close>"], ["proof (prove)\nusing this:\n  l \\<in> .[insert x X]\n  c1 \\<in> P[insert x X]\n  c2 \\<in> P[insert x X]\n  g1' \\<in> P[insert x X]\n  g2' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. s \\<in> P[insert x X]", "unfolding s_def"], ["proof (prove)\nusing this:\n  l \\<in> .[insert x X]\n  c1 \\<in> P[insert x X]\n  c2 \\<in> P[insert x X]\n  g1' \\<in> P[insert x X]\n  g2' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. c2 * punit.monom_mult (1::'a) (l - except (i.lpp g1') {x}) g1' -\n    c1 * punit.monom_mult (1::'a) (l - except (i.lpp g2') {x}) g2'\n    \\<in> P[insert x X]", "by (intro Polys_closed_minus Polys_closed_times Polys_closed_monom_mult PPs_closed_minus)"], ["proof (state)\nthis:\n  s \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "have \"s \\<in> ideal G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> ideal G", "unfolding s_def times_monomial_left[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 * (monomial (1::'a) (l - except (i.lpp g1') {x}) * g1') -\n    c1 * (monomial (1::'a) (l - except (i.lpp g2') {x}) * g2')\n    \\<in> ideal G", "by (intro ideal.span_diff ideal.span_scale ideal.span_base \\<open>g1' \\<in> G\\<close> \\<open>g2' \\<in> G\\<close>)"], ["proof (state)\nthis:\n  s \\<in> ideal G\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "with G_isGB"], ["proof (chain)\npicking this:\n  i.punit.is_Groebner_basis G\n  s \\<in> ideal G", "have \"(i.punit.red G)\\<^sup>*\\<^sup>* s 0\""], ["proof (prove)\nusing this:\n  i.punit.is_Groebner_basis G\n  s \\<in> ideal G\n\ngoal (1 subgoal):\n 1. (i.punit.red G)\\<^sup>*\\<^sup>* s 0", "by (rule i.punit.GB_imp_zero_reducibility[simplified])"], ["proof (state)\nthis:\n  (i.punit.red G)\\<^sup>*\\<^sup>* s 0\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "with \\<open>finite (insert x X)\\<close> G_sub fin_G \\<open>s \\<in> P[_]\\<close>"], ["proof (chain)\npicking this:\n  finite (insert x X)\n  G \\<subseteq> P[insert x X]\n  finite G\n  s \\<in> P[insert x X]\n  (i.punit.red G)\\<^sup>*\\<^sup>* s 0", "obtain q0 where 1: \"s = 0 + (\\<Sum>g\\<in>G. q0 g * g)\" and 2: \"\\<And>g. q0 g \\<in> P[insert x X]\"\n        and 3: \"\\<And>g. lex_pm (i.lpp (q0 g * g)) (i.lpp s)\""], ["proof (prove)\nusing this:\n  finite (insert x X)\n  G \\<subseteq> P[insert x X]\n  finite G\n  s \\<in> P[insert x X]\n  (i.punit.red G)\\<^sup>*\\<^sup>* s 0\n\ngoal (1 subgoal):\n 1. (\\<And>q0.\n        \\<lbrakk>s = 0 + (\\<Sum>g\\<in>G. q0 g * g);\n         \\<And>g. q0 g \\<in> P[insert x X];\n         \\<And>g. lex_pm (i.lpp (q0 g * g)) (i.lpp s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule i.punit.red_rtrancl_repE[simplified, OF dickson_grading_varnum, where m=0,\n                                            simplified i.dgrad_p_set_varnum]) blast"], ["proof (state)\nthis:\n  s = 0 + (\\<Sum>g\\<in>G. q0 g * g)\n  q0 ?g2 \\<in> P[insert x X]\n  lex_pm (i.lpp (q0 ?g2 * ?g2)) (i.lpp s)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "define q where \"q = (\\<lambda>g. inverse c \\<cdot> (\\<Sum>h\\<in>{y\\<in>G. ?e (focus {x} y) = g}. ?e (focus {x} (q0 h))))\""], ["proof (state)\nthis:\n  q =\n  (\\<lambda>g.\n      inverse c \\<cdot>\n      (\\<Sum>h\\<in>{y \\<in> G.\n                    poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n         poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h))))\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "have eq4: \"?e (focus {x} (monomial 1 (l - t))) = monomial 1 (l - t)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a 0)\n     (focus {x} (monomial (1::'a) (l - t))) =\n    monomial (1::'a) (l - t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a 0)\n     (focus {x} (monomial (1::'a) (l - t))) =\n    monomial (1::'a) (l - t)", "have \"focus {x} (monomial (1::'a) (l - t)) = monomial (monomial 1 (l - t)) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus {x} (monomial (1::'a) (l - t)) =\n    monomial (monomial (1::'a) (l - t)) 0", "proof (intro focus_Polys_Compl Polys_closed_monomial PPs_closed_minus)"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<in> .[- {x}]", "from \\<open>x \\<notin> X\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> X", "have \"X \\<subseteq> - {x}\""], ["proof (prove)\nusing this:\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. X \\<subseteq> - {x}", "by simp"], ["proof (state)\nthis:\n  X \\<subseteq> - {x}\n\ngoal (1 subgoal):\n 1. l \\<in> .[- {x}]", "hence \".[X] \\<subseteq> .[- {x}]\""], ["proof (prove)\nusing this:\n  X \\<subseteq> - {x}\n\ngoal (1 subgoal):\n 1. .[X] \\<subseteq> .[- {x}]", "by (rule PPs_mono)"], ["proof (state)\nthis:\n  .[X] \\<subseteq> .[- {x}]\n\ngoal (1 subgoal):\n 1. l \\<in> .[- {x}]", "with \\<open>l \\<in> .[X]\\<close>"], ["proof (chain)\npicking this:\n  l \\<in> .[X]\n  .[X] \\<subseteq> .[- {x}]", "show \"l \\<in> .[- {x}]\""], ["proof (prove)\nusing this:\n  l \\<in> .[X]\n  .[X] \\<subseteq> .[- {x}]\n\ngoal (1 subgoal):\n 1. l \\<in> .[- {x}]", ".."], ["proof (state)\nthis:\n  l \\<in> .[- {x}]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  focus {x} (monomial (1::'a) (l - t)) =\n  monomial (monomial (1::'a) (l - t)) 0\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a 0)\n     (focus {x} (monomial (1::'a) (l - t))) =\n    monomial (1::'a) (l - t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  focus {x} (monomial (1::'a) (l - t)) =\n  monomial (monomial (1::'a) (l - t)) 0\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a 0)\n     (focus {x} (monomial (1::'a) (l - t))) =\n    monomial (1::'a) (l - t)", "by (simp add: poly_eval_monomial)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a 0)\n   (focus {x} (monomial (1::'a) (l - t))) =\n  monomial (1::'a) (l - t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a 0)\n   (focus {x} (monomial (1::'a) (l - ?t2))) =\n  monomial (1::'a) (l - ?t2)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "from c2_nz"], ["proof (chain)\npicking this:\n  poly_eval (\\<lambda>_. a) c2 \\<noteq> (0::'a)", "have eq5: \"inverse c * poly_eval (\\<lambda>_. a) c2 = 1 / lookup g1 (i.lpp g1)\""], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>_. a) c2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. inverse c * poly_eval (\\<lambda>_. a) c2 =\n    (1::'a) / lookup g1 (i.lpp g1)", "unfolding lpp1"], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>_. a) c2 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. inverse c * poly_eval (\\<lambda>_. a) c2 =\n    (1::'a) / lookup g1 (except (i.lpp g1') {x})", "using \\<open>g1' \\<in> P[_]\\<close>"], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>_. a) c2 \\<noteq> (0::'a)\n  g1' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. inverse c * poly_eval (\\<lambda>_. a) c2 =\n    (1::'a) / lookup g1 (except (i.lpp g1') {x})", "by (simp add: c_def mult.assoc divide_inverse_commute g1 lookup_e_focus\n                flip: lpp_focus i.punit.lc_def c1_def)"], ["proof (state)\nthis:\n  inverse c * poly_eval (\\<lambda>_. a) c2 = (1::'a) / lookup g1 (i.lpp g1)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "from c1_nz"], ["proof (chain)\npicking this:\n  poly_eval (\\<lambda>_. a) c1 \\<noteq> (0::'a)", "have eq6: \"inverse c * poly_eval (\\<lambda>_. a) c1 = 1 / lookup g2 (i.lpp g2)\""], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>_. a) c1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. inverse c * poly_eval (\\<lambda>_. a) c1 =\n    (1::'a) / lookup g2 (i.lpp g2)", "unfolding lpp2"], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>_. a) c1 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. inverse c * poly_eval (\\<lambda>_. a) c1 =\n    (1::'a) / lookup g2 (except (i.lpp g2') {x})", "using \\<open>g2' \\<in> P[_]\\<close>"], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>_. a) c1 \\<noteq> (0::'a)\n  g2' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. inverse c * poly_eval (\\<lambda>_. a) c1 =\n    (1::'a) / lookup g2 (except (i.lpp g2') {x})", "by (simp add: c_def mult.assoc mult.left_commute[of \"inverse (poly_eval (\\<lambda>_. a) c1)\"]\n                    divide_inverse_commute g2 lookup_e_focus flip: lpp_focus i.punit.lc_def c2_def)"], ["proof (state)\nthis:\n  inverse c * poly_eval (\\<lambda>_. a) c1 = (1::'a) / lookup g2 (i.lpp g2)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "have l_alt: \"l = lcs (i.lpp g1) (i.lpp g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = lcs (i.lpp g1) (i.lpp g2)", "by (simp only: l_def lpp1 lpp2)"], ["proof (state)\nthis:\n  l = lcs (i.lpp g1) (i.lpp g2)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "have spoly_eq: \"i.punit.spoly g1 g2 = (inverse c) \\<cdot> ?e (focus {x} s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i.punit.spoly g1 g2 =\n    inverse c \\<cdot> poly_eval (\\<lambda>_. monomial a 0) (focus {x} s)", "by (simp add: s_def focus_minus focus_times poly_eval_minus poly_eval_times eval_c1 eval_c2\n                      eq4 eq5 eq6 map_scale_eq_times times_monomial_monomial right_diff_distrib\n                      i.punit.spoly_def Let_def\n                 flip: mult.assoc times_monomial_left g1 g2 lpp1 lpp2 l_alt)"], ["proof (state)\nthis:\n  i.punit.spoly g1 g2 =\n  inverse c \\<cdot> poly_eval (\\<lambda>_. monomial a 0) (focus {x} s)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "also"], ["proof (state)\nthis:\n  i.punit.spoly g1 g2 =\n  inverse c \\<cdot> poly_eval (\\<lambda>_. monomial a 0) (focus {x} s)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "have \"\\<dots> = (\\<Sum>g\\<in>G. inverse c \\<cdot> (?e (focus {x} (q0 g)) * ?e (focus {x} g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse c \\<cdot> poly_eval (\\<lambda>_. monomial a 0) (focus {x} s) =\n    (\\<Sum>g\\<in>G.\n       inverse c \\<cdot>\n       (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g)) *\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)))", "by (simp add: 1 focus_sum poly_eval_sum focus_times poly_eval_times map_scale_sum_distrib_left)"], ["proof (state)\nthis:\n  inverse c \\<cdot> poly_eval (\\<lambda>_. monomial a 0) (focus {x} s) =\n  (\\<Sum>g\\<in>G.\n     inverse c \\<cdot>\n     (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g)) *\n      poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)))\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "also"], ["proof (state)\nthis:\n  inverse c \\<cdot> poly_eval (\\<lambda>_. monomial a 0) (focus {x} s) =\n  (\\<Sum>g\\<in>G.\n     inverse c \\<cdot>\n     (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g)) *\n      poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)))\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "have \"\\<dots> = (\\<Sum>g\\<in>G3. \\<Sum>h\\<in>{y\\<in>G. ?e (focus{x} y) = g}.\n                                      inverse c \\<cdot> (?e (focus {x} (q0 h)) * ?e (focus {x} h)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>g\\<in>G.\n       inverse c \\<cdot>\n       (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g)) *\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))) =\n    (\\<Sum>g\\<in>G3.\n       \\<Sum>h\\<in>{y \\<in> G.\n                    poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n         inverse c \\<cdot>\n         (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n          poly_eval (\\<lambda>_. monomial a 0) (focus {x} h)))", "unfolding G3_def image_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>g\\<in>G.\n       inverse c \\<cdot>\n       (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g)) *\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))) =\n    (\\<Sum>g\\<in>(\\<lambda>xa.\n                     poly_eval (\\<lambda>_. monomial a 0) (focus {x} xa)) `\n                 G.\n       \\<Sum>h\\<in>{y \\<in> G.\n                    poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n         inverse c \\<cdot>\n         (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n          poly_eval (\\<lambda>_. monomial a 0) (focus {x} h)))", "using fin_G"], ["proof (prove)\nusing this:\n  finite G\n\ngoal (1 subgoal):\n 1. (\\<Sum>g\\<in>G.\n       inverse c \\<cdot>\n       (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g)) *\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))) =\n    (\\<Sum>g\\<in>(\\<lambda>xa.\n                     poly_eval (\\<lambda>_. monomial a 0) (focus {x} xa)) `\n                 G.\n       \\<Sum>h\\<in>{y \\<in> G.\n                    poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n         inverse c \\<cdot>\n         (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n          poly_eval (\\<lambda>_. monomial a 0) (focus {x} h)))", "by (rule sum.image_gen)"], ["proof (state)\nthis:\n  (\\<Sum>g\\<in>G.\n     inverse c \\<cdot>\n     (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g)) *\n      poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))) =\n  (\\<Sum>g\\<in>G3.\n     \\<Sum>h\\<in>{y \\<in> G.\n                  poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n       inverse c \\<cdot>\n       (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} h)))\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "also"], ["proof (state)\nthis:\n  (\\<Sum>g\\<in>G.\n     inverse c \\<cdot>\n     (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g)) *\n      poly_eval (\\<lambda>_. monomial a 0) (focus {x} g))) =\n  (\\<Sum>g\\<in>G3.\n     \\<Sum>h\\<in>{y \\<in> G.\n                  poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n       inverse c \\<cdot>\n       (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} h)))\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "have \"\\<dots> = (\\<Sum>g\\<in>G3. inverse c \\<cdot> (\\<Sum>h\\<in>{y\\<in>G. ?e (focus{x} y) = g}. ?e (focus {x} (q0 h))) * g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>g\\<in>G3.\n       \\<Sum>h\\<in>{y \\<in> G.\n                    poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n         inverse c \\<cdot>\n         (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n          poly_eval (\\<lambda>_. monomial a 0) (focus {x} h))) =\n    (\\<Sum>g\\<in>G3.\n       inverse c \\<cdot>\n       (\\<Sum>h\\<in>{y \\<in> G.\n                     poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                     g}.\n          poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h))) *\n       g)", "by (intro sum.cong refl) (simp add: map_scale_eq_times sum_distrib_left sum_distrib_right mult.assoc)"], ["proof (state)\nthis:\n  (\\<Sum>g\\<in>G3.\n     \\<Sum>h\\<in>{y \\<in> G.\n                  poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n       inverse c \\<cdot>\n       (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} h))) =\n  (\\<Sum>g\\<in>G3.\n     inverse c \\<cdot>\n     (\\<Sum>h\\<in>{y \\<in> G.\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h))) *\n     g)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "also"], ["proof (state)\nthis:\n  (\\<Sum>g\\<in>G3.\n     \\<Sum>h\\<in>{y \\<in> G.\n                  poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n       inverse c \\<cdot>\n       (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} h))) =\n  (\\<Sum>g\\<in>G3.\n     inverse c \\<cdot>\n     (\\<Sum>h\\<in>{y \\<in> G.\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h))) *\n     g)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"\\<dots> = (\\<Sum>g\\<in>G3. q g * g)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>g\\<in>G3.\n       inverse c \\<cdot>\n       (\\<Sum>h\\<in>{y \\<in> G.\n                     poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                     g}.\n          poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h))) *\n       g) =\n    (\\<Sum>g\\<in>G3. q g * g)", "by (rule sum.cong) (simp add: q_def sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>g\\<in>G3.\n     inverse c \\<cdot>\n     (\\<Sum>h\\<in>{y \\<in> G.\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h))) *\n     g) =\n  (\\<Sum>g\\<in>G3. q g * g)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "finally"], ["proof (chain)\npicking this:\n  i.punit.spoly g1 g2 = (\\<Sum>g\\<in>G3. q g * g)", "have \"i.punit.spoly g1 g2 = (\\<Sum>g\\<in>G3. q g * g)\""], ["proof (prove)\nusing this:\n  i.punit.spoly g1 g2 = (\\<Sum>g\\<in>G3. q g * g)\n\ngoal (1 subgoal):\n 1. i.punit.spoly g1 g2 = (\\<Sum>g\\<in>G3. q g * g)", "."], ["proof (state)\nthis:\n  i.punit.spoly g1 g2 = (\\<Sum>g\\<in>G3. q g * g)\n\ngoal (1 subgoal):\n 1. \\<And>g1 g2.\n       \\<lbrakk>g1 \\<in> G3; g2 \\<in> G3; g1 \\<noteq> 0; g2 \\<noteq> 0;\n        i.punit.spoly g1 g2 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "thus \"i.punit.spoly_rep (varnum X) 0 G3 g1 g2\""], ["proof (prove)\nusing this:\n  i.punit.spoly g1 g2 = (\\<Sum>g\\<in>G3. q g * g)\n\ngoal (1 subgoal):\n 1. i.punit.spoly_rep (varnum X) 0 G3 g1 g2", "proof (rule i.punit.spoly_repI[simplified, where m=0 and d=\"varnum X\",\n                                        simplified i.dgrad_p_set_varnum])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g. q g \\<in> P[X]\n 2. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "fix g"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g. q g \\<in> P[X]\n 2. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "show \"q g \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q g \\<in> P[X]", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse c \\<cdot>\n    (\\<Sum>h\\<in>{y \\<in> G.\n                  poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)))\n    \\<in> P[X]", "proof (intro Polys_closed_map_scale Polys_closed_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                 g} \\<Longrightarrow>\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 aa)) \\<in> P[X]", "fix g0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                 g} \\<Longrightarrow>\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 aa)) \\<in> P[X]", "from \\<open>q0 g0 \\<in> P[insert x X]\\<close>"], ["proof (chain)\npicking this:\n  q0 g0 \\<in> P[insert x X]", "have \"?e (focus {x} (q0 g0)) \\<in> P[insert x X - {x}]\""], ["proof (prove)\nusing this:\n  q0 g0 \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g0))\n    \\<in> P[insert x X - {x}]", "by (rule poly_eval_focus_in_Polys)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g0))\n  \\<in> P[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                 g} \\<Longrightarrow>\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 aa)) \\<in> P[X]", "thus \"?e (focus {x} (q0 g0)) \\<in> P[X]\""], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g0))\n  \\<in> P[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g0)) \\<in> P[X]", "by (simp only: eq1)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 g0)) \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q g \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "assume \"q g \\<noteq> 0 \\<and> g \\<noteq> 0\""], ["proof (state)\nthis:\n  q g \\<noteq> 0 \\<and> g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "hence \"q g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q g \\<noteq> 0 \\<and> g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q g \\<noteq> 0", ".."], ["proof (state)\nthis:\n  q g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "have \"i.lpp (q g * g) = i.lpp (\\<Sum>h\\<in>{y\\<in>G. ?e (focus {x} y) = g}. inverse c \\<cdot> ?e (focus {x} (q0 h)) * g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i.lpp (q g * g) =\n    i.lpp\n     (\\<Sum>h\\<in>{y \\<in> G.\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n        inverse c \\<cdot>\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        g)", "by (simp add: q_def map_scale_sum_distrib_left sum_distrib_right)"], ["proof (state)\nthis:\n  i.lpp (q g * g) =\n  i.lpp\n   (\\<Sum>h\\<in>{y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n      inverse c \\<cdot>\n      poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n      g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "also"], ["proof (state)\nthis:\n  i.lpp (q g * g) =\n  i.lpp\n   (\\<Sum>h\\<in>{y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n      inverse c \\<cdot>\n      poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n      g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "have \"lex_pm \\<dots> (i.ordered_powerprod_lin.Max\n                {i.lpp (inverse c \\<cdot> ?e (focus {x} (q0 h)) * g) | h. h \\<in> {y\\<in>G. ?e (focus {x} y) = g}})\"\n          (is \"lex_pm _ (i.ordered_powerprod_lin.Max ?A)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm\n     (i.lpp\n       (\\<Sum>h\\<in>{y \\<in> G.\n                     poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                     g}.\n          inverse c \\<cdot>\n          poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n          g))\n     (i.ordered_powerprod_lin.Max\n       {i.lpp\n         (inverse c \\<cdot>\n          poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n          g) |\n        h. h \\<in> {y \\<in> G.\n                    poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                    g}})", "by (fact i.punit.lt_sum_le_Max)"], ["proof (state)\nthis:\n  lex_pm\n   (i.lpp\n     (\\<Sum>h\\<in>{y \\<in> G.\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n        inverse c \\<cdot>\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        g))\n   (i.ordered_powerprod_lin.Max\n     {i.lpp\n       (inverse c \\<cdot>\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        g) |\n      h. h \\<in> {y \\<in> G.\n                  poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}})\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "also"], ["proof (state)\nthis:\n  lex_pm\n   (i.lpp\n     (\\<Sum>h\\<in>{y \\<in> G.\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}.\n        inverse c \\<cdot>\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        g))\n   (i.ordered_powerprod_lin.Max\n     {i.lpp\n       (inverse c \\<cdot>\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        g) |\n      h. h \\<in> {y \\<in> G.\n                  poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}})\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "have \"lex_pm \\<dots> (i.lpp s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm\n     (i.ordered_powerprod_lin.Max\n       {i.lpp\n         (inverse c \\<cdot>\n          poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n          g) |\n        h. h \\<in> {y \\<in> G.\n                    poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                    g}})\n     (i.lpp s)", "proof (rule i.ordered_powerprod_lin.Max.boundedI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite\n     {i.lpp\n       (inverse c \\<cdot>\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        g) |\n      h. h \\<in> {y \\<in> G.\n                  poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}}\n 2. {i.lpp\n      (inverse c \\<cdot>\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n       g) |\n     h. h \\<in> {y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                 g}} \\<noteq>\n    {}\n 3. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "from fin_G"], ["proof (chain)\npicking this:\n  finite G", "show \"finite ?A\""], ["proof (prove)\nusing this:\n  finite G\n\ngoal (1 subgoal):\n 1. finite\n     {i.lpp\n       (inverse c \\<cdot>\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        g) |\n      h. h \\<in> {y \\<in> G.\n                  poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}}", "by simp"], ["proof (state)\nthis:\n  finite\n   {i.lpp\n     (inverse c \\<cdot>\n      poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n      g) |\n    h. h \\<in> {y \\<in> G.\n                poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}}\n\ngoal (2 subgoals):\n 1. {i.lpp\n      (inverse c \\<cdot>\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n       g) |\n     h. h \\<in> {y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                 g}} \\<noteq>\n    {}\n 2. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. {i.lpp\n      (inverse c \\<cdot>\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n       g) |\n     h. h \\<in> {y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                 g}} \\<noteq>\n    {}\n 2. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "show \"?A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i.lpp\n      (inverse c \\<cdot>\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n       g) |\n     h. h \\<in> {y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                 g}} \\<noteq>\n    {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. {i.lpp\n      (inverse c \\<cdot>\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n       g) |\n     h. h \\<in> {y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}} =\n    {} \\<Longrightarrow>\n    False", "assume \"?A = {}\""], ["proof (state)\nthis:\n  {i.lpp\n    (inverse c \\<cdot>\n     poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n     g) |\n   h. h \\<in> {y \\<in> G.\n               poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}} =\n  {}\n\ngoal (1 subgoal):\n 1. {i.lpp\n      (inverse c \\<cdot>\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n       g) |\n     h. h \\<in> {y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}} =\n    {} \\<Longrightarrow>\n    False", "hence \"{h \\<in> G. ?e (focus {x} h) = g} = {}\""], ["proof (prove)\nusing this:\n  {i.lpp\n    (inverse c \\<cdot>\n     poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n     g) |\n   h. h \\<in> {y \\<in> G.\n               poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}} =\n  {}\n\ngoal (1 subgoal):\n 1. {h \\<in> G. poly_eval (\\<lambda>_. monomial a 0) (focus {x} h) = g} = {}", "by simp"], ["proof (state)\nthis:\n  {h \\<in> G. poly_eval (\\<lambda>_. monomial a 0) (focus {x} h) = g} = {}\n\ngoal (1 subgoal):\n 1. {i.lpp\n      (inverse c \\<cdot>\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n       g) |\n     h. h \\<in> {y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}} =\n    {} \\<Longrightarrow>\n    False", "hence \"q g = 0\""], ["proof (prove)\nusing this:\n  {h \\<in> G. poly_eval (\\<lambda>_. monomial a 0) (focus {x} h) = g} = {}\n\ngoal (1 subgoal):\n 1. q g = 0", "by (simp only: q_def sum.empty map_scale_zero_right)"], ["proof (state)\nthis:\n  q g = 0\n\ngoal (1 subgoal):\n 1. {i.lpp\n      (inverse c \\<cdot>\n       poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n       g) |\n     h. h \\<in> {y \\<in> G.\n                 poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}} =\n    {} \\<Longrightarrow>\n    False", "with \\<open>q g \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  q g \\<noteq> 0\n  q g = 0", "show False"], ["proof (prove)\nusing this:\n  q g \\<noteq> 0\n  q g = 0\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {i.lpp\n    (inverse c \\<cdot>\n     poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n     g) |\n   h. h \\<in> {y \\<in> G.\n               poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n               g}} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "assume \"t \\<in> ?A\""], ["proof (state)\nthis:\n  t \\<in> {i.lpp\n            (inverse c \\<cdot>\n             poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n             g) |\n           h. h \\<in> {y \\<in> G.\n                       poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                       g}}\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "then"], ["proof (chain)\npicking this:\n  t \\<in> {i.lpp\n            (inverse c \\<cdot>\n             poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n             g) |\n           h. h \\<in> {y \\<in> G.\n                       poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                       g}}", "obtain h where \"h \\<in> G\" and g[symmetric]: \"?e (focus {x} h) = g\"\n            and \"t = i.lpp (inverse c \\<cdot> ?e (focus {x} (q0 h)) * g)\""], ["proof (prove)\nusing this:\n  t \\<in> {i.lpp\n            (inverse c \\<cdot>\n             poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n             g) |\n           h. h \\<in> {y \\<in> G.\n                       poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) =\n                       g}}\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> G;\n         poly_eval (\\<lambda>_. monomial a 0) (focus {x} h) = g;\n         t =\n         i.lpp\n          (inverse c \\<cdot>\n           poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n           g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  h \\<in> G\n  g = poly_eval (\\<lambda>_. monomial a 0) (focus {x} h)\n  t =\n  i.lpp\n   (inverse c \\<cdot>\n    poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n    g)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "note this(3)"], ["proof (state)\nthis:\n  t =\n  i.lpp\n   (inverse c \\<cdot>\n    poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n    g)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "also"], ["proof (state)\nthis:\n  t =\n  i.lpp\n   (inverse c \\<cdot>\n    poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n    g)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "have \"i.lpp (inverse c \\<cdot> ?e (focus {x} (q0 h)) * g) =\n                      i.lpp (inverse c \\<cdot> (?e (focus {x} (q0 h * h))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i.lpp\n     (inverse c \\<cdot>\n      poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n      g) =\n    i.lpp\n     (inverse c \\<cdot>\n      poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))", "by (simp only: map_scale_eq_times mult.assoc g poly_eval_times focus_times)"], ["proof (state)\nthis:\n  i.lpp\n   (inverse c \\<cdot>\n    poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n    g) =\n  i.lpp\n   (inverse c \\<cdot>\n    poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "also"], ["proof (state)\nthis:\n  i.lpp\n   (inverse c \\<cdot>\n    poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n    g) =\n  i.lpp\n   (inverse c \\<cdot>\n    poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "from \\<open>inverse c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  inverse c \\<noteq> (0::'a)", "have \"\\<dots> = i.lpp (?e (focus {x} (q0 h * h)))\""], ["proof (prove)\nusing this:\n  inverse c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. i.lpp\n     (inverse c \\<cdot>\n      poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h))) =\n    i.lpp (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))", "by (rule i.punit.lt_map_scale)"], ["proof (state)\nthis:\n  i.lpp\n   (inverse c \\<cdot>\n    poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h))) =\n  i.lpp (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "also"], ["proof (state)\nthis:\n  i.lpp\n   (inverse c \\<cdot>\n    poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h))) =\n  i.lpp (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "have \"lex_pm \\<dots> (i.lpp (q0 h * h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm\n     (i.lpp (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h))))\n     (i.lpp (q0 h * h))", "proof (rule i.punit.lt_le, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"lookup (?e (focus {x} (q0 h * h))) u \\<noteq> 0\""], ["proof (state)\nthis:\n  lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n   u \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"u \\<in> keys (?e (focus {x} (q0 h * h)))\""], ["proof (prove)\nusing this:\n  lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n   u \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. u \\<in> keys\n             (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  u \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "with keys_poly_eval_focus_subset"], ["proof (chain)\npicking this:\n  keys (poly_eval (\\<lambda>x. monomial (?a x) 0) (focus ?X ?p))\n  \\<subseteq> (\\<lambda>t. except t ?X) ` keys ?p\n  u \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))", "have \"u \\<in> (\\<lambda>v. except v {x}) ` keys (q0 h * h)\""], ["proof (prove)\nusing this:\n  keys (poly_eval (\\<lambda>x. monomial (?a x) 0) (focus ?X ?p))\n  \\<subseteq> (\\<lambda>t. except t ?X) ` keys ?p\n  u \\<in> keys (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n\ngoal (1 subgoal):\n 1. u \\<in> (\\<lambda>v. except v {x}) ` keys (q0 h * h)", ".."], ["proof (state)\nthis:\n  u \\<in> (\\<lambda>v. except v {x}) ` keys (q0 h * h)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  u \\<in> (\\<lambda>v. except v {x}) ` keys (q0 h * h)", "obtain v where \"v \\<in> keys (q0 h * h)\" and u: \"u = except v {x}\""], ["proof (prove)\nusing this:\n  u \\<in> (\\<lambda>v. except v {x}) ` keys (q0 h * h)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> keys (q0 h * h); u = except v {x}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> keys (q0 h * h)\n  u = except v {x}\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"lex_pm u (Poly_Mapping.single x (lookup v x) + u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm u (monomial (lookup v x) x + u)", "by (metis add.commute add.right_neutral i.plus_monotone_left lex_pm_zero_min)"], ["proof (state)\nthis:\n  lex_pm u (monomial (lookup v x) x + u)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lex_pm u (monomial (lookup v x) x + u)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<dots> = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (lookup v x) x + u = v", "by (simp only: u flip: plus_except)"], ["proof (state)\nthis:\n  monomial (lookup v x) x + u = v\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  monomial (lookup v x) x + u = v\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>v \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> keys (q0 h * h)", "have \"lex_pm v (i.lpp (q0 h * h))\""], ["proof (prove)\nusing this:\n  v \\<in> keys (q0 h * h)\n\ngoal (1 subgoal):\n 1. lex_pm v (i.lpp (q0 h * h))", "by (rule i.punit.lt_max_keys)"], ["proof (state)\nthis:\n  lex_pm v (i.lpp (q0 h * h))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  lex_pm u (i.lpp (q0 h * h))", "have \"lex_pm u (i.lpp (q0 h * h))\""], ["proof (prove)\nusing this:\n  lex_pm u (i.lpp (q0 h * h))\n\ngoal (1 subgoal):\n 1. lex_pm u (i.lpp (q0 h * h))", "."], ["proof (state)\nthis:\n  lex_pm u (i.lpp (q0 h * h))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  lex_pm u (i.lpp (q0 h * h))\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"lex_pm_strict (i.lpp (q0 h * h)) u\""], ["proof (state)\nthis:\n  lex_pm_strict (i.lpp (q0 h * h)) u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>lex_pm_strict (i.lpp (q0 h * h)) u;\n        lookup (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h)))\n         u \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  lex_pm u (i.lpp (q0 h * h))\n  lex_pm_strict (i.lpp (q0 h * h)) u", "show False"], ["proof (prove)\nusing this:\n  lex_pm u (i.lpp (q0 h * h))\n  lex_pm_strict (i.lpp (q0 h * h)) u\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_pm\n   (i.lpp (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h))))\n   (i.lpp (q0 h * h))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "also"], ["proof (state)\nthis:\n  lex_pm\n   (i.lpp (poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h * h))))\n   (i.lpp (q0 h * h))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "have \"lex_pm \\<dots> (i.lpp s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm (i.lpp (q0 h * h)) (i.lpp s)", "by fact"], ["proof (state)\nthis:\n  lex_pm (i.lpp (q0 h * h)) (i.lpp s)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       aa \\<in> {i.lpp\n                  (inverse c \\<cdot>\n                   poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n                   g) |\n                 h. h \\<in> {y \\<in> G.\n                             poly_eval (\\<lambda>_. monomial a 0)\n                              (focus {x} y) =\n                             g}} \\<Longrightarrow>\n       lex_pm aa (i.lpp s)", "finally"], ["proof (chain)\npicking this:\n  lex_pm t (i.lpp s)", "show \"lex_pm t (i.lpp s)\""], ["proof (prove)\nusing this:\n  lex_pm t (i.lpp s)\n\ngoal (1 subgoal):\n 1. lex_pm t (i.lpp s)", "."], ["proof (state)\nthis:\n  lex_pm t (i.lpp s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_pm\n   (i.ordered_powerprod_lin.Max\n     {i.lpp\n       (inverse c \\<cdot>\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        g) |\n      h. h \\<in> {y \\<in> G.\n                  poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}})\n   (i.lpp s)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "also"], ["proof (state)\nthis:\n  lex_pm\n   (i.ordered_powerprod_lin.Max\n     {i.lpp\n       (inverse c \\<cdot>\n        poly_eval (\\<lambda>_. monomial a 0) (focus {x} (q0 h)) *\n        g) |\n      h. h \\<in> {y \\<in> G.\n                  poly_eval (\\<lambda>_. monomial a 0) (focus {x} y) = g}})\n   (i.lpp s)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "have \"lex_pm_strict \\<dots> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm_strict (i.lpp s) l", "proof (rule i.punit.lt_less)"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<noteq> 0\n 2. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "from spoly_nz"], ["proof (chain)\npicking this:\n  i.punit.spoly g1 g2 \\<noteq> 0", "show \"s \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i.punit.spoly g1 g2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0", "by (auto simp: spoly_eq)"], ["proof (state)\nthis:\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "assume \"lex_pm l t\""], ["proof (state)\nthis:\n  lex_pm l t\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "have \"g1' = flatten (focus X g1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g1' = flatten (focus X g1')", "by simp"], ["proof (state)\nthis:\n  g1' = flatten (focus X g1')\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "also"], ["proof (state)\nthis:\n  g1' = flatten (focus X g1')\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "have \"\\<dots> = flatten (monomial c1 (i.lpp (focus X g1')) + i.punit.tail (focus X g1'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (focus X g1') =\n    flatten (monomial c1 (i.lpp (focus X g1')) + i.punit.tail (focus X g1'))", "by (simp only: c1_def flip: i.punit.leading_monomial_tail)"], ["proof (state)\nthis:\n  flatten (focus X g1') =\n  flatten (monomial c1 (i.lpp (focus X g1')) + i.punit.tail (focus X g1'))\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "also"], ["proof (state)\nthis:\n  flatten (focus X g1') =\n  flatten (monomial c1 (i.lpp (focus X g1')) + i.punit.tail (focus X g1'))\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "from \\<open>g1' \\<in> P[_]\\<close>"], ["proof (chain)\npicking this:\n  g1' \\<in> P[insert x X]", "have \"\\<dots> = punit.monom_mult 1 (except (i.lpp g1') {x}) c1 +\n                                              flatten (i.punit.tail (focus X g1'))\""], ["proof (prove)\nusing this:\n  g1' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. flatten\n     (monomial c1 (i.lpp (focus X g1')) + i.punit.tail (focus X g1')) =\n    punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n    flatten (i.punit.tail (focus X g1'))", "by (simp only: flatten_plus flatten_monomial lpp_focus)"], ["proof (state)\nthis:\n  flatten (monomial c1 (i.lpp (focus X g1')) + i.punit.tail (focus X g1')) =\n  punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n  flatten (i.punit.tail (focus X g1'))\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  g1' =\n  punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n  flatten (i.punit.tail (focus X g1'))", "have \"punit.monom_mult 1 (except (i.lpp g1') {x}) c1 +\n                              flatten (i.punit.tail (focus X g1')) = g1'\" (is \"?l = _\")"], ["proof (prove)\nusing this:\n  g1' =\n  punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n  flatten (i.punit.tail (focus X g1'))\n\ngoal (1 subgoal):\n 1. punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n    flatten (i.punit.tail (focus X g1')) =\n    g1'", "by (rule sym)"], ["proof (state)\nthis:\n  punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n  flatten (i.punit.tail (focus X g1')) =\n  g1'\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "moreover"], ["proof (state)\nthis:\n  punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n  flatten (i.punit.tail (focus X g1')) =\n  g1'\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "have \"c2 * punit.monom_mult 1 (l - except (i.lpp g1') {x}) ?l =\n                          punit.monom_mult 1 l (c1 * c2) +\n                          c2 * punit.monom_mult 1 (l - i.lpp (focus X g1'))\n                                                  (flatten (i.punit.tail (focus X g1')))\"\n            (is \"_ = punit.monom_mult 1 l (c1 * c2) + ?a\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. c2 *\n    punit.monom_mult (1::'a) (l - except (i.lpp g1') {x})\n     (punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n      flatten (i.punit.tail (focus X g1'))) =\n    punit.monom_mult (1::'a) l (c1 * c2) +\n    c2 *\n    punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n     (flatten (i.punit.tail (focus X g1')))", "by (simp add: punit.monom_mult_dist_right punit.monom_mult_assoc l_def minus_plus adds_lcs)\n               (simp add: distrib_left lpp_focus \\<open>g1' \\<in> P[_]\\<close> flip: times_monomial_left)"], ["proof (state)\nthis:\n  c2 *\n  punit.monom_mult (1::'a) (l - except (i.lpp g1') {x})\n   (punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n    flatten (i.punit.tail (focus X g1'))) =\n  punit.monom_mult (1::'a) l (c1 * c2) +\n  c2 *\n  punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n   (flatten (i.punit.tail (focus X g1')))\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n  flatten (i.punit.tail (focus X g1')) =\n  g1'\n  c2 *\n  punit.monom_mult (1::'a) (l - except (i.lpp g1') {x})\n   (punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n    flatten (i.punit.tail (focus X g1'))) =\n  punit.monom_mult (1::'a) l (c1 * c2) +\n  c2 *\n  punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n   (flatten (i.punit.tail (focus X g1')))", "have a: \"c2 * punit.monom_mult 1 (l - except (i.lpp g1') {x}) g1' =\n                                punit.monom_mult 1 l (c1 * c2) + ?a\""], ["proof (prove)\nusing this:\n  punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n  flatten (i.punit.tail (focus X g1')) =\n  g1'\n  c2 *\n  punit.monom_mult (1::'a) (l - except (i.lpp g1') {x})\n   (punit.monom_mult (1::'a) (except (i.lpp g1') {x}) c1 +\n    flatten (i.punit.tail (focus X g1'))) =\n  punit.monom_mult (1::'a) l (c1 * c2) +\n  c2 *\n  punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n   (flatten (i.punit.tail (focus X g1')))\n\ngoal (1 subgoal):\n 1. c2 * punit.monom_mult (1::'a) (l - except (i.lpp g1') {x}) g1' =\n    punit.monom_mult (1::'a) l (c1 * c2) +\n    c2 *\n    punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n     (flatten (i.punit.tail (focus X g1')))", "by simp"], ["proof (state)\nthis:\n  c2 * punit.monom_mult (1::'a) (l - except (i.lpp g1') {x}) g1' =\n  punit.monom_mult (1::'a) l (c1 * c2) +\n  c2 *\n  punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n   (flatten (i.punit.tail (focus X g1')))\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "have \"g2' = flatten (focus X g2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g2' = flatten (focus X g2')", "by simp"], ["proof (state)\nthis:\n  g2' = flatten (focus X g2')\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "also"], ["proof (state)\nthis:\n  g2' = flatten (focus X g2')\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "have \"\\<dots> = flatten (monomial c2 (i.lpp (focus X g2')) + i.punit.tail (focus X g2'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (focus X g2') =\n    flatten (monomial c2 (i.lpp (focus X g2')) + i.punit.tail (focus X g2'))", "by (simp only: c2_def flip: i.punit.leading_monomial_tail)"], ["proof (state)\nthis:\n  flatten (focus X g2') =\n  flatten (monomial c2 (i.lpp (focus X g2')) + i.punit.tail (focus X g2'))\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "also"], ["proof (state)\nthis:\n  flatten (focus X g2') =\n  flatten (monomial c2 (i.lpp (focus X g2')) + i.punit.tail (focus X g2'))\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "from \\<open>g2' \\<in> P[_]\\<close>"], ["proof (chain)\npicking this:\n  g2' \\<in> P[insert x X]", "have \"\\<dots> = punit.monom_mult 1 (except (i.lpp g2') {x}) c2 +\n                                              flatten (i.punit.tail (focus X g2'))\""], ["proof (prove)\nusing this:\n  g2' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. flatten\n     (monomial c2 (i.lpp (focus X g2')) + i.punit.tail (focus X g2')) =\n    punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n    flatten (i.punit.tail (focus X g2'))", "by (simp only: flatten_plus flatten_monomial lpp_focus)"], ["proof (state)\nthis:\n  flatten (monomial c2 (i.lpp (focus X g2')) + i.punit.tail (focus X g2')) =\n  punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n  flatten (i.punit.tail (focus X g2'))\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  g2' =\n  punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n  flatten (i.punit.tail (focus X g2'))", "have \"punit.monom_mult 1 (except (i.lpp g2') {x}) c2 +\n                              flatten (i.punit.tail (focus X g2')) = g2'\" (is \"?l = _\")"], ["proof (prove)\nusing this:\n  g2' =\n  punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n  flatten (i.punit.tail (focus X g2'))\n\ngoal (1 subgoal):\n 1. punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n    flatten (i.punit.tail (focus X g2')) =\n    g2'", "by (rule sym)"], ["proof (state)\nthis:\n  punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n  flatten (i.punit.tail (focus X g2')) =\n  g2'\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "moreover"], ["proof (state)\nthis:\n  punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n  flatten (i.punit.tail (focus X g2')) =\n  g2'\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "have \"c1 * punit.monom_mult 1 (l - except (i.lpp g2') {x}) ?l =\n                          punit.monom_mult 1 l (c1 * c2) +\n                          c1 * punit.monom_mult 1 (l - i.lpp (focus X g2'))\n                                                  (flatten (i.punit.tail (focus X g2')))\"\n            (is \"_ = punit.monom_mult 1 l (c1 * c2) + ?b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. c1 *\n    punit.monom_mult (1::'a) (l - except (i.lpp g2') {x})\n     (punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n      flatten (i.punit.tail (focus X g2'))) =\n    punit.monom_mult (1::'a) l (c1 * c2) +\n    c1 *\n    punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n     (flatten (i.punit.tail (focus X g2')))", "by (simp add: punit.monom_mult_dist_right punit.monom_mult_assoc l_def minus_plus adds_lcs_2)\n               (simp add: distrib_left lpp_focus \\<open>g2' \\<in> P[_]\\<close> flip: times_monomial_left)"], ["proof (state)\nthis:\n  c1 *\n  punit.monom_mult (1::'a) (l - except (i.lpp g2') {x})\n   (punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n    flatten (i.punit.tail (focus X g2'))) =\n  punit.monom_mult (1::'a) l (c1 * c2) +\n  c1 *\n  punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n   (flatten (i.punit.tail (focus X g2')))\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n  flatten (i.punit.tail (focus X g2')) =\n  g2'\n  c1 *\n  punit.monom_mult (1::'a) (l - except (i.lpp g2') {x})\n   (punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n    flatten (i.punit.tail (focus X g2'))) =\n  punit.monom_mult (1::'a) l (c1 * c2) +\n  c1 *\n  punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n   (flatten (i.punit.tail (focus X g2')))", "have b: \"c1 * punit.monom_mult 1 (l - except (i.lpp g2') {x}) g2' =\n                                punit.monom_mult 1 l (c1 * c2) + ?b\""], ["proof (prove)\nusing this:\n  punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n  flatten (i.punit.tail (focus X g2')) =\n  g2'\n  c1 *\n  punit.monom_mult (1::'a) (l - except (i.lpp g2') {x})\n   (punit.monom_mult (1::'a) (except (i.lpp g2') {x}) c2 +\n    flatten (i.punit.tail (focus X g2'))) =\n  punit.monom_mult (1::'a) l (c1 * c2) +\n  c1 *\n  punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n   (flatten (i.punit.tail (focus X g2')))\n\ngoal (1 subgoal):\n 1. c1 * punit.monom_mult (1::'a) (l - except (i.lpp g2') {x}) g2' =\n    punit.monom_mult (1::'a) l (c1 * c2) +\n    c1 *\n    punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n     (flatten (i.punit.tail (focus X g2')))", "by simp"], ["proof (state)\nthis:\n  c1 * punit.monom_mult (1::'a) (l - except (i.lpp g2') {x}) g2' =\n  punit.monom_mult (1::'a) l (c1 * c2) +\n  c1 *\n  punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n   (flatten (i.punit.tail (focus X g2')))\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "have lex_pm_strict_t: \"lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))\"\n            if \"t \\<in> keys (d * punit.monom_mult 1 (l - i.lpp (focus X h))\n                                            (flatten (i.punit.tail (focus X h))))\"\n            and \"h \\<in> G\" and \"d \\<in> P[{x}]\" for d h"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "have 0: \"lex_pm_strict (u + v) w\" if \"lex_pm_strict v w\" and \"w \\<in> .[X]\" and \"u \\<in> .[{x}]\"\n              for u v w"], ["proof (prove)\ngoal (1 subgoal):\n 1. lex_pm_strict (u + v) w", "using that(1)"], ["proof (prove)\nusing this:\n  lex_pm_strict v w\n\ngoal (1 subgoal):\n 1. lex_pm_strict (u + v) w", "proof (rule lex_pm_strict_plus_left)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> keys w; y \\<in> keys u\\<rbrakk>\n       \\<Longrightarrow> x < y", "fix y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> keys w; y \\<in> keys u\\<rbrakk>\n       \\<Longrightarrow> x < y", "assume \"y \\<in> keys w\""], ["proof (state)\nthis:\n  y \\<in> keys w\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> keys w; y \\<in> keys u\\<rbrakk>\n       \\<Longrightarrow> x < y", "also"], ["proof (state)\nthis:\n  y \\<in> keys w\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> keys w; y \\<in> keys u\\<rbrakk>\n       \\<Longrightarrow> x < y", "from that(2)"], ["proof (chain)\npicking this:\n  w \\<in> .[X]", "have \"\\<dots> \\<subseteq> X\""], ["proof (prove)\nusing this:\n  w \\<in> .[X]\n\ngoal (1 subgoal):\n 1. keys w \\<subseteq> X", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys w \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> keys w; y \\<in> keys u\\<rbrakk>\n       \\<Longrightarrow> x < y", "also"], ["proof (state)\nthis:\n  keys w \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> keys w; y \\<in> keys u\\<rbrakk>\n       \\<Longrightarrow> x < y", "have \"\\<dots> \\<subseteq> {..<x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> {..<x}", "by fact"], ["proof (state)\nthis:\n  X \\<subseteq> {..<x}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> keys w; y \\<in> keys u\\<rbrakk>\n       \\<Longrightarrow> x < y", "finally"], ["proof (chain)\npicking this:\n  y \\<in> {..<x}", "have \"y < x\""], ["proof (prove)\nusing this:\n  y \\<in> {..<x}\n\ngoal (1 subgoal):\n 1. y < x", "by simp"], ["proof (state)\nthis:\n  y < x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> keys w; y \\<in> keys u\\<rbrakk>\n       \\<Longrightarrow> x < y", "assume \"z \\<in> keys u\""], ["proof (state)\nthis:\n  z \\<in> keys u\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> keys w; y \\<in> keys u\\<rbrakk>\n       \\<Longrightarrow> x < y", "also"], ["proof (state)\nthis:\n  z \\<in> keys u\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> keys w; y \\<in> keys u\\<rbrakk>\n       \\<Longrightarrow> x < y", "from that(3)"], ["proof (chain)\npicking this:\n  u \\<in> .[{x}]", "have \"\\<dots> \\<subseteq> {x}\""], ["proof (prove)\nusing this:\n  u \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. keys u \\<subseteq> {x}", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys u \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> keys w; y \\<in> keys u\\<rbrakk>\n       \\<Longrightarrow> x < y", "finally"], ["proof (chain)\npicking this:\n  z \\<in> {x}", "show \"y < z\""], ["proof (prove)\nusing this:\n  z \\<in> {x}\n\ngoal (1 subgoal):\n 1. y < z", "using \\<open>y < x\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> {x}\n  y < x\n\ngoal (1 subgoal):\n 1. y < z", "by simp"], ["proof (state)\nthis:\n  y < z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>lex_pm_strict ?v2 ?w2; ?w2 \\<in> .[X]; ?u2 \\<in> .[{x}]\\<rbrakk>\n  \\<Longrightarrow> lex_pm_strict (?u2 + ?v2) ?w2\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "let ?h = \"focus X h\""], ["proof (state)\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "from that(2)"], ["proof (chain)\npicking this:\n  h \\<in> G", "have \"?h \\<in> G'\""], ["proof (prove)\nusing this:\n  h \\<in> G\n\ngoal (1 subgoal):\n 1. focus X h \\<in> G'", "by (simp add: G'_def)"], ["proof (state)\nthis:\n  focus X h \\<in> G'\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "with \\<open>G' \\<subseteq> P[X]\\<close>"], ["proof (chain)\npicking this:\n  G' \\<subseteq> P[X]\n  focus X h \\<in> G'", "have \"?h \\<in> P[X]\""], ["proof (prove)\nusing this:\n  G' \\<subseteq> P[X]\n  focus X h \\<in> G'\n\ngoal (1 subgoal):\n 1. focus X h \\<in> P[X]", ".."], ["proof (state)\nthis:\n  focus X h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "hence \"i.lpp ?h \\<in> .[X]\""], ["proof (prove)\nusing this:\n  focus X h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. i.lpp (focus X h) \\<in> .[X]", "by (rule i.PPs_closed_lpp)"], ["proof (state)\nthis:\n  i.lpp (focus X h) \\<in> .[X]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "from that(1)"], ["proof (chain)\npicking this:\n  t \\<in> keys\n           (d *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X h))\n             (flatten (i.punit.tail (focus X h))))", "obtain t1 t2 where \"t1 \\<in> keys d\"\n              and \"t2 \\<in> keys (punit.monom_mult 1 (l - i.lpp ?h) (flatten (i.punit.tail ?h)))\"\n              and t: \"t = t1 + t2\""], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (d *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X h))\n             (flatten (i.punit.tail (focus X h))))\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        \\<lbrakk>t1 \\<in> keys d;\n         t2 \\<in> keys\n                   (punit.monom_mult (1::'a) (l - i.lpp (focus X h))\n                     (flatten (i.punit.tail (focus X h))));\n         t = t1 + t2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_timesE)"], ["proof (state)\nthis:\n  t1 \\<in> keys d\n  t2 \\<in> keys\n            (punit.monom_mult (1::'a) (l - i.lpp (focus X h))\n              (flatten (i.punit.tail (focus X h))))\n  t = t1 + t2\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "from this(2)"], ["proof (chain)\npicking this:\n  t2 \\<in> keys\n            (punit.monom_mult (1::'a) (l - i.lpp (focus X h))\n              (flatten (i.punit.tail (focus X h))))", "obtain t3 where \"t3 \\<in> keys (flatten (i.punit.tail ?h))\"\n              and t2: \"t2 = l - i.lpp ?h + t3\""], ["proof (prove)\nusing this:\n  t2 \\<in> keys\n            (punit.monom_mult (1::'a) (l - i.lpp (focus X h))\n              (flatten (i.punit.tail (focus X h))))\n\ngoal (1 subgoal):\n 1. (\\<And>t3.\n        \\<lbrakk>t3 \\<in> keys (flatten (i.punit.tail (focus X h)));\n         t2 = l - i.lpp (focus X h) + t3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: punit.keys_monom_mult)"], ["proof (state)\nthis:\n  t3 \\<in> keys (flatten (i.punit.tail (focus X h)))\n  t2 = l - i.lpp (focus X h) + t3\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "from this(1)"], ["proof (chain)\npicking this:\n  t3 \\<in> keys (flatten (i.punit.tail (focus X h)))", "obtain t4 t5 where \"t4 \\<in> keys (i.punit.tail ?h)\"\n              and t5_in: \"t5 \\<in> keys (lookup (i.punit.tail ?h) t4)\" and t3: \"t3 = t4 + t5\""], ["proof (prove)\nusing this:\n  t3 \\<in> keys (flatten (i.punit.tail (focus X h)))\n\ngoal (1 subgoal):\n 1. (\\<And>t4 t5.\n        \\<lbrakk>t4 \\<in> keys (i.punit.tail (focus X h));\n         t5 \\<in> keys (lookup (i.punit.tail (focus X h)) t4);\n         t3 = t4 + t5\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using keys_flatten_subset"], ["proof (prove)\nusing this:\n  t3 \\<in> keys (flatten (i.punit.tail (focus X h)))\n  keys (flatten ?p)\n  \\<subseteq> (\\<Union>t\\<in>keys ?p. (+) t ` keys (lookup ?p t))\n\ngoal (1 subgoal):\n 1. (\\<And>t4 t5.\n        \\<lbrakk>t4 \\<in> keys (i.punit.tail (focus X h));\n         t5 \\<in> keys (lookup (i.punit.tail (focus X h)) t4);\n         t3 = t4 + t5\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t4 \\<in> keys (i.punit.tail (focus X h))\n  t5 \\<in> keys (lookup (i.punit.tail (focus X h)) t4)\n  t3 = t4 + t5\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "from this(1)"], ["proof (chain)\npicking this:\n  t4 \\<in> keys (i.punit.tail (focus X h))", "have 1: \"lex_pm_strict t4 (i.lpp ?h)\""], ["proof (prove)\nusing this:\n  t4 \\<in> keys (i.punit.tail (focus X h))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t4 (i.lpp (focus X h))", "by (rule i.punit.keys_tail_less_lt)"], ["proof (state)\nthis:\n  lex_pm_strict t4 (i.lpp (focus X h))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "from that(2)"], ["proof (chain)\npicking this:\n  h \\<in> G", "have \"lookup ?h t4 \\<in> P[{x}]\""], ["proof (prove)\nusing this:\n  h \\<in> G\n\ngoal (1 subgoal):\n 1. lookup (focus X h) t4 \\<in> P[{x}]", "by (rule lookup_focus_in)"], ["proof (state)\nthis:\n  lookup (focus X h) t4 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "hence \"keys (lookup ?h t4) \\<subseteq> .[{x}]\""], ["proof (prove)\nusing this:\n  lookup (focus X h) t4 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. keys (lookup (focus X h) t4) \\<subseteq> .[{x}]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys (lookup (focus X h) t4) \\<subseteq> .[{x}]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "moreover"], ["proof (state)\nthis:\n  keys (lookup (focus X h) t4) \\<subseteq> .[{x}]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "from t5_in"], ["proof (chain)\npicking this:\n  t5 \\<in> keys (lookup (i.punit.tail (focus X h)) t4)", "have t5_in: \"t5 \\<in> keys (lookup ?h t4)\""], ["proof (prove)\nusing this:\n  t5 \\<in> keys (lookup (i.punit.tail (focus X h)) t4)\n\ngoal (1 subgoal):\n 1. t5 \\<in> keys (lookup (focus X h) t4)", "by (simp add: i.punit.lookup_tail split: if_split_asm)"], ["proof (state)\nthis:\n  t5 \\<in> keys (lookup (focus X h) t4)\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "ultimately"], ["proof (chain)\npicking this:\n  keys (lookup (focus X h) t4) \\<subseteq> .[{x}]\n  t5 \\<in> keys (lookup (focus X h) t4)", "have \"t5 \\<in> .[{x}]\""], ["proof (prove)\nusing this:\n  keys (lookup (focus X h) t4) \\<subseteq> .[{x}]\n  t5 \\<in> keys (lookup (focus X h) t4)\n\ngoal (1 subgoal):\n 1. t5 \\<in> .[{x}]", ".."], ["proof (state)\nthis:\n  t5 \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "with 1 \\<open>i.lpp ?h \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  lex_pm_strict t4 (i.lpp (focus X h))\n  i.lpp (focus X h) \\<in> .[X]\n  t5 \\<in> .[{x}]", "have \"lex_pm_strict (t5 + t4) (i.lpp ?h)\""], ["proof (prove)\nusing this:\n  lex_pm_strict t4 (i.lpp (focus X h))\n  i.lpp (focus X h) \\<in> .[X]\n  t5 \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. lex_pm_strict (t5 + t4) (i.lpp (focus X h))", "by (rule 0)"], ["proof (state)\nthis:\n  lex_pm_strict (t5 + t4) (i.lpp (focus X h))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "hence \"lex_pm_strict t3 (i.lpp ?h)\""], ["proof (prove)\nusing this:\n  lex_pm_strict (t5 + t4) (i.lpp (focus X h))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t3 (i.lpp (focus X h))", "by (simp only: t3 add.commute)"], ["proof (state)\nthis:\n  lex_pm_strict t3 (i.lpp (focus X h))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "hence \"lex_pm_strict t2 (l - i.lpp ?h + i.lpp ?h)\""], ["proof (prove)\nusing this:\n  lex_pm_strict t3 (i.lpp (focus X h))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t2 (l - i.lpp (focus X h) + i.lpp (focus X h))", "unfolding t2"], ["proof (prove)\nusing this:\n  lex_pm_strict t3 (i.lpp (focus X h))\n\ngoal (1 subgoal):\n 1. lex_pm_strict (l - i.lpp (focus X h) + t3)\n     (l - i.lpp (focus X h) + i.lpp (focus X h))", "by (rule i.plus_monotone_strict_left)"], ["proof (state)\nthis:\n  lex_pm_strict t2 (l - i.lpp (focus X h) + i.lpp (focus X h))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "moreover"], ["proof (state)\nthis:\n  lex_pm_strict t2 (l - i.lpp (focus X h) + i.lpp (focus X h))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "from \\<open>l \\<in> .[X]\\<close> \\<open>i.lpp ?h \\<in> .[X]\\<close>"], ["proof (chain)\npicking this:\n  l \\<in> .[X]\n  i.lpp (focus X h) \\<in> .[X]", "have \"l - i.lpp ?h + i.lpp ?h \\<in> .[X]\""], ["proof (prove)\nusing this:\n  l \\<in> .[X]\n  i.lpp (focus X h) \\<in> .[X]\n\ngoal (1 subgoal):\n 1. l - i.lpp (focus X h) + i.lpp (focus X h) \\<in> .[X]", "by (intro PPs_closed_plus PPs_closed_minus)"], ["proof (state)\nthis:\n  l - i.lpp (focus X h) + i.lpp (focus X h) \\<in> .[X]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "moreover"], ["proof (state)\nthis:\n  l - i.lpp (focus X h) + i.lpp (focus X h) \\<in> .[X]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "from \\<open>t1 \\<in> keys d\\<close> that(3)"], ["proof (chain)\npicking this:\n  t1 \\<in> keys d\n  d \\<in> P[{x}]", "have \"t1 \\<in> .[{x}]\""], ["proof (prove)\nusing this:\n  t1 \\<in> keys d\n  d \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. t1 \\<in> .[{x}]", "by (auto dest: PolysD)"], ["proof (state)\nthis:\n  t1 \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "ultimately"], ["proof (chain)\npicking this:\n  lex_pm_strict t2 (l - i.lpp (focus X h) + i.lpp (focus X h))\n  l - i.lpp (focus X h) + i.lpp (focus X h) \\<in> .[X]\n  t1 \\<in> .[{x}]", "show ?thesis"], ["proof (prove)\nusing this:\n  lex_pm_strict t2 (l - i.lpp (focus X h) + i.lpp (focus X h))\n  l - i.lpp (focus X h) + i.lpp (focus X h) \\<in> .[X]\n  t1 \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))", "unfolding t"], ["proof (prove)\nusing this:\n  lex_pm_strict t2 (l - i.lpp (focus X h) + i.lpp (focus X h))\n  l - i.lpp (focus X h) + i.lpp (focus X h) \\<in> .[X]\n  t1 \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. lex_pm_strict (t1 + t2) (l - i.lpp (focus X h) + i.lpp (focus X h))", "by (rule 0)"], ["proof (state)\nthis:\n  lex_pm_strict t (l - i.lpp (focus X h) + i.lpp (focus X h))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> keys\n                    (?d2 *\n                     punit.monom_mult (1::'a) (l - i.lpp (focus X ?h2))\n                      (flatten (i.punit.tail (focus X ?h2))));\n   ?h2 \\<in> G; ?d2 \\<in> P[{x}]\\<rbrakk>\n  \\<Longrightarrow> lex_pm_strict t\n                     (l - i.lpp (focus X ?h2) + i.lpp (focus X ?h2))\n\ngoal (1 subgoal):\n 1. \\<And>u. lex_pm l u \\<Longrightarrow> lookup s u = (0::'a)", "show \"lookup s t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup s t = (0::'a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup s t \\<noteq> (0::'a) \\<Longrightarrow> False", "assume \"lookup s t \\<noteq> 0\""], ["proof (state)\nthis:\n  lookup s t \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. lookup s t \\<noteq> (0::'a) \\<Longrightarrow> False", "hence \"t \\<in> keys s\""], ["proof (prove)\nusing this:\n  lookup s t \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. t \\<in> keys s", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  t \\<in> keys s\n\ngoal (1 subgoal):\n 1. lookup s t \\<noteq> (0::'a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  t \\<in> keys s\n\ngoal (1 subgoal):\n 1. lookup s t \\<noteq> (0::'a) \\<Longrightarrow> False", "have \"\\<dots> = keys (?a - ?b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys s =\n    keys\n     (c2 *\n      punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n       (flatten (i.punit.tail (focus X g1'))) -\n      c1 *\n      punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n       (flatten (i.punit.tail (focus X g2'))))", "by (simp add: s_def a b)"], ["proof (state)\nthis:\n  keys s =\n  keys\n   (c2 *\n    punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n     (flatten (i.punit.tail (focus X g1'))) -\n    c1 *\n    punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n     (flatten (i.punit.tail (focus X g2'))))\n\ngoal (1 subgoal):\n 1. lookup s t \\<noteq> (0::'a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  keys s =\n  keys\n   (c2 *\n    punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n     (flatten (i.punit.tail (focus X g1'))) -\n    c1 *\n    punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n     (flatten (i.punit.tail (focus X g2'))))\n\ngoal (1 subgoal):\n 1. lookup s t \\<noteq> (0::'a) \\<Longrightarrow> False", "have \"\\<dots> \\<subseteq> keys ?a \\<union> keys ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (c2 *\n      punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n       (flatten (i.punit.tail (focus X g1'))) -\n      c1 *\n      punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n       (flatten (i.punit.tail (focus X g2'))))\n    \\<subseteq> keys\n                 (c2 *\n                  punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n                   (flatten (i.punit.tail (focus X g1')))) \\<union>\n                keys\n                 (c1 *\n                  punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n                   (flatten (i.punit.tail (focus X g2'))))", "by (fact keys_minus)"], ["proof (state)\nthis:\n  keys\n   (c2 *\n    punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n     (flatten (i.punit.tail (focus X g1'))) -\n    c1 *\n    punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n     (flatten (i.punit.tail (focus X g2'))))\n  \\<subseteq> keys\n               (c2 *\n                punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n                 (flatten (i.punit.tail (focus X g1')))) \\<union>\n              keys\n               (c1 *\n                punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n                 (flatten (i.punit.tail (focus X g2'))))\n\ngoal (1 subgoal):\n 1. lookup s t \\<noteq> (0::'a) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  t \\<in> keys\n           (c2 *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n             (flatten (i.punit.tail (focus X g1')))) \\<union>\n          keys\n           (c1 *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n             (flatten (i.punit.tail (focus X g2'))))", "show False"], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (c2 *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n             (flatten (i.punit.tail (focus X g1')))) \\<union>\n          keys\n           (c1 *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n             (flatten (i.punit.tail (focus X g2'))))\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> keys\n             (c2 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n               (flatten (i.punit.tail (focus X g1')))) \\<Longrightarrow>\n    False\n 2. t \\<in> keys\n             (c1 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n               (flatten (i.punit.tail (focus X g2')))) \\<Longrightarrow>\n    False", "assume \"t \\<in> keys ?a\""], ["proof (state)\nthis:\n  t \\<in> keys\n           (c2 *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n             (flatten (i.punit.tail (focus X g1'))))\n\ngoal (2 subgoals):\n 1. t \\<in> keys\n             (c2 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n               (flatten (i.punit.tail (focus X g1')))) \\<Longrightarrow>\n    False\n 2. t \\<in> keys\n             (c1 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n               (flatten (i.punit.tail (focus X g2')))) \\<Longrightarrow>\n    False", "hence \"lex_pm_strict t (l - i.lpp (focus X g1') + i.lpp (focus X g1'))\""], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (c2 *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n             (flatten (i.punit.tail (focus X g1'))))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X g1') + i.lpp (focus X g1'))", "using \\<open>g1' \\<in> G\\<close> \\<open>c2 \\<in> P[{x}]\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (c2 *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n             (flatten (i.punit.tail (focus X g1'))))\n  g1' \\<in> G\n  c2 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X g1') + i.lpp (focus X g1'))", "by (rule lex_pm_strict_t)"], ["proof (state)\nthis:\n  lex_pm_strict t (l - i.lpp (focus X g1') + i.lpp (focus X g1'))\n\ngoal (2 subgoals):\n 1. t \\<in> keys\n             (c2 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n               (flatten (i.punit.tail (focus X g1')))) \\<Longrightarrow>\n    False\n 2. t \\<in> keys\n             (c1 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n               (flatten (i.punit.tail (focus X g2')))) \\<Longrightarrow>\n    False", "with \\<open>g1' \\<in> P[_]\\<close>"], ["proof (chain)\npicking this:\n  g1' \\<in> P[insert x X]\n  lex_pm_strict t (l - i.lpp (focus X g1') + i.lpp (focus X g1'))", "have \"lex_pm_strict t l\""], ["proof (prove)\nusing this:\n  g1' \\<in> P[insert x X]\n  lex_pm_strict t (l - i.lpp (focus X g1') + i.lpp (focus X g1'))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t l", "by (simp add: lpp_focus l_def minus_plus adds_lcs)"], ["proof (state)\nthis:\n  lex_pm_strict t l\n\ngoal (2 subgoals):\n 1. t \\<in> keys\n             (c2 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g1'))\n               (flatten (i.punit.tail (focus X g1')))) \\<Longrightarrow>\n    False\n 2. t \\<in> keys\n             (c1 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n               (flatten (i.punit.tail (focus X g2')))) \\<Longrightarrow>\n    False", "with \\<open>lex_pm l t\\<close>"], ["proof (chain)\npicking this:\n  lex_pm l t\n  lex_pm_strict t l", "show ?thesis"], ["proof (prove)\nusing this:\n  lex_pm l t\n  lex_pm_strict t l\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (c1 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n               (flatten (i.punit.tail (focus X g2')))) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (c1 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n               (flatten (i.punit.tail (focus X g2')))) \\<Longrightarrow>\n    False", "assume \"t \\<in> keys ?b\""], ["proof (state)\nthis:\n  t \\<in> keys\n           (c1 *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n             (flatten (i.punit.tail (focus X g2'))))\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (c1 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n               (flatten (i.punit.tail (focus X g2')))) \\<Longrightarrow>\n    False", "hence \"lex_pm_strict t (l - i.lpp (focus X g2') + i.lpp (focus X g2'))\""], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (c1 *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n             (flatten (i.punit.tail (focus X g2'))))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X g2') + i.lpp (focus X g2'))", "using \\<open>g2' \\<in> G\\<close> \\<open>c1 \\<in> P[{x}]\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (c1 *\n            punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n             (flatten (i.punit.tail (focus X g2'))))\n  g2' \\<in> G\n  c1 \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. lex_pm_strict t (l - i.lpp (focus X g2') + i.lpp (focus X g2'))", "by (rule lex_pm_strict_t)"], ["proof (state)\nthis:\n  lex_pm_strict t (l - i.lpp (focus X g2') + i.lpp (focus X g2'))\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (c1 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n               (flatten (i.punit.tail (focus X g2')))) \\<Longrightarrow>\n    False", "with \\<open>g2' \\<in> P[_]\\<close>"], ["proof (chain)\npicking this:\n  g2' \\<in> P[insert x X]\n  lex_pm_strict t (l - i.lpp (focus X g2') + i.lpp (focus X g2'))", "have \"lex_pm_strict t l\""], ["proof (prove)\nusing this:\n  g2' \\<in> P[insert x X]\n  lex_pm_strict t (l - i.lpp (focus X g2') + i.lpp (focus X g2'))\n\ngoal (1 subgoal):\n 1. lex_pm_strict t l", "by (simp add: lpp_focus l_def minus_plus adds_lcs_2)"], ["proof (state)\nthis:\n  lex_pm_strict t l\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (c1 *\n              punit.monom_mult (1::'a) (l - i.lpp (focus X g2'))\n               (flatten (i.punit.tail (focus X g2')))) \\<Longrightarrow>\n    False", "with \\<open>lex_pm l t\\<close>"], ["proof (chain)\npicking this:\n  lex_pm l t\n  lex_pm_strict t l", "show ?thesis"], ["proof (prove)\nusing this:\n  lex_pm l t\n  lex_pm_strict t l\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup s t = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lex_pm_strict (i.lpp s) l\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "also"], ["proof (state)\nthis:\n  lex_pm_strict (i.lpp s) l\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "have \"\\<dots> = lcs (i.lpp g1) (i.lpp g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = lcs (i.lpp g1) (i.lpp g2)", "by (simp only: l_def lpp1 lpp2)"], ["proof (state)\nthis:\n  l = lcs (i.lpp g1) (i.lpp g2)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       q g \\<noteq> 0 \\<and> g \\<noteq> 0 \\<Longrightarrow>\n       lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "finally"], ["proof (chain)\npicking this:\n  lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "show \"lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))\""], ["proof (prove)\nusing this:\n  lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))\n\ngoal (1 subgoal):\n 1. lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))", "."], ["proof (state)\nthis:\n  lex_pm_strict (i.lpp (q g * g)) (lcs (i.lpp g1) (i.lpp g2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i.punit.spoly_rep (varnum X) 0 G3 g1 g2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i.punit.is_Groebner_basis G3\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "have \"1 \\<in> ideal (?e ` focus {x} ` F) \\<longleftrightarrow> 1 \\<in> ideal (?e ` focus {x} ` F) \\<inter> P[- {x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<in> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)) =\n    (1 \\<in> ideal\n              (poly_eval (\\<lambda>_. monomial a 0) `\n               focus {x} ` F) \\<inter>\n             P[- {x}])", "by (simp add: one_in_Polys)"], ["proof (state)\nthis:\n  (1 \\<in> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)) =\n  (1 \\<in> ideal\n            (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F) \\<inter>\n           P[- {x}])\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "also"], ["proof (state)\nthis:\n  (1 \\<in> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)) =\n  (1 \\<in> ideal\n            (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F) \\<inter>\n           P[- {x}])\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "have \"\\<dots> \\<longleftrightarrow> 1 \\<in> ideal G3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<in> ideal\n              (poly_eval (\\<lambda>_. monomial a 0) `\n               focus {x} ` F) \\<inter>\n             P[- {x}]) =\n    (1 \\<in> ideal G3)", "by (simp add: one_in_Polys flip: eq3)"], ["proof (state)\nthis:\n  (1 \\<in> ideal\n            (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F) \\<inter>\n           P[- {x}]) =\n  (1 \\<in> ideal G3)\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "also"], ["proof (state)\nthis:\n  (1 \\<in> ideal\n            (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F) \\<inter>\n           P[- {x}]) =\n  (1 \\<in> ideal G3)\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "have \"\\<not> \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal G3", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "note G3_isGB"], ["proof (state)\nthis:\n  i.punit.is_Groebner_basis G3\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  i.punit.is_Groebner_basis G3\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "assume \"1 \\<in> ideal G3\""], ["proof (state)\nthis:\n  1 \\<in> ideal G3\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  1 \\<in> ideal G3\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "have \"1 \\<noteq> (0::_ \\<Rightarrow>\\<^sub>0 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  i.punit.is_Groebner_basis G3\n  1 \\<in> ideal G3\n  1 \\<noteq> 0", "obtain g where \"g \\<in> G3\" and \"g \\<noteq> 0\" and \"i.lpp g adds i.lpp (1::_ \\<Rightarrow>\\<^sub>0 'a)\""], ["proof (prove)\nusing this:\n  i.punit.is_Groebner_basis G3\n  1 \\<in> ideal G3\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G3; g \\<noteq> 0; i.lpp g adds i.lpp 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule i.punit.GB_adds_lt[simplified])"], ["proof (state)\nthis:\n  g \\<in> G3\n  g \\<noteq> 0\n  i.lpp g adds i.lpp 1\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "from this(3)"], ["proof (chain)\npicking this:\n  i.lpp g adds i.lpp 1", "have \"i.lpp g = 0\""], ["proof (prove)\nusing this:\n  i.lpp g adds i.lpp 1\n\ngoal (1 subgoal):\n 1. i.lpp g = 0", "by (simp add: i.punit.lt_monomial adds_zero flip: single_one)"], ["proof (state)\nthis:\n  i.lpp g = 0\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "hence \"monomial (i.lcf g) 0 = g\""], ["proof (prove)\nusing this:\n  i.lpp g = 0\n\ngoal (1 subgoal):\n 1. monomial (i.lcf g) 0 = g", "by (rule i.punit.lt_eq_min_term_monomial[simplified])"], ["proof (state)\nthis:\n  monomial (i.lcf g) 0 = g\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "from \\<open>g \\<in> G3\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> G3", "obtain g' where \"g' \\<in> G\" and g: \"g = ?e (focus {x} g')\""], ["proof (prove)\nusing this:\n  g \\<in> G3\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>g' \\<in> G;\n         g = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: G3_def)"], ["proof (state)\nthis:\n  g' \\<in> G\n  g = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g')\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "from this(1)"], ["proof (chain)\npicking this:\n  g' \\<in> G", "have \"i.lpp g = except (i.lpp g') {x}\""], ["proof (prove)\nusing this:\n  g' \\<in> G\n\ngoal (1 subgoal):\n 1. i.lpp g = except (i.lpp g') {x}", "unfolding g"], ["proof (prove)\nusing this:\n  g' \\<in> G\n\ngoal (1 subgoal):\n 1. i.lpp (poly_eval (\\<lambda>_. monomial a 0) (focus {x} g')) =\n    except (i.lpp g') {x}", "by (rule lpp_e_focus)"], ["proof (state)\nthis:\n  i.lpp g = except (i.lpp g') {x}\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "hence \"keys (i.lpp g') \\<subseteq> {x}\""], ["proof (prove)\nusing this:\n  i.lpp g = except (i.lpp g') {x}\n\ngoal (1 subgoal):\n 1. keys (i.lpp g') \\<subseteq> {x}", "by (simp add: \\<open>i.lpp g = 0\\<close> except_eq_zero_iff)"], ["proof (state)\nthis:\n  keys (i.lpp g') \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "have \"g' \\<in> P[{x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' \\<in> P[{x}]", "proof (intro PolysI subsetI PPsI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "fix t y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "assume \"t \\<in> keys g'\""], ["proof (state)\nthis:\n  t \\<in> keys g'\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "hence \"lex_pm t (i.lpp g')\""], ["proof (prove)\nusing this:\n  t \\<in> keys g'\n\ngoal (1 subgoal):\n 1. lex_pm t (i.lpp g')", "by (rule i.punit.lt_max_keys)"], ["proof (state)\nthis:\n  lex_pm t (i.lpp g')\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "moreover"], ["proof (state)\nthis:\n  lex_pm t (i.lpp g')\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "assume \"y \\<in> keys t\""], ["proof (state)\nthis:\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "ultimately"], ["proof (chain)\npicking this:\n  lex_pm t (i.lpp g')\n  y \\<in> keys t", "obtain z where \"z \\<in> keys (i.lpp g')\" and \"z \\<le> y\""], ["proof (prove)\nusing this:\n  lex_pm t (i.lpp g')\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> keys (i.lpp g'); z \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule lex_pm_keys_leE)"], ["proof (state)\nthis:\n  z \\<in> keys (i.lpp g')\n  z \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "with \\<open>keys (i.lpp g') \\<subseteq> {x}\\<close>"], ["proof (chain)\npicking this:\n  keys (i.lpp g') \\<subseteq> {x}\n  z \\<in> keys (i.lpp g')\n  z \\<le> y", "have \"x \\<le> y\""], ["proof (prove)\nusing this:\n  keys (i.lpp g') \\<subseteq> {x}\n  z \\<in> keys (i.lpp g')\n  z \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by blast"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "from \\<open>g' \\<in> G\\<close> G_sub"], ["proof (chain)\npicking this:\n  g' \\<in> G\n  G \\<subseteq> P[insert x X]", "have \"g' \\<in> P[insert x X]\""], ["proof (prove)\nusing this:\n  g' \\<in> G\n  G \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. g' \\<in> P[insert x X]", ".."], ["proof (state)\nthis:\n  g' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "hence \"indets g' \\<subseteq> insert x X\""], ["proof (prove)\nusing this:\n  g' \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. indets g' \\<subseteq> insert x X", "by (rule PolysD)"], ["proof (state)\nthis:\n  indets g' \\<subseteq> insert x X\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "moreover"], ["proof (state)\nthis:\n  indets g' \\<subseteq> insert x X\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "from \\<open>y \\<in> _\\<close> \\<open>t \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> keys t\n  t \\<in> keys g'", "have \"y \\<in> indets g'\""], ["proof (prove)\nusing this:\n  y \\<in> keys t\n  t \\<in> keys g'\n\ngoal (1 subgoal):\n 1. y \\<in> indets g'", "by (rule in_indetsI)"], ["proof (state)\nthis:\n  y \\<in> indets g'\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "ultimately"], ["proof (chain)\npicking this:\n  indets g' \\<subseteq> insert x X\n  y \\<in> indets g'", "have \"y \\<in> insert x X\""], ["proof (prove)\nusing this:\n  indets g' \\<subseteq> insert x X\n  y \\<in> indets g'\n\ngoal (1 subgoal):\n 1. y \\<in> insert x X", ".."], ["proof (state)\nthis:\n  y \\<in> insert x X\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> keys g'; xaa \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> xaa \\<in> {x}", "thus \"y \\<in> {x}\""], ["proof (prove)\nusing this:\n  y \\<in> insert x X\n\ngoal (1 subgoal):\n 1. y \\<in> {x}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> {x}\n 2. y \\<in> X \\<Longrightarrow> y \\<in> {x}", "assume \"y \\<in> X\""], ["proof (state)\nthis:\n  y \\<in> X\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> {x}\n 2. y \\<in> X \\<Longrightarrow> y \\<in> {x}", "with assms(3)"], ["proof (chain)\npicking this:\n  X \\<subseteq> {..<x}\n  y \\<in> X", "have \"y \\<in> {..<x}\""], ["proof (prove)\nusing this:\n  X \\<subseteq> {..<x}\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. y \\<in> {..<x}", ".."], ["proof (state)\nthis:\n  y \\<in> {..<x}\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> y \\<in> {x}\n 2. y \\<in> X \\<Longrightarrow> y \\<in> {x}", "with \\<open>x \\<le> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<in> {..<x}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<in> {..<x}\n\ngoal (1 subgoal):\n 1. y \\<in> {x}", "by simp"], ["proof (state)\nthis:\n  y \\<in> {x}\n\ngoal (1 subgoal):\n 1. y = x \\<Longrightarrow> y \\<in> {x}", "qed simp"], ["proof (state)\nthis:\n  y \\<in> {x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g' \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  g' \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "from \\<open>g' \\<in> G\\<close>"], ["proof (chain)\npicking this:\n  g' \\<in> G", "have \"g' \\<in> ideal G\""], ["proof (prove)\nusing this:\n  g' \\<in> G\n\ngoal (1 subgoal):\n 1. g' \\<in> ideal G", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  g' \\<in> ideal G\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  g' \\<in> P[{x}]\n  g' \\<in> ideal G", "have \"g' \\<in> ideal F \\<inter> P[{x}]\""], ["proof (prove)\nusing this:\n  g' \\<in> P[{x}]\n  g' \\<in> ideal G\n\ngoal (1 subgoal):\n 1. g' \\<in> ideal F \\<inter> P[{x}]", "by (simp add: ideal_G)"], ["proof (state)\nthis:\n  g' \\<in> ideal F \\<inter> P[{x}]\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "with assms(5)"], ["proof (chain)\npicking this:\n  ideal F \\<inter> P[{x}] \\<subseteq> {0}\n  g' \\<in> ideal F \\<inter> P[{x}]", "have \"g' = 0\""], ["proof (prove)\nusing this:\n  ideal F \\<inter> P[{x}] \\<subseteq> {0}\n  g' \\<in> ideal F \\<inter> P[{x}]\n\ngoal (1 subgoal):\n 1. g' = 0", "by blast"], ["proof (state)\nthis:\n  g' = 0\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "hence \"g = 0\""], ["proof (prove)\nusing this:\n  g' = 0\n\ngoal (1 subgoal):\n 1. g = 0", "by (simp add: g)"], ["proof (state)\nthis:\n  g = 0\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal G3 \\<Longrightarrow> False", "with \\<open>g \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  g \\<noteq> 0\n  g = 0", "show False"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  g = 0\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<notin> ideal G3\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial ?a 0) ` focus {x} ` F)", "finally"], ["proof (chain)\npicking this:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)", "show \"1 \\<notin> ideal (?e ` focus {x} ` F)\""], ["proof (prove)\nusing this:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)", "."], ["proof (state)\nthis:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma weak_Nullstellensatz_aux_3:\n  assumes \"F \\<subseteq> P[insert x X]\" and \"x \\<notin> X\" and \"1 \\<notin> ideal F\" and \"\\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\"\n  obtains a::\"'a::alg_closed_field\" where \"1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?x = \"monomial 1 (Poly_Mapping.single x 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms(4)"], ["proof (chain)\npicking this:\n  \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}", "obtain f where \"f \\<in> ideal F\" and \"f \\<in> P[{x}]\" and \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> ideal F; f \\<in> P[{x}]; f \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f \\<in> ideal F\n  f \\<in> P[{x}]\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define p where \"p = poly_of_pm x f\""], ["proof (state)\nthis:\n  p = poly_of_pm x f\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from \\<open>f \\<in> P[{x}]\\<close> \\<open>f \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> P[{x}]\n  f \\<noteq> 0", "have \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<in> P[{x}]\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by (auto simp: p_def poly_of_pm_eq_zero_iff simp flip: keys_eq_empty dest!: PolysD(1))"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain c A m where A: \"finite A\" and p: \"p = Polynomial.smult c (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a)\"\n    and \"\\<And>x. m x = 0 \\<longleftrightarrow> x \\<notin> A\" and \"c = 0 \\<longleftrightarrow> p = 0\" and \"\\<And>z. poly p z = 0 \\<longleftrightarrow> (c = 0 \\<or> z \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A c m.\n        \\<lbrakk>finite A;\n         p = Polynomial.smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a);\n         \\<And>x. (m x = 0) = (x \\<notin> A); (c = (0::'a)) = (p = 0);\n         \\<And>z.\n            (poly p z = (0::'a)) = (c = (0::'a) \\<or> z \\<in> A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule linear_factorsE) blast"], ["proof (state)\nthis:\n  finite A\n  p = Polynomial.smult c (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n  (m ?x1 = 0) = (?x1 \\<notin> A)\n  (c = (0::'a)) = (p = 0)\n  (poly p ?z1 = (0::'a)) = (c = (0::'a) \\<or> ?z1 \\<in> A)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from this(4, 5)"], ["proof (chain)\npicking this:\n  (c = (0::'a)) = (p = 0)\n  (poly p ?z1 = (0::'a)) = (c = (0::'a) \\<or> ?z1 \\<in> A)", "have \"c \\<noteq> 0\" and \"\\<And>z. poly p z = 0 \\<longleftrightarrow> z \\<in> A\""], ["proof (prove)\nusing this:\n  (c = (0::'a)) = (p = 0)\n  (poly p ?z1 = (0::'a)) = (c = (0::'a) \\<or> ?z1 \\<in> A)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) &&& (\\<And>z. (poly p z = (0::'a)) = (z \\<in> A))", "by (simp_all add: \\<open>p \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  (poly p ?z1 = (0::'a)) = (?z1 \\<in> A)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>a\\<in>A. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A.\n       1 \\<notin> ideal\n                   (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "assume asm: \"\\<not> (\\<exists>a\\<in>A. 1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F))\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>a\\<in>A.\n             1 \\<notin> ideal\n                         (poly_eval (\\<lambda>_. monomial a 0) `\n                          focus {x} ` F))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "obtain g h where \"g a \\<in> ideal F\" and 1: \"h a * (?x - monomial a 0) + g a = 1\"\n      if \"a \\<in> A\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>\\<And>a. a \\<in> A \\<Longrightarrow> g a \\<in> ideal F;\n         \\<And>a.\n            a \\<in> A \\<Longrightarrow>\n            h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a =\n            1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>\\<And>a. a \\<in> A \\<Longrightarrow> g a \\<in> ideal F;\n         \\<And>a.\n            a \\<in> A \\<Longrightarrow>\n            h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a =\n            1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define P where \"P = (\\<lambda>gh a. fst gh \\<in> ideal F \\<and> fst gh + snd gh * (?x - monomial a 0) = 1)\""], ["proof (state)\nthis:\n  P =\n  (\\<lambda>gh a.\n      fst gh \\<in> ideal F \\<and>\n      fst gh + snd gh * (monomial (1::'a) (monomial 1 x) - monomial a 0) =\n      1)\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>\\<And>a. a \\<in> A \\<Longrightarrow> g a \\<in> ideal F;\n         \\<And>a.\n            a \\<in> A \\<Longrightarrow>\n            h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a =\n            1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define gh where \"gh = (\\<lambda>a. SOME gh. P gh a)\""], ["proof (state)\nthis:\n  gh = (\\<lambda>a. SOME gh. P gh a)\n\ngoal (1 subgoal):\n 1. (\\<And>g h.\n        \\<lbrakk>\\<And>a. a \\<in> A \\<Longrightarrow> g a \\<in> ideal F;\n         \\<And>a.\n            a \\<in> A \\<Longrightarrow>\n            h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a =\n            1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "assume \"a \\<in> A\""], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "with asm"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>a\\<in>A.\n             1 \\<notin> ideal\n                         (poly_eval (\\<lambda>_. monomial a 0) `\n                          focus {x} ` F))\n  a \\<in> A", "have \"1 \\<in> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>a\\<in>A.\n             1 \\<notin> ideal\n                         (poly_eval (\\<lambda>_. monomial a 0) `\n                          focus {x} ` F))\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)", "by blast"], ["proof (state)\nthis:\n  1 \\<in> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "hence \"1 \\<in> poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` ideal F\""], ["proof (prove)\nusing this:\n  1 \\<in> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. 1 \\<in> poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` ideal F", "by (simp add: image_poly_eval_focus_ideal one_in_Polys)"], ["proof (state)\nthis:\n  1 \\<in> poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` ideal F\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "then"], ["proof (chain)\npicking this:\n  1 \\<in> poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` ideal F", "obtain g where \"g \\<in> ideal F\" and \"1 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)\""], ["proof (prove)\nusing this:\n  1 \\<in> poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> ideal F;\n         1 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding image_image"], ["proof (prove)\nusing this:\n  1 \\<in> (\\<lambda>xa.\n              poly_eval (\\<lambda>_. monomial a 0) (focus {x} xa)) `\n          ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> ideal F;\n         1 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  g \\<in> ideal F\n  1 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "note this(2)"], ["proof (state)\nthis:\n  1 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "also"], ["proof (state)\nthis:\n  1 = poly_eval (\\<lambda>_. monomial a 0) (focus {x} g)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "have \"poly_eval (\\<lambda>_. monomial a 0) (focus {x} g) = poly (poly_of_focus x g) (monomial a 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a 0) (focus {x} g) =\n    poly (poly_of_focus x g) (monomial a 0)", "by (simp only: poly_poly_of_focus)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a 0) (focus {x} g) =\n  poly (poly_of_focus x g) (monomial a 0)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "also"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a 0) (focus {x} g) =\n  poly (poly_of_focus x g) (monomial a 0)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "have \"\\<dots> = poly (poly_of_focus x g) (?x - (?x - monomial a 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_of_focus x g) (monomial a 0) =\n    poly (poly_of_focus x g)\n     (monomial (1::'a) (monomial 1 x) -\n      (monomial (1::'a) (monomial 1 x) - monomial a 0))", "by simp"], ["proof (state)\nthis:\n  poly (poly_of_focus x g) (monomial a 0) =\n  poly (poly_of_focus x g)\n   (monomial (1::'a) (monomial 1 x) -\n    (monomial (1::'a) (monomial 1 x) - monomial a 0))\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "also"], ["proof (state)\nthis:\n  poly (poly_of_focus x g) (monomial a 0) =\n  poly (poly_of_focus x g)\n   (monomial (1::'a) (monomial 1 x) -\n    (monomial (1::'a) (monomial 1 x) - monomial a 0))\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "obtain h where \"\\<dots> = poly (poly_of_focus x g) ?x - h * (?x - monomial a 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        poly (poly_of_focus x g)\n         (monomial (1::'a) (monomial 1 x) -\n          (monomial (1::'a) (monomial 1 x) - monomial a 0)) =\n        poly (poly_of_focus x g) (monomial (1::'a) (monomial 1 x)) -\n        h *\n        (monomial (1::'a) (monomial 1 x) - monomial a 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_minus_rightE)"], ["proof (state)\nthis:\n  poly (poly_of_focus x g)\n   (monomial (1::'a) (monomial 1 x) -\n    (monomial (1::'a) (monomial 1 x) - monomial a 0)) =\n  poly (poly_of_focus x g) (monomial (1::'a) (monomial 1 x)) -\n  h * (monomial (1::'a) (monomial 1 x) - monomial a 0)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "also"], ["proof (state)\nthis:\n  poly (poly_of_focus x g)\n   (monomial (1::'a) (monomial 1 x) -\n    (monomial (1::'a) (monomial 1 x) - monomial a 0)) =\n  poly (poly_of_focus x g) (monomial (1::'a) (monomial 1 x)) -\n  h * (monomial (1::'a) (monomial 1 x) - monomial a 0)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "have \"\\<dots> = g - h * (?x - monomial a 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_of_focus x g) (monomial (1::'a) (monomial 1 x)) -\n    h * (monomial (1::'a) (monomial 1 x) - monomial a 0) =\n    g - h * (monomial (1::'a) (monomial 1 x) - monomial a 0)", "by (simp only: poly_poly_of_focus_monomial)"], ["proof (state)\nthis:\n  poly (poly_of_focus x g) (monomial (1::'a) (monomial 1 x)) -\n  h * (monomial (1::'a) (monomial 1 x) - monomial a 0) =\n  g - h * (monomial (1::'a) (monomial 1 x) - monomial a 0)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "finally"], ["proof (chain)\npicking this:\n  1 = g - h * (monomial (1::'a) (monomial 1 x) - monomial a 0)", "have \"g - h * (?x - monomial a 0) = 1\""], ["proof (prove)\nusing this:\n  1 = g - h * (monomial (1::'a) (monomial 1 x) - monomial a 0)\n\ngoal (1 subgoal):\n 1. g - h * (monomial (1::'a) (monomial 1 x) - monomial a 0) = 1", "by (rule sym)"], ["proof (state)\nthis:\n  g - h * (monomial (1::'a) (monomial 1 x) - monomial a 0) = 1\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "with \\<open>g \\<in> ideal F\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> ideal F\n  g - h * (monomial (1::'a) (monomial 1 x) - monomial a 0) = 1", "have \"P (g, - h) a\""], ["proof (prove)\nusing this:\n  g \\<in> ideal F\n  g - h * (monomial (1::'a) (monomial 1 x) - monomial a 0) = 1\n\ngoal (1 subgoal):\n 1. P (g, - h) a", "by (simp add: P_def)"], ["proof (state)\nthis:\n  P (g, - h) a\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "hence \"P (gh a) a\""], ["proof (prove)\nusing this:\n  P (g, - h) a\n\ngoal (1 subgoal):\n 1. P (gh a) a", "unfolding gh_def"], ["proof (prove)\nusing this:\n  P (g, - h) a\n\ngoal (1 subgoal):\n 1. P (SOME gh. P gh a) a", "by (rule someI)"], ["proof (state)\nthis:\n  P (gh a) a\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ?g1 a \\<in> ideal F\n 2. \\<And>a.\n       a \\<in> A \\<Longrightarrow>\n       ?h1 a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + ?g1 a = 1", "thus \"fst (gh a) \\<in> ideal F\" and \"snd (gh a) * (?x - monomial a 0) + fst (gh a) = 1\""], ["proof (prove)\nusing this:\n  P (gh a) a\n\ngoal (1 subgoal):\n 1. fst (gh a) \\<in> ideal F &&&\n    snd (gh a) * (monomial (1::'a) (monomial 1 x) - monomial a 0) +\n    fst (gh a) =\n    1", "by (simp_all only: P_def add.commute)"], ["proof (state)\nthis:\n  fst (gh a) \\<in> ideal F\n  snd (gh a) * (monomial (1::'a) (monomial 1 x) - monomial a 0) +\n  fst (gh a) =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a1 \\<in> A \\<Longrightarrow> g ?a1 \\<in> ideal F\n  ?a1 \\<in> A \\<Longrightarrow>\n  h ?a1 * (monomial (1::'a) (monomial 1 x) - monomial ?a1 0) + g ?a1 = 1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "from this(1)"], ["proof (chain)\npicking this:\n  ?a1 \\<in> A \\<Longrightarrow> g ?a1 \\<in> ideal F", "obtain g' where \"g' \\<in> ideal F\"\n      and 2: \"(\\<Prod>a\\<in>A. (h a * (?x - monomial a 0) + g a) ^ m a) =\n                (\\<Prod>a\\<in>A. (h a * (?x - monomial a 0)) ^ m a) + g'\""], ["proof (prove)\nusing this:\n  ?a1 \\<in> A \\<Longrightarrow> g ?a1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>g' \\<in> ideal F;\n         (\\<Prod>a\\<in>A.\n            (h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a) ^\n            m a) =\n         (\\<Prod>a\\<in>A.\n            (h a * (monomial (1::'a) (monomial 1 x) - monomial a 0)) ^\n            m a) +\n         g'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule weak_Nullstellensatz_aux_1)"], ["proof (state)\nthis:\n  g' \\<in> ideal F\n  (\\<Prod>a\\<in>A.\n     (h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a) ^ m a) =\n  (\\<Prod>a\\<in>A.\n     (h a * (monomial (1::'a) (monomial 1 x) - monomial a 0)) ^ m a) +\n  g'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "have \"1 = (\\<Prod>a\\<in>A. (h a * (?x - monomial a 0) + g a) ^ m a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 =\n    (\\<Prod>a\\<in>A.\n       (h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a) ^ m a)", "by (rule sym) (intro prod.neutral ballI, simp only: 1 power_one)"], ["proof (state)\nthis:\n  1 =\n  (\\<Prod>a\\<in>A.\n     (h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a) ^ m a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  1 =\n  (\\<Prod>a\\<in>A.\n     (h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a) ^ m a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "have \"\\<dots> = (\\<Prod>a\\<in>A. h a ^ m a) * (\\<Prod>a\\<in>A. (?x - monomial a 0) ^ m a) + g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>A.\n       (h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a) ^\n       m a) =\n    (\\<Prod>a\\<in>A. h a ^ m a) *\n    (\\<Prod>a\\<in>A.\n       (monomial (1::'a) (monomial 1 x) - monomial a 0) ^ m a) +\n    g'", "by (simp only: 2 power_mult_distrib prod.distrib)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>A.\n     (h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a) ^ m a) =\n  (\\<Prod>a\\<in>A. h a ^ m a) *\n  (\\<Prod>a\\<in>A. (monomial (1::'a) (monomial 1 x) - monomial a 0) ^ m a) +\n  g'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>A.\n     (h a * (monomial (1::'a) (monomial 1 x) - monomial a 0) + g a) ^ m a) =\n  (\\<Prod>a\\<in>A. h a ^ m a) *\n  (\\<Prod>a\\<in>A. (monomial (1::'a) (monomial 1 x) - monomial a 0) ^ m a) +\n  g'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "have \"(\\<Prod>a\\<in>A. (?x - monomial a 0) ^ m a) = pm_of_poly x (\\<Prod>a\\<in>A. [:- a, 1:] ^ m a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>A.\n       (monomial (1::'a) (monomial 1 x) - monomial a 0) ^ m a) =\n    pm_of_poly x (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)", "by (simp add: pm_of_poly_prod pm_of_poly_pCons single_uminus punit.monom_mult_monomial\n              flip: single_one)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>A. (monomial (1::'a) (monomial 1 x) - monomial a 0) ^ m a) =\n  pm_of_poly x (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>A. (monomial (1::'a) (monomial 1 x) - monomial a 0) ^ m a) =\n  pm_of_poly x (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "from \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)", "have \"\\<dots> = monomial (inverse c) 0 * pm_of_poly x p\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. pm_of_poly x (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n    monomial (inverse c) 0 * pm_of_poly x p", "by (simp add: p map_scale_assoc flip: map_scale_eq_times)"], ["proof (state)\nthis:\n  pm_of_poly x (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  monomial (inverse c) 0 * pm_of_poly x p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  pm_of_poly x (\\<Prod>a\\<in>A. [:- a, 1::'a:] ^ m a) =\n  monomial (inverse c) 0 * pm_of_poly x p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "from \\<open>f \\<in> P[{x}]\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> P[{x}]", "have \"\\<dots> = monomial (inverse c) 0 * f\""], ["proof (prove)\nusing this:\n  f \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. monomial (inverse c) 0 * pm_of_poly x p = monomial (inverse c) 0 * f", "by (simp only: \\<open>p = poly_of_pm x f\\<close> pm_of_poly_of_pm)"], ["proof (state)\nthis:\n  monomial (inverse c) 0 * pm_of_poly x p = monomial (inverse c) 0 * f\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  1 = (\\<Prod>a\\<in>A. h a ^ m a) * (monomial (inverse c) 0 * f) + g'", "have \"1 = ((\\<Prod>a\\<in>A. h a ^ m a) * monomial (inverse c) 0) * f + g'\""], ["proof (prove)\nusing this:\n  1 = (\\<Prod>a\\<in>A. h a ^ m a) * (monomial (inverse c) 0 * f) + g'\n\ngoal (1 subgoal):\n 1. 1 = (\\<Prod>a\\<in>A. h a ^ m a) * monomial (inverse c) 0 * f + g'", "by (simp only: mult.assoc)"], ["proof (state)\nthis:\n  1 = (\\<Prod>a\\<in>A. h a ^ m a) * monomial (inverse c) 0 * f + g'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  1 = (\\<Prod>a\\<in>A. h a ^ m a) * monomial (inverse c) 0 * f + g'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "from \\<open>f \\<in> ideal F\\<close> \\<open>g' \\<in> ideal F\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> ideal F\n  g' \\<in> ideal F", "have \"\\<dots> \\<in> ideal F\""], ["proof (prove)\nusing this:\n  f \\<in> ideal F\n  g' \\<in> ideal F\n\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>A. h a ^ m a) * monomial (inverse c) 0 * f + g'\n    \\<in> ideal F", "by (intro ideal.span_add ideal.span_scale)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>A. h a ^ m a) * monomial (inverse c) 0 * f + g'\n  \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  1 \\<in> ideal F", "have \"1 \\<in> ideal F\""], ["proof (prove)\nusing this:\n  1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal F", "."], ["proof (state)\nthis:\n  1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>A.\n               1 \\<notin> ideal\n                           (poly_eval (\\<lambda>_. monomial a 0) `\n                            focus {x} ` F)) \\<Longrightarrow>\n    False", "with assms(3)"], ["proof (chain)\npicking this:\n  1 \\<notin> ideal F\n  1 \\<in> ideal F", "show False"], ["proof (prove)\nusing this:\n  1 \\<notin> ideal F\n  1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a\\<in>A.\n     1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>A.\n     1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)", "obtain a where \"1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>A.\n     1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem weak_Nullstellensatz:\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\" and \"\\<V> F = ({}::('x::{countable,linorder} \\<Rightarrow> 'a::alg_closed_field) set)\"\n  shows \"ideal F = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal F = UNIV", "unfolding ideal_eq_UNIV_iff_contains_one"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> ideal F", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal F \\<Longrightarrow> False", "assume \"1 \\<notin> ideal F\""], ["proof (state)\nthis:\n  1 \\<notin> ideal F\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal F \\<Longrightarrow> False", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]\n  1 \\<notin> ideal F", "obtain a where \"1 \\<notin> ideal (poly_eval a ` F)\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n  1 \\<notin> ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (induct X arbitrary: F thesis rule: finite_linorder_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>F thesis.\n       \\<lbrakk>\\<And>a.\n                   (1::'a)\n                   \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                   thesis;\n        F \\<subseteq> P[{}]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "case empty"], ["proof (state)\nthis:\n  (1::'a) \\<notin> ideal (poly_eval ?a ` F) \\<Longrightarrow> thesis\n  F \\<subseteq> P[{}]\n  1 \\<notin> ideal F\n\ngoal (2 subgoals):\n 1. \\<And>F thesis.\n       \\<lbrakk>\\<And>a.\n                   (1::'a)\n                   \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                   thesis;\n        F \\<subseteq> P[{}]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"F \\<subseteq> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> {0}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> {0}", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> {0}", "assume \"f \\<in> F\""], ["proof (state)\nthis:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> {0}", "with empty.prems(2)"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[{}]\n  f \\<in> F", "have \"f \\<in> P[{}]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[{}]\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. f \\<in> P[{}]", ".."], ["proof (state)\nthis:\n  f \\<in> P[{}]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> {0}", "then"], ["proof (chain)\npicking this:\n  f \\<in> P[{}]", "obtain c where f: \"f = monomial c 0\""], ["proof (prove)\nusing this:\n  f \\<in> P[{}]\n\ngoal (1 subgoal):\n 1. (\\<And>c. f = monomial c 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Polys_empty"], ["proof (prove)\nusing this:\n  f \\<in> range (Poly_Mapping.single 0)\n\ngoal (1 subgoal):\n 1. (\\<And>c. f = monomial c 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  f = monomial c 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> {0}", "also"], ["proof (state)\nthis:\n  f = monomial c 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> {0}", "have \"c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = (0::'a)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow> False", "assume \"c \\<noteq> 0\""], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow> False", "from \\<open>f \\<in> F\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F", "have \"f \\<in> ideal F\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. f \\<in> ideal F", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow> False", "hence \"monomial (inverse c) 0 * f \\<in> ideal F\""], ["proof (prove)\nusing this:\n  f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. monomial (inverse c) 0 * f \\<in> ideal F", "by (rule ideal.span_scale)"], ["proof (state)\nthis:\n  monomial (inverse c) 0 * f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow> False", "with \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)\n  monomial (inverse c) 0 * f \\<in> ideal F", "have \"1 \\<in> ideal F\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  monomial (inverse c) 0 * f \\<in> ideal F\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal F", "by (simp add: f times_monomial_monomial)"], ["proof (state)\nthis:\n  1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow> False", "with empty.prems(3)"], ["proof (chain)\npicking this:\n  1 \\<notin> ideal F\n  1 \\<in> ideal F", "show False"], ["proof (prove)\nusing this:\n  1 \\<notin> ideal F\n  1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> {0}", "finally"], ["proof (chain)\npicking this:\n  f = monomial (0::'a) 0", "show \"f \\<in> {0}\""], ["proof (prove)\nusing this:\n  f = monomial (0::'a) 0\n\ngoal (1 subgoal):\n 1. f \\<in> {0}", "by simp"], ["proof (state)\nthis:\n  f \\<in> {0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F \\<subseteq> {0}\n\ngoal (2 subgoals):\n 1. \\<And>F thesis.\n       \\<lbrakk>\\<And>a.\n                   (1::'a)\n                   \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                   thesis;\n        F \\<subseteq> P[{}]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"poly_eval 0 ` F \\<subseteq> {0}\""], ["proof (prove)\nusing this:\n  F \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. poly_eval 0 ` F \\<subseteq> {0::'a}", "by auto"], ["proof (state)\nthis:\n  poly_eval 0 ` F \\<subseteq> {0::'a}\n\ngoal (2 subgoals):\n 1. \\<And>F thesis.\n       \\<lbrakk>\\<And>a.\n                   (1::'a)\n                   \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                   thesis;\n        F \\<subseteq> P[{}]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"ideal (poly_eval 0 ` F) = {0}\""], ["proof (prove)\nusing this:\n  poly_eval 0 ` F \\<subseteq> {0::'a}\n\ngoal (1 subgoal):\n 1. ideal (poly_eval 0 ` F) = {0::'a}", "by simp"], ["proof (state)\nthis:\n  ideal (poly_eval 0 ` F) = {0::'a}\n\ngoal (2 subgoals):\n 1. \\<And>F thesis.\n       \\<lbrakk>\\<And>a.\n                   (1::'a)\n                   \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                   thesis;\n        F \\<subseteq> P[{}]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"1 \\<notin> ideal (poly_eval 0 ` F)\""], ["proof (prove)\nusing this:\n  ideal (poly_eval 0 ` F) = {0::'a}\n\ngoal (1 subgoal):\n 1. (1::'a) \\<notin> ideal (poly_eval 0 ` F)", "by (simp del: ideal_eq_zero_iff)"], ["proof (state)\nthis:\n  (1::'a) \\<notin> ideal (poly_eval 0 ` F)\n\ngoal (2 subgoals):\n 1. \\<And>F thesis.\n       \\<lbrakk>\\<And>a.\n                   (1::'a)\n                   \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                   thesis;\n        F \\<subseteq> P[{}]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  (1::'a) \\<notin> ideal (poly_eval 0 ` F)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule empty.prems)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (insert x X)"], ["proof (state)\nthis:\n  finite X\n  X \\<subseteq> {..<x}\n  \\<lbrakk>\\<And>a.\n              (1::'a) \\<notin> ideal (poly_eval a ` ?F) \\<Longrightarrow>\n              ?thesis;\n   ?F \\<subseteq> P[X]; 1 \\<notin> ideal ?F\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  (1::'a) \\<notin> ideal (poly_eval ?a ` F) \\<Longrightarrow> thesis\n  F \\<subseteq> P[insert x X]\n  1 \\<notin> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain a0 where \"1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\" (is \"_ \\<notin> ideal ?F\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a0.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a0 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"ideal F \\<inter> P[{x}] \\<subseteq> {0}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a0.\n                1 \\<notin> ideal\n                            (poly_eval (\\<lambda>_. monomial a0 0) `\n                             focus {x} ` F) \\<Longrightarrow>\n                thesis;\n     ideal F \\<inter> P[{x}] \\<subseteq> {0}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>a0.\n                1 \\<notin> ideal\n                            (poly_eval (\\<lambda>_. monomial a0 0) `\n                             focus {x} ` F) \\<Longrightarrow>\n                thesis;\n     \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  ideal F \\<inter> P[{x}] \\<subseteq> {0}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a0.\n                1 \\<notin> ideal\n                            (poly_eval (\\<lambda>_. monomial a0 0) `\n                             focus {x} ` F) \\<Longrightarrow>\n                thesis;\n     ideal F \\<inter> P[{x}] \\<subseteq> {0}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>a0.\n                1 \\<notin> ideal\n                            (poly_eval (\\<lambda>_. monomial a0 0) `\n                             focus {x} ` F) \\<Longrightarrow>\n                thesis;\n     \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\\<rbrakk>\n    \\<Longrightarrow> thesis", "with insert.hyps(1) insert.prems(2) insert.hyps(2) insert.prems(3)"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[insert x X]\n  X \\<subseteq> {..<x}\n  1 \\<notin> ideal F\n  ideal F \\<inter> P[{x}] \\<subseteq> {0}", "obtain a0\n        where \"1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[insert x X]\n  X \\<subseteq> {..<x}\n  1 \\<notin> ideal F\n  ideal F \\<inter> P[{x}] \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. (\\<And>a0.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a0 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule weak_Nullstellensatz_aux_2)"], ["proof (state)\nthis:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a0.\n                1 \\<notin> ideal\n                            (poly_eval (\\<lambda>_. monomial a0 0) `\n                             focus {x} ` F) \\<Longrightarrow>\n                thesis;\n     ideal F \\<inter> P[{x}] \\<subseteq> {0}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>a0.\n                1 \\<notin> ideal\n                            (poly_eval (\\<lambda>_. monomial a0 0) `\n                             focus {x} ` F) \\<Longrightarrow>\n                thesis;\n     \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a0.\n                1 \\<notin> ideal\n                            (poly_eval (\\<lambda>_. monomial a0 0) `\n                             focus {x} ` F) \\<Longrightarrow>\n                thesis;\n     \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a0.\n                1 \\<notin> ideal\n                            (poly_eval (\\<lambda>_. monomial a0 0) `\n                             focus {x} ` F) \\<Longrightarrow>\n                thesis;\n     \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a0.\n                1 \\<notin> ideal\n                            (poly_eval (\\<lambda>_. monomial a0 0) `\n                             focus {x} ` F) \\<Longrightarrow>\n                thesis;\n     \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\\<rbrakk>\n    \\<Longrightarrow> thesis", "from insert.hyps(2)"], ["proof (chain)\npicking this:\n  X \\<subseteq> {..<x}", "have \"x \\<notin> X\""], ["proof (prove)\nusing this:\n  X \\<subseteq> {..<x}\n\ngoal (1 subgoal):\n 1. x \\<notin> X", "by blast"], ["proof (state)\nthis:\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a0.\n                1 \\<notin> ideal\n                            (poly_eval (\\<lambda>_. monomial a0 0) `\n                             focus {x} ` F) \\<Longrightarrow>\n                thesis;\n     \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\\<rbrakk>\n    \\<Longrightarrow> thesis", "with insert.prems(2)"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[insert x X]\n  x \\<notin> X", "obtain a0 where \"1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[insert x X]\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. (\\<And>a0.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a0 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using insert.prems(3) False"], ["proof (prove)\nusing this:\n  F \\<subseteq> P[insert x X]\n  x \\<notin> X\n  1 \\<notin> ideal F\n  \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. (\\<And>a0.\n        1 \\<notin> ideal\n                    (poly_eval (\\<lambda>_. monomial a0 0) `\n                     focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule weak_Nullstellensatz_aux_3)"], ["proof (state)\nthis:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a0.\n                1 \\<notin> ideal\n                            (poly_eval (\\<lambda>_. monomial a0 0) `\n                             focus {x} ` F) \\<Longrightarrow>\n                thesis;\n     \\<not> ideal F \\<inter> P[{x}] \\<subseteq> {0}\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"?F \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "assume \"f \\<in> F\""], ["proof (state)\nthis:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "with insert.prems(2)"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[insert x X]\n  f \\<in> F", "have \"f \\<in> P[insert x X]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[insert x X]\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. f \\<in> P[insert x X]", ".."], ["proof (state)\nthis:\n  f \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "hence \"poly_eval (\\<lambda>_. monomial a0 0) (focus {x} f) \\<in> P[insert x X - {x}]\""], ["proof (prove)\nusing this:\n  f \\<in> P[insert x X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) (focus {x} f)\n    \\<in> P[insert x X - {x}]", "by (rule poly_eval_focus_in_Polys)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a0 0) (focus {x} f)\n  \\<in> P[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "also"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a0 0) (focus {x} f)\n  \\<in> P[insert x X - {x}]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "have \"\\<dots> \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[insert x X - {x}] \\<subseteq> P[X]", "by (rule Polys_mono) simp"], ["proof (state)\nthis:\n  P[insert x X - {x}] \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "finally"], ["proof (chain)\npicking this:\n  poly_eval (\\<lambda>_. monomial a0 0) (focus {x} f) \\<in> P[X]", "have \"poly_eval (\\<lambda>_. monomial a0 0) (focus {x} f) \\<in> P[X]\""], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>_. monomial a0 0) (focus {x} f) \\<in> P[X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) (focus {x} f) \\<in> P[X]", "."], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a0 0) (focus {x} f) \\<in> P[X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "}"], ["proof (state)\nthis:\n  ?f2 \\<in> F \\<Longrightarrow>\n  poly_eval (\\<lambda>_. monomial a0 0) (focus {x} ?f2) \\<in> P[X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?f2 \\<in> F \\<Longrightarrow>\n  poly_eval (\\<lambda>_. monomial a0 0) (focus {x} ?f2) \\<in> P[X]\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "by blast"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\n  poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]", "obtain a1 where \"1 \\<notin> ideal (poly_eval a1 ` ?F)\""], ["proof (prove)\nusing this:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\n  poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>a1.\n        (1::'a)\n        \\<notin> ideal\n                  (poly_eval a1 `\n                   poly_eval (\\<lambda>_. monomial a0 0) `\n                   focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using insert.hyps(3)"], ["proof (prove)\nusing this:\n  1 \\<notin> ideal (poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\n  poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F \\<subseteq> P[X]\n  \\<lbrakk>\\<And>a.\n              (1::'a) \\<notin> ideal (poly_eval a ` ?F) \\<Longrightarrow>\n              ?thesis;\n   ?F \\<subseteq> P[X]; 1 \\<notin> ideal ?F\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a1.\n        (1::'a)\n        \\<notin> ideal\n                  (poly_eval a1 `\n                   poly_eval (\\<lambda>_. monomial a0 0) `\n                   focus {x} ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (1::'a)\n  \\<notin> ideal\n            (poly_eval a1 `\n             poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  (1::'a)\n  \\<notin> ideal\n            (poly_eval a1 `\n             poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F)\n\ngoal (1 subgoal):\n 1. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"poly_eval a1 ` ?F = poly_eval (a1(x := poly_eval a1 (monomial a0 0))) ` F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a1 ` poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F =\n    poly_eval (a1(x := poly_eval a1 (monomial a0 0))) ` F", "by (simp add: image_image poly_eval_poly_eval_focus fun_upd_def)"], ["proof (state)\nthis:\n  poly_eval a1 ` poly_eval (\\<lambda>_. monomial a0 0) ` focus {x} ` F =\n  poly_eval (a1(x := poly_eval a1 (monomial a0 0))) ` F\n\ngoal (1 subgoal):\n 1. \\<And>a A F thesis.\n       \\<lbrakk>finite A; A \\<subseteq> {..<a};\n        \\<And>F thesis.\n           \\<lbrakk>\\<And>a.\n                       (1::'a)\n                       \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n                       thesis;\n            F \\<subseteq> P[A]; 1 \\<notin> ideal F\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>a.\n           (1::'a) \\<notin> ideal (poly_eval a ` F) \\<Longrightarrow>\n           thesis;\n        F \\<subseteq> P[insert a A]; 1 \\<notin> ideal F\\<rbrakk>\n       \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  (1::'a)\n  \\<notin> ideal (poly_eval (a1(x := poly_eval a1 (monomial a0 0))) ` F)", "show ?case"], ["proof (prove)\nusing this:\n  (1::'a)\n  \\<notin> ideal (poly_eval (a1(x := poly_eval a1 (monomial a0 0))) ` F)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule insert.prems)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (1::'a) \\<notin> ideal (poly_eval a ` F)\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal F \\<Longrightarrow> False", "hence \"ideal (poly_eval a ` F) \\<noteq> UNIV\""], ["proof (prove)\nusing this:\n  (1::'a) \\<notin> ideal (poly_eval a ` F)\n\ngoal (1 subgoal):\n 1. ideal (poly_eval a ` F) \\<noteq> UNIV", "by (simp add: ideal_eq_UNIV_iff_contains_one)"], ["proof (state)\nthis:\n  ideal (poly_eval a ` F) \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal F \\<Longrightarrow> False", "hence \"ideal (poly_eval a ` F) = {0}\""], ["proof (prove)\nusing this:\n  ideal (poly_eval a ` F) \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. ideal (poly_eval a ` F) = {0::'a}", "using ideal_field_disj[of \"poly_eval a ` F\"]"], ["proof (prove)\nusing this:\n  ideal (poly_eval a ` F) \\<noteq> UNIV\n  ideal (poly_eval a ` F) = {0::'a} \\<or> ideal (poly_eval a ` F) = UNIV\n\ngoal (1 subgoal):\n 1. ideal (poly_eval a ` F) = {0::'a}", "by blast"], ["proof (state)\nthis:\n  ideal (poly_eval a ` F) = {0::'a}\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal F \\<Longrightarrow> False", "hence \"poly_eval a ` F \\<subseteq> {0}\""], ["proof (prove)\nusing this:\n  ideal (poly_eval a ` F) = {0::'a}\n\ngoal (1 subgoal):\n 1. poly_eval a ` F \\<subseteq> {0::'a}", "by simp"], ["proof (state)\nthis:\n  poly_eval a ` F \\<subseteq> {0::'a}\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal F \\<Longrightarrow> False", "hence \"a \\<in> \\<V> F\""], ["proof (prove)\nusing this:\n  poly_eval a ` F \\<subseteq> {0::'a}\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V> F", "by (rule variety_ofI_alt)"], ["proof (state)\nthis:\n  a \\<in> \\<V> F\n\ngoal (1 subgoal):\n 1. 1 \\<notin> ideal F \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  a \\<in> \\<V> F\n\ngoal (1 subgoal):\n 1. False", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma radical_idealI:\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\" and \"f \\<in> P[X]\" and \"x \\<notin> X\"\n    and \"\\<V> (insert (1 - punit.monom_mult 1 (Poly_Mapping.single x 1) f) F) = {}\"\n  shows \"(f::('x::{countable,linorder} \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::alg_closed_field) \\<in> \\<surd>ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "proof (cases \"f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F\n 2. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "case True"], ["proof (state)\nthis:\n  f = 0\n\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F\n 2. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = 0\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "by simp"], ["proof (state)\nthis:\n  f \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "case False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "from assms(4)"], ["proof (chain)\npicking this:\n  x \\<notin> X", "have \"P[X] \\<subseteq> P[- {x}]\""], ["proof (prove)\nusing this:\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. P[X] \\<subseteq> P[- {x}]", "by (auto simp: Polys_alt)"], ["proof (state)\nthis:\n  P[X] \\<subseteq> P[- {x}]\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "with assms(3)"], ["proof (chain)\npicking this:\n  f \\<in> P[X]\n  P[X] \\<subseteq> P[- {x}]", "have \"f \\<in> P[- {x}]\""], ["proof (prove)\nusing this:\n  f \\<in> P[X]\n  P[X] \\<subseteq> P[- {x}]\n\ngoal (1 subgoal):\n 1. f \\<in> P[- {x}]", ".."], ["proof (state)\nthis:\n  f \\<in> P[- {x}]\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "let ?x = \"Poly_Mapping.single x 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "let ?f = \"punit.monom_mult 1 ?x f\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "from assms(1)"], ["proof (chain)\npicking this:\n  finite X", "have \"finite (insert x X)\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. finite (insert x X)", "by simp"], ["proof (state)\nthis:\n  finite (insert x X)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "moreover"], ["proof (state)\nthis:\n  finite (insert x X)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "have \"insert (1 - ?f) F \\<subseteq> P[insert x X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F\n    \\<subseteq> P[insert x X]", "unfolding insert_subset"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> P[insert x X] \\<and>\n    F \\<subseteq> P[insert x X]", "proof (intro conjI Polys_closed_minus one_in_Polys Polys_closed_monom_mult PPs_closed_single)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<in> insert x X\n 2. f \\<in> P[insert x X]\n 3. F \\<subseteq> P[insert x X]", "have \"P[X] \\<subseteq> P[insert x X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[X] \\<subseteq> P[insert x X]", "by (rule Polys_mono) blast"], ["proof (state)\nthis:\n  P[X] \\<subseteq> P[insert x X]\n\ngoal (3 subgoals):\n 1. x \\<in> insert x X\n 2. f \\<in> P[insert x X]\n 3. F \\<subseteq> P[insert x X]", "with assms(2, 3)"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[X]\n  f \\<in> P[X]\n  P[X] \\<subseteq> P[insert x X]", "show \"f \\<in> P[insert x X]\" and \"F \\<subseteq> P[insert x X]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[X]\n  f \\<in> P[X]\n  P[X] \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. f \\<in> P[insert x X] &&& F \\<subseteq> P[insert x X]", "by blast+"], ["proof (state)\nthis:\n  f \\<in> P[insert x X]\n  F \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. x \\<in> insert x X", "qed simp"], ["proof (state)\nthis:\n  insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F\n  \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "ultimately"], ["proof (chain)\npicking this:\n  finite (insert x X)\n  insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F\n  \\<subseteq> P[insert x X]", "have \"ideal (insert (1 - ?f) F) = UNIV\""], ["proof (prove)\nusing this:\n  finite (insert x X)\n  insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F\n  \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. ideal (insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F) = UNIV", "using assms(5)"], ["proof (prove)\nusing this:\n  finite (insert x X)\n  insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F\n  \\<subseteq> P[insert x X]\n  \\<V> (insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F) = {}\n\ngoal (1 subgoal):\n 1. ideal (insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F) = UNIV", "by (rule weak_Nullstellensatz)"], ["proof (state)\nthis:\n  ideal (insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F) = UNIV\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "hence \"1 \\<in> ideal (insert (1 - ?f) F)\""], ["proof (prove)\nusing this:\n  ideal (insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F) = UNIV\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal (insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F)", "by simp"], ["proof (state)\nthis:\n  1 \\<in> ideal (insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "then"], ["proof (chain)\npicking this:\n  1 \\<in> ideal (insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F)", "obtain F' q where fin': \"finite F'\" and F'_sub: \"F' \\<subseteq> insert (1 - ?f) F\"\n    and eq: \"1 = (\\<Sum>f'\\<in>F'. q f' * f')\""], ["proof (prove)\nusing this:\n  1 \\<in> ideal (insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F)\n\ngoal (1 subgoal):\n 1. (\\<And>F' q.\n        \\<lbrakk>finite F';\n         F' \\<subseteq> insert\n                         (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F;\n         1 = (\\<Sum>f'\\<in>F'. q f' * f')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule ideal.spanE)"], ["proof (state)\nthis:\n  finite F'\n  F' \\<subseteq> insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F\n  1 = (\\<Sum>f'\\<in>F'. q f' * f')\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> f \\<in> \\<surd>ideal F", "show \"f \\<in> \\<surd>ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "proof (cases \"1 - ?f \\<in> F'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "case True"], ["proof (state)\nthis:\n  1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F'\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "define g where \"g = (\\<lambda>x::('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a. Fract x 1)\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. Fraction_Field.Fract x 1)\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "define F'' where \"F'' = F' - {1 - ?f}\""], ["proof (state)\nthis:\n  F'' = F' - {1 - punit.monom_mult (1::'a) (monomial 1 x) f}\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "define q0 where \"q0 = q (1 - ?f)\""], ["proof (state)\nthis:\n  q0 = q (1 - punit.monom_mult (1::'a) (monomial 1 x) f)\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have g_0: \"g 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g 0 = 0", "by (simp add: g_def fract_collapse)"], ["proof (state)\nthis:\n  g 0 = 0\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have g_1: \"g 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g 1 = 1", "by (simp add: g_def fract_collapse)"], ["proof (state)\nthis:\n  g 1 = 1\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have g_plus: \"g (a + b) = g a + g b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (a + b) = g a + g b", "by (simp add: g_def)"], ["proof (state)\nthis:\n  g (?a2 + ?b2) = g ?a2 + g ?b2\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have g_minus: \"g (a - b) = g a - g b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (a - b) = g a - g b", "by (simp add: g_def)"], ["proof (state)\nthis:\n  g (?a2 - ?b2) = g ?a2 - g ?b2\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have g_times: \"g (a * b) = g a * g b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (a * b) = g a * g b", "by (simp add: g_def)"], ["proof (state)\nthis:\n  g (?a2 * ?b2) = g ?a2 * g ?b2\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "from fin'"], ["proof (chain)\npicking this:\n  finite F'", "have fin'': \"finite F''\""], ["proof (prove)\nusing this:\n  finite F'\n\ngoal (1 subgoal):\n 1. finite F''", "by (simp add: F''_def)"], ["proof (state)\nthis:\n  finite F''\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "from F'_sub"], ["proof (chain)\npicking this:\n  F' \\<subseteq> insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F", "have F''_sub: \"F'' \\<subseteq> F\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F\n\ngoal (1 subgoal):\n 1. F'' \\<subseteq> F", "by (auto simp: F''_def)"], ["proof (state)\nthis:\n  F'' \\<subseteq> F\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have \"focus {x} ?f = monomial 1 ?x * focus {x} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. focus {x} (punit.monom_mult (1::'a) (monomial 1 x) f) =\n    monomial 1 (monomial 1 x) * focus {x} f", "by (simp add: focus_times focus_monomial except_single flip: times_monomial_left)"], ["proof (state)\nthis:\n  focus {x} (punit.monom_mult (1::'a) (monomial 1 x) f) =\n  monomial 1 (monomial 1 x) * focus {x} f\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "also"], ["proof (state)\nthis:\n  focus {x} (punit.monom_mult (1::'a) (monomial 1 x) f) =\n  monomial 1 (monomial 1 x) * focus {x} f\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "from \\<open>f \\<in> P[- {x}]\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> P[- {x}]", "have \"focus {x} f = monomial f 0\""], ["proof (prove)\nusing this:\n  f \\<in> P[- {x}]\n\ngoal (1 subgoal):\n 1. focus {x} f = monomial f 0", "by (rule focus_Polys_Compl)"], ["proof (state)\nthis:\n  focus {x} f = monomial f 0\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "finally"], ["proof (chain)\npicking this:\n  focus {x} (punit.monom_mult (1::'a) (monomial 1 x) f) =\n  monomial 1 (monomial 1 x) * monomial f 0", "have \"focus {x} ?f = monomial f ?x\""], ["proof (prove)\nusing this:\n  focus {x} (punit.monom_mult (1::'a) (monomial 1 x) f) =\n  monomial 1 (monomial 1 x) * monomial f 0\n\ngoal (1 subgoal):\n 1. focus {x} (punit.monom_mult (1::'a) (monomial 1 x) f) =\n    monomial f (monomial 1 x)", "by (simp add: times_monomial_monomial)"], ["proof (state)\nthis:\n  focus {x} (punit.monom_mult (1::'a) (monomial 1 x) f) =\n  monomial f (monomial 1 x)\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "hence eq1: \"poly (map_poly g (poly_of_focus x (1 - ?f))) (Fract 1 f) = 0\""], ["proof (prove)\nusing this:\n  focus {x} (punit.monom_mult (1::'a) (monomial 1 x) f) =\n  monomial f (monomial 1 x)\n\ngoal (1 subgoal):\n 1. poly\n     (map_poly g\n       (poly_of_focus x (1 - punit.monom_mult (1::'a) (monomial 1 x) f)))\n     (Fraction_Field.Fract 1 f) =\n    0", "by (simp add: poly_of_focus_def focus_minus poly_of_pm_minus poly_of_pm_monomial\n                PPs_closed_single map_poly_minus g_0 g_1 g_minus map_poly_monom poly_monom)\n         (simp add: g_def Fract_same \\<open>f \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  poly\n   (map_poly g\n     (poly_of_focus x (1 - punit.monom_mult (1::'a) (monomial 1 x) f)))\n   (Fraction_Field.Fract 1 f) =\n  0\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have eq2: \"poly (map_poly g (poly_of_focus x f')) (Fract 1 f) = Fract f' 1\" if \"f' \\<in> F''\" for f'"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x f')) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract f' 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x f')) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract f' 1", "from that F''_sub"], ["proof (chain)\npicking this:\n  f' \\<in> F''\n  F'' \\<subseteq> F", "have \"f' \\<in> F\""], ["proof (prove)\nusing this:\n  f' \\<in> F''\n  F'' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. f' \\<in> F", ".."], ["proof (state)\nthis:\n  f' \\<in> F\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x f')) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract f' 1", "with assms(2)"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[X]\n  f' \\<in> F", "have \"f' \\<in> P[X]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[X]\n  f' \\<in> F\n\ngoal (1 subgoal):\n 1. f' \\<in> P[X]", ".."], ["proof (state)\nthis:\n  f' \\<in> P[X]\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x f')) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract f' 1", "with \\<open>P[X] \\<subseteq> _\\<close>"], ["proof (chain)\npicking this:\n  P[X] \\<subseteq> P[- {x}]\n  f' \\<in> P[X]", "have \"f' \\<in> P[- {x}]\""], ["proof (prove)\nusing this:\n  P[X] \\<subseteq> P[- {x}]\n  f' \\<in> P[X]\n\ngoal (1 subgoal):\n 1. f' \\<in> P[- {x}]", ".."], ["proof (state)\nthis:\n  f' \\<in> P[- {x}]\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x f')) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract f' 1", "hence \"focus {x} f' = monomial f' 0\""], ["proof (prove)\nusing this:\n  f' \\<in> P[- {x}]\n\ngoal (1 subgoal):\n 1. focus {x} f' = monomial f' 0", "by (rule focus_Polys_Compl)"], ["proof (state)\nthis:\n  focus {x} f' = monomial f' 0\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x f')) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract f' 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  focus {x} f' = monomial f' 0\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x f')) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract f' 1", "by (simp add: poly_of_focus_def focus_minus poly_of_pm_minus poly_of_pm_monomial\n                zero_in_PPs map_poly_minus g_0 g_1 g_minus map_poly_monom poly_monom)\n           (simp only: g_def)"], ["proof (state)\nthis:\n  poly (map_poly g (poly_of_focus x f')) (Fraction_Field.Fract 1 f) =\n  Fraction_Field.Fract f' 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f'2 \\<in> F'' \\<Longrightarrow>\n  poly (map_poly g (poly_of_focus x ?f'2)) (Fraction_Field.Fract 1 f) =\n  Fraction_Field.Fract ?f'2 1\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "define p0m0 where \"p0m0 = (\\<lambda>f'. SOME z. poly (map_poly g (poly_of_focus x (q f'))) (Fract 1 f) =\n                                              Fract (fst z) (f ^ snd z))\""], ["proof (state)\nthis:\n  p0m0 =\n  (\\<lambda>f'.\n      SOME z.\n         poly (map_poly g (poly_of_focus x (q f')))\n          (Fraction_Field.Fract 1 f) =\n         Fraction_Field.Fract (fst z) (f ^ snd z))\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "define p0 where \"p0 = fst \\<circ> p0m0\""], ["proof (state)\nthis:\n  p0 = fst \\<circ> p0m0\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "define m0 where \"m0 = snd \\<circ> p0m0\""], ["proof (state)\nthis:\n  m0 = snd \\<circ> p0m0\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "define m where \"m = Max (m0 ` F'')\""], ["proof (state)\nthis:\n  m = Max (m0 ` F'')\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have eq3: \"poly (map_poly g (poly_of_focus x (q f'))) (Fract 1 f) = Fract (p0 f') (f ^ m0 f')\"\n      for f'"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract (p0 f') (f ^ m0 f')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract (p0 f') (f ^ m0 f')", "have \"g a = 0 \\<longleftrightarrow> a = 0\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g a = 0) = (a = 0)", "by (simp add: g_def Fract_eq_zero_iff)"], ["proof (state)\nthis:\n  (g ?a2 = 0) = (?a2 = 0)\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract (p0 f') (f ^ m0 f')", "hence \"set (Polynomial.coeffs (map_poly g (poly_of_focus x (q f')))) \\<subseteq> range (\\<lambda>x. Fract x 1)\""], ["proof (prove)\nusing this:\n  (g ?a2 = 0) = (?a2 = 0)\n\ngoal (1 subgoal):\n 1. set (Polynomial.coeffs (map_poly g (poly_of_focus x (q f'))))\n    \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x 1)", "by (auto simp: set_coeffs_map_poly g_def)"], ["proof (state)\nthis:\n  set (Polynomial.coeffs (map_poly g (poly_of_focus x (q f'))))\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x 1)\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract (p0 f') (f ^ m0 f')", "then"], ["proof (chain)\npicking this:\n  set (Polynomial.coeffs (map_poly g (poly_of_focus x (q f'))))\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x 1)", "obtain p m' where \"poly (map_poly g (poly_of_focus x (q f'))) (Fract 1 f) = Fract p (f ^ m')\""], ["proof (prove)\nusing this:\n  set (Polynomial.coeffs (map_poly g (poly_of_focus x (q f'))))\n  \\<subseteq> range (\\<lambda>x. Fraction_Field.Fract x 1)\n\ngoal (1 subgoal):\n 1. (\\<And>p m'.\n        poly (map_poly g (poly_of_focus x (q f')))\n         (Fraction_Field.Fract 1 f) =\n        Fraction_Field.Fract p (f ^ m') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule poly_Fract)"], ["proof (state)\nthis:\n  poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n  Fraction_Field.Fract p (f ^ m')\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract (p0 f') (f ^ m0 f')", "hence \"poly (map_poly g (poly_of_focus x (q f'))) (Fract 1 f) = Fract (fst (p, m')) (f ^ snd (p, m'))\""], ["proof (prove)\nusing this:\n  poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n  Fraction_Field.Fract p (f ^ m')\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract (fst (p, m')) (f ^ snd (p, m'))", "by simp"], ["proof (state)\nthis:\n  poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n  Fraction_Field.Fract (fst (p, m')) (f ^ snd (p, m'))\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract (p0 f') (f ^ m0 f')", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n  Fraction_Field.Fract (fst (p, m')) (f ^ snd (p, m'))\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract (p0 f') (f ^ m0 f')", "unfolding p0_def m0_def p0m0_def o_def"], ["proof (prove)\nusing this:\n  poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n  Fraction_Field.Fract (fst (p, m')) (f ^ snd (p, m'))\n\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n    Fraction_Field.Fract\n     (fst (SOME z.\n              poly (map_poly g (poly_of_focus x (q f')))\n               (Fraction_Field.Fract 1 f) =\n              Fraction_Field.Fract (fst z) (f ^ snd z)))\n     (f ^\n      snd (SOME z.\n              poly (map_poly g (poly_of_focus x (q f')))\n               (Fraction_Field.Fract 1 f) =\n              Fraction_Field.Fract (fst z) (f ^ snd z)))", "by (rule someI)"], ["proof (state)\nthis:\n  poly (map_poly g (poly_of_focus x (q f'))) (Fraction_Field.Fract 1 f) =\n  Fraction_Field.Fract (p0 f') (f ^ m0 f')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (map_poly g (poly_of_focus x (q ?f'2))) (Fraction_Field.Fract 1 f) =\n  Fraction_Field.Fract (p0 ?f'2) (f ^ m0 ?f'2)\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "note eq"], ["proof (state)\nthis:\n  1 = (\\<Sum>f'\\<in>F'. q f' * f')\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "also"], ["proof (state)\nthis:\n  1 = (\\<Sum>f'\\<in>F'. q f' * f')\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "from True fin'"], ["proof (chain)\npicking this:\n  1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F'\n  finite F'", "have \"(\\<Sum>f'\\<in>F'. q f' * f') = q0 * (1 - ?f) + (\\<Sum>f'\\<in>F''. q f' * f')\""], ["proof (prove)\nusing this:\n  1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F'\n  finite F'\n\ngoal (1 subgoal):\n 1. (\\<Sum>f'\\<in>F'. q f' * f') =\n    q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n    (\\<Sum>f'\\<in>F''. q f' * f')", "by (simp add: q0_def F''_def sum.remove)"], ["proof (state)\nthis:\n  (\\<Sum>f'\\<in>F'. q f' * f') =\n  q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n  (\\<Sum>f'\\<in>F''. q f' * f')\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "finally"], ["proof (chain)\npicking this:\n  1 =\n  q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n  (\\<Sum>f'\\<in>F''. q f' * f')", "have \"poly_of_focus x 1 = poly_of_focus x (q0 * (1 - ?f) + (\\<Sum>f'\\<in>F''. q f' * f'))\""], ["proof (prove)\nusing this:\n  1 =\n  q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n  (\\<Sum>f'\\<in>F''. q f' * f')\n\ngoal (1 subgoal):\n 1. poly_of_focus x 1 =\n    poly_of_focus x\n     (q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n      (\\<Sum>f'\\<in>F''. q f' * f'))", "by (rule arg_cong)"], ["proof (state)\nthis:\n  poly_of_focus x 1 =\n  poly_of_focus x\n   (q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n    (\\<Sum>f'\\<in>F''. q f' * f'))\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "hence \"1 = poly (map_poly g (poly_of_focus x (q0 * (1 - ?f) + (\\<Sum>f'\\<in>F''. q f' * f')))) (Fract 1 f)\""], ["proof (prove)\nusing this:\n  poly_of_focus x 1 =\n  poly_of_focus x\n   (q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n    (\\<Sum>f'\\<in>F''. q f' * f'))\n\ngoal (1 subgoal):\n 1. 1 =\n    poly\n     (map_poly g\n       (poly_of_focus x\n         (q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n          (\\<Sum>f'\\<in>F''. q f' * f'))))\n     (Fraction_Field.Fract 1 f)", "by (simp add: g_1)"], ["proof (state)\nthis:\n  1 =\n  poly\n   (map_poly g\n     (poly_of_focus x\n       (q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n        (\\<Sum>f'\\<in>F''. q f' * f'))))\n   (Fraction_Field.Fract 1 f)\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "also"], ["proof (state)\nthis:\n  1 =\n  poly\n   (map_poly g\n     (poly_of_focus x\n       (q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n        (\\<Sum>f'\\<in>F''. q f' * f'))))\n   (Fraction_Field.Fract 1 f)\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have \"\\<dots> = poly (map_poly g (poly_of_focus x (\\<Sum>f'\\<in>F''. q f' * f'))) (Fract 1 f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     (map_poly g\n       (poly_of_focus x\n         (q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n          (\\<Sum>f'\\<in>F''. q f' * f'))))\n     (Fraction_Field.Fract 1 f) =\n    poly (map_poly g (poly_of_focus x (\\<Sum>f'\\<in>F''. q f' * f')))\n     (Fraction_Field.Fract 1 f)", "by (simp only: poly_of_focus_plus map_poly_plus g_0 g_plus g_times poly_add\n                poly_of_focus_times map_poly_times poly_mult eq1 mult_zero_right add_0_left)"], ["proof (state)\nthis:\n  poly\n   (map_poly g\n     (poly_of_focus x\n       (q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n        (\\<Sum>f'\\<in>F''. q f' * f'))))\n   (Fraction_Field.Fract 1 f) =\n  poly (map_poly g (poly_of_focus x (\\<Sum>f'\\<in>F''. q f' * f')))\n   (Fraction_Field.Fract 1 f)\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "also"], ["proof (state)\nthis:\n  poly\n   (map_poly g\n     (poly_of_focus x\n       (q0 * (1 - punit.monom_mult (1::'a) (monomial 1 x) f) +\n        (\\<Sum>f'\\<in>F''. q f' * f'))))\n   (Fraction_Field.Fract 1 f) =\n  poly (map_poly g (poly_of_focus x (\\<Sum>f'\\<in>F''. q f' * f')))\n   (Fraction_Field.Fract 1 f)\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have \"\\<dots> = (\\<Sum>f'\\<in>F''. Fract (p0 f') (f ^ m0 f') * Fract f' 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly g (poly_of_focus x (\\<Sum>f'\\<in>F''. q f' * f')))\n     (Fraction_Field.Fract 1 f) =\n    (\\<Sum>f'\\<in>F''.\n       Fraction_Field.Fract (p0 f') (f ^ m0 f') * Fraction_Field.Fract f' 1)", "by (simp only: poly_of_focus_sum poly_of_focus_times map_poly_sum map_poly_times\n                g_0 g_plus g_times poly_sum poly_mult eq2 eq3 cong: sum.cong)"], ["proof (state)\nthis:\n  poly (map_poly g (poly_of_focus x (\\<Sum>f'\\<in>F''. q f' * f')))\n   (Fraction_Field.Fract 1 f) =\n  (\\<Sum>f'\\<in>F''.\n     Fraction_Field.Fract (p0 f') (f ^ m0 f') * Fraction_Field.Fract f' 1)\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "finally"], ["proof (chain)\npicking this:\n  1 =\n  (\\<Sum>f'\\<in>F''.\n     Fraction_Field.Fract (p0 f') (f ^ m0 f') * Fraction_Field.Fract f' 1)", "have \"Fract (f ^ m) 1 = Fract (f ^ m) 1 * (\\<Sum>f'\\<in>F''. Fract (p0 f' * f') (f ^ m0 f'))\""], ["proof (prove)\nusing this:\n  1 =\n  (\\<Sum>f'\\<in>F''.\n     Fraction_Field.Fract (p0 f') (f ^ m0 f') * Fraction_Field.Fract f' 1)\n\ngoal (1 subgoal):\n 1. Fraction_Field.Fract (f ^ m) 1 =\n    Fraction_Field.Fract (f ^ m) 1 *\n    (\\<Sum>f'\\<in>F''. Fraction_Field.Fract (p0 f' * f') (f ^ m0 f'))", "by simp"], ["proof (state)\nthis:\n  Fraction_Field.Fract (f ^ m) 1 =\n  Fraction_Field.Fract (f ^ m) 1 *\n  (\\<Sum>f'\\<in>F''. Fraction_Field.Fract (p0 f' * f') (f ^ m0 f'))\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "also"], ["proof (state)\nthis:\n  Fraction_Field.Fract (f ^ m) 1 =\n  Fraction_Field.Fract (f ^ m) 1 *\n  (\\<Sum>f'\\<in>F''. Fraction_Field.Fract (p0 f' * f') (f ^ m0 f'))\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have \"\\<dots> = (\\<Sum>f'\\<in>F''. Fract (f ^ m * (p0 f' * f')) (f ^ m0 f'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fraction_Field.Fract (f ^ m) 1 *\n    (\\<Sum>f'\\<in>F''. Fraction_Field.Fract (p0 f' * f') (f ^ m0 f')) =\n    (\\<Sum>f'\\<in>F''.\n       Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f'))", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  Fraction_Field.Fract (f ^ m) 1 *\n  (\\<Sum>f'\\<in>F''. Fraction_Field.Fract (p0 f' * f') (f ^ m0 f')) =\n  (\\<Sum>f'\\<in>F''.\n     Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f'))\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "also"], ["proof (state)\nthis:\n  Fraction_Field.Fract (f ^ m) 1 *\n  (\\<Sum>f'\\<in>F''. Fraction_Field.Fract (p0 f' * f') (f ^ m0 f')) =\n  (\\<Sum>f'\\<in>F''.\n     Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f'))\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"\\<dots> = (\\<Sum>f'\\<in>F''. Fract ((f ^ (m - m0 f') * p0 f') * f') 1)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. (\\<Sum>f'\\<in>F''.\n       Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f')) =\n    (\\<Sum>f'\\<in>F''.\n       Fraction_Field.Fract (f ^ (m - m0 f') * p0 f' * f') 1)", "proof (rule sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       Fraction_Field.Fract (f ^ m * (p0 x * x)) (f ^ m0 x) =\n       Fraction_Field.Fract (f ^ (m - m0 x) * p0 x * x) 1", "fix f'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       Fraction_Field.Fract (f ^ m * (p0 x * x)) (f ^ m0 x) =\n       Fraction_Field.Fract (f ^ (m - m0 x) * p0 x * x) 1", "assume \"f' \\<in> F''\""], ["proof (state)\nthis:\n  f' \\<in> F''\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       Fraction_Field.Fract (f ^ m * (p0 x * x)) (f ^ m0 x) =\n       Fraction_Field.Fract (f ^ (m - m0 x) * p0 x * x) 1", "hence \"m0 f' \\<in> m0 ` F''\""], ["proof (prove)\nusing this:\n  f' \\<in> F''\n\ngoal (1 subgoal):\n 1. m0 f' \\<in> m0 ` F''", "by (rule imageI)"], ["proof (state)\nthis:\n  m0 f' \\<in> m0 ` F''\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       Fraction_Field.Fract (f ^ m * (p0 x * x)) (f ^ m0 x) =\n       Fraction_Field.Fract (f ^ (m - m0 x) * p0 x * x) 1", "with _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  m0 f' \\<in> m0 ` F''", "have \"m0 f' \\<le> m\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  m0 f' \\<in> m0 ` F''\n\ngoal (1 subgoal):\n 1. m0 f' \\<le> m", "unfolding m_def"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  m0 f' \\<in> m0 ` F''\n\ngoal (1 subgoal):\n 1. m0 f' \\<le> Max (m0 ` F'')", "by (rule Max_ge) (simp add: fin'')"], ["proof (state)\nthis:\n  m0 f' \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       Fraction_Field.Fract (f ^ m * (p0 x * x)) (f ^ m0 x) =\n       Fraction_Field.Fract (f ^ (m - m0 x) * p0 x * x) 1", "hence \"f ^ m = f ^ (m0 f') * f ^ (m - m0 f')\""], ["proof (prove)\nusing this:\n  m0 f' \\<le> m\n\ngoal (1 subgoal):\n 1. f ^ m = f ^ m0 f' * f ^ (m - m0 f')", "by (simp flip: power_add)"], ["proof (state)\nthis:\n  f ^ m = f ^ m0 f' * f ^ (m - m0 f')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       Fraction_Field.Fract (f ^ m * (p0 x * x)) (f ^ m0 x) =\n       Fraction_Field.Fract (f ^ (m - m0 x) * p0 x * x) 1", "hence \"Fract (f ^ m * (p0 f' * f')) (f ^ m0 f') = Fract (f ^ m0 f') (f ^ m0 f') *\n                                                        Fract (f ^ (m - m0 f') * (p0 f' * f')) 1\""], ["proof (prove)\nusing this:\n  f ^ m = f ^ m0 f' * f ^ (m - m0 f')\n\ngoal (1 subgoal):\n 1. Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f') =\n    Fraction_Field.Fract (f ^ m0 f') (f ^ m0 f') *\n    Fraction_Field.Fract (f ^ (m - m0 f') * (p0 f' * f')) 1", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f') =\n  Fraction_Field.Fract (f ^ m0 f') (f ^ m0 f') *\n  Fraction_Field.Fract (f ^ (m - m0 f') * (p0 f' * f')) 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       Fraction_Field.Fract (f ^ m * (p0 x * x)) (f ^ m0 x) =\n       Fraction_Field.Fract (f ^ (m - m0 x) * p0 x * x) 1", "also"], ["proof (state)\nthis:\n  Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f') =\n  Fraction_Field.Fract (f ^ m0 f') (f ^ m0 f') *\n  Fraction_Field.Fract (f ^ (m - m0 f') * (p0 f' * f')) 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       Fraction_Field.Fract (f ^ m * (p0 x * x)) (f ^ m0 x) =\n       Fraction_Field.Fract (f ^ (m - m0 x) * p0 x * x) 1", "from \\<open>f \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "have \"Fract (f ^ m0 f') (f ^ m0 f') = 1\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Fraction_Field.Fract (f ^ m0 f') (f ^ m0 f') = 1", "by (simp add: Fract_same)"], ["proof (state)\nthis:\n  Fraction_Field.Fract (f ^ m0 f') (f ^ m0 f') = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> F'' \\<Longrightarrow>\n       Fraction_Field.Fract (f ^ m * (p0 x * x)) (f ^ m0 x) =\n       Fraction_Field.Fract (f ^ (m - m0 x) * p0 x * x) 1", "finally"], ["proof (chain)\npicking this:\n  Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f') =\n  1 * Fraction_Field.Fract (f ^ (m - m0 f') * (p0 f' * f')) 1", "show \"Fract (f ^ m * (p0 f' * f')) (f ^ m0 f') = Fract (f ^ (m - m0 f') * p0 f' * f') 1\""], ["proof (prove)\nusing this:\n  Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f') =\n  1 * Fraction_Field.Fract (f ^ (m - m0 f') * (p0 f' * f')) 1\n\ngoal (1 subgoal):\n 1. Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f') =\n    Fraction_Field.Fract (f ^ (m - m0 f') * p0 f' * f') 1", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f') =\n  Fraction_Field.Fract (f ^ (m - m0 f') * p0 f' * f') 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>f'\\<in>F''.\n     Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f')) =\n  (\\<Sum>f'\\<in>F''. Fraction_Field.Fract (f ^ (m - m0 f') * p0 f' * f') 1)\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "also"], ["proof (state)\nthis:\n  (\\<Sum>f'\\<in>F''.\n     Fraction_Field.Fract (f ^ m * (p0 f' * f')) (f ^ m0 f')) =\n  (\\<Sum>f'\\<in>F''. Fraction_Field.Fract (f ^ (m - m0 f') * p0 f' * f') 1)\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "from fin''"], ["proof (chain)\npicking this:\n  finite F''", "have \"\\<dots> = Fract (\\<Sum>f'\\<in>F''. (f ^ (m - m0 f') * p0 f') * f') 1\""], ["proof (prove)\nusing this:\n  finite F''\n\ngoal (1 subgoal):\n 1. (\\<Sum>f'\\<in>F''.\n       Fraction_Field.Fract (f ^ (m - m0 f') * p0 f' * f') 1) =\n    Fraction_Field.Fract (\\<Sum>f'\\<in>F''. f ^ (m - m0 f') * p0 f' * f') 1", "by (induct F'') (simp_all add: fract_collapse)"], ["proof (state)\nthis:\n  (\\<Sum>f'\\<in>F''.\n     Fraction_Field.Fract (f ^ (m - m0 f') * p0 f' * f') 1) =\n  Fraction_Field.Fract (\\<Sum>f'\\<in>F''. f ^ (m - m0 f') * p0 f' * f') 1\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "finally"], ["proof (chain)\npicking this:\n  Fraction_Field.Fract (f ^ m) 1 =\n  Fraction_Field.Fract (\\<Sum>f'\\<in>F''. f ^ (m - m0 f') * p0 f' * f') 1", "have \"f ^ m = (\\<Sum>f'\\<in>F''. (f ^ (m - m0 f') * p0 f') * f')\""], ["proof (prove)\nusing this:\n  Fraction_Field.Fract (f ^ m) 1 =\n  Fraction_Field.Fract (\\<Sum>f'\\<in>F''. f ^ (m - m0 f') * p0 f' * f') 1\n\ngoal (1 subgoal):\n 1. f ^ m = (\\<Sum>f'\\<in>F''. f ^ (m - m0 f') * p0 f' * f')", "by (simp add: eq_fract)"], ["proof (state)\nthis:\n  f ^ m = (\\<Sum>f'\\<in>F''. f ^ (m - m0 f') * p0 f' * f')\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "also"], ["proof (state)\nthis:\n  f ^ m = (\\<Sum>f'\\<in>F''. f ^ (m - m0 f') * p0 f' * f')\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have \"\\<dots> \\<in> ideal F''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f'\\<in>F''. f ^ (m - m0 f') * p0 f' * f') \\<in> ideal F''", "by (rule ideal.sum_in_spanI)"], ["proof (state)\nthis:\n  (\\<Sum>f'\\<in>F''. f ^ (m - m0 f') * p0 f' * f') \\<in> ideal F''\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "also"], ["proof (state)\nthis:\n  (\\<Sum>f'\\<in>F''. f ^ (m - m0 f') * p0 f' * f') \\<in> ideal F''\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "from \\<open>F'' \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  F'' \\<subseteq> F", "have \"\\<dots> \\<subseteq> ideal F\""], ["proof (prove)\nusing this:\n  F'' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. ideal F'' \\<subseteq> ideal F", "by (rule ideal.span_mono)"], ["proof (state)\nthis:\n  ideal F'' \\<subseteq> ideal F\n\ngoal (2 subgoals):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<in> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "finally"], ["proof (chain)\npicking this:\n  f ^ m \\<in> ideal F", "show \"f \\<in> \\<surd>ideal F\""], ["proof (prove)\nusing this:\n  f ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "by (rule radicalI)"], ["proof (state)\nthis:\n  f \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "case False"], ["proof (state)\nthis:\n  1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<notin> F'\n\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "with F'_sub"], ["proof (chain)\npicking this:\n  F' \\<subseteq> insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F\n  1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<notin> F'", "have \"F' \\<subseteq> F\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> insert (1 - punit.monom_mult (1::'a) (monomial 1 x) f) F\n  1 - punit.monom_mult (1::'a) (monomial 1 x) f \\<notin> F'\n\ngoal (1 subgoal):\n 1. F' \\<subseteq> F", "by blast"], ["proof (state)\nthis:\n  F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have \"1 \\<in> ideal F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> ideal F'", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f'\\<in>F'. q f' * f') \\<in> ideal F'", "by (rule ideal.sum_in_spanI)"], ["proof (state)\nthis:\n  1 \\<in> ideal F'\n\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "also"], ["proof (state)\nthis:\n  1 \\<in> ideal F'\n\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "from \\<open>F' \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  F' \\<subseteq> F", "have \"\\<dots> \\<subseteq> ideal F\""], ["proof (prove)\nusing this:\n  F' \\<subseteq> F\n\ngoal (1 subgoal):\n 1. ideal F' \\<subseteq> ideal F", "by (rule ideal.span_mono)"], ["proof (state)\nthis:\n  ideal F' \\<subseteq> ideal F\n\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "finally"], ["proof (chain)\npicking this:\n  1 \\<in> ideal F", "have \"ideal F = UNIV\""], ["proof (prove)\nusing this:\n  1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. ideal F = UNIV", "by (simp only: ideal_eq_UNIV_iff_contains_one)"], ["proof (state)\nthis:\n  ideal F = UNIV\n\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'a) (monomial 1 x) f\n    \\<notin> F' \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "thus ?thesis"], ["proof (prove)\nusing this:\n  ideal F = UNIV\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "by simp"], ["proof (state)\nthis:\n  f \\<in> \\<surd>ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f \\<in> \\<surd>ideal F\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary radical_idealI_extend_indets:\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\"\n    and \"\\<V> (insert (1 - punit.monom_mult 1 (Poly_Mapping.single None 1) (extend_indets f))\n                            (extend_indets ` F)) = {}\"\n  shows \"(f::(_::{countable,linorder} \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 _::alg_closed_field) \\<in> \\<surd>ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "define Y where \"Y = X \\<union> indets f\""], ["proof (state)\nthis:\n  Y = X \\<union> indets f\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "from assms(1)"], ["proof (chain)\npicking this:\n  finite X", "have fin_Y: \"finite Y\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. finite Y", "by (simp add: Y_def finite_indets)"], ["proof (state)\nthis:\n  finite Y\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "have \"P[X] \\<subseteq> P[Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[X] \\<subseteq> P[Y]", "by (rule Polys_mono) (simp add: Y_def)"], ["proof (state)\nthis:\n  P[X] \\<subseteq> P[Y]\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "with assms(2)"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[X]\n  P[X] \\<subseteq> P[Y]", "have F_sub: \"F \\<subseteq> P[Y]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[X]\n  P[X] \\<subseteq> P[Y]\n\ngoal (1 subgoal):\n 1. F \\<subseteq> P[Y]", "by (rule subset_trans)"], ["proof (state)\nthis:\n  F \\<subseteq> P[Y]\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "have f_in: \"f \\<in> P[Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> P[Y]", "by (simp add: Y_def Polys_alt)"], ["proof (state)\nthis:\n  f \\<in> P[Y]\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "let ?F = \"extend_indets ` F\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "let ?f = \"extend_indets f\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "let ?X = \"Some ` Y\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "from fin_Y"], ["proof (chain)\npicking this:\n  finite Y", "have \"finite ?X\""], ["proof (prove)\nusing this:\n  finite Y\n\ngoal (1 subgoal):\n 1. finite (Some ` Y)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite (Some ` Y)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "moreover"], ["proof (state)\nthis:\n  finite (Some ` Y)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "from F_sub"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[Y]", "have \"?F \\<subseteq> P[?X]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[Y]\n\ngoal (1 subgoal):\n 1. extend_indets ` F \\<subseteq> P[Some ` Y]", "by (auto simp: indets_extend_indets intro!: PolysI_alt imageI dest!: PolysD(2) subsetD[of F])"], ["proof (state)\nthis:\n  extend_indets ` F \\<subseteq> P[Some ` Y]\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "moreover"], ["proof (state)\nthis:\n  extend_indets ` F \\<subseteq> P[Some ` Y]\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "from f_in"], ["proof (chain)\npicking this:\n  f \\<in> P[Y]", "have \"?f \\<in> P[?X]\""], ["proof (prove)\nusing this:\n  f \\<in> P[Y]\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> P[Some ` Y]", "by (auto simp: indets_extend_indets intro!: PolysI_alt imageI dest!: PolysD(2))"], ["proof (state)\nthis:\n  extend_indets f \\<in> P[Some ` Y]\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "moreover"], ["proof (state)\nthis:\n  extend_indets f \\<in> P[Some ` Y]\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "have \"None \\<notin> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. None \\<notin> Some ` Y", "by simp"], ["proof (state)\nthis:\n  None \\<notin> Some ` Y\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "ultimately"], ["proof (chain)\npicking this:\n  finite (Some ` Y)\n  extend_indets ` F \\<subseteq> P[Some ` Y]\n  extend_indets f \\<in> P[Some ` Y]\n  None \\<notin> Some ` Y", "have \"?f \\<in> \\<surd>ideal ?F\""], ["proof (prove)\nusing this:\n  finite (Some ` Y)\n  extend_indets ` F \\<subseteq> P[Some ` Y]\n  extend_indets f \\<in> P[Some ` Y]\n  None \\<notin> Some ` Y\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)", "using assms(3)"], ["proof (prove)\nusing this:\n  finite (Some ` Y)\n  extend_indets ` F \\<subseteq> P[Some ` Y]\n  extend_indets f \\<in> P[Some ` Y]\n  None \\<notin> Some ` Y\n  \\<V>\n   (insert\n     (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n     (extend_indets ` F)) =\n  {}\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)", "by (rule radical_idealI)"], ["proof (state)\nthis:\n  extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "also"], ["proof (state)\nthis:\n  extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "have \"?f \\<in> \\<surd>ideal ?F \\<longleftrightarrow> f \\<in> \\<surd>ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)) =\n    (f \\<in> \\<surd>ideal F)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)", "assume \"f \\<in> \\<surd>ideal F\""], ["proof (state)\nthis:\n  f \\<in> \\<surd>ideal F\n\ngoal (2 subgoals):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)", "then"], ["proof (chain)\npicking this:\n  f \\<in> \\<surd>ideal F", "obtain m where \"f ^ m \\<in> ideal F\""], ["proof (prove)\nusing this:\n  f \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        f ^ m \\<in> ideal F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule radicalE)"], ["proof (state)\nthis:\n  f ^ m \\<in> ideal F\n\ngoal (2 subgoals):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)", "hence \"extend_indets (f ^ m) \\<in> extend_indets ` ideal F\""], ["proof (prove)\nusing this:\n  f ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. extend_indets (f ^ m) \\<in> extend_indets ` ideal F", "by (rule imageI)"], ["proof (state)\nthis:\n  extend_indets (f ^ m) \\<in> extend_indets ` ideal F\n\ngoal (2 subgoals):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)", "with extend_indets_ideal_subset"], ["proof (chain)\npicking this:\n  extend_indets ` ideal ?F \\<subseteq> ideal (extend_indets ` ?F)\n  extend_indets (f ^ m) \\<in> extend_indets ` ideal F", "have \"?f ^ m \\<in> ideal ?F\""], ["proof (prove)\nusing this:\n  extend_indets ` ideal ?F \\<subseteq> ideal (extend_indets ` ?F)\n  extend_indets (f ^ m) \\<in> extend_indets ` ideal F\n\ngoal (1 subgoal):\n 1. extend_indets f ^ m \\<in> ideal (extend_indets ` F)", "unfolding extend_indets_power"], ["proof (prove)\nusing this:\n  extend_indets ` ideal ?F \\<subseteq> ideal (extend_indets ` ?F)\n  extend_indets f ^ m \\<in> extend_indets ` ideal F\n\ngoal (1 subgoal):\n 1. extend_indets f ^ m \\<in> ideal (extend_indets ` F)", ".."], ["proof (state)\nthis:\n  extend_indets f ^ m \\<in> ideal (extend_indets ` F)\n\ngoal (2 subgoals):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F\n 2. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)", "thus \"?f \\<in> \\<surd>ideal ?F\""], ["proof (prove)\nusing this:\n  extend_indets f ^ m \\<in> ideal (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)", "by (rule radicalI)"], ["proof (state)\nthis:\n  extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "assume \"?f \\<in> \\<surd>ideal ?F\""], ["proof (state)\nthis:\n  extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "then"], ["proof (chain)\npicking this:\n  extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)", "obtain m where \"?f ^ m \\<in> ideal ?F\""], ["proof (prove)\nusing this:\n  extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        extend_indets f ^ m\n        \\<in> ideal (extend_indets ` F) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule radicalE)"], ["proof (state)\nthis:\n  extend_indets f ^ m \\<in> ideal (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "moreover"], ["proof (state)\nthis:\n  extend_indets f ^ m \\<in> ideal (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have \"?f ^ m \\<in> P[- {None}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend_indets f ^ m \\<in> P[- {None}]", "by (rule Polys_closed_power) (auto intro!: PolysI_alt simp: indets_extend_indets)"], ["proof (state)\nthis:\n  extend_indets f ^ m \\<in> P[- {None}]\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "ultimately"], ["proof (chain)\npicking this:\n  extend_indets f ^ m \\<in> ideal (extend_indets ` F)\n  extend_indets f ^ m \\<in> P[- {None}]", "have \"extend_indets (f ^ m) \\<in> extend_indets ` ideal F\""], ["proof (prove)\nusing this:\n  extend_indets f ^ m \\<in> ideal (extend_indets ` F)\n  extend_indets f ^ m \\<in> P[- {None}]\n\ngoal (1 subgoal):\n 1. extend_indets (f ^ m) \\<in> extend_indets ` ideal F", "by (simp add: extend_indets_ideal extend_indets_power)"], ["proof (state)\nthis:\n  extend_indets (f ^ m) \\<in> extend_indets ` ideal F\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "hence \"f ^ m \\<in> ideal F\""], ["proof (prove)\nusing this:\n  extend_indets (f ^ m) \\<in> extend_indets ` ideal F\n\ngoal (1 subgoal):\n 1. f ^ m \\<in> ideal F", "by (simp only: inj_image_mem_iff[OF inj_extend_indets])"], ["proof (state)\nthis:\n  f ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. extend_indets f \\<in> \\<surd>ideal (extend_indets ` F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "thus \"f \\<in> \\<surd>ideal F\""], ["proof (prove)\nusing this:\n  f ^ m \\<in> ideal F\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "by (rule radicalI)"], ["proof (state)\nthis:\n  f \\<in> \\<surd>ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (extend_indets f \\<in> \\<surd>ideal (extend_indets ` F)) =\n  (f \\<in> \\<surd>ideal F)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "finally"], ["proof (chain)\npicking this:\n  f \\<in> \\<surd>ideal F", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "."], ["proof (state)\nthis:\n  f \\<in> \\<surd>ideal F\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem Nullstellensatz:\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\"\n    and \"(f::(_::{countable,linorder} \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 _::alg_closed_field) \\<in> \\<I> (\\<V> F)\"\n  shows \"f \\<in> \\<surd>ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "proof (rule radical_idealI_extend_indets)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<V>\n     (insert\n       (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n       (extend_indets ` F)) =\n    {}", "let ?f = \"punit.monom_mult 1 (monomial 1 None) (extend_indets f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<V>\n     (insert\n       (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n       (extend_indets ` F)) =\n    {}", "show \"\\<V> (insert (1 - ?f) (extend_indets ` F)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V>\n     (insert\n       (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n       (extend_indets ` F)) =\n    {}", "proof (intro subset_antisym subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F)) \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F))", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F)) \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F))", "assume \"a \\<in> \\<V> (insert (1 - ?f) (extend_indets ` F))\""], ["proof (state)\nthis:\n  a \\<in> \\<V>\n           (insert\n             (1 -\n              punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n             (extend_indets ` F))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F)) \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F))", "moreover"], ["proof (state)\nthis:\n  a \\<in> \\<V>\n           (insert\n             (1 -\n              punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n             (extend_indets ` F))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F)) \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F))", "have \"1 - ?f \\<in> insert (1 - ?f) (extend_indets ` F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f)\n    \\<in> insert\n           (1 -\n            punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n           (extend_indets ` F)", "by simp"], ["proof (state)\nthis:\n  1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f)\n  \\<in> insert\n         (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n         (extend_indets ` F)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F)) \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F))", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> \\<V>\n           (insert\n             (1 -\n              punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n             (extend_indets ` F))\n  1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f)\n  \\<in> insert\n         (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n         (extend_indets ` F)", "have \"poly_eval a (1 - ?f) = 0\""], ["proof (prove)\nusing this:\n  a \\<in> \\<V>\n           (insert\n             (1 -\n              punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n             (extend_indets ` F))\n  1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f)\n  \\<in> insert\n         (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n         (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. poly_eval a\n     (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f)) =\n    (0::'b)", "by (rule variety_ofD)"], ["proof (state)\nthis:\n  poly_eval a\n   (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f)) =\n  (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F)) \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F))", "hence \"poly_eval a (extend_indets f) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly_eval a\n   (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f)) =\n  (0::'b)\n\ngoal (1 subgoal):\n 1. poly_eval a (extend_indets f) \\<noteq> (0::'b)", "by (auto simp: poly_eval_minus poly_eval_times simp flip: times_monomial_left)"], ["proof (state)\nthis:\n  poly_eval a (extend_indets f) \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F)) \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F))", "hence \"poly_eval (a \\<circ> Some) f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly_eval a (extend_indets f) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. poly_eval (a \\<circ> Some) f \\<noteq> (0::'b)", "by (simp add: poly_eval_extend_indets)"], ["proof (state)\nthis:\n  poly_eval (a \\<circ> Some) f \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F)) \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F))", "have \"a \\<circ> Some \\<in> \\<V> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<circ> Some \\<in> \\<V> F", "proof (rule variety_ofI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> F \\<Longrightarrow> poly_eval (a \\<circ> Some) f = (0::'b)", "fix f'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> F \\<Longrightarrow> poly_eval (a \\<circ> Some) f = (0::'b)", "assume \"f' \\<in> F\""], ["proof (state)\nthis:\n  f' \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> F \\<Longrightarrow> poly_eval (a \\<circ> Some) f = (0::'b)", "hence \"extend_indets f' \\<in> insert (1 - ?f) (extend_indets ` F)\""], ["proof (prove)\nusing this:\n  f' \\<in> F\n\ngoal (1 subgoal):\n 1. extend_indets f'\n    \\<in> insert\n           (1 -\n            punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n           (extend_indets ` F)", "by simp"], ["proof (state)\nthis:\n  extend_indets f'\n  \\<in> insert\n         (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n         (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> F \\<Longrightarrow> poly_eval (a \\<circ> Some) f = (0::'b)", "with \\<open>a \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> \\<V>\n           (insert\n             (1 -\n              punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n             (extend_indets ` F))\n  extend_indets f'\n  \\<in> insert\n         (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n         (extend_indets ` F)", "have \"poly_eval a (extend_indets f') = 0\""], ["proof (prove)\nusing this:\n  a \\<in> \\<V>\n           (insert\n             (1 -\n              punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n             (extend_indets ` F))\n  extend_indets f'\n  \\<in> insert\n         (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n         (extend_indets ` F)\n\ngoal (1 subgoal):\n 1. poly_eval a (extend_indets f') = (0::'b)", "by (rule variety_ofD)"], ["proof (state)\nthis:\n  poly_eval a (extend_indets f') = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> F \\<Longrightarrow> poly_eval (a \\<circ> Some) f = (0::'b)", "thus \"poly_eval (a \\<circ> Some) f' = 0\""], ["proof (prove)\nusing this:\n  poly_eval a (extend_indets f') = (0::'b)\n\ngoal (1 subgoal):\n 1. poly_eval (a \\<circ> Some) f' = (0::'b)", "by (simp only: poly_eval_extend_indets)"], ["proof (state)\nthis:\n  poly_eval (a \\<circ> Some) f' = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<circ> Some \\<in> \\<V> F\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F)) \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F))", "with assms(3)"], ["proof (chain)\npicking this:\n  f \\<in> \\<I> (\\<V> F)\n  a \\<circ> Some \\<in> \\<V> F", "have \"poly_eval (a \\<circ> Some) f = 0\""], ["proof (prove)\nusing this:\n  f \\<in> \\<I> (\\<V> F)\n  a \\<circ> Some \\<in> \\<V> F\n\ngoal (1 subgoal):\n 1. poly_eval (a \\<circ> Some) f = (0::'b)", "by (rule ideal_ofD)"], ["proof (state)\nthis:\n  poly_eval (a \\<circ> Some) f = (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F)) \\<Longrightarrow>\n       x \\<in> {}\n 2. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F))", "with \\<open>poly_eval (a \\<circ> Some) f \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  poly_eval (a \\<circ> Some) f \\<noteq> (0::'b)\n  poly_eval (a \\<circ> Some) f = (0::'b)", "show \"a \\<in> {}\""], ["proof (prove)\nusing this:\n  poly_eval (a \\<circ> Some) f \\<noteq> (0::'b)\n  poly_eval (a \\<circ> Some) f = (0::'b)\n\ngoal (1 subgoal):\n 1. a \\<in> {}", ".."], ["proof (state)\nthis:\n  a \\<in> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {} \\<Longrightarrow>\n       x \\<in> \\<V>\n                (insert\n                  (1 -\n                   punit.monom_mult (1::'b) (monomial 1 None)\n                    (extend_indets f))\n                  (extend_indets ` F))", "qed simp"], ["proof (state)\nthis:\n  \\<V>\n   (insert\n     (1 - punit.monom_mult (1::'b) (monomial 1 None) (extend_indets f))\n     (extend_indets ` F)) =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem strong_Nullstellensatz:\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\"\n  shows \"\\<I> (\\<V> F) = \\<surd>ideal (F::((_::{countable,linorder} \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 _::alg_closed_field) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> (\\<V> F) = \\<surd>ideal F", "proof (intro subset_antisym subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> \\<I> (\\<V> F) \\<Longrightarrow> x \\<in> \\<surd>ideal F\n 2. \\<And>x. x \\<in> \\<surd>ideal F \\<Longrightarrow> x \\<in> \\<I> (\\<V> F)", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> \\<I> (\\<V> F) \\<Longrightarrow> x \\<in> \\<surd>ideal F\n 2. \\<And>x. x \\<in> \\<surd>ideal F \\<Longrightarrow> x \\<in> \\<I> (\\<V> F)", "assume \"f \\<in> \\<I> (\\<V> F)\""], ["proof (state)\nthis:\n  f \\<in> \\<I> (\\<V> F)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> \\<I> (\\<V> F) \\<Longrightarrow> x \\<in> \\<surd>ideal F\n 2. \\<And>x. x \\<in> \\<surd>ideal F \\<Longrightarrow> x \\<in> \\<I> (\\<V> F)", "with assms"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]\n  f \\<in> \\<I> (\\<V> F)", "show \"f \\<in> \\<surd>ideal F\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n  f \\<in> \\<I> (\\<V> F)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "by (rule Nullstellensatz)"], ["proof (state)\nthis:\n  f \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<surd>ideal F \\<Longrightarrow> x \\<in> \\<I> (\\<V> F)", "qed (metis ideal_ofI variety_ofD variety_of_radical_ideal)"], ["", "text \\<open>The following lemma can be used for actually \\<^emph>\\<open>deciding\\<close> whether a polynomial is contained in\n  the radical of an ideal or not.\\<close>"], ["", "lemma radical_ideal_iff:\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\" and \"f \\<in> P[X]\" and \"x \\<notin> X\"\n  shows \"(f::(_::{countable,linorder} \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 _::alg_closed_field) \\<in> \\<surd>ideal F \\<longleftrightarrow>\n            1 \\<in> ideal (insert (1 - punit.monom_mult 1 (Poly_Mapping.single x 1) f) F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<in> \\<surd>ideal F) =\n    (1 \\<in> ideal\n              (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f \\<in> \\<surd>ideal F) =\n    (1 \\<in> ideal\n              (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))", "let ?f = \"punit.monom_mult 1 (Poly_Mapping.single x 1) f\""], ["proof (state)\ngoal (1 subgoal):\n 1. (f \\<in> \\<surd>ideal F) =\n    (1 \\<in> ideal\n              (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<in> \\<surd>ideal F) =\n    (1 \\<in> ideal\n              (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n 2. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "assume \"f \\<in> \\<surd>ideal F\""], ["proof (state)\nthis:\n  f \\<in> \\<surd>ideal F\n\ngoal (2 subgoals):\n 1. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n 2. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "then"], ["proof (chain)\npicking this:\n  f \\<in> \\<surd>ideal F", "obtain m where \"f ^ m \\<in> ideal F\""], ["proof (prove)\nusing this:\n  f \\<in> \\<surd>ideal F\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        f ^ m \\<in> ideal F \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule radicalE)"], ["proof (state)\nthis:\n  f ^ m \\<in> ideal F\n\ngoal (2 subgoals):\n 1. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n 2. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "from assms(1)"], ["proof (chain)\npicking this:\n  finite X", "have \"finite (insert x X)\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. finite (insert x X)", "by simp"], ["proof (state)\nthis:\n  finite (insert x X)\n\ngoal (2 subgoals):\n 1. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n 2. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "moreover"], ["proof (state)\nthis:\n  finite (insert x X)\n\ngoal (2 subgoals):\n 1. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n 2. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have \"insert (1 - ?f) F \\<subseteq> P[insert x X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F\n    \\<subseteq> P[insert x X]", "unfolding insert_subset"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'b) (monomial 1 x) f \\<in> P[insert x X] \\<and>\n    F \\<subseteq> P[insert x X]", "proof (intro conjI Polys_closed_minus one_in_Polys Polys_closed_monom_mult PPs_closed_single)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<in> insert x X\n 2. f \\<in> P[insert x X]\n 3. F \\<subseteq> P[insert x X]", "have \"P[X] \\<subseteq> P[insert x X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[X] \\<subseteq> P[insert x X]", "by (rule Polys_mono) blast"], ["proof (state)\nthis:\n  P[X] \\<subseteq> P[insert x X]\n\ngoal (3 subgoals):\n 1. x \\<in> insert x X\n 2. f \\<in> P[insert x X]\n 3. F \\<subseteq> P[insert x X]", "with assms(2, 3)"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[X]\n  f \\<in> P[X]\n  P[X] \\<subseteq> P[insert x X]", "show \"f \\<in> P[insert x X]\" and \"F \\<subseteq> P[insert x X]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[X]\n  f \\<in> P[X]\n  P[X] \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. f \\<in> P[insert x X] &&& F \\<subseteq> P[insert x X]", "by blast+"], ["proof (state)\nthis:\n  f \\<in> P[insert x X]\n  F \\<subseteq> P[insert x X]\n\ngoal (1 subgoal):\n 1. x \\<in> insert x X", "qed simp"], ["proof (state)\nthis:\n  insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F\n  \\<subseteq> P[insert x X]\n\ngoal (2 subgoals):\n 1. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n 2. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "moreover"], ["proof (state)\nthis:\n  insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F\n  \\<subseteq> P[insert x X]\n\ngoal (2 subgoals):\n 1. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n 2. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have \"\\<V> (insert (1 - ?f) F) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F) = {}", "proof (intro subset_antisym subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "assume \"a \\<in> \\<V> (insert (1 - ?f) F)\""], ["proof (state)\nthis:\n  a \\<in> \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "moreover"], ["proof (state)\nthis:\n  a \\<in> \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "have \"1 - ?f \\<in> insert (1 - ?f) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - punit.monom_mult (1::'b) (monomial 1 x) f\n    \\<in> insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F", "by simp"], ["proof (state)\nthis:\n  1 - punit.monom_mult (1::'b) (monomial 1 x) f\n  \\<in> insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n  1 - punit.monom_mult (1::'b) (monomial 1 x) f\n  \\<in> insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F", "have \"poly_eval a (1 - ?f) = 0\""], ["proof (prove)\nusing this:\n  a \\<in> \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n  1 - punit.monom_mult (1::'b) (monomial 1 x) f\n  \\<in> insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F\n\ngoal (1 subgoal):\n 1. poly_eval a (1 - punit.monom_mult (1::'b) (monomial 1 x) f) = (0::'b)", "by (rule variety_ofD)"], ["proof (state)\nthis:\n  poly_eval a (1 - punit.monom_mult (1::'b) (monomial 1 x) f) = (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "hence \"poly_eval a (f ^ m) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly_eval a (1 - punit.monom_mult (1::'b) (monomial 1 x) f) = (0::'b)\n\ngoal (1 subgoal):\n 1. poly_eval a (f ^ m) \\<noteq> (0::'b)", "by (auto simp: poly_eval_minus poly_eval_times poly_eval_power simp flip: times_monomial_left)"], ["proof (state)\nthis:\n  poly_eval a (f ^ m) \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "from \\<open>a \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "have \"a \\<in> \\<V> (ideal (insert (1 - ?f) F))\""], ["proof (prove)\nusing this:\n  a \\<in> \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V>\n             (ideal\n               (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))", "by (simp only: variety_of_ideal)"], ["proof (state)\nthis:\n  a \\<in> \\<V>\n           (ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "moreover"], ["proof (state)\nthis:\n  a \\<in> \\<V>\n           (ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "from \\<open>f ^ m \\<in> ideal F\\<close> ideal.span_mono"], ["proof (chain)\npicking this:\n  f ^ m \\<in> ideal F\n  ?A \\<subseteq> ?B \\<Longrightarrow> ideal ?A \\<subseteq> ideal ?B", "have \"f ^ m \\<in> ideal (insert (1 - ?f) F)\""], ["proof (prove)\nusing this:\n  f ^ m \\<in> ideal F\n  ?A \\<subseteq> ?B \\<Longrightarrow> ideal ?A \\<subseteq> ideal ?B\n\ngoal (1 subgoal):\n 1. f ^ m\n    \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "by (rule rev_subsetD) blast"], ["proof (state)\nthis:\n  f ^ m\n  \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> \\<V>\n           (ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))\n  f ^ m\n  \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "have \"poly_eval a (f ^ m) = 0\""], ["proof (prove)\nusing this:\n  a \\<in> \\<V>\n           (ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))\n  f ^ m\n  \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n\ngoal (1 subgoal):\n 1. poly_eval a (f ^ m) = (0::'b)", "by (rule variety_ofD)"], ["proof (state)\nthis:\n  poly_eval a (f ^ m) = (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "with \\<open>poly_eval a (f ^ m) \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  poly_eval a (f ^ m) \\<noteq> (0::'b)\n  poly_eval a (f ^ m) = (0::'b)", "show \"a \\<in> {}\""], ["proof (prove)\nusing this:\n  poly_eval a (f ^ m) \\<noteq> (0::'b)\n  poly_eval a (f ^ m) = (0::'b)\n\ngoal (1 subgoal):\n 1. a \\<in> {}", ".."], ["proof (state)\nthis:\n  a \\<in> {}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "qed simp"], ["proof (state)\nthis:\n  \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F) = {}\n\ngoal (2 subgoals):\n 1. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n 2. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "ultimately"], ["proof (chain)\npicking this:\n  finite (insert x X)\n  insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F\n  \\<subseteq> P[insert x X]\n  \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F) = {}", "have \"ideal (insert (1 - ?f) F) = UNIV\""], ["proof (prove)\nusing this:\n  finite (insert x X)\n  insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F\n  \\<subseteq> P[insert x X]\n  \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F) = {}\n\ngoal (1 subgoal):\n 1. ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F) = UNIV", "by (rule weak_Nullstellensatz)"], ["proof (state)\nthis:\n  ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F) = UNIV\n\ngoal (2 subgoals):\n 1. f \\<in> \\<surd>ideal F \\<Longrightarrow>\n    1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n 2. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "thus \"1 \\<in> ideal (insert (1 - ?f) F)\""], ["proof (prove)\nusing this:\n  ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F) = UNIV\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "by simp"], ["proof (state)\nthis:\n  1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "assume \"1 \\<in> ideal (insert (1 - ?f) F)\""], ["proof (state)\nthis:\n  1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "have \"\\<V> (insert (1 - ?f) F) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F) = {}", "proof (intro subset_antisym subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "assume \"a \\<in> \\<V> (insert (1 - ?f) F)\""], ["proof (state)\nthis:\n  a \\<in> \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "hence \"a \\<in> \\<V> (ideal (insert (1 - ?f) F))\""], ["proof (prove)\nusing this:\n  a \\<in> \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n\ngoal (1 subgoal):\n 1. a \\<in> \\<V>\n             (ideal\n               (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))", "by (simp only: variety_of_ideal)"], ["proof (state)\nthis:\n  a \\<in> \\<V>\n           (ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "hence \"poly_eval a 1 = 0\""], ["proof (prove)\nusing this:\n  a \\<in> \\<V>\n           (ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))\n\ngoal (1 subgoal):\n 1. poly_eval a 1 = (0::'b)", "using \\<open>1 \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> \\<V>\n           (ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))\n  1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)\n\ngoal (1 subgoal):\n 1. poly_eval a 1 = (0::'b)", "by (rule variety_ofD)"], ["proof (state)\nthis:\n  poly_eval a 1 = (0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n                   F) \\<Longrightarrow>\n       xa \\<in> {}\n 2. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "thus \"a \\<in> {}\""], ["proof (prove)\nusing this:\n  poly_eval a 1 = (0::'b)\n\ngoal (1 subgoal):\n 1. a \\<in> {}", "by simp"], ["proof (state)\nthis:\n  a \\<in> {}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {} \\<Longrightarrow>\n       xa \\<in> \\<V>\n                 (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F)", "qed simp"], ["proof (state)\nthis:\n  \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F) = {}\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal\n             (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f)\n               F) \\<Longrightarrow>\n    f \\<in> \\<surd>ideal F", "with assms"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]\n  f \\<in> P[X]\n  x \\<notin> X\n  \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F) = {}", "show \"f \\<in> \\<surd>ideal F\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n  f \\<in> P[X]\n  x \\<notin> X\n  \\<V> (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F) = {}\n\ngoal (1 subgoal):\n 1. f \\<in> \\<surd>ideal F", "by (rule radical_idealI)"], ["proof (state)\nthis:\n  f \\<in> \\<surd>ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f \\<in> \\<surd>ideal F) =\n  (1 \\<in> ideal (insert (1 - punit.monom_mult (1::'b) (monomial 1 x) f) F))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* theory *)"]]}