{"file_name": "/home/qj213/afp-2021-10-22/thys/Nullstellensatz/Univariate_PM.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nullstellensatz", "problem_names": ["lemma pm_of_poly_aux:\n  \"{t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> 0} =\n          Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> 0}\" (is \"?M = _\")", "lemma lookup_pm_of_poly_single [simp]:\n  \"lookup (pm_of_poly x p) (Poly_Mapping.single x d) = poly.coeff p d\"", "lemma keys_pm_of_poly: \"keys (pm_of_poly x p) = Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> 0}\"", "lemma coeff_poly_of_pm [simp]: \"poly.coeff (poly_of_pm x p) k = lookup p (Poly_Mapping.single x k)\"", "lemma pm_of_poly_of_pm:\n  assumes \"p \\<in> P[{x}]\"\n  shows \"pm_of_poly x (poly_of_pm x p) = p\"", "lemma poly_of_pm_of_poly [simp]: \"poly_of_pm x (pm_of_poly x p) = p\"", "lemma pm_of_poly_in_Polys: \"pm_of_poly x p \\<in> P[{x}]\"", "lemma pm_of_poly_zero [simp]: \"pm_of_poly x 0 = 0\"", "lemma pm_of_poly_eq_zero_iff [iff]: \"pm_of_poly x p = 0 \\<longleftrightarrow> p = 0\"", "lemma pm_of_poly_monom: \"pm_of_poly x (Polynomial.monom c d) = monomial c (Poly_Mapping.single x d)\"", "lemma pm_of_poly_plus: \"pm_of_poly x (p + q) = pm_of_poly x p + pm_of_poly x q\"", "lemma pm_of_poly_uminus [simp]: \"pm_of_poly x (- p) = - pm_of_poly x p\"", "lemma pm_of_poly_minus: \"pm_of_poly x (p - q) = pm_of_poly x p - pm_of_poly x q\"", "lemma pm_of_poly_one [simp]: \"pm_of_poly x 1 = 1\"", "lemma pm_of_poly_pCons:\n  \"pm_of_poly x (pCons c p) =\n      monomial c 0 + punit.monom_mult (1::_::monoid_mult) (Poly_Mapping.single x 1) (pm_of_poly x p)\"\n    (is \"?l = ?r\")", "lemma pm_of_poly_smult [simp]: \"pm_of_poly x (Polynomial.smult c p) = c \\<cdot> pm_of_poly x p\"", "lemma pm_of_poly_times: \"pm_of_poly x (p * q) = pm_of_poly x p * pm_of_poly x (q::_::ring_1 poly)\"", "lemma pm_of_poly_sum: \"pm_of_poly x (sum f I) = (\\<Sum>i\\<in>I. pm_of_poly x (f i))\"", "lemma pm_of_poly_prod: \"pm_of_poly x (prod f I) = (\\<Prod>i\\<in>I. pm_of_poly x (f i :: _::ring_1 poly))\"", "lemma pm_of_poly_power [simp]: \"pm_of_poly x (p ^ m) = pm_of_poly x (p::_::ring_1 poly) ^ m\"", "lemma poly_of_pm_zero [simp]: \"poly_of_pm x 0 = 0\"", "lemma poly_of_pm_eq_zero_iff: \"poly_of_pm x p = 0 \\<longleftrightarrow> keys p \\<inter> .[{x}] = {}\"", "lemma poly_of_pm_monomial:\n  \"poly_of_pm x (monomial c t) = (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])\"", "lemma poly_of_pm_plus: \"poly_of_pm x (p + q) = poly_of_pm x p + poly_of_pm x q\"", "lemma poly_of_pm_uminus [simp]: \"poly_of_pm x (- p) = - poly_of_pm x p\"", "lemma poly_of_pm_minus: \"poly_of_pm x (p - q) = poly_of_pm x p - poly_of_pm x q\"", "lemma poly_of_pm_one [simp]: \"poly_of_pm x 1 = 1\"", "lemma poly_of_pm_times:\n  \"poly_of_pm x (p * q) = poly_of_pm x p * poly_of_pm x (q::_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1)\"", "lemma poly_of_pm_sum: \"poly_of_pm x (sum f I) = (\\<Sum>i\\<in>I. poly_of_pm x (f i))\"", "lemma poly_of_pm_prod: \"poly_of_pm x (prod f I) = (\\<Prod>i\\<in>I. poly_of_pm x (f i))\"", "lemma poly_of_pm_power [simp]: \"poly_of_pm x (p ^ m) = poly_of_pm x p ^ m\"", "lemma poly_eq_poly_eval: \"poly (poly_of_pm x p) a = poly_eval (\\<lambda>y. a when y = x) p\"", "lemma poly_eval_eq_poly: \"poly_eval a (pm_of_poly x p) = poly p (a x)\"", "lemma flat_pm_of_poly_in_Polys:\n  assumes \"range (poly.coeff p) \\<subseteq> P[Y]\"\n  shows \"flat_pm_of_poly x p \\<in> P[insert x Y]\"", "lemma\n  shows flat_pm_of_poly_zero [simp]: \"flat_pm_of_poly x 0 = 0\"\n    and flat_pm_of_poly_monom: \"flat_pm_of_poly x (Polynomial.monom c d) =\n                                    punit.monom_mult 1 (Poly_Mapping.single x d) c\"\n    and flat_pm_of_poly_plus: \"flat_pm_of_poly x (p + q) =\n                                  flat_pm_of_poly x p + flat_pm_of_poly x q\"\n    and flat_pm_of_poly_one [simp]: \"flat_pm_of_poly x 1 = 1\"\n    and flat_pm_of_poly_sum: \"flat_pm_of_poly x (sum f I) = (\\<Sum>i\\<in>I. flat_pm_of_poly x (f i))\"", "lemma\n  shows flat_pm_of_poly_uminus [simp]: \"flat_pm_of_poly x (- p) = - flat_pm_of_poly x p\"\n    and flat_pm_of_poly_minus: \"flat_pm_of_poly x (p - q) =\n                                  flat_pm_of_poly x p - flat_pm_of_poly x (q::_::ring poly)\"", "lemma flat_pm_of_poly_pCons:\n  \"flat_pm_of_poly x (pCons c p) =\n    c + punit.monom_mult 1 (Poly_Mapping.single x 1) (flat_pm_of_poly x (p::_::comm_semiring_1 poly))\"", "lemma flat_pm_of_poly_smult [simp]:\n  \"flat_pm_of_poly x (Polynomial.smult c p) = c * flat_pm_of_poly x (p::_::comm_semiring_1 poly)\"", "lemma\n  shows flat_pm_of_poly_times: \"flat_pm_of_poly x (p * q) = flat_pm_of_poly x p * flat_pm_of_poly x q\"\n    and flat_pm_of_poly_prod: \"flat_pm_of_poly x (prod f I) =\n                                  (\\<Prod>i\\<in>I. flat_pm_of_poly x (f i :: _::comm_ring_1 poly))\"\n    and flat_pm_of_poly_power: \"flat_pm_of_poly x (p ^ m) = flat_pm_of_poly x (p::_::comm_ring_1 poly) ^ m\"", "lemma coeff_poly_of_focus_subset_Polys:\n  assumes \"p \\<in> P[X]\"\n  shows \"range (poly.coeff (poly_of_focus x p)) \\<subseteq> P[X - {x}]\"", "lemma\n  shows poly_of_focus_zero [simp]: \"poly_of_focus x 0 = 0\"\n    and poly_of_focus_uminus [simp]: \"poly_of_focus x (- p) = - poly_of_focus x p\"\n    and poly_of_focus_plus: \"poly_of_focus x (p + q) = poly_of_focus x p + poly_of_focus x q\"\n    and poly_of_focus_minus: \"poly_of_focus x (p - q) = poly_of_focus x p - poly_of_focus x q\"\n    and poly_of_focus_one [simp]: \"poly_of_focus x 1 = 1\"\n    and poly_of_focus_sum: \"poly_of_focus x (sum f I) = (\\<Sum>i\\<in>I. poly_of_focus x (f i))\"", "lemma poly_of_focus_eq_zero_iff [iff]: \"poly_of_focus x p = 0 \\<longleftrightarrow> p = 0\"", "lemma poly_of_focus_monomial:\n  \"poly_of_focus x (monomial c t) = Polynomial.monom (monomial c (except t {x})) (lookup t x)\"", "lemma\n  shows poly_of_focus_times: \"poly_of_focus x (p * q) = poly_of_focus x p * poly_of_focus x q\"\n    and poly_of_focus_prod: \"poly_of_focus x (prod f I) =\n                                  (\\<Prod>i\\<in>I. poly_of_focus x (f i :: _ \\<Rightarrow>\\<^sub>0 _::comm_semiring_1))\"\n    and poly_of_focus_power: \"poly_of_focus x (p ^ m) = poly_of_focus x (p::_ \\<Rightarrow>\\<^sub>0 _::comm_semiring_1) ^ m\"", "lemma flat_pm_of_poly_of_focus [simp]: \"flat_pm_of_poly x (poly_of_focus x p) = p\"", "lemma poly_of_focus_flat_pm_of_poly:\n  assumes \"range (poly.coeff p) \\<subseteq> P[- {x}]\"\n  shows \"poly_of_focus x (flat_pm_of_poly x p) = p\"", "lemma flat_pm_of_poly_eq_zeroD:\n  assumes \"flat_pm_of_poly x p = 0\" and \"range (poly.coeff p) \\<subseteq> P[- {x}]\"\n  shows \"p = 0\"", "lemma poly_poly_of_focus: \"poly (poly_of_focus x p) a = poly_eval (\\<lambda>_. a) (focus {x} p)\""], "translations": [["", "lemma pm_of_poly_aux:\n  \"{t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> 0} =\n          Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> 0}\" (is \"?M = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> (0::'b)} =\n    Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}", "proof (intro subset_antisym subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n                    (0::'b)} \\<Longrightarrow>\n       xa \\<in> Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}\n 2. \\<And>xa.\n       xa \\<in> Poly_Mapping.single x `\n                {d. poly.coeff p d \\<noteq> (0::'b)} \\<Longrightarrow>\n       xa \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n                    (0::'b)}", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n                    (0::'b)} \\<Longrightarrow>\n       xa \\<in> Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}\n 2. \\<And>xa.\n       xa \\<in> Poly_Mapping.single x `\n                {d. poly.coeff p d \\<noteq> (0::'b)} \\<Longrightarrow>\n       xa \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n                    (0::'b)}", "assume \"t \\<in> ?M\""], ["proof (state)\nthis:\n  t \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n              (0::'b)}\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n                    (0::'b)} \\<Longrightarrow>\n       xa \\<in> Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}\n 2. \\<And>xa.\n       xa \\<in> Poly_Mapping.single x `\n                {d. poly.coeff p d \\<noteq> (0::'b)} \\<Longrightarrow>\n       xa \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n                    (0::'b)}", "hence \"\\<And>y. y \\<noteq> x \\<Longrightarrow> Poly_Mapping.lookup t y = 0\""], ["proof (prove)\nusing this:\n  t \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n              (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<noteq> x \\<Longrightarrow> lookup t y = 0", "by (fastforce simp: PPs_def in_keys_iff)"], ["proof (state)\nthis:\n  ?y \\<noteq> x \\<Longrightarrow> lookup t ?y = 0\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n                    (0::'b)} \\<Longrightarrow>\n       xa \\<in> Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}\n 2. \\<And>xa.\n       xa \\<in> Poly_Mapping.single x `\n                {d. poly.coeff p d \\<noteq> (0::'b)} \\<Longrightarrow>\n       xa \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n                    (0::'b)}", "hence \"t = Poly_Mapping.single x (lookup t x)\""], ["proof (prove)\nusing this:\n  ?y \\<noteq> x \\<Longrightarrow> lookup t ?y = 0\n\ngoal (1 subgoal):\n 1. t = monomial (lookup t x) x", "using poly_mapping_eqI"], ["proof (prove)\nusing this:\n  ?y \\<noteq> x \\<Longrightarrow> lookup t ?y = 0\n  (\\<And>k. lookup ?f k = lookup ?g k) \\<Longrightarrow> ?f = ?g\n\ngoal (1 subgoal):\n 1. t = monomial (lookup t x) x", "by (metis (full_types) lookup_single_eq lookup_single_not_eq)"], ["proof (state)\nthis:\n  t = monomial (lookup t x) x\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n                    (0::'b)} \\<Longrightarrow>\n       xa \\<in> Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}\n 2. \\<And>xa.\n       xa \\<in> Poly_Mapping.single x `\n                {d. poly.coeff p d \\<noteq> (0::'b)} \\<Longrightarrow>\n       xa \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n                    (0::'b)}", "then"], ["proof (chain)\npicking this:\n  t = monomial (lookup t x) x", "show \"t \\<in> (Poly_Mapping.single x) ` {d. poly.coeff p d \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  t = monomial (lookup t x) x\n\ngoal (1 subgoal):\n 1. t \\<in> Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}", "using \\<open>t \\<in> ?M\\<close>"], ["proof (prove)\nusing this:\n  t = monomial (lookup t x) x\n  t \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n              (0::'b)}\n\ngoal (1 subgoal):\n 1. t \\<in> Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}", "by auto"], ["proof (state)\nthis:\n  t \\<in> Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Poly_Mapping.single x `\n                {d. poly.coeff p d \\<noteq> (0::'b)} \\<Longrightarrow>\n       xa \\<in> {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq>\n                    (0::'b)}", "qed (auto split: if_splits simp: PPs_def)"], ["", "lift_definition pm_of_poly :: \"'x \\<Rightarrow> 'a poly \\<Rightarrow> ('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_monoid_add\"\n  is \"\\<lambda>x p t. (poly.coeff p (lookup t x)) when t \\<in> .[{x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x poly.\n       finite\n        {xa.\n         (poly.coeff poly (lookup xa x) when xa \\<in> .[{x}]) \\<noteq>\n         (0::'a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x poly.\n       finite\n        {xa.\n         (poly.coeff poly (lookup xa x) when xa \\<in> .[{x}]) \\<noteq>\n         (0::'a)}", "fix x::'x and p::\"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x poly.\n       finite\n        {xa.\n         (poly.coeff poly (lookup xa x) when xa \\<in> .[{x}]) \\<noteq>\n         (0::'a)}", "show \"finite {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> (0::'a)}", "unfolding pm_of_poly_aux"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'a)})", "using finite_surj[OF MOST_coeff_eq_0[unfolded eventually_cofinite]]"], ["proof (prove)\nusing this:\n  ?B \\<subseteq> ?f `\n                 {x. poly.coeff ?p1 x \\<noteq> (0::?'a1)} \\<Longrightarrow>\n  finite ?B\n\ngoal (1 subgoal):\n 1. finite (Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'a)})", "by blast"], ["proof (state)\nthis:\n  finite\n   {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition poly_of_pm :: \"'x \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> 'a::comm_monoid_add poly\"\n  where \"poly_of_pm x p = Abs_poly (\\<lambda>d. lookup p (Poly_Mapping.single x d))\""], ["", "lemma lookup_pm_of_poly_single [simp]:\n  \"lookup (pm_of_poly x p) (Poly_Mapping.single x d) = poly.coeff p d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (pm_of_poly x p) (monomial d x) = poly.coeff p d", "by (simp add: pm_of_poly.rep_eq PPs_closed_single)"], ["", "lemma keys_pm_of_poly: \"keys (pm_of_poly x p) = Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (pm_of_poly x p) =\n    Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. keys (pm_of_poly x p) =\n    Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}", "have \"keys (pm_of_poly x p) = {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (pm_of_poly x p) =\n    {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> (0::'b)}", "by (rule set_eqI) (simp add: pm_of_poly.rep_eq flip: lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  keys (pm_of_poly x p) =\n  {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. keys (pm_of_poly x p) =\n    Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}", "also"], ["proof (state)\nthis:\n  keys (pm_of_poly x p) =\n  {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. keys (pm_of_poly x p) =\n    Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}", "have \"\\<dots> = Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> (0::'b)} =\n    Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}", "by (fact pm_of_poly_aux)"], ["proof (state)\nthis:\n  {t. (poly.coeff p (lookup t x) when t \\<in> .[{x}]) \\<noteq> (0::'b)} =\n  Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. keys (pm_of_poly x p) =\n    Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}", "finally"], ["proof (chain)\npicking this:\n  keys (pm_of_poly x p) =\n  Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (pm_of_poly x p) =\n  Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. keys (pm_of_poly x p) =\n    Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}", "."], ["proof (state)\nthis:\n  keys (pm_of_poly x p) =\n  Poly_Mapping.single x ` {d. poly.coeff p d \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_poly_of_pm [simp]: \"poly.coeff (poly_of_pm x p) k = lookup p (Poly_Mapping.single x k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (poly_of_pm x p) k = lookup p (monomial k x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly.coeff (poly_of_pm x p) k = lookup p (monomial k x)", "have 0:\"Poly_Mapping.single x ` {d. lookup p (Poly_Mapping.single x d) \\<noteq> 0} \\<subseteq> {d. lookup p d \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.single x ` {d. lookup p (monomial d x) \\<noteq> (0::'a)}\n    \\<subseteq> {d. lookup p d \\<noteq> (0::'a)}", "by auto"], ["proof (state)\nthis:\n  Poly_Mapping.single x ` {d. lookup p (monomial d x) \\<noteq> (0::'a)}\n  \\<subseteq> {d. lookup p d \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. poly.coeff (poly_of_pm x p) k = lookup p (monomial k x)", "have \"\\<forall>\\<^sub>\\<infinity> k. lookup p (Poly_Mapping.single x k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>\\<infinity>k. lookup p (monomial k x) = (0::'a)", "unfolding coeff_def eventually_cofinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {xa. lookup p (monomial xa x) \\<noteq> (0::'a)}", "using finite_imageD[OF finite_subset[OF 0 Poly_Mapping.finite_lookup]] inj_single"], ["proof (prove)\nusing this:\n  inj_on (Poly_Mapping.single x)\n   {d. lookup p (monomial d x) \\<noteq> (0::'a)} \\<Longrightarrow>\n  finite {d. lookup p (monomial d x) \\<noteq> (0::'a)}\n  inj (Poly_Mapping.single ?k)\n\ngoal (1 subgoal):\n 1. finite {xa. lookup p (monomial xa x) \\<noteq> (0::'a)}", "by (metis inj_eq inj_onI)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>\\<infinity>k. lookup p (monomial k x) = (0::'a)\n\ngoal (1 subgoal):\n 1. poly.coeff (poly_of_pm x p) k = lookup p (monomial k x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>\\<infinity>k. lookup p (monomial k x) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>\\<infinity>k. lookup p (monomial k x) = (0::'a)\n\ngoal (1 subgoal):\n 1. poly.coeff (poly_of_pm x p) k = lookup p (monomial k x)", "by (simp add: poly_of_pm_def Abs_poly_inverse)"], ["proof (state)\nthis:\n  poly.coeff (poly_of_pm x p) k = lookup p (monomial k x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pm_of_poly_of_pm:\n  assumes \"p \\<in> P[{x}]\"\n  shows \"pm_of_poly x (poly_of_pm x p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (poly_of_pm x p) = p", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (pm_of_poly x (poly_of_pm x p)) k = lookup p k", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (pm_of_poly x (poly_of_pm x p)) k = lookup p k", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[{x}]", "have \"keys p \\<subseteq> .[{x}]\""], ["proof (prove)\nusing this:\n  p \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. keys p \\<subseteq> .[{x}]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys p \\<subseteq> .[{x}]\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup (pm_of_poly x (poly_of_pm x p)) k = lookup p k", "show \"lookup (pm_of_poly x (poly_of_pm x p)) t = lookup p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (pm_of_poly x (poly_of_pm x p)) t = lookup p t", "proof (simp add: pm_of_poly.rep_eq when_def, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    lookup p (monomial (lookup t x) x) = lookup p t\n 2. t \\<notin> .[{x}] \\<Longrightarrow> lookup p t = (0::'b)", "assume \"t \\<in> .[{x}]\""], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    lookup p (monomial (lookup t x) x) = lookup p t\n 2. t \\<notin> .[{x}] \\<Longrightarrow> lookup p t = (0::'b)", "hence \"Poly_Mapping.single x (lookup t x) = t\""], ["proof (prove)\nusing this:\n  t \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. monomial (lookup t x) x = t", "by (simp add: PPsD keys_subset_singleton_imp_monomial)"], ["proof (state)\nthis:\n  monomial (lookup t x) x = t\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    lookup p (monomial (lookup t x) x) = lookup p t\n 2. t \\<notin> .[{x}] \\<Longrightarrow> lookup p t = (0::'b)", "thus \"lookup p (Poly_Mapping.single x (lookup t x)) = lookup p t\""], ["proof (prove)\nusing this:\n  monomial (lookup t x) x = t\n\ngoal (1 subgoal):\n 1. lookup p (monomial (lookup t x) x) = lookup p t", "by simp"], ["proof (state)\nthis:\n  lookup p (monomial (lookup t x) x) = lookup p t\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow> lookup p t = (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow> lookup p t = (0::'b)", "assume \"t \\<notin> .[{x}]\""], ["proof (state)\nthis:\n  t \\<notin> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow> lookup p t = (0::'b)", "with assms PolysD"], ["proof (chain)\npicking this:\n  p \\<in> P[{x}]\n  ?p \\<in> P[?X] \\<Longrightarrow> keys ?p \\<subseteq> .[?X]\n  ?p \\<in> P[?X] \\<Longrightarrow> indets ?p \\<subseteq> ?X\n  t \\<notin> .[{x}]", "have \"t \\<notin> keys p\""], ["proof (prove)\nusing this:\n  p \\<in> P[{x}]\n  ?p \\<in> P[?X] \\<Longrightarrow> keys ?p \\<subseteq> .[?X]\n  ?p \\<in> P[?X] \\<Longrightarrow> indets ?p \\<subseteq> ?X\n  t \\<notin> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<notin> keys p", "by blast"], ["proof (state)\nthis:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow> lookup p t = (0::'b)", "thus \"lookup p t = 0\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. lookup p t = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup p t = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (pm_of_poly x (poly_of_pm x p)) t = lookup p t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_of_pm_of_poly [simp]: \"poly_of_pm x (pm_of_poly x p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (pm_of_poly x p) = p", "by (simp add: poly_of_pm_def coeff_inverse)"], ["", "lemma pm_of_poly_in_Polys: \"pm_of_poly x p \\<in> P[{x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x p \\<in> P[{x}]", "by (auto simp: keys_pm_of_poly PPs_closed_single intro!: PolysI)"], ["", "lemma pm_of_poly_zero [simp]: \"pm_of_poly x 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x 0 = 0", "by (rule poly_mapping_eqI) (simp add: pm_of_poly.rep_eq)"], ["", "lemma pm_of_poly_eq_zero_iff [iff]: \"pm_of_poly x p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pm_of_poly x p = 0) = (p = 0)", "by (metis poly_of_pm_of_poly pm_of_poly_zero)"], ["", "lemma pm_of_poly_monom: \"pm_of_poly x (Polynomial.monom c d) = monomial c (Poly_Mapping.single x d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (Polynomial.monom c d) = monomial c (monomial d x)", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_poly x (Polynomial.monom c d)) k =\n       lookup (monomial c (monomial d x)) k", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_poly x (Polynomial.monom c d)) k =\n       lookup (monomial c (monomial d x)) k", "show \"lookup (pm_of_poly x (Polynomial.monom c d)) t = lookup (monomial c (monomial d x)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (pm_of_poly x (Polynomial.monom c d)) t =\n    lookup (monomial c (monomial d x)) t", "proof (cases \"t \\<in> .[{x}]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    lookup (pm_of_poly x (Polynomial.monom c d)) t =\n    lookup (monomial c (monomial d x)) t\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    lookup (pm_of_poly x (Polynomial.monom c d)) t =\n    lookup (monomial c (monomial d x)) t", "case True"], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    lookup (pm_of_poly x (Polynomial.monom c d)) t =\n    lookup (monomial c (monomial d x)) t\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    lookup (pm_of_poly x (Polynomial.monom c d)) t =\n    lookup (monomial c (monomial d x)) t", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. lookup (pm_of_poly x (Polynomial.monom c d)) t =\n    lookup (monomial c (monomial d x)) t", "by (auto simp: pm_of_poly.rep_eq lookup_single PPs_singleton when_def dest: monomial_inj)"], ["proof (state)\nthis:\n  lookup (pm_of_poly x (Polynomial.monom c d)) t =\n  lookup (monomial c (monomial d x)) t\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    lookup (pm_of_poly x (Polynomial.monom c d)) t =\n    lookup (monomial c (monomial d x)) t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    lookup (pm_of_poly x (Polynomial.monom c d)) t =\n    lookup (monomial c (monomial d x)) t", "case False"], ["proof (state)\nthis:\n  t \\<notin> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    lookup (pm_of_poly x (Polynomial.monom c d)) t =\n    lookup (monomial c (monomial d x)) t", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<notin> .[{x}]\n\ngoal (1 subgoal):\n 1. lookup (pm_of_poly x (Polynomial.monom c d)) t =\n    lookup (monomial c (monomial d x)) t", "by (auto simp add: pm_of_poly.rep_eq lookup_single PPs_singleton)"], ["proof (state)\nthis:\n  lookup (pm_of_poly x (Polynomial.monom c d)) t =\n  lookup (monomial c (monomial d x)) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (pm_of_poly x (Polynomial.monom c d)) t =\n  lookup (monomial c (monomial d x)) t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pm_of_poly_plus: \"pm_of_poly x (p + q) = pm_of_poly x p + pm_of_poly x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (p + q) = pm_of_poly x p + pm_of_poly x q", "by (rule poly_mapping_eqI) (simp add: pm_of_poly.rep_eq lookup_add when_add_distrib)"], ["", "lemma pm_of_poly_uminus [simp]: \"pm_of_poly x (- p) = - pm_of_poly x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (- p) = - pm_of_poly x p", "by (rule poly_mapping_eqI) (simp add: pm_of_poly.rep_eq when_distrib)"], ["", "lemma pm_of_poly_minus: \"pm_of_poly x (p - q) = pm_of_poly x p - pm_of_poly x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (p - q) = pm_of_poly x p - pm_of_poly x q", "by (rule poly_mapping_eqI) (simp add: pm_of_poly.rep_eq lookup_minus when_diff_distrib)"], ["", "lemma pm_of_poly_one [simp]: \"pm_of_poly x 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x 1 = 1", "by (simp add: pm_of_poly_monom flip: single_one monom_eq_1)"], ["", "lemma pm_of_poly_pCons:\n  \"pm_of_poly x (pCons c p) =\n      monomial c 0 + punit.monom_mult (1::_::monoid_mult) (Poly_Mapping.single x 1) (pm_of_poly x p)\"\n    (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (pCons c p) =\n    monomial c 0 + punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p)", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_poly x (pCons c p)) k =\n       lookup\n        (monomial c 0 +\n         punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n        k", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_poly x (pCons c p)) k =\n       lookup\n        (monomial c 0 +\n         punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n        k", "let ?x = \"Poly_Mapping.single x (Suc 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_poly x (pCons c p)) k =\n       lookup\n        (monomial c 0 +\n         punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n        k", "show \"lookup ?l t = lookup ?r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "proof (cases \"?x adds t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t\n 2. \\<not> monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "case True"], ["proof (state)\nthis:\n  monomial (Suc 0) x adds t\n\ngoal (2 subgoals):\n 1. monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t\n 2. \\<not> monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "have 1: \"t - ?x \\<in> .[{x}] \\<longleftrightarrow> t \\<in> .[{x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t - monomial (Suc 0) x \\<in> .[{x}]) = (t \\<in> .[{x}])", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t - monomial (Suc 0) x \\<in> .[{x}] \\<Longrightarrow> t \\<in> .[{x}]\n 2. t \\<in> .[{x}] \\<Longrightarrow> t - monomial (Suc 0) x \\<in> .[{x}]", "assume \"t - ?x \\<in> .[{x}]\""], ["proof (state)\nthis:\n  t - monomial (Suc 0) x \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t - monomial (Suc 0) x \\<in> .[{x}] \\<Longrightarrow> t \\<in> .[{x}]\n 2. t \\<in> .[{x}] \\<Longrightarrow> t - monomial (Suc 0) x \\<in> .[{x}]", "moreover"], ["proof (state)\nthis:\n  t - monomial (Suc 0) x \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t - monomial (Suc 0) x \\<in> .[{x}] \\<Longrightarrow> t \\<in> .[{x}]\n 2. t \\<in> .[{x}] \\<Longrightarrow> t - monomial (Suc 0) x \\<in> .[{x}]", "have \"?x \\<in> .[{x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (Suc 0) x \\<in> .[{x}]", "by (rule PPs_closed_single) simp"], ["proof (state)\nthis:\n  monomial (Suc 0) x \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t - monomial (Suc 0) x \\<in> .[{x}] \\<Longrightarrow> t \\<in> .[{x}]\n 2. t \\<in> .[{x}] \\<Longrightarrow> t - monomial (Suc 0) x \\<in> .[{x}]", "ultimately"], ["proof (chain)\npicking this:\n  t - monomial (Suc 0) x \\<in> .[{x}]\n  monomial (Suc 0) x \\<in> .[{x}]", "have \"(t - ?x) + ?x \\<in> .[{x}]\""], ["proof (prove)\nusing this:\n  t - monomial (Suc 0) x \\<in> .[{x}]\n  monomial (Suc 0) x \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. t - monomial (Suc 0) x + monomial (Suc 0) x \\<in> .[{x}]", "by (rule PPs_closed_plus)"], ["proof (state)\nthis:\n  t - monomial (Suc 0) x + monomial (Suc 0) x \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t - monomial (Suc 0) x \\<in> .[{x}] \\<Longrightarrow> t \\<in> .[{x}]\n 2. t \\<in> .[{x}] \\<Longrightarrow> t - monomial (Suc 0) x \\<in> .[{x}]", "with True"], ["proof (chain)\npicking this:\n  monomial (Suc 0) x adds t\n  t - monomial (Suc 0) x + monomial (Suc 0) x \\<in> .[{x}]", "show \"t \\<in> .[{x}]\""], ["proof (prove)\nusing this:\n  monomial (Suc 0) x adds t\n  t - monomial (Suc 0) x + monomial (Suc 0) x \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<in> .[{x}]", "by (simp add: adds_minus)"], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<in> .[{x}] \\<Longrightarrow> t - monomial (Suc 0) x \\<in> .[{x}]", "qed (rule PPs_closed_minus)"], ["proof (state)\nthis:\n  (t - monomial (Suc 0) x \\<in> .[{x}]) = (t \\<in> .[{x}])\n\ngoal (2 subgoals):\n 1. monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t\n 2. \\<not> monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "from True"], ["proof (chain)\npicking this:\n  monomial (Suc 0) x adds t", "have \"0 < lookup t x\""], ["proof (prove)\nusing this:\n  monomial (Suc 0) x adds t\n\ngoal (1 subgoal):\n 1. 0 < lookup t x", "by (metis adds_minus lookup_add lookup_single_eq n_not_Suc_n neq0_conv plus_eq_zero_2)"], ["proof (state)\nthis:\n  0 < lookup t x\n\ngoal (2 subgoals):\n 1. monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t\n 2. \\<not> monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "moreover"], ["proof (state)\nthis:\n  0 < lookup t x\n\ngoal (2 subgoals):\n 1. monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t\n 2. \\<not> monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "from this"], ["proof (chain)\npicking this:\n  0 < lookup t x", "have \"t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < lookup t x\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  t \\<noteq> 0\n\ngoal (2 subgoals):\n 1. monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t\n 2. \\<not> monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "ultimately"], ["proof (chain)\npicking this:\n  0 < lookup t x\n  t \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < lookup t x\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "using True"], ["proof (prove)\nusing this:\n  0 < lookup t x\n  t \\<noteq> 0\n  monomial (Suc 0) x adds t\n\ngoal (1 subgoal):\n 1. lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "by (simp add: pm_of_poly.rep_eq lookup_add lookup_single punit.lookup_monom_mult 1 coeff_pCons\n                    lookup_minus split: nat.split)"], ["proof (state)\nthis:\n  lookup (pm_of_poly x (pCons c p)) t =\n  lookup\n   (monomial c 0 + punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n   t\n\ngoal (1 subgoal):\n 1. \\<not> monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "case False"], ["proof (state)\nthis:\n  \\<not> monomial (Suc 0) x adds t\n\ngoal (1 subgoal):\n 1. \\<not> monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "moreover"], ["proof (state)\nthis:\n  \\<not> monomial (Suc 0) x adds t\n\ngoal (1 subgoal):\n 1. \\<not> monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "have \"t \\<in> .[{x}] \\<longleftrightarrow> t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<in> .[{x}]) = (t = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow> t = 0\n 2. t = 0 \\<Longrightarrow> t \\<in> .[{x}]", "assume \"t \\<in> .[{x}]\""], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow> t = 0\n 2. t = 0 \\<Longrightarrow> t \\<in> .[{x}]", "hence \"keys t \\<subseteq> {x}\""], ["proof (prove)\nusing this:\n  t \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> {x}", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys t \\<subseteq> {x}\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow> t = 0\n 2. t = 0 \\<Longrightarrow> t \\<in> .[{x}]", "show \"t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "assume \"t \\<noteq> 0\""], ["proof (state)\nthis:\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "hence \"keys t \\<noteq> {}\""], ["proof (prove)\nusing this:\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys t \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  keys t \\<noteq> {}", "obtain y where \"y \\<in> keys t\""], ["proof (prove)\nusing this:\n  keys t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> keys t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>keys t \\<subseteq> {x}\\<close>"], ["proof (chain)\npicking this:\n  keys t \\<subseteq> {x}\n  y \\<in> keys t", "have \"y \\<in> {x}\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> {x}\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. y \\<in> {x}", ".."], ["proof (state)\nthis:\n  y \\<in> {x}\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "hence \"y = x\""], ["proof (prove)\nusing this:\n  y \\<in> {x}\n\ngoal (1 subgoal):\n 1. y = x", "by simp"], ["proof (state)\nthis:\n  y = x\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>y \\<in> keys t\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> keys t\n  y = x", "have \"Suc 0 \\<le> lookup t x\""], ["proof (prove)\nusing this:\n  y \\<in> keys t\n  y = x\n\ngoal (1 subgoal):\n 1. Suc 0 \\<le> lookup t x", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  Suc 0 \\<le> lookup t x\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "hence \"?x adds t\""], ["proof (prove)\nusing this:\n  Suc 0 \\<le> lookup t x\n\ngoal (1 subgoal):\n 1. monomial (Suc 0) x adds t", "by (metis adds_poly_mappingI le0 le_funI lookup_single_eq lookup_single_not_eq)"], ["proof (state)\nthis:\n  monomial (Suc 0) x adds t\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0 \\<Longrightarrow> False", "with False"], ["proof (chain)\npicking this:\n  \\<not> monomial (Suc 0) x adds t\n  monomial (Suc 0) x adds t", "show False"], ["proof (prove)\nusing this:\n  \\<not> monomial (Suc 0) x adds t\n  monomial (Suc 0) x adds t\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t = 0\n\ngoal (1 subgoal):\n 1. t = 0 \\<Longrightarrow> t \\<in> .[{x}]", "qed (simp only: zero_in_PPs)"], ["proof (state)\nthis:\n  (t \\<in> .[{x}]) = (t = 0)\n\ngoal (1 subgoal):\n 1. \\<not> monomial (Suc 0) x adds t \\<Longrightarrow>\n    lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> monomial (Suc 0) x adds t\n  (t \\<in> .[{x}]) = (t = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> monomial (Suc 0) x adds t\n  (t \\<in> .[{x}]) = (t = 0)\n\ngoal (1 subgoal):\n 1. lookup (pm_of_poly x (pCons c p)) t =\n    lookup\n     (monomial c 0 +\n      punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n     t", "by (simp add: pm_of_poly.rep_eq lookup_add lookup_single punit.lookup_monom_mult when_def)"], ["proof (state)\nthis:\n  lookup (pm_of_poly x (pCons c p)) t =\n  lookup\n   (monomial c 0 + punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n   t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (pm_of_poly x (pCons c p)) t =\n  lookup\n   (monomial c 0 + punit.monom_mult (1::'b) (monomial 1 x) (pm_of_poly x p))\n   t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pm_of_poly_smult [simp]: \"pm_of_poly x (Polynomial.smult c p) = c \\<cdot> pm_of_poly x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (Polynomial.smult c p) = c \\<cdot> pm_of_poly x p", "by (rule poly_mapping_eqI) (simp add: pm_of_poly.rep_eq when_distrib)"], ["", "lemma pm_of_poly_times: \"pm_of_poly x (p * q) = pm_of_poly x p * pm_of_poly x (q::_::ring_1 poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (p * q) = pm_of_poly x p * pm_of_poly x q", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. pm_of_poly x (0 * q) = pm_of_poly x 0 * pm_of_poly x q\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        pm_of_poly x (p * q) = pm_of_poly x p * pm_of_poly x q\\<rbrakk>\n       \\<Longrightarrow> pm_of_poly x (pCons a p * q) =\n                         pm_of_poly x (pCons a p) * pm_of_poly x q", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. pm_of_poly x (0 * q) = pm_of_poly x 0 * pm_of_poly x q\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        pm_of_poly x (p * q) = pm_of_poly x p * pm_of_poly x q\\<rbrakk>\n       \\<Longrightarrow> pm_of_poly x (pCons a p * q) =\n                         pm_of_poly x (pCons a p) * pm_of_poly x q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (0 * q) = pm_of_poly x 0 * pm_of_poly x q", "by simp"], ["proof (state)\nthis:\n  pm_of_poly x (0 * q) = pm_of_poly x 0 * pm_of_poly x q\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        pm_of_poly x (p * q) = pm_of_poly x p * pm_of_poly x q\\<rbrakk>\n       \\<Longrightarrow> pm_of_poly x (pCons a p * q) =\n                         pm_of_poly x (pCons a p) * pm_of_poly x q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        pm_of_poly x (p * q) = pm_of_poly x p * pm_of_poly x q\\<rbrakk>\n       \\<Longrightarrow> pm_of_poly x (pCons a p * q) =\n                         pm_of_poly x (pCons a p) * pm_of_poly x q", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'b) \\<or> p \\<noteq> 0\n  pm_of_poly x (p * q) = pm_of_poly x p * pm_of_poly x q\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'b) \\<or> p \\<noteq> 0;\n        pm_of_poly x (p * q) = pm_of_poly x p * pm_of_poly x q\\<rbrakk>\n       \\<Longrightarrow> pm_of_poly x (pCons a p * q) =\n                         pm_of_poly x (pCons a p) * pm_of_poly x q", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (pCons a p * q) = pm_of_poly x (pCons a p) * pm_of_poly x q", "by (simp add: pm_of_poly_plus pm_of_poly_pCons map_scale_eq_times pCons(2) algebra_simps\n             flip: times_monomial_left)"], ["proof (state)\nthis:\n  pm_of_poly x (pCons a p * q) = pm_of_poly x (pCons a p) * pm_of_poly x q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pm_of_poly_sum: \"pm_of_poly x (sum f I) = (\\<Sum>i\\<in>I. pm_of_poly x (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (sum f I) = (\\<Sum>i\\<in>I. pm_of_poly x (f i))", "by (induct I rule: infinite_finite_induct) (simp_all add: pm_of_poly_plus)"], ["", "lemma pm_of_poly_prod: \"pm_of_poly x (prod f I) = (\\<Prod>i\\<in>I. pm_of_poly x (f i :: _::ring_1 poly))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (prod f I) = (\\<Prod>i\\<in>I. pm_of_poly x (f i))", "by (induct I rule: infinite_finite_induct) (simp_all add: pm_of_poly_times)"], ["", "lemma pm_of_poly_power [simp]: \"pm_of_poly x (p ^ m) = pm_of_poly x (p::_::ring_1 poly) ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_poly x (p ^ m) = pm_of_poly x p ^ m", "by (induct m) (simp_all add: pm_of_poly_times)"], ["", "lemma poly_of_pm_zero [simp]: \"poly_of_pm x 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x 0 = 0", "by (metis poly_of_pm_of_poly pm_of_poly_zero)"], ["", "lemma poly_of_pm_eq_zero_iff: \"poly_of_pm x p = 0 \\<longleftrightarrow> keys p \\<inter> .[{x}] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_of_pm x p = 0) = (keys p \\<inter> .[{x}] = {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "assume eq: \"poly_of_pm x p = 0\""], ["proof (state)\nthis:\n  poly_of_pm x p = 0\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "{"], ["proof (state)\nthis:\n  poly_of_pm x p = 0\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "assume \"t \\<in> .[{x}]\""], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "then"], ["proof (chain)\npicking this:\n  t \\<in> .[{x}]", "obtain d where \"t = Poly_Mapping.single x d\""], ["proof (prove)\nusing this:\n  t \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. (\\<And>d. t = monomial d x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding PPs_singleton"], ["proof (prove)\nusing this:\n  t \\<in> range (Poly_Mapping.single x)\n\ngoal (1 subgoal):\n 1. (\\<And>d. t = monomial d x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t = monomial d x\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "moreover"], ["proof (state)\nthis:\n  t = monomial d x\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "assume \"t \\<in> keys p\""], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "ultimately"], ["proof (chain)\npicking this:\n  t = monomial d x\n  t \\<in> keys p", "have \"0 \\<noteq> lookup p (Poly_Mapping.single x d)\""], ["proof (prove)\nusing this:\n  t = monomial d x\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. (0::'a) \\<noteq> lookup p (monomial d x)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (0::'a) \\<noteq> lookup p (monomial d x)\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "also"], ["proof (state)\nthis:\n  (0::'a) \\<noteq> lookup p (monomial d x)\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "have \"lookup p (Poly_Mapping.single x d) = Polynomial.coeff (poly_of_pm x p) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup p (monomial d x) = poly.coeff (poly_of_pm x p) d", "by simp"], ["proof (state)\nthis:\n  lookup p (monomial d x) = poly.coeff (poly_of_pm x p) d\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "also"], ["proof (state)\nthis:\n  lookup p (monomial d x) = poly.coeff (poly_of_pm x p) d\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (poly_of_pm x p) d = (0::'a)", "by (simp add: eq)"], ["proof (state)\nthis:\n  poly.coeff (poly_of_pm x p) d = (0::'a)\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "finally"], ["proof (chain)\npicking this:\n  (0::'a) \\<noteq> (0::'a)", "have False"], ["proof (prove)\nusing this:\n  (0::'a) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?t2 \\<in> .[{x}]; ?t2 \\<in> keys p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. poly_of_pm x p = 0 \\<Longrightarrow> keys p \\<inter> .[{x}] = {}\n 2. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "thus \"keys p \\<inter> .[{x}] = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?t2 \\<in> .[{x}]; ?t2 \\<in> keys p\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. keys p \\<inter> .[{x}] = {}", "by blast"], ["proof (state)\nthis:\n  keys p \\<inter> .[{x}] = {}\n\ngoal (1 subgoal):\n 1. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "assume *: \"keys p \\<inter> .[{x}] = {}\""], ["proof (state)\nthis:\n  keys p \\<inter> .[{x}] = {}\n\ngoal (1 subgoal):\n 1. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "{"], ["proof (state)\nthis:\n  keys p \\<inter> .[{x}] = {}\n\ngoal (1 subgoal):\n 1. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "have \"Poly_Mapping.single x d \\<in> .[{x}]\" (is \"?x \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial d x \\<in> .[{x}]", "by (rule PPs_closed_single) simp"], ["proof (state)\nthis:\n  monomial d x \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "with *"], ["proof (chain)\npicking this:\n  keys p \\<inter> .[{x}] = {}\n  monomial d x \\<in> .[{x}]", "have \"?x \\<notin> keys p\""], ["proof (prove)\nusing this:\n  keys p \\<inter> .[{x}] = {}\n  monomial d x \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. monomial d x \\<notin> keys p", "by blast"], ["proof (state)\nthis:\n  monomial d x \\<notin> keys p\n\ngoal (1 subgoal):\n 1. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "hence \"Polynomial.coeff (poly_of_pm x p) d = 0\""], ["proof (prove)\nusing this:\n  monomial d x \\<notin> keys p\n\ngoal (1 subgoal):\n 1. poly.coeff (poly_of_pm x p) d = (0::'a)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  poly.coeff (poly_of_pm x p) d = (0::'a)\n\ngoal (1 subgoal):\n 1. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "}"], ["proof (state)\nthis:\n  poly.coeff (poly_of_pm x p) ?d2 = (0::'a)\n\ngoal (1 subgoal):\n 1. keys p \\<inter> .[{x}] = {} \\<Longrightarrow> poly_of_pm x p = 0", "thus \"poly_of_pm x p = 0\""], ["proof (prove)\nusing this:\n  poly.coeff (poly_of_pm x p) ?d2 = (0::'a)\n\ngoal (1 subgoal):\n 1. poly_of_pm x p = 0", "using leading_coeff_0_iff"], ["proof (prove)\nusing this:\n  poly.coeff (poly_of_pm x p) ?d2 = (0::'a)\n  (lead_coeff ?p = (0::?'a)) = (?p = 0)\n\ngoal (1 subgoal):\n 1. poly_of_pm x p = 0", "by blast"], ["proof (state)\nthis:\n  poly_of_pm x p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_of_pm_monomial:\n  \"poly_of_pm x (monomial c t) = (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "proof (cases \"t \\<in> .[{x}]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "case True"], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "moreover"], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "from this"], ["proof (chain)\npicking this:\n  t \\<in> .[{x}]", "obtain d where \"t = Poly_Mapping.single x d\""], ["proof (prove)\nusing this:\n  t \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. (\\<And>d. t = monomial d x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis PPsD keys_subset_singleton_imp_monomial)"], ["proof (state)\nthis:\n  t = monomial d x\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> .[{x}]\n  t = monomial d x", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> .[{x}]\n  t = monomial d x\n\ngoal (1 subgoal):\n 1. poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "unfolding Polynomial.monom.abs_eq coeff_poly_of_pm"], ["proof (prove)\nusing this:\n  t \\<in> .[{x}]\n  t = monomial d x\n\ngoal (1 subgoal):\n 1. poly_of_pm x (monomial c t) =\n    (Abs_poly (\\<lambda>n. if lookup t x = n then c else (0::'a)) when\n     t \\<in> .[{x}])", "by (auto simp: poly_of_pm_def lookup_single when_def\n        dest!: monomial_inj intro!: arg_cong[where f=Abs_poly])"], ["proof (state)\nthis:\n  poly_of_pm x (monomial c t) =\n  (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "case False"], ["proof (state)\nthis:\n  t \\<notin> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "moreover"], ["proof (state)\nthis:\n  t \\<notin> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "from this"], ["proof (chain)\npicking this:\n  t \\<notin> .[{x}]", "have \"t \\<noteq> monomial d x\" for d"], ["proof (prove)\nusing this:\n  t \\<notin> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<noteq> monomial d x", "by (auto simp: PPs_closed_single)"], ["proof (state)\nthis:\n  t \\<noteq> monomial ?d x\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "ultimately"], ["proof (chain)\npicking this:\n  t \\<notin> .[{x}]\n  t \\<noteq> monomial ?d x", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<notin> .[{x}]\n  t \\<noteq> monomial ?d x\n\ngoal (1 subgoal):\n 1. poly_of_pm x (monomial c t) =\n    (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])", "unfolding Polynomial.monom.abs_eq coeff_poly_of_pm"], ["proof (prove)\nusing this:\n  t \\<notin> .[{x}]\n  t \\<noteq> monomial ?d x\n\ngoal (1 subgoal):\n 1. poly_of_pm x (monomial c t) =\n    (Abs_poly (\\<lambda>n. if lookup t x = n then c else (0::'a)) when\n     t \\<in> .[{x}])", "by (auto simp: poly_of_pm_def lookup_single when_def zero_poly.abs_eq)"], ["proof (state)\nthis:\n  poly_of_pm x (monomial c t) =\n  (Polynomial.monom c (lookup t x) when t \\<in> .[{x}])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_of_pm_plus: \"poly_of_pm x (p + q) = poly_of_pm x p + poly_of_pm x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (p + q) = poly_of_pm x p + poly_of_pm x q", "unfolding Polynomial.plus_poly.abs_eq coeff_poly_of_pm"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (p + q) =\n    Abs_poly (\\<lambda>n. lookup p (monomial n x) + lookup q (monomial n x))", "by (simp add: poly_of_pm_def lookup_add)"], ["", "lemma poly_of_pm_uminus [simp]: \"poly_of_pm x (- p) = - poly_of_pm x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (- p) = - poly_of_pm x p", "unfolding Polynomial.uminus_poly.abs_eq coeff_poly_of_pm"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (- p) = Abs_poly (\\<lambda>n. - lookup p (monomial n x))", "by (simp add: poly_of_pm_def)"], ["", "lemma poly_of_pm_minus: \"poly_of_pm x (p - q) = poly_of_pm x p - poly_of_pm x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (p - q) = poly_of_pm x p - poly_of_pm x q", "unfolding Polynomial.minus_poly.abs_eq coeff_poly_of_pm"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (p - q) =\n    Abs_poly (\\<lambda>n. lookup p (monomial n x) - lookup q (monomial n x))", "by (simp add: poly_of_pm_def lookup_minus)"], ["", "lemma poly_of_pm_one [simp]: \"poly_of_pm x 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x 1 = 1", "by (simp add: poly_of_pm_monomial zero_in_PPs flip: single_one monom_eq_1)"], ["", "lemma poly_of_pm_times:\n  \"poly_of_pm x (p * q) = poly_of_pm x p * poly_of_pm x (q::_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (p * q) = poly_of_pm x p * poly_of_pm x q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_of_pm x (p * q) = poly_of_pm x p * poly_of_pm x q", "have eq: \"poly_of_pm x (monomial c t * q) = poly_of_pm x (monomial c t) * poly_of_pm x q\"\n    if \"c \\<noteq> 0\" for c t"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "proof (cases \"t \\<in> .[{x}]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "case True"], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "then"], ["proof (chain)\npicking this:\n  t \\<in> .[{x}]", "obtain d where t: \"t = Poly_Mapping.single x d\""], ["proof (prove)\nusing this:\n  t \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. (\\<And>d. t = monomial d x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding PPs_singleton"], ["proof (prove)\nusing this:\n  t \\<in> range (Poly_Mapping.single x)\n\ngoal (1 subgoal):\n 1. (\\<And>d. t = monomial d x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t = monomial d x\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "have \"poly_of_pm x (monomial c t) * poly_of_pm x q = Polynomial.monom c (lookup t x) * poly_of_pm x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (monomial c t) * poly_of_pm x q =\n    Polynomial.monom c (lookup t x) * poly_of_pm x q", "by (simp add: True poly_of_pm_monomial)"], ["proof (state)\nthis:\n  poly_of_pm x (monomial c t) * poly_of_pm x q =\n  Polynomial.monom c (lookup t x) * poly_of_pm x q\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "also"], ["proof (state)\nthis:\n  poly_of_pm x (monomial c t) * poly_of_pm x q =\n  Polynomial.monom c (lookup t x) * poly_of_pm x q\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "have \"\\<dots> = poly_of_pm x (monomial c t * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom c (lookup t x) * poly_of_pm x q =\n    poly_of_pm x (monomial c t * q)", "unfolding t"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n    poly_of_pm x (monomial c (monomial d x) * q)", "proof (induct d)"], ["proof (state)\ngoal (2 subgoals):\n 1. Polynomial.monom c (lookup (monomial 0 x) x) * poly_of_pm x q =\n    poly_of_pm x (monomial c (monomial 0 x) * q)\n 2. \\<And>d.\n       Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial d x) * q) \\<Longrightarrow>\n       Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Polynomial.monom c (lookup (monomial 0 x) x) * poly_of_pm x q =\n    poly_of_pm x (monomial c (monomial 0 x) * q)\n 2. \\<And>d.\n       Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial d x) * q) \\<Longrightarrow>\n       Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "have \"Polynomial.smult c (poly_of_pm x q) = poly_of_pm x (c \\<cdot> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult c (poly_of_pm x q) = poly_of_pm x (c \\<cdot> q)", "unfolding Polynomial.smult.abs_eq coeff_poly_of_pm"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_poly (\\<lambda>n. c * lookup q (monomial n x)) =\n    poly_of_pm x (c \\<cdot> q)", "by (simp add: poly_of_pm_def)"], ["proof (state)\nthis:\n  Polynomial.smult c (poly_of_pm x q) = poly_of_pm x (c \\<cdot> q)\n\ngoal (2 subgoals):\n 1. Polynomial.monom c (lookup (monomial 0 x) x) * poly_of_pm x q =\n    poly_of_pm x (monomial c (monomial 0 x) * q)\n 2. \\<And>d.\n       Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial d x) * q) \\<Longrightarrow>\n       Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "with that"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)\n  Polynomial.smult c (poly_of_pm x q) = poly_of_pm x (c \\<cdot> q)", "show ?case"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  Polynomial.smult c (poly_of_pm x q) = poly_of_pm x (c \\<cdot> q)\n\ngoal (1 subgoal):\n 1. Polynomial.monom c (lookup (monomial 0 x) x) * poly_of_pm x q =\n    poly_of_pm x (monomial c (monomial 0 x) * q)", "by (simp add: Polynomial.times_poly_def flip: map_scale_eq_times)"], ["proof (state)\nthis:\n  Polynomial.monom c (lookup (monomial 0 x) x) * poly_of_pm x q =\n  poly_of_pm x (monomial c (monomial 0 x) * q)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial d x) * q) \\<Longrightarrow>\n       Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial d x) * q) \\<Longrightarrow>\n       Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "case (Suc d)"], ["proof (state)\nthis:\n  Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n  poly_of_pm x (monomial c (monomial d x) * q)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial d x) * q) \\<Longrightarrow>\n       Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "have 1: \"Poly_Mapping.single x a adds Poly_Mapping.single x b \\<longleftrightarrow> a \\<le> b\" for a b :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (monomial a x adds monomial b x) = (a \\<le> b)", "by (metis adds_def deg_pm_mono deg_pm_single le_Suc_ex single_add)"], ["proof (state)\nthis:\n  (monomial ?a x adds monomial ?b x) = (?a \\<le> ?b)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial d x) * q) \\<Longrightarrow>\n       Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "have 2: \"poly_of_pm x (punit.monom_mult 1 (Poly_Mapping.single x 1) r) = pCons 0 (poly_of_pm x r)\"\n        for r :: \"_ \\<Rightarrow>\\<^sub>0 'a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (punit.monom_mult (1::'a) (monomial 1 x) r) =\n    pCons (0::'a) (poly_of_pm x r)", "unfolding poly.coeff_inject[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (poly_of_pm x (punit.monom_mult (1::'a) (monomial 1 x) r)) =\n    poly.coeff (pCons (0::'a) (poly_of_pm x r))", "by (rule ext) (simp add: coeff_pCons punit.lookup_monom_mult adds_zero monomial_0_iff 1\n                            flip: single_diff split: nat.split)"], ["proof (state)\nthis:\n  poly_of_pm x (punit.monom_mult (1::'a) (monomial 1 x) ?r) =\n  pCons (0::'a) (poly_of_pm x ?r)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial d x) * q) \\<Longrightarrow>\n       Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "from Suc that"], ["proof (chain)\npicking this:\n  Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n  poly_of_pm x (monomial c (monomial d x) * q)\n  c \\<noteq> (0::'a)", "have \"Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n                          poly_of_pm x (punit.monom_mult 1 (Poly_Mapping.single x 1)\n                                            ((monomial c (monomial d x)) * q))\""], ["proof (prove)\nusing this:\n  Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n  poly_of_pm x (monomial c (monomial d x) * q)\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n    poly_of_pm x\n     (punit.monom_mult (1::'a) (monomial 1 x)\n       (monomial c (monomial d x) * q))", "by (simp add: Polynomial.times_poly_def 2 del: One_nat_def)"], ["proof (state)\nthis:\n  Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n  poly_of_pm x\n   (punit.monom_mult (1::'a) (monomial 1 x) (monomial c (monomial d x) * q))\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial d x) * q) \\<Longrightarrow>\n       Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "also"], ["proof (state)\nthis:\n  Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n  poly_of_pm x\n   (punit.monom_mult (1::'a) (monomial 1 x) (monomial c (monomial d x) * q))\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial d x) * q) \\<Longrightarrow>\n       Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "have \"\\<dots> = poly_of_pm x (monomial c (Poly_Mapping.single x (Suc d)) * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x\n     (punit.monom_mult (1::'a) (monomial 1 x)\n       (monomial c (monomial d x) * q)) =\n    poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "by (simp add: ac_simps times_monomial_monomial flip: single_add times_monomial_left)"], ["proof (state)\nthis:\n  poly_of_pm x\n   (punit.monom_mult (1::'a) (monomial 1 x)\n     (monomial c (monomial d x) * q)) =\n  poly_of_pm x (monomial c (monomial (Suc d) x) * q)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       Polynomial.monom c (lookup (monomial d x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial d x) * q) \\<Longrightarrow>\n       Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n       poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "finally"], ["proof (chain)\npicking this:\n  Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n  poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "show ?case"], ["proof (prove)\nusing this:\n  Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n  poly_of_pm x (monomial c (monomial (Suc d) x) * q)\n\ngoal (1 subgoal):\n 1. Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n    poly_of_pm x (monomial c (monomial (Suc d) x) * q)", "."], ["proof (state)\nthis:\n  Polynomial.monom c (lookup (monomial (Suc d) x) x) * poly_of_pm x q =\n  poly_of_pm x (monomial c (monomial (Suc d) x) * q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Polynomial.monom c (lookup t x) * poly_of_pm x q =\n  poly_of_pm x (monomial c t * q)\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "finally"], ["proof (chain)\npicking this:\n  poly_of_pm x (monomial c t) * poly_of_pm x q =\n  poly_of_pm x (monomial c t * q)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_of_pm x (monomial c t) * poly_of_pm x q =\n  poly_of_pm x (monomial c t * q)\n\ngoal (1 subgoal):\n 1. poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "by (rule sym)"], ["proof (state)\nthis:\n  poly_of_pm x (monomial c t * q) =\n  poly_of_pm x (monomial c t) * poly_of_pm x q\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "case False"], ["proof (state)\nthis:\n  t \\<notin> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "{"], ["proof (state)\nthis:\n  t \\<notin> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "assume \"s \\<in> keys (monomial c t * q)\""], ["proof (state)\nthis:\n  s \\<in> keys (monomial c t * q)\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "also"], ["proof (state)\nthis:\n  s \\<in> keys (monomial c t * q)\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "have \"\\<dots> \\<subseteq> (+) t ` keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial c t * q) \\<subseteq> (+) t ` keys q", "unfolding times_monomial_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (punit.monom_mult c t q) \\<subseteq> (+) t ` keys q", "by (fact punit.keys_monom_mult_subset[simplified])"], ["proof (state)\nthis:\n  keys (monomial c t * q) \\<subseteq> (+) t ` keys q\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "finally"], ["proof (chain)\npicking this:\n  s \\<in> (+) t ` keys q", "obtain u where s: \"s = t + u\""], ["proof (prove)\nusing this:\n  s \\<in> (+) t ` keys q\n\ngoal (1 subgoal):\n 1. (\\<And>u. s = t + u \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  s = t + u\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "assume \"s \\<in> .[{x}]\""], ["proof (state)\nthis:\n  s \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "hence \"s - u \\<in> .[{x}]\""], ["proof (prove)\nusing this:\n  s \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. s - u \\<in> .[{x}]", "by (rule PPs_closed_minus)"], ["proof (state)\nthis:\n  s - u \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "hence \"t \\<in> .[{x}]\""], ["proof (prove)\nusing this:\n  s - u \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<in> .[{x}]", "by (simp add: s)"], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "with False"], ["proof (chain)\npicking this:\n  t \\<notin> .[{x}]\n  t \\<in> .[{x}]", "have False"], ["proof (prove)\nusing this:\n  t \\<notin> .[{x}]\n  t \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?s2 \\<in> keys (monomial c t * q); ?s2 \\<in> .[{x}]\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "hence \"poly_of_pm x (monomial c t * q) = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2 \\<in> keys (monomial c t * q); ?s2 \\<in> .[{x}]\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. poly_of_pm x (monomial c t * q) = 0", "by (auto simp: poly_of_pm_eq_zero_iff)"], ["proof (state)\nthis:\n  poly_of_pm x (monomial c t * q) = 0\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "with False"], ["proof (chain)\npicking this:\n  t \\<notin> .[{x}]\n  poly_of_pm x (monomial c t * q) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<notin> .[{x}]\n  poly_of_pm x (monomial c t * q) = 0\n\ngoal (1 subgoal):\n 1. poly_of_pm x (monomial c t * q) =\n    poly_of_pm x (monomial c t) * poly_of_pm x q", "by (simp add: poly_of_pm_monomial)"], ["proof (state)\nthis:\n  poly_of_pm x (monomial c t * q) =\n  poly_of_pm x (monomial c t) * poly_of_pm x q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?c \\<noteq> (0::'a) \\<Longrightarrow>\n  poly_of_pm x (monomial ?c ?t * q) =\n  poly_of_pm x (monomial ?c ?t) * poly_of_pm x q\n\ngoal (1 subgoal):\n 1. poly_of_pm x (p * q) = poly_of_pm x p * poly_of_pm x q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (p * q) = poly_of_pm x p * poly_of_pm x q", "by (induct p rule: poly_mapping_plus_induct) (simp_all add: poly_of_pm_plus eq distrib_right)"], ["proof (state)\nthis:\n  poly_of_pm x (p * q) = poly_of_pm x p * poly_of_pm x q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_of_pm_sum: \"poly_of_pm x (sum f I) = (\\<Sum>i\\<in>I. poly_of_pm x (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (sum f I) = (\\<Sum>i\\<in>I. poly_of_pm x (f i))", "by (induct I rule: infinite_finite_induct) (simp_all add: poly_of_pm_plus)"], ["", "lemma poly_of_pm_prod: \"poly_of_pm x (prod f I) = (\\<Prod>i\\<in>I. poly_of_pm x (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (prod f I) = (\\<Prod>i\\<in>I. poly_of_pm x (f i))", "by (induct I rule: infinite_finite_induct) (simp_all add: poly_of_pm_times)"], ["", "lemma poly_of_pm_power [simp]: \"poly_of_pm x (p ^ m) = poly_of_pm x p ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_pm x (p ^ m) = poly_of_pm x p ^ m", "by (induct m) (simp_all add: poly_of_pm_times)"], ["", "subsection \\<open>Evaluating Polynomials\\<close>"], ["", "lemma poly_eq_poly_eval: \"poly (poly_of_pm x p) a = poly_eval (\\<lambda>y. a when y = x) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_of_pm x p) a = poly_eval (\\<lambda>y. a when y = x) p", "proof (induction p rule: poly_mapping_plus_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly (poly_of_pm x 0) a = poly_eval (\\<lambda>y. a when y = x) 0\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        poly (poly_of_pm x p) a =\n        poly_eval (\\<lambda>y. a when y = x) p\\<rbrakk>\n       \\<Longrightarrow> poly (poly_of_pm x (monomial c t + p)) a =\n                         poly_eval (\\<lambda>y. a when y = x)\n                          (monomial c t + p)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. poly (poly_of_pm x 0) a = poly_eval (\\<lambda>y. a when y = x) 0\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        poly (poly_of_pm x p) a =\n        poly_eval (\\<lambda>y. a when y = x) p\\<rbrakk>\n       \\<Longrightarrow> poly (poly_of_pm x (monomial c t + p)) a =\n                         poly_eval (\\<lambda>y. a when y = x)\n                          (monomial c t + p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_of_pm x 0) a = poly_eval (\\<lambda>y. a when y = x) 0", "by simp"], ["proof (state)\nthis:\n  poly (poly_of_pm x 0) a = poly_eval (\\<lambda>y. a when y = x) 0\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        poly (poly_of_pm x p) a =\n        poly_eval (\\<lambda>y. a when y = x) p\\<rbrakk>\n       \\<Longrightarrow> poly (poly_of_pm x (monomial c t + p)) a =\n                         poly_eval (\\<lambda>y. a when y = x)\n                          (monomial c t + p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        poly (poly_of_pm x p) a =\n        poly_eval (\\<lambda>y. a when y = x) p\\<rbrakk>\n       \\<Longrightarrow> poly (poly_of_pm x (monomial c t + p)) a =\n                         poly_eval (\\<lambda>y. a when y = x)\n                          (monomial c t + p)", "case (2 p c t)"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  t \\<notin> keys p\n  poly (poly_of_pm x p) a = poly_eval (\\<lambda>y. a when y = x) p\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        poly (poly_of_pm x p) a =\n        poly_eval (\\<lambda>y. a when y = x) p\\<rbrakk>\n       \\<Longrightarrow> poly (poly_of_pm x (monomial c t + p)) a =\n                         poly_eval (\\<lambda>y. a when y = x)\n                          (monomial c t + p)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "proof (cases \"t \\<in> .[{x}]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "case True"], ["proof (state)\nthis:\n  t \\<in> .[{x}]\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "have \"poly_eval (\\<lambda>y. a when y = x) (monomial c t) = c * (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>y. a when y = x) (monomial c t) =\n    c * (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y)", "by (simp only: poly_eval_monomial)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>y. a when y = x) (monomial c t) =\n  c * (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y)\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "also"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>y. a when y = x) (monomial c t) =\n  c * (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y)\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "from True"], ["proof (chain)\npicking this:\n  t \\<in> .[{x}]", "have \"(\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y) = (\\<Prod>y\\<in>{x}. (a when y = x) ^ lookup t y)\""], ["proof (prove)\nusing this:\n  t \\<in> .[{x}]\n\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y) =\n    (\\<Prod>y\\<in>{x}. (a when y = x) ^ lookup t y)", "by (intro prod.mono_neutral_left ballI) (auto simp: in_keys_iff dest: PPsD)"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y) =\n  (\\<Prod>y\\<in>{x}. (a when y = x) ^ lookup t y)\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "also"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y) =\n  (\\<Prod>y\\<in>{x}. (a when y = x) ^ lookup t y)\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "have \"\\<dots> = a ^ lookup t x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>{x}. (a when y = x) ^ lookup t y) = a ^ lookup t x", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>{x}. (a when y = x) ^ lookup t y) = a ^ lookup t x\n\ngoal (2 subgoals):\n 1. t \\<in> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)\n 2. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "finally"], ["proof (chain)\npicking this:\n  poly_eval (\\<lambda>y. a when y = x) (monomial c t) = c * a ^ lookup t x", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>y. a when y = x) (monomial c t) = c * a ^ lookup t x\n\ngoal (1 subgoal):\n 1. poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "by (simp add: poly_of_pm_plus poly_of_pm_monomial poly_monom poly_eval_plus True 2(3))"], ["proof (state)\nthis:\n  poly (poly_of_pm x (monomial c t + p)) a =\n  poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "case False"], ["proof (state)\nthis:\n  t \\<notin> .[{x}]\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "have \"poly_eval (\\<lambda>y. a when y = x) (monomial c t) = c * (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>y. a when y = x) (monomial c t) =\n    c * (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y)", "by (simp only: poly_eval_monomial)"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>y. a when y = x) (monomial c t) =\n  c * (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y)\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "also"], ["proof (state)\nthis:\n  poly_eval (\\<lambda>y. a when y = x) (monomial c t) =\n  c * (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y)\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"(\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y) = 0\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y) = (0::'a)", "proof (rule prod_zero)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>aa\\<in>keys t. (a when aa = x) ^ lookup t aa = (0::'a)", "from False"], ["proof (chain)\npicking this:\n  t \\<notin> .[{x}]", "obtain y where \"y \\<in> keys t\" and \"y \\<noteq> x\""], ["proof (prove)\nusing this:\n  t \\<notin> .[{x}]\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> keys t; y \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: PPs_def)"], ["proof (state)\nthis:\n  y \\<in> keys t\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<exists>aa\\<in>keys t. (a when aa = x) ^ lookup t aa = (0::'a)", "from this(1)"], ["proof (chain)\npicking this:\n  y \\<in> keys t", "show \"\\<exists>y\\<in>keys t. (a when y = x) ^ lookup t y = 0\""], ["proof (prove)\nusing this:\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>keys t. (a when y = x) ^ lookup t y = (0::'a)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (a when y = x) ^ lookup t y = (0::'a)", "from \\<open>y \\<in> keys t\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> keys t", "have \"0 < lookup t y\""], ["proof (prove)\nusing this:\n  y \\<in> keys t\n\ngoal (1 subgoal):\n 1. 0 < lookup t y", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  0 < lookup t y\n\ngoal (1 subgoal):\n 1. (a when y = x) ^ lookup t y = (0::'a)", "with \\<open>y \\<noteq> x\\<close>"], ["proof (chain)\npicking this:\n  y \\<noteq> x\n  0 < lookup t y", "show \"(a when y = x) ^ lookup t y = 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> x\n  0 < lookup t y\n\ngoal (1 subgoal):\n 1. (a when y = x) ^ lookup t y = (0::'a)", "by (simp add: zero_power)"], ["proof (state)\nthis:\n  (a when y = x) ^ lookup t y = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y\\<in>keys t. (a when y = x) ^ lookup t y = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>keys t. (a when y = x) ^ lookup t y) = (0::'a)\n\ngoal (1 subgoal):\n 1. t \\<notin> .[{x}] \\<Longrightarrow>\n    poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "finally"], ["proof (chain)\npicking this:\n  poly_eval (\\<lambda>y. a when y = x) (monomial c t) = c * (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_eval (\\<lambda>y. a when y = x) (monomial c t) = c * (0::'a)\n\ngoal (1 subgoal):\n 1. poly (poly_of_pm x (monomial c t + p)) a =\n    poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)", "by (simp add: poly_of_pm_plus poly_of_pm_monomial poly_monom poly_eval_plus False 2(3))"], ["proof (state)\nthis:\n  poly (poly_of_pm x (monomial c t + p)) a =\n  poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly (poly_of_pm x (monomial c t + p)) a =\n  poly_eval (\\<lambda>y. a when y = x) (monomial c t + p)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary poly_eq_poly_eval':\n  assumes \"p \\<in> P[{x}]\"\n  shows \"poly (poly_of_pm x p) a = poly_eval (\\<lambda>_. a) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_of_pm x p) a = poly_eval (\\<lambda>_. a) p", "unfolding poly_eq_poly_eval"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>y. a when y = x) p = poly_eval (\\<lambda>_. a) p", "using refl"], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. poly_eval (\\<lambda>y. a when y = x) p = poly_eval (\\<lambda>_. a) p", "proof (rule poly_eval_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> indets p \\<Longrightarrow> (a when xa = x) = a", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> indets p \\<Longrightarrow> (a when xa = x) = a", "assume \"y \\<in> indets p\""], ["proof (state)\nthis:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> indets p \\<Longrightarrow> (a when xa = x) = a", "also"], ["proof (state)\nthis:\n  y \\<in> indets p\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> indets p \\<Longrightarrow> (a when xa = x) = a", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[{x}]", "have \"\\<dots> \\<subseteq> {x}\""], ["proof (prove)\nusing this:\n  p \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. indets p \\<subseteq> {x}", "by (rule PolysD)"], ["proof (state)\nthis:\n  indets p \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> indets p \\<Longrightarrow> (a when xa = x) = a", "finally"], ["proof (chain)\npicking this:\n  y \\<in> {x}", "show \"(a when y = x) = a\""], ["proof (prove)\nusing this:\n  y \\<in> {x}\n\ngoal (1 subgoal):\n 1. (a when y = x) = a", "by simp"], ["proof (state)\nthis:\n  (a when y = x) = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_eval_eq_poly: \"poly_eval a (pm_of_poly x p) = poly p (a x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_eval a (pm_of_poly x p) = poly p (a x)", "by (induct p)\n    (simp_all add: pm_of_poly_pCons poly_eval_plus poly_eval_times poly_eval_monomial\n              flip: times_monomial_left)"], ["", "subsection \\<open>Morphisms \\<open>flat_pm_of_poly\\<close> and \\<open>poly_of_focus\\<close>\\<close>"], ["", "definition flat_pm_of_poly :: \"'x \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) poly \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::semiring_1)\"\n  where \"flat_pm_of_poly x = flatten \\<circ> pm_of_poly x\""], ["", "definition poly_of_focus :: \"'x \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_monoid_add) poly\"\n  where \"poly_of_focus x = poly_of_pm x \\<circ> focus {x}\""], ["", "lemma flat_pm_of_poly_in_Polys:\n  assumes \"range (poly.coeff p) \\<subseteq> P[Y]\"\n  shows \"flat_pm_of_poly x p \\<in> P[insert x Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_pm_of_poly x p \\<in> P[insert x Y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. flat_pm_of_poly x p \\<in> P[insert x Y]", "let ?p = \"pm_of_poly x p\""], ["proof (state)\ngoal (1 subgoal):\n 1. flat_pm_of_poly x p \\<in> P[insert x Y]", "from assms"], ["proof (chain)\npicking this:\n  range (poly.coeff p) \\<subseteq> P[Y]", "have \"lookup ?p ` keys ?p \\<subseteq> P[Y]\""], ["proof (prove)\nusing this:\n  range (poly.coeff p) \\<subseteq> P[Y]\n\ngoal (1 subgoal):\n 1. lookup (pm_of_poly x p) ` keys (pm_of_poly x p) \\<subseteq> P[Y]", "by (simp add: keys_pm_of_poly image_image) blast"], ["proof (state)\nthis:\n  lookup (pm_of_poly x p) ` keys (pm_of_poly x p) \\<subseteq> P[Y]\n\ngoal (1 subgoal):\n 1. flat_pm_of_poly x p \\<in> P[insert x Y]", "with pm_of_poly_in_Polys"], ["proof (chain)\npicking this:\n  pm_of_poly ?x ?p \\<in> P[{?x}]\n  lookup (pm_of_poly x p) ` keys (pm_of_poly x p) \\<subseteq> P[Y]", "have \"flatten ?p \\<in> P[{x} \\<union> Y]\""], ["proof (prove)\nusing this:\n  pm_of_poly ?x ?p \\<in> P[{?x}]\n  lookup (pm_of_poly x p) ` keys (pm_of_poly x p) \\<subseteq> P[Y]\n\ngoal (1 subgoal):\n 1. flatten (pm_of_poly x p) \\<in> P[{x} \\<union> Y]", "by (rule flatten_in_Polys)"], ["proof (state)\nthis:\n  flatten (pm_of_poly x p) \\<in> P[{x} \\<union> Y]\n\ngoal (1 subgoal):\n 1. flat_pm_of_poly x p \\<in> P[insert x Y]", "thus ?thesis"], ["proof (prove)\nusing this:\n  flatten (pm_of_poly x p) \\<in> P[{x} \\<union> Y]\n\ngoal (1 subgoal):\n 1. flat_pm_of_poly x p \\<in> P[insert x Y]", "by (simp add: flat_pm_of_poly_def)"], ["proof (state)\nthis:\n  flat_pm_of_poly x p \\<in> P[insert x Y]\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary indets_flat_pm_of_poly_subset:\n  \"indets (flat_pm_of_poly x p) \\<subseteq> insert x (\\<Union> (indets ` range (poly.coeff p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indets (flat_pm_of_poly x p)\n    \\<subseteq> insert x (\\<Union> (indets ` range (poly.coeff p)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. indets (flat_pm_of_poly x p)\n    \\<subseteq> insert x (\\<Union> (indets ` range (poly.coeff p)))", "let ?p = \"pm_of_poly x p\""], ["proof (state)\ngoal (1 subgoal):\n 1. indets (flat_pm_of_poly x p)\n    \\<subseteq> insert x (\\<Union> (indets ` range (poly.coeff p)))", "let ?Y = \"\\<Union> (indets ` range (poly.coeff p))\""], ["proof (state)\ngoal (1 subgoal):\n 1. indets (flat_pm_of_poly x p)\n    \\<subseteq> insert x (\\<Union> (indets ` range (poly.coeff p)))", "have \"range (poly.coeff p) \\<subseteq> P[?Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (poly.coeff p)\n    \\<subseteq> P[\\<Union> (indets ` range (poly.coeff p))]", "by (auto intro: PolysI_alt)"], ["proof (state)\nthis:\n  range (poly.coeff p)\n  \\<subseteq> P[\\<Union> (indets ` range (poly.coeff p))]\n\ngoal (1 subgoal):\n 1. indets (flat_pm_of_poly x p)\n    \\<subseteq> insert x (\\<Union> (indets ` range (poly.coeff p)))", "hence \"flat_pm_of_poly x p \\<in> P[insert x ?Y]\""], ["proof (prove)\nusing this:\n  range (poly.coeff p)\n  \\<subseteq> P[\\<Union> (indets ` range (poly.coeff p))]\n\ngoal (1 subgoal):\n 1. flat_pm_of_poly x p\n    \\<in> P[insert x (\\<Union> (indets ` range (poly.coeff p)))]", "by (rule flat_pm_of_poly_in_Polys)"], ["proof (state)\nthis:\n  flat_pm_of_poly x p\n  \\<in> P[insert x (\\<Union> (indets ` range (poly.coeff p)))]\n\ngoal (1 subgoal):\n 1. indets (flat_pm_of_poly x p)\n    \\<subseteq> insert x (\\<Union> (indets ` range (poly.coeff p)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  flat_pm_of_poly x p\n  \\<in> P[insert x (\\<Union> (indets ` range (poly.coeff p)))]\n\ngoal (1 subgoal):\n 1. indets (flat_pm_of_poly x p)\n    \\<subseteq> insert x (\\<Union> (indets ` range (poly.coeff p)))", "by (rule PolysD)"], ["proof (state)\nthis:\n  indets (flat_pm_of_poly x p)\n  \\<subseteq> insert x (\\<Union> (indets ` range (poly.coeff p)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  shows flat_pm_of_poly_zero [simp]: \"flat_pm_of_poly x 0 = 0\"\n    and flat_pm_of_poly_monom: \"flat_pm_of_poly x (Polynomial.monom c d) =\n                                    punit.monom_mult 1 (Poly_Mapping.single x d) c\"\n    and flat_pm_of_poly_plus: \"flat_pm_of_poly x (p + q) =\n                                  flat_pm_of_poly x p + flat_pm_of_poly x q\"\n    and flat_pm_of_poly_one [simp]: \"flat_pm_of_poly x 1 = 1\"\n    and flat_pm_of_poly_sum: \"flat_pm_of_poly x (sum f I) = (\\<Sum>i\\<in>I. flat_pm_of_poly x (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (flat_pm_of_poly x 0 = 0 &&&\n     flat_pm_of_poly x (Polynomial.monom c d) =\n     punit.monom_mult (1::'c) (monomial d x) c) &&&\n    flat_pm_of_poly x (p + q) =\n    flat_pm_of_poly x p + flat_pm_of_poly x q &&&\n    flat_pm_of_poly x 1 = 1 &&&\n    flat_pm_of_poly x (sum f I) = (\\<Sum>i\\<in>I. flat_pm_of_poly x (f i))", "by (simp_all add: flat_pm_of_poly_def pm_of_poly_monom flatten_monomial pm_of_poly_plus\n                    flatten_plus pm_of_poly_sum flatten_sum)"], ["", "lemma\n  shows flat_pm_of_poly_uminus [simp]: \"flat_pm_of_poly x (- p) = - flat_pm_of_poly x p\"\n    and flat_pm_of_poly_minus: \"flat_pm_of_poly x (p - q) =\n                                  flat_pm_of_poly x p - flat_pm_of_poly x (q::_::ring poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_pm_of_poly x (- p) = - flat_pm_of_poly x p &&&\n    flat_pm_of_poly x (p - q) = flat_pm_of_poly x p - flat_pm_of_poly x q", "by (simp_all add: flat_pm_of_poly_def pm_of_poly_minus flatten_minus)"], ["", "lemma flat_pm_of_poly_pCons:\n  \"flat_pm_of_poly x (pCons c p) =\n    c + punit.monom_mult 1 (Poly_Mapping.single x 1) (flat_pm_of_poly x (p::_::comm_semiring_1 poly))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_pm_of_poly x (pCons c p) =\n    c + punit.monom_mult (1::'b) (monomial 1 x) (flat_pm_of_poly x p)", "by (simp add: flat_pm_of_poly_def pm_of_poly_pCons flatten_plus flatten_monomial flatten_times\n          flip: times_monomial_left)"], ["", "lemma flat_pm_of_poly_smult [simp]:\n  \"flat_pm_of_poly x (Polynomial.smult c p) = c * flat_pm_of_poly x (p::_::comm_semiring_1 poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_pm_of_poly x (Polynomial.smult c p) = c * flat_pm_of_poly x p", "by (simp add: flat_pm_of_poly_def map_scale_eq_times flatten_times flatten_monomial pm_of_poly_times)"], ["", "lemma\n  shows flat_pm_of_poly_times: \"flat_pm_of_poly x (p * q) = flat_pm_of_poly x p * flat_pm_of_poly x q\"\n    and flat_pm_of_poly_prod: \"flat_pm_of_poly x (prod f I) =\n                                  (\\<Prod>i\\<in>I. flat_pm_of_poly x (f i :: _::comm_ring_1 poly))\"\n    and flat_pm_of_poly_power: \"flat_pm_of_poly x (p ^ m) = flat_pm_of_poly x (p::_::comm_ring_1 poly) ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_pm_of_poly x (p * q) =\n    flat_pm_of_poly x p * flat_pm_of_poly x q &&&\n    flat_pm_of_poly x (prod f I) =\n    (\\<Prod>i\\<in>I. flat_pm_of_poly x (f i)) &&&\n    flat_pm_of_poly x (p ^ m) = flat_pm_of_poly x p ^ m", "by (simp_all add: flat_pm_of_poly_def flatten_times pm_of_poly_times flatten_prod pm_of_poly_prod)"], ["", "lemma coeff_poly_of_focus_subset_Polys:\n  assumes \"p \\<in> P[X]\"\n  shows \"range (poly.coeff (poly_of_focus x p)) \\<subseteq> P[X - {x}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (poly.coeff (poly_of_focus x p)) \\<subseteq> P[X - {x}]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. range (poly.coeff (poly_of_focus x p)) \\<subseteq> P[X - {x}]", "have \"range (poly.coeff (poly_of_focus x p)) \\<subseteq> range (lookup (focus {x} p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (poly.coeff (poly_of_focus x p))\n    \\<subseteq> range (lookup (focus {x} p))", "by (auto simp: poly_of_focus_def)"], ["proof (state)\nthis:\n  range (poly.coeff (poly_of_focus x p))\n  \\<subseteq> range (lookup (focus {x} p))\n\ngoal (1 subgoal):\n 1. range (poly.coeff (poly_of_focus x p)) \\<subseteq> P[X - {x}]", "also"], ["proof (state)\nthis:\n  range (poly.coeff (poly_of_focus x p))\n  \\<subseteq> range (lookup (focus {x} p))\n\ngoal (1 subgoal):\n 1. range (poly.coeff (poly_of_focus x p)) \\<subseteq> P[X - {x}]", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> P[X]", "have \"\\<dots> \\<subseteq> P[X - {x}]\""], ["proof (prove)\nusing this:\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. range (lookup (focus {x} p)) \\<subseteq> P[X - {x}]", "by (rule focus_coeffs_subset_Polys')"], ["proof (state)\nthis:\n  range (lookup (focus {x} p)) \\<subseteq> P[X - {x}]\n\ngoal (1 subgoal):\n 1. range (poly.coeff (poly_of_focus x p)) \\<subseteq> P[X - {x}]", "finally"], ["proof (chain)\npicking this:\n  range (poly.coeff (poly_of_focus x p)) \\<subseteq> P[X - {x}]", "show ?thesis"], ["proof (prove)\nusing this:\n  range (poly.coeff (poly_of_focus x p)) \\<subseteq> P[X - {x}]\n\ngoal (1 subgoal):\n 1. range (poly.coeff (poly_of_focus x p)) \\<subseteq> P[X - {x}]", "."], ["proof (state)\nthis:\n  range (poly.coeff (poly_of_focus x p)) \\<subseteq> P[X - {x}]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  shows poly_of_focus_zero [simp]: \"poly_of_focus x 0 = 0\"\n    and poly_of_focus_uminus [simp]: \"poly_of_focus x (- p) = - poly_of_focus x p\"\n    and poly_of_focus_plus: \"poly_of_focus x (p + q) = poly_of_focus x p + poly_of_focus x q\"\n    and poly_of_focus_minus: \"poly_of_focus x (p - q) = poly_of_focus x p - poly_of_focus x q\"\n    and poly_of_focus_one [simp]: \"poly_of_focus x 1 = 1\"\n    and poly_of_focus_sum: \"poly_of_focus x (sum f I) = (\\<Sum>i\\<in>I. poly_of_focus x (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_of_focus x 0 = 0 &&&\n     poly_of_focus x (- p) = - poly_of_focus x p &&&\n     poly_of_focus x (p + q) = poly_of_focus x p + poly_of_focus x q) &&&\n    poly_of_focus x (p - q) = poly_of_focus x p - poly_of_focus x q &&&\n    poly_of_focus x 1 = 1 &&&\n    poly_of_focus x (sum f I) = (\\<Sum>i\\<in>I. poly_of_focus x (f i))", "by (simp_all add: poly_of_focus_def keys_focus poly_of_pm_plus focus_plus poly_of_pm_minus focus_minus\n                    poly_of_pm_sum focus_sum)"], ["", "lemma poly_of_focus_eq_zero_iff [iff]: \"poly_of_focus x p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_of_focus x p = 0) = (p = 0)", "using focus_in_Polys[of \"{x}\" p]"], ["proof (prove)\nusing this:\n  focus {x} p \\<in> P[{x}]\n\ngoal (1 subgoal):\n 1. (poly_of_focus x p = 0) = (p = 0)", "by (auto simp: poly_of_focus_def poly_of_pm_eq_zero_iff Int_absorb2 dest: PolysD)"], ["", "lemma poly_of_focus_monomial:\n  \"poly_of_focus x (monomial c t) = Polynomial.monom (monomial c (except t {x})) (lookup t x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_focus x (monomial c t) =\n    Polynomial.monom (monomial c (except t {x})) (lookup t x)", "by (simp add: poly_of_focus_def focus_monomial poly_of_pm_monomial PPs_def keys_except lookup_except)"], ["", "lemma\n  shows poly_of_focus_times: \"poly_of_focus x (p * q) = poly_of_focus x p * poly_of_focus x q\"\n    and poly_of_focus_prod: \"poly_of_focus x (prod f I) =\n                                  (\\<Prod>i\\<in>I. poly_of_focus x (f i :: _ \\<Rightarrow>\\<^sub>0 _::comm_semiring_1))\"\n    and poly_of_focus_power: \"poly_of_focus x (p ^ m) = poly_of_focus x (p::_ \\<Rightarrow>\\<^sub>0 _::comm_semiring_1) ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_focus x (p * q) = poly_of_focus x p * poly_of_focus x q &&&\n    poly_of_focus x (prod f I) = (\\<Prod>i\\<in>I. poly_of_focus x (f i)) &&&\n    poly_of_focus x (p ^ m) = poly_of_focus x p ^ m", "by (simp_all add: poly_of_focus_def poly_of_pm_times focus_times poly_of_pm_prod focus_prod)"], ["", "lemma flat_pm_of_poly_of_focus [simp]: \"flat_pm_of_poly x (poly_of_focus x p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_pm_of_poly x (poly_of_focus x p) = p", "by (simp add: flat_pm_of_poly_def poly_of_focus_def pm_of_poly_of_pm focus_in_Polys)"], ["", "lemma poly_of_focus_flat_pm_of_poly:\n  assumes \"range (poly.coeff p) \\<subseteq> P[- {x}]\"\n  shows \"poly_of_focus x (flat_pm_of_poly x p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_focus x (flat_pm_of_poly x p) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_of_focus x (flat_pm_of_poly x p) = p", "from assms"], ["proof (chain)\npicking this:\n  range (poly.coeff p) \\<subseteq> P[- {x}]", "have \"lookup (pm_of_poly x p) ` keys (pm_of_poly x p) \\<subseteq> P[- {x}]\""], ["proof (prove)\nusing this:\n  range (poly.coeff p) \\<subseteq> P[- {x}]\n\ngoal (1 subgoal):\n 1. lookup (pm_of_poly x p) ` keys (pm_of_poly x p) \\<subseteq> P[- {x}]", "by (simp add: keys_pm_of_poly image_image) blast"], ["proof (state)\nthis:\n  lookup (pm_of_poly x p) ` keys (pm_of_poly x p) \\<subseteq> P[- {x}]\n\ngoal (1 subgoal):\n 1. poly_of_focus x (flat_pm_of_poly x p) = p", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup (pm_of_poly x p) ` keys (pm_of_poly x p) \\<subseteq> P[- {x}]\n\ngoal (1 subgoal):\n 1. poly_of_focus x (flat_pm_of_poly x p) = p", "by (simp add: flat_pm_of_poly_def poly_of_focus_def focus_flatten pm_of_poly_in_Polys)"], ["proof (state)\nthis:\n  poly_of_focus x (flat_pm_of_poly x p) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flat_pm_of_poly_eq_zeroD:\n  assumes \"flat_pm_of_poly x p = 0\" and \"range (poly.coeff p) \\<subseteq> P[- {x}]\"\n  shows \"p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = 0", "from assms(2)"], ["proof (chain)\npicking this:\n  range (poly.coeff p) \\<subseteq> P[- {x}]", "have \"p = poly_of_focus x (flat_pm_of_poly x p)\""], ["proof (prove)\nusing this:\n  range (poly.coeff p) \\<subseteq> P[- {x}]\n\ngoal (1 subgoal):\n 1. p = poly_of_focus x (flat_pm_of_poly x p)", "by (simp only: poly_of_focus_flat_pm_of_poly)"], ["proof (state)\nthis:\n  p = poly_of_focus x (flat_pm_of_poly x p)\n\ngoal (1 subgoal):\n 1. p = 0", "also"], ["proof (state)\nthis:\n  p = poly_of_focus x (flat_pm_of_poly x p)\n\ngoal (1 subgoal):\n 1. p = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_focus x (flat_pm_of_poly x p) = 0", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  poly_of_focus x (flat_pm_of_poly x p) = 0\n\ngoal (1 subgoal):\n 1. p = 0", "finally"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = 0", "."], ["proof (state)\nthis:\n  p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_poly_of_focus: \"poly (poly_of_focus x p) a = poly_eval (\\<lambda>_. a) (focus {x} p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_of_focus x p) a = poly_eval (\\<lambda>_. a) (focus {x} p)", "by (simp add: poly_of_focus_def poly_eq_poly_eval' focus_in_Polys)"], ["", "corollary poly_poly_of_focus_monomial:\n  \"poly (poly_of_focus x p) (monomial 1 (Poly_Mapping.single x 1)) = (p::_ \\<Rightarrow>\\<^sub>0 _::comm_semiring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_of_focus x p) (monomial (1::'b) (monomial 1 x)) = p", "unfolding poly_poly_of_focus poly_eval_focus"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_subst\n     (\\<lambda>xa.\n         if xa \\<in> {x} then monomial (1::'b) (monomial 1 x)\n         else monomial (1::'b) (monomial 1 xa))\n     p =\n    p", "by (rule poly_subst_id) simp"], ["", "end"], ["", "(* theory *)"]]}