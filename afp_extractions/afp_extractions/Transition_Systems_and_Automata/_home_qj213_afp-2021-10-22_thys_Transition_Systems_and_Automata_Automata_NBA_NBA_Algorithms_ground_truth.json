{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Algorithms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma (in igb_fr_graph) acc_run_lasso_prpl: \"Ex is_acc_run \\<Longrightarrow> Ex is_lasso_prpl\"", "lemma (in igb_fr_graph)  lasso_prpl_acc_run_iff: \"Ex is_lasso_prpl \\<longleftrightarrow> Ex is_acc_run\"", "lemma [autoref_rel_intf]: \"REL_INTF igbg_impl_rel_ext i_igbg\"", "lemmas [autoref_op_pat] = op_language_empty_def[symmetric]", "lemma nba_g_ahs: \"nba_g A = \\<lparr> g_V = UNIV, g_E = E_of_succ (\\<lambda> p. CAST\n      ((\\<Union> a \\<in> alphabet A. transition A a p ::: \\<langle>S\\<rangle> list_set_rel) ::: \\<langle>S\\<rangle> ahs_rel bhc)),\n      g_V0 = initial A \\<rparr>\"", "lemma nbai_gi_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      shows \"(NBA_Algorithms.nbai_gi seq bhc hms, nba_g) \\<in>\n        \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>unit_rel, S\\<rangle> g_impl_rel_ext\"", "lemma nba_nodes_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel\"\n      shows \"(NBA_Algorithms.nba_nodes seq bhc hms Ai,\n        (OP nodes ::: \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>S\\<rangle> ahs_rel bhc) $ A) \\<in> \\<langle>S\\<rangle> ahs_rel bhc\"", "lemma nba_igbg_ahs: \"nba_igbg A = \\<lparr> g_V = UNIV, g_E = E_of_succ (\\<lambda> p. CAST\n      ((\\<Union> a \\<in> alphabet A. transition A a p ::: \\<langle>S\\<rangle> list_set_rel) ::: \\<langle>S\\<rangle> ahs_rel bhc)), g_V0 = initial A,\n      igbg_num_acc = 1, igbg_acc = \\<lambda> p. if accepting A p then {0} else {} \\<rparr>\"", "lemma nbai_igbgi_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      shows \"(NBA_Algorithms.nbai_igbgi seq bhc hms, nba_igbg) \\<in>\n        \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> igbg_impl_rel_ext unit_rel S\"", "lemma nba_language_empty_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel\"\n      shows \"(NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n        (OP op_language_empty ::: \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> bool_rel) $ A) \\<in> bool_rel\""], "translations": [["", "lemma (in igb_fr_graph) acc_run_lasso_prpl: \"Ex is_acc_run \\<Longrightarrow> Ex is_lasso_prpl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex is_acc_run \\<Longrightarrow> Ex is_lasso_prpl", "using accepted_lasso is_lasso_prpl_of_lasso"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite local.reachable; is_acc_run ?r\\<rbrakk>\n  \\<Longrightarrow> Ex is_lasso\n  is_lasso_prpl (prpl_of_lasso ?L) = is_lasso ?L\n\ngoal (1 subgoal):\n 1. Ex is_acc_run \\<Longrightarrow> Ex is_lasso_prpl", "by blast"], ["", "lemma (in igb_fr_graph)  lasso_prpl_acc_run_iff: \"Ex is_lasso_prpl \\<longleftrightarrow> Ex is_acc_run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex is_lasso_prpl = Ex is_acc_run", "using acc_run_lasso_prpl lasso_prpl_acc_run"], ["proof (prove)\nusing this:\n  Ex is_acc_run \\<Longrightarrow> Ex is_lasso_prpl\n  is_lasso_prpl (?pr, ?pl) \\<Longrightarrow>\n  is_acc_run (?pr \\<frown> ?pl\\<^sup>\\<omega>)\n\ngoal (1 subgoal):\n 1. Ex is_lasso_prpl = Ex is_acc_run", "by auto"], ["", "lemma [autoref_rel_intf]: \"REL_INTF igbg_impl_rel_ext i_igbg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_INTF igbg_impl_rel_ext i_igbg", "by (rule REL_INTFI)"], ["", "subsection \\<open>Operations\\<close>"], ["", "definition op_language_empty where [simp]: \"op_language_empty A \\<equiv> language A = {}\""], ["", "lemmas [autoref_op_pat] = op_language_empty_def[symmetric]"], ["", "subsection \\<open>Implementations\\<close>"], ["", "context\n  begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "by this"], ["", "lemma nba_g_ahs: \"nba_g A = \\<lparr> g_V = UNIV, g_E = E_of_succ (\\<lambda> p. CAST\n      ((\\<Union> a \\<in> alphabet A. transition A a p ::: \\<langle>S\\<rangle> list_set_rel) ::: \\<langle>S\\<rangle> ahs_rel bhc)),\n      g_V0 = initial A \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nba_g A =\n    \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ\n          (\\<lambda>p.\n              CAST\n               ((\\<Union>a\\<in>alphabet A.\n                    transition A a p :::\n                    \\<langle>S\\<rangle>list_set_rel) :::\n                \\<langle>S\\<rangle>ahs_rel bhc)),\n       g_V0 = initial A\\<rparr>", "unfolding nba_g_def nba.successors_alt_def CAST_def id_apply autoref_tag_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ (\\<lambda>p. \\<Union>a\\<in>alphabet A. transition A a p),\n       g_V0 = initial A\\<rparr> =\n    \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ (\\<lambda>p. \\<Union>a\\<in>alphabet A. transition A a p),\n       g_V0 = initial A\\<rparr>", "by rule"], ["", "schematic_goal nbai_gi:\n      notes [autoref_ga_rules] = map2set_to_list\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhc\"\n      assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n      assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n      assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel\"\n      shows \"(?f :: ?'a, RETURN (nba_g A)) \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, RETURN (nba_g A)) \\<in> ?A", "unfolding nba_g_ahs[where S = S and bhc = bhc]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     RETURN\n      \\<lparr>g_V = UNIV,\n         g_E =\n           E_of_succ\n            (\\<lambda>p.\n                CAST\n                 ((\\<Union>a\\<in>alphabet A.\n                      transition A a p :::\n                      \\<langle>S\\<rangle>list_set_rel) :::\n                  \\<langle>S\\<rangle>ahs_rel bhc)),\n         g_V0 = initial A\\<rparr>)\n    \\<in> ?A", "by (autoref_monadic (plain))"], ["", "concrete_definition nbai_gi uses nbai_gi"], ["", "lemma nbai_gi_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      shows \"(NBA_Algorithms.nbai_gi seq bhc hms, nba_g) \\<in>\n        \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>unit_rel, S\\<rangle> g_impl_rel_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nbai_gi seq bhc hms, nba_g)\n    \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n          \\<langle>unit_rel, S\\<rangle>g_impl_rel_ext", "using nbai_gi.refine[THEN RETURN_nres_relD] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_bounded_hashcode ?S1 ?seq1 ?bhc1;\n   is_valid_def_hm_size TYPE(?'a1) ?hms1;\n   (?seq1, (=)) \\<in> ?S1 \\<rightarrow> ?S1 \\<rightarrow> bool_rel;\n   (?Ai1, ?A1) \\<in> \\<langle>?L1, ?S1\\<rangle>nbai_nba_rel\\<rbrakk>\n  \\<Longrightarrow> (NBA_Algorithms.nbai_gi ?seq1 ?bhc1 ?hms1 ?Ai1,\n                     nba_g ?A1)\n                    \\<in> \\<langle>unit_rel, ?S1\\<rangle>g_impl_rel_ext\n  SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\n  GEN_OP seq (=) (S \\<rightarrow> S \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nbai_gi seq bhc hms, nba_g)\n    \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n          \\<langle>unit_rel, S\\<rangle>g_impl_rel_ext", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_bounded_hashcode ?S1 ?seq1 ?bhc1;\n   is_valid_def_hm_size TYPE(?'a1) ?hms1;\n   (?seq1, (=)) \\<in> ?S1 \\<rightarrow> ?S1 \\<rightarrow> bool_rel;\n   (?Ai1, ?A1) \\<in> \\<langle>?L1, ?S1\\<rangle>nbai_nba_rel\\<rbrakk>\n  \\<Longrightarrow> (NBA_Algorithms.nbai_gi ?seq1 ?bhc1 ?hms1 ?Ai1,\n                     nba_g ?A1)\n                    \\<in> \\<langle>unit_rel, ?S1\\<rangle>g_impl_rel_ext\n  is_bounded_hashcode S seq bhc\n  is_valid_def_hm_size TYPE('statei) hms\n  (seq, (=)) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nbai_gi seq bhc hms, nba_g)\n    \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n          \\<langle>unit_rel, S\\<rangle>g_impl_rel_ext", "by blast"], ["", "schematic_goal nba_nodes:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes [simp]: \"finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))\"\n      assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhc\"\n      assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n      assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n      assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel\"\n      shows \"(?f :: ?'a, op_reachable (nba_g A)) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, op_reachable (nba_g A)) \\<in> ?R", "by autoref"], ["", "concrete_definition nba_nodes uses nba_nodes"], ["", "lemma nba_nodes_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel\"\n      shows \"(NBA_Algorithms.nba_nodes seq bhc hms Ai,\n        (OP nodes ::: \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>S\\<rangle> ahs_rel bhc) $ A) \\<in> \\<langle>S\\<rangle> ahs_rel bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_nodes seq bhc hms Ai,\n     (OP nodes :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_nodes seq bhc hms Ai,\n     (OP nodes :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "have 1: \"nodes A = op_reachable (nba_g A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes A = op_reachable (nba_g A)", "by (auto simp: nba_g_V0 nba_g_E_rtrancl)"], ["proof (state)\nthis:\n  nodes A = op_reachable (nba_g A)\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_nodes seq bhc hms Ai,\n     (OP nodes :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "have 2: \"finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))", "using assms(1)"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (finite (nodes A))\n\ngoal (1 subgoal):\n 1. finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))", "unfolding 1"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (finite (op_reachable (nba_g A)))\n\ngoal (1 subgoal):\n 1. finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))", "by simp"], ["proof (state)\nthis:\n  finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_nodes seq bhc hms Ai,\n     (OP nodes :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_nodes seq bhc hms Ai,\n     (OP nodes :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "using nba_nodes.refine assms 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ((g_E (nba_g ?A))\\<^sup>* `` g_V0 (nba_g ?A));\n   is_bounded_hashcode ?S ?seq ?bhc; is_valid_def_hm_size TYPE(?'c) ?hms;\n   (?seq, (=)) \\<in> ?S \\<rightarrow> ?S \\<rightarrow> bool_rel;\n   (?Ai, ?A) \\<in> \\<langle>?L, ?S\\<rangle>nbai_nba_rel\\<rbrakk>\n  \\<Longrightarrow> (NBA_Algorithms.nba_nodes ?seq ?bhc ?hms ?Ai,\n                     op_reachable (nba_g ?A))\n                    \\<in> \\<langle>?S\\<rangle>ahs_rel ?bhc\n  SIDE_PRECOND (finite (nodes A))\n  SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\n  GEN_OP seq (=) (S \\<rightarrow> S \\<rightarrow> bool_rel)\n  (Ai, A) \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel\n  finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_nodes seq bhc hms Ai,\n     (OP nodes :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "unfolding autoref_tag_defs 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ((g_E (nba_g ?A))\\<^sup>* `` g_V0 (nba_g ?A));\n   is_bounded_hashcode ?S ?seq ?bhc; is_valid_def_hm_size TYPE(?'c) ?hms;\n   (?seq, (=)) \\<in> ?S \\<rightarrow> ?S \\<rightarrow> bool_rel;\n   (?Ai, ?A) \\<in> \\<langle>?L, ?S\\<rangle>nbai_nba_rel\\<rbrakk>\n  \\<Longrightarrow> (NBA_Algorithms.nba_nodes ?seq ?bhc ?hms ?Ai,\n                     op_reachable (nba_g ?A))\n                    \\<in> \\<langle>?S\\<rangle>ahs_rel ?bhc\n  finite (op_reachable (nba_g A))\n  is_bounded_hashcode S seq bhc\n  is_valid_def_hm_size TYPE('statei) hms\n  (seq, (=)) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\n  (Ai, A) \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel\n  finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_nodes seq bhc hms Ai, op_reachable (nba_g A))\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "by blast"], ["proof (state)\nthis:\n  (NBA_Algorithms.nba_nodes seq bhc hms Ai,\n   (OP nodes :::\n    \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n    \\<langle>S\\<rangle>ahs_rel bhc) $\n   A)\n  \\<in> \\<langle>S\\<rangle>ahs_rel bhc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nba_igbg_ahs: \"nba_igbg A = \\<lparr> g_V = UNIV, g_E = E_of_succ (\\<lambda> p. CAST\n      ((\\<Union> a \\<in> alphabet A. transition A a p ::: \\<langle>S\\<rangle> list_set_rel) ::: \\<langle>S\\<rangle> ahs_rel bhc)), g_V0 = initial A,\n      igbg_num_acc = 1, igbg_acc = \\<lambda> p. if accepting A p then {0} else {} \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nba_igbg A =\n    \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ\n          (\\<lambda>p.\n              CAST\n               ((\\<Union>a\\<in>alphabet A.\n                    transition A a p :::\n                    \\<langle>S\\<rangle>list_set_rel) :::\n                \\<langle>S\\<rangle>ahs_rel bhc)),\n       g_V0 = initial A, igbg_num_acc = 1,\n       igbg_acc = \\<lambda>p. if accepting A p then {0} else {}\\<rparr>", "unfolding nba_g_def nba_igbg_def nba.successors_alt_def CAST_def id_apply autoref_tag_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_rec.extend\n     \\<lparr>g_V = UNIV,\n        g_E =\n          E_of_succ\n           (\\<lambda>p. \\<Union>a\\<in>alphabet A. transition A a p),\n        g_V0 = initial A\\<rparr>\n     \\<lparr>igbg_num_acc = 1,\n        igbg_acc = \\<lambda>p. if accepting A p then {0} else {}\\<rparr> =\n    \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ (\\<lambda>p. \\<Union>a\\<in>alphabet A. transition A a p),\n       g_V0 = initial A, igbg_num_acc = 1,\n       igbg_acc = \\<lambda>p. if accepting A p then {0} else {}\\<rparr>", "unfolding graph_rec.defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>g_V =\n              g_V \\<lparr>g_V = UNIV,\n                     g_E =\n                       E_of_succ\n                        (\\<lambda>p.\n                            \\<Union>a\\<in>alphabet A. transition A a p),\n                     g_V0 = initial A\\<rparr>,\n       g_E =\n         g_E \\<lparr>g_V = UNIV,\n                g_E =\n                  E_of_succ\n                   (\\<lambda>p. \\<Union>a\\<in>alphabet A. transition A a p),\n                g_V0 = initial A\\<rparr>,\n       g_V0 =\n         g_V0\n          \\<lparr>g_V = UNIV,\n             g_E =\n               E_of_succ\n                (\\<lambda>p. \\<Union>a\\<in>alphabet A. transition A a p),\n             g_V0 = initial A\\<rparr>,\n       igbg_num_acc = 1,\n       igbg_acc = \\<lambda>p. if accepting A p then {0} else {}\\<rparr> =\n    \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ (\\<lambda>p. \\<Union>a\\<in>alphabet A. transition A a p),\n       g_V0 = initial A, igbg_num_acc = 1,\n       igbg_acc = \\<lambda>p. if accepting A p then {0} else {}\\<rparr>", "by simp"], ["", "schematic_goal nbai_igbgi:\n      notes [autoref_ga_rules] = map2set_to_list\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhc\"\n      assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n      assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n      assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel\"\n      shows \"(?f :: ?'a, RETURN (nba_igbg A)) \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, RETURN (nba_igbg A)) \\<in> ?A", "unfolding nba_igbg_ahs[where S = S and bhc = bhc]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     RETURN\n      \\<lparr>g_V = UNIV,\n         g_E =\n           E_of_succ\n            (\\<lambda>p.\n                CAST\n                 ((\\<Union>a\\<in>alphabet A.\n                      transition A a p :::\n                      \\<langle>S\\<rangle>list_set_rel) :::\n                  \\<langle>S\\<rangle>ahs_rel bhc)),\n         g_V0 = initial A, igbg_num_acc = 1,\n         igbg_acc = \\<lambda>p. if accepting A p then {0} else {}\\<rparr>)\n    \\<in> ?A", "by (autoref_monadic (plain))"], ["", "concrete_definition nbai_igbgi uses nbai_igbgi"], ["", "lemma nbai_igbgi_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      shows \"(NBA_Algorithms.nbai_igbgi seq bhc hms, nba_igbg) \\<in>\n        \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> igbg_impl_rel_ext unit_rel S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nbai_igbgi seq bhc hms, nba_igbg)\n    \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n          igbg_impl_rel_ext unit_rel S", "using nbai_igbgi.refine[THEN RETURN_nres_relD] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_bounded_hashcode ?S1 ?seq1 ?bhc1;\n   is_valid_def_hm_size TYPE(?'a1) ?hms1;\n   (?seq1, (=)) \\<in> ?S1 \\<rightarrow> ?S1 \\<rightarrow> bool_rel;\n   (?Ai1, ?A1) \\<in> \\<langle>?L1, ?S1\\<rangle>nbai_nba_rel\\<rbrakk>\n  \\<Longrightarrow> (NBA_Algorithms.nbai_igbgi ?seq1 ?bhc1 ?hms1 ?Ai1,\n                     nba_igbg ?A1)\n                    \\<in> igbg_impl_rel_ext unit_rel ?S1\n  SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\n  GEN_OP seq (=) (S \\<rightarrow> S \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nbai_igbgi seq bhc hms, nba_igbg)\n    \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n          igbg_impl_rel_ext unit_rel S", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_bounded_hashcode ?S1 ?seq1 ?bhc1;\n   is_valid_def_hm_size TYPE(?'a1) ?hms1;\n   (?seq1, (=)) \\<in> ?S1 \\<rightarrow> ?S1 \\<rightarrow> bool_rel;\n   (?Ai1, ?A1) \\<in> \\<langle>?L1, ?S1\\<rangle>nbai_nba_rel\\<rbrakk>\n  \\<Longrightarrow> (NBA_Algorithms.nbai_igbgi ?seq1 ?bhc1 ?hms1 ?Ai1,\n                     nba_igbg ?A1)\n                    \\<in> igbg_impl_rel_ext unit_rel ?S1\n  is_bounded_hashcode S seq bhc\n  is_valid_def_hm_size TYPE('statei) hms\n  (seq, (=)) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nbai_igbgi seq bhc hms, nba_igbg)\n    \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n          igbg_impl_rel_ext unit_rel S", "by blast"], ["", "schematic_goal nba_language_empty:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes [simp]: \"igb_fr_graph (nba_igbg A)\"\n      assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhs\"\n      assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n      assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n      assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel\"\n      shows \"(?f :: ?'a, do { r \\<leftarrow> op_find_lasso_spec (nba_igbg A); RETURN (r = None)}) \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     op_find_lasso_spec (nba_igbg A) \\<bind>\n     (\\<lambda>r. RETURN (r = None)))\n    \\<in> ?A", "by (autoref_monadic (plain))"], ["", "concrete_definition nba_language_empty uses nba_language_empty"], ["", "lemma nba_language_empty_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel\"\n      shows \"(NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n        (OP op_language_empty ::: \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> bool_rel) $ A) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have 1: \"nodes A = op_reachable (nba_g A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes A = op_reachable (nba_g A)", "by (auto simp: nba_g_V0 nba_g_E_rtrancl)"], ["proof (state)\nthis:\n  nodes A = op_reachable (nba_g A)\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have 2: \"finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))", "using assms(1)"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (finite (nodes A))\n\ngoal (1 subgoal):\n 1. finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))", "unfolding 1"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (finite (op_reachable (nba_g A)))\n\ngoal (1 subgoal):\n 1. finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))", "by simp"], ["proof (state)\nthis:\n  finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "interpret igb_fr_graph \"nba_igbg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_fr_graph (nba_igbg A)", "using 2"], ["proof (prove)\nusing this:\n  finite ((g_E (nba_g A))\\<^sup>* `` g_V0 (nba_g A))\n\ngoal (1 subgoal):\n 1. igb_fr_graph (nba_igbg A)", "unfolding nba_igbg_def nba_g_def graph_rec.defs"], ["proof (prove)\nusing this:\n  finite\n   ((g_E \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n            g_V0 = initial A\\<rparr>)\\<^sup>* ``\n    g_V0\n     \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n        g_V0 = initial A\\<rparr>)\n\ngoal (1 subgoal):\n 1. igb_fr_graph\n     \\<lparr>g_V =\n               g_V \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n                      g_V0 = initial A\\<rparr>,\n        g_E =\n          g_E \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n                 g_V0 = initial A\\<rparr>,\n        g_V0 =\n          g_V0\n           \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n              g_V0 = initial A\\<rparr>,\n        igbg_num_acc = 1,\n        igbg_acc = \\<lambda>p. if accepting A p then {0} else {}\\<rparr>", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have \"(RETURN (NBA_Algorithms.nba_language_empty seq bhc hms Ai),\n        do { r \\<leftarrow> find_lasso_spec; RETURN (r = None) }) \\<in> \\<langle>bool_rel\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (NBA_Algorithms.nba_language_empty seq bhc hms Ai),\n     find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "using nba_language_empty.refine assms igb_fr_graph_axioms"], ["proof (prove)\nusing this:\n  \\<lbrakk>igb_fr_graph (nba_igbg ?A); is_bounded_hashcode ?S ?seq ?bhs;\n   is_valid_def_hm_size TYPE(?'c) ?hms;\n   (?seq, (=)) \\<in> ?S \\<rightarrow> ?S \\<rightarrow> bool_rel;\n   (?Ai, ?A) \\<in> \\<langle>?L, ?S\\<rangle>nbai_nba_rel\\<rbrakk>\n  \\<Longrightarrow> (RETURN\n                      (NBA_Algorithms.nba_language_empty ?seq ?bhs ?hms\n                        ?Ai),\n                     op_find_lasso_spec (nba_igbg ?A) \\<bind>\n                     (\\<lambda>r. RETURN (r = None)))\n                    \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n  SIDE_PRECOND (finite (nodes A))\n  SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\n  GEN_OP seq (=) (S \\<rightarrow> S \\<rightarrow> bool_rel)\n  (Ai, A) \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel\n  igb_fr_graph (nba_igbg A)\n\ngoal (1 subgoal):\n 1. (RETURN (NBA_Algorithms.nba_language_empty seq bhc hms Ai),\n     find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "by simp"], ["proof (state)\nthis:\n  (RETURN (NBA_Algorithms.nba_language_empty seq bhc hms Ai),\n   find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "also"], ["proof (state)\nthis:\n  (RETURN (NBA_Algorithms.nba_language_empty seq bhc hms Ai),\n   find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have \"(do { r \\<leftarrow> find_lasso_spec; RETURN (r = None) },\n        RETURN (\\<not> Ex is_lasso_prpl)) \\<in> \\<langle>bool_rel\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)),\n     RETURN (\\<not> Ex is_lasso_prpl))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "unfolding find_lasso_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPEC\n      (\\<lambda>r.\n          case r of\n          None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n          | Some x \\<Rightarrow> is_lasso_prpl x) \\<bind>\n     (\\<lambda>r. RETURN (r = None)),\n     RETURN (\\<not> Ex is_lasso_prpl))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "by (refine_vcg) (auto split: option.splits)"], ["proof (state)\nthis:\n  (find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)),\n   RETURN (\\<not> Ex is_lasso_prpl))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "finally"], ["proof (chain)\npicking this:\n  (RETURN (NBA_Algorithms.nba_language_empty seq bhc hms Ai),\n   RETURN (\\<not> Ex is_lasso_prpl))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel O\n        \\<langle>bool_rel\\<rangle>nres_rel", "have \"NBA_Algorithms.nba_language_empty seq bhc hms Ai \\<longleftrightarrow> \\<not> Ex is_lasso_prpl\""], ["proof (prove)\nusing this:\n  (RETURN (NBA_Algorithms.nba_language_empty seq bhc hms Ai),\n   RETURN (\\<not> Ex is_lasso_prpl))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel O\n        \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. NBA_Algorithms.nba_language_empty seq bhc hms Ai =\n    (\\<not> Ex is_lasso_prpl)", "unfolding nres_rel_comp"], ["proof (prove)\nusing this:\n  (RETURN (NBA_Algorithms.nba_language_empty seq bhc hms Ai),\n   RETURN (\\<not> Ex is_lasso_prpl))\n  \\<in> \\<langle>bool_rel O bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. NBA_Algorithms.nba_language_empty seq bhc hms Ai =\n    (\\<not> Ex is_lasso_prpl)", "using RETURN_nres_relD"], ["proof (prove)\nusing this:\n  (RETURN (NBA_Algorithms.nba_language_empty seq bhc hms Ai),\n   RETURN (\\<not> Ex is_lasso_prpl))\n  \\<in> \\<langle>bool_rel O bool_rel\\<rangle>nres_rel\n  (RETURN ?x, RETURN ?y)\n  \\<in> \\<langle>?A\\<rangle>nres_rel \\<Longrightarrow>\n  (?x, ?y) \\<in> ?A\n\ngoal (1 subgoal):\n 1. NBA_Algorithms.nba_language_empty seq bhc hms Ai =\n    (\\<not> Ex is_lasso_prpl)", "by force"], ["proof (state)\nthis:\n  NBA_Algorithms.nba_language_empty seq bhc hms Ai =\n  (\\<not> Ex is_lasso_prpl)\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "also"], ["proof (state)\nthis:\n  NBA_Algorithms.nba_language_empty seq bhc hms Ai =\n  (\\<not> Ex is_lasso_prpl)\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have \"\\<dots> \\<longleftrightarrow> \\<not> Ex is_acc_run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> Ex is_lasso_prpl) = (\\<not> Ex is_acc_run)", "using lasso_prpl_acc_run_iff"], ["proof (prove)\nusing this:\n  Ex is_lasso_prpl = Ex is_acc_run\n\ngoal (1 subgoal):\n 1. (\\<not> Ex is_lasso_prpl) = (\\<not> Ex is_acc_run)", "by auto"], ["proof (state)\nthis:\n  (\\<not> Ex is_lasso_prpl) = (\\<not> Ex is_acc_run)\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "also"], ["proof (state)\nthis:\n  (\\<not> Ex is_lasso_prpl) = (\\<not> Ex is_acc_run)\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have \"\\<dots> \\<longleftrightarrow> language A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> Ex is_acc_run) = (language A = {})", "using acc_run_language is_igb_graph"], ["proof (prove)\nusing this:\n  igb_graph (nba_igbg ?A) \\<Longrightarrow>\n  Ex (igb_graph.is_acc_run (nba_igbg ?A)) = (language ?A \\<noteq> {})\n  igb_graph (nba_igbg A)\n\ngoal (1 subgoal):\n 1. (\\<not> Ex is_acc_run) = (language A = {})", "by auto"], ["proof (state)\nthis:\n  (\\<not> Ex is_acc_run) = (language A = {})\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "finally"], ["proof (chain)\npicking this:\n  NBA_Algorithms.nba_language_empty seq bhc hms Ai = (language A = {})", "show ?thesis"], ["proof (prove)\nusing this:\n  NBA_Algorithms.nba_language_empty seq bhc hms Ai = (language A = {})\n\ngoal (1 subgoal):\n 1. (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n     (OP op_language_empty :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "by simp"], ["proof (state)\nthis:\n  (NBA_Algorithms.nba_language_empty seq bhc hms Ai,\n   (OP op_language_empty :::\n    \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> bool_rel) $\n   A)\n  \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}