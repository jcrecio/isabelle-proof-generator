{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Automata/Nondeterministic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma states_alt_def: \"states r p = map snd r\"", "lemma trace_alt_def: \"trace r p = smap snd r\"", "lemma successors_alt_def: \"successors A p = (\\<Union> a \\<in> alphabet A. transition A a p)\"", "lemma reachable_transition[intro]:\n      assumes \"a \\<in> alphabet A\" \"q \\<in> reachable A p\" \"r \\<in> transition A a q\"\n      shows \"r \\<in> reachable A p\"", "lemma nodes_transition[intro]:\n      assumes \"a \\<in> alphabet A\" \"p \\<in> nodes A\" \"q \\<in> transition A a p\"\n      shows \"q \\<in> nodes A\"", "lemma path_alphabet:\n      assumes \"length r = length w\" \"path A (w || r) p\"\n      shows \"w \\<in> lists (alphabet A)\"", "lemma run_alphabet:\n      assumes \"run A (w ||| r) p\"\n      shows \"w \\<in> streams (alphabet A)\"", "lemma restrict_simps[simp]:\n      \"alphabet (restrict A) = alphabet A\"\n      \"initial (restrict A) = initial A\"\n      \"transition (restrict A) a p = (if a \\<in> alphabet A then transition A a p else {})\"\n      \"condition (restrict A) = condition A\"", "lemma restrict_path[simp]: \"path (restrict A) = path A\"", "lemma restrict_run[simp]: \"run (restrict A) = run A\"", "lemma language[intro]:\n      assumes \"length r = length w\" \"p \\<in> initial A\" \"path A (w || r) p\" \"test (condition A) w r p\"\n      shows \"w \\<in> language A\"", "lemma language_elim[elim]:\n      assumes \"w \\<in> language A\"\n      obtains r p\n      where \"length r = length w\" \"p \\<in> initial A\" \"path A (w || r) p\" \"test (condition A) w r p\"", "lemma language_alphabet: \"language A \\<subseteq> lists (alphabet A)\"", "lemma restrict_language[simp]: \"language (restrict A) = language A\"", "lemma language[intro]:\n      assumes \"p \\<in> initial A\" \"run A (w ||| r) p\" \"test (condition A) w r p\"\n      shows \"w \\<in> language A\"", "lemma language_elim[elim]:\n      assumes \"w \\<in> language A\"\n      obtains r p\n      where \"p \\<in> initial A\" \"run A (w ||| r) p\" \"test (condition A) w r p\"", "lemma language_alphabet: \"language A \\<subseteq> streams (alphabet A)\"", "lemma restrict_language[simp]: \"language (restrict A) = language A\"", "lemma degeneralize_simps[simp]:\n      \"alphabet\\<^sub>2 (degeneralize A) = alphabet\\<^sub>1 A\"\n      \"initial\\<^sub>2 (degeneralize A) = initial\\<^sub>1 A \\<times> {0}\"\n      \"transition\\<^sub>2 (degeneralize A) a (p, k) =\n        {(q, count (condition\\<^sub>1 A) (item (p, a, q)) k) |q. q \\<in> transition\\<^sub>1 A a p}\"\n      \"condition\\<^sub>2 (degeneralize A) = degen (condition\\<^sub>1 A) \\<circ> translate\"", "lemma run_degeneralize:\n      assumes \"a.run A (w ||| r) p\"\n      shows \"b.run (degeneralize A) (w ||| r ||| sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r) k) (p, k)\"", "lemma degeneralize_run:\n      assumes \"b.run (degeneralize A) (w ||| rs) pk\"\n      obtains r s p k\n      where \"rs = r ||| s\" \"pk = (p, k)\" \"a.run A (w ||| r) p\" \"s = sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r) k\"", "lemma degeneralize_nodes:\n      \"b.nodes (degeneralize A) \\<subseteq> a.nodes A \\<times> insert 0 {0 ..< length (condition\\<^sub>1 A)}\"", "lemma nodes_degeneralize: \"a.nodes A \\<subseteq> fst ` b.nodes (degeneralize A)\"", "lemma degeneralize_nodes_finite[iff]: \"finite (b.nodes (degeneralize A)) \\<longleftrightarrow> finite (a.nodes A)\"", "lemma degeneralize_language[simp]: \"b.language (degeneralize A) = a.language A\"", "lemma product_simps[simp]:\n      \"alphabet\\<^sub>3 (product A B) = alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B\"\n      \"initial\\<^sub>3 (product A B) = initial\\<^sub>1 A \\<times> initial\\<^sub>2 B\"\n      \"transition\\<^sub>3 (product A B) a (p, q) = transition\\<^sub>1 A a p \\<times> transition\\<^sub>2 B a q\"\n      \"condition\\<^sub>3 (product A B) = condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)\"", "lemma product_target[simp]:\n      assumes \"length w = length r\" \"length r = length s\"\n      shows \"c.target (w || r || s) (p, q) = (a.target (w || r) p, b.target (w || s) q)\"", "lemma product_path[iff]:\n      assumes \"length w = length r\" \"length r = length s\"\n      shows \"c.path (product A B) (w || r || s) (p, q) \\<longleftrightarrow>\n        a.path A (w || r) p \\<and> b.path B (w || s) q\"", "lemma product_run[iff]: \"c.run (product A B) (w ||| r ||| s) (p, q) \\<longleftrightarrow>\n      a.run A (w ||| r) p \\<and> b.run B (w ||| s) q\"", "lemma product_nodes: \"c.nodes (product A B) \\<subseteq> a.nodes A \\<times> b.nodes B\"", "lemma product_nodes_finite[intro]:\n      assumes \"finite (a.nodes A)\" \"finite (b.nodes B)\"\n      shows \"finite (c.nodes (product A B))\"", "lemma product_language[simp]: \"c.language (product A B) = a.language A \\<inter> b.language B\"", "lemma product_language[simp]: \"c.language (product A B) = a.language A \\<inter> b.language B\"", "lemma sum_simps[simp]:\n      \"alphabet\\<^sub>3 (sum A B) = alphabet\\<^sub>1 A \\<union> alphabet\\<^sub>2 B\"\n      \"initial\\<^sub>3 (sum A B) = initial\\<^sub>1 A <+> initial\\<^sub>2 B\"\n      \"transition\\<^sub>3 (sum A B) a (Inl p) = Inl ` transition\\<^sub>1 A a p\"\n      \"transition\\<^sub>3 (sum A B) a (Inr q) = Inr ` transition\\<^sub>2 B a q\"\n      \"condition\\<^sub>3 (sum A B) = condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)\"", "lemma path_sum_a:\n      assumes \"length r = length w\" \"a.path A (w || r) p\"\n      shows \"c.path (sum A B) (w || map Inl r) (Inl p)\"", "lemma path_sum_b:\n      assumes \"length s = length w\" \"b.path B (w || s) q\"\n      shows \"c.path (sum A B) (w || map Inr s) (Inr q)\"", "lemma sum_path:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      assumes \"length rs = length w\" \"c.path (sum A B) (w || rs) pq\"\n      obtains\n        (a) r p where \"rs = map Inl r\" \"pq = Inl p\" \"a.path A (w || r) p\" |\n        (b) s q where \"rs = map Inr s\" \"pq = Inr q\" \"b.path B (w || s) q\"", "lemma run_sum_a:\n      assumes \"a.run A (w ||| r) p\"\n      shows \"c.run (sum A B) (w ||| smap Inl r) (Inl p)\"", "lemma run_sum_b:\n      assumes \"b.run B (w ||| s) q\"\n      shows \"c.run (sum A B) (w ||| smap Inr s) (Inr q)\"", "lemma sum_run:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      assumes \"c.run (sum A B) (w ||| rs) pq\"\n      obtains\n        (a) r p where \"rs = smap Inl r\" \"pq = Inl p\" \"a.run A (w ||| r) p\" |\n        (b) s q where \"rs = smap Inr s\" \"pq = Inr q\" \"b.run B (w ||| s) q\"", "lemma sum_nodes:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"c.nodes (sum A B) \\<subseteq> a.nodes A <+> b.nodes B\"", "lemma sum_nodes_finite[intro]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      assumes \"finite (a.nodes A)\" \"finite (b.nodes B)\"\n      shows \"finite (c.nodes (sum A B))\"", "lemma sum_language[simp]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"c.language (sum A B) = a.language A \\<union> b.language B\"", "lemma sum_language[simp]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"c.language (sum A B) = a.language A \\<union> b.language B\"", "lemma product_simps[simp]:\n      \"alphabet\\<^sub>2 (product AA) = \\<Inter> (alphabet\\<^sub>1 ` set AA)\"\n      \"initial\\<^sub>2 (product AA) = listset (map initial\\<^sub>1 AA)\"\n      \"transition\\<^sub>2 (product AA) a ps = listset (map2 (\\<lambda> A p. transition\\<^sub>1 A a p) AA ps)\"\n      \"condition\\<^sub>2 (product AA) = condition (map condition\\<^sub>1 AA)\"", "lemma product_run_length:\n      assumes \"length ps = length AA\"\n      assumes \"b.run (product AA) (w ||| r) ps\"\n      assumes \"qs \\<in> sset r\"\n      shows \"length qs = length AA\"", "lemma product_run_stranspose:\n      assumes \"length ps = length AA\"\n      assumes \"b.run (product AA) (w ||| r) ps\"\n      obtains rs where \"r = stranspose rs\" \"length rs = length AA\"", "lemma run_product:\n      assumes \"length rs = length AA\" \"length ps = length AA\"\n      assumes \"\\<And> k. k < length AA \\<Longrightarrow> a.run (AA ! k) (w ||| rs ! k) (ps ! k)\"\n      shows \"b.run (product AA) (w ||| stranspose rs) ps\"", "lemma product_run:\n      assumes \"length rs = length AA\" \"length ps = length AA\"\n      assumes \"b.run (product AA) (w ||| stranspose rs) ps\"\n      shows \"k < length AA \\<Longrightarrow> a.run (AA ! k) (w ||| rs ! k) (ps ! k)\"", "lemma product_nodes: \"b.nodes (product AA) \\<subseteq> listset (map a.nodes AA)\"", "lemma product_nodes_finite[intro]:\n      assumes \"list_all (finite \\<circ> a.nodes) AA\"\n      shows \"finite (b.nodes (product AA))\"", "lemma product_nodes_card:\n      assumes \"list_all (finite \\<circ> a.nodes) AA\"\n      shows \"card (b.nodes (product AA)) \\<le> prod_list (map (card \\<circ> a.nodes) AA)\"", "lemma product_language[simp]: \"b.language (product AA) = \\<Inter> (a.language ` set AA)\"", "lemma sum_simps[simp]:\n      \"alphabet\\<^sub>2 (sum AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      \"initial\\<^sub>2 (sum AA) = (\\<Union> k < length AA. {k} \\<times> initial\\<^sub>1 (AA ! k))\"\n      \"transition\\<^sub>2 (sum AA) a (k, p) = {k} \\<times> transition\\<^sub>1 (AA ! k) a p\"\n      \"condition\\<^sub>2 (sum AA) = condition (map condition\\<^sub>1 AA)\"", "lemma run_sum:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      assumes \"A \\<in> set AA\"\n      assumes \"a.run A (w ||| s) p\"\n      obtains k where \"k < length AA\" \"A = AA ! k\" \"b.run (sum AA) (w ||| sconst k ||| s) (k, p)\"", "lemma sum_run:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      assumes \"k < length AA\"\n      assumes \"b.run (sum AA) (w ||| r) (k, p)\"\n      obtains s where \"r = sconst k ||| s\" \"a.run (AA ! k) (w ||| s) p\"", "lemma sum_nodes:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      shows \"b.nodes (sum AA) \\<subseteq> (\\<Union> k < length AA. {k} \\<times> a.nodes (AA ! k))\"", "lemma sum_nodes_finite[intro]:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      assumes \"list_all (finite \\<circ> a.nodes) AA\"\n      shows \"finite (b.nodes (sum AA))\"", "lemma sum_language[simp]:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      shows \"b.language (sum AA) = \\<Union> (a.language ` set AA)\""], "translations": [["", "lemma states_alt_def: \"states r p = map snd r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states r p = map snd r", "by (induct r arbitrary: p) (auto)"], ["", "lemma trace_alt_def: \"trace r p = smap snd r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace r p = smap snd r", "by (coinduction arbitrary: r p) (auto)"], ["", "lemma successors_alt_def: \"successors A p = (\\<Union> a \\<in> alphabet A. transition A a p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. successors A p = (\\<Union>a\\<in>alphabet A. transition A a p)", "by auto"], ["", "lemma reachable_transition[intro]:\n      assumes \"a \\<in> alphabet A\" \"q \\<in> reachable A p\" \"r \\<in> transition A a q\"\n      shows \"r \\<in> reachable A p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> reachable' A p", "using reachable.execute assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?q \\<in> reachable' ?A ?p;\n   fst ?a \\<in> alphabet ?A \\<and>\n   snd ?a \\<in> transition ?A (fst ?a) ?q\\<rbrakk>\n  \\<Longrightarrow> snd ?a \\<in> reachable' ?A ?p\n  a \\<in> alphabet A\n  q \\<in> reachable' A p\n  r \\<in> transition A a q\n\ngoal (1 subgoal):\n 1. r \\<in> reachable' A p", "by force"], ["", "lemma nodes_transition[intro]:\n      assumes \"a \\<in> alphabet A\" \"p \\<in> nodes A\" \"q \\<in> transition A a p\"\n      shows \"q \\<in> nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> nodes' A", "using nodes.execute assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in> nodes' ?A;\n   fst ?a \\<in> alphabet ?A \\<and>\n   snd ?a \\<in> transition ?A (fst ?a) ?p\\<rbrakk>\n  \\<Longrightarrow> snd ?a \\<in> nodes' ?A\n  a \\<in> alphabet A\n  p \\<in> nodes' A\n  q \\<in> transition A a p\n\ngoal (1 subgoal):\n 1. q \\<in> nodes' A", "by force"], ["", "lemma path_alphabet:\n      assumes \"length r = length w\" \"path A (w || r) p\"\n      shows \"w \\<in> lists (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> lists (alphabet A)", "using assms"], ["proof (prove)\nusing this:\n  length r = length w\n  path' A (w || r) p\n\ngoal (1 subgoal):\n 1. w \\<in> lists (alphabet A)", "by (induct arbitrary: p rule: list_induct2) (auto)"], ["", "lemma run_alphabet:\n      assumes \"run A (w ||| r) p\"\n      shows \"w \\<in> streams (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> streams (alphabet A)", "using assms"], ["proof (prove)\nusing this:\n  run' A (w ||| r) p\n\ngoal (1 subgoal):\n 1. w \\<in> streams (alphabet A)", "by (coinduction arbitrary: w r p) (metis run.cases stream.map szip_smap szip_smap_fst)"], ["", "definition restrict :: \"'automaton \\<Rightarrow> 'automaton\" where\n      \"restrict A \\<equiv> automaton\n        (alphabet A)\n        (initial A)\n        (\\<lambda> a p. if a \\<in> alphabet A then transition A a p else {})\n        (condition A)\""], ["", "lemma restrict_simps[simp]:\n      \"alphabet (restrict A) = alphabet A\"\n      \"initial (restrict A) = initial A\"\n      \"transition (restrict A) a p = (if a \\<in> alphabet A then transition A a p else {})\"\n      \"condition (restrict A) = condition A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet (restrict A) = alphabet A &&&\n     initial (restrict A) = initial A) &&&\n    transition (restrict A) a p =\n    (if a \\<in> alphabet A then transition A a p else {}) &&&\n    condition (restrict A) = condition A", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\n      (automaton (alphabet A) (initial A)\n        (\\<lambda>a p. if a \\<in> alphabet A then transition A a p else {})\n        (condition A)) =\n     alphabet A &&&\n     initial\n      (automaton (alphabet A) (initial A)\n        (\\<lambda>a p. if a \\<in> alphabet A then transition A a p else {})\n        (condition A)) =\n     initial A) &&&\n    transition\n     (automaton (alphabet A) (initial A)\n       (\\<lambda>a p. if a \\<in> alphabet A then transition A a p else {})\n       (condition A))\n     a p =\n    (if a \\<in> alphabet A then transition A a p else {}) &&&\n    condition\n     (automaton (alphabet A) (initial A)\n       (\\<lambda>a p. if a \\<in> alphabet A then transition A a p else {})\n       (condition A)) =\n    condition A", "by auto"], ["", "lemma restrict_path[simp]: \"path (restrict A) = path A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path' (restrict A) = path' A", "proof (intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. path' (restrict A) x xa \\<Longrightarrow> path' A x xa\n 2. \\<And>x xa. path' A x xa \\<Longrightarrow> path' (restrict A) x xa", "show \"path A wr p\" if \"path (restrict A) wr p\" for wr p"], ["proof (prove)\ngoal (1 subgoal):\n 1. path' A wr p", "using that"], ["proof (prove)\nusing this:\n  path' (restrict A) wr p\n\ngoal (1 subgoal):\n 1. path' A wr p", "by induct auto"], ["proof (state)\nthis:\n  path' (restrict A) ?wr ?p \\<Longrightarrow> path' A ?wr ?p\n\ngoal (1 subgoal):\n 1. \\<And>x xa. path' A x xa \\<Longrightarrow> path' (restrict A) x xa", "show \"path (restrict A) wr p\" if \"path A wr p\" for wr p"], ["proof (prove)\ngoal (1 subgoal):\n 1. path' (restrict A) wr p", "using that"], ["proof (prove)\nusing this:\n  path' A wr p\n\ngoal (1 subgoal):\n 1. path' (restrict A) wr p", "by induct auto"], ["proof (state)\nthis:\n  path' A ?wr ?p \\<Longrightarrow> path' (restrict A) ?wr ?p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict_run[simp]: \"run (restrict A) = run A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run' (restrict A) = run' A", "proof (intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. run' (restrict A) x xa \\<Longrightarrow> run' A x xa\n 2. \\<And>x xa. run' A x xa \\<Longrightarrow> run' (restrict A) x xa", "show \"run A wr p\" if \"run (restrict A) wr p\" for wr p"], ["proof (prove)\ngoal (1 subgoal):\n 1. run' A wr p", "using that"], ["proof (prove)\nusing this:\n  run' (restrict A) wr p\n\ngoal (1 subgoal):\n 1. run' A wr p", "by coinduct auto"], ["proof (state)\nthis:\n  run' (restrict A) ?wr ?p \\<Longrightarrow> run' A ?wr ?p\n\ngoal (1 subgoal):\n 1. \\<And>x xa. run' A x xa \\<Longrightarrow> run' (restrict A) x xa", "show \"run (restrict A) wr p\" if \"run A wr p\" for wr p"], ["proof (prove)\ngoal (1 subgoal):\n 1. run' (restrict A) wr p", "using that"], ["proof (prove)\nusing this:\n  run' A wr p\n\ngoal (1 subgoal):\n 1. run' (restrict A) wr p", "by coinduct auto"], ["proof (state)\nthis:\n  run' A ?wr ?p \\<Longrightarrow> run' (restrict A) ?wr ?p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale automaton_path =\n    automaton automaton alphabet initial transition condition\n    for automaton :: \"'label set \\<Rightarrow> 'state set \\<Rightarrow> ('label \\<Rightarrow> 'state \\<Rightarrow> 'state set) \\<Rightarrow> 'condition \\<Rightarrow> 'automaton\"\n    and alphabet initial transition condition\n    +\n    fixes test :: \"'condition \\<Rightarrow> 'label list \\<Rightarrow> 'state list \\<Rightarrow> 'state \\<Rightarrow> bool\"\n  begin"], ["", "definition language :: \"'automaton \\<Rightarrow> 'label list set\" where\n      \"language A \\<equiv> {w |w r p. length r = length w \\<and> p \\<in> initial A \\<and> path A (w || r) p \\<and> test (condition A) w r p}\""], ["", "lemma language[intro]:\n      assumes \"length r = length w\" \"p \\<in> initial A\" \"path A (w || r) p\" \"test (condition A) w r p\"\n      shows \"w \\<in> language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> language A", "using assms"], ["proof (prove)\nusing this:\n  length r = length w\n  p \\<in> initial A\n  path' A (w || r) p\n  test (condition A) w r p\n\ngoal (1 subgoal):\n 1. w \\<in> language A", "unfolding language_def"], ["proof (prove)\nusing this:\n  length r = length w\n  p \\<in> initial A\n  path' A (w || r) p\n  test (condition A) w r p\n\ngoal (1 subgoal):\n 1. w \\<in> {uu_.\n             \\<exists>w r p.\n                uu_ = w \\<and>\n                length r = length w \\<and>\n                p \\<in> initial A \\<and>\n                path' A (w || r) p \\<and> test (condition A) w r p}", "by auto"], ["", "lemma language_elim[elim]:\n      assumes \"w \\<in> language A\"\n      obtains r p\n      where \"length r = length w\" \"p \\<in> initial A\" \"path A (w || r) p\" \"test (condition A) w r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r p.\n        \\<lbrakk>length r = length w; p \\<in> initial A; path' A (w || r) p;\n         test (condition A) w r p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  w \\<in> language A\n\ngoal (1 subgoal):\n 1. (\\<And>r p.\n        \\<lbrakk>length r = length w; p \\<in> initial A; path' A (w || r) p;\n         test (condition A) w r p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding language_def"], ["proof (prove)\nusing this:\n  w \\<in> {uu_.\n           \\<exists>w r p.\n              uu_ = w \\<and>\n              length r = length w \\<and>\n              p \\<in> initial A \\<and>\n              path' A (w || r) p \\<and> test (condition A) w r p}\n\ngoal (1 subgoal):\n 1. (\\<And>r p.\n        \\<lbrakk>length r = length w; p \\<in> initial A; path' A (w || r) p;\n         test (condition A) w r p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma language_alphabet: \"language A \\<subseteq> lists (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language A \\<subseteq> lists (alphabet A)", "by (auto dest: path_alphabet)"], ["", "lemma restrict_language[simp]: \"language (restrict A) = language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language (restrict A) = language A", "by force"], ["", "end"], ["", "locale automaton_run =\n    automaton automaton alphabet initial transition condition\n    for automaton :: \"'label set \\<Rightarrow> 'state set \\<Rightarrow> ('label \\<Rightarrow> 'state \\<Rightarrow> 'state set) \\<Rightarrow> 'condition \\<Rightarrow> 'automaton\"\n    and alphabet initial transition condition\n    +\n    fixes test :: \"'condition \\<Rightarrow> 'label stream \\<Rightarrow> 'state stream \\<Rightarrow> 'state \\<Rightarrow> bool\"\n  begin"], ["", "definition language :: \"'automaton \\<Rightarrow> 'label stream set\" where\n      \"language A \\<equiv> {w |w r p. p \\<in> initial A \\<and> run A (w ||| r) p \\<and> test (condition A) w r p}\""], ["", "lemma language[intro]:\n      assumes \"p \\<in> initial A\" \"run A (w ||| r) p\" \"test (condition A) w r p\"\n      shows \"w \\<in> language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> language A", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> initial A\n  run' A (w ||| r) p\n  test (condition A) w r p\n\ngoal (1 subgoal):\n 1. w \\<in> language A", "unfolding language_def"], ["proof (prove)\nusing this:\n  p \\<in> initial A\n  run' A (w ||| r) p\n  test (condition A) w r p\n\ngoal (1 subgoal):\n 1. w \\<in> {uu_.\n             \\<exists>w r p.\n                uu_ = w \\<and>\n                p \\<in> initial A \\<and>\n                run' A (w ||| r) p \\<and> test (condition A) w r p}", "by auto"], ["", "lemma language_elim[elim]:\n      assumes \"w \\<in> language A\"\n      obtains r p\n      where \"p \\<in> initial A\" \"run A (w ||| r) p\" \"test (condition A) w r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p r.\n        \\<lbrakk>p \\<in> initial A; run' A (w ||| r) p;\n         test (condition A) w r p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  w \\<in> language A\n\ngoal (1 subgoal):\n 1. (\\<And>p r.\n        \\<lbrakk>p \\<in> initial A; run' A (w ||| r) p;\n         test (condition A) w r p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding language_def"], ["proof (prove)\nusing this:\n  w \\<in> {uu_.\n           \\<exists>w r p.\n              uu_ = w \\<and>\n              p \\<in> initial A \\<and>\n              run' A (w ||| r) p \\<and> test (condition A) w r p}\n\ngoal (1 subgoal):\n 1. (\\<And>p r.\n        \\<lbrakk>p \\<in> initial A; run' A (w ||| r) p;\n         test (condition A) w r p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma language_alphabet: \"language A \\<subseteq> streams (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language A \\<subseteq> streams (alphabet A)", "by (auto dest: run_alphabet)"], ["", "lemma restrict_language[simp]: \"language (restrict A) = language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language (restrict A) = language A", "by force"], ["", "end"], ["", "locale automaton_degeneralization =\n    a: automaton automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 +\n    b: automaton automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    for automaton\\<^sub>1 :: \"'label set \\<Rightarrow> 'state set \\<Rightarrow> ('label \\<Rightarrow> 'state \\<Rightarrow> 'state set) \\<Rightarrow> 'item pred gen \\<Rightarrow> 'automaton\\<^sub>1\"\n    and alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n    and automaton\\<^sub>2 :: \"'label set \\<Rightarrow> 'state degen set \\<Rightarrow> ('label \\<Rightarrow> 'state degen \\<Rightarrow> 'state degen set) \\<Rightarrow> 'item_degen pred \\<Rightarrow> 'automaton\\<^sub>2\"\n    and alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    +\n    fixes item :: \"'state \\<times> 'label \\<times> 'state \\<Rightarrow> 'item\"\n    fixes translate :: \"'item_degen \\<Rightarrow> 'item degen\"\n  begin"], ["", "definition degeneralize :: \"'automaton\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>2\" where\n      \"degeneralize A \\<equiv> automaton\\<^sub>2\n        (alphabet\\<^sub>1 A)\n        (initial\\<^sub>1 A \\<times> {0})\n        (\\<lambda> a (p, k). {(q, count (condition\\<^sub>1 A) (item (p, a, q)) k) |q. q \\<in> transition\\<^sub>1 A a p})\n        (degen (condition\\<^sub>1 A) \\<circ> translate)\""], ["", "lemma degeneralize_simps[simp]:\n      \"alphabet\\<^sub>2 (degeneralize A) = alphabet\\<^sub>1 A\"\n      \"initial\\<^sub>2 (degeneralize A) = initial\\<^sub>1 A \\<times> {0}\"\n      \"transition\\<^sub>2 (degeneralize A) a (p, k) =\n        {(q, count (condition\\<^sub>1 A) (item (p, a, q)) k) |q. q \\<in> transition\\<^sub>1 A a p}\"\n      \"condition\\<^sub>2 (degeneralize A) = degen (condition\\<^sub>1 A) \\<circ> translate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2 (degeneralize A) = alphabet\\<^sub>1 A &&&\n     initial\\<^sub>2 (degeneralize A) = initial\\<^sub>1 A \\<times> {0}) &&&\n    transition\\<^sub>2 (degeneralize A) a (p, k) =\n    {(q, count (condition\\<^sub>1 A) (item (p, a, q)) k) |q.\n     q \\<in> transition\\<^sub>1 A a p} &&&\n    condition\\<^sub>2 (degeneralize A) =\n    degen (condition\\<^sub>1 A) \\<circ> translate", "unfolding degeneralize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2\n      (automaton\\<^sub>2 (alphabet\\<^sub>1 A)\n        (initial\\<^sub>1 A \\<times> {0})\n        (\\<lambda>a (p, k).\n            {(q, count (condition\\<^sub>1 A) (item (p, a, q)) k) |q.\n             q \\<in> transition\\<^sub>1 A a p})\n        (degen (condition\\<^sub>1 A) \\<circ> translate)) =\n     alphabet\\<^sub>1 A &&&\n     initial\\<^sub>2\n      (automaton\\<^sub>2 (alphabet\\<^sub>1 A)\n        (initial\\<^sub>1 A \\<times> {0})\n        (\\<lambda>a (p, k).\n            {(q, count (condition\\<^sub>1 A) (item (p, a, q)) k) |q.\n             q \\<in> transition\\<^sub>1 A a p})\n        (degen (condition\\<^sub>1 A) \\<circ> translate)) =\n     initial\\<^sub>1 A \\<times> {0}) &&&\n    transition\\<^sub>2\n     (automaton\\<^sub>2 (alphabet\\<^sub>1 A)\n       (initial\\<^sub>1 A \\<times> {0})\n       (\\<lambda>a (p, k).\n           {(q, count (condition\\<^sub>1 A) (item (p, a, q)) k) |q.\n            q \\<in> transition\\<^sub>1 A a p})\n       (degen (condition\\<^sub>1 A) \\<circ> translate))\n     a (p, k) =\n    {(q, count (condition\\<^sub>1 A) (item (p, a, q)) k) |q.\n     q \\<in> transition\\<^sub>1 A a p} &&&\n    condition\\<^sub>2\n     (automaton\\<^sub>2 (alphabet\\<^sub>1 A)\n       (initial\\<^sub>1 A \\<times> {0})\n       (\\<lambda>a (p, k).\n           {(q, count (condition\\<^sub>1 A) (item (p, a, q)) k) |q.\n            q \\<in> transition\\<^sub>1 A a p})\n       (degen (condition\\<^sub>1 A) \\<circ> translate)) =\n    degen (condition\\<^sub>1 A) \\<circ> translate", "by auto"], ["", "lemma run_degeneralize:\n      assumes \"a.run A (w ||| r) p\"\n      shows \"b.run (degeneralize A) (w ||| r ||| sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r) k) (p, k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.run' (degeneralize A)\n     (w |||\n      r |||\n      sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r)\n       k)\n     (p, k)", "using assms"], ["proof (prove)\nusing this:\n  a.run' A (w ||| r) p\n\ngoal (1 subgoal):\n 1. b.run' (degeneralize A)\n     (w |||\n      r |||\n      sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r)\n       k)\n     (p, k)", "by (coinduction arbitrary: w r p k) (force elim: a.run.cases)"], ["", "lemma degeneralize_run:\n      assumes \"b.run (degeneralize A) (w ||| rs) pk\"\n      obtains r s p k\n      where \"rs = r ||| s\" \"pk = (p, k)\" \"a.run A (w ||| r) p\" \"s = sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r s p k.\n        \\<lbrakk>rs = r ||| s; pk = (p, k); a.run' A (w ||| r) p;\n         s =\n         sscan (count (condition\\<^sub>1 A) \\<circ> item)\n          (p ## r ||| w ||| r) k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>r s p k.\n        \\<lbrakk>rs = r ||| s; pk = (p, k); a.run' A (w ||| r) p;\n         s =\n         sscan (count (condition\\<^sub>1 A) \\<circ> item)\n          (p ## r ||| w ||| r) k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain r s p k where 1: \"rs = r ||| s\" \"pk = (p, k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r s p k.\n        \\<lbrakk>rs = r ||| s; pk = (p, k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using szip_smap surjective_pairing"], ["proof (prove)\nusing this:\n  smap fst ?zs ||| smap snd ?zs = ?zs\n  ?t = (fst ?t, snd ?t)\n\ngoal (1 subgoal):\n 1. (\\<And>r s p k.\n        \\<lbrakk>rs = r ||| s; pk = (p, k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  rs = r ||| s\n  pk = (p, k)\n\ngoal (1 subgoal):\n 1. (\\<And>r s p k.\n        \\<lbrakk>rs = r ||| s; pk = (p, k); a.run' A (w ||| r) p;\n         s =\n         sscan (count (condition\\<^sub>1 A) \\<circ> item)\n          (p ## r ||| w ||| r) k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. rs = ?r ||| ?s\n 2. pk = (?p, ?k)\n 3. a.run' A (w ||| ?r) ?p\n 4. ?s =\n    sscan (count (condition\\<^sub>1 A) \\<circ> item) (?p ## ?r ||| w ||| ?r)\n     ?k", "show \"rs = r ||| s\" \"pk = (p, k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs = r ||| s &&& pk = (p, k)", "using 1"], ["proof (prove)\nusing this:\n  rs = r ||| s\n  pk = (p, k)\n\ngoal (1 subgoal):\n 1. rs = r ||| s &&& pk = (p, k)", "by this"], ["proof (state)\nthis:\n  rs = r ||| s\n  pk = (p, k)\n\ngoal (2 subgoals):\n 1. a.run' A (w ||| r) p\n 2. s =\n    sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r) k", "show \"a.run A (w ||| r) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a.run' A (w ||| r) p", "using assms"], ["proof (prove)\nusing this:\n  b.run' (degeneralize A) (w ||| rs) pk\n\ngoal (1 subgoal):\n 1. a.run' A (w ||| r) p", "unfolding 1"], ["proof (prove)\nusing this:\n  b.run' (degeneralize A) (w ||| r ||| s) (p, k)\n\ngoal (1 subgoal):\n 1. a.run' A (w ||| r) p", "by (coinduction arbitrary: w r s p k) (force elim: b.run.cases)"], ["proof (state)\nthis:\n  a.run' A (w ||| r) p\n\ngoal (1 subgoal):\n 1. s =\n    sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r) k", "show \"s = sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s =\n    sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r) k", "using assms"], ["proof (prove)\nusing this:\n  b.run' (degeneralize A) (w ||| rs) pk\n\ngoal (1 subgoal):\n 1. s =\n    sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r) k", "unfolding 1"], ["proof (prove)\nusing this:\n  b.run' (degeneralize A) (w ||| r ||| s) (p, k)\n\ngoal (1 subgoal):\n 1. s =\n    sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r) k", "by (coinduction arbitrary: w r s p k) (erule b.run.cases, force)"], ["proof (state)\nthis:\n  s =\n  sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## r ||| w ||| r) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degeneralize_nodes:\n      \"b.nodes (degeneralize A) \\<subseteq> a.nodes A \\<times> insert 0 {0 ..< length (condition\\<^sub>1 A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.nodes' (degeneralize A)\n    \\<subseteq> a.nodes' A \\<times>\n                insert 0 {0..<length (condition\\<^sub>1 A)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> b.nodes' (degeneralize A) \\<Longrightarrow>\n       x \\<in> a.nodes' A \\<times>\n               insert 0 {0..<length (condition\\<^sub>1 A)}", "fix pk"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> b.nodes' (degeneralize A) \\<Longrightarrow>\n       x \\<in> a.nodes' A \\<times>\n               insert 0 {0..<length (condition\\<^sub>1 A)}", "assume \"pk \\<in> b.nodes (degeneralize A)\""], ["proof (state)\nthis:\n  pk \\<in> b.nodes' (degeneralize A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> b.nodes' (degeneralize A) \\<Longrightarrow>\n       x \\<in> a.nodes' A \\<times>\n               insert 0 {0..<length (condition\\<^sub>1 A)}", "then"], ["proof (chain)\npicking this:\n  pk \\<in> b.nodes' (degeneralize A)", "show \"pk \\<in> a.nodes A \\<times> insert 0 {0 ..< length (condition\\<^sub>1 A)}\""], ["proof (prove)\nusing this:\n  pk \\<in> b.nodes' (degeneralize A)\n\ngoal (1 subgoal):\n 1. pk \\<in> a.nodes' A \\<times> insert 0 {0..<length (condition\\<^sub>1 A)}", "by (induct) (force, cases \"condition\\<^sub>1 A = []\", auto)"], ["proof (state)\nthis:\n  pk \\<in> a.nodes' A \\<times> insert 0 {0..<length (condition\\<^sub>1 A)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nodes_degeneralize: \"a.nodes A \\<subseteq> fst ` b.nodes (degeneralize A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a.nodes' A \\<subseteq> fst ` b.nodes' (degeneralize A)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> a.nodes' A \\<Longrightarrow>\n       x \\<in> fst ` b.nodes' (degeneralize A)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> a.nodes' A \\<Longrightarrow>\n       x \\<in> fst ` b.nodes' (degeneralize A)", "assume \"p \\<in> a.nodes A\""], ["proof (state)\nthis:\n  p \\<in> a.nodes' A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> a.nodes' A \\<Longrightarrow>\n       x \\<in> fst ` b.nodes' (degeneralize A)", "then"], ["proof (chain)\npicking this:\n  p \\<in> a.nodes' A", "show \"p \\<in> fst ` b.nodes (degeneralize A)\""], ["proof (prove)\nusing this:\n  p \\<in> a.nodes' A\n\ngoal (1 subgoal):\n 1. p \\<in> fst ` b.nodes' (degeneralize A)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       p \\<in> initial\\<^sub>1 A \\<Longrightarrow>\n       p \\<in> fst ` b.nodes' (degeneralize A)\n 2. \\<And>p a.\n       \\<lbrakk>p \\<in> a.nodes' A; p \\<in> fst ` b.nodes' (degeneralize A);\n        fst a \\<in> alphabet\\<^sub>1 A \\<and>\n        snd a \\<in> transition\\<^sub>1 A (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> fst ` b.nodes' (degeneralize A)", "case (initial p)"], ["proof (state)\nthis:\n  p \\<in> initial\\<^sub>1 A\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       p \\<in> initial\\<^sub>1 A \\<Longrightarrow>\n       p \\<in> fst ` b.nodes' (degeneralize A)\n 2. \\<And>p a.\n       \\<lbrakk>p \\<in> a.nodes' A; p \\<in> fst ` b.nodes' (degeneralize A);\n        fst a \\<in> alphabet\\<^sub>1 A \\<and>\n        snd a \\<in> transition\\<^sub>1 A (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> fst ` b.nodes' (degeneralize A)", "have \"(p, 0) \\<in> b.nodes (degeneralize A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p, 0) \\<in> b.nodes' (degeneralize A)", "using initial"], ["proof (prove)\nusing this:\n  p \\<in> initial\\<^sub>1 A\n\ngoal (1 subgoal):\n 1. (p, 0) \\<in> b.nodes' (degeneralize A)", "by auto"], ["proof (state)\nthis:\n  (p, 0) \\<in> b.nodes' (degeneralize A)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       p \\<in> initial\\<^sub>1 A \\<Longrightarrow>\n       p \\<in> fst ` b.nodes' (degeneralize A)\n 2. \\<And>p a.\n       \\<lbrakk>p \\<in> a.nodes' A; p \\<in> fst ` b.nodes' (degeneralize A);\n        fst a \\<in> alphabet\\<^sub>1 A \\<and>\n        snd a \\<in> transition\\<^sub>1 A (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> fst ` b.nodes' (degeneralize A)", "then"], ["proof (chain)\npicking this:\n  (p, 0) \\<in> b.nodes' (degeneralize A)", "show ?case"], ["proof (prove)\nusing this:\n  (p, 0) \\<in> b.nodes' (degeneralize A)\n\ngoal (1 subgoal):\n 1. p \\<in> fst ` b.nodes' (degeneralize A)", "using image_iff fst_conv"], ["proof (prove)\nusing this:\n  (p, 0) \\<in> b.nodes' (degeneralize A)\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  fst (?x1.0, ?x2.0) = ?x1.0\n\ngoal (1 subgoal):\n 1. p \\<in> fst ` b.nodes' (degeneralize A)", "by force"], ["proof (state)\nthis:\n  p \\<in> fst ` b.nodes' (degeneralize A)\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> a.nodes' A; p \\<in> fst ` b.nodes' (degeneralize A);\n        fst a \\<in> alphabet\\<^sub>1 A \\<and>\n        snd a \\<in> transition\\<^sub>1 A (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> fst ` b.nodes' (degeneralize A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> a.nodes' A; p \\<in> fst ` b.nodes' (degeneralize A);\n        fst a \\<in> alphabet\\<^sub>1 A \\<and>\n        snd a \\<in> transition\\<^sub>1 A (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> fst ` b.nodes' (degeneralize A)", "case (execute p aq)"], ["proof (state)\nthis:\n  p \\<in> a.nodes' A\n  p \\<in> fst ` b.nodes' (degeneralize A)\n  fst aq \\<in> alphabet\\<^sub>1 A \\<and>\n  snd aq \\<in> transition\\<^sub>1 A (fst aq) p\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> a.nodes' A; p \\<in> fst ` b.nodes' (degeneralize A);\n        fst a \\<in> alphabet\\<^sub>1 A \\<and>\n        snd a \\<in> transition\\<^sub>1 A (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> fst ` b.nodes' (degeneralize A)", "obtain k where \"(p, k) \\<in> b.nodes (degeneralize A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        (p, k) \\<in> b.nodes' (degeneralize A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using execute(2)"], ["proof (prove)\nusing this:\n  p \\<in> fst ` b.nodes' (degeneralize A)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        (p, k) \\<in> b.nodes' (degeneralize A) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (p, k) \\<in> b.nodes' (degeneralize A)\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> a.nodes' A; p \\<in> fst ` b.nodes' (degeneralize A);\n        fst a \\<in> alphabet\\<^sub>1 A \\<and>\n        snd a \\<in> transition\\<^sub>1 A (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> fst ` b.nodes' (degeneralize A)", "then"], ["proof (chain)\npicking this:\n  (p, k) \\<in> b.nodes' (degeneralize A)", "have \"(snd aq, count (condition\\<^sub>1 A) (item (p, aq)) k) \\<in> b.nodes (degeneralize A)\""], ["proof (prove)\nusing this:\n  (p, k) \\<in> b.nodes' (degeneralize A)\n\ngoal (1 subgoal):\n 1. (snd aq, count (condition\\<^sub>1 A) (item (p, aq)) k)\n    \\<in> b.nodes' (degeneralize A)", "using execute(3)"], ["proof (prove)\nusing this:\n  (p, k) \\<in> b.nodes' (degeneralize A)\n  fst aq \\<in> alphabet\\<^sub>1 A \\<and>\n  snd aq \\<in> transition\\<^sub>1 A (fst aq) p\n\ngoal (1 subgoal):\n 1. (snd aq, count (condition\\<^sub>1 A) (item (p, aq)) k)\n    \\<in> b.nodes' (degeneralize A)", "by auto"], ["proof (state)\nthis:\n  (snd aq, count (condition\\<^sub>1 A) (item (p, aq)) k)\n  \\<in> b.nodes' (degeneralize A)\n\ngoal (1 subgoal):\n 1. \\<And>p a.\n       \\<lbrakk>p \\<in> a.nodes' A; p \\<in> fst ` b.nodes' (degeneralize A);\n        fst a \\<in> alphabet\\<^sub>1 A \\<and>\n        snd a \\<in> transition\\<^sub>1 A (fst a) p\\<rbrakk>\n       \\<Longrightarrow> snd a \\<in> fst ` b.nodes' (degeneralize A)", "then"], ["proof (chain)\npicking this:\n  (snd aq, count (condition\\<^sub>1 A) (item (p, aq)) k)\n  \\<in> b.nodes' (degeneralize A)", "show ?case"], ["proof (prove)\nusing this:\n  (snd aq, count (condition\\<^sub>1 A) (item (p, aq)) k)\n  \\<in> b.nodes' (degeneralize A)\n\ngoal (1 subgoal):\n 1. snd aq \\<in> fst ` b.nodes' (degeneralize A)", "using image_iff snd_conv"], ["proof (prove)\nusing this:\n  (snd aq, count (condition\\<^sub>1 A) (item (p, aq)) k)\n  \\<in> b.nodes' (degeneralize A)\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  snd (?x1.0, ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. snd aq \\<in> fst ` b.nodes' (degeneralize A)", "by force"], ["proof (state)\nthis:\n  snd aq \\<in> fst ` b.nodes' (degeneralize A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> fst ` b.nodes' (degeneralize A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degeneralize_nodes_finite[iff]: \"finite (b.nodes (degeneralize A)) \\<longleftrightarrow> finite (a.nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (b.nodes' (degeneralize A)) = finite (a.nodes' A)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (b.nodes' (degeneralize A)) \\<Longrightarrow> finite (a.nodes' A)\n 2. finite (a.nodes' A) \\<Longrightarrow> finite (b.nodes' (degeneralize A))", "show \"finite (a.nodes A)\" if \"finite (b.nodes (degeneralize A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (a.nodes' A)", "using finite_subset nodes_degeneralize that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  a.nodes' ?A \\<subseteq> fst ` b.nodes' (degeneralize ?A)\n  finite (b.nodes' (degeneralize A))\n\ngoal (1 subgoal):\n 1. finite (a.nodes' A)", "by blast"], ["proof (state)\nthis:\n  finite (b.nodes' (degeneralize A)) \\<Longrightarrow> finite (a.nodes' A)\n\ngoal (1 subgoal):\n 1. finite (a.nodes' A) \\<Longrightarrow> finite (b.nodes' (degeneralize A))", "show \"finite (b.nodes (degeneralize A))\" if \"finite (a.nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (b.nodes' (degeneralize A))", "using finite_subset degeneralize_nodes that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  b.nodes' (degeneralize ?A)\n  \\<subseteq> a.nodes' ?A \\<times>\n              insert 0 {0..<length (condition\\<^sub>1 ?A)}\n  finite (a.nodes' A)\n\ngoal (1 subgoal):\n 1. finite (b.nodes' (degeneralize A))", "by blast"], ["proof (state)\nthis:\n  finite (a.nodes' A) \\<Longrightarrow> finite (b.nodes' (degeneralize A))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale automaton_degeneralization_run =\n    automaton_degeneralization\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      item translate +\n    a: automaton_run automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_run automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and item translate\n    +\n    assumes test[iff]: \"test\\<^sub>2 (degen cs \\<circ> translate) w\n      (r ||| sscan (count cs \\<circ> item) (p ## r ||| w ||| r) k) (p, k) \\<longleftrightarrow> test\\<^sub>1 cs w r p\"\n  begin"], ["", "lemma degeneralize_language[simp]: \"b.language (degeneralize A) = a.language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.language (degeneralize A) = a.language A", "unfolding a.language_def b.language_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        p \\<in> initial\\<^sub>2 (degeneralize A) \\<and>\n        b.run' (degeneralize A) (w ||| r) p \\<and>\n        test\\<^sub>2 (condition\\<^sub>2 (degeneralize A)) w r p} =\n    {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        p \\<in> initial\\<^sub>1 A \\<and>\n        a.run' A (w ||| r) p \\<and>\n        test\\<^sub>1 (condition\\<^sub>1 A) w r p}", "by (auto dest: run_degeneralize elim!: degeneralize_run)"], ["", "end"], ["", "locale automaton_product =\n    a: automaton automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 +\n    b: automaton automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 +\n    c: automaton automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n    for automaton\\<^sub>1 :: \"'label set \\<Rightarrow> 'state\\<^sub>1 set \\<Rightarrow> ('label \\<Rightarrow> 'state\\<^sub>1 \\<Rightarrow> 'state\\<^sub>1 set) \\<Rightarrow> 'condition\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>1\"\n    and alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n    and automaton\\<^sub>2 :: \"'label set \\<Rightarrow> 'state\\<^sub>2 set \\<Rightarrow> ('label \\<Rightarrow> 'state\\<^sub>2 \\<Rightarrow> 'state\\<^sub>2 set) \\<Rightarrow> 'condition\\<^sub>2 \\<Rightarrow> 'automaton\\<^sub>2\"\n    and alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    and automaton\\<^sub>3 :: \"'label set \\<Rightarrow> ('state\\<^sub>1 \\<times> 'state\\<^sub>2) set \\<Rightarrow> ('label \\<Rightarrow> 'state\\<^sub>1 \\<times> 'state\\<^sub>2 \\<Rightarrow> ('state\\<^sub>1 \\<times> 'state\\<^sub>2) set) \\<Rightarrow> 'condition\\<^sub>3 \\<Rightarrow> 'automaton\\<^sub>3\"\n    and alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n    +\n    fixes condition :: \"'condition\\<^sub>1 \\<Rightarrow> 'condition\\<^sub>2 \\<Rightarrow> 'condition\\<^sub>3\"\n  begin"], ["", "definition product :: \"'automaton\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>2 \\<Rightarrow> 'automaton\\<^sub>3\" where\n      \"product A B \\<equiv> automaton\\<^sub>3\n        (alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B)\n        (initial\\<^sub>1 A \\<times> initial\\<^sub>2 B)\n        (\\<lambda> a (p, q). transition\\<^sub>1 A a p \\<times> transition\\<^sub>2 B a q)\n        (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))\""], ["", "lemma product_simps[simp]:\n      \"alphabet\\<^sub>3 (product A B) = alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B\"\n      \"initial\\<^sub>3 (product A B) = initial\\<^sub>1 A \\<times> initial\\<^sub>2 B\"\n      \"transition\\<^sub>3 (product A B) a (p, q) = transition\\<^sub>1 A a p \\<times> transition\\<^sub>2 B a q\"\n      \"condition\\<^sub>3 (product A B) = condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>3 (product A B) =\n     alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B &&&\n     initial\\<^sub>3 (product A B) =\n     initial\\<^sub>1 A \\<times> initial\\<^sub>2 B) &&&\n    transition\\<^sub>3 (product A B) a (p, q) =\n    transition\\<^sub>1 A a p \\<times> transition\\<^sub>2 B a q &&&\n    condition\\<^sub>3 (product A B) =\n    condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)", "unfolding product_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>3\n      (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B)\n        (initial\\<^sub>1 A \\<times> initial\\<^sub>2 B)\n        (\\<lambda>a (p, q).\n            transition\\<^sub>1 A a p \\<times> transition\\<^sub>2 B a q)\n        (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))) =\n     alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B &&&\n     initial\\<^sub>3\n      (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B)\n        (initial\\<^sub>1 A \\<times> initial\\<^sub>2 B)\n        (\\<lambda>a (p, q).\n            transition\\<^sub>1 A a p \\<times> transition\\<^sub>2 B a q)\n        (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))) =\n     initial\\<^sub>1 A \\<times> initial\\<^sub>2 B) &&&\n    transition\\<^sub>3\n     (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B)\n       (initial\\<^sub>1 A \\<times> initial\\<^sub>2 B)\n       (\\<lambda>a (p, q).\n           transition\\<^sub>1 A a p \\<times> transition\\<^sub>2 B a q)\n       (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)))\n     a (p, q) =\n    transition\\<^sub>1 A a p \\<times> transition\\<^sub>2 B a q &&&\n    condition\\<^sub>3\n     (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B)\n       (initial\\<^sub>1 A \\<times> initial\\<^sub>2 B)\n       (\\<lambda>a (p, q).\n           transition\\<^sub>1 A a p \\<times> transition\\<^sub>2 B a q)\n       (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))) =\n    condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)", "by auto"], ["", "lemma product_target[simp]:\n      assumes \"length w = length r\" \"length r = length s\"\n      shows \"c.target (w || r || s) (p, q) = (a.target (w || r) p, b.target (w || s) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.target (w || r || s) (p, q) =\n    (a.target (w || r) p, b.target (w || s) q)", "using assms"], ["proof (prove)\nusing this:\n  length w = length r\n  length r = length s\n\ngoal (1 subgoal):\n 1. c.target (w || r || s) (p, q) =\n    (a.target (w || r) p, b.target (w || s) q)", "by (induct arbitrary: p q rule: list_induct3) (auto)"], ["", "lemma product_path[iff]:\n      assumes \"length w = length r\" \"length r = length s\"\n      shows \"c.path (product A B) (w || r || s) (p, q) \\<longleftrightarrow>\n        a.path A (w || r) p \\<and> b.path B (w || s) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.path' (product A B) (w || r || s) (p, q) =\n    (a.path' A (w || r) p \\<and> b.path' B (w || s) q)", "using assms"], ["proof (prove)\nusing this:\n  length w = length r\n  length r = length s\n\ngoal (1 subgoal):\n 1. c.path' (product A B) (w || r || s) (p, q) =\n    (a.path' A (w || r) p \\<and> b.path' B (w || s) q)", "by (induct arbitrary: p q rule: list_induct3) (auto)"], ["", "lemma product_run[iff]: \"c.run (product A B) (w ||| r ||| s) (p, q) \\<longleftrightarrow>\n      a.run A (w ||| r) p \\<and> b.run B (w ||| s) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.run' (product A B) (w ||| r ||| s) (p, q) =\n    (a.run' A (w ||| r) p \\<and> b.run' B (w ||| s) q)", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. c.run' (product A B) (w ||| r ||| s) (p, q) \\<Longrightarrow>\n    a.run' A (w ||| r) p\n 2. c.run' (product A B) (w ||| r ||| s) (p, q) \\<Longrightarrow>\n    b.run' B (w ||| s) q\n 3. \\<lbrakk>a.run' A (w ||| r) p; b.run' B (w ||| s) q\\<rbrakk>\n    \\<Longrightarrow> c.run' (product A B) (w ||| r ||| s) (p, q)", "show \"a.run A (w ||| r) p\" if \"c.run (product A B) (w ||| r ||| s) (p, q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a.run' A (w ||| r) p", "using that"], ["proof (prove)\nusing this:\n  c.run' (product A B) (w ||| r ||| s) (p, q)\n\ngoal (1 subgoal):\n 1. a.run' A (w ||| r) p", "by (coinduction arbitrary: w r s p q) (force elim: c.run.cases)"], ["proof (state)\nthis:\n  c.run' (product A B) (w ||| r ||| s) (p, q) \\<Longrightarrow>\n  a.run' A (w ||| r) p\n\ngoal (2 subgoals):\n 1. c.run' (product A B) (w ||| r ||| s) (p, q) \\<Longrightarrow>\n    b.run' B (w ||| s) q\n 2. \\<lbrakk>a.run' A (w ||| r) p; b.run' B (w ||| s) q\\<rbrakk>\n    \\<Longrightarrow> c.run' (product A B) (w ||| r ||| s) (p, q)", "show \"b.run B (w ||| s) q\" if \"c.run (product A B) (w ||| r ||| s) (p, q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.run' B (w ||| s) q", "using that"], ["proof (prove)\nusing this:\n  c.run' (product A B) (w ||| r ||| s) (p, q)\n\ngoal (1 subgoal):\n 1. b.run' B (w ||| s) q", "by (coinduction arbitrary: w r s p q) (force elim: c.run.cases)"], ["proof (state)\nthis:\n  c.run' (product A B) (w ||| r ||| s) (p, q) \\<Longrightarrow>\n  b.run' B (w ||| s) q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a.run' A (w ||| r) p; b.run' B (w ||| s) q\\<rbrakk>\n    \\<Longrightarrow> c.run' (product A B) (w ||| r ||| s) (p, q)", "show \"c.run (product A B) (w ||| r ||| s) (p, q)\" if \"a.run A (w ||| r) p\" \"b.run B (w ||| s) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.run' (product A B) (w ||| r ||| s) (p, q)", "using that"], ["proof (prove)\nusing this:\n  a.run' A (w ||| r) p\n  b.run' B (w ||| s) q\n\ngoal (1 subgoal):\n 1. c.run' (product A B) (w ||| r ||| s) (p, q)", "by (coinduction arbitrary: w r s p q) (auto elim: a.run.cases b.run.cases)"], ["proof (state)\nthis:\n  \\<lbrakk>a.run' A (w ||| r) p; b.run' B (w ||| s) q\\<rbrakk>\n  \\<Longrightarrow> c.run' (product A B) (w ||| r ||| s) (p, q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_nodes: \"c.nodes (product A B) \\<subseteq> a.nodes A \\<times> b.nodes B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.nodes' (product A B) \\<subseteq> a.nodes' A \\<times> b.nodes' B", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c.nodes' (product A B) \\<Longrightarrow>\n       x \\<in> a.nodes' A \\<times> b.nodes' B", "fix pq"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c.nodes' (product A B) \\<Longrightarrow>\n       x \\<in> a.nodes' A \\<times> b.nodes' B", "assume \"pq \\<in> c.nodes (product A B)\""], ["proof (state)\nthis:\n  pq \\<in> c.nodes' (product A B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c.nodes' (product A B) \\<Longrightarrow>\n       x \\<in> a.nodes' A \\<times> b.nodes' B", "then"], ["proof (chain)\npicking this:\n  pq \\<in> c.nodes' (product A B)", "show \"pq \\<in> a.nodes A \\<times> b.nodes B\""], ["proof (prove)\nusing this:\n  pq \\<in> c.nodes' (product A B)\n\ngoal (1 subgoal):\n 1. pq \\<in> a.nodes' A \\<times> b.nodes' B", "by induct auto"], ["proof (state)\nthis:\n  pq \\<in> a.nodes' A \\<times> b.nodes' B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_nodes_finite[intro]:\n      assumes \"finite (a.nodes A)\" \"finite (b.nodes B)\"\n      shows \"finite (c.nodes (product A B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (c.nodes' (product A B))", "using finite_subset product_nodes assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  c.nodes' (product ?A ?B) \\<subseteq> a.nodes' ?A \\<times> b.nodes' ?B\n  finite (a.nodes' A)\n  finite (b.nodes' B)\n\ngoal (1 subgoal):\n 1. finite (c.nodes' (product A B))", "by blast"], ["", "end"], ["", "locale automaton_intersection_path =\n    automaton_product\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n      condition +\n    a: automaton_path automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_path automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2 +\n    c: automaton_path automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    and condition\n    +\n    assumes test[iff]: \"length r = length w \\<Longrightarrow> length s = length w \\<Longrightarrow>\n      test\\<^sub>3 (condition c\\<^sub>1 c\\<^sub>2) w (r || s) (p, q) \\<longleftrightarrow> test\\<^sub>1 c\\<^sub>1 w r p \\<and> test\\<^sub>2 c\\<^sub>2 w s q\"\n  begin"], ["", "lemma product_language[simp]: \"c.language (product A B) = a.language A \\<inter> b.language B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.language (product A B) = a.language A \\<inter> b.language B", "unfolding a.language_def b.language_def c.language_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        length r = length w \\<and>\n        p \\<in> initial\\<^sub>3 (product A B) \\<and>\n        c.path' (product A B) (w || r) p \\<and>\n        test\\<^sub>3 (condition\\<^sub>3 (product A B)) w r p} =\n    {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        length r = length w \\<and>\n        p \\<in> initial\\<^sub>1 A \\<and>\n        a.path' A (w || r) p \\<and>\n        test\\<^sub>1 (condition\\<^sub>1 A) w r p} \\<inter>\n    {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        length r = length w \\<and>\n        p \\<in> initial\\<^sub>2 B \\<and>\n        b.path' B (w || r) p \\<and>\n        test\\<^sub>2 (condition\\<^sub>2 B) w r p}", "by (force iff: split_zip)"], ["", "end"], ["", "locale automaton_intersection_run =\n    automaton_product\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n      condition +\n    a: automaton_run automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_run automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2 +\n    c: automaton_run automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    and condition\n    +\n    assumes test[iff]: \"test\\<^sub>3 (condition c\\<^sub>1 c\\<^sub>2) w (r ||| s) (p, q) \\<longleftrightarrow> test\\<^sub>1 c\\<^sub>1 w r p \\<and> test\\<^sub>2 c\\<^sub>2 w s q\"\n  begin"], ["", "lemma product_language[simp]: \"c.language (product A B) = a.language A \\<inter> b.language B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.language (product A B) = a.language A \\<inter> b.language B", "unfolding a.language_def b.language_def c.language_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        p \\<in> initial\\<^sub>3 (product A B) \\<and>\n        c.run' (product A B) (w ||| r) p \\<and>\n        test\\<^sub>3 (condition\\<^sub>3 (product A B)) w r p} =\n    {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        p \\<in> initial\\<^sub>1 A \\<and>\n        a.run' A (w ||| r) p \\<and>\n        test\\<^sub>1 (condition\\<^sub>1 A) w r p} \\<inter>\n    {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        p \\<in> initial\\<^sub>2 B \\<and>\n        b.run' B (w ||| r) p \\<and>\n        test\\<^sub>2 (condition\\<^sub>2 B) w r p}", "by (fastforce iff: split_szip)"], ["", "end"], ["", "locale automaton_sum =\n    a: automaton automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 +\n    b: automaton automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 +\n    c: automaton automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n    for automaton\\<^sub>1 :: \"'label set \\<Rightarrow> 'state\\<^sub>1 set \\<Rightarrow> ('label \\<Rightarrow> 'state\\<^sub>1 \\<Rightarrow> 'state\\<^sub>1 set) \\<Rightarrow> 'condition\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>1\"\n    and alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n    and automaton\\<^sub>2 :: \"'label set \\<Rightarrow> 'state\\<^sub>2 set \\<Rightarrow> ('label \\<Rightarrow> 'state\\<^sub>2 \\<Rightarrow> 'state\\<^sub>2 set) \\<Rightarrow> 'condition\\<^sub>2 \\<Rightarrow> 'automaton\\<^sub>2\"\n    and alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    and automaton\\<^sub>3 :: \"'label set \\<Rightarrow> ('state\\<^sub>1 + 'state\\<^sub>2) set \\<Rightarrow> ('label \\<Rightarrow> 'state\\<^sub>1 + 'state\\<^sub>2 \\<Rightarrow> ('state\\<^sub>1 + 'state\\<^sub>2) set) \\<Rightarrow> 'condition\\<^sub>3 \\<Rightarrow> 'automaton\\<^sub>3\"\n    and alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n    +\n    fixes condition :: \"'condition\\<^sub>1 \\<Rightarrow> 'condition\\<^sub>2 \\<Rightarrow> 'condition\\<^sub>3\"\n  begin"], ["", "definition sum :: \"'automaton\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>2 \\<Rightarrow> 'automaton\\<^sub>3\" where\n      \"sum A B \\<equiv> automaton\\<^sub>3\n        (alphabet\\<^sub>1 A \\<union> alphabet\\<^sub>2 B)\n        (initial\\<^sub>1 A <+> initial\\<^sub>2 B)\n        (\\<lambda> a. \\<lambda> Inl p \\<Rightarrow> Inl ` transition\\<^sub>1 A a p | Inr q \\<Rightarrow> Inr ` transition\\<^sub>2 B a q)\n        (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))\""], ["", "lemma sum_simps[simp]:\n      \"alphabet\\<^sub>3 (sum A B) = alphabet\\<^sub>1 A \\<union> alphabet\\<^sub>2 B\"\n      \"initial\\<^sub>3 (sum A B) = initial\\<^sub>1 A <+> initial\\<^sub>2 B\"\n      \"transition\\<^sub>3 (sum A B) a (Inl p) = Inl ` transition\\<^sub>1 A a p\"\n      \"transition\\<^sub>3 (sum A B) a (Inr q) = Inr ` transition\\<^sub>2 B a q\"\n      \"condition\\<^sub>3 (sum A B) = condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>3 (local.sum A B) =\n     alphabet\\<^sub>1 A \\<union> alphabet\\<^sub>2 B &&&\n     initial\\<^sub>3 (local.sum A B) =\n     initial\\<^sub>1 A <+> initial\\<^sub>2 B) &&&\n    transition\\<^sub>3 (local.sum A B) a (Inl p) =\n    Inl ` transition\\<^sub>1 A a p &&&\n    transition\\<^sub>3 (local.sum A B) a (Inr q) =\n    Inr ` transition\\<^sub>2 B a q &&&\n    condition\\<^sub>3 (local.sum A B) =\n    condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)", "unfolding sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>3\n      (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<union> alphabet\\<^sub>2 B)\n        (initial\\<^sub>1 A <+> initial\\<^sub>2 B)\n        (\\<lambda>a x.\n            case x of Inl p \\<Rightarrow> Inl ` transition\\<^sub>1 A a p\n            | Inr q \\<Rightarrow> Inr ` transition\\<^sub>2 B a q)\n        (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))) =\n     alphabet\\<^sub>1 A \\<union> alphabet\\<^sub>2 B &&&\n     initial\\<^sub>3\n      (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<union> alphabet\\<^sub>2 B)\n        (initial\\<^sub>1 A <+> initial\\<^sub>2 B)\n        (\\<lambda>a x.\n            case x of Inl p \\<Rightarrow> Inl ` transition\\<^sub>1 A a p\n            | Inr q \\<Rightarrow> Inr ` transition\\<^sub>2 B a q)\n        (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))) =\n     initial\\<^sub>1 A <+> initial\\<^sub>2 B) &&&\n    transition\\<^sub>3\n     (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<union> alphabet\\<^sub>2 B)\n       (initial\\<^sub>1 A <+> initial\\<^sub>2 B)\n       (\\<lambda>a x.\n           case x of Inl p \\<Rightarrow> Inl ` transition\\<^sub>1 A a p\n           | Inr q \\<Rightarrow> Inr ` transition\\<^sub>2 B a q)\n       (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)))\n     a (Inl p) =\n    Inl ` transition\\<^sub>1 A a p &&&\n    transition\\<^sub>3\n     (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<union> alphabet\\<^sub>2 B)\n       (initial\\<^sub>1 A <+> initial\\<^sub>2 B)\n       (\\<lambda>a x.\n           case x of Inl p \\<Rightarrow> Inl ` transition\\<^sub>1 A a p\n           | Inr q \\<Rightarrow> Inr ` transition\\<^sub>2 B a q)\n       (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)))\n     a (Inr q) =\n    Inr ` transition\\<^sub>2 B a q &&&\n    condition\\<^sub>3\n     (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<union> alphabet\\<^sub>2 B)\n       (initial\\<^sub>1 A <+> initial\\<^sub>2 B)\n       (\\<lambda>a x.\n           case x of Inl p \\<Rightarrow> Inl ` transition\\<^sub>1 A a p\n           | Inr q \\<Rightarrow> Inr ` transition\\<^sub>2 B a q)\n       (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))) =\n    condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)", "by auto"], ["", "lemma path_sum_a:\n      assumes \"length r = length w\" \"a.path A (w || r) p\"\n      shows \"c.path (sum A B) (w || map Inl r) (Inl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.path' (local.sum A B) (w || map Inl r) (Inl p)", "using assms"], ["proof (prove)\nusing this:\n  length r = length w\n  a.path' A (w || r) p\n\ngoal (1 subgoal):\n 1. c.path' (local.sum A B) (w || map Inl r) (Inl p)", "by (induct arbitrary: p rule: list_induct2) (auto)"], ["", "lemma path_sum_b:\n      assumes \"length s = length w\" \"b.path B (w || s) q\"\n      shows \"c.path (sum A B) (w || map Inr s) (Inr q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.path' (local.sum A B) (w || map Inr s) (Inr q)", "using assms"], ["proof (prove)\nusing this:\n  length s = length w\n  b.path' B (w || s) q\n\ngoal (1 subgoal):\n 1. c.path' (local.sum A B) (w || map Inr s) (Inr q)", "by (induct arbitrary: q rule: list_induct2) (auto)"], ["", "lemma sum_path:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      assumes \"length rs = length w\" \"c.path (sum A B) (w || rs) pq\"\n      obtains\n        (a) r p where \"rs = map Inl r\" \"pq = Inl p\" \"a.path A (w || r) p\" |\n        (b) s q where \"rs = map Inr s\" \"pq = Inr q\" \"b.path B (w || s) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r p.\n                \\<lbrakk>rs = map Inl r; pq = Inl p;\n                 a.path' A (w || r) p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>s q.\n        \\<lbrakk>rs = map Inr s; pq = Inr q; b.path' B (w || s) q\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases pq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inl a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Inl p)"], ["proof (state)\nthis:\n  pq = Inl p\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inl a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 1: \"rs = map Inl (map projl rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs = map Inl (map projl rs)", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  length rs = length w\n  c.path' (local.sum A B) (w || rs) pq\n\ngoal (1 subgoal):\n 1. rs = map Inl (map projl rs)", "unfolding Inl"], ["proof (prove)\nusing this:\n  length rs = length w\n  c.path' (local.sum A B) (w || rs) (Inl p)\n\ngoal (1 subgoal):\n 1. rs = map Inl (map projl rs)", "by (induct arbitrary: p rule: list_induct2) (auto)"], ["proof (state)\nthis:\n  rs = map Inl (map projl rs)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inl a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 2: \"a.path A (w || map projl rs) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a.path' A (w || map projl rs) p", "using assms(2, 1, 3)"], ["proof (prove)\nusing this:\n  length rs = length w\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n  c.path' (local.sum A B) (w || rs) pq\n\ngoal (1 subgoal):\n 1. a.path' A (w || map projl rs) p", "unfolding Inl"], ["proof (prove)\nusing this:\n  length rs = length w\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n  c.path' (local.sum A B) (w || rs) (Inl p)\n\ngoal (1 subgoal):\n 1. a.path' A (w || map projl rs) p", "by (induct arbitrary: p rule: list_induct2) (auto)"], ["proof (state)\nthis:\n  a.path' A (w || map projl rs) p\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inl a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using a 1 Inl 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>rs = map Inl ?r; pq = Inl ?p; a.path' A (w || ?r) ?p\\<rbrakk>\n  \\<Longrightarrow> thesis\n  rs = map Inl (map projl rs)\n  pq = Inl p\n  a.path' A (w || map projl rs) p\n\ngoal (1 subgoal):\n 1. thesis", "by this"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Inr q)"], ["proof (state)\nthis:\n  pq = Inr q\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 1: \"rs = map Inr (map projr rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs = map Inr (map projr rs)", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  length rs = length w\n  c.path' (local.sum A B) (w || rs) pq\n\ngoal (1 subgoal):\n 1. rs = map Inr (map projr rs)", "unfolding Inr"], ["proof (prove)\nusing this:\n  length rs = length w\n  c.path' (local.sum A B) (w || rs) (Inr q)\n\ngoal (1 subgoal):\n 1. rs = map Inr (map projr rs)", "by (induct arbitrary: q rule: list_induct2) (auto)"], ["proof (state)\nthis:\n  rs = map Inr (map projr rs)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 2: \"b.path B (w || map projr rs) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.path' B (w || map projr rs) q", "using assms(2, 1, 3)"], ["proof (prove)\nusing this:\n  length rs = length w\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n  c.path' (local.sum A B) (w || rs) pq\n\ngoal (1 subgoal):\n 1. b.path' B (w || map projr rs) q", "unfolding Inr"], ["proof (prove)\nusing this:\n  length rs = length w\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n  c.path' (local.sum A B) (w || rs) (Inr q)\n\ngoal (1 subgoal):\n 1. b.path' B (w || map projr rs) q", "by (induct arbitrary: q rule: list_induct2) (auto)"], ["proof (state)\nthis:\n  b.path' B (w || map projr rs) q\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = map Inl r; pq = Inl p;\n                    a.path' A (w || r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = map Inr s; pq = Inr q;\n            b.path' B (w || s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using b 1 Inr 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>rs = map Inr ?s; pq = Inr ?q; b.path' B (w || ?s) ?q\\<rbrakk>\n  \\<Longrightarrow> thesis\n  rs = map Inr (map projr rs)\n  pq = Inr q\n  b.path' B (w || map projr rs) q\n\ngoal (1 subgoal):\n 1. thesis", "by this"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma run_sum_a:\n      assumes \"a.run A (w ||| r) p\"\n      shows \"c.run (sum A B) (w ||| smap Inl r) (Inl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.run' (local.sum A B) (w ||| smap Inl r) (Inl p)", "using assms"], ["proof (prove)\nusing this:\n  a.run' A (w ||| r) p\n\ngoal (1 subgoal):\n 1. c.run' (local.sum A B) (w ||| smap Inl r) (Inl p)", "by (coinduction arbitrary: w r p) (force elim: a.run.cases)"], ["", "lemma run_sum_b:\n      assumes \"b.run B (w ||| s) q\"\n      shows \"c.run (sum A B) (w ||| smap Inr s) (Inr q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.run' (local.sum A B) (w ||| smap Inr s) (Inr q)", "using assms"], ["proof (prove)\nusing this:\n  b.run' B (w ||| s) q\n\ngoal (1 subgoal):\n 1. c.run' (local.sum A B) (w ||| smap Inr s) (Inr q)", "by (coinduction arbitrary: w s q) (force elim: b.run.cases)"], ["", "lemma sum_run:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      assumes \"c.run (sum A B) (w ||| rs) pq\"\n      obtains\n        (a) r p where \"rs = smap Inl r\" \"pq = Inl p\" \"a.run A (w ||| r) p\" |\n        (b) s q where \"rs = smap Inr s\" \"pq = Inr q\" \"b.run B (w ||| s) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r p.\n                \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                 a.run' A (w ||| r) p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>s q.\n        \\<lbrakk>rs = smap Inr s; pq = Inr q; b.run' B (w ||| s) q\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases pq)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inl a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Inl p)"], ["proof (state)\nthis:\n  pq = Inl p\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inl a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 1: \"rs = smap Inl (smap projl rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs = smap Inl (smap projl rs)", "using assms(2)"], ["proof (prove)\nusing this:\n  c.run' (local.sum A B) (w ||| rs) pq\n\ngoal (1 subgoal):\n 1. rs = smap Inl (smap projl rs)", "unfolding Inl"], ["proof (prove)\nusing this:\n  c.run' (local.sum A B) (w ||| rs) (Inl p)\n\ngoal (1 subgoal):\n 1. rs = smap Inl (smap projl rs)", "by (coinduction arbitrary: w rs p) (force elim: c.run.cases)"], ["proof (state)\nthis:\n  rs = smap Inl (smap projl rs)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inl a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 2: \"a.run A (w ||| smap projl rs) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a.run' A (w ||| smap projl rs) p", "using assms"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n  c.run' (local.sum A B) (w ||| rs) pq\n\ngoal (1 subgoal):\n 1. a.run' A (w ||| smap projl rs) p", "unfolding Inl"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n  c.run' (local.sum A B) (w ||| rs) (Inl p)\n\ngoal (1 subgoal):\n 1. a.run' A (w ||| smap projl rs) p", "by (coinduction arbitrary: w rs p) (force elim: c.run.cases)"], ["proof (state)\nthis:\n  a.run' A (w ||| smap projl rs) p\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inl a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using a 1 Inl 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>rs = smap Inl ?r; pq = Inl ?p; a.run' A (w ||| ?r) ?p\\<rbrakk>\n  \\<Longrightarrow> thesis\n  rs = smap Inl (smap projl rs)\n  pq = Inl p\n  a.run' A (w ||| smap projl rs) p\n\ngoal (1 subgoal):\n 1. thesis", "by this"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Inr q)"], ["proof (state)\nthis:\n  pq = Inr q\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 1: \"rs = smap Inr (smap projr rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rs = smap Inr (smap projr rs)", "using assms(2)"], ["proof (prove)\nusing this:\n  c.run' (local.sum A B) (w ||| rs) pq\n\ngoal (1 subgoal):\n 1. rs = smap Inr (smap projr rs)", "unfolding Inr"], ["proof (prove)\nusing this:\n  c.run' (local.sum A B) (w ||| rs) (Inr q)\n\ngoal (1 subgoal):\n 1. rs = smap Inr (smap projr rs)", "by (coinduction arbitrary: w rs q) (force elim: c.run.cases)"], ["proof (state)\nthis:\n  rs = smap Inr (smap projr rs)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 2: \"b.run B (w ||| smap projr rs) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.run' B (w ||| smap projr rs) q", "using assms"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n  c.run' (local.sum A B) (w ||| rs) pq\n\ngoal (1 subgoal):\n 1. b.run' B (w ||| smap projr rs) q", "unfolding Inr"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n  c.run' (local.sum A B) (w ||| rs) (Inr q)\n\ngoal (1 subgoal):\n 1. b.run' B (w ||| smap projr rs) q", "by (coinduction arbitrary: w rs q) (force elim: c.run.cases)"], ["proof (state)\nthis:\n  b.run' B (w ||| smap projr rs) q\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>\\<And>r p.\n                   \\<lbrakk>rs = smap Inl r; pq = Inl p;\n                    a.run' A (w ||| r) p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>s q.\n           \\<lbrakk>rs = smap Inr s; pq = Inr q;\n            b.run' B (w ||| s) q\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        pq = Inr b\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using b 1 Inr 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>rs = smap Inr ?s; pq = Inr ?q; b.run' B (w ||| ?s) ?q\\<rbrakk>\n  \\<Longrightarrow> thesis\n  rs = smap Inr (smap projr rs)\n  pq = Inr q\n  b.run' B (w ||| smap projr rs) q\n\ngoal (1 subgoal):\n 1. thesis", "by this"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_nodes:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"c.nodes (sum A B) \\<subseteq> a.nodes A <+> b.nodes B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.nodes' (local.sum A B) \\<subseteq> a.nodes' A <+> b.nodes' B", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c.nodes' (local.sum A B) \\<Longrightarrow>\n       x \\<in> a.nodes' A <+> b.nodes' B", "fix pq"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c.nodes' (local.sum A B) \\<Longrightarrow>\n       x \\<in> a.nodes' A <+> b.nodes' B", "assume \"pq \\<in> c.nodes (sum A B)\""], ["proof (state)\nthis:\n  pq \\<in> c.nodes' (local.sum A B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c.nodes' (local.sum A B) \\<Longrightarrow>\n       x \\<in> a.nodes' A <+> b.nodes' B", "then"], ["proof (chain)\npicking this:\n  pq \\<in> c.nodes' (local.sum A B)", "show \"pq \\<in> a.nodes A <+> b.nodes B\""], ["proof (prove)\nusing this:\n  pq \\<in> c.nodes' (local.sum A B)\n\ngoal (1 subgoal):\n 1. pq \\<in> a.nodes' A <+> b.nodes' B", "using assms"], ["proof (prove)\nusing this:\n  pq \\<in> c.nodes' (local.sum A B)\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. pq \\<in> a.nodes' A <+> b.nodes' B", "by (induct) (auto 0 3)"], ["proof (state)\nthis:\n  pq \\<in> a.nodes' A <+> b.nodes' B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_nodes_finite[intro]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      assumes \"finite (a.nodes A)\" \"finite (b.nodes B)\"\n      shows \"finite (c.nodes (sum A B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (c.nodes' (local.sum A B))", "using finite_subset sum_nodes assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  alphabet\\<^sub>1 ?A = alphabet\\<^sub>2 ?B \\<Longrightarrow>\n  c.nodes' (local.sum ?A ?B) \\<subseteq> a.nodes' ?A <+> b.nodes' ?B\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n  finite (a.nodes' A)\n  finite (b.nodes' B)\n\ngoal (1 subgoal):\n 1. finite (c.nodes' (local.sum A B))", "by (auto intro: finite_Plus)"], ["", "end"], ["", "locale automaton_union_path =\n    automaton_sum\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n      condition +\n    a: automaton_path automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_path automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2 +\n    c: automaton_path automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    and condition\n    +\n    assumes test\\<^sub>1[iff]: \"length r = length w \\<Longrightarrow> test\\<^sub>3 (condition c\\<^sub>1 c\\<^sub>2) w (map Inl r) (Inl p) \\<longleftrightarrow> test\\<^sub>1 c\\<^sub>1 w r p\"\n    assumes test\\<^sub>2[iff]: \"length s = length w \\<Longrightarrow> test\\<^sub>3 (condition c\\<^sub>1 c\\<^sub>2) w (map Inr s) (Inr q) \\<longleftrightarrow> test\\<^sub>2 c\\<^sub>2 w s q\"\n  begin"], ["", "lemma sum_language[simp]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"c.language (sum A B) = a.language A \\<union> b.language B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.language (local.sum A B) = a.language A \\<union> b.language B", "using assms"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. c.language (local.sum A B) = a.language A \\<union> b.language B", "unfolding a.language_def b.language_def c.language_def"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        length r = length w \\<and>\n        p \\<in> initial\\<^sub>3 (local.sum A B) \\<and>\n        c.path' (local.sum A B) (w || r) p \\<and>\n        test\\<^sub>3 (condition\\<^sub>3 (local.sum A B)) w r p} =\n    {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        length r = length w \\<and>\n        p \\<in> initial\\<^sub>1 A \\<and>\n        a.path' A (w || r) p \\<and>\n        test\\<^sub>1 (condition\\<^sub>1 A) w r p} \\<union>\n    {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        length r = length w \\<and>\n        p \\<in> initial\\<^sub>2 B \\<and>\n        b.path' B (w || r) p \\<and>\n        test\\<^sub>2 (condition\\<^sub>2 B) w r p}", "by (force intro: path_sum_a path_sum_b elim!: sum_path)"], ["", "end"], ["", "locale automaton_union_run =\n    automaton_sum\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n      condition +\n    a: automaton_run automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_run automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2 +\n    c: automaton_run automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    and condition\n    +\n    assumes test\\<^sub>1[iff]: \"test\\<^sub>3 (condition c\\<^sub>1 c\\<^sub>2) w (smap Inl r) (Inl p) \\<longleftrightarrow> test\\<^sub>1 c\\<^sub>1 w r p\"\n    assumes test\\<^sub>2[iff]: \"test\\<^sub>3 (condition c\\<^sub>1 c\\<^sub>2) w (smap Inr s) (Inr q) \\<longleftrightarrow> test\\<^sub>2 c\\<^sub>2 w s q\"\n  begin"], ["", "lemma sum_language[simp]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"c.language (sum A B) = a.language A \\<union> b.language B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.language (local.sum A B) = a.language A \\<union> b.language B", "using assms"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. c.language (local.sum A B) = a.language A \\<union> b.language B", "unfolding a.language_def b.language_def c.language_def"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        p \\<in> initial\\<^sub>3 (local.sum A B) \\<and>\n        c.run' (local.sum A B) (w ||| r) p \\<and>\n        test\\<^sub>3 (condition\\<^sub>3 (local.sum A B)) w r p} =\n    {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        p \\<in> initial\\<^sub>1 A \\<and>\n        a.run' A (w ||| r) p \\<and>\n        test\\<^sub>1 (condition\\<^sub>1 A) w r p} \\<union>\n    {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        p \\<in> initial\\<^sub>2 B \\<and>\n        b.run' B (w ||| r) p \\<and>\n        test\\<^sub>2 (condition\\<^sub>2 B) w r p}", "by (auto intro: run_sum_a run_sum_b elim!: sum_run)"], ["", "end"], ["", "locale automaton_product_list =\n    a: automaton automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 +\n    b: automaton automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    for automaton\\<^sub>1 :: \"'label set \\<Rightarrow> 'state set \\<Rightarrow> ('label \\<Rightarrow> 'state \\<Rightarrow> 'state set) \\<Rightarrow> 'condition\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>1\"\n    and alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n    and automaton\\<^sub>2 :: \"'label set \\<Rightarrow> 'state list set \\<Rightarrow> ('label \\<Rightarrow> 'state list \\<Rightarrow> 'state list set) \\<Rightarrow> 'condition\\<^sub>2 \\<Rightarrow> 'automaton\\<^sub>2\"\n    and alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    +\n    fixes condition :: \"'condition\\<^sub>1 list \\<Rightarrow> 'condition\\<^sub>2\"\n  begin"], ["", "definition product :: \"'automaton\\<^sub>1 list \\<Rightarrow> 'automaton\\<^sub>2\" where\n      \"product AA \\<equiv> automaton\\<^sub>2\n        (\\<Inter> (alphabet\\<^sub>1 ` set AA))\n        (listset (map initial\\<^sub>1 AA))\n        (\\<lambda> a ps. listset (map2 (\\<lambda> A p. transition\\<^sub>1 A a p) AA ps))\n        (condition (map condition\\<^sub>1 AA))\""], ["", "lemma product_simps[simp]:\n      \"alphabet\\<^sub>2 (product AA) = \\<Inter> (alphabet\\<^sub>1 ` set AA)\"\n      \"initial\\<^sub>2 (product AA) = listset (map initial\\<^sub>1 AA)\"\n      \"transition\\<^sub>2 (product AA) a ps = listset (map2 (\\<lambda> A p. transition\\<^sub>1 A a p) AA ps)\"\n      \"condition\\<^sub>2 (product AA) = condition (map condition\\<^sub>1 AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2 (product AA) =\n     \\<Inter> (alphabet\\<^sub>1 ` set AA) &&&\n     initial\\<^sub>2 (product AA) = listset (map initial\\<^sub>1 AA)) &&&\n    transition\\<^sub>2 (product AA) a ps =\n    listset (map2 (\\<lambda>x. transition\\<^sub>1 x a) AA ps) &&&\n    condition\\<^sub>2 (product AA) = condition (map condition\\<^sub>1 AA)", "unfolding product_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2\n      (automaton\\<^sub>2 (\\<Inter> (alphabet\\<^sub>1 ` set AA))\n        (listset (map initial\\<^sub>1 AA))\n        (\\<lambda>a ps.\n            listset (map2 (\\<lambda>x. transition\\<^sub>1 x a) AA ps))\n        (condition (map condition\\<^sub>1 AA))) =\n     \\<Inter> (alphabet\\<^sub>1 ` set AA) &&&\n     initial\\<^sub>2\n      (automaton\\<^sub>2 (\\<Inter> (alphabet\\<^sub>1 ` set AA))\n        (listset (map initial\\<^sub>1 AA))\n        (\\<lambda>a ps.\n            listset (map2 (\\<lambda>x. transition\\<^sub>1 x a) AA ps))\n        (condition (map condition\\<^sub>1 AA))) =\n     listset (map initial\\<^sub>1 AA)) &&&\n    transition\\<^sub>2\n     (automaton\\<^sub>2 (\\<Inter> (alphabet\\<^sub>1 ` set AA))\n       (listset (map initial\\<^sub>1 AA))\n       (\\<lambda>a ps.\n           listset (map2 (\\<lambda>x. transition\\<^sub>1 x a) AA ps))\n       (condition (map condition\\<^sub>1 AA)))\n     a ps =\n    listset (map2 (\\<lambda>x. transition\\<^sub>1 x a) AA ps) &&&\n    condition\\<^sub>2\n     (automaton\\<^sub>2 (\\<Inter> (alphabet\\<^sub>1 ` set AA))\n       (listset (map initial\\<^sub>1 AA))\n       (\\<lambda>a ps.\n           listset (map2 (\\<lambda>x. transition\\<^sub>1 x a) AA ps))\n       (condition (map condition\\<^sub>1 AA))) =\n    condition (map condition\\<^sub>1 AA)", "by auto"], ["", "lemma product_run_length:\n      assumes \"length ps = length AA\"\n      assumes \"b.run (product AA) (w ||| r) ps\"\n      assumes \"qs \\<in> sset r\"\n      shows \"length qs = length AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = length AA", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length qs = length AA", "have \"pred_stream (\\<lambda> qs. length qs = length AA) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>qs. length qs = length AA) r", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  length ps = length AA\n  b.run' (product AA) (w ||| r) ps\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>qs. length qs = length AA) r", "by (coinduction arbitrary: w r ps)\n          (force elim: b.run.cases simp: listset_member list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  pred_stream (\\<lambda>qs. length qs = length AA) r\n\ngoal (1 subgoal):\n 1. length qs = length AA", "then"], ["proof (chain)\npicking this:\n  pred_stream (\\<lambda>qs. length qs = length AA) r", "show ?thesis"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>qs. length qs = length AA) r\n\ngoal (1 subgoal):\n 1. length qs = length AA", "using assms(3)"], ["proof (prove)\nusing this:\n  pred_stream (\\<lambda>qs. length qs = length AA) r\n  qs \\<in> sset r\n\ngoal (1 subgoal):\n 1. length qs = length AA", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  \\<forall>qs\\<in>sset r. length qs = length AA\n  qs \\<in> sset r\n\ngoal (1 subgoal):\n 1. length qs = length AA", "by auto"], ["proof (state)\nthis:\n  length qs = length AA\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_run_stranspose:\n      assumes \"length ps = length AA\"\n      assumes \"b.run (product AA) (w ||| r) ps\"\n      obtains rs where \"r = stranspose rs\" \"length rs = length AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>r = stranspose rs; length rs = length AA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>rs.\n        \\<lbrakk>r = stranspose rs; length rs = length AA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    r = stranspose ?rs2\n 2. (\\<And>rs.\n        \\<lbrakk>r = stranspose rs; length rs = length AA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length ?rs2 = length AA", "define rs where \"rs \\<equiv> map (\\<lambda> k. smap (\\<lambda> ps. ps ! k) r) [0 ..< length AA]\""], ["proof (state)\nthis:\n  rs \\<equiv> map (\\<lambda>k. smap (\\<lambda>ps. ps ! k) r) [0..<length AA]\n\ngoal (2 subgoals):\n 1. (\\<And>rs.\n        \\<lbrakk>r = stranspose rs; length rs = length AA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    r = stranspose ?rs2\n 2. (\\<And>rs.\n        \\<lbrakk>r = stranspose rs; length rs = length AA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length ?rs2 = length AA", "have \"length qs = length AA\" if \"qs \\<in> sset r\" for qs"], ["proof (prove)\ngoal (1 subgoal):\n 1. length qs = length AA", "using product_run_length assms that"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?ps = length ?AA; b.run' (product ?AA) (?w ||| ?r) ?ps;\n   ?qs \\<in> sset ?r\\<rbrakk>\n  \\<Longrightarrow> length ?qs = length ?AA\n  length ps = length AA\n  b.run' (product AA) (w ||| r) ps\n  qs \\<in> sset r\n\ngoal (1 subgoal):\n 1. length qs = length AA", "by this"], ["proof (state)\nthis:\n  ?qs \\<in> sset r \\<Longrightarrow> length ?qs = length AA\n\ngoal (2 subgoals):\n 1. (\\<And>rs.\n        \\<lbrakk>r = stranspose rs; length rs = length AA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    r = stranspose ?rs2\n 2. (\\<And>rs.\n        \\<lbrakk>r = stranspose rs; length rs = length AA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length ?rs2 = length AA", "then"], ["proof (chain)\npicking this:\n  ?qs \\<in> sset r \\<Longrightarrow> length ?qs = length AA", "show \"r = stranspose rs\""], ["proof (prove)\nusing this:\n  ?qs \\<in> sset r \\<Longrightarrow> length ?qs = length AA\n\ngoal (1 subgoal):\n 1. r = stranspose rs", "unfolding rs_def"], ["proof (prove)\nusing this:\n  ?qs \\<in> sset r \\<Longrightarrow> length ?qs = length AA\n\ngoal (1 subgoal):\n 1. r =\n    stranspose\n     (map (\\<lambda>k. smap (\\<lambda>ps. ps ! k) r) [0..<length AA])", "by (coinduction arbitrary: r) (force intro: nth_equalityI simp: comp_def)"], ["proof (state)\nthis:\n  r = stranspose rs\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>r = stranspose rs; length rs = length AA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    length\n     (map (\\<lambda>k. smap (\\<lambda>ps. ps ! k) r) [0..<length AA]) =\n    length AA", "show \"length rs = length AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length rs = length AA", "unfolding rs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>k. smap (\\<lambda>ps. ps ! k) r) [0..<length AA]) =\n    length AA", "by auto"], ["proof (state)\nthis:\n  length rs = length AA\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma run_product:\n      assumes \"length rs = length AA\" \"length ps = length AA\"\n      assumes \"\\<And> k. k < length AA \\<Longrightarrow> a.run (AA ! k) (w ||| rs ! k) (ps ! k)\"\n      shows \"b.run (product AA) (w ||| stranspose rs) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.run' (product AA) (w ||| stranspose rs) ps", "using assms"], ["proof (prove)\nusing this:\n  length rs = length AA\n  length ps = length AA\n  ?k < length AA \\<Longrightarrow>\n  a.run' (AA ! ?k) (w ||| rs ! ?k) (ps ! ?k)\n\ngoal (1 subgoal):\n 1. b.run' (product AA) (w ||| stranspose rs) ps", "proof (coinduction arbitrary: w rs ps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a r w rs ps.\n       \\<lbrakk>a ## r = w ||| stranspose rs; length rs = length AA;\n        length ps = length AA;\n        \\<forall>k<length AA.\n           a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n       \\<Longrightarrow> (fst a \\<in> alphabet\\<^sub>2 (product AA) \\<and>\n                          snd a\n                          \\<in> transition\\<^sub>2 (product AA) (fst a)\n                                 ps) \\<and>\n                         (\\<exists>w rs ps.\n                             r = w ||| stranspose rs \\<and>\n                             snd a = ps \\<and>\n                             length rs = length AA \\<and>\n                             length ps = length AA \\<and>\n                             (\\<forall>k<length AA.\n                                 a.run' (AA ! k) (w ||| rs ! k) (ps ! k)))", "case (run ap r)"], ["proof (state)\nthis:\n  ap ## r = w ||| stranspose rs\n  length rs = length AA\n  length ps = length AA\n  \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\n\ngoal (1 subgoal):\n 1. \\<And>a r w rs ps.\n       \\<lbrakk>a ## r = w ||| stranspose rs; length rs = length AA;\n        length ps = length AA;\n        \\<forall>k<length AA.\n           a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n       \\<Longrightarrow> (fst a \\<in> alphabet\\<^sub>2 (product AA) \\<and>\n                          snd a\n                          \\<in> transition\\<^sub>2 (product AA) (fst a)\n                                 ps) \\<and>\n                         (\\<exists>w rs ps.\n                             r = w ||| stranspose rs \\<and>\n                             snd a = ps \\<and>\n                             length rs = length AA \\<and>\n                             length ps = length AA \\<and>\n                             (\\<forall>k<length AA.\n                                 a.run' (AA ! k) (w ||| rs ! k) (ps ! k)))", "then"], ["proof (chain)\npicking this:\n  ap ## r = w ||| stranspose rs\n  length rs = length AA\n  length ps = length AA\n  \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)", "show ?case"], ["proof (prove)\nusing this:\n  ap ## r = w ||| stranspose rs\n  length rs = length AA\n  length ps = length AA\n  \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\n\ngoal (1 subgoal):\n 1. (fst ap \\<in> alphabet\\<^sub>2 (product AA) \\<and>\n     snd ap \\<in> transition\\<^sub>2 (product AA) (fst ap) ps) \\<and>\n    (\\<exists>w rs ps.\n        r = w ||| stranspose rs \\<and>\n        snd ap = ps \\<and>\n        length rs = length AA \\<and>\n        length ps = length AA \\<and>\n        (\\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)))", "proof (intro conjI exI)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> fst ap \\<in> alphabet\\<^sub>2 (product AA)\n 2. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> snd ap\n                      \\<in> transition\\<^sub>2 (product AA) (fst ap) ps\n 3. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> r = ?w5 ||| stranspose ?rs6\n 4. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> snd ap = ?ps7\n 5. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> length ?rs6 = length AA\n 6. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> length ?ps7 = length AA\n 7. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length AA.\n                         a.run' (AA ! k) (?w5 ||| ?rs6 ! k) (?ps7 ! k)", "show \"fst ap \\<in> alphabet\\<^sub>2 (product AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ap \\<in> alphabet\\<^sub>2 (product AA)", "using run"], ["proof (prove)\nusing this:\n  ap ## r = w ||| stranspose rs\n  length rs = length AA\n  length ps = length AA\n  \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\n\ngoal (1 subgoal):\n 1. fst ap \\<in> alphabet\\<^sub>2 (product AA)", "by (force elim: a.run.cases simp: set_conv_nth)"], ["proof (state)\nthis:\n  fst ap \\<in> alphabet\\<^sub>2 (product AA)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> snd ap\n                      \\<in> transition\\<^sub>2 (product AA) (fst ap) ps\n 2. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> r = ?w5 ||| stranspose ?rs6\n 3. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> snd ap = ?ps7\n 4. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> length ?rs6 = length AA\n 5. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> length ?ps7 = length AA\n 6. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length AA.\n                         a.run' (AA ! k) (?w5 ||| ?rs6 ! k) (?ps7 ! k)", "show \"snd ap \\<in> transition\\<^sub>2 (product AA) (fst ap) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ap \\<in> transition\\<^sub>2 (product AA) (fst ap) ps", "using run"], ["proof (prove)\nusing this:\n  ap ## r = w ||| stranspose rs\n  length rs = length AA\n  length ps = length AA\n  \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\n\ngoal (1 subgoal):\n 1. snd ap \\<in> transition\\<^sub>2 (product AA) (fst ap) ps", "by (force elim: a.run.cases simp: listset_member list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  snd ap \\<in> transition\\<^sub>2 (product AA) (fst ap) ps\n\ngoal (5 subgoals):\n 1. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> r = ?w5 ||| stranspose ?rs6\n 2. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> snd ap = ?ps7\n 3. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> length ?rs6 = length AA\n 4. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> length ?ps7 = length AA\n 5. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k<length AA.\n                         a.run' (AA ! k) (?w5 ||| ?rs6 ! k) (?ps7 ! k)", "show \"\\<forall> k < length AA. a.run' (AA ! k) (stl w ||| map stl rs ! k) (map shd rs ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length AA.\n       a.run' (AA ! k) (stl w ||| map stl rs ! k) (map shd rs ! k)", "using run"], ["proof (prove)\nusing this:\n  ap ## r = w ||| stranspose rs\n  length rs = length AA\n  length ps = length AA\n  \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\n\ngoal (1 subgoal):\n 1. \\<forall>k<length AA.\n       a.run' (AA ! k) (stl w ||| map stl rs ! k) (map shd rs ! k)", "by (force elim: a.run.cases)"], ["proof (state)\nthis:\n  \\<forall>k<length AA.\n     a.run' (AA ! k) (stl w ||| map stl rs ! k) (map shd rs ! k)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> r = stl w ||| stranspose (map stl rs)\n 2. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> snd ap = map shd rs\n 3. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> length (map stl rs) = length AA\n 4. \\<lbrakk>ap ## r = w ||| stranspose rs; length rs = length AA;\n     length ps = length AA;\n     \\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)\\<rbrakk>\n    \\<Longrightarrow> length (map shd rs) = length AA", "qed auto"], ["proof (state)\nthis:\n  (fst ap \\<in> alphabet\\<^sub>2 (product AA) \\<and>\n   snd ap \\<in> transition\\<^sub>2 (product AA) (fst ap) ps) \\<and>\n  (\\<exists>w rs ps.\n      r = w ||| stranspose rs \\<and>\n      snd ap = ps \\<and>\n      length rs = length AA \\<and>\n      length ps = length AA \\<and>\n      (\\<forall>k<length AA. a.run' (AA ! k) (w ||| rs ! k) (ps ! k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_run:\n      assumes \"length rs = length AA\" \"length ps = length AA\"\n      assumes \"b.run (product AA) (w ||| stranspose rs) ps\"\n      shows \"k < length AA \\<Longrightarrow> a.run (AA ! k) (w ||| rs ! k) (ps ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length AA \\<Longrightarrow> a.run' (AA ! k) (w ||| rs ! k) (ps ! k)", "using assms"], ["proof (prove)\nusing this:\n  length rs = length AA\n  length ps = length AA\n  b.run' (product AA) (w ||| stranspose rs) ps\n\ngoal (1 subgoal):\n 1. k < length AA \\<Longrightarrow> a.run' (AA ! k) (w ||| rs ! k) (ps ! k)", "proof (coinduction arbitrary: w rs ps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a r w rs ps.\n       \\<lbrakk>a ## r = w ||| rs ! k; k < length AA; length rs = length AA;\n        length ps = length AA;\n        b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n       \\<Longrightarrow> (fst a \\<in> alphabet\\<^sub>1 (AA ! k) \\<and>\n                          snd a\n                          \\<in> transition\\<^sub>1 (AA ! k) (fst a)\n                                 (ps ! k)) \\<and>\n                         (\\<exists>w rs ps.\n                             r = w ||| rs ! k \\<and>\n                             snd a = ps ! k \\<and>\n                             k < length AA \\<and>\n                             length rs = length AA \\<and>\n                             length ps = length AA \\<and>\n                             b.run' (product AA) (w ||| stranspose rs) ps)", "case (run ap wr)"], ["proof (state)\nthis:\n  ap ## wr = w ||| rs ! k\n  k < length AA\n  length rs = length AA\n  length ps = length AA\n  b.run' (product AA) (w ||| stranspose rs) ps\n\ngoal (1 subgoal):\n 1. \\<And>a r w rs ps.\n       \\<lbrakk>a ## r = w ||| rs ! k; k < length AA; length rs = length AA;\n        length ps = length AA;\n        b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n       \\<Longrightarrow> (fst a \\<in> alphabet\\<^sub>1 (AA ! k) \\<and>\n                          snd a\n                          \\<in> transition\\<^sub>1 (AA ! k) (fst a)\n                                 (ps ! k)) \\<and>\n                         (\\<exists>w rs ps.\n                             r = w ||| rs ! k \\<and>\n                             snd a = ps ! k \\<and>\n                             k < length AA \\<and>\n                             length rs = length AA \\<and>\n                             length ps = length AA \\<and>\n                             b.run' (product AA) (w ||| stranspose rs) ps)", "then"], ["proof (chain)\npicking this:\n  ap ## wr = w ||| rs ! k\n  k < length AA\n  length rs = length AA\n  length ps = length AA\n  b.run' (product AA) (w ||| stranspose rs) ps", "show ?case"], ["proof (prove)\nusing this:\n  ap ## wr = w ||| rs ! k\n  k < length AA\n  length rs = length AA\n  length ps = length AA\n  b.run' (product AA) (w ||| stranspose rs) ps\n\ngoal (1 subgoal):\n 1. (fst ap \\<in> alphabet\\<^sub>1 (AA ! k) \\<and>\n     snd ap \\<in> transition\\<^sub>1 (AA ! k) (fst ap) (ps ! k)) \\<and>\n    (\\<exists>w rs ps.\n        wr = w ||| rs ! k \\<and>\n        snd ap = ps ! k \\<and>\n        k < length AA \\<and>\n        length rs = length AA \\<and>\n        length ps = length AA \\<and>\n        b.run' (product AA) (w ||| stranspose rs) ps)", "proof (intro exI conjI)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> fst ap \\<in> alphabet\\<^sub>1 (AA ! k)\n 2. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> snd ap\n                      \\<in> transition\\<^sub>1 (AA ! k) (fst ap) (ps ! k)\n 3. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> wr = ?w6 ||| ?rs7 ! k\n 4. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> snd ap = ?ps8 ! k\n 5. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> k < length AA\n 6. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> length ?rs7 = length AA\n 7. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> length ?ps8 = length AA\n 8. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> b.run' (product AA) (?w6 ||| stranspose ?rs7) ?ps8", "show \"fst ap \\<in> alphabet\\<^sub>1 (AA ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ap \\<in> alphabet\\<^sub>1 (AA ! k)", "using run"], ["proof (prove)\nusing this:\n  ap ## wr = w ||| rs ! k\n  k < length AA\n  length rs = length AA\n  length ps = length AA\n  b.run' (product AA) (w ||| stranspose rs) ps\n\ngoal (1 subgoal):\n 1. fst ap \\<in> alphabet\\<^sub>1 (AA ! k)", "by (force elim: b.run.cases)"], ["proof (state)\nthis:\n  fst ap \\<in> alphabet\\<^sub>1 (AA ! k)\n\ngoal (7 subgoals):\n 1. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> snd ap\n                      \\<in> transition\\<^sub>1 (AA ! k) (fst ap) (ps ! k)\n 2. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> wr = ?w6 ||| ?rs7 ! k\n 3. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> snd ap = ?ps8 ! k\n 4. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> k < length AA\n 5. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> length ?rs7 = length AA\n 6. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> length ?ps8 = length AA\n 7. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> b.run' (product AA) (?w6 ||| stranspose ?rs7) ?ps8", "show \"snd ap \\<in> transition\\<^sub>1 (AA ! k) (fst ap) (ps ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ap \\<in> transition\\<^sub>1 (AA ! k) (fst ap) (ps ! k)", "using run"], ["proof (prove)\nusing this:\n  ap ## wr = w ||| rs ! k\n  k < length AA\n  length rs = length AA\n  length ps = length AA\n  b.run' (product AA) (w ||| stranspose rs) ps\n\ngoal (1 subgoal):\n 1. snd ap \\<in> transition\\<^sub>1 (AA ! k) (fst ap) (ps ! k)", "by (force elim: b.run.cases simp: listset_member list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  snd ap \\<in> transition\\<^sub>1 (AA ! k) (fst ap) (ps ! k)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> wr = ?w6 ||| ?rs7 ! k\n 2. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> snd ap = ?ps8 ! k\n 3. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> k < length AA\n 4. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> length ?rs7 = length AA\n 5. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> length ?ps8 = length AA\n 6. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> b.run' (product AA) (?w6 ||| stranspose ?rs7) ?ps8", "show \"b.run' (product AA) (stl w ||| stranspose (map stl rs)) (shd (stranspose rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.run' (product AA) (stl w ||| stranspose (map stl rs))\n     (shd (stranspose rs))", "using run"], ["proof (prove)\nusing this:\n  ap ## wr = w ||| rs ! k\n  k < length AA\n  length rs = length AA\n  length ps = length AA\n  b.run' (product AA) (w ||| stranspose rs) ps\n\ngoal (1 subgoal):\n 1. b.run' (product AA) (stl w ||| stranspose (map stl rs))\n     (shd (stranspose rs))", "by (force elim: b.run.cases)"], ["proof (state)\nthis:\n  b.run' (product AA) (stl w ||| stranspose (map stl rs))\n   (shd (stranspose rs))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> wr = stl w ||| map stl rs ! k\n 2. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> snd ap = shd (stranspose rs) ! k\n 3. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> k < length AA\n 4. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> length (map stl rs) = length AA\n 5. \\<lbrakk>ap ## wr = w ||| rs ! k; k < length AA; length rs = length AA;\n     length ps = length AA;\n     b.run' (product AA) (w ||| stranspose rs) ps\\<rbrakk>\n    \\<Longrightarrow> length (shd (stranspose rs)) = length AA", "qed auto"], ["proof (state)\nthis:\n  (fst ap \\<in> alphabet\\<^sub>1 (AA ! k) \\<and>\n   snd ap \\<in> transition\\<^sub>1 (AA ! k) (fst ap) (ps ! k)) \\<and>\n  (\\<exists>w rs ps.\n      wr = w ||| rs ! k \\<and>\n      snd ap = ps ! k \\<and>\n      k < length AA \\<and>\n      length rs = length AA \\<and>\n      length ps = length AA \\<and>\n      b.run' (product AA) (w ||| stranspose rs) ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_nodes: \"b.nodes (product AA) \\<subseteq> listset (map a.nodes AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.nodes' (product AA) \\<subseteq> listset (map a.nodes' AA)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> b.nodes' (product AA) \\<Longrightarrow>\n       x \\<in> listset (map a.nodes' AA)", "show \"ps \\<in> listset (map a.nodes AA)\" if \"ps \\<in> b.nodes (product AA)\" for ps"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<in> listset (map a.nodes' AA)", "using that"], ["proof (prove)\nusing this:\n  ps \\<in> b.nodes' (product AA)\n\ngoal (1 subgoal):\n 1. ps \\<in> listset (map a.nodes' AA)", "by (induct) (auto 0 3 simp: listset_member list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  ?ps \\<in> b.nodes' (product AA) \\<Longrightarrow>\n  ?ps \\<in> listset (map a.nodes' AA)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_nodes_finite[intro]:\n      assumes \"list_all (finite \\<circ> a.nodes) AA\"\n      shows \"finite (b.nodes (product AA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (b.nodes' (product AA))", "using list.pred_map product_nodes assms"], ["proof (prove)\nusing this:\n  list_all ?Q (map ?f ?x) = list_all (?Q \\<circ> ?f) ?x\n  b.nodes' (product ?AA) \\<subseteq> listset (map a.nodes' ?AA)\n  list_all (finite \\<circ> a.nodes') AA\n\ngoal (1 subgoal):\n 1. finite (b.nodes' (product AA))", "by (blast dest: finite_subset)"], ["", "lemma product_nodes_card:\n      assumes \"list_all (finite \\<circ> a.nodes) AA\"\n      shows \"card (b.nodes (product AA)) \\<le> prod_list (map (card \\<circ> a.nodes) AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "have \"card (b.nodes (product AA)) \\<le> card (listset (map a.nodes AA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA)) \\<le> card (listset (map a.nodes' AA))", "using list.pred_map product_nodes assms"], ["proof (prove)\nusing this:\n  list_all ?Q (map ?f ?x) = list_all (?Q \\<circ> ?f) ?x\n  b.nodes' (product ?AA) \\<subseteq> listset (map a.nodes' ?AA)\n  list_all (finite \\<circ> a.nodes') AA\n\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA)) \\<le> card (listset (map a.nodes' AA))", "by (blast intro: card_mono)"], ["proof (state)\nthis:\n  card (b.nodes' (product AA)) \\<le> card (listset (map a.nodes' AA))\n\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "also"], ["proof (state)\nthis:\n  card (b.nodes' (product AA)) \\<le> card (listset (map a.nodes' AA))\n\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "have \"\\<dots> = prod_list (map (card \\<circ> a.nodes) AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (listset (map a.nodes' AA)) =\n    prod_list (map (card \\<circ> a.nodes') AA)", "by simp"], ["proof (state)\nthis:\n  card (listset (map a.nodes' AA)) =\n  prod_list (map (card \\<circ> a.nodes') AA)\n\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "finally"], ["proof (chain)\npicking this:\n  card (b.nodes' (product AA))\n  \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (b.nodes' (product AA))\n  \\<le> prod_list (map (card \\<circ> a.nodes') AA)\n\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "by this"], ["proof (state)\nthis:\n  card (b.nodes' (product AA))\n  \\<le> prod_list (map (card \\<circ> a.nodes') AA)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale automaton_intersection_list_run =\n    automaton_product_list\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      condition +\n    a: automaton_run automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_run automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and condition\n    +\n    assumes test[iff]: \"length rs = length cs \\<Longrightarrow> length ps = length cs \\<Longrightarrow>\n      test\\<^sub>2 (condition cs) w (stranspose rs) ps \\<longleftrightarrow> list_all (\\<lambda> (c, r, p). test\\<^sub>1 c w r p) (cs || rs || ps)\"\n  begin"], ["", "lemma product_language[simp]: \"b.language (product AA) = \\<Inter> (a.language ` set AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.language (product AA) = \\<Inter> (a.language ` set AA)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> b.language (product AA); xa \\<in> set AA\\<rbrakk>\n       \\<Longrightarrow> x \\<in> a.language xa\n 2. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "fix A w"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> b.language (product AA); xa \\<in> set AA\\<rbrakk>\n       \\<Longrightarrow> x \\<in> a.language xa\n 2. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "assume 1: \"w \\<in> b.language (product AA)\" \"A \\<in> set AA\""], ["proof (state)\nthis:\n  w \\<in> b.language (product AA)\n  A \\<in> set AA\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> b.language (product AA); xa \\<in> set AA\\<rbrakk>\n       \\<Longrightarrow> x \\<in> a.language xa\n 2. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "obtain r ps where 2:\n        \"ps \\<in> initial\\<^sub>2 (product AA)\"\n        \"b.run (product AA) (w ||| r) ps\"\n        \"test\\<^sub>2 (condition\\<^sub>2 (product AA)) w r ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps r.\n        \\<lbrakk>ps \\<in> initial\\<^sub>2 (product AA);\n         b.run' (product AA) (w ||| r) ps;\n         test\\<^sub>2 (condition\\<^sub>2 (product AA)) w r ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1(1)"], ["proof (prove)\nusing this:\n  w \\<in> b.language (product AA)\n\ngoal (1 subgoal):\n 1. (\\<And>ps r.\n        \\<lbrakk>ps \\<in> initial\\<^sub>2 (product AA);\n         b.run' (product AA) (w ||| r) ps;\n         test\\<^sub>2 (condition\\<^sub>2 (product AA)) w r ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ps \\<in> initial\\<^sub>2 (product AA)\n  b.run' (product AA) (w ||| r) ps\n  test\\<^sub>2 (condition\\<^sub>2 (product AA)) w r ps\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> b.language (product AA); xa \\<in> set AA\\<rbrakk>\n       \\<Longrightarrow> x \\<in> a.language xa\n 2. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "have 3: \"length ps = length AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ps = length AA", "using 2(1)"], ["proof (prove)\nusing this:\n  ps \\<in> initial\\<^sub>2 (product AA)\n\ngoal (1 subgoal):\n 1. length ps = length AA", "by (simp add: listset_member list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  length ps = length AA\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> b.language (product AA); xa \\<in> set AA\\<rbrakk>\n       \\<Longrightarrow> x \\<in> a.language xa\n 2. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "obtain rs where 4: \"r = stranspose rs\" \"length rs = length AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>r = stranspose rs; length rs = length AA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using product_run_stranspose 3 2(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?ps = length ?AA; b.run' (product ?AA) (?w ||| ?r) ?ps;\n   \\<And>rs.\n      \\<lbrakk>?r = stranspose rs; length rs = length ?AA\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  length ps = length AA\n  b.run' (product AA) (w ||| r) ps\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>r = stranspose rs; length rs = length AA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  r = stranspose rs\n  length rs = length AA\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> b.language (product AA); xa \\<in> set AA\\<rbrakk>\n       \\<Longrightarrow> x \\<in> a.language xa\n 2. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "obtain k where 5: \"k < length AA\" \"A = AA ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length AA; A = AA ! k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1(2)"], ["proof (prove)\nusing this:\n  A \\<in> set AA\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length AA; A = AA ! k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  A \\<in> {AA ! i |i. i < length AA}\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length AA; A = AA ! k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k < length AA\n  A = AA ! k\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> b.language (product AA); xa \\<in> set AA\\<rbrakk>\n       \\<Longrightarrow> x \\<in> a.language xa\n 2. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "show \"w \\<in> a.language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> a.language A", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?p \\<in> initial\\<^sub>1 A\n 2. a.run' A (w ||| ?r) ?p\n 3. test\\<^sub>1 (condition\\<^sub>1 A) w ?r ?p", "show \"ps ! k \\<in> initial\\<^sub>1 A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps ! k \\<in> initial\\<^sub>1 A", "using 2(1) 5"], ["proof (prove)\nusing this:\n  ps \\<in> initial\\<^sub>2 (product AA)\n  k < length AA\n  A = AA ! k\n\ngoal (1 subgoal):\n 1. ps ! k \\<in> initial\\<^sub>1 A", "by (auto simp: listset_member list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  ps ! k \\<in> initial\\<^sub>1 A\n\ngoal (2 subgoals):\n 1. a.run' A (w ||| ?r) (ps ! k)\n 2. test\\<^sub>1 (condition\\<^sub>1 A) w ?r (ps ! k)", "show \"a.run A (w ||| rs ! k) (ps ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a.run' A (w ||| rs ! k) (ps ! k)", "using 2(2) 3 4 5"], ["proof (prove)\nusing this:\n  b.run' (product AA) (w ||| r) ps\n  length ps = length AA\n  r = stranspose rs\n  length rs = length AA\n  k < length AA\n  A = AA ! k\n\ngoal (1 subgoal):\n 1. a.run' A (w ||| rs ! k) (ps ! k)", "by (auto intro: product_run)"], ["proof (state)\nthis:\n  a.run' A (w ||| rs ! k) (ps ! k)\n\ngoal (1 subgoal):\n 1. test\\<^sub>1 (condition\\<^sub>1 A) w (rs ! k) (ps ! k)", "show \"test\\<^sub>1 (condition\\<^sub>1 A) w (rs ! k) (ps ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\\<^sub>1 (condition\\<^sub>1 A) w (rs ! k) (ps ! k)", "using 2(3) 3 4 5"], ["proof (prove)\nusing this:\n  test\\<^sub>2 (condition\\<^sub>2 (product AA)) w r ps\n  length ps = length AA\n  r = stranspose rs\n  length rs = length AA\n  k < length AA\n  A = AA ! k\n\ngoal (1 subgoal):\n 1. test\\<^sub>1 (condition\\<^sub>1 A) w (rs ! k) (ps ! k)", "by (simp add: list_all_length)"], ["proof (state)\nthis:\n  test\\<^sub>1 (condition\\<^sub>1 A) w (rs ! k) (ps ! k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w \\<in> a.language A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "assume 1: \"w \\<in> \\<Inter> (a.language ` set AA)\""], ["proof (state)\nthis:\n  w \\<in> \\<Inter> (a.language ` set AA)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "have 2: \"\\<forall> A \\<in> set AA. \\<exists> r p. p \\<in> initial\\<^sub>1 A \\<and> a.run A (w ||| r) p \\<and> test\\<^sub>1 (condition\\<^sub>1 A) w r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>set AA.\n       \\<exists>r p.\n          p \\<in> initial\\<^sub>1 A \\<and>\n          a.run' A (w ||| r) p \\<and>\n          test\\<^sub>1 (condition\\<^sub>1 A) w r p", "using 1"], ["proof (prove)\nusing this:\n  w \\<in> \\<Inter> (a.language ` set AA)\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>set AA.\n       \\<exists>r p.\n          p \\<in> initial\\<^sub>1 A \\<and>\n          a.run' A (w ||| r) p \\<and>\n          test\\<^sub>1 (condition\\<^sub>1 A) w r p", "by blast"], ["proof (state)\nthis:\n  \\<forall>A\\<in>set AA.\n     \\<exists>r p.\n        p \\<in> initial\\<^sub>1 A \\<and>\n        a.run' A (w ||| r) p \\<and> test\\<^sub>1 (condition\\<^sub>1 A) w r p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "obtain rs ps where 3:\n        \"length rs = length AA\" \"length ps = length AA\"\n        \"\\<And> k. k < length AA \\<Longrightarrow> ps ! k \\<in> initial\\<^sub>1 (AA ! k)\"\n        \"\\<And> k. k < length AA \\<Longrightarrow> a.run (AA ! k) (w ||| rs ! k) (ps ! k)\"\n        \"\\<And> k. k < length AA \\<Longrightarrow> test\\<^sub>1 (condition\\<^sub>1 (AA ! k)) w (rs ! k) (ps ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rs ps.\n        \\<lbrakk>length rs = length AA; length ps = length AA;\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            ps ! k \\<in> initial\\<^sub>1 (AA ! k);\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            a.run' (AA ! k) (w ||| rs ! k) (ps ! k);\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            test\\<^sub>1 (condition\\<^sub>1 (AA ! k)) w (rs ! k)\n             (ps ! k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>set AA.\n     \\<exists>r p.\n        p \\<in> initial\\<^sub>1 A \\<and>\n        a.run' A (w ||| r) p \\<and> test\\<^sub>1 (condition\\<^sub>1 A) w r p\n\ngoal (1 subgoal):\n 1. (\\<And>rs ps.\n        \\<lbrakk>length rs = length AA; length ps = length AA;\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            ps ! k \\<in> initial\\<^sub>1 (AA ! k);\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            a.run' (AA ! k) (w ||| rs ! k) (ps ! k);\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            test\\<^sub>1 (condition\\<^sub>1 (AA ! k)) w (rs ! k)\n             (ps ! k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Ball_set list_choice_zip list_choice_pair"], ["proof (prove)\nusing this:\n  \\<exists>ys.\n     length ys = length AA \\<and>\n     (\\<exists>zs.\n         length zs = min (length AA) (length ys) \\<and>\n         list_all\n          (\\<lambda>(A, r, p).\n              p \\<in> initial\\<^sub>1 A \\<and>\n              a.run' A (w ||| r) p \\<and>\n              test\\<^sub>1 (condition\\<^sub>1 A) w r p)\n          (AA || ys || zs))\n\ngoal (1 subgoal):\n 1. (\\<And>rs ps.\n        \\<lbrakk>length rs = length AA; length ps = length AA;\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            ps ! k \\<in> initial\\<^sub>1 (AA ! k);\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            a.run' (AA ! k) (w ||| rs ! k) (ps ! k);\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            test\\<^sub>1 (condition\\<^sub>1 (AA ! k)) w (rs ! k)\n             (ps ! k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list.pred_set set_conv_nth"], ["proof (prove)\nusing this:\n  \\<exists>ys.\n     length ys = length AA \\<and>\n     (\\<exists>zs.\n         length zs = min (length AA) (length ys) \\<and>\n         (\\<forall>(A, r, p)\n                   \\<in>{(AA || ys || zs) ! i |i.\n                         i < length (AA || ys || zs)}.\n             p \\<in> initial\\<^sub>1 A \\<and>\n             a.run' A (w ||| r) p \\<and>\n             test\\<^sub>1 (condition\\<^sub>1 A) w r p))\n\ngoal (1 subgoal):\n 1. (\\<And>rs ps.\n        \\<lbrakk>length rs = length AA; length ps = length AA;\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            ps ! k \\<in> initial\\<^sub>1 (AA ! k);\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            a.run' (AA ! k) (w ||| rs ! k) (ps ! k);\n         \\<And>k.\n            k < length AA \\<Longrightarrow>\n            test\\<^sub>1 (condition\\<^sub>1 (AA ! k)) w (rs ! k)\n             (ps ! k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  length rs = length AA\n  length ps = length AA\n  ?k < length AA \\<Longrightarrow> ps ! ?k \\<in> initial\\<^sub>1 (AA ! ?k)\n  ?k < length AA \\<Longrightarrow>\n  a.run' (AA ! ?k) (w ||| rs ! ?k) (ps ! ?k)\n  ?k < length AA \\<Longrightarrow>\n  test\\<^sub>1 (condition\\<^sub>1 (AA ! ?k)) w (rs ! ?k) (ps ! ?k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Inter> (a.language ` set AA) \\<Longrightarrow>\n       x \\<in> b.language (product AA)", "show \"w \\<in> b.language (product AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> b.language (product AA)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?p \\<in> initial\\<^sub>2 (product AA)\n 2. b.run' (product AA) (w ||| ?r) ?p\n 3. test\\<^sub>2 (condition\\<^sub>2 (product AA)) w ?r ?p", "show \"ps \\<in> initial\\<^sub>2 (product AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<in> initial\\<^sub>2 (product AA)", "using 3"], ["proof (prove)\nusing this:\n  length rs = length AA\n  length ps = length AA\n  ?k < length AA \\<Longrightarrow> ps ! ?k \\<in> initial\\<^sub>1 (AA ! ?k)\n  ?k < length AA \\<Longrightarrow>\n  a.run' (AA ! ?k) (w ||| rs ! ?k) (ps ! ?k)\n  ?k < length AA \\<Longrightarrow>\n  test\\<^sub>1 (condition\\<^sub>1 (AA ! ?k)) w (rs ! ?k) (ps ! ?k)\n\ngoal (1 subgoal):\n 1. ps \\<in> initial\\<^sub>2 (product AA)", "by (auto simp: listset_member list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  ps \\<in> initial\\<^sub>2 (product AA)\n\ngoal (2 subgoals):\n 1. b.run' (product AA) (w ||| ?r) ps\n 2. test\\<^sub>2 (condition\\<^sub>2 (product AA)) w ?r ps", "show \"b.run (product AA) (w ||| stranspose rs) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.run' (product AA) (w ||| stranspose rs) ps", "using 3"], ["proof (prove)\nusing this:\n  length rs = length AA\n  length ps = length AA\n  ?k < length AA \\<Longrightarrow> ps ! ?k \\<in> initial\\<^sub>1 (AA ! ?k)\n  ?k < length AA \\<Longrightarrow>\n  a.run' (AA ! ?k) (w ||| rs ! ?k) (ps ! ?k)\n  ?k < length AA \\<Longrightarrow>\n  test\\<^sub>1 (condition\\<^sub>1 (AA ! ?k)) w (rs ! ?k) (ps ! ?k)\n\ngoal (1 subgoal):\n 1. b.run' (product AA) (w ||| stranspose rs) ps", "by (auto intro: run_product)"], ["proof (state)\nthis:\n  b.run' (product AA) (w ||| stranspose rs) ps\n\ngoal (1 subgoal):\n 1. test\\<^sub>2 (condition\\<^sub>2 (product AA)) w (stranspose rs) ps", "show \"test\\<^sub>2 (condition\\<^sub>2 (product AA)) w (stranspose rs) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test\\<^sub>2 (condition\\<^sub>2 (product AA)) w (stranspose rs) ps", "using 3"], ["proof (prove)\nusing this:\n  length rs = length AA\n  length ps = length AA\n  ?k < length AA \\<Longrightarrow> ps ! ?k \\<in> initial\\<^sub>1 (AA ! ?k)\n  ?k < length AA \\<Longrightarrow>\n  a.run' (AA ! ?k) (w ||| rs ! ?k) (ps ! ?k)\n  ?k < length AA \\<Longrightarrow>\n  test\\<^sub>1 (condition\\<^sub>1 (AA ! ?k)) w (rs ! ?k) (ps ! ?k)\n\ngoal (1 subgoal):\n 1. test\\<^sub>2 (condition\\<^sub>2 (product AA)) w (stranspose rs) ps", "by (auto simp: list_all_length)"], ["proof (state)\nthis:\n  test\\<^sub>2 (condition\\<^sub>2 (product AA)) w (stranspose rs) ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w \\<in> b.language (product AA)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale automaton_sum_list =\n    a: automaton automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 +\n    b: automaton automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    for automaton\\<^sub>1 :: \"'label set \\<Rightarrow> 'state set \\<Rightarrow> ('label \\<Rightarrow> 'state \\<Rightarrow> 'state set) \\<Rightarrow> 'condition\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>1\"\n    and alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n    and automaton\\<^sub>2 :: \"'label set \\<Rightarrow> (nat \\<times> 'state) set \\<Rightarrow> ('label \\<Rightarrow> nat \\<times> 'state \\<Rightarrow> (nat \\<times> 'state) set) \\<Rightarrow> 'condition\\<^sub>2 \\<Rightarrow> 'automaton\\<^sub>2\"\n    and alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    +\n    fixes condition :: \"'condition\\<^sub>1 list \\<Rightarrow> 'condition\\<^sub>2\"\n  begin"], ["", "definition sum :: \"'automaton\\<^sub>1 list \\<Rightarrow> 'automaton\\<^sub>2\" where\n      \"sum AA \\<equiv> automaton\\<^sub>2\n        (\\<Union> (alphabet\\<^sub>1 ` set AA))\n        (\\<Union> k < length AA. {k} \\<times> initial\\<^sub>1 (AA ! k))\n        (\\<lambda> a (k, p). {k} \\<times> transition\\<^sub>1 (AA ! k) a p)\n        (condition (map condition\\<^sub>1 AA))\""], ["", "lemma sum_simps[simp]:\n      \"alphabet\\<^sub>2 (sum AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      \"initial\\<^sub>2 (sum AA) = (\\<Union> k < length AA. {k} \\<times> initial\\<^sub>1 (AA ! k))\"\n      \"transition\\<^sub>2 (sum AA) a (k, p) = {k} \\<times> transition\\<^sub>1 (AA ! k) a p\"\n      \"condition\\<^sub>2 (sum AA) = condition (map condition\\<^sub>1 AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2 (local.sum AA) =\n     \\<Union> (alphabet\\<^sub>1 ` set AA) &&&\n     initial\\<^sub>2 (local.sum AA) =\n     (\\<Union>k<length AA. {k} \\<times> initial\\<^sub>1 (AA ! k))) &&&\n    transition\\<^sub>2 (local.sum AA) a (k, p) =\n    {k} \\<times> transition\\<^sub>1 (AA ! k) a p &&&\n    condition\\<^sub>2 (local.sum AA) = condition (map condition\\<^sub>1 AA)", "unfolding sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2\n      (automaton\\<^sub>2 (\\<Union> (alphabet\\<^sub>1 ` set AA))\n        (\\<Union>k<length AA. {k} \\<times> initial\\<^sub>1 (AA ! k))\n        (\\<lambda>a (k, p). {k} \\<times> transition\\<^sub>1 (AA ! k) a p)\n        (condition (map condition\\<^sub>1 AA))) =\n     \\<Union> (alphabet\\<^sub>1 ` set AA) &&&\n     initial\\<^sub>2\n      (automaton\\<^sub>2 (\\<Union> (alphabet\\<^sub>1 ` set AA))\n        (\\<Union>k<length AA. {k} \\<times> initial\\<^sub>1 (AA ! k))\n        (\\<lambda>a (k, p). {k} \\<times> transition\\<^sub>1 (AA ! k) a p)\n        (condition (map condition\\<^sub>1 AA))) =\n     (\\<Union>k<length AA. {k} \\<times> initial\\<^sub>1 (AA ! k))) &&&\n    transition\\<^sub>2\n     (automaton\\<^sub>2 (\\<Union> (alphabet\\<^sub>1 ` set AA))\n       (\\<Union>k<length AA. {k} \\<times> initial\\<^sub>1 (AA ! k))\n       (\\<lambda>a (k, p). {k} \\<times> transition\\<^sub>1 (AA ! k) a p)\n       (condition (map condition\\<^sub>1 AA)))\n     a (k, p) =\n    {k} \\<times> transition\\<^sub>1 (AA ! k) a p &&&\n    condition\\<^sub>2\n     (automaton\\<^sub>2 (\\<Union> (alphabet\\<^sub>1 ` set AA))\n       (\\<Union>k<length AA. {k} \\<times> initial\\<^sub>1 (AA ! k))\n       (\\<lambda>a (k, p). {k} \\<times> transition\\<^sub>1 (AA ! k) a p)\n       (condition (map condition\\<^sub>1 AA))) =\n    condition (map condition\\<^sub>1 AA)", "by auto"], ["", "lemma run_sum:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      assumes \"A \\<in> set AA\"\n      assumes \"a.run A (w ||| s) p\"\n      obtains k where \"k < length AA\" \"A = AA ! k\" \"b.run (sum AA) (w ||| sconst k ||| s) (k, p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length AA; A = AA ! k;\n         b.run' (local.sum AA) (w ||| sconst k ||| s) (k, p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length AA; A = AA ! k;\n         b.run' (local.sum AA) (w ||| sconst k ||| s) (k, p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain k where 1: \"k < length AA\" \"A = AA ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length AA; A = AA ! k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  A \\<in> set AA\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length AA; A = AA ! k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  A \\<in> {AA ! i |i. i < length AA}\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length AA; A = AA ! k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k < length AA\n  A = AA ! k\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length AA; A = AA ! k;\n         b.run' (local.sum AA) (w ||| sconst k ||| s) (k, p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?k < length AA\n 2. A = AA ! ?k\n 3. b.run' (local.sum AA) (w ||| sconst ?k ||| s) (?k, p)", "show \"k < length AA\" \"A = AA ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length AA &&& A = AA ! k", "using 1"], ["proof (prove)\nusing this:\n  k < length AA\n  A = AA ! k\n\ngoal (1 subgoal):\n 1. k < length AA &&& A = AA ! k", "by this"], ["proof (state)\nthis:\n  k < length AA\n  A = AA ! k\n\ngoal (1 subgoal):\n 1. b.run' (local.sum AA) (w ||| sconst k ||| s) (k, p)", "show \"b.run (sum AA) (w ||| sconst k ||| s) (k, p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.run' (local.sum AA) (w ||| sconst k ||| s) (k, p)", "using assms 1(2)"], ["proof (prove)\nusing this:\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n  A \\<in> set AA\n  a.run' A (w ||| s) p\n  A = AA ! k\n\ngoal (1 subgoal):\n 1. b.run' (local.sum AA) (w ||| sconst k ||| s) (k, p)", "by (coinduction arbitrary: w s p) (force elim: a.run.cases)"], ["proof (state)\nthis:\n  b.run' (local.sum AA) (w ||| sconst k ||| s) (k, p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_run:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      assumes \"k < length AA\"\n      assumes \"b.run (sum AA) (w ||| r) (k, p)\"\n      obtains s where \"r = sconst k ||| s\" \"a.run (AA ! k) (w ||| s) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>r = sconst k ||| s; a.run' (AA ! k) (w ||| s) p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>s.\n        \\<lbrakk>r = sconst k ||| s; a.run' (AA ! k) (w ||| s) p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    r = sconst k ||| ?s2\n 2. (\\<And>s.\n        \\<lbrakk>r = sconst k ||| s; a.run' (AA ! k) (w ||| s) p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    a.run' (AA ! k) (w ||| ?s2) p", "show \"r = sconst k ||| smap snd r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = sconst k ||| smap snd r", "using assms"], ["proof (prove)\nusing this:\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n  k < length AA\n  b.run' (local.sum AA) (w ||| r) (k, p)\n\ngoal (1 subgoal):\n 1. r = sconst k ||| smap snd r", "by (coinduction arbitrary: w r p) (force elim: b.run.cases)"], ["proof (state)\nthis:\n  r = sconst k ||| smap snd r\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>r = sconst k ||| s; a.run' (AA ! k) (w ||| s) p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    a.run' (AA ! k) (w ||| smap snd r) p", "show \"a.run (AA ! k) (w ||| smap snd r) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a.run' (AA ! k) (w ||| smap snd r) p", "using assms"], ["proof (prove)\nusing this:\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n  k < length AA\n  b.run' (local.sum AA) (w ||| r) (k, p)\n\ngoal (1 subgoal):\n 1. a.run' (AA ! k) (w ||| smap snd r) p", "by (coinduction arbitrary: w r p) (force elim: b.run.cases)"], ["proof (state)\nthis:\n  a.run' (AA ! k) (w ||| smap snd r) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_nodes:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      shows \"b.nodes (sum AA) \\<subseteq> (\\<Union> k < length AA. {k} \\<times> a.nodes (AA ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.nodes' (local.sum AA)\n    \\<subseteq> (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> b.nodes' (local.sum AA) \\<Longrightarrow>\n       x \\<in> (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))", "show \"kp \\<in> (\\<Union> k < length AA. {k} \\<times> a.nodes (AA ! k))\" if \"kp \\<in> b.nodes (sum AA)\" for kp"], ["proof (prove)\ngoal (1 subgoal):\n 1. kp \\<in> (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))", "using that assms"], ["proof (prove)\nusing this:\n  kp \\<in> b.nodes' (local.sum AA)\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n\ngoal (1 subgoal):\n 1. kp \\<in> (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))", "by (induct) (auto 0 4)"], ["proof (state)\nthis:\n  ?kp \\<in> b.nodes' (local.sum AA) \\<Longrightarrow>\n  ?kp \\<in> (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_nodes_finite[intro]:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      assumes \"list_all (finite \\<circ> a.nodes) AA\"\n      shows \"finite (b.nodes (sum AA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (b.nodes' (local.sum AA))", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. b.nodes' (local.sum AA) \\<subseteq> ?B\n 2. finite ?B", "show \"b.nodes (sum AA) \\<subseteq> (\\<Union> k < length AA. {k} \\<times> a.nodes (AA ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.nodes' (local.sum AA)\n    \\<subseteq> (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))", "using sum_nodes assms(1)"], ["proof (prove)\nusing this:\n  \\<Inter> (alphabet\\<^sub>1 ` set ?AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set ?AA) \\<Longrightarrow>\n  b.nodes' (local.sum ?AA)\n  \\<subseteq> (\\<Union>k<length ?AA. {k} \\<times> a.nodes' (?AA ! k))\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n\ngoal (1 subgoal):\n 1. b.nodes' (local.sum AA)\n    \\<subseteq> (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))", "by this"], ["proof (state)\nthis:\n  b.nodes' (local.sum AA)\n  \\<subseteq> (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))\n\ngoal (1 subgoal):\n 1. finite (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))", "show \"finite (\\<Union> k < length AA. {k} \\<times> a.nodes' (AA ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))", "using assms(2)"], ["proof (prove)\nusing this:\n  list_all (finite \\<circ> a.nodes') AA\n\ngoal (1 subgoal):\n 1. finite (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))", "unfolding list_all_length"], ["proof (prove)\nusing this:\n  \\<forall>n<length AA. (finite \\<circ> a.nodes') (AA ! n)\n\ngoal (1 subgoal):\n 1. finite (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))", "by auto"], ["proof (state)\nthis:\n  finite (\\<Union>k<length AA. {k} \\<times> a.nodes' (AA ! k))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale automaton_union_list_run =\n    automaton_sum_list\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      condition +\n    a: automaton_run automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_run automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and condition\n    +\n    assumes test[iff]: \"k < length cs \\<Longrightarrow> test\\<^sub>2 (condition cs) w (sconst k ||| r) (k, p) \\<longleftrightarrow> test\\<^sub>1 (cs ! k) w r p\"\n  begin"], ["", "lemma sum_language[simp]:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      shows \"b.language (sum AA) = \\<Union> (a.language ` set AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.language (local.sum AA) = \\<Union> (a.language ` set AA)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b.language (local.sum AA) \\<subseteq> \\<Union> (a.language ` set AA)\n 2. \\<Union> (a.language ` set AA) \\<subseteq> b.language (local.sum AA)", "show \"b.language (sum AA) \\<subseteq> \\<Union> (a.language ` set AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.language (local.sum AA) \\<subseteq> \\<Union> (a.language ` set AA)", "using assms"], ["proof (prove)\nusing this:\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n\ngoal (1 subgoal):\n 1. b.language (local.sum AA) \\<subseteq> \\<Union> (a.language ` set AA)", "unfolding a.language_def b.language_def"], ["proof (prove)\nusing this:\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        p \\<in> initial\\<^sub>2 (local.sum AA) \\<and>\n        b.run' (local.sum AA) (w ||| r) p \\<and>\n        test\\<^sub>2 (condition\\<^sub>2 (local.sum AA)) w r p}\n    \\<subseteq> (\\<Union>A\\<in>set AA.\n                    {uu_.\n                     \\<exists>w r p.\n                        uu_ = w \\<and>\n                        p \\<in> initial\\<^sub>1 A \\<and>\n                        a.run' A (w ||| r) p \\<and>\n                        test\\<^sub>1 (condition\\<^sub>1 A) w r p})", "by (force elim: sum_run)"], ["proof (state)\nthis:\n  b.language (local.sum AA) \\<subseteq> \\<Union> (a.language ` set AA)\n\ngoal (1 subgoal):\n 1. \\<Union> (a.language ` set AA) \\<subseteq> b.language (local.sum AA)", "show \"\\<Union> (a.language ` set AA) \\<subseteq> b.language (sum AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (a.language ` set AA) \\<subseteq> b.language (local.sum AA)", "using assms"], ["proof (prove)\nusing this:\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n\ngoal (1 subgoal):\n 1. \\<Union> (a.language ` set AA) \\<subseteq> b.language (local.sum AA)", "unfolding a.language_def b.language_def"], ["proof (prove)\nusing this:\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n\ngoal (1 subgoal):\n 1. (\\<Union>A\\<in>set AA.\n        {uu_.\n         \\<exists>w r p.\n            uu_ = w \\<and>\n            p \\<in> initial\\<^sub>1 A \\<and>\n            a.run' A (w ||| r) p \\<and>\n            test\\<^sub>1 (condition\\<^sub>1 A) w r p})\n    \\<subseteq> {uu_.\n                 \\<exists>w r p.\n                    uu_ = w \\<and>\n                    p \\<in> initial\\<^sub>2 (local.sum AA) \\<and>\n                    b.run' (local.sum AA) (w ||| r) p \\<and>\n                    test\\<^sub>2 (condition\\<^sub>2 (local.sum AA)) w r p}", "by (force elim!: run_sum)"], ["proof (state)\nthis:\n  \\<Union> (a.language ` set AA) \\<subseteq> b.language (local.sum AA)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}