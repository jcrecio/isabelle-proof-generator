{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Automata/DBA/DBA_Combine.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemmas degeneralize_language[simp] = degeneralization.degeneralize_language[folded DBA.language_def]", "lemmas degeneralize_nodes_finite[iff] = degeneralization.degeneralize_nodes_finite[folded DBA.nodes_def]", "lemmas degeneralize_nodes_card = degeneralization.degeneralize_nodes_card[folded DBA.nodes_def]", "lemmas intersect'_language[simp] = intersection.product_language[folded DGBA.language_def]", "lemmas intersect'_nodes_finite = intersection.product_nodes_finite[folded DGBA.nodes_def]", "lemmas intersect'_nodes_card = intersection.product_nodes_card[folded DGBA.nodes_def]", "lemmas union_language = union.product_language", "lemmas union_nodes_finite = union.product_nodes_finite", "lemmas union_nodes_card = union.product_nodes_card", "lemmas intersect_list'_language[simp] = intersection_list.product_language[folded DGBA.language_def]", "lemmas intersect_list'_nodes_finite = intersection_list.product_nodes_finite[folded DGBA.nodes_def]", "lemmas intersect_list'_nodes_card = intersection_list.product_nodes_card[folded DGBA.nodes_def]", "lemmas union_list_language = union_list.product_language", "lemmas union_list_nodes_finite = union_list.product_nodes_finite", "lemmas union_list_nodes_card = union_list.product_nodes_card", "lemma intersect_language[simp]: \"DBA.language (intersect A B) = DBA.language A \\<inter> DBA.language B\"", "lemma intersect_nodes_finite:\n    assumes \"finite (DBA.nodes A)\" \"finite (DBA.nodes B)\"\n    shows \"finite (DBA.nodes (intersect A B))\"", "lemma intersect_nodes_card:\n    assumes \"finite (DBA.nodes A)\" \"finite (DBA.nodes B)\"\n    shows \"card (DBA.nodes (intersect A B)) \\<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)\"", "lemma intersect_list_language[simp]: \"DBA.language (intersect_list AA) = \\<Inter> (DBA.language ` set AA)\"", "lemma intersect_list_nodes_finite:\n    assumes \"list_all (finite \\<circ> DBA.nodes) AA\"\n    shows \"finite (DBA.nodes (intersect_list AA))\"", "lemma intersect_list_nodes_card:\n    assumes \"list_all (finite \\<circ> DBA.nodes) AA\"\n    shows \"card (DBA.nodes (intersect_list AA)) \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)\""], "translations": [["", "lemmas degeneralize_language[simp] = degeneralization.degeneralize_language[folded DBA.language_def]"], ["", "lemmas degeneralize_nodes_finite[iff] = degeneralization.degeneralize_nodes_finite[folded DBA.nodes_def]"], ["", "lemmas degeneralize_nodes_card = degeneralization.degeneralize_nodes_card[folded DBA.nodes_def]"], ["", "global_interpretation intersection: automaton_intersection_run\n    dba.dba dba.alphabet dba.initial dba.transition dba.accepting \"\\<lambda> P w r p. infs P (p ## r)\"\n    dba.dba dba.alphabet dba.initial dba.transition dba.accepting \"\\<lambda> P w r p. infs P (p ## r)\"\n    dgba.dgba dgba.alphabet dgba.initial dgba.transition dgba.accepting \"\\<lambda> P w r p. gen infs P (p ## r)\"\n    \"\\<lambda> c\\<^sub>1 c\\<^sub>2. [c\\<^sub>1 \\<circ> fst, c\\<^sub>2 \\<circ> snd]\"\n    defines intersect' = intersection.product"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton_intersection_run dba dba.alphabet dba.initial dba.transition\n     dba.accepting (\\<lambda>P w r p. infs P (p ## r)) dba dba.alphabet\n     dba.initial dba.transition dba.accepting\n     (\\<lambda>P w r p. infs P (p ## r)) dgba dgba.alphabet dgba.initial\n     dgba.transition dgba.accepting (\\<lambda>P w r p. gen infs P (p ## r))\n     (\\<lambda>c\\<^sub>1 c\\<^sub>2.\n         [c\\<^sub>1 \\<circ> fst, c\\<^sub>2 \\<circ> snd])", "by unfold_locales auto"], ["", "lemmas intersect'_language[simp] = intersection.product_language[folded DGBA.language_def]"], ["", "lemmas intersect'_nodes_finite = intersection.product_nodes_finite[folded DGBA.nodes_def]"], ["", "lemmas intersect'_nodes_card = intersection.product_nodes_card[folded DGBA.nodes_def]"], ["", "global_interpretation union: automaton_union_run\n    dba.dba dba.alphabet dba.initial dba.transition dba.accepting \"\\<lambda> P w r p. infs P (p ## r)\"\n    dba.dba dba.alphabet dba.initial dba.transition dba.accepting \"\\<lambda> P w r p. infs P (p ## r)\"\n    dba.dba dba.alphabet dba.initial dba.transition dba.accepting \"\\<lambda> P w r p. infs P (p ## r)\"\n    \"\\<lambda> c\\<^sub>1 c\\<^sub>2 pq. (c\\<^sub>1 \\<circ> fst) pq \\<or> (c\\<^sub>2 \\<circ> snd) pq\"\n    defines union = union.product"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton_union_run dba dba.alphabet dba.initial dba.transition\n     dba.accepting (\\<lambda>P w r p. infs P (p ## r)) dba dba.alphabet\n     dba.initial dba.transition dba.accepting\n     (\\<lambda>P w r p. infs P (p ## r)) dba dba.alphabet dba.initial\n     dba.transition dba.accepting (\\<lambda>P w r p. infs P (p ## r))\n     (\\<lambda>c\\<^sub>1 c\\<^sub>2 pq.\n         (c\\<^sub>1 \\<circ> fst) pq \\<or> (c\\<^sub>2 \\<circ> snd) pq)", "by (unfold_locales) (simp del: comp_apply)"], ["", "lemmas union_language = union.product_language"], ["", "lemmas union_nodes_finite = union.product_nodes_finite"], ["", "lemmas union_nodes_card = union.product_nodes_card"], ["", "global_interpretation intersection_list: automaton_intersection_list_run\n    dba.dba dba.alphabet dba.initial dba.transition dba.accepting \"\\<lambda> P w r p. infs P (p ## r)\"\n    dgba.dgba dgba.alphabet dgba.initial dgba.transition dgba.accepting \"\\<lambda> P w r p. gen infs P (p ## r)\"\n    \"\\<lambda> cs. map (\\<lambda> k pp. (cs ! k) (pp ! k)) [0 ..< length cs]\"\n    defines intersect_list' = intersection_list.product"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton_intersection_list_run dba dba.alphabet dba.initial\n     dba.transition dba.accepting (\\<lambda>P w r p. infs P (p ## r)) dgba\n     dgba.alphabet dgba.initial dgba.transition dgba.accepting\n     (\\<lambda>P w r p. gen infs P (p ## r))\n     (\\<lambda>cs. map (\\<lambda>k pp. (cs ! k) (pp ! k)) [0..<length cs])", "by (unfold_locales) (auto simp: gen_def comp_def)"], ["", "lemmas intersect_list'_language[simp] = intersection_list.product_language[folded DGBA.language_def]"], ["", "lemmas intersect_list'_nodes_finite = intersection_list.product_nodes_finite[folded DGBA.nodes_def]"], ["", "lemmas intersect_list'_nodes_card = intersection_list.product_nodes_card[folded DGBA.nodes_def]"], ["", "global_interpretation union_list: automaton_union_list_run\n    dba.dba dba.alphabet dba.initial dba.transition dba.accepting \"\\<lambda> P w r p. infs P (p ## r)\"\n    dba.dba dba.alphabet dba.initial dba.transition dba.accepting \"\\<lambda> P w r p. infs P (p ## r)\"\n    \"\\<lambda> cs pp. \\<exists> k < length cs. (cs ! k) (pp ! k)\"\n    defines union_list = union_list.product"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton_union_list_run dba dba.alphabet dba.initial dba.transition\n     dba.accepting (\\<lambda>P w r p. infs P (p ## r)) dba dba.alphabet\n     dba.initial dba.transition dba.accepting\n     (\\<lambda>P w r p. infs P (p ## r))\n     (\\<lambda>cs pp. \\<exists>k<length cs. (cs ! k) (pp ! k))", "by (unfold_locales) (simp add: comp_def)"], ["", "lemmas union_list_language = union_list.product_language"], ["", "lemmas union_list_nodes_finite = union_list.product_nodes_finite"], ["", "lemmas union_list_nodes_card = union_list.product_nodes_card"], ["", "(* TODO: these compound definitions are annoying, can we move those into Deterministic theory *)"], ["", "abbreviation intersect where \"intersect A B \\<equiv> degeneralize (intersect' A B)\""], ["", "lemma intersect_language[simp]: \"DBA.language (intersect A B) = DBA.language A \\<inter> DBA.language B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBA.language (intersect A B) = DBA.language A \\<inter> DBA.language B", "by simp"], ["", "lemma intersect_nodes_finite:\n    assumes \"finite (DBA.nodes A)\" \"finite (DBA.nodes B)\"\n    shows \"finite (DBA.nodes (intersect A B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DBA.nodes (intersect A B))", "using intersect'_nodes_finite assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (DBA.nodes ?A); finite (DBA.nodes ?B)\\<rbrakk>\n  \\<Longrightarrow> finite (DGBA.nodes (intersect' ?A ?B))\n  finite (DBA.nodes A)\n  finite (DBA.nodes B)\n\ngoal (1 subgoal):\n 1. finite (DBA.nodes (intersect A B))", "by simp"], ["", "lemma intersect_nodes_card:\n    assumes \"finite (DBA.nodes A)\" \"finite (DBA.nodes B)\"\n    shows \"card (DBA.nodes (intersect A B)) \\<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect A B))\n    \\<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect A B))\n    \\<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)", "have \"card (DBA.nodes (intersect A B)) \\<le>\n      max 1 (length (dgba.accepting (intersect' A B))) * card (DGBA.nodes (intersect' A B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect A B))\n    \\<le> max 1 (length (dgba.accepting (intersect' A B))) *\n          card (DGBA.nodes (intersect' A B))", "using degeneralize_nodes_card"], ["proof (prove)\nusing this:\n  card (DBA.nodes (degeneralize ?A))\n  \\<le> max 1 (length (dgba.accepting ?A)) * card (DGBA.nodes ?A)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect A B))\n    \\<le> max 1 (length (dgba.accepting (intersect' A B))) *\n          card (DGBA.nodes (intersect' A B))", "by this"], ["proof (state)\nthis:\n  card (DBA.nodes (intersect A B))\n  \\<le> max 1 (length (dgba.accepting (intersect' A B))) *\n        card (DGBA.nodes (intersect' A B))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect A B))\n    \\<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)", "also"], ["proof (state)\nthis:\n  card (DBA.nodes (intersect A B))\n  \\<le> max 1 (length (dgba.accepting (intersect' A B))) *\n        card (DGBA.nodes (intersect' A B))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect A B))\n    \\<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)", "have \"length (dgba.accepting (intersect' A B)) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (dgba.accepting (intersect' A B)) = 2", "by simp"], ["proof (state)\nthis:\n  length (dgba.accepting (intersect' A B)) = 2\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect A B))\n    \\<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)", "also"], ["proof (state)\nthis:\n  length (dgba.accepting (intersect' A B)) = 2\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect A B))\n    \\<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)", "have \"card (DGBA.nodes (intersect' A B)) \\<le> card (DBA.nodes A) * card (DBA.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DGBA.nodes (intersect' A B))\n    \\<le> card (DBA.nodes A) * card (DBA.nodes B)", "using intersect'_nodes_card assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (DBA.nodes ?A); finite (DBA.nodes ?B)\\<rbrakk>\n  \\<Longrightarrow> card (DGBA.nodes (intersect' ?A ?B))\n                    \\<le> card (DBA.nodes ?A) * card (DBA.nodes ?B)\n  finite (DBA.nodes A)\n  finite (DBA.nodes B)\n\ngoal (1 subgoal):\n 1. card (DGBA.nodes (intersect' A B))\n    \\<le> card (DBA.nodes A) * card (DBA.nodes B)", "by this"], ["proof (state)\nthis:\n  card (DGBA.nodes (intersect' A B))\n  \\<le> card (DBA.nodes A) * card (DBA.nodes B)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect A B))\n    \\<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max 1 2 * x \\<le> max 1 2 * y) \\<Longrightarrow>\n  card (DBA.nodes (intersect A B))\n  \\<le> max 1 2 * (card (DBA.nodes A) * card (DBA.nodes B))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max 1 2 * x \\<le> max 1 2 * y) \\<Longrightarrow>\n  card (DBA.nodes (intersect A B))\n  \\<le> max 1 2 * (card (DBA.nodes A) * card (DBA.nodes B))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect A B))\n    \\<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)", "by simp"], ["proof (state)\nthis:\n  card (DBA.nodes (intersect A B))\n  \\<le> 2 * card (DBA.nodes A) * card (DBA.nodes B)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation intersect_list where \"intersect_list AA \\<equiv> degeneralize (intersect_list' AA)\""], ["", "lemma intersect_list_language[simp]: \"DBA.language (intersect_list AA) = \\<Inter> (DBA.language ` set AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBA.language (intersect_list AA) = \\<Inter> (DBA.language ` set AA)", "by simp"], ["", "lemma intersect_list_nodes_finite:\n    assumes \"list_all (finite \\<circ> DBA.nodes) AA\"\n    shows \"finite (DBA.nodes (intersect_list AA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DBA.nodes (intersect_list AA))", "using intersect_list'_nodes_finite assms"], ["proof (prove)\nusing this:\n  list_all (finite \\<circ> DBA.nodes) ?AA \\<Longrightarrow>\n  finite (DGBA.nodes (intersect_list' ?AA))\n  list_all (finite \\<circ> DBA.nodes) AA\n\ngoal (1 subgoal):\n 1. finite (DBA.nodes (intersect_list AA))", "by simp"], ["", "lemma intersect_list_nodes_card:\n    assumes \"list_all (finite \\<circ> DBA.nodes) AA\"\n    shows \"card (DBA.nodes (intersect_list AA)) \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)", "have \"card (DBA.nodes (intersect_list AA)) \\<le>\n      max 1 (length (dgba.accepting (intersect_list' AA))) * card (DGBA.nodes (intersect_list' AA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect_list AA))\n    \\<le> max 1 (length (dgba.accepting (intersect_list' AA))) *\n          card (DGBA.nodes (intersect_list' AA))", "using degeneralize_nodes_card"], ["proof (prove)\nusing this:\n  card (DBA.nodes (degeneralize ?A))\n  \\<le> max 1 (length (dgba.accepting ?A)) * card (DGBA.nodes ?A)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect_list AA))\n    \\<le> max 1 (length (dgba.accepting (intersect_list' AA))) *\n          card (DGBA.nodes (intersect_list' AA))", "by this"], ["proof (state)\nthis:\n  card (DBA.nodes (intersect_list AA))\n  \\<le> max 1 (length (dgba.accepting (intersect_list' AA))) *\n        card (DGBA.nodes (intersect_list' AA))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)", "also"], ["proof (state)\nthis:\n  card (DBA.nodes (intersect_list AA))\n  \\<le> max 1 (length (dgba.accepting (intersect_list' AA))) *\n        card (DGBA.nodes (intersect_list' AA))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)", "have \"length (dgba.accepting (intersect_list' AA)) = length AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (dgba.accepting (intersect_list' AA)) = length AA", "by simp"], ["proof (state)\nthis:\n  length (dgba.accepting (intersect_list' AA)) = length AA\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)", "also"], ["proof (state)\nthis:\n  length (dgba.accepting (intersect_list' AA)) = length AA\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)", "have \"card (DGBA.nodes (intersect_list' AA)) \\<le> prod_list (map (card \\<circ> DBA.nodes) AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DGBA.nodes (intersect_list' AA))\n    \\<le> prod_list (map (card \\<circ> DBA.nodes) AA)", "using intersect_list'_nodes_card assms"], ["proof (prove)\nusing this:\n  list_all (finite \\<circ> DBA.nodes) ?AA \\<Longrightarrow>\n  card (DGBA.nodes (intersect_list' ?AA))\n  \\<le> prod_list (map (card \\<circ> DBA.nodes) ?AA)\n  list_all (finite \\<circ> DBA.nodes) AA\n\ngoal (1 subgoal):\n 1. card (DGBA.nodes (intersect_list' AA))\n    \\<le> prod_list (map (card \\<circ> DBA.nodes) AA)", "by this"], ["proof (state)\nthis:\n  card (DGBA.nodes (intersect_list' AA))\n  \\<le> prod_list (map (card \\<circ> DBA.nodes) AA)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max 1 (length AA) * x \\<le> max 1 (length AA) * y) \\<Longrightarrow>\n  card (DBA.nodes (intersect_list AA))\n  \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max 1 (length AA) * x \\<le> max 1 (length AA) * y) \\<Longrightarrow>\n  card (DBA.nodes (intersect_list AA))\n  \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (intersect_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)", "by simp"], ["proof (state)\nthis:\n  card (DBA.nodes (intersect_list AA))\n  \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DBA.nodes) AA)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}