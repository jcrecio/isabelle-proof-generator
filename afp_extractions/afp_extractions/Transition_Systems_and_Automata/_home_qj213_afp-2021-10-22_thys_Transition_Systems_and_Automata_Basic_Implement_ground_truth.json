{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Basic/Implement.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemmas [refine] = plain_nres_relI", "lemma vcg0:\n    assumes \"(f, g) \\<in> \\<langle>Id\\<rangle> nres_rel\"\n    shows \"g \\<le> h \\<Longrightarrow> f \\<le> h\"", "lemma vcg1:\n    assumes \"(f, g) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle> nres_rel\"\n    shows \"g x \\<le> h x \\<Longrightarrow> f x \\<le> h x\"", "lemma vcg2:\n    assumes \"(f, g) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle> nres_rel\"\n    shows \"g x y \\<le> h x y \\<Longrightarrow> f x y \\<le> h x y\"", "lemma RETURN_nres_relD:\n    assumes \"(RETURN x, RETURN y) \\<in> \\<langle>A\\<rangle> nres_rel\"\n    shows \"(x, y) \\<in> A\"", "lemma FOREACH_rule_insert:\n    assumes \"finite S\"\n    assumes \"I {} s\"\n    assumes \"\\<And> s. I S s \\<Longrightarrow> P s\"\n    assumes \"\\<And> T x s. T \\<subseteq> S \\<Longrightarrow> I T s \\<Longrightarrow> x \\<in> S \\<Longrightarrow> x \\<notin> T \\<Longrightarrow> f x s \\<le> SPEC (I (insert x T))\"\n    shows \"FOREACH S f s \\<le> SPEC P\"", "lemma FOREACH_rule_map:\n    assumes \"finite (dom g)\"\n    assumes \"I Map.empty s\"\n    assumes \"\\<And> s. I g s \\<Longrightarrow> P s\"\n    assumes \"\\<And> h k v s. h \\<subseteq>\\<^sub>m g \\<Longrightarrow> I h s \\<Longrightarrow> g k = Some v \\<Longrightarrow> k \\<notin> dom h \\<Longrightarrow>\n      f (k, v) s \\<le> SPEC (I (h (k \\<mapsto> v)))\"\n    shows \"FOREACH (map_to_set g) f s \\<le> SPEC P\"", "lemma FOREACH_rule_insert_eq:\n    assumes \"finite S\"\n    assumes \"X {} = s\"\n    assumes \"X S = t\"\n    assumes \"\\<And> T x. T \\<subseteq> S \\<Longrightarrow> x \\<in> S \\<Longrightarrow> x \\<notin> T \\<Longrightarrow> f x (X T) \\<le> SPEC (HOL.eq (X (insert x T)))\"\n    shows \"FOREACH S f s \\<le> SPEC (HOL.eq t)\"", "lemma FOREACH_rule_map_eq:\n    assumes \"finite (dom g)\"\n    assumes \"X Map.empty = s\"\n    assumes \"X g = t\"\n    assumes \"\\<And> h k v. h \\<subseteq>\\<^sub>m g \\<Longrightarrow> g k = Some v \\<Longrightarrow> k \\<notin> dom h \\<Longrightarrow>\n      f (k, v) (X h) \\<le> SPEC (HOL.eq (X (h (k \\<mapsto> v))))\"\n    shows \"FOREACH (map_to_set g) f s \\<le> SPEC (HOL.eq t)\"", "lemma FOREACH_rule_map_map: \"(FOREACH (map_to_set m) (\\<lambda> (k, v). F k (f k v)),\n    FOREACH (map_to_set (\\<lambda> k. map_option (f k) (m k))) (\\<lambda> (k, v). F k v)) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle> nres_rel\"", "lemma list_set_rel_Id_on[simp]: \"\\<langle>Id_on A\\<rangle> list_set_rel = \\<langle>Id\\<rangle> list_set_rel \\<inter> UNIV \\<times> Pow A\"", "lemma list_set_card[param]: \"(length, card) \\<in> \\<langle>A\\<rangle> list_set_rel \\<rightarrow> nat_rel\"", "lemma list_set_insert[param]:\n    assumes \"y \\<notin> Y\"\n    assumes \"(x, y) \\<in> A\" \"(xs, Y) \\<in> \\<langle>A\\<rangle> list_set_rel\"\n    shows \"(x # xs, insert y Y) \\<in> \\<langle>A\\<rangle> list_set_rel\"", "lemma list_set_union[param]:\n    assumes \"X \\<inter> Y = {}\"\n    assumes \"(xs, X) \\<in> \\<langle>A\\<rangle> list_set_rel\" \"(ys, Y) \\<in> \\<langle>A\\<rangle> list_set_rel\"\n    shows \"(xs @ ys, X \\<union> Y) \\<in> \\<langle>A\\<rangle> list_set_rel\"", "lemma list_set_Union[param]:\n    assumes \"\\<And> X Y. X \\<in> S \\<Longrightarrow> Y \\<in> S \\<Longrightarrow> X \\<noteq> Y \\<Longrightarrow> X \\<inter> Y = {}\"\n    assumes \"(xs, S) \\<in> \\<langle>\\<langle>A\\<rangle> list_set_rel\\<rangle> list_set_rel\"\n    shows \"(concat xs, Union S) \\<in> \\<langle>A\\<rangle> list_set_rel\"", "lemma list_set_image[param]:\n    assumes \"inj_on g S\"\n    assumes \"(f, g) \\<in> A \\<rightarrow> B\" \"(xs, S) \\<in> \\<langle>A\\<rangle> list_set_rel\"\n    shows \"(map f xs, g ` S) \\<in> \\<langle>B\\<rangle> list_set_rel\"", "lemma list_set_bind[param]:\n    assumes \"\\<And> x y. x \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> g x \\<inter> g y = {}\"\n    assumes \"(xs, S) \\<in> \\<langle>A\\<rangle> list_set_rel\" \"(f, g) \\<in> A \\<rightarrow> \\<langle>B\\<rangle> list_set_rel\"\n    shows \"(xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle> list_set_rel\"", "lemma dflt_ahm_rel_finite_nat: \"finite_map_rel (\\<langle>nat_rel, V\\<rangle> dflt_ahm_rel)\"", "lemma [autoref_op_pat]: \"(Some \\<circ> f) |` X \\<equiv> OP (\\<lambda> f X. (Some \\<circ> f) |` X) f X\"", "lemma [autoref_op_pat]: \"\\<Union>(m ` S) \\<equiv> OP (\\<lambda>S m. \\<Union>(m ` S)) S m\"", "lemma gen_UNION[autoref_rules_raw]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes to_list: \"SIDE_GEN_ALGO (is_set_to_list A Rs1 tol)\"\n      assumes empty: \"GEN_OP emp {} (\\<langle>B\\<rangle> Rs3)\"\n      assumes union: \"GEN_OP un union (\\<langle>B\\<rangle> Rs2 \\<rightarrow> \\<langle>B\\<rangle> Rs3 \\<rightarrow> \\<langle>B\\<rangle> Rs3)\"\n      shows \"(gen_UNION tol emp un, \\<lambda>A f. \\<Union> (f ` A)) \\<in> \\<langle>A\\<rangle> Rs1 \\<rightarrow> (A \\<rightarrow> \\<langle>B\\<rangle> Rs2) \\<rightarrow> \\<langle>B\\<rangle> Rs3\"", "lemma gen_Image[autoref_rules]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes to_list: \"SIDE_GEN_ALGO (is_set_to_list (A \\<times>\\<^sub>r B) Rs1 tol1)\"\n      assumes member: \"GEN_OP mem2 (\\<in>) (A \\<rightarrow> \\<langle>A\\<rangle> Rs2 \\<rightarrow> bool_rel)\"\n      assumes empty: \"GEN_OP emp3 {} (\\<langle>B\\<rangle> Rs3)\"\n      assumes insert: \"GEN_OP ins3 Set.insert (B \\<rightarrow> \\<langle>B\\<rangle> Rs3 \\<rightarrow> \\<langle>B\\<rangle> Rs3)\"\n      shows \"(gen_Image tol1 mem2 emp3 ins3, Image) \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle> Rs1 \\<rightarrow> \\<langle>A\\<rangle> Rs2 \\<rightarrow> \\<langle>B\\<rangle> Rs3\"", "lemma list_set_union_autoref[autoref_rules]:\n      assumes \"PRIO_TAG_OPTIMIZATION\"\n      assumes \"SIDE_PRECOND_OPT (a' \\<inter> b' = {})\"\n      assumes \"(a, a') \\<in> \\<langle>R\\<rangle> list_set_rel\"\n      assumes \"(b, b') \\<in> \\<langle>R\\<rangle> list_set_rel\"\n      shows \"(a @ b,\n        (OP union ::: \\<langle>R\\<rangle> list_set_rel \\<rightarrow> \\<langle>R\\<rangle> list_set_rel \\<rightarrow> \\<langle>R\\<rangle> list_set_rel) $ a' $ b') \\<in>\n        \\<langle>R\\<rangle> list_set_rel\"", "lemma list_set_image_autoref[autoref_rules]:\n      assumes \"PRIO_TAG_OPTIMIZATION\"\n      assumes INJ: \"SIDE_PRECOND_OPT (inj_on f s)\"\n      assumes \"\\<And> xi x. (xi, x) \\<in> Ra \\<Longrightarrow> x \\<in> s \\<Longrightarrow> (fi xi, f $ x) \\<in> Rb\"\n      assumes LP: \"(l,s)\\<in>\\<langle>Ra\\<rangle>list_set_rel\"\n      shows \"(map fi l,\n        (OP image ::: (Ra \\<rightarrow> Rb) \\<rightarrow> \\<langle>Ra\\<rangle> list_set_rel \\<rightarrow> \\<langle>Rb\\<rangle> list_set_rel) $ f $ s) \\<in>\n        \\<langle>Rb\\<rangle> list_set_rel\"", "lemma list_set_UNION_autoref[autoref_rules]:\n      assumes \"PRIO_TAG_OPTIMIZATION\"\n      assumes \"SIDE_PRECOND_OPT (\\<forall> x \\<in> S. \\<forall> y \\<in> S. x \\<noteq> y \\<longrightarrow> g x \\<inter> g y = {})\"\n      assumes \"(xs, S) \\<in> \\<langle>A\\<rangle> list_set_rel\" \"(f, g) \\<in> A \\<rightarrow> \\<langle>B\\<rangle> list_set_rel\"\n      shows \"(xs \\<bind> f,\n        (OP (\\<lambda>A f. \\<Union> (f ` A)) ::: \\<langle>A\\<rangle> list_set_rel \\<rightarrow> (A \\<rightarrow> \\<langle>B\\<rangle> list_set_rel) \\<rightarrow> \\<langle>B\\<rangle> list_set_rel) $ S $ g) \\<in>\n        \\<langle>B\\<rangle> list_set_rel\"", "lemma gen_equals[autoref_rules]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes BALL: \"GEN_OP ball op_map_ball (\\<langle>Rk, Rv\\<rangle> Rm \\<rightarrow> (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow> bool_rel)\"\n      assumes LU: \"GEN_OP lu op_map_lookup (Rk \\<rightarrow> \\<langle>Rk, Rv\\<rangle> Rm \\<rightarrow> \\<langle>Rv\\<rangle> option_rel)\"\n      assumes EQ: \"GEN_OP eq HOL.eq (Rv \\<rightarrow> Rv \\<rightarrow> bool_rel)\"\n      shows \"(gen_equals ball lu eq, HOL.eq) \\<in> \\<langle>Rk, Rv\\<rangle> Rm \\<rightarrow> \\<langle>Rk, Rv\\<rangle> Rm \\<rightarrow> bool_rel\"", "lemma [autoref_itype]: \"op_set_enumerate ::\\<^sub>i \\<langle>A\\<rangle>\\<^sub>i i_set \\<rightarrow>\\<^sub>i \\<langle>\\<langle>A, i_nat\\<rangle>\\<^sub>i i_map\\<rangle>\\<^sub>i i_nres\"", "lemma [autoref_hom]: \"CONSTRAINT op_set_enumerate (\\<langle>A\\<rangle> Rs \\<rightarrow> \\<langle>\\<langle>A, nat_rel\\<rangle> Rm\\<rangle> nres_rel)\"", "lemma gen_enumerate[autoref_rules_raw]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes to_list: \"SIDE_GEN_ALGO (is_set_to_list A Rs tol)\"\n      assumes empty: \"GEN_OP emp op_map_empty (\\<langle>A, nat_rel\\<rangle> Rm)\"\n      assumes update: \"GEN_OP upd op_map_update (A \\<rightarrow> nat_rel \\<rightarrow> \\<langle>A, nat_rel\\<rangle> Rm \\<rightarrow> \\<langle>A, nat_rel\\<rangle> Rm)\"\n      shows \"(\\<lambda> S. RETURN (gen_enumerate tol upd emp S), op_set_enumerate) \\<in>\n        \\<langle>A\\<rangle> Rs \\<rightarrow> \\<langle>\\<langle>A, nat_rel\\<rangle> Rm\\<rangle> nres_rel\"", "lemma gen_enumerate_it_to_list[refine_transfer_post_simp]:\n      \"gen_enumerate (it_to_list it) =\n       (\\<lambda> upd emp S. snd (foldli (it_to_list it S) (\\<lambda> _. True)\n      (\\<lambda> x s. case s of (k, m) \\<Rightarrow> (Suc k, upd x k m)) (0, emp)))\"", "lemma gen_build[autoref_rules]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes to_list: \"SIDE_GEN_ALGO (is_set_to_list A Rs tol)\"\n      assumes empty: \"GEN_OP emp op_map_empty (\\<langle>A, B\\<rangle> Rm)\"\n      assumes update: \"GEN_OP upd op_map_update (A \\<rightarrow> B \\<rightarrow> \\<langle>A, B\\<rangle> Rm \\<rightarrow> \\<langle>A, B\\<rangle> Rm)\"\n      shows \"(\\<lambda> f X. gen_build tol upd emp f X, \\<lambda> f X. (Some \\<circ> f) |` X) \\<in>\n        (A \\<rightarrow> B) \\<rightarrow> \\<langle>A\\<rangle> Rs \\<rightarrow> \\<langle>A, B\\<rangle> Rm\"", "lemma map2set_to_list:\n      assumes \"GEN_ALGO_tag (is_map_to_list Rk unit_rel R it)\"\n      shows \"is_set_to_list Rk (map2set_rel R) (to_list (map_iterator_dom \\<circ> (foldli \\<circ> it)))\"", "lemma CAST_to_list[autoref_rules_raw]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes \"SIDE_GEN_ALGO (is_set_to_list A Rs tol)\"\n      shows \"(tol, CAST) \\<in> \\<langle>A\\<rangle> Rs \\<rightarrow> \\<langle>A\\<rangle> list_set_rel\"", "lemma param_foldli:\n      assumes \"(xs, ys) \\<in> \\<langle>Ra\\<rangle> list_rel\"\n      assumes \"(c, d) \\<in> Rs \\<rightarrow> bool_rel\"\n      assumes \"\\<And> x y. (x, y) \\<in> Ra \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs\"\n      assumes \"(a, b) \\<in> Rs\"\n      shows \"(foldli xs c f a, foldli ys d g b) \\<in> Rs\"", "lemma det_fold_sorted_set:\n      assumes 1: \"det_fold_set ordR c' f' \\<sigma>' result\"\n      assumes 2: \"is_set_to_sorted_list ordR Rk Rs tsl\"\n      assumes SREF[param]: \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n      assumes [param]:  \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n      assumes [param]: \"\\<And> x y. (x, y) \\<in> Rk \\<Longrightarrow> y \\<in> s' \\<Longrightarrow> (f x,f' y)\\<in>R\\<sigma> \\<rightarrow> R\\<sigma>\"\n      assumes [param]: \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n      shows \"(foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\"", "lemma det_fold_set:\n      assumes \"det_fold_set (\\<lambda>_ _. True) c' f' \\<sigma>' result\"\n      assumes \"is_set_to_list Rk Rs tsl\"\n      assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n      assumes \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n      assumes \"\\<And> x y. (x, y) \\<in> Rk \\<Longrightarrow> y \\<in> s' \\<Longrightarrow> (f x, f' y)\\<in>R\\<sigma> \\<rightarrow> R\\<sigma>\"\n      assumes \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n      shows \"(foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\"", "lemma gen_image[autoref_rules_raw]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 it1)\"\n      assumes INS: \"GEN_OP ins2 Set.insert (Rk'\\<rightarrow>\\<langle>Rk'\\<rangle>Rs2\\<rightarrow>\\<langle>Rk'\\<rangle>Rs2)\"\n      assumes EMPTY: \"GEN_OP empty2 {} (\\<langle>Rk'\\<rangle>Rs2)\"\n      assumes \"\\<And> xi x. (xi, x) \\<in> Rk \\<Longrightarrow> x \\<in> s \\<Longrightarrow> (fi xi, f $ x) \\<in> Rk'\"\n      assumes \"(l, s) \\<in> \\<langle>Rk\\<rangle>Rs1\"\n      shows \"(gen_image (\\<lambda> x. foldli (it1 x)) empty2 ins2 fi l,\n        (OP image ::: (Rk\\<rightarrow>Rk') \\<rightarrow> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk'\\<rangle>Rs2)) $ f $ s) \\<in> (\\<langle>Rk'\\<rangle>Rs2)\""], "translations": [["", "lemmas [refine] = plain_nres_relI"], ["", "lemma vcg0:\n    assumes \"(f, g) \\<in> \\<langle>Id\\<rangle> nres_rel\"\n    shows \"g \\<le> h \\<Longrightarrow> f \\<le> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<le> h \\<Longrightarrow> f \\<le> h", "using order_trans nres_relD[OF assms[param_fo, OF], THEN refine_IdD]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  f \\<le> g\n\ngoal (1 subgoal):\n 1. g \\<le> h \\<Longrightarrow> f \\<le> h", "by this"], ["", "lemma vcg1:\n    assumes \"(f, g) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle> nres_rel\"\n    shows \"g x \\<le> h x \\<Longrightarrow> f x \\<le> h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x \\<le> h x \\<Longrightarrow> f x \\<le> h x", "using order_trans nres_relD[OF assms[param_fo, OF IdI], THEN refine_IdD]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  f ?x2 \\<le> g ?x2\n\ngoal (1 subgoal):\n 1. g x \\<le> h x \\<Longrightarrow> f x \\<le> h x", "by this"], ["", "lemma vcg2:\n    assumes \"(f, g) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle> nres_rel\"\n    shows \"g x y \\<le> h x y \\<Longrightarrow> f x y \\<le> h x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x y \\<le> h x y \\<Longrightarrow> f x y \\<le> h x y", "using order_trans nres_relD[OF assms[param_fo, OF IdI IdI], THEN refine_IdD]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  f ?x3 ?x2 \\<le> g ?x3 ?x2\n\ngoal (1 subgoal):\n 1. g x y \\<le> h x y \\<Longrightarrow> f x y \\<le> h x y", "by this"], ["", "lemma RETURN_nres_relD:\n    assumes \"(RETURN x, RETURN y) \\<in> \\<langle>A\\<rangle> nres_rel\"\n    shows \"(x, y) \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  (RETURN x, RETURN y) \\<in> \\<langle>A\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> A", "unfolding nres_rel_def"], ["proof (prove)\nusing this:\n  (RETURN x, RETURN y) \\<in> {(c, a). c \\<le> \\<Down> A a}\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> A", "by simp"], ["", "lemma FOREACH_rule_insert:\n    assumes \"finite S\"\n    assumes \"I {} s\"\n    assumes \"\\<And> s. I S s \\<Longrightarrow> P s\"\n    assumes \"\\<And> T x s. T \\<subseteq> S \\<Longrightarrow> I T s \\<Longrightarrow> x \\<in> S \\<Longrightarrow> x \\<notin> T \\<Longrightarrow> f x s \\<le> SPEC (I (insert x T))\"\n    shows \"FOREACH S f s \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH S f s \\<le> SPEC P", "proof (rule FOREACH_rule[where I = \"\\<lambda> T s. I (S - T) s\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. finite S\n 2. I (S - S) s\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I (S - it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (S - (it - {x})))\n 4. \\<And>\\<sigma>. I (S - {}) \\<sigma> \\<Longrightarrow> P \\<sigma>", "show \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "using assms(1)"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. finite S", "by this"], ["proof (state)\nthis:\n  finite S\n\ngoal (3 subgoals):\n 1. I (S - S) s\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I (S - it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (S - (it - {x})))\n 3. \\<And>\\<sigma>. I (S - {}) \\<sigma> \\<Longrightarrow> P \\<sigma>", "show \"I (S - S) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (S - S) s", "using assms(2)"], ["proof (prove)\nusing this:\n  I {} s\n\ngoal (1 subgoal):\n 1. I (S - S) s", "by simp"], ["proof (state)\nthis:\n  I (S - S) s\n\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I (S - it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (S - (it - {x})))\n 2. \\<And>\\<sigma>. I (S - {}) \\<sigma> \\<Longrightarrow> P \\<sigma>", "show \"P s\" if \"I (S - {}) s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "using assms(3) that"], ["proof (prove)\nusing this:\n  I S ?s \\<Longrightarrow> P ?s\n  I (S - {}) s\n\ngoal (1 subgoal):\n 1. P s", "by simp"], ["proof (state)\nthis:\n  I (S - {}) ?s \\<Longrightarrow> P ?s\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I (S - it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (S - (it - {x})))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I (S - it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (S - (it - {x})))", "fix x T s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I (S - it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (S - (it - {x})))", "assume 1: \"x \\<in> T\" \"T \\<subseteq> S\" \"I (S - T) s\""], ["proof (state)\nthis:\n  x \\<in> T\n  T \\<subseteq> S\n  I (S - T) s\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I (S - it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (S - (it - {x})))", "have \"f x s \\<le> SPEC (I (insert x (S - T)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x s \\<le> SPEC (I (insert x (S - T)))", "using assms(4) 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?T \\<subseteq> S; I ?T ?s; ?x \\<in> S; ?x \\<notin> ?T\\<rbrakk>\n  \\<Longrightarrow> f ?x ?s \\<le> SPEC (I (insert ?x ?T))\n  x \\<in> T\n  T \\<subseteq> S\n  I (S - T) s\n\ngoal (1 subgoal):\n 1. f x s \\<le> SPEC (I (insert x (S - T)))", "by blast"], ["proof (state)\nthis:\n  f x s \\<le> SPEC (I (insert x (S - T)))\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I (S - it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (S - (it - {x})))", "also"], ["proof (state)\nthis:\n  f x s \\<le> SPEC (I (insert x (S - T)))\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I (S - it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (S - (it - {x})))", "have \"insert x (S - T) = S - (T - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x (S - T) = S - (T - {x})", "using 1(1, 2)"], ["proof (prove)\nusing this:\n  x \\<in> T\n  T \\<subseteq> S\n\ngoal (1 subgoal):\n 1. insert x (S - T) = S - (T - {x})", "by (simp add: it_step_insert_iff)"], ["proof (state)\nthis:\n  insert x (S - T) = S - (T - {x})\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> S; I (S - it) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (S - (it - {x})))", "finally"], ["proof (chain)\npicking this:\n  f x s \\<le> SPEC (I (S - (T - {x})))", "show \"f x s \\<le> SPEC (I (S - (T - {x})))\""], ["proof (prove)\nusing this:\n  f x s \\<le> SPEC (I (S - (T - {x})))\n\ngoal (1 subgoal):\n 1. f x s \\<le> SPEC (I (S - (T - {x})))", "by this"], ["proof (state)\nthis:\n  f x s \\<le> SPEC (I (S - (T - {x})))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FOREACH_rule_map:\n    assumes \"finite (dom g)\"\n    assumes \"I Map.empty s\"\n    assumes \"\\<And> s. I g s \\<Longrightarrow> P s\"\n    assumes \"\\<And> h k v s. h \\<subseteq>\\<^sub>m g \\<Longrightarrow> I h s \\<Longrightarrow> g k = Some v \\<Longrightarrow> k \\<notin> dom h \\<Longrightarrow>\n      f (k, v) s \\<le> SPEC (I (h (k \\<mapsto> v)))\"\n    shows \"FOREACH (map_to_set g) f s \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH (map_to_set g) f s \\<le> SPEC P", "proof (rule FOREACH_rule_insert[where I = \"\\<lambda> H s. I (set_to_map H) s\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (map_to_set g)\n 2. I (set_to_map {}) s\n 3. \\<And>s. I (set_to_map (map_to_set g)) s \\<Longrightarrow> P s\n 4. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "show \"finite (map_to_set g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (map_to_set g)", "unfolding finite_map_to_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom g)", "using assms(1)"], ["proof (prove)\nusing this:\n  finite (dom g)\n\ngoal (1 subgoal):\n 1. finite (dom g)", "by this"], ["proof (state)\nthis:\n  finite (map_to_set g)\n\ngoal (3 subgoals):\n 1. I (set_to_map {}) s\n 2. \\<And>s. I (set_to_map (map_to_set g)) s \\<Longrightarrow> P s\n 3. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "show \"I (set_to_map {}) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (set_to_map {}) s", "using assms(2)"], ["proof (prove)\nusing this:\n  I Map.empty s\n\ngoal (1 subgoal):\n 1. I (set_to_map {}) s", "by simp"], ["proof (state)\nthis:\n  I (set_to_map {}) s\n\ngoal (2 subgoals):\n 1. \\<And>s. I (set_to_map (map_to_set g)) s \\<Longrightarrow> P s\n 2. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "show \"P s\" if \"I (set_to_map (map_to_set g)) s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. P s", "using assms(3) that"], ["proof (prove)\nusing this:\n  I g ?s \\<Longrightarrow> P ?s\n  I (set_to_map (map_to_set g)) s\n\ngoal (1 subgoal):\n 1. P s", "unfolding map_to_set_inverse"], ["proof (prove)\nusing this:\n  I g ?s \\<Longrightarrow> P ?s\n  I g s\n\ngoal (1 subgoal):\n 1. P s", "by this"], ["proof (state)\nthis:\n  I (set_to_map (map_to_set g)) ?s \\<Longrightarrow> P ?s\n\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "fix H x s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "assume 1: \"H \\<subseteq> map_to_set g\" \"I (set_to_map H) s\" \"x \\<in> map_to_set g\" \"x \\<notin> H\""], ["proof (state)\nthis:\n  H \\<subseteq> map_to_set g\n  I (set_to_map H) s\n  x \\<in> map_to_set g\n  x \\<notin> H\n\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "obtain k v where 2: \"x = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. x = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "have 3: \"inj_on fst H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on fst H", "using inj_on_fst_map_to_set inj_on_subset 1(1)"], ["proof (prove)\nusing this:\n  inj_on fst (map_to_set ?m)\n  \\<lbrakk>inj_on ?f ?A; ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?B\n  H \\<subseteq> map_to_set g\n\ngoal (1 subgoal):\n 1. inj_on fst H", "by blast"], ["proof (state)\nthis:\n  inj_on fst H\n\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "have \"f x s = f (k, v) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x s = f (k, v) s", "unfolding 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (k, v) s = f (k, v) s", "by rule"], ["proof (state)\nthis:\n  f x s = f (k, v) s\n\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "also"], ["proof (state)\nthis:\n  f x s = f (k, v) s\n\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "have \"\\<dots> \\<le> SPEC (I (set_to_map H (k \\<mapsto> v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (k, v) s \\<le> SPEC (I (set_to_map H(k \\<mapsto> v)))", "proof (rule assms(4))"], ["proof (state)\ngoal (4 subgoals):\n 1. set_to_map H \\<subseteq>\\<^sub>m g\n 2. I (set_to_map H) s\n 3. g k = Some v\n 4. k \\<notin> dom (set_to_map H)", "show \"set_to_map H \\<subseteq>\\<^sub>m g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_map H \\<subseteq>\\<^sub>m g", "using 1(1) 3"], ["proof (prove)\nusing this:\n  H \\<subseteq> map_to_set g\n  inj_on fst H\n\ngoal (1 subgoal):\n 1. set_to_map H \\<subseteq>\\<^sub>m g", "by (metis inj_on_fst_map_to_set map_leI map_to_set_inverse set_to_map_simp subset_eq)"], ["proof (state)\nthis:\n  set_to_map H \\<subseteq>\\<^sub>m g\n\ngoal (3 subgoals):\n 1. I (set_to_map H) s\n 2. g k = Some v\n 3. k \\<notin> dom (set_to_map H)", "show \"I (set_to_map H) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (set_to_map H) s", "using 1(2)"], ["proof (prove)\nusing this:\n  I (set_to_map H) s\n\ngoal (1 subgoal):\n 1. I (set_to_map H) s", "by this"], ["proof (state)\nthis:\n  I (set_to_map H) s\n\ngoal (2 subgoals):\n 1. g k = Some v\n 2. k \\<notin> dom (set_to_map H)", "show \"g k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g k = Some v", "using 1(3)"], ["proof (prove)\nusing this:\n  x \\<in> map_to_set g\n\ngoal (1 subgoal):\n 1. g k = Some v", "unfolding 2 map_to_set_def"], ["proof (prove)\nusing this:\n  (k, v) \\<in> {(k, v). g k = Some v}\n\ngoal (1 subgoal):\n 1. g k = Some v", "by simp"], ["proof (state)\nthis:\n  g k = Some v\n\ngoal (1 subgoal):\n 1. k \\<notin> dom (set_to_map H)", "show \"k \\<notin> dom (set_to_map H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<notin> dom (set_to_map H)", "using 1(1, 3, 4)"], ["proof (prove)\nusing this:\n  H \\<subseteq> map_to_set g\n  x \\<in> map_to_set g\n  x \\<notin> H\n\ngoal (1 subgoal):\n 1. k \\<notin> dom (set_to_map H)", "unfolding 2 set_to_map_dom"], ["proof (prove)\nusing this:\n  H \\<subseteq> map_to_set g\n  (k, v) \\<in> map_to_set g\n  (k, v) \\<notin> H\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` H", "by (metis fst_conv inj_on_fst_map_to_set inj_on_image_mem_iff)"], ["proof (state)\nthis:\n  k \\<notin> dom (set_to_map H)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (k, v) s \\<le> SPEC (I (set_to_map H(k \\<mapsto> v)))\n\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "also"], ["proof (state)\nthis:\n  f (k, v) s \\<le> SPEC (I (set_to_map H(k \\<mapsto> v)))\n\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "have \"set_to_map H (k \\<mapsto> v) = set_to_map H (fst x \\<mapsto> snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_map H(k \\<mapsto> v) = set_to_map H(fst x \\<mapsto> snd x)", "unfolding 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_map H(k \\<mapsto> v) = set_to_map H(fst (k, v) \\<mapsto>\n    snd (k, v))", "by simp"], ["proof (state)\nthis:\n  set_to_map H(k \\<mapsto> v) = set_to_map H(fst x \\<mapsto> snd x)\n\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "also"], ["proof (state)\nthis:\n  set_to_map H(k \\<mapsto> v) = set_to_map H(fst x \\<mapsto> snd x)\n\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "have \"\\<dots> = set_to_map (insert x H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_map H(fst x \\<mapsto> snd x) = set_to_map (insert x H)", "using 1(1, 3, 4)"], ["proof (prove)\nusing this:\n  H \\<subseteq> map_to_set g\n  x \\<in> map_to_set g\n  x \\<notin> H\n\ngoal (1 subgoal):\n 1. set_to_map H(fst x \\<mapsto> snd x) = set_to_map (insert x H)", "by (metis inj_on_fst_map_to_set inj_on_image_mem_iff set_to_map_insert)"], ["proof (state)\nthis:\n  set_to_map H(fst x \\<mapsto> snd x) = set_to_map (insert x H)\n\ngoal (1 subgoal):\n 1. \\<And>T x s.\n       \\<lbrakk>T \\<subseteq> map_to_set g; I (set_to_map T) s;\n        x \\<in> map_to_set g; x \\<notin> T\\<rbrakk>\n       \\<Longrightarrow> f x s \\<le> SPEC (I (set_to_map (insert x T)))", "finally"], ["proof (chain)\npicking this:\n  f x s \\<le> SPEC (I (set_to_map (insert x H)))", "show \"f x s \\<le> SPEC (I (set_to_map (insert x H)))\""], ["proof (prove)\nusing this:\n  f x s \\<le> SPEC (I (set_to_map (insert x H)))\n\ngoal (1 subgoal):\n 1. f x s \\<le> SPEC (I (set_to_map (insert x H)))", "by this"], ["proof (state)\nthis:\n  f x s \\<le> SPEC (I (set_to_map (insert x H)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FOREACH_rule_insert_eq:\n    assumes \"finite S\"\n    assumes \"X {} = s\"\n    assumes \"X S = t\"\n    assumes \"\\<And> T x. T \\<subseteq> S \\<Longrightarrow> x \\<in> S \\<Longrightarrow> x \\<notin> T \\<Longrightarrow> f x (X T) \\<le> SPEC (HOL.eq (X (insert x T)))\"\n    shows \"FOREACH S f s \\<le> SPEC (HOL.eq t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH S f s \\<le> SPEC ((=) t)", "by (rule FOREACH_rule_insert[where I = \"HOL.eq \\<circ> X\"]) (use assms in auto)"], ["", "lemma FOREACH_rule_map_eq:\n    assumes \"finite (dom g)\"\n    assumes \"X Map.empty = s\"\n    assumes \"X g = t\"\n    assumes \"\\<And> h k v. h \\<subseteq>\\<^sub>m g \\<Longrightarrow> g k = Some v \\<Longrightarrow> k \\<notin> dom h \\<Longrightarrow>\n      f (k, v) (X h) \\<le> SPEC (HOL.eq (X (h (k \\<mapsto> v))))\"\n    shows \"FOREACH (map_to_set g) f s \\<le> SPEC (HOL.eq t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH (map_to_set g) f s \\<le> SPEC ((=) t)", "by (rule FOREACH_rule_map[where I = \"HOL.eq \\<circ> X\"]) (use assms in auto)"], ["", "lemma FOREACH_rule_map_map: \"(FOREACH (map_to_set m) (\\<lambda> (k, v). F k (f k v)),\n    FOREACH (map_to_set (\\<lambda> k. map_option (f k) (m k))) (\\<lambda> (k, v). F k v)) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FOREACH (map_to_set m) (\\<lambda>(k, v). F k (f k v)),\n     FOREACH (map_to_set (\\<lambda>k. map_option (f k) (m k)))\n      (\\<lambda>(k, v). F k v))\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "proof refine_vcg"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       inj_on (?\\<alpha>2 a a') (map_to_set m)\n 2. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       map_to_set (\\<lambda>k. map_option (f k) (m k)) =\n       ?\\<alpha>2 a a' ` map_to_set m\n 3. \\<And>a a' x it \\<sigma> x' it' \\<sigma>' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> Id; x' = ?\\<alpha>2 a a' x; x \\<in> it;\n        x' \\<in> it'; it' = ?\\<alpha>2 a a' ` it;\n        it \\<subseteq> map_to_set m;\n        it' \\<subseteq> map_to_set (\\<lambda>k. map_option (f k) (m k));\n        (\\<sigma>, \\<sigma>') \\<in> Id; x' = (x1, x2);\n        x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> F x1a (f x1a x2a) \\<sigma>\n                         \\<le> \\<Down> Id (F x1 x2 \\<sigma>')", "show \"inj_on (\\<lambda> (k, v). (k, f k v)) (map_to_set m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(k, v). (k, f k v)) (map_to_set m)", "unfolding map_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(k, v). (k, f k v)) {(k, v). m k = Some v}", "by rule auto"], ["proof (state)\nthis:\n  inj_on (\\<lambda>(k, v). (k, f k v)) (map_to_set m)\n\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       map_to_set (\\<lambda>k. map_option (f k) (m k)) =\n       (\\<lambda>(k, v). (k, f k v)) ` map_to_set m\n 2. \\<And>a a' x it \\<sigma> x' it' \\<sigma>' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> Id;\n        x' = (case x of (k, v) \\<Rightarrow> (k, f k v)); x \\<in> it;\n        x' \\<in> it'; it' = (\\<lambda>(k, v). (k, f k v)) ` it;\n        it \\<subseteq> map_to_set m;\n        it' \\<subseteq> map_to_set (\\<lambda>k. map_option (f k) (m k));\n        (\\<sigma>, \\<sigma>') \\<in> Id; x' = (x1, x2);\n        x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> F x1a (f x1a x2a) \\<sigma>\n                         \\<le> \\<Down> Id (F x1 x2 \\<sigma>')", "show \"map_to_set (\\<lambda> k. map_option (f k) (m k)) = (\\<lambda> (k, v). (k, f k v)) ` map_to_set m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set (\\<lambda>k. map_option (f k) (m k)) =\n    (\\<lambda>(k, v). (k, f k v)) ` map_to_set m", "unfolding map_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(k, v). map_option (f k) (m k) = Some v} =\n    (\\<lambda>(k, v). (k, f k v)) ` {(k, v). m k = Some v}", "by auto"], ["proof (state)\nthis:\n  map_to_set (\\<lambda>k. map_option (f k) (m k)) =\n  (\\<lambda>(k, v). (k, f k v)) ` map_to_set m\n\ngoal (1 subgoal):\n 1. \\<And>a a' x it \\<sigma> x' it' \\<sigma>' x1 x2 x1a x2a.\n       \\<lbrakk>(a, a') \\<in> Id;\n        x' = (case x of (k, v) \\<Rightarrow> (k, f k v)); x \\<in> it;\n        x' \\<in> it'; it' = (\\<lambda>(k, v). (k, f k v)) ` it;\n        it \\<subseteq> map_to_set m;\n        it' \\<subseteq> map_to_set (\\<lambda>k. map_option (f k) (m k));\n        (\\<sigma>, \\<sigma>') \\<in> Id; x' = (x1, x2);\n        x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> F x1a (f x1a x2a) \\<sigma>\n                         \\<le> \\<Down> Id (F x1 x2 \\<sigma>')", "qed auto"], ["", "subsection \\<open>Implementations for Sets Represented by Lists\\<close>"], ["", "lemma list_set_rel_Id_on[simp]: \"\\<langle>Id_on A\\<rangle> list_set_rel = \\<langle>Id\\<rangle> list_set_rel \\<inter> UNIV \\<times> Pow A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id_on A\\<rangle>list_set_rel =\n    \\<langle>Id\\<rangle>list_set_rel \\<inter> UNIV \\<times> Pow A", "unfolding list_set_rel_def relcomp_unfold in_br_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, z).\n     \\<exists>y.\n        (x, y) \\<in> \\<langle>Id_on A\\<rangle>list_rel \\<and>\n        z = set y \\<and> distinct y} =\n    {(x, z).\n     \\<exists>y.\n        (x, y) \\<in> \\<langle>Id\\<rangle>list_rel \\<and>\n        z = set y \\<and> distinct y} \\<inter>\n    UNIV \\<times> Pow A", "by auto"], ["", "lemma list_set_card[param]: \"(length, card) \\<in> \\<langle>A\\<rangle> list_set_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length, card)\n    \\<in> \\<langle>A\\<rangle>list_set_rel \\<rightarrow> nat_rel", "unfolding list_set_rel_def relcomp_unfold in_br_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length, card)\n    \\<in> {(x, z).\n           \\<exists>y.\n              (x, y) \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n              z = set y \\<and> distinct y} \\<rightarrow>\n          nat_rel", "by (auto simp: distinct_card list_rel_imp_same_length)"], ["", "lemma list_set_insert[param]:\n    assumes \"y \\<notin> Y\"\n    assumes \"(x, y) \\<in> A\" \"(xs, Y) \\<in> \\<langle>A\\<rangle> list_set_rel\"\n    shows \"(x # xs, insert y Y) \\<in> \\<langle>A\\<rangle> list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs, insert y Y) \\<in> \\<langle>A\\<rangle>list_set_rel", "using assms"], ["proof (prove)\nusing this:\n  y \\<notin> Y\n  (x, y) \\<in> A\n  (xs, Y) \\<in> \\<langle>A\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (x # xs, insert y Y) \\<in> \\<langle>A\\<rangle>list_set_rel", "unfolding list_set_rel_def relcomp_unfold in_br_conv"], ["proof (prove)\nusing this:\n  y \\<notin> Y\n  (x, y) \\<in> A\n  (xs, Y)\n  \\<in> {(x, z).\n         \\<exists>y.\n            (x, y) \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n            z = set y \\<and> distinct y}\n\ngoal (1 subgoal):\n 1. (x # xs, insert y Y)\n    \\<in> {(x, z).\n           \\<exists>y.\n              (x, y) \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n              z = set y \\<and> distinct y}", "by (auto) (metis refine_list(2)[param_fo] distinct.simps(2) list.simps(15))"], ["", "lemma list_set_union[param]:\n    assumes \"X \\<inter> Y = {}\"\n    assumes \"(xs, X) \\<in> \\<langle>A\\<rangle> list_set_rel\" \"(ys, Y) \\<in> \\<langle>A\\<rangle> list_set_rel\"\n    shows \"(xs @ ys, X \\<union> Y) \\<in> \\<langle>A\\<rangle> list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ys, X \\<union> Y) \\<in> \\<langle>A\\<rangle>list_set_rel", "using assms"], ["proof (prove)\nusing this:\n  X \\<inter> Y = {}\n  (xs, X) \\<in> \\<langle>A\\<rangle>list_set_rel\n  (ys, Y) \\<in> \\<langle>A\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (xs @ ys, X \\<union> Y) \\<in> \\<langle>A\\<rangle>list_set_rel", "unfolding list_set_rel_def relcomp_unfold in_br_conv"], ["proof (prove)\nusing this:\n  X \\<inter> Y = {}\n  (xs, X)\n  \\<in> {(x, z).\n         \\<exists>y.\n            (x, y) \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n            z = set y \\<and> distinct y}\n  (ys, Y)\n  \\<in> {(x, z).\n         \\<exists>y.\n            (x, y) \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n            z = set y \\<and> distinct y}\n\ngoal (1 subgoal):\n 1. (xs @ ys, X \\<union> Y)\n    \\<in> {(x, z).\n           \\<exists>y.\n              (x, y) \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n              z = set y \\<and> distinct y}", "by (auto) (meson param_append[param_fo] distinct_append set_union_code)"], ["", "lemma list_set_Union[param]:\n    assumes \"\\<And> X Y. X \\<in> S \\<Longrightarrow> Y \\<in> S \\<Longrightarrow> X \\<noteq> Y \\<Longrightarrow> X \\<inter> Y = {}\"\n    assumes \"(xs, S) \\<in> \\<langle>\\<langle>A\\<rangle> list_set_rel\\<rangle> list_set_rel\"\n    shows \"(concat xs, Union S) \\<in> \\<langle>A\\<rangle> list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel", "note distinct_map[iff]"], ["proof (state)\nthis:\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel", "obtain zs where 1: \"(xs, zs) \\<in> \\<langle>\\<langle>A\\<rangle> list_set_rel\\<rangle> list_rel\" \"S = set zs\" \"distinct zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>zs.\n        \\<lbrakk>(xs, zs)\n                 \\<in> \\<langle>\\<langle>A\\<rangle>list_set_rel\\<rangle>list_rel;\n         S = set zs; distinct zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  (xs, S)\n  \\<in> \\<langle>\\<langle>A\\<rangle>list_set_rel\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (\\<And>zs.\n        \\<lbrakk>(xs, zs)\n                 \\<in> \\<langle>\\<langle>A\\<rangle>list_set_rel\\<rangle>list_rel;\n         S = set zs; distinct zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_set_rel_def relcomp_unfold in_br_conv"], ["proof (prove)\nusing this:\n  (xs, S)\n  \\<in> {(x, z).\n         \\<exists>y.\n            (x, y)\n            \\<in> \\<langle>{(x, z).\n                            \\<exists>y.\n                               (x, y)\n                               \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n                               z = set y \\<and>\n                               distinct y}\\<rangle>list_rel \\<and>\n            z = set y \\<and> distinct y}\n\ngoal (1 subgoal):\n 1. (\\<And>zs.\n        \\<lbrakk>(xs, zs)\n                 \\<in> \\<langle>{(x, z).\n                                 \\<exists>y.\n                                    (x, y)\n                                    \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n                                    z = set y \\<and>\n                                    distinct y}\\<rangle>list_rel;\n         S = set zs; distinct zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (xs, zs) \\<in> \\<langle>\\<langle>A\\<rangle>list_set_rel\\<rangle>list_rel\n  S = set zs\n  distinct zs\n\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel", "obtain ys where 2: \"(xs, ys) \\<in> \\<langle>\\<langle>A\\<rangle> list_rel\\<rangle> list_rel\" \"zs = map set ys\" \"list_all distinct ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>(xs, ys)\n                 \\<in> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>list_rel;\n         zs = map set ys; list_all distinct ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1(1)"], ["proof (prove)\nusing this:\n  (xs, zs) \\<in> \\<langle>\\<langle>A\\<rangle>list_set_rel\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>(xs, ys)\n                 \\<in> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>list_rel;\n         zs = map set ys; list_all distinct ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_set_rel_def list_rel_compp"], ["proof (prove)\nusing this:\n  (xs, zs)\n  \\<in> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>list_rel O\n        \\<langle>br set distinct\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>(xs, ys)\n                 \\<in> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>list_rel;\n         zs = map set ys; list_all distinct ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding relcomp_unfold mem_Collect_eq prod.case"], ["proof (prove)\nusing this:\n  \\<exists>y.\n     (xs, y)\n     \\<in> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>list_rel \\<and>\n     (y, zs) \\<in> \\<langle>br set distinct\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>(xs, ys)\n                 \\<in> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>list_rel;\n         zs = map set ys; list_all distinct ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding br_list_rel in_br_conv"], ["proof (prove)\nusing this:\n  \\<exists>y.\n     (xs, y)\n     \\<in> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>list_rel \\<and>\n     zs = map set y \\<and> list_all distinct y\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>(xs, ys)\n                 \\<in> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>list_rel;\n         zs = map set ys; list_all distinct ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (xs, ys) \\<in> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>list_rel\n  zs = map set ys\n  list_all distinct ys\n\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel", "have 20: \"set a \\<in> S\" \"set b \\<in> S\" \"set a \\<noteq> set b\" if \"a \\<in> set ys\" \"b \\<in> set ys\" \"a \\<noteq> b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. set a \\<in> S &&& set b \\<in> S &&& set a \\<noteq> set b", "using 1(3) that"], ["proof (prove)\nusing this:\n  distinct zs\n  a \\<in> set ys\n  b \\<in> set ys\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. set a \\<in> S &&& set b \\<in> S &&& set a \\<noteq> set b", "unfolding 1(2) 2(2)"], ["proof (prove)\nusing this:\n  distinct (map set ys)\n  a \\<in> set ys\n  b \\<in> set ys\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. set a \\<in> set (map set ys) &&&\n    set b \\<in> set (map set ys) &&& set a \\<noteq> set b", "by (auto dest: inj_onD)"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> set ys; ?b \\<in> set ys; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> set ?a \\<in> S\n  \\<lbrakk>?a \\<in> set ys; ?b \\<in> set ys; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> set ?b \\<in> S\n  \\<lbrakk>?a \\<in> set ys; ?b \\<in> set ys; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> set ?a \\<noteq> set ?b\n\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel", "have 3: \"set a \\<inter> set b = {}\" if \"a \\<in> set ys\" \"b \\<in> set ys\" \"a \\<noteq> b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. set a \\<inter> set b = {}", "using assms(1) 20 that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?X \\<in> S; ?Y \\<in> S; ?X \\<noteq> ?Y\\<rbrakk>\n  \\<Longrightarrow> ?X \\<inter> ?Y = {}\n  \\<lbrakk>?a \\<in> set ys; ?b \\<in> set ys; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> set ?a \\<in> S\n  \\<lbrakk>?a \\<in> set ys; ?b \\<in> set ys; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> set ?b \\<in> S\n  \\<lbrakk>?a \\<in> set ys; ?b \\<in> set ys; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> set ?a \\<noteq> set ?b\n  a \\<in> set ys\n  b \\<in> set ys\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. set a \\<inter> set b = {}", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> set ys; ?b \\<in> set ys; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> set ?a \\<inter> set ?b = {}\n\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel", "have 4: \"Union S = set (concat ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> S = set (concat ys)", "unfolding 1(2) 2(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (map set ys)) = set (concat ys)", "by simp"], ["proof (state)\nthis:\n  \\<Union> S = set (concat ys)\n\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel", "have 5: \"distinct (concat ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (concat ys)", "using 1(3) 2(2, 3) 3"], ["proof (prove)\nusing this:\n  distinct zs\n  zs = map set ys\n  list_all distinct ys\n  \\<lbrakk>?a \\<in> set ys; ?b \\<in> set ys; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> set ?a \\<inter> set ?b = {}\n\ngoal (1 subgoal):\n 1. distinct (concat ys)", "unfolding list.pred_set"], ["proof (prove)\nusing this:\n  distinct zs\n  zs = map set ys\n  Ball (set ys) distinct\n  \\<lbrakk>?a \\<in> set ys; ?b \\<in> set ys; ?a \\<noteq> ?b\\<rbrakk>\n  \\<Longrightarrow> set ?a \\<inter> set ?b = {}\n\ngoal (1 subgoal):\n 1. distinct (concat ys)", "by (blast intro: distinct_concat)"], ["proof (state)\nthis:\n  distinct (concat ys)\n\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel", "have 6: \"(concat xs, concat ys) \\<in> \\<langle>A\\<rangle> list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (concat xs, concat ys) \\<in> \\<langle>A\\<rangle>list_rel", "using 2(1)"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (concat xs, concat ys) \\<in> \\<langle>A\\<rangle>list_rel", "by parametricity"], ["proof (state)\nthis:\n  (concat xs, concat ys) \\<in> \\<langle>A\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel", "unfolding list_set_rel_def relcomp_unfold in_br_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S)\n    \\<in> {(x, z).\n           \\<exists>y.\n              (x, y) \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n              z = set y \\<and> distinct y}", "using 4 5 6"], ["proof (prove)\nusing this:\n  \\<Union> S = set (concat ys)\n  distinct (concat ys)\n  (concat xs, concat ys) \\<in> \\<langle>A\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (concat xs, \\<Union> S)\n    \\<in> {(x, z).\n           \\<exists>y.\n              (x, y) \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n              z = set y \\<and> distinct y}", "by blast"], ["proof (state)\nthis:\n  (concat xs, \\<Union> S) \\<in> \\<langle>A\\<rangle>list_set_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_set_image[param]:\n    assumes \"inj_on g S\"\n    assumes \"(f, g) \\<in> A \\<rightarrow> B\" \"(xs, S) \\<in> \\<langle>A\\<rangle> list_set_rel\"\n    shows \"(map f xs, g ` S) \\<in> \\<langle>B\\<rangle> list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f xs, g ` S) \\<in> \\<langle>B\\<rangle>list_set_rel", "using assms"], ["proof (prove)\nusing this:\n  inj_on g S\n  (f, g) \\<in> A \\<rightarrow> B\n  (xs, S) \\<in> \\<langle>A\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (map f xs, g ` S) \\<in> \\<langle>B\\<rangle>list_set_rel", "unfolding list_set_rel_def relcomp_unfold in_br_conv"], ["proof (prove)\nusing this:\n  inj_on g S\n  (f, g) \\<in> A \\<rightarrow> B\n  (xs, S)\n  \\<in> {(x, z).\n         \\<exists>y.\n            (x, y) \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n            z = set y \\<and> distinct y}\n\ngoal (1 subgoal):\n 1. (map f xs, g ` S)\n    \\<in> {(x, z).\n           \\<exists>y.\n              (x, y) \\<in> \\<langle>B\\<rangle>list_rel \\<and>\n              z = set y \\<and> distinct y}", "using param_map[param_fo] distinct_map"], ["proof (prove)\nusing this:\n  inj_on g S\n  (f, g) \\<in> A \\<rightarrow> B\n  (xs, S)\n  \\<in> {(x, z).\n         \\<exists>y.\n            (x, y) \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n            z = set y \\<and> distinct y}\n  \\<lbrakk>(?x1, ?x'1) \\<in> ?R1.2 \\<rightarrow> ?R2.2;\n   (?x, ?x') \\<in> \\<langle>?R1.2\\<rangle>list_rel\\<rbrakk>\n  \\<Longrightarrow> (map ?x1 ?x, map ?x'1 ?x')\n                    \\<in> \\<langle>?R2.2\\<rangle>list_rel\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n\ngoal (1 subgoal):\n 1. (map f xs, g ` S)\n    \\<in> {(x, z).\n           \\<exists>y.\n              (x, y) \\<in> \\<langle>B\\<rangle>list_rel \\<and>\n              z = set y \\<and> distinct y}", "by fastforce"], ["", "lemma list_set_bind[param]:\n    assumes \"\\<And> x y. x \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> g x \\<inter> g y = {}\"\n    assumes \"(xs, S) \\<in> \\<langle>A\\<rangle> list_set_rel\" \"(f, g) \\<in> A \\<rightarrow> \\<langle>B\\<rangle> list_set_rel\"\n    shows \"(xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle> list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "note [param] = list_set_autoref_filter list_set_autoref_isEmpty"], ["proof (state)\nthis:\n  (filter, op_set_filter)\n  \\<in> (?R \\<rightarrow> bool_rel) \\<rightarrow>\n        \\<langle>?R\\<rangle>list_set_rel \\<rightarrow>\n        \\<langle>?R\\<rangle>list_set_rel\n  (is_Nil, op_set_isEmpty)\n  \\<in> \\<langle>?R\\<rangle>list_set_rel \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "let ?xs = \"filter (Not \\<circ> is_Nil \\<circ> f) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "let ?S = \"op_set_filter (Not \\<circ> op_set_isEmpty \\<circ> g) S\""], ["proof (state)\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "have 1: \"inj_on g ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on g (op_set_filter (Not \\<circ> op_set_isEmpty \\<circ> g) S)", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> S; ?y \\<in> S; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> g ?x \\<inter> g ?y = {}\n\ngoal (1 subgoal):\n 1. inj_on g (op_set_filter (Not \\<circ> op_set_isEmpty \\<circ> g) S)", "by (fastforce intro: inj_onI)"], ["proof (state)\nthis:\n  inj_on g (op_set_filter (Not \\<circ> op_set_isEmpty \\<circ> g) S)\n\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "have \"xs \\<bind> f = concat (map f ?xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<bind> f = concat (map f (filter (Not \\<circ> is_Nil \\<circ> f) xs))", "by (induct xs) (auto split: list.split)"], ["proof (state)\nthis:\n  xs \\<bind> f = concat (map f (filter (Not \\<circ> is_Nil \\<circ> f) xs))\n\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "also"], ["proof (state)\nthis:\n  xs \\<bind> f = concat (map f (filter (Not \\<circ> is_Nil \\<circ> f) xs))\n\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "have \"(\\<dots>, \\<Union> (g ` ?S)) \\<in> \\<langle>B\\<rangle> list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (concat (map f (filter (Not \\<circ> is_Nil \\<circ> f) xs)),\n     \\<Union> (g ` op_set_filter (Not \\<circ> op_set_isEmpty \\<circ> g) S))\n    \\<in> \\<langle>B\\<rangle>list_set_rel", "using assms 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> S; ?y \\<in> S; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> g ?x \\<inter> g ?y = {}\n  (xs, S) \\<in> \\<langle>A\\<rangle>list_set_rel\n  (f, g) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>list_set_rel\n  inj_on g (op_set_filter (Not \\<circ> op_set_isEmpty \\<circ> g) S)\n\ngoal (1 subgoal):\n 1. (concat (map f (filter (Not \\<circ> is_Nil \\<circ> f) xs)),\n     \\<Union> (g ` op_set_filter (Not \\<circ> op_set_isEmpty \\<circ> g) S))\n    \\<in> \\<langle>B\\<rangle>list_set_rel", "by parametricity auto"], ["proof (state)\nthis:\n  (concat (map f (filter (Not \\<circ> is_Nil \\<circ> f) xs)),\n   \\<Union> (g ` op_set_filter (Not \\<circ> op_set_isEmpty \\<circ> g) S))\n  \\<in> \\<langle>B\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "also"], ["proof (state)\nthis:\n  (concat (map f (filter (Not \\<circ> is_Nil \\<circ> f) xs)),\n   \\<Union> (g ` op_set_filter (Not \\<circ> op_set_isEmpty \\<circ> g) S))\n  \\<in> \\<langle>B\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "have \"\\<Union> (g ` ?S) = S \\<bind> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (g ` op_set_filter (Not \\<circ> op_set_isEmpty \\<circ> g) S) =\n    S \\<bind> g", "by auto auto"], ["proof (state)\nthis:\n  \\<Union> (g ` op_set_filter (Not \\<circ> op_set_isEmpty \\<circ> g) S) =\n  S \\<bind> g\n\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "finally"], ["proof (chain)\npicking this:\n  (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel", "by this"], ["proof (state)\nthis:\n  (xs \\<bind> f, S \\<bind> g) \\<in> \\<langle>B\\<rangle>list_set_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Autoref Setup\\<close>"], ["", "(* TODO: inline this? *)"], ["", "lemma dflt_ahm_rel_finite_nat: \"finite_map_rel (\\<langle>nat_rel, V\\<rangle> dflt_ahm_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_map_rel (\\<langle>nat_rel, V\\<rangle>dflt_ahm_rel)", "by tagged_solver"], ["", "context\n  begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "by this"], ["", "lemma [autoref_op_pat]: \"(Some \\<circ> f) |` X \\<equiv> OP (\\<lambda> f X. (Some \\<circ> f) |` X) f X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Some \\<circ> f) |` X \\<equiv>\n    OP (\\<lambda>f. (|`) (Some \\<circ> f)) f X", "by simp"], ["", "lemma [autoref_op_pat]: \"\\<Union>(m ` S) \\<equiv> OP (\\<lambda>S m. \\<Union>(m ` S)) S m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (m ` S) \\<equiv> OP (\\<lambda>S m. \\<Union> (m ` S)) S m", "by simp"], ["", "definition gen_UNION where\n      \"gen_UNION tol emp un X f \\<equiv> fold (un \\<circ> f) (tol X) emp\""], ["", "lemma gen_UNION[autoref_rules_raw]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes to_list: \"SIDE_GEN_ALGO (is_set_to_list A Rs1 tol)\"\n      assumes empty: \"GEN_OP emp {} (\\<langle>B\\<rangle> Rs3)\"\n      assumes union: \"GEN_OP un union (\\<langle>B\\<rangle> Rs2 \\<rightarrow> \\<langle>B\\<rangle> Rs3 \\<rightarrow> \\<langle>B\\<rangle> Rs3)\"\n      shows \"(gen_UNION tol emp un, \\<lambda>A f. \\<Union> (f ` A)) \\<in> \\<langle>A\\<rangle> Rs1 \\<rightarrow> (A \\<rightarrow> \\<langle>B\\<rangle> Rs2) \\<rightarrow> \\<langle>B\\<rangle> Rs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_UNION tol emp un, \\<lambda>A f. \\<Union> (f ` A))\n    \\<in> \\<langle>A\\<rangle>Rs1 \\<rightarrow>\n          (A \\<rightarrow> \\<langle>B\\<rangle>Rs2) \\<rightarrow>\n          \\<langle>B\\<rangle>Rs3", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "note [unfolded autoref_tag_defs, param] = empty union"], ["proof (state)\nthis:\n  (emp, {}) \\<in> \\<langle>B\\<rangle>Rs3\n  (un, (\\<union>))\n  \\<in> \\<langle>B\\<rangle>Rs2 \\<rightarrow>\n        \\<langle>B\\<rangle>Rs3 \\<rightarrow> \\<langle>B\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "fix f g T S"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "assume 1[param]: \"(T, S) \\<in> \\<langle>A\\<rangle> Rs1\" \"(g, f) \\<in> A \\<rightarrow> \\<langle>B\\<rangle> Rs2\""], ["proof (state)\nthis:\n  (T, S) \\<in> \\<langle>A\\<rangle>Rs1\n  (g, f) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "obtain tsl' where\n        [param]: \"(tol T, tsl') \\<in> \\<langle>A\\<rangle> list_rel\"\n        and IT': \"RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tol T, tsl') \\<in> \\<langle>A\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using to_list[unfolded autoref_tag_defs is_set_to_list_def] 1(1)"], ["proof (prove)\nusing this:\n  is_set_to_sorted_list (\\<lambda>_ _. True) A Rs1 tol\n  (T, S) \\<in> \\<langle>A\\<rangle>Rs1\n\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tol T, tsl') \\<in> \\<langle>A\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_set_to_sorted_listE)"], ["proof (state)\nthis:\n  (tol T, tsl') \\<in> \\<langle>A\\<rangle>list_rel\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "from IT'"], ["proof (chain)\npicking this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S", "have 10: \"S = set tsl'\" \"distinct tsl'\""], ["proof (prove)\nusing this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\n\ngoal (1 subgoal):\n 1. S = set tsl' &&& distinct tsl'", "unfolding it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  RETURN tsl'\n  \\<le> SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l)\n\ngoal (1 subgoal):\n 1. S = set tsl' &&& distinct tsl'", "by simp_all"], ["proof (state)\nthis:\n  S = set tsl'\n  distinct tsl'\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "have \"gen_UNION tol emp un T g = fold (un \\<circ> g) (tol T) emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_UNION tol emp un T g = fold (un \\<circ> g) (tol T) emp", "unfolding gen_UNION_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (un \\<circ> g) (tol T) emp = fold (un \\<circ> g) (tol T) emp", "by rule"], ["proof (state)\nthis:\n  gen_UNION tol emp un T g = fold (un \\<circ> g) (tol T) emp\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "also"], ["proof (state)\nthis:\n  gen_UNION tol emp un T g = fold (un \\<circ> g) (tol T) emp\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "have \"(\\<dots>, fold (union \\<circ> f) tsl' {}) \\<in> \\<langle>B\\<rangle> Rs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fold (un \\<circ> g) (tol T) emp, fold ((\\<union>) \\<circ> f) tsl' {})\n    \\<in> \\<langle>B\\<rangle>Rs3", "by parametricity"], ["proof (state)\nthis:\n  (fold (un \\<circ> g) (tol T) emp, fold ((\\<union>) \\<circ> f) tsl' {})\n  \\<in> \\<langle>B\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "also"], ["proof (state)\nthis:\n  (fold (un \\<circ> g) (tol T) emp, fold ((\\<union>) \\<circ> f) tsl' {})\n  \\<in> \\<langle>B\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "have \"fold (union \\<circ> f) tsl' X = \\<Union>(f ` S) \\<union> X\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold ((\\<union>) \\<circ> f) tsl' X = \\<Union> (f ` S) \\<union> X", "unfolding 10(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold ((\\<union>) \\<circ> f) tsl' X = \\<Union> (f ` set tsl') \\<union> X", "by (induct tsl' arbitrary: X) (auto)"], ["proof (state)\nthis:\n  fold ((\\<union>) \\<circ> f) tsl' ?X = \\<Union> (f ` S) \\<union> ?X\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "also"], ["proof (state)\nthis:\n  fold ((\\<union>) \\<circ> f) tsl' ?X = \\<Union> (f ` S) \\<union> ?X\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "have \"\\<Union>(f ` S) \\<union> {} = \\<Union>(f ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (f ` S) \\<union> {} = \\<Union> (f ` S)", "by simp"], ["proof (state)\nthis:\n  \\<Union> (f ` S) \\<union> {} = \\<Union> (f ` S)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A\\<rangle>Rs1;\n        (aa, a'a) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_UNION tol emp un a aa, \\<Union> (a'a ` a'))\n                         \\<in> \\<langle>B\\<rangle>Rs3", "finally"], ["proof (chain)\npicking this:\n  (gen_UNION tol emp un T g, \\<Union> (f ` S)) \\<in> \\<langle>B\\<rangle>Rs3", "show \"(gen_UNION tol emp un T g, \\<Union>(f ` S)) \\<in> \\<langle>B\\<rangle> Rs3\""], ["proof (prove)\nusing this:\n  (gen_UNION tol emp un T g, \\<Union> (f ` S)) \\<in> \\<langle>B\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. (gen_UNION tol emp un T g, \\<Union> (f ` S))\n    \\<in> \\<langle>B\\<rangle>Rs3", "by this"], ["proof (state)\nthis:\n  (gen_UNION tol emp un T g, \\<Union> (f ` S)) \\<in> \\<langle>B\\<rangle>Rs3\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gen_Image where\n      \"gen_Image tol1 mem2 emp3 ins3 X Y \\<equiv> fold\n        (\\<lambda> (a, b). if mem2 a Y then ins3 b else id) (tol1 X) emp3\""], ["", "lemma gen_Image[autoref_rules]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes to_list: \"SIDE_GEN_ALGO (is_set_to_list (A \\<times>\\<^sub>r B) Rs1 tol1)\"\n      assumes member: \"GEN_OP mem2 (\\<in>) (A \\<rightarrow> \\<langle>A\\<rangle> Rs2 \\<rightarrow> bool_rel)\"\n      assumes empty: \"GEN_OP emp3 {} (\\<langle>B\\<rangle> Rs3)\"\n      assumes insert: \"GEN_OP ins3 Set.insert (B \\<rightarrow> \\<langle>B\\<rangle> Rs3 \\<rightarrow> \\<langle>B\\<rangle> Rs3)\"\n      shows \"(gen_Image tol1 mem2 emp3 ins3, Image) \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle> Rs1 \\<rightarrow> \\<langle>A\\<rangle> Rs2 \\<rightarrow> \\<langle>B\\<rangle> Rs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_Image tol1 mem2 emp3 ins3, (``))\n    \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1 \\<rightarrow>\n          \\<langle>A\\<rangle>Rs2 \\<rightarrow> \\<langle>B\\<rangle>Rs3", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "note [unfolded autoref_tag_defs, param] = member empty insert"], ["proof (state)\nthis:\n  (mem2, (\\<in>))\n  \\<in> A \\<rightarrow> \\<langle>A\\<rangle>Rs2 \\<rightarrow> bool_rel\n  (emp3, {}) \\<in> \\<langle>B\\<rangle>Rs3\n  (ins3, insert)\n  \\<in> B \\<rightarrow>\n        \\<langle>B\\<rangle>Rs3 \\<rightarrow> \\<langle>B\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "fix T S X Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "assume 1[param]: \"(T, S) \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle> Rs1\" \"(Y, X) \\<in> \\<langle>A\\<rangle> Rs2\""], ["proof (state)\nthis:\n  (T, S) \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1\n  (Y, X) \\<in> \\<langle>A\\<rangle>Rs2\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "obtain tsl' where\n        [param]: \"(tol1 T, tsl') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle> list_rel\"\n        and IT': \"RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tol1 T, tsl')\n                 \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using to_list[unfolded autoref_tag_defs is_set_to_list_def] 1(1)"], ["proof (prove)\nusing this:\n  is_set_to_sorted_list (\\<lambda>_ _. True) (A \\<times>\\<^sub>r B) Rs1 tol1\n  (T, S) \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1\n\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tol1 T, tsl')\n                 \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_set_to_sorted_listE)"], ["proof (state)\nthis:\n  (tol1 T, tsl') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>list_rel\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "from IT'"], ["proof (chain)\npicking this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S", "have 10: \"S = set tsl'\" \"distinct tsl'\""], ["proof (prove)\nusing this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\n\ngoal (1 subgoal):\n 1. S = set tsl' &&& distinct tsl'", "unfolding it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  RETURN tsl'\n  \\<le> SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l)\n\ngoal (1 subgoal):\n 1. S = set tsl' &&& distinct tsl'", "by simp_all"], ["proof (state)\nthis:\n  S = set tsl'\n  distinct tsl'\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "have \"gen_Image tol1 mem2 emp3 ins3 T Y =\n        fold (\\<lambda> (a, b). if mem2 a Y then ins3 b else id) (tol1 T) emp3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_Image tol1 mem2 emp3 ins3 T Y =\n    fold (\\<lambda>(a, b). if mem2 a Y then ins3 b else id) (tol1 T) emp3", "unfolding gen_Image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(a, b). if mem2 a Y then ins3 b else id) (tol1 T) emp3 =\n    fold (\\<lambda>(a, b). if mem2 a Y then ins3 b else id) (tol1 T) emp3", "by rule"], ["proof (state)\nthis:\n  gen_Image tol1 mem2 emp3 ins3 T Y =\n  fold (\\<lambda>(a, b). if mem2 a Y then ins3 b else id) (tol1 T) emp3\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "also"], ["proof (state)\nthis:\n  gen_Image tol1 mem2 emp3 ins3 T Y =\n  fold (\\<lambda>(a, b). if mem2 a Y then ins3 b else id) (tol1 T) emp3\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "have \"(\\<dots>, fold (\\<lambda> (a, b). if a \\<in> X then Set.insert b else id) tsl' {}) \\<in> \\<langle>B\\<rangle> Rs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fold (\\<lambda>(a, b). if mem2 a Y then ins3 b else id) (tol1 T) emp3,\n     fold (\\<lambda>(a, b). if a \\<in> X then insert b else id) tsl' {})\n    \\<in> \\<langle>B\\<rangle>Rs3", "by parametricity"], ["proof (state)\nthis:\n  (fold (\\<lambda>(a, b). if mem2 a Y then ins3 b else id) (tol1 T) emp3,\n   fold (\\<lambda>(a, b). if a \\<in> X then insert b else id) tsl' {})\n  \\<in> \\<langle>B\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "also"], ["proof (state)\nthis:\n  (fold (\\<lambda>(a, b). if mem2 a Y then ins3 b else id) (tol1 T) emp3,\n   fold (\\<lambda>(a, b). if a \\<in> X then insert b else id) tsl' {})\n  \\<in> \\<langle>B\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "have \"fold (\\<lambda> (a, b). if a \\<in> X then Set.insert b else id) tsl' M = S `` X \\<union> M\" for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(a, b). if a \\<in> X then insert b else id) tsl' M =\n    S `` X \\<union> M", "unfolding 10(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(a, b). if a \\<in> X then insert b else id) tsl' M =\n    set tsl' `` X \\<union> M", "by (induct tsl' arbitrary: M) (auto split: prod.splits)"], ["proof (state)\nthis:\n  fold (\\<lambda>(a, b). if a \\<in> X then insert b else id) tsl' ?M =\n  S `` X \\<union> ?M\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "also"], ["proof (state)\nthis:\n  fold (\\<lambda>(a, b). if a \\<in> X then insert b else id) tsl' ?M =\n  S `` X \\<union> ?M\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "have \"S `` X \\<union> {} = S `` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S `` X \\<union> {} = S `` X", "by simp"], ["proof (state)\nthis:\n  S `` X \\<union> {} = S `` X\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>A \\<times>\\<^sub>r B\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Image tol1 mem2 emp3 ins3 a aa, a' `` a'a)\n                         \\<in> \\<langle>B\\<rangle>Rs3", "finally"], ["proof (chain)\npicking this:\n  (gen_Image tol1 mem2 emp3 ins3 T Y, S `` X) \\<in> \\<langle>B\\<rangle>Rs3", "show \"(gen_Image tol1 mem2 emp3 ins3 T Y, S `` X) \\<in> \\<langle>B\\<rangle> Rs3\""], ["proof (prove)\nusing this:\n  (gen_Image tol1 mem2 emp3 ins3 T Y, S `` X) \\<in> \\<langle>B\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. (gen_Image tol1 mem2 emp3 ins3 T Y, S `` X) \\<in> \\<langle>B\\<rangle>Rs3", "by this"], ["proof (state)\nthis:\n  (gen_Image tol1 mem2 emp3 ins3 T Y, S `` X) \\<in> \\<langle>B\\<rangle>Rs3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_set_union_autoref[autoref_rules]:\n      assumes \"PRIO_TAG_OPTIMIZATION\"\n      assumes \"SIDE_PRECOND_OPT (a' \\<inter> b' = {})\"\n      assumes \"(a, a') \\<in> \\<langle>R\\<rangle> list_set_rel\"\n      assumes \"(b, b') \\<in> \\<langle>R\\<rangle> list_set_rel\"\n      shows \"(a @ b,\n        (OP union ::: \\<langle>R\\<rangle> list_set_rel \\<rightarrow> \\<langle>R\\<rangle> list_set_rel \\<rightarrow> \\<langle>R\\<rangle> list_set_rel) $ a' $ b') \\<in>\n        \\<langle>R\\<rangle> list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a @ b,\n     (OP (\\<union>) :::\n      \\<langle>R\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>R\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>R\\<rangle>list_set_rel) $\n     a' $\n     b')\n    \\<in> \\<langle>R\\<rangle>list_set_rel", "using assms list_set_union"], ["proof (prove)\nusing this:\n  PRIO_TAG_OPTIMIZATION\n  SIDE_PRECOND_OPT (a' \\<inter> b' = {})\n  (a, a') \\<in> \\<langle>R\\<rangle>list_set_rel\n  (b, b') \\<in> \\<langle>R\\<rangle>list_set_rel\n  \\<lbrakk>?X \\<inter> ?Y = {};\n   (?xs, ?X) \\<in> \\<langle>?A\\<rangle>list_set_rel;\n   (?ys, ?Y) \\<in> \\<langle>?A\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> (?xs @ ?ys, ?X \\<union> ?Y)\n                    \\<in> \\<langle>?A\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (a @ b,\n     (OP (\\<union>) :::\n      \\<langle>R\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>R\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>R\\<rangle>list_set_rel) $\n     a' $\n     b')\n    \\<in> \\<langle>R\\<rangle>list_set_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  PRIO_TAG_OPTIMIZATION\n  a' \\<inter> b' = {}\n  (a, a') \\<in> \\<langle>R\\<rangle>list_set_rel\n  (b, b') \\<in> \\<langle>R\\<rangle>list_set_rel\n  \\<lbrakk>?X \\<inter> ?Y = {};\n   (?xs, ?X) \\<in> \\<langle>?A\\<rangle>list_set_rel;\n   (?ys, ?Y) \\<in> \\<langle>?A\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> (?xs @ ?ys, ?X \\<union> ?Y)\n                    \\<in> \\<langle>?A\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (a @ b, a' \\<union> b') \\<in> \\<langle>R\\<rangle>list_set_rel", "by blast"], ["", "lemma list_set_image_autoref[autoref_rules]:\n      assumes \"PRIO_TAG_OPTIMIZATION\"\n      assumes INJ: \"SIDE_PRECOND_OPT (inj_on f s)\"\n      assumes \"\\<And> xi x. (xi, x) \\<in> Ra \\<Longrightarrow> x \\<in> s \\<Longrightarrow> (fi xi, f $ x) \\<in> Rb\"\n      assumes LP: \"(l,s)\\<in>\\<langle>Ra\\<rangle>list_set_rel\"\n      shows \"(map fi l,\n        (OP image ::: (Ra \\<rightarrow> Rb) \\<rightarrow> \\<langle>Ra\\<rangle> list_set_rel \\<rightarrow> \\<langle>Rb\\<rangle> list_set_rel) $ f $ s) \\<in>\n        \\<langle>Rb\\<rangle> list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map fi l,\n     (OP (`) :::\n      (Ra \\<rightarrow> Rb) \\<rightarrow>\n      \\<langle>Ra\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>Rb\\<rangle>list_set_rel) $\n     f $\n     s)\n    \\<in> \\<langle>Rb\\<rangle>list_set_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (map fi l,\n     (OP (`) :::\n      (Ra \\<rightarrow> Rb) \\<rightarrow>\n      \\<langle>Ra\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>Rb\\<rangle>list_set_rel) $\n     f $\n     s)\n    \\<in> \\<langle>Rb\\<rangle>list_set_rel", "from LP"], ["proof (chain)\npicking this:\n  (l, s) \\<in> \\<langle>Ra\\<rangle>list_set_rel", "obtain l' where 1: \"(l,l')\\<in>\\<langle>Ra\\<rangle>list_rel\" and L'S: \"(l',s)\\<in>br set distinct\""], ["proof (prove)\nusing this:\n  (l, s) \\<in> \\<langle>Ra\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n         (l', s) \\<in> br set distinct\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_set_rel_def"], ["proof (prove)\nusing this:\n  (l, s) \\<in> \\<langle>Ra\\<rangle>list_rel O br set distinct\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n         (l', s) \\<in> br set distinct\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\n  (l', s) \\<in> br set distinct\n\ngoal (1 subgoal):\n 1. (map fi l,\n     (OP (`) :::\n      (Ra \\<rightarrow> Rb) \\<rightarrow>\n      \\<langle>Ra\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>Rb\\<rangle>list_set_rel) $\n     f $\n     s)\n    \\<in> \\<langle>Rb\\<rangle>list_set_rel", "have 2: \"s = set l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = set l'", "using L'S"], ["proof (prove)\nusing this:\n  (l', s) \\<in> br set distinct\n\ngoal (1 subgoal):\n 1. s = set l'", "unfolding in_br_conv"], ["proof (prove)\nusing this:\n  s = set l' \\<and> distinct l'\n\ngoal (1 subgoal):\n 1. s = set l'", "by auto"], ["proof (state)\nthis:\n  s = set l'\n\ngoal (1 subgoal):\n 1. (map fi l,\n     (OP (`) :::\n      (Ra \\<rightarrow> Rb) \\<rightarrow>\n      \\<langle>Ra\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>Rb\\<rangle>list_set_rel) $\n     f $\n     s)\n    \\<in> \\<langle>Rb\\<rangle>list_set_rel", "have \"(map fi l, map f l')\\<in>\\<langle>Rb\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map fi l, map f l') \\<in> \\<langle>Rb\\<rangle>list_rel", "using 1 L'S assms(3)"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\n  (l', s) \\<in> br set distinct\n  \\<lbrakk>(?xi, ?x) \\<in> Ra; ?x \\<in> s\\<rbrakk>\n  \\<Longrightarrow> (fi ?xi, f $ ?x) \\<in> Rb\n\ngoal (1 subgoal):\n 1. (map fi l, map f l') \\<in> \\<langle>Rb\\<rangle>list_rel", "unfolding 2 in_br_conv"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\n  set l' = set l' \\<and> distinct l'\n  \\<lbrakk>(?xi, ?x) \\<in> Ra; ?x \\<in> set l'\\<rbrakk>\n  \\<Longrightarrow> (fi ?xi, f $ ?x) \\<in> Rb\n\ngoal (1 subgoal):\n 1. (map fi l, map f l') \\<in> \\<langle>Rb\\<rangle>list_rel", "by induct auto"], ["proof (state)\nthis:\n  (map fi l, map f l') \\<in> \\<langle>Rb\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (map fi l,\n     (OP (`) :::\n      (Ra \\<rightarrow> Rb) \\<rightarrow>\n      \\<langle>Ra\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>Rb\\<rangle>list_set_rel) $\n     f $\n     s)\n    \\<in> \\<langle>Rb\\<rangle>list_set_rel", "also"], ["proof (state)\nthis:\n  (map fi l, map f l') \\<in> \\<langle>Rb\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (map fi l,\n     (OP (`) :::\n      (Ra \\<rightarrow> Rb) \\<rightarrow>\n      \\<langle>Ra\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>Rb\\<rangle>list_set_rel) $\n     f $\n     s)\n    \\<in> \\<langle>Rb\\<rangle>list_set_rel", "from INJ L'S"], ["proof (chain)\npicking this:\n  SIDE_PRECOND_OPT (inj_on f s)\n  (l', s) \\<in> br set distinct", "have \"(map f l',f`s)\\<in>br set distinct\""], ["proof (prove)\nusing this:\n  SIDE_PRECOND_OPT (inj_on f s)\n  (l', s) \\<in> br set distinct\n\ngoal (1 subgoal):\n 1. (map f l', f ` s) \\<in> br set distinct", "by (induct l' arbitrary: s) (auto simp: br_def dest: injD)"], ["proof (state)\nthis:\n  (map f l', f ` s) \\<in> br set distinct\n\ngoal (1 subgoal):\n 1. (map fi l,\n     (OP (`) :::\n      (Ra \\<rightarrow> Rb) \\<rightarrow>\n      \\<langle>Ra\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>Rb\\<rangle>list_set_rel) $\n     f $\n     s)\n    \\<in> \\<langle>Rb\\<rangle>list_set_rel", "finally (relcompI)"], ["proof (chain)\npicking this:\n  (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>list_rel O br set distinct", "show ?thesis"], ["proof (prove)\nusing this:\n  (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>list_rel O br set distinct\n\ngoal (1 subgoal):\n 1. (map fi l,\n     (OP (`) :::\n      (Ra \\<rightarrow> Rb) \\<rightarrow>\n      \\<langle>Ra\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>Rb\\<rangle>list_set_rel) $\n     f $\n     s)\n    \\<in> \\<langle>Rb\\<rangle>list_set_rel", "unfolding autoref_tag_defs list_set_rel_def"], ["proof (prove)\nusing this:\n  (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>list_rel O br set distinct\n\ngoal (1 subgoal):\n 1. (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>list_rel O br set distinct", "by this"], ["proof (state)\nthis:\n  (map fi l,\n   (OP (`) :::\n    (Ra \\<rightarrow> Rb) \\<rightarrow>\n    \\<langle>Ra\\<rangle>list_set_rel \\<rightarrow>\n    \\<langle>Rb\\<rangle>list_set_rel) $\n   f $\n   s)\n  \\<in> \\<langle>Rb\\<rangle>list_set_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_set_UNION_autoref[autoref_rules]:\n      assumes \"PRIO_TAG_OPTIMIZATION\"\n      assumes \"SIDE_PRECOND_OPT (\\<forall> x \\<in> S. \\<forall> y \\<in> S. x \\<noteq> y \\<longrightarrow> g x \\<inter> g y = {})\"\n      assumes \"(xs, S) \\<in> \\<langle>A\\<rangle> list_set_rel\" \"(f, g) \\<in> A \\<rightarrow> \\<langle>B\\<rangle> list_set_rel\"\n      shows \"(xs \\<bind> f,\n        (OP (\\<lambda>A f. \\<Union> (f ` A)) ::: \\<langle>A\\<rangle> list_set_rel \\<rightarrow> (A \\<rightarrow> \\<langle>B\\<rangle> list_set_rel) \\<rightarrow> \\<langle>B\\<rangle> list_set_rel) $ S $ g) \\<in>\n        \\<langle>B\\<rangle> list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<bind> f,\n     (OP (\\<lambda>A f. \\<Union> (f ` A)) :::\n      \\<langle>A\\<rangle>list_set_rel \\<rightarrow>\n      (A \\<rightarrow> \\<langle>B\\<rangle>list_set_rel) \\<rightarrow>\n      \\<langle>B\\<rangle>list_set_rel) $\n     S $\n     g)\n    \\<in> \\<langle>B\\<rangle>list_set_rel", "using assms list_set_bind"], ["proof (prove)\nusing this:\n  PRIO_TAG_OPTIMIZATION\n  SIDE_PRECOND_OPT\n   (\\<forall>x\\<in>S.\n       \\<forall>y\\<in>S.\n          x \\<noteq> y \\<longrightarrow> g x \\<inter> g y = {})\n  (xs, S) \\<in> \\<langle>A\\<rangle>list_set_rel\n  (f, g) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>list_set_rel\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<in> ?S; y \\<in> ?S; x \\<noteq> y\\<rbrakk>\n              \\<Longrightarrow> ?g x \\<inter> ?g y = {};\n   (?xs, ?S) \\<in> \\<langle>?A\\<rangle>list_set_rel;\n   (?f, ?g) \\<in> ?A \\<rightarrow> \\<langle>?B\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> (?xs \\<bind> ?f, ?S \\<bind> ?g)\n                    \\<in> \\<langle>?B\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (xs \\<bind> f,\n     (OP (\\<lambda>A f. \\<Union> (f ` A)) :::\n      \\<langle>A\\<rangle>list_set_rel \\<rightarrow>\n      (A \\<rightarrow> \\<langle>B\\<rangle>list_set_rel) \\<rightarrow>\n      \\<langle>B\\<rangle>list_set_rel) $\n     S $\n     g)\n    \\<in> \\<langle>B\\<rangle>list_set_rel", "unfolding bind_UNION autoref_tag_defs"], ["proof (prove)\nusing this:\n  PRIO_TAG_OPTIMIZATION\n  \\<forall>x\\<in>S.\n     \\<forall>y\\<in>S. x \\<noteq> y \\<longrightarrow> g x \\<inter> g y = {}\n  (xs, S) \\<in> \\<langle>A\\<rangle>list_set_rel\n  (f, g) \\<in> A \\<rightarrow> \\<langle>B\\<rangle>list_set_rel\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<in> ?S; y \\<in> ?S; x \\<noteq> y\\<rbrakk>\n              \\<Longrightarrow> ?g x \\<inter> ?g y = {};\n   (?xs, ?S) \\<in> \\<langle>?A\\<rangle>list_set_rel;\n   (?f, ?g) \\<in> ?A \\<rightarrow> \\<langle>?B\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> (?xs \\<bind> ?f, \\<Union> (?g ` ?S))\n                    \\<in> \\<langle>?B\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (xs \\<bind> f, \\<Union> (g ` S)) \\<in> \\<langle>B\\<rangle>list_set_rel", "by metis"], ["", "definition gen_equals where\n      \"gen_equals ball lu eq f g \\<equiv>\n        ball f (\\<lambda> (k, v). rel_option eq (lu k g) (Some v)) \\<and>\n        ball g (\\<lambda> (k, v). rel_option eq (lu k f) (Some v))\""], ["", "lemma gen_equals[autoref_rules]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes BALL: \"GEN_OP ball op_map_ball (\\<langle>Rk, Rv\\<rangle> Rm \\<rightarrow> (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow> bool_rel)\"\n      assumes LU: \"GEN_OP lu op_map_lookup (Rk \\<rightarrow> \\<langle>Rk, Rv\\<rangle> Rm \\<rightarrow> \\<langle>Rv\\<rangle> option_rel)\"\n      assumes EQ: \"GEN_OP eq HOL.eq (Rv \\<rightarrow> Rv \\<rightarrow> bool_rel)\"\n      shows \"(gen_equals ball lu eq, HOL.eq) \\<in> \\<langle>Rk, Rv\\<rangle> Rm \\<rightarrow> \\<langle>Rk, Rv\\<rangle> Rm \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_equals ball lu eq, (=))\n    \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> bool_rel", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "note [unfolded autoref_tag_defs, param] = BALL LU EQ"], ["proof (state)\nthis:\n  (ball, op_map_ball)\n  \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n        (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n        bool_rel\n  (lu, op_map_lookup)\n  \\<in> Rk \\<rightarrow>\n        \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n        \\<langle>Rv\\<rangle>option_rel\n  (eq, (=)) \\<in> Rv \\<rightarrow> Rv \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "fix fi f gi g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "assume [param]: \"(fi, f) \\<in> \\<langle>Rk, Rv\\<rangle> Rm\" \"(gi, g) \\<in> \\<langle>Rk, Rv\\<rangle> Rm\""], ["proof (state)\nthis:\n  (fi, f) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n  (gi, g) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "have \"gen_equals ball lu eq fi gi \\<longleftrightarrow> ball fi (\\<lambda> (k, v). rel_option eq (lu k gi) (Some v)) \\<and>\n        ball gi (\\<lambda> (k, v). rel_option eq (lu k fi) (Some v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_equals ball lu eq fi gi =\n    (ball fi (\\<lambda>(k, v). rel_option eq (lu k gi) (Some v)) \\<and>\n     ball gi (\\<lambda>(k, v). rel_option eq (lu k fi) (Some v)))", "unfolding gen_equals_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ball fi (\\<lambda>(k, v). rel_option eq (lu k gi) (Some v)) \\<and>\n     ball gi (\\<lambda>(k, v). rel_option eq (lu k fi) (Some v))) =\n    (ball fi (\\<lambda>(k, v). rel_option eq (lu k gi) (Some v)) \\<and>\n     ball gi (\\<lambda>(k, v). rel_option eq (lu k fi) (Some v)))", "by rule"], ["proof (state)\nthis:\n  gen_equals ball lu eq fi gi =\n  (ball fi (\\<lambda>(k, v). rel_option eq (lu k gi) (Some v)) \\<and>\n   ball gi (\\<lambda>(k, v). rel_option eq (lu k fi) (Some v)))\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "also"], ["proof (state)\nthis:\n  gen_equals ball lu eq fi gi =\n  (ball fi (\\<lambda>(k, v). rel_option eq (lu k gi) (Some v)) \\<and>\n   ball gi (\\<lambda>(k, v). rel_option eq (lu k fi) (Some v)))\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "have \"ball fi (\\<lambda> (k, v). rel_option eq (lu k gi) (Some v)) \\<longleftrightarrow>\n        op_map_ball f (\\<lambda> (k, v). rel_option HOL.eq (op_map_lookup k g) (Some v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ball fi (\\<lambda>(k, v). rel_option eq (lu k gi) (Some v)) =\n    op_map_ball f\n     (\\<lambda>(k, v). rel_option (=) (op_map_lookup k g) (Some v))", "by (rule IdD) (parametricity)"], ["proof (state)\nthis:\n  ball fi (\\<lambda>(k, v). rel_option eq (lu k gi) (Some v)) =\n  op_map_ball f\n   (\\<lambda>(k, v). rel_option (=) (op_map_lookup k g) (Some v))\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "also"], ["proof (state)\nthis:\n  ball fi (\\<lambda>(k, v). rel_option eq (lu k gi) (Some v)) =\n  op_map_ball f\n   (\\<lambda>(k, v). rel_option (=) (op_map_lookup k g) (Some v))\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "have \"ball gi (\\<lambda> (k, v). rel_option eq (lu k fi) (Some v)) \\<longleftrightarrow>\n        op_map_ball g (\\<lambda> (k, v). rel_option HOL.eq (op_map_lookup k f) (Some v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ball gi (\\<lambda>(k, v). rel_option eq (lu k fi) (Some v)) =\n    op_map_ball g\n     (\\<lambda>(k, v). rel_option (=) (op_map_lookup k f) (Some v))", "by (rule IdD) (parametricity)"], ["proof (state)\nthis:\n  ball gi (\\<lambda>(k, v). rel_option eq (lu k fi) (Some v)) =\n  op_map_ball g\n   (\\<lambda>(k, v). rel_option (=) (op_map_lookup k f) (Some v))\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "also"], ["proof (state)\nthis:\n  ball gi (\\<lambda>(k, v). rel_option eq (lu k fi) (Some v)) =\n  op_map_ball g\n   (\\<lambda>(k, v). rel_option (=) (op_map_lookup k f) (Some v))\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "have \"op_map_ball f (\\<lambda> (k, v). rel_option HOL.eq (op_map_lookup k g) (Some v)) \\<and>\n        op_map_ball g (\\<lambda> (k, v). rel_option HOL.eq (op_map_lookup k f) (Some v)) \\<longleftrightarrow>\n        (\\<forall> a b. f a = Some b \\<longleftrightarrow> g a = Some b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_map_ball f\n      (\\<lambda>(k, v). rel_option (=) (op_map_lookup k g) (Some v)) \\<and>\n     op_map_ball g\n      (\\<lambda>(k, v). rel_option (=) (op_map_lookup k f) (Some v))) =\n    (\\<forall>a b. (f a = Some b) = (g a = Some b))", "unfolding op_map_ball_def map_to_set_def option.rel_eq op_map_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>(k, v)\\<in>{(k, v). f k = Some v}. g k = Some v) \\<and>\n     (\\<forall>(k, v)\\<in>{(k, v). g k = Some v}. f k = Some v)) =\n    (\\<forall>a b. (f a = Some b) = (g a = Some b))", "by auto"], ["proof (state)\nthis:\n  (op_map_ball f\n    (\\<lambda>(k, v). rel_option (=) (op_map_lookup k g) (Some v)) \\<and>\n   op_map_ball g\n    (\\<lambda>(k, v). rel_option (=) (op_map_lookup k f) (Some v))) =\n  (\\<forall>a b. (f a = Some b) = (g a = Some b))\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "also"], ["proof (state)\nthis:\n  (op_map_ball f\n    (\\<lambda>(k, v). rel_option (=) (op_map_lookup k g) (Some v)) \\<and>\n   op_map_ball g\n    (\\<lambda>(k, v). rel_option (=) (op_map_lookup k f) (Some v))) =\n  (\\<forall>a b. (f a = Some b) = (g a = Some b))\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "have \"(\\<forall> a b. f a = Some b \\<longleftrightarrow> g a = Some b) \\<longleftrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. (f a = Some b) = (g a = Some b)) = (f = g)", "using option.exhaust ext"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = None \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Some x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x. ?f x = ?g x) \\<Longrightarrow> ?f = ?g\n\ngoal (1 subgoal):\n 1. (\\<forall>a b. (f a = Some b) = (g a = Some b)) = (f = g)", "by metis"], ["proof (state)\nthis:\n  (\\<forall>a b. (f a = Some b) = (g a = Some b)) = (f = g)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_equals ball lu eq a aa, a' = a'a)\n                         \\<in> bool_rel", "finally"], ["proof (chain)\npicking this:\n  gen_equals ball lu eq fi gi = (f = g)", "show \"(gen_equals ball lu eq fi gi, f = g) \\<in> bool_rel\""], ["proof (prove)\nusing this:\n  gen_equals ball lu eq fi gi = (f = g)\n\ngoal (1 subgoal):\n 1. (gen_equals ball lu eq fi gi, f = g) \\<in> bool_rel", "by simp"], ["proof (state)\nthis:\n  (gen_equals ball lu eq fi gi, f = g) \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: why don't we just SPEC a list and then use map_of \\<circ> enumerate, all of this\n      could be done right in the implementation so we don't need a generic algorithm *)\n    (* TODO: generic algorithms should really be generic, this is sort of specialized,\n      replace with do { xs \\<leftarrow> op_set_to_list S; RETURN (map_of (xs || [0 ..< length xs])) } *)"], ["", "definition op_set_enumerate :: \"'a set \\<Rightarrow> ('a \\<rightharpoonup> nat) nres\" where\n      \"op_set_enumerate S \\<equiv> SPEC (\\<lambda> f. dom f = S \\<and> inj_on f S)\""], ["", "lemma [autoref_itype]: \"op_set_enumerate ::\\<^sub>i \\<langle>A\\<rangle>\\<^sub>i i_set \\<rightarrow>\\<^sub>i \\<langle>\\<langle>A, i_nat\\<rangle>\\<^sub>i i_map\\<rangle>\\<^sub>i i_nres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_set_enumerate ::\\<^sub>i\n    \\<langle>A\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>A, i_nat\\<rangle>\\<^sub>ii_map\\<rangle>\\<^sub>ii_nres", "by simp"], ["", "lemma [autoref_hom]: \"CONSTRAINT op_set_enumerate (\\<langle>A\\<rangle> Rs \\<rightarrow> \\<langle>\\<langle>A, nat_rel\\<rangle> Rm\\<rangle> nres_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT op_set_enumerate\n     (\\<langle>A\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>A,\n      nat_rel\\<rangle>Rm\\<rangle>nres_rel)", "by simp"], ["", "definition gen_enumerate where\n      \"gen_enumerate tol upd emp S \\<equiv> snd (fold (\\<lambda> x (k, m). (Suc k, upd x k m)) (tol S) (0, emp))\""], ["", "lemma gen_enumerate[autoref_rules_raw]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes to_list: \"SIDE_GEN_ALGO (is_set_to_list A Rs tol)\"\n      assumes empty: \"GEN_OP emp op_map_empty (\\<langle>A, nat_rel\\<rangle> Rm)\"\n      assumes update: \"GEN_OP upd op_map_update (A \\<rightarrow> nat_rel \\<rightarrow> \\<langle>A, nat_rel\\<rangle> Rm \\<rightarrow> \\<langle>A, nat_rel\\<rangle> Rm)\"\n      shows \"(\\<lambda> S. RETURN (gen_enumerate tol upd emp S), op_set_enumerate) \\<in>\n        \\<langle>A\\<rangle> Rs \\<rightarrow> \\<langle>\\<langle>A, nat_rel\\<rangle> Rm\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>S. RETURN (gen_enumerate tol upd emp S), op_set_enumerate)\n    \\<in> \\<langle>A\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>A,\n          nat_rel\\<rangle>Rm\\<rangle>nres_rel", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "note [unfolded autoref_tag_defs, param] = empty update"], ["proof (state)\nthis:\n  (emp, op_map_empty) \\<in> \\<langle>A, nat_rel\\<rangle>Rm\n  (upd, op_map_update)\n  \\<in> A \\<rightarrow>\n        nat_rel \\<rightarrow>\n        \\<langle>A, nat_rel\\<rangle>Rm \\<rightarrow> \\<langle>A,\n        nat_rel\\<rangle>Rm\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "fix T S"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "assume 1: \"(T, S) \\<in> \\<langle>A\\<rangle> Rs\""], ["proof (state)\nthis:\n  (T, S) \\<in> \\<langle>A\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "obtain tsl' where\n        [param]: \"(tol T, tsl') \\<in> \\<langle>A\\<rangle>list_rel\"\n        and IT': \"RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tol T, tsl') \\<in> \\<langle>A\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using to_list[unfolded autoref_tag_defs is_set_to_list_def] 1"], ["proof (prove)\nusing this:\n  is_set_to_sorted_list (\\<lambda>_ _. True) A Rs tol\n  (T, S) \\<in> \\<langle>A\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tol T, tsl') \\<in> \\<langle>A\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_set_to_sorted_listE)"], ["proof (state)\nthis:\n  (tol T, tsl') \\<in> \\<langle>A\\<rangle>list_rel\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "from IT'"], ["proof (chain)\npicking this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S", "have 10: \"S = set tsl'\" \"distinct tsl'\""], ["proof (prove)\nusing this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\n\ngoal (1 subgoal):\n 1. S = set tsl' &&& distinct tsl'", "unfolding it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  RETURN tsl'\n  \\<le> SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l)\n\ngoal (1 subgoal):\n 1. S = set tsl' &&& distinct tsl'", "by simp_all"], ["proof (state)\nthis:\n  S = set tsl'\n  distinct tsl'\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "have 2: \"dom (snd (fold (\\<lambda> x (k, m). (Suc k, m (x \\<mapsto> k))) tsl' (k, m))) = dom m \\<union> set tsl'\"\n        for k m"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (snd (fold (\\<lambda>x (k, m). (Suc k, m(x \\<mapsto> k))) tsl'\n               (k, m))) =\n    dom m \\<union> set tsl'", "by (induct tsl' arbitrary: k m) (auto)"], ["proof (state)\nthis:\n  dom (snd (fold (\\<lambda>x (k, m). (Suc k, m(x \\<mapsto> k))) tsl'\n             (?k, ?m))) =\n  dom ?m \\<union> set tsl'\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "have 3: \"inj_on (snd (fold (\\<lambda> x (k, m). (Suc k, m (x \\<mapsto> k))) tsl' (0, Map.empty))) (set tsl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (snd (fold (\\<lambda>x (k, m). (Suc k, m(x \\<mapsto> k))) tsl'\n            (0, Map.empty)))\n     (set tsl')", "using 10(2)"], ["proof (prove)\nusing this:\n  distinct tsl'\n\ngoal (1 subgoal):\n 1. inj_on\n     (snd (fold (\\<lambda>x (k, m). (Suc k, m(x \\<mapsto> k))) tsl'\n            (0, Map.empty)))\n     (set tsl')", "by (auto intro!: inj_onI simp: fold_map_of)\n          (metis diff_zero distinct_Ex1 distinct_upt length_upt map_of_zip_nth option.simps(1))"], ["proof (state)\nthis:\n  inj_on\n   (snd (fold (\\<lambda>x (k, m). (Suc k, m(x \\<mapsto> k))) tsl'\n          (0, Map.empty)))\n   (set tsl')\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "let ?f = \"RETURN (snd (fold (\\<lambda> x (k, m). (Suc k, op_map_update x k m)) tsl' (0, op_map_empty)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "have \"(RETURN (gen_enumerate tol upd emp T), ?f) \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle> Rm\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (gen_enumerate tol upd emp T),\n     RETURN\n      (snd (fold (\\<lambda>x (k, m). (Suc k, op_map_update x k m)) tsl'\n             (0, op_map_empty))))\n    \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "unfolding gen_enumerate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN\n      (snd (fold (\\<lambda>x (k, m). (Suc k, upd x k m)) (tol T) (0, emp))),\n     RETURN\n      (snd (fold (\\<lambda>x (k, m). (Suc k, op_map_update x k m)) tsl'\n             (0, op_map_empty))))\n    \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "by parametricity"], ["proof (state)\nthis:\n  (RETURN (gen_enumerate tol upd emp T),\n   RETURN\n    (snd (fold (\\<lambda>x (k, m). (Suc k, op_map_update x k m)) tsl'\n           (0, op_map_empty))))\n  \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  (RETURN (gen_enumerate tol upd emp T),\n   RETURN\n    (snd (fold (\\<lambda>x (k, m). (Suc k, op_map_update x k m)) tsl'\n           (0, op_map_empty))))\n  \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "have \"(?f, op_set_enumerate S) \\<in> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN\n      (snd (fold (\\<lambda>x (k, m). (Suc k, op_map_update x k m)) tsl'\n             (0, op_map_empty))),\n     op_set_enumerate S)\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding op_set_enumerate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN\n      (snd (fold (\\<lambda>x (k, m). (Suc k, op_map_update x k m)) tsl'\n             (0, op_map_empty))),\n     SPEC (\\<lambda>f. dom f = S \\<and> inj_on f S))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "using 2 3 10"], ["proof (prove)\nusing this:\n  dom (snd (fold (\\<lambda>x (k, m). (Suc k, m(x \\<mapsto> k))) tsl'\n             (?k, ?m))) =\n  dom ?m \\<union> set tsl'\n  inj_on\n   (snd (fold (\\<lambda>x (k, m). (Suc k, m(x \\<mapsto> k))) tsl'\n          (0, Map.empty)))\n   (set tsl')\n  S = set tsl'\n  distinct tsl'\n\ngoal (1 subgoal):\n 1. (RETURN\n      (snd (fold (\\<lambda>x (k, m). (Suc k, op_map_update x k m)) tsl'\n             (0, op_map_empty))),\n     SPEC (\\<lambda>f. dom f = S \\<and> inj_on f S))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "by refine_vcg auto"], ["proof (state)\nthis:\n  (RETURN\n    (snd (fold (\\<lambda>x (k, m). (Suc k, op_map_update x k m)) tsl'\n           (0, op_map_empty))),\n   op_set_enumerate S)\n  \\<in> \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>A\\<rangle>Rs \\<Longrightarrow>\n       (RETURN (gen_enumerate tol upd emp a), op_set_enumerate a')\n       \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "finally"], ["proof (chain)\npicking this:\n  (RETURN (gen_enumerate tol upd emp T), op_set_enumerate S)\n  \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel O\n        \\<langle>Id\\<rangle>nres_rel", "show \"(RETURN (gen_enumerate tol upd emp T), op_set_enumerate S) \\<in>\n        \\<langle>\\<langle>A, nat_rel\\<rangle> Rm\\<rangle> nres_rel\""], ["proof (prove)\nusing this:\n  (RETURN (gen_enumerate tol upd emp T), op_set_enumerate S)\n  \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel O\n        \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (gen_enumerate tol upd emp T), op_set_enumerate S)\n    \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "unfolding nres_rel_comp"], ["proof (prove)\nusing this:\n  (RETURN (gen_enumerate tol upd emp T), op_set_enumerate S)\n  \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm O Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (gen_enumerate tol upd emp T), op_set_enumerate S)\n    \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel", "by simp"], ["proof (state)\nthis:\n  (RETURN (gen_enumerate tol upd emp T), op_set_enumerate S)\n  \\<in> \\<langle>\\<langle>A, nat_rel\\<rangle>Rm\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gen_enumerate_it_to_list[refine_transfer_post_simp]:\n      \"gen_enumerate (it_to_list it) =\n       (\\<lambda> upd emp S. snd (foldli (it_to_list it S) (\\<lambda> _. True)\n      (\\<lambda> x s. case s of (k, m) \\<Rightarrow> (Suc k, upd x k m)) (0, emp)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_enumerate (it_to_list it) =\n    (\\<lambda>upd emp S.\n        snd (foldli (it_to_list it S) (\\<lambda>_. True)\n              (\\<lambda>x s.\n                  case s of (k, m) \\<Rightarrow> (Suc k, upd x k m))\n              (0, emp)))", "unfolding gen_enumerate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>upd emp S.\n        snd (fold (\\<lambda>x (k, m). (Suc k, upd x k m)) (it_to_list it S)\n              (0, emp))) =\n    (\\<lambda>upd emp S.\n        snd (foldli (it_to_list it S) (\\<lambda>_. True)\n              (\\<lambda>x s.\n                  case s of (k, m) \\<Rightarrow> (Suc k, upd x k m))\n              (0, emp)))", "unfolding foldl_conv_fold[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>upd emp S.\n        snd (foldl\n              (\\<lambda>s x.\n                  case s of (k, m) \\<Rightarrow> (Suc k, upd x k m))\n              (0, emp) (it_to_list it S))) =\n    (\\<lambda>upd emp S.\n        snd (foldli (it_to_list it S) (\\<lambda>_. True)\n              (\\<lambda>x s.\n                  case s of (k, m) \\<Rightarrow> (Suc k, upd x k m))\n              (0, emp)))", "unfolding foldli_foldl[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>upd emp S.\n        snd (foldli (it_to_list it S) (\\<lambda>_. True)\n              (\\<lambda>x s.\n                  case s of (k, m) \\<Rightarrow> (Suc k, upd x k m))\n              (0, emp))) =\n    (\\<lambda>upd emp S.\n        snd (foldli (it_to_list it S) (\\<lambda>_. True)\n              (\\<lambda>x s.\n                  case s of (k, m) \\<Rightarrow> (Suc k, upd x k m))\n              (0, emp)))", "by rule"], ["", "definition gen_build where\n      \"gen_build tol upd emp f X \\<equiv> fold (\\<lambda> x. upd x (f x)) (tol X) emp\""], ["", "lemma gen_build[autoref_rules]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes to_list: \"SIDE_GEN_ALGO (is_set_to_list A Rs tol)\"\n      assumes empty: \"GEN_OP emp op_map_empty (\\<langle>A, B\\<rangle> Rm)\"\n      assumes update: \"GEN_OP upd op_map_update (A \\<rightarrow> B \\<rightarrow> \\<langle>A, B\\<rangle> Rm \\<rightarrow> \\<langle>A, B\\<rangle> Rm)\"\n      shows \"(\\<lambda> f X. gen_build tol upd emp f X, \\<lambda> f X. (Some \\<circ> f) |` X) \\<in>\n        (A \\<rightarrow> B) \\<rightarrow> \\<langle>A\\<rangle> Rs \\<rightarrow> \\<langle>A, B\\<rangle> Rm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_build tol upd emp, \\<lambda>f. (|`) (Some \\<circ> f))\n    \\<in> (A \\<rightarrow> B) \\<rightarrow>\n          \\<langle>A\\<rangle>Rs \\<rightarrow> \\<langle>A, B\\<rangle>Rm", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "note [unfolded autoref_tag_defs, param] = empty update"], ["proof (state)\nthis:\n  (emp, op_map_empty) \\<in> \\<langle>A, B\\<rangle>Rm\n  (upd, op_map_update)\n  \\<in> A \\<rightarrow>\n        B \\<rightarrow>\n        \\<langle>A, B\\<rangle>Rm \\<rightarrow> \\<langle>A, B\\<rangle>Rm\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "fix f g T S"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "assume 1[param]: \"(g, f) \\<in> A \\<rightarrow> B\" \"(T, S) \\<in> \\<langle>A\\<rangle> Rs\""], ["proof (state)\nthis:\n  (g, f) \\<in> A \\<rightarrow> B\n  (T, S) \\<in> \\<langle>A\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "obtain tsl' where\n        [param]: \"(tol T, tsl') \\<in> \\<langle>A\\<rangle>list_rel\"\n        and IT': \"RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tol T, tsl') \\<in> \\<langle>A\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using to_list[unfolded autoref_tag_defs is_set_to_list_def] 1(2)"], ["proof (prove)\nusing this:\n  is_set_to_sorted_list (\\<lambda>_ _. True) A Rs tol\n  (T, S) \\<in> \\<langle>A\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tol T, tsl') \\<in> \\<langle>A\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_set_to_sorted_listE)"], ["proof (state)\nthis:\n  (tol T, tsl') \\<in> \\<langle>A\\<rangle>list_rel\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "from IT'"], ["proof (chain)\npicking this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S", "have 10: \"S = set tsl'\" \"distinct tsl'\""], ["proof (prove)\nusing this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) S\n\ngoal (1 subgoal):\n 1. S = set tsl' &&& distinct tsl'", "unfolding it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  RETURN tsl'\n  \\<le> SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             S = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l)\n\ngoal (1 subgoal):\n 1. S = set tsl' &&& distinct tsl'", "by simp_all"], ["proof (state)\nthis:\n  S = set tsl'\n  distinct tsl'\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "have \"gen_build tol upd emp g T = fold (\\<lambda> x. upd x (g x)) (tol T) emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_build tol upd emp g T = fold (\\<lambda>x. upd x (g x)) (tol T) emp", "unfolding gen_build_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>x. upd x (g x)) (tol T) emp =\n    fold (\\<lambda>x. upd x (g x)) (tol T) emp", "by rule"], ["proof (state)\nthis:\n  gen_build tol upd emp g T = fold (\\<lambda>x. upd x (g x)) (tol T) emp\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "also"], ["proof (state)\nthis:\n  gen_build tol upd emp g T = fold (\\<lambda>x. upd x (g x)) (tol T) emp\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "have \"(\\<dots>, fold (\\<lambda> x. op_map_update x (f x)) tsl' op_map_empty) \\<in> \\<langle>A, B\\<rangle> Rm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fold (\\<lambda>x. upd x (g x)) (tol T) emp,\n     fold (\\<lambda>x. op_map_update x (f x)) tsl' op_map_empty)\n    \\<in> \\<langle>A, B\\<rangle>Rm", "by parametricity"], ["proof (state)\nthis:\n  (fold (\\<lambda>x. upd x (g x)) (tol T) emp,\n   fold (\\<lambda>x. op_map_update x (f x)) tsl' op_map_empty)\n  \\<in> \\<langle>A, B\\<rangle>Rm\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "also"], ["proof (state)\nthis:\n  (fold (\\<lambda>x. upd x (g x)) (tol T) emp,\n   fold (\\<lambda>x. op_map_update x (f x)) tsl' op_map_empty)\n  \\<in> \\<langle>A, B\\<rangle>Rm\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "have \"fold (\\<lambda> x. op_map_update x (f x)) tsl' m = m ++ (Some \\<circ> f) |` S\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>x. op_map_update x (f x)) tsl' m =\n    m ++ (Some \\<circ> f) |` S", "unfolding 10 op_map_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>x m. m(x \\<mapsto> f x)) tsl' m =\n    m ++ (Some \\<circ> f) |` set tsl'", "by (induct tsl' arbitrary: m rule: rev_induct) (auto simp add: restrict_map_insert)"], ["proof (state)\nthis:\n  fold (\\<lambda>x. op_map_update x (f x)) tsl' ?m =\n  ?m ++ (Some \\<circ> f) |` S\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "also"], ["proof (state)\nthis:\n  fold (\\<lambda>x. op_map_update x (f x)) tsl' ?m =\n  ?m ++ (Some \\<circ> f) |` S\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "have \"op_map_empty ++ (Some \\<circ> f) |` S = (Some \\<circ> f) |` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_map_empty ++ (Some \\<circ> f) |` S = (Some \\<circ> f) |` S", "by simp"], ["proof (state)\nthis:\n  op_map_empty ++ (Some \\<circ> f) |` S = (Some \\<circ> f) |` S\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> A \\<rightarrow> B;\n        (aa, a'a) \\<in> \\<langle>A\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_build tol upd emp a aa,\n                          (Some \\<circ> a') |` a'a)\n                         \\<in> \\<langle>A, B\\<rangle>Rm", "finally"], ["proof (chain)\npicking this:\n  (gen_build tol upd emp g T, (Some \\<circ> f) |` S) \\<in> \\<langle>A,\n  B\\<rangle>Rm", "show \"(gen_build tol upd emp g T, (Some \\<circ> f) |` S) \\<in> \\<langle>A, B\\<rangle> Rm\""], ["proof (prove)\nusing this:\n  (gen_build tol upd emp g T, (Some \\<circ> f) |` S) \\<in> \\<langle>A,\n  B\\<rangle>Rm\n\ngoal (1 subgoal):\n 1. (gen_build tol upd emp g T, (Some \\<circ> f) |` S) \\<in> \\<langle>A,\n    B\\<rangle>Rm", "by this"], ["proof (state)\nthis:\n  (gen_build tol upd emp g T, (Some \\<circ> f) |` S) \\<in> \\<langle>A,\n  B\\<rangle>Rm\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"to_list it s \\<equiv> it s top Cons Nil\""], ["", "lemma map2set_to_list:\n      assumes \"GEN_ALGO_tag (is_map_to_list Rk unit_rel R it)\"\n      shows \"is_set_to_list Rk (map2set_rel R) (to_list (map_iterator_dom \\<circ> (foldli \\<circ> it)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_set_to_list Rk (map2set_rel R)\n     (to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "unfolding is_set_to_list_def is_set_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<longrightarrow>\n       (\\<exists>l'.\n           (to_list\n             ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n             s,\n            l')\n           \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n           RETURN l' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s')", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<Longrightarrow>\n       \\<exists>l'.\n          (to_list\n            ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n            s,\n           l')\n          \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n          RETURN l' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'", "fix f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<Longrightarrow>\n       \\<exists>l'.\n          (to_list\n            ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n            s,\n           l')\n          \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n          RETURN l' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'", "assume 1: \"(f, g) \\<in> \\<langle>Rk\\<rangle> map2set_rel R\""], ["proof (state)\nthis:\n  (f, g) \\<in> \\<langle>Rk\\<rangle>map2set_rel R\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<Longrightarrow>\n       \\<exists>l'.\n          (to_list\n            ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n            s,\n           l')\n          \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n          RETURN l' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'", "obtain xs where 2: \"(it_to_list (map_iterator_dom \\<circ> (foldli \\<circ> it)) f, xs) \\<in> \\<langle>Rk\\<rangle> list_rel\"\n        \"RETURN xs \\<le> it_to_sorted_list (\\<lambda> _ _. True) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>(it_to_list\n                   ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>))\n                     foldli it)\n                   f,\n                  xs)\n                 \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN xs \\<le> it_to_sorted_list (\\<lambda>_ _. True) g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using map2set_to_list[OF assms] 1"], ["proof (prove)\nusing this:\n  is_set_to_list Rk (map2set_rel R)\n   (it_to_list\n     ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))\n  (f, g) \\<in> \\<langle>Rk\\<rangle>map2set_rel R\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>(it_to_list\n                   ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>))\n                     foldli it)\n                   f,\n                  xs)\n                 \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN xs \\<le> it_to_sorted_list (\\<lambda>_ _. True) g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_set_to_list_def is_set_to_sorted_list_def"], ["proof (prove)\nusing this:\n  \\<forall>s s'.\n     (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<longrightarrow>\n     (\\<exists>l'.\n         (it_to_list\n           ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) s,\n          l')\n         \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n         RETURN l' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s')\n  (f, g) \\<in> \\<langle>Rk\\<rangle>map2set_rel R\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>(it_to_list\n                   ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>))\n                     foldli it)\n                   f,\n                  xs)\n                 \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN xs \\<le> it_to_sorted_list (\\<lambda>_ _. True) g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (it_to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n    f,\n   xs)\n  \\<in> \\<langle>Rk\\<rangle>list_rel\n  RETURN xs \\<le> it_to_sorted_list (\\<lambda>_ _. True) g\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<Longrightarrow>\n       \\<exists>l'.\n          (to_list\n            ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n            s,\n           l')\n          \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n          RETURN l' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'", "have 3: \"map_iterator_dom (foldli xs) top (#) a =\n        rev (map_iterator_dom (foldli xs) (\\<lambda> _. True) (\\<lambda> x l. l @ [x]) (rev a))\"\n          for xs :: \"('k \\<times> unit) list\" and a"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_dom (foldli xs) top (#) a =\n    rev (map_iterator_dom (foldli xs) (\\<lambda>_. True)\n          (\\<lambda>x l. l @ [x]) (rev a))", "unfolding map_iterator_dom_def set_iterator_image_def set_iterator_image_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli xs top\n     (\\<lambda>x \\<sigma>.\n         case Some (fst x) of None \\<Rightarrow> \\<sigma>\n         | Some x' \\<Rightarrow> x' # \\<sigma>)\n     a =\n    rev (foldli xs (\\<lambda>_. True)\n          (\\<lambda>x \\<sigma>.\n              case Some (fst x) of None \\<Rightarrow> \\<sigma>\n              | Some x' \\<Rightarrow> \\<sigma> @ [x'])\n          (rev a))", "by (induct xs arbitrary: a) (auto)"], ["proof (state)\nthis:\n  map_iterator_dom (foldli ?xs1) top (#) ?a1 =\n  rev (map_iterator_dom (foldli ?xs1) (\\<lambda>_. True)\n        (\\<lambda>x l. l @ [x]) (rev ?a1))\n\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<Longrightarrow>\n       \\<exists>l'.\n          (to_list\n            ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n            s,\n           l')\n          \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n          RETURN l' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'", "show \"\\<exists> xs. (to_list (map_iterator_dom \\<circ> (foldli \\<circ> it)) f, xs) \\<in> \\<langle>Rk\\<rangle> list_rel \\<and>\n        RETURN xs \\<le> it_to_sorted_list (\\<lambda> _ _. True) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       (to_list\n         ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) f,\n        xs)\n       \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n       RETURN xs \\<le> it_to_sorted_list (\\<lambda>_ _. True) g", "proof (intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n      f,\n     ?xs)\n    \\<in> \\<langle>Rk\\<rangle>list_rel\n 2. RETURN ?xs \\<le> it_to_sorted_list (\\<lambda>_ _. True) g", "have \"to_list (map_iterator_dom \\<circ> (foldli \\<circ> it)) f =\n          rev (it_to_list (map_iterator_dom \\<circ> (foldli \\<circ> it)) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n     f =\n    rev (it_to_list\n          ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) f)", "unfolding to_list_def it_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it f top (#)\n     [] =\n    rev ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it f\n          (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [])", "by (simp add: 3)"], ["proof (state)\nthis:\n  to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) f =\n  rev (it_to_list\n        ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) f)\n\ngoal (2 subgoals):\n 1. (to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n      f,\n     ?xs)\n    \\<in> \\<langle>Rk\\<rangle>list_rel\n 2. RETURN ?xs \\<le> it_to_sorted_list (\\<lambda>_ _. True) g", "also"], ["proof (state)\nthis:\n  to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) f =\n  rev (it_to_list\n        ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) f)\n\ngoal (2 subgoals):\n 1. (to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n      f,\n     ?xs)\n    \\<in> \\<langle>Rk\\<rangle>list_rel\n 2. RETURN ?xs \\<le> it_to_sorted_list (\\<lambda>_ _. True) g", "have \"(rev (it_to_list (map_iterator_dom \\<circ> (foldli \\<circ> it)) f), rev xs) \\<in> \\<langle>Rk\\<rangle> list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rev (it_to_list\n           ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n           f),\n     rev xs)\n    \\<in> \\<langle>Rk\\<rangle>list_rel", "using 2(1)"], ["proof (prove)\nusing this:\n  (it_to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n    f,\n   xs)\n  \\<in> \\<langle>Rk\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (rev (it_to_list\n           ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n           f),\n     rev xs)\n    \\<in> \\<langle>Rk\\<rangle>list_rel", "by parametricity"], ["proof (state)\nthis:\n  (rev (it_to_list\n         ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) f),\n   rev xs)\n  \\<in> \\<langle>Rk\\<rangle>list_rel\n\ngoal (2 subgoals):\n 1. (to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n      f,\n     ?xs)\n    \\<in> \\<langle>Rk\\<rangle>list_rel\n 2. RETURN ?xs \\<le> it_to_sorted_list (\\<lambda>_ _. True) g", "finally"], ["proof (chain)\npicking this:\n  (to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) f,\n   rev xs)\n  \\<in> \\<langle>Rk\\<rangle>list_rel", "show \"(to_list (map_iterator_dom \\<circ> (foldli \\<circ> it)) f, rev xs) \\<in> \\<langle>Rk\\<rangle> list_rel\""], ["proof (prove)\nusing this:\n  (to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) f,\n   rev xs)\n  \\<in> \\<langle>Rk\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n      f,\n     rev xs)\n    \\<in> \\<langle>Rk\\<rangle>list_rel", "by this"], ["proof (state)\nthis:\n  (to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) f,\n   rev xs)\n  \\<in> \\<langle>Rk\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. RETURN (rev xs) \\<le> it_to_sorted_list (\\<lambda>_ _. True) g", "show \"RETURN (rev xs) \\<le> it_to_sorted_list (\\<lambda> _ _. True) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (rev xs) \\<le> it_to_sorted_list (\\<lambda>_ _. True) g", "using 2(2)"], ["proof (prove)\nusing this:\n  RETURN xs \\<le> it_to_sorted_list (\\<lambda>_ _. True) g\n\ngoal (1 subgoal):\n 1. RETURN (rev xs) \\<le> it_to_sorted_list (\\<lambda>_ _. True) g", "unfolding it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  RETURN xs\n  \\<le> SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             g = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l)\n\ngoal (1 subgoal):\n 1. RETURN (rev xs)\n    \\<le> SPEC\n           (\\<lambda>l.\n               distinct l \\<and>\n               g = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l)", "by auto"], ["proof (state)\nthis:\n  RETURN (rev xs) \\<le> it_to_sorted_list (\\<lambda>_ _. True) g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     (to_list ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it)\n       f,\n      xs)\n     \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n     RETURN xs \\<le> it_to_sorted_list (\\<lambda>_ _. True) g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CAST_to_list[autoref_rules_raw]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes \"SIDE_GEN_ALGO (is_set_to_list A Rs tol)\"\n      shows \"(tol, CAST) \\<in> \\<langle>A\\<rangle> Rs \\<rightarrow> \\<langle>A\\<rangle> list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tol, CAST)\n    \\<in> \\<langle>A\\<rangle>Rs \\<rightarrow>\n          \\<langle>A\\<rangle>list_set_rel", "using assms(2)"], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (is_set_to_list A Rs tol)\n\ngoal (1 subgoal):\n 1. (tol, CAST)\n    \\<in> \\<langle>A\\<rangle>Rs \\<rightarrow>\n          \\<langle>A\\<rangle>list_set_rel", "unfolding autoref_tag_defs is_set_to_list_def"], ["proof (prove)\nusing this:\n  is_set_to_sorted_list (\\<lambda>_ _. True) A Rs tol\n\ngoal (1 subgoal):\n 1. (tol, CAST)\n    \\<in> \\<langle>A\\<rangle>Rs \\<rightarrow>\n          \\<langle>A\\<rangle>list_set_rel", "by (auto simp: it_to_sorted_list_def list_set_rel_def in_br_conv elim!: is_set_to_sorted_listE)"], ["", "(* TODO: do we really need stronger versions of all these small lemmata? *)"], ["", "lemma param_foldli:\n      assumes \"(xs, ys) \\<in> \\<langle>Ra\\<rangle> list_rel\"\n      assumes \"(c, d) \\<in> Rs \\<rightarrow> bool_rel\"\n      assumes \"\\<And> x y. (x, y) \\<in> Ra \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs\"\n      assumes \"(a, b) \\<in> Rs\"\n      shows \"(foldli xs c f a, foldli ys d g b) \\<in> Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli xs c f a, foldli ys d g b) \\<in> Rs", "using assms"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> \\<langle>Ra\\<rangle>list_rel\n  (c, d) \\<in> Rs \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Ra; ?x \\<in> set xs; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> (f ?x, g ?y) \\<in> Rs \\<rightarrow> Rs\n  (a, b) \\<in> Rs\n\ngoal (1 subgoal):\n 1. (foldli xs c f a, foldli ys d g b) \\<in> Rs", "proof (induct arbitrary: a b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(c, d) \\<in> Rs \\<rightarrow> bool_rel;\n        \\<And>x y.\n           \\<lbrakk>(x, y) \\<in> Ra; x \\<in> set []; y \\<in> set []\\<rbrakk>\n           \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs;\n        (a, b) \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> (foldli [] c f a, foldli [] d g b) \\<in> Rs\n 2. \\<And>x x' l l' a b.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        \\<And>a b.\n           \\<lbrakk>(c, d) \\<in> Rs \\<rightarrow> bool_rel;\n            \\<And>x y.\n               \\<lbrakk>(x, y) \\<in> Ra; x \\<in> set l;\n                y \\<in> set l'\\<rbrakk>\n               \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs;\n            (a, b) \\<in> Rs\\<rbrakk>\n           \\<Longrightarrow> (foldli l c f a, foldli l' d g b) \\<in> Rs;\n        (c, d) \\<in> Rs \\<rightarrow> bool_rel;\n        \\<And>xa y.\n           \\<lbrakk>(xa, y) \\<in> Ra; xa \\<in> set (x # l);\n            y \\<in> set (x' # l')\\<rbrakk>\n           \\<Longrightarrow> (f xa, g y) \\<in> Rs \\<rightarrow> Rs;\n        (a, b) \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) c f a, foldli (x' # l') d g b)\n                         \\<in> Rs", "case 1"], ["proof (state)\nthis:\n  (c, d) \\<in> Rs \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Ra; ?x \\<in> set []; ?y \\<in> set []\\<rbrakk>\n  \\<Longrightarrow> (f ?x, g ?y) \\<in> Rs \\<rightarrow> Rs\n  (a, b) \\<in> Rs\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(c, d) \\<in> Rs \\<rightarrow> bool_rel;\n        \\<And>x y.\n           \\<lbrakk>(x, y) \\<in> Ra; x \\<in> set []; y \\<in> set []\\<rbrakk>\n           \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs;\n        (a, b) \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> (foldli [] c f a, foldli [] d g b) \\<in> Rs\n 2. \\<And>x x' l l' a b.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        \\<And>a b.\n           \\<lbrakk>(c, d) \\<in> Rs \\<rightarrow> bool_rel;\n            \\<And>x y.\n               \\<lbrakk>(x, y) \\<in> Ra; x \\<in> set l;\n                y \\<in> set l'\\<rbrakk>\n               \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs;\n            (a, b) \\<in> Rs\\<rbrakk>\n           \\<Longrightarrow> (foldli l c f a, foldli l' d g b) \\<in> Rs;\n        (c, d) \\<in> Rs \\<rightarrow> bool_rel;\n        \\<And>xa y.\n           \\<lbrakk>(xa, y) \\<in> Ra; xa \\<in> set (x # l);\n            y \\<in> set (x' # l')\\<rbrakk>\n           \\<Longrightarrow> (f xa, g y) \\<in> Rs \\<rightarrow> Rs;\n        (a, b) \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) c f a, foldli (x' # l') d g b)\n                         \\<in> Rs", "then"], ["proof (chain)\npicking this:\n  (c, d) \\<in> Rs \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Ra; ?x \\<in> set []; ?y \\<in> set []\\<rbrakk>\n  \\<Longrightarrow> (f ?x, g ?y) \\<in> Rs \\<rightarrow> Rs\n  (a, b) \\<in> Rs", "show ?case"], ["proof (prove)\nusing this:\n  (c, d) \\<in> Rs \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Ra; ?x \\<in> set []; ?y \\<in> set []\\<rbrakk>\n  \\<Longrightarrow> (f ?x, g ?y) \\<in> Rs \\<rightarrow> Rs\n  (a, b) \\<in> Rs\n\ngoal (1 subgoal):\n 1. (foldli [] c f a, foldli [] d g b) \\<in> Rs", "by simp"], ["proof (state)\nthis:\n  (foldli [] c f a, foldli [] d g b) \\<in> Rs\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' a b.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        \\<And>a b.\n           \\<lbrakk>(c, d) \\<in> Rs \\<rightarrow> bool_rel;\n            \\<And>x y.\n               \\<lbrakk>(x, y) \\<in> Ra; x \\<in> set l;\n                y \\<in> set l'\\<rbrakk>\n               \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs;\n            (a, b) \\<in> Rs\\<rbrakk>\n           \\<Longrightarrow> (foldli l c f a, foldli l' d g b) \\<in> Rs;\n        (c, d) \\<in> Rs \\<rightarrow> bool_rel;\n        \\<And>xa y.\n           \\<lbrakk>(xa, y) \\<in> Ra; xa \\<in> set (x # l);\n            y \\<in> set (x' # l')\\<rbrakk>\n           \\<Longrightarrow> (f xa, g y) \\<in> Rs \\<rightarrow> Rs;\n        (a, b) \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) c f a, foldli (x' # l') d g b)\n                         \\<in> Rs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' l l' a b.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        \\<And>a b.\n           \\<lbrakk>(c, d) \\<in> Rs \\<rightarrow> bool_rel;\n            \\<And>x y.\n               \\<lbrakk>(x, y) \\<in> Ra; x \\<in> set l;\n                y \\<in> set l'\\<rbrakk>\n               \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs;\n            (a, b) \\<in> Rs\\<rbrakk>\n           \\<Longrightarrow> (foldli l c f a, foldli l' d g b) \\<in> Rs;\n        (c, d) \\<in> Rs \\<rightarrow> bool_rel;\n        \\<And>xa y.\n           \\<lbrakk>(xa, y) \\<in> Ra; xa \\<in> set (x # l);\n            y \\<in> set (x' # l')\\<rbrakk>\n           \\<Longrightarrow> (f xa, g y) \\<in> Rs \\<rightarrow> Rs;\n        (a, b) \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) c f a, foldli (x' # l') d g b)\n                         \\<in> Rs", "case (2 x y xs ys)"], ["proof (state)\nthis:\n  (x, y) \\<in> Ra\n  (xs, ys) \\<in> \\<langle>Ra\\<rangle>list_rel\n  \\<lbrakk>(c, d) \\<in> Rs \\<rightarrow> bool_rel;\n   \\<And>x y.\n      \\<lbrakk>(x, y) \\<in> Ra; x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs;\n   (?a, ?b) \\<in> Rs\\<rbrakk>\n  \\<Longrightarrow> (foldli xs c f ?a, foldli ys d g ?b) \\<in> Rs\n  (c, d) \\<in> Rs \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Ra; ?x \\<in> set (x # xs);\n   ?y \\<in> set (y # ys)\\<rbrakk>\n  \\<Longrightarrow> (f ?x, g ?y) \\<in> Rs \\<rightarrow> Rs\n  (a, b) \\<in> Rs\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' a b.\n       \\<lbrakk>(x, x') \\<in> Ra;\n        (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel;\n        \\<And>a b.\n           \\<lbrakk>(c, d) \\<in> Rs \\<rightarrow> bool_rel;\n            \\<And>x y.\n               \\<lbrakk>(x, y) \\<in> Ra; x \\<in> set l;\n                y \\<in> set l'\\<rbrakk>\n               \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs;\n            (a, b) \\<in> Rs\\<rbrakk>\n           \\<Longrightarrow> (foldli l c f a, foldli l' d g b) \\<in> Rs;\n        (c, d) \\<in> Rs \\<rightarrow> bool_rel;\n        \\<And>xa y.\n           \\<lbrakk>(xa, y) \\<in> Ra; xa \\<in> set (x # l);\n            y \\<in> set (x' # l')\\<rbrakk>\n           \\<Longrightarrow> (f xa, g y) \\<in> Rs \\<rightarrow> Rs;\n        (a, b) \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) c f a, foldli (x' # l') d g b)\n                         \\<in> Rs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "proof (cases \"c a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs\n 2. \\<not> c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "case True"], ["proof (state)\nthis:\n  c a\n\ngoal (2 subgoals):\n 1. c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs\n 2. \\<not> c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "have 10: \"(c a, d b) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c a, d b) \\<in> bool_rel", "using 2"], ["proof (prove)\nusing this:\n  (x, y) \\<in> Ra\n  (xs, ys) \\<in> \\<langle>Ra\\<rangle>list_rel\n  \\<lbrakk>(c, d) \\<in> Rs \\<rightarrow> bool_rel;\n   \\<And>x y.\n      \\<lbrakk>(x, y) \\<in> Ra; x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs;\n   (?a, ?b) \\<in> Rs\\<rbrakk>\n  \\<Longrightarrow> (foldli xs c f ?a, foldli ys d g ?b) \\<in> Rs\n  (c, d) \\<in> Rs \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Ra; ?x \\<in> set (x # xs);\n   ?y \\<in> set (y # ys)\\<rbrakk>\n  \\<Longrightarrow> (f ?x, g ?y) \\<in> Rs \\<rightarrow> Rs\n  (a, b) \\<in> Rs\n\ngoal (1 subgoal):\n 1. (c a, d b) \\<in> bool_rel", "by parametricity"], ["proof (state)\nthis:\n  (c a, d b) \\<in> bool_rel\n\ngoal (2 subgoals):\n 1. c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs\n 2. \\<not> c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "have 20: \"d b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d b", "using 10 True"], ["proof (prove)\nusing this:\n  (c a, d b) \\<in> bool_rel\n  c a\n\ngoal (1 subgoal):\n 1. d b", "by auto"], ["proof (state)\nthis:\n  d b\n\ngoal (2 subgoals):\n 1. c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs\n 2. \\<not> c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "have 30: \"(foldli xs c f (f x a), foldli ys d g (g y b)) \\<in> Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli xs c f (f x a), foldli ys d g (g y b)) \\<in> Rs", "by (auto intro!: 2 2(5)[THEN fun_relD])"], ["proof (state)\nthis:\n  (foldli xs c f (f x a), foldli ys d g (g y b)) \\<in> Rs\n\ngoal (2 subgoals):\n 1. c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs\n 2. \\<not> c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "using True 20 30"], ["proof (prove)\nusing this:\n  c a\n  d b\n  (foldli xs c f (f x a), foldli ys d g (g y b)) \\<in> Rs\n\ngoal (1 subgoal):\n 1. (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "by simp"], ["proof (state)\nthis:\n  (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs\n\ngoal (1 subgoal):\n 1. \\<not> c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "case False"], ["proof (state)\nthis:\n  \\<not> c a\n\ngoal (1 subgoal):\n 1. \\<not> c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "have 10: \"(c a, d b) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c a, d b) \\<in> bool_rel", "using 2"], ["proof (prove)\nusing this:\n  (x, y) \\<in> Ra\n  (xs, ys) \\<in> \\<langle>Ra\\<rangle>list_rel\n  \\<lbrakk>(c, d) \\<in> Rs \\<rightarrow> bool_rel;\n   \\<And>x y.\n      \\<lbrakk>(x, y) \\<in> Ra; x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs;\n   (?a, ?b) \\<in> Rs\\<rbrakk>\n  \\<Longrightarrow> (foldli xs c f ?a, foldli ys d g ?b) \\<in> Rs\n  (c, d) \\<in> Rs \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Ra; ?x \\<in> set (x # xs);\n   ?y \\<in> set (y # ys)\\<rbrakk>\n  \\<Longrightarrow> (f ?x, g ?y) \\<in> Rs \\<rightarrow> Rs\n  (a, b) \\<in> Rs\n\ngoal (1 subgoal):\n 1. (c a, d b) \\<in> bool_rel", "by parametricity"], ["proof (state)\nthis:\n  (c a, d b) \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. \\<not> c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "have 20: \"\\<not> d b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> d b", "using 10 False"], ["proof (prove)\nusing this:\n  (c a, d b) \\<in> bool_rel\n  \\<not> c a\n\ngoal (1 subgoal):\n 1. \\<not> d b", "by auto"], ["proof (state)\nthis:\n  \\<not> d b\n\ngoal (1 subgoal):\n 1. \\<not> c a \\<Longrightarrow>\n    (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs", "unfolding foldli.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if c a then foldli xs c f (f x a) else a,\n     if d b then foldli ys d g (g y b) else b)\n    \\<in> Rs", "using False 20 2"], ["proof (prove)\nusing this:\n  \\<not> c a\n  \\<not> d b\n  (x, y) \\<in> Ra\n  (xs, ys) \\<in> \\<langle>Ra\\<rangle>list_rel\n  \\<lbrakk>(c, d) \\<in> Rs \\<rightarrow> bool_rel;\n   \\<And>x y.\n      \\<lbrakk>(x, y) \\<in> Ra; x \\<in> set xs; y \\<in> set ys\\<rbrakk>\n      \\<Longrightarrow> (f x, g y) \\<in> Rs \\<rightarrow> Rs;\n   (?a, ?b) \\<in> Rs\\<rbrakk>\n  \\<Longrightarrow> (foldli xs c f ?a, foldli ys d g ?b) \\<in> Rs\n  (c, d) \\<in> Rs \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Ra; ?x \\<in> set (x # xs);\n   ?y \\<in> set (y # ys)\\<rbrakk>\n  \\<Longrightarrow> (f ?x, g ?y) \\<in> Rs \\<rightarrow> Rs\n  (a, b) \\<in> Rs\n\ngoal (1 subgoal):\n 1. (if c a then foldli xs c f (f x a) else a,\n     if d b then foldli ys d g (g y b) else b)\n    \\<in> Rs", "by simp"], ["proof (state)\nthis:\n  (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (foldli (x # xs) c f a, foldli (y # ys) d g b) \\<in> Rs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_fold_sorted_set:\n      assumes 1: \"det_fold_set ordR c' f' \\<sigma>' result\"\n      assumes 2: \"is_set_to_sorted_list ordR Rk Rs tsl\"\n      assumes SREF[param]: \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n      assumes [param]:  \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n      assumes [param]: \"\\<And> x y. (x, y) \\<in> Rk \\<Longrightarrow> y \\<in> s' \\<Longrightarrow> (f x,f' y)\\<in>R\\<sigma> \\<rightarrow> R\\<sigma>\"\n      assumes [param]: \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n      shows \"(foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "obtain tsl' where\n        n[param]: \"(tsl s,tsl') \\<in> \\<langle>Rk\\<rangle>list_rel\"\n        and IT: \"RETURN tsl' \\<le> it_to_sorted_list ordR s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tsl s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2 SREF"], ["proof (prove)\nusing this:\n  is_set_to_sorted_list ordR Rk Rs tsl\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tsl s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_set_to_sorted_listE)"], ["proof (state)\nthis:\n  (tsl s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel\n  RETURN tsl' \\<le> it_to_sorted_list ordR s'\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "from IT"], ["proof (chain)\npicking this:\n  RETURN tsl' \\<le> it_to_sorted_list ordR s'", "have suen: \"s' = set tsl'\""], ["proof (prove)\nusing this:\n  RETURN tsl' \\<le> it_to_sorted_list ordR s'\n\ngoal (1 subgoal):\n 1. s' = set tsl'", "unfolding it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  RETURN tsl'\n  \\<le> SPEC\n         (\\<lambda>l. distinct l \\<and> s' = set l \\<and> sorted_wrt ordR l)\n\ngoal (1 subgoal):\n 1. s' = set tsl'", "by simp_all"], ["proof (state)\nthis:\n  s' = set tsl'\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "have \"(foldli (tsl s) c f \\<sigma>, foldli tsl' c' f' \\<sigma>') \\<in> R\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, foldli tsl' c' f' \\<sigma>')\n    \\<in> R\\<sigma>", "using assms(4, 5, 6) n"], ["proof (prove)\nusing this:\n  (c, c') \\<in> R\\<sigma> \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Rk; ?y \\<in> s'\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f' ?y) \\<in> R\\<sigma> \\<rightarrow> R\\<sigma>\n  (\\<sigma>, \\<sigma>') \\<in> R\\<sigma>\n  (tsl s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, foldli tsl' c' f' \\<sigma>')\n    \\<in> R\\<sigma>", "unfolding suen"], ["proof (prove)\nusing this:\n  (c, c') \\<in> R\\<sigma> \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Rk; ?y \\<in> set tsl'\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f' ?y) \\<in> R\\<sigma> \\<rightarrow> R\\<sigma>\n  (\\<sigma>, \\<sigma>') \\<in> R\\<sigma>\n  (tsl s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, foldli tsl' c' f' \\<sigma>')\n    \\<in> R\\<sigma>", "using param_foldli[OF n assms(4)] assms"], ["proof (prove)\nusing this:\n  (c, c') \\<in> R\\<sigma> \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Rk; ?y \\<in> set tsl'\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f' ?y) \\<in> R\\<sigma> \\<rightarrow> R\\<sigma>\n  (\\<sigma>, \\<sigma>') \\<in> R\\<sigma>\n  (tsl s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>(x, y) \\<in> Rk; x \\<in> set (tsl s);\n               y \\<in> set tsl'\\<rbrakk>\n              \\<Longrightarrow> (?f x, ?g y)\n                                \\<in> R\\<sigma> \\<rightarrow> R\\<sigma>;\n   (?a, ?b) \\<in> R\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> (foldli (tsl s) c ?f ?a, foldli tsl' c' ?g ?b)\n                    \\<in> R\\<sigma>\n  det_fold_set ordR c' f' \\<sigma>' result\n  is_set_to_sorted_list ordR Rk Rs tsl\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n  (c, c') \\<in> R\\<sigma> \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Rk; ?y \\<in> s'\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f' ?y) \\<in> R\\<sigma> \\<rightarrow> R\\<sigma>\n  (\\<sigma>, \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, foldli tsl' c' f' \\<sigma>')\n    \\<in> R\\<sigma>", "by simp"], ["proof (state)\nthis:\n  (foldli (tsl s) c f \\<sigma>, foldli tsl' c' f' \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "also"], ["proof (state)\nthis:\n  (foldli (tsl s) c f \\<sigma>, foldli tsl' c' f' \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "have \"foldli tsl' c' f' \\<sigma>' = result s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli tsl' c' f' \\<sigma>' = result s'", "using 1 IT"], ["proof (prove)\nusing this:\n  det_fold_set ordR c' f' \\<sigma>' result\n  RETURN tsl' \\<le> it_to_sorted_list ordR s'\n\ngoal (1 subgoal):\n 1. foldli tsl' c' f' \\<sigma>' = result s'", "unfolding det_fold_set_def it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     distinct l \\<and> sorted_wrt ordR l \\<longrightarrow>\n     foldli l c' f' \\<sigma>' = result (set l)\n  RETURN tsl'\n  \\<le> SPEC\n         (\\<lambda>l. distinct l \\<and> s' = set l \\<and> sorted_wrt ordR l)\n\ngoal (1 subgoal):\n 1. foldli tsl' c' f' \\<sigma>' = result s'", "by simp"], ["proof (state)\nthis:\n  foldli tsl' c' f' \\<sigma>' = result s'\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "finally"], ["proof (chain)\npicking this:\n  (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "."], ["proof (state)\nthis:\n  (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_fold_set:\n      assumes \"det_fold_set (\\<lambda>_ _. True) c' f' \\<sigma>' result\"\n      assumes \"is_set_to_list Rk Rs tsl\"\n      assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n      assumes \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n      assumes \"\\<And> x y. (x, y) \\<in> Rk \\<Longrightarrow> y \\<in> s' \\<Longrightarrow> (f x, f' y)\\<in>R\\<sigma> \\<rightarrow> R\\<sigma>\"\n      assumes \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n      shows \"(foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  det_fold_set (\\<lambda>_ _. True) c' f' \\<sigma>' result\n  is_set_to_list Rk Rs tsl\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n  (c, c') \\<in> R\\<sigma> \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Rk; ?y \\<in> s'\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f' ?y) \\<in> R\\<sigma> \\<rightarrow> R\\<sigma>\n  (\\<sigma>, \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "unfolding is_set_to_list_def"], ["proof (prove)\nusing this:\n  det_fold_set (\\<lambda>_ _. True) c' f' \\<sigma>' result\n  is_set_to_sorted_list (\\<lambda>_ _. True) Rk Rs tsl\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n  (c, c') \\<in> R\\<sigma> \\<rightarrow> bool_rel\n  \\<lbrakk>(?x, ?y) \\<in> Rk; ?y \\<in> s'\\<rbrakk>\n  \\<Longrightarrow> (f ?x, f' ?y) \\<in> R\\<sigma> \\<rightarrow> R\\<sigma>\n  (\\<sigma>, \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "by (rule det_fold_sorted_set)"], ["", "lemma gen_image[autoref_rules_raw]:\n      assumes PRIO_TAG_GEN_ALGO\n      assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 it1)\"\n      assumes INS: \"GEN_OP ins2 Set.insert (Rk'\\<rightarrow>\\<langle>Rk'\\<rangle>Rs2\\<rightarrow>\\<langle>Rk'\\<rangle>Rs2)\"\n      assumes EMPTY: \"GEN_OP empty2 {} (\\<langle>Rk'\\<rangle>Rs2)\"\n      assumes \"\\<And> xi x. (xi, x) \\<in> Rk \\<Longrightarrow> x \\<in> s \\<Longrightarrow> (fi xi, f $ x) \\<in> Rk'\"\n      assumes \"(l, s) \\<in> \\<langle>Rk\\<rangle>Rs1\"\n      shows \"(gen_image (\\<lambda> x. foldli (it1 x)) empty2 ins2 fi l,\n        (OP image ::: (Rk\\<rightarrow>Rk') \\<rightarrow> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk'\\<rangle>Rs2)) $ f $ s) \\<in> (\\<langle>Rk'\\<rangle>Rs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_image (\\<lambda>x. foldli (it1 x)) empty2 ins2 fi l,\n     (OP (`) :::\n      (Rk \\<rightarrow> Rk') \\<rightarrow>\n      \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2) $\n     f $\n     s)\n    \\<in> \\<langle>Rk'\\<rangle>Rs2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (gen_image (\\<lambda>x. foldli (it1 x)) empty2 ins2 fi l,\n     (OP (`) :::\n      (Rk \\<rightarrow> Rk') \\<rightarrow>\n      \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2) $\n     f $\n     s)\n    \\<in> \\<langle>Rk'\\<rangle>Rs2", "note [unfolded autoref_tag_defs, param] = INS EMPTY"], ["proof (state)\nthis:\n  (ins2, insert)\n  \\<in> Rk' \\<rightarrow>\n        \\<langle>Rk'\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2\n  (empty2, {}) \\<in> \\<langle>Rk'\\<rangle>Rs2\n\ngoal (1 subgoal):\n 1. (gen_image (\\<lambda>x. foldli (it1 x)) empty2 ins2 fi l,\n     (OP (`) :::\n      (Rk \\<rightarrow> Rk') \\<rightarrow>\n      \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2) $\n     f $\n     s)\n    \\<in> \\<langle>Rk'\\<rangle>Rs2", "note 1 = det_fold_set[OF foldli_image IT[unfolded autoref_tag_defs]]"], ["proof (state)\nthis:\n  \\<lbrakk>(?s, ?s') \\<in> \\<langle>Rk\\<rangle>Rs1;\n   (?c, \\<lambda>_. True) \\<in> ?R\\<sigma> \\<rightarrow> bool_rel;\n   \\<And>x y.\n      \\<lbrakk>(x, y) \\<in> Rk; y \\<in> ?s'\\<rbrakk>\n      \\<Longrightarrow> (?f x, insert (?f1 y))\n                        \\<in> ?R\\<sigma> \\<rightarrow> ?R\\<sigma>;\n   (?\\<sigma>, {}) \\<in> ?R\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> (foldli (it1 ?s) ?c ?f ?\\<sigma>, ?f1 ` ?s')\n                    \\<in> ?R\\<sigma>\n\ngoal (1 subgoal):\n 1. (gen_image (\\<lambda>x. foldli (it1 x)) empty2 ins2 fi l,\n     (OP (`) :::\n      (Rk \\<rightarrow> Rk') \\<rightarrow>\n      \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2) $\n     f $\n     s)\n    \\<in> \\<langle>Rk'\\<rangle>Rs2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_image (\\<lambda>x. foldli (it1 x)) empty2 ins2 fi l,\n     (OP (`) :::\n      (Rk \\<rightarrow> Rk') \\<rightarrow>\n      \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2) $\n     f $\n     s)\n    \\<in> \\<langle>Rk'\\<rangle>Rs2", "using assms 1"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  SIDE_GEN_ALGO (is_set_to_list Rk Rs1 it1)\n  GEN_OP ins2 insert\n   (Rk' \\<rightarrow>\n    \\<langle>Rk'\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2)\n  GEN_OP empty2 {} (\\<langle>Rk'\\<rangle>Rs2)\n  \\<lbrakk>(?xi, ?x) \\<in> Rk; ?x \\<in> s\\<rbrakk>\n  \\<Longrightarrow> (fi ?xi, f $ ?x) \\<in> Rk'\n  (l, s) \\<in> \\<langle>Rk\\<rangle>Rs1\n  \\<lbrakk>(?s, ?s') \\<in> \\<langle>Rk\\<rangle>Rs1;\n   (?c, \\<lambda>_. True) \\<in> ?R\\<sigma> \\<rightarrow> bool_rel;\n   \\<And>x y.\n      \\<lbrakk>(x, y) \\<in> Rk; y \\<in> ?s'\\<rbrakk>\n      \\<Longrightarrow> (?f x, insert (?f1 y))\n                        \\<in> ?R\\<sigma> \\<rightarrow> ?R\\<sigma>;\n   (?\\<sigma>, {}) \\<in> ?R\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> (foldli (it1 ?s) ?c ?f ?\\<sigma>, ?f1 ` ?s')\n                    \\<in> ?R\\<sigma>\n\ngoal (1 subgoal):\n 1. (gen_image (\\<lambda>x. foldli (it1 x)) empty2 ins2 fi l,\n     (OP (`) :::\n      (Rk \\<rightarrow> Rk') \\<rightarrow>\n      \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2) $\n     f $\n     s)\n    \\<in> \\<langle>Rk'\\<rangle>Rs2", "unfolding gen_image_def autoref_tag_defs"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  is_set_to_list Rk Rs1 it1\n  (ins2, insert)\n  \\<in> Rk' \\<rightarrow>\n        \\<langle>Rk'\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2\n  (empty2, {}) \\<in> \\<langle>Rk'\\<rangle>Rs2\n  \\<lbrakk>(?xi, ?x) \\<in> Rk; ?x \\<in> s\\<rbrakk>\n  \\<Longrightarrow> (fi ?xi, f ?x) \\<in> Rk'\n  (l, s) \\<in> \\<langle>Rk\\<rangle>Rs1\n  \\<lbrakk>(?s, ?s') \\<in> \\<langle>Rk\\<rangle>Rs1;\n   (?c, \\<lambda>_. True) \\<in> ?R\\<sigma> \\<rightarrow> bool_rel;\n   \\<And>x y.\n      \\<lbrakk>(x, y) \\<in> Rk; y \\<in> ?s'\\<rbrakk>\n      \\<Longrightarrow> (?f x, insert (?f1 y))\n                        \\<in> ?R\\<sigma> \\<rightarrow> ?R\\<sigma>;\n   (?\\<sigma>, {}) \\<in> ?R\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> (foldli (it1 ?s) ?c ?f ?\\<sigma>, ?f1 ` ?s')\n                    \\<in> ?R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (it1 l) (\\<lambda>_. True) (\\<lambda>x. ins2 (fi x)) empty2,\n     f ` s)\n    \\<in> \\<langle>Rk'\\<rangle>Rs2", "by parametricity"], ["proof (state)\nthis:\n  (gen_image (\\<lambda>x. foldli (it1 x)) empty2 ins2 fi l,\n   (OP (`) :::\n    (Rk \\<rightarrow> Rk') \\<rightarrow>\n    \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2) $\n   f $\n   s)\n  \\<in> \\<langle>Rk'\\<rangle>Rs2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}