{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Basic/Sequence.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma list_pred_cases:\n    assumes \"list_all P xs\"\n    obtains (nil) \"xs = []\" | (cons) y ys where \"xs = y # ys\" \"P y\" \"list_all P ys\"", "lemma lists_iff_set: \"w \\<in> lists A \\<longleftrightarrow> set w \\<subseteq> A\"", "lemma fold_const: \"fold const xs a = last (a # xs)\"", "lemma take_Suc: \"take (Suc n) xs = (if xs = [] then [] else hd xs # take n (tl xs))\"", "lemma bind_map[simp]: \"map f xs \\<bind> g = xs \\<bind> g \\<circ> f\"", "lemma ball_bind[iff]: \"Ball (set (xs \\<bind> f)) P \\<longleftrightarrow> (\\<forall> x \\<in> set xs. \\<forall> y \\<in> set (f x). P y)\"", "lemma bex_bind[iff]: \"Bex (set (xs \\<bind> f)) P \\<longleftrightarrow> (\\<exists> x \\<in> set xs. \\<exists> y \\<in> set (f x). P y)\"", "lemma list_choice: \"list_all (\\<lambda> x. \\<exists> y. P x y) xs \\<longleftrightarrow> (\\<exists> ys. list_all2 P xs ys)\"", "lemma listset_member: \"ys \\<in> listset XS \\<longleftrightarrow> list_all2 (\\<in>) ys XS\"", "lemma listset_empty[iff]: \"listset XS = {} \\<longleftrightarrow> \\<not> list_all (\\<lambda> A. A \\<noteq> {}) XS\"", "lemma listset_finite[iff]:\n    assumes \"list_all (\\<lambda> A. A \\<noteq> {}) XS\"\n    shows \"finite (listset XS) \\<longleftrightarrow> list_all finite XS\"", "lemma listset_finite'[intro]:\n    assumes \"list_all finite XS\"\n    shows \"finite (listset XS)\"", "lemma listset_card[simp]: \"card (listset XS) = prod_list (map card XS)\"", "lemma stream_pred_cases:\n    assumes \"pred_stream P xs\"\n    obtains (scons) y ys where \"xs = y ## ys\" \"P y\" \"pred_stream P ys\"", "lemma stream_rel_coinduct[case_names stream_rel, coinduct pred: stream_all2]:\n    assumes \"R u v\"\n    assumes \"\\<And> a u b v. R (a ## u) (b ## v) \\<Longrightarrow> P a b \\<and> R u v\"\n    shows \"stream_all2 P u v\"", "lemma stream_rel_coinduct_shift[case_names stream_rel, consumes 1]:\n    assumes \"R u v\"\n    assumes \"\\<And> u v. R u v \\<Longrightarrow>\n      \\<exists> u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2. u = u\\<^sub>1 @- u\\<^sub>2 \\<and> v = v\\<^sub>1 @- v\\<^sub>2 \\<and> u\\<^sub>1 \\<noteq> [] \\<and> v\\<^sub>1 \\<noteq> [] \\<and> list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\"\n    shows \"stream_all2 P u v\"", "lemma stream_pred_coinduct[case_names stream_pred, coinduct pred: pred_stream]:\n    assumes \"R w\"\n    assumes \"\\<And> a w. R (a ## w) \\<Longrightarrow> P a \\<and> R w\"\n    shows \"pred_stream P w\"", "lemma stream_pred_coinduct_shift[case_names stream_pred, consumes 1]:\n    assumes \"R w\"\n    assumes \"\\<And> w. R w \\<Longrightarrow> \\<exists> u v. w = u @- v \\<and> u \\<noteq> [] \\<and> list_all P u \\<and> R v\"\n    shows \"pred_stream P w\"", "lemma stream_pred_flat_coinduct[case_names stream_pred, consumes 1]:\n    assumes \"R ws\"\n    assumes \"\\<And> w ws. R (w ## ws) \\<Longrightarrow> w \\<noteq> [] \\<and> list_all P w \\<and> R ws\"\n    shows \"pred_stream P (flat ws)\"", "lemmas stream_eq_coinduct[case_names stream_eq, coinduct pred: HOL.eq] =\n    stream_rel_coinduct[where ?P = HOL.eq, unfolded stream.rel_eq]", "lemmas stream_eq_coinduct_shift[case_names stream_eq, consumes 1] =\n    stream_rel_coinduct_shift[where ?P = HOL.eq, unfolded stream.rel_eq list.rel_eq]", "lemma stream_pred_shift[iff]: \"pred_stream P (u @- v) \\<longleftrightarrow> list_all P u \\<and> pred_stream P v\"", "lemma stream_rel_shift[iff]:\n    assumes \"length u\\<^sub>1 = length v\\<^sub>1\"\n    shows \"stream_all2 P (u\\<^sub>1 @- u\\<^sub>2) (v\\<^sub>1 @- v\\<^sub>2) \\<longleftrightarrow> list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> stream_all2 P u\\<^sub>2 v\\<^sub>2\"", "lemma sset_subset_stream_pred: \"sset w \\<subseteq> A \\<longleftrightarrow> pred_stream (\\<lambda> a. a \\<in> A) w\"", "lemma eq_scons: \"w = a ## v \\<longleftrightarrow> a = shd w \\<and> v = stl w\"", "lemma scons_eq: \"a ## v = w \\<longleftrightarrow> shd w = a \\<and> stl w = v\"", "lemma eq_shift: \"w = u @- v \\<longleftrightarrow> stake (length u) w = u \\<and> sdrop (length u) w = v\"", "lemma shift_eq: \"u @- v = w \\<longleftrightarrow> u = stake (length u) w \\<and> v = sdrop (length u) w\"", "lemma scons_eq_shift: \"a ## w = u @- v \\<longleftrightarrow> ([] = u \\<and> a ## w = v) \\<or> (\\<exists> u'. a # u' = u \\<and> w = u' @- v)\"", "lemma shift_eq_scons: \"u @- v = a ## w \\<longleftrightarrow> (u = [] \\<and> v = a ## w) \\<or> (\\<exists> u'. u = a # u' \\<and> u' @- v = w)\"", "lemma stream_all2_sset1:\n    assumes \"stream_all2 P xs ys\"\n    shows \"\\<forall> x \\<in> sset xs. \\<exists> y \\<in> sset ys. P x y\"", "lemma stream_all2_sset2:\n    assumes \"stream_all2 P xs ys\"\n    shows \"\\<forall> y \\<in> sset ys. \\<exists> x \\<in> sset xs. P x y\"", "lemma smap_eq_scons[iff]: \"smap f xs = y ## ys \\<longleftrightarrow> f (shd xs) = y \\<and> smap f (stl xs) = ys\"", "lemma scons_eq_smap[iff]: \"y ## ys = smap f xs \\<longleftrightarrow> y = f (shd xs) \\<and> ys = smap f (stl xs)\"", "lemma smap_eq_shift[iff]:\n    \"smap f w = u @- v \\<longleftrightarrow> (\\<exists> w\\<^sub>1 w\\<^sub>2. w = w\\<^sub>1 @- w\\<^sub>2 \\<and> map f w\\<^sub>1 = u \\<and> smap f w\\<^sub>2 = v)\"", "lemma shift_eq_smap[iff]:\n    \"u @- v = smap f w \\<longleftrightarrow> (\\<exists> w\\<^sub>1 w\\<^sub>2. w = w\\<^sub>1 @- w\\<^sub>2 \\<and> u = map f w\\<^sub>1 \\<and> v = smap f w\\<^sub>2)\"", "lemma szip_eq_scons[iff]: \"szip xs ys = z ## zs \\<longleftrightarrow> (shd xs, shd ys) = z \\<and> szip (stl xs) (stl ys) = zs\"", "lemma scons_eq_szip[iff]: \"z ## zs = szip xs ys \\<longleftrightarrow> z = (shd xs, shd ys) \\<and> zs = szip (stl xs) (stl ys)\"", "lemma siterate_eq_scons[iff]: \"siterate f s = a ## w \\<longleftrightarrow> s = a \\<and> siterate f (f s) = w\"", "lemma scons_eq_siterate[iff]: \"a ## w = siterate f s \\<longleftrightarrow> a = s \\<and> w = siterate f (f s)\"", "lemma snth_0: \"(a ## w) !! 0 = a\"", "lemma eqI_snth:\n    assumes \"\\<And> i. u !! i = v !! i\"\n    shows \"u = v\"", "lemma stream_pred_snth: \"pred_stream P w \\<longleftrightarrow> (\\<forall> i. P (w !! i))\"", "lemma stream_rel_snth: \"stream_all2 P u v \\<longleftrightarrow> (\\<forall> i. P (u !! i) (v !! i))\"", "lemma stream_rel_pred_szip: \"stream_all2 P u v \\<longleftrightarrow> pred_stream (case_prod P) (szip u v)\"", "lemma sconst_eq[iff]: \"sconst x = sconst y \\<longleftrightarrow> x = y\"", "lemma stream_pred__sconst[iff]: \"pred_stream P (sconst x) \\<longleftrightarrow> P x\"", "lemma stream_rel_sconst[iff]: \"stream_all2 P (sconst x) (sconst y) \\<longleftrightarrow> P x y\"", "lemma set_sset_stake[intro!, simp]: \"set (stake n xs) \\<subseteq> sset xs\"", "lemma sset_sdrop[intro!, simp]: \"sset (sdrop n xs) \\<subseteq> sset xs\"", "lemma set_stake_snth: \"x \\<in> set (stake n xs) \\<longleftrightarrow> (\\<exists> i < n. xs !! i = x)\"", "lemma szip_transfer[transfer_rule]:\n    includes lifting_syntax\n    shows \"(stream_all2 A ===> stream_all2 B ===> stream_all2 (rel_prod A B)) szip szip\"", "lemma siterate_transfer[transfer_rule]:\n    includes lifting_syntax\n    shows \"((A ===> A) ===> A ===> stream_all2 A) siterate siterate\"", "lemma split_stream_first:\n    assumes \"A \\<inter> sset xs \\<noteq> {}\"\n    obtains ys a zs\n    where \"xs = ys @- a ## zs\" \"A \\<inter> set ys = {}\" \"a \\<in> A\"", "lemma split_stream_first':\n    assumes \"x \\<in> sset xs\"\n    obtains ys zs\n    where \"xs = ys @- x ## zs\" \"x \\<notin> set ys\"", "lemma streams_UNIV[iff]: \"streams A = UNIV \\<longleftrightarrow> A = UNIV\"", "lemma streams_int[simp]: \"streams (A \\<inter> B) = streams A \\<inter> streams B\"", "lemma streams_Int[simp]: \"streams (\\<Inter> S) = \\<Inter> (streams ` S)\"", "lemma pred_list_listsp[pred_set_conv]: \"list_all = listsp\"", "lemma pred_stream_streamsp[pred_set_conv]: \"pred_stream = streamsp\"", "lemma scan_append[simp]: \"scan f (xs @ ys) a = scan f xs a @ scan f ys (fold f xs a)\"", "lemma scan_eq_nil[iff]: \"scan f xs a = [] \\<longleftrightarrow> xs = []\"", "lemma scan_eq_cons[iff]:\n    \"scan f xs a = b # w \\<longleftrightarrow> (\\<exists> y ys. xs = y # ys \\<and> f y a = b \\<and> scan f ys (f y a) = w)\"", "lemma scan_eq_append[iff]:\n    \"scan f xs a = u @ v \\<longleftrightarrow> (\\<exists> ys zs. xs = ys @ zs \\<and> scan f ys a = u \\<and> scan f zs (fold f ys a) = v)\"", "lemma scan_length[simp]: \"length (scan f xs a) = length xs\"", "lemma scan_last: \"last (a # scan f xs a) = fold f xs a\"", "lemma scan_butlast[simp]: \"scan f (butlast xs) a = butlast (scan f xs a)\"", "lemma scan_const[simp]: \"scan const xs a = xs\"", "lemma scan_nth[simp]:\n    assumes \"i < length (scan f xs a)\"\n    shows \"scan f xs a ! i = fold f (take (Suc i) xs) a\"", "lemma scan_map[simp]: \"scan f (map g xs) a = scan (f \\<circ> g) xs a\"", "lemma scan_take[simp]: \"take k (scan f xs a) = scan f (take k xs) a\"", "lemma scan_drop[simp]: \"drop k (scan f xs a) = scan f (drop k xs) (fold f (take k xs) a)\"", "lemma sscan_scons[simp]: \"sscan f (x ## xs) a = f x a ## sscan f xs (f x a)\"", "lemma sscan_shift[simp]: \"sscan f (xs @- ys) a = scan f xs a @- sscan f ys (fold f xs a)\"", "lemma sscan_eq_scons[iff]:\n    \"sscan f xs a = b ## w \\<longleftrightarrow> f (shd xs) a = b \\<and> sscan f (stl xs) (f (shd xs) a) = w\"", "lemma scons_eq_sscan[iff]:\n    \"b ## w = sscan f xs a \\<longleftrightarrow> b = f (shd xs) a \\<and> w = sscan f (stl xs) (f (shd xs) a)\"", "lemma sscan_const[simp]: \"sscan const xs a = xs\"", "lemma sscan_snth[simp]: \"sscan f xs a !! i = fold f (stake (Suc i) xs) a\"", "lemma sscan_scons_snth[simp]: \"(a ## sscan f xs a) !! i = fold f (stake i xs) a\"", "lemma sscan_smap[simp]: \"sscan f (smap g xs) a = sscan (f \\<circ> g) xs a\"", "lemma sscan_stake[simp]: \"stake k (sscan f xs a) = scan f (stake k xs) a\"", "lemma sscan_sdrop[simp]: \"sdrop k (sscan f xs a) = sscan f (sdrop k xs) (fold f (stake k xs) a)\"", "lemma stranspose_eq_scons[iff]: \"stranspose ws = a ## w \\<longleftrightarrow> map shd ws = a \\<and> stranspose (map stl ws) = w\"", "lemma scons_eq_stranspose[iff]: \"a ## w = stranspose ws \\<longleftrightarrow> a = map shd ws \\<and> w = stranspose (map stl ws)\"", "lemma stranspose_nil[simp]: \"stranspose [] = sconst []\"", "lemma stranspose_cons[simp]: \"stranspose (w # ws) = smap2 Cons w (stranspose ws)\"", "lemma snth_stranspose[simp]: \"stranspose ws !! k = map (\\<lambda> w. w !! k) ws\"", "lemma stranspose_nth[simp]:\n    assumes \"k < length ws\"\n    shows \"smap (\\<lambda> xs. xs ! k) (stranspose ws) = ws ! k\"", "lemma sdistinct_scons_elim[elim!]:\n    assumes \"sdistinct (x ## xs)\"\n    obtains \"x \\<notin> sset xs\" \"sdistinct xs\"", "lemma sdistinct_coinduct[case_names sdistinct, coinduct pred: sdistinct]:\n    assumes \"P xs\"\n    assumes \"\\<And> x xs. P (x ## xs) \\<Longrightarrow> x \\<notin> sset xs \\<and> P xs\"\n    shows \"sdistinct xs\"", "lemma sdistinct_shift[intro!]:\n    assumes \"distinct xs\" \"sdistinct ys\" \"set xs \\<inter> sset ys = {}\"\n    shows \"sdistinct (xs @- ys)\"", "lemma sdistinct_shift_elim[elim!]:\n    assumes \"sdistinct (xs @- ys)\"\n    obtains \"distinct xs\" \"sdistinct ys\" \"set xs \\<inter> sset ys = {}\"", "lemma sdistinct_infinite_sset:\n    assumes \"sdistinct w\"\n    shows \"infinite (sset w)\"", "lemma not_sdistinct_decomp:\n    assumes \"\\<not> sdistinct w\"\n    obtains u v a w'\n    where \"w = u @- a ## v @- a ## w'\"", "lemma sdescending_coinduct[case_names sdescending, coinduct pred: sdescending]:\n    assumes \"P w\"\n    assumes \"\\<And> a b w. P (a ## b ## w) \\<Longrightarrow> a \\<ge> b \\<and> P (b ## w)\"\n    shows \"sdescending w\"", "lemma sdescending_scons:\n    assumes \"sdescending (a ## w)\"\n    shows \"sdescending w\"", "lemma sdescending_sappend:\n    assumes \"sdescending (u @- v)\"\n    obtains \"sdescending v\"", "lemma sdescending_sdrop:\n    assumes \"sdescending w\"\n    shows \"sdescending (sdrop k w)\"", "lemma sdescending_sset_scons:\n    assumes \"sdescending (a ## w)\"\n    assumes \"b \\<in> sset w\"\n    shows \"a \\<ge> b\"", "lemma sdescending_sset_sappend:\n    assumes \"sdescending (u @- v)\"\n    assumes \"a \\<in> set u\" \"b \\<in> sset v\"\n    shows \"a \\<ge> b\"", "lemma sdescending_snth_antimono:\n    assumes \"sdescending w\"\n    shows \"antimono (snth w)\"", "lemma sdescending_stuck:\n    fixes w :: \"'a :: wellorder stream\"\n    assumes \"sdescending w\"\n    obtains u a\n    where \"w = u @- sconst a\""], "translations": [["", "lemma list_pred_cases:\n    assumes \"list_all P xs\"\n    obtains (nil) \"xs = []\" | (cons) y ys where \"xs = y # ys\" \"P y\" \"list_all P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = [] \\<Longrightarrow> thesis;\n     \\<And>y ys.\n        \\<lbrakk>xs = y # ys; P y; list_all P ys\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  list_all P xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = [] \\<Longrightarrow> thesis;\n     \\<And>y ys.\n        \\<lbrakk>xs = y # ys; P y; list_all P ys\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases xs) (auto)"], ["", "lemma lists_iff_set: \"w \\<in> lists A \\<longleftrightarrow> set w \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> lists A) = (set w \\<subseteq> A)", "by auto"], ["", "lemma fold_const: \"fold const xs a = last (a # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>x _. x) xs a = last (a # xs)", "by (induct xs arbitrary: a) (auto simp: last.simps)"], ["", "lemma take_Suc: \"take (Suc n) xs = (if xs = [] then [] else hd xs # take n (tl xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc n) xs = (if xs = [] then [] else hd xs # take n (tl xs))", "by (simp add: take_Suc)"], ["", "lemma bind_map[simp]: \"map f xs \\<bind> g = xs \\<bind> g \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f xs \\<bind> g = xs \\<bind> g \\<circ> f", "unfolding List.bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map g (map f xs)) = concat (map (g \\<circ> f) xs)", "by simp"], ["", "lemma ball_bind[iff]: \"Ball (set (xs \\<bind> f)) P \\<longleftrightarrow> (\\<forall> x \\<in> set xs. \\<forall> y \\<in> set (f x). P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (xs \\<bind> f)) P =\n    (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set (f x). P y)", "unfolding set_list_bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (\\<Union>x\\<in>set xs. set (f x)) P =\n    (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set (f x). P y)", "by simp"], ["", "lemma bex_bind[iff]: \"Bex (set (xs \\<bind> f)) P \\<longleftrightarrow> (\\<exists> x \\<in> set xs. \\<exists> y \\<in> set (f x). P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex (set (xs \\<bind> f)) P =\n    (\\<exists>x\\<in>set xs. \\<exists>y\\<in>set (f x). P y)", "unfolding set_list_bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex (\\<Union>x\\<in>set xs. set (f x)) P =\n    (\\<exists>x\\<in>set xs. \\<exists>y\\<in>set (f x). P y)", "by simp"], ["", "lemma list_choice: \"list_all (\\<lambda> x. \\<exists> y. P x y) xs \\<longleftrightarrow> (\\<exists> ys. list_all2 P xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. \\<exists>y. P x y) xs =\n    (\\<exists>ys. list_all2 P xs ys)", "by (induct xs) (auto simp: list_all2_Cons1)"], ["", "lemma listset_member: \"ys \\<in> listset XS \\<longleftrightarrow> list_all2 (\\<in>) ys XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys \\<in> listset XS) = list_all2 (\\<in>) ys XS", "by (induct XS arbitrary: ys) (auto simp: set_Cons_def list_all2_Cons2)"], ["", "lemma listset_empty[iff]: \"listset XS = {} \\<longleftrightarrow> \\<not> list_all (\\<lambda> A. A \\<noteq> {}) XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (listset XS = {}) = (\\<not> list_all (\\<lambda>A. A \\<noteq> {}) XS)", "by (induct XS) (auto simp: set_Cons_def)"], ["", "lemma listset_finite[iff]:\n    assumes \"list_all (\\<lambda> A. A \\<noteq> {}) XS\"\n    shows \"finite (listset XS) \\<longleftrightarrow> list_all finite XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (listset XS) = list_all finite XS", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>A. A \\<noteq> {}) XS\n\ngoal (1 subgoal):\n 1. finite (listset XS) = list_all finite XS", "proof (induct XS)"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all (\\<lambda>A. A \\<noteq> {}) [] \\<Longrightarrow>\n    finite (listset []) = list_all finite []\n 2. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "case Nil"], ["proof (state)\nthis:\n  list_all (\\<lambda>A. A \\<noteq> {}) []\n\ngoal (2 subgoals):\n 1. list_all (\\<lambda>A. A \\<noteq> {}) [] \\<Longrightarrow>\n    finite (listset []) = list_all finite []\n 2. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (listset []) = list_all finite []", "by simp"], ["proof (state)\nthis:\n  finite (listset []) = list_all finite []\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "case (Cons A XS)"], ["proof (state)\nthis:\n  list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n  finite (listset XS) = list_all finite XS\n  list_all (\\<lambda>A. A \\<noteq> {}) (A # XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "note [simp] = finite_image_iff finite_cartesian_product_iff"], ["proof (state)\nthis:\n  inj_on ?f ?A \\<Longrightarrow> finite (?f ` ?A) = finite ?A\n  finite (?A \\<times> ?B) =\n  (?A = {} \\<or> ?B = {} \\<or> finite ?A \\<and> finite ?B)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "have \"listset (A # XS) = case_prod Cons ` (A \\<times> listset XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. listset (A # XS) = (\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)", "by (auto simp: set_Cons_def)"], ["proof (state)\nthis:\n  listset (A # XS) = (\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "also"], ["proof (state)\nthis:\n  listset (A # XS) = (\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "have \"finite \\<dots> \\<longleftrightarrow> finite (A \\<times> listset XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)) =\n    finite (A \\<times> listset XS)", "by (simp add: inj_on_def)"], ["proof (state)\nthis:\n  finite ((\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)) =\n  finite (A \\<times> listset XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "also"], ["proof (state)\nthis:\n  finite ((\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)) =\n  finite (A \\<times> listset XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "have \"\\<dots> \\<longleftrightarrow> finite A \\<and> finite (listset XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (A \\<times> listset XS) = (finite A \\<and> finite (listset XS))", "using Cons(2)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>A. A \\<noteq> {}) (A # XS)\n\ngoal (1 subgoal):\n 1. finite (A \\<times> listset XS) = (finite A \\<and> finite (listset XS))", "by simp"], ["proof (state)\nthis:\n  finite (A \\<times> listset XS) = (finite A \\<and> finite (listset XS))\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "also"], ["proof (state)\nthis:\n  finite (A \\<times> listset XS) = (finite A \\<and> finite (listset XS))\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "have \"finite (listset XS) \\<longleftrightarrow> list_all finite XS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (listset XS) = list_all finite XS", "using Cons"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n  finite (listset XS) = list_all finite XS\n  list_all (\\<lambda>A. A \\<noteq> {}) (A # XS)\n\ngoal (1 subgoal):\n 1. finite (listset XS) = list_all finite XS", "by simp"], ["proof (state)\nthis:\n  finite (listset XS) = list_all finite XS\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "also"], ["proof (state)\nthis:\n  finite (listset XS) = list_all finite XS\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "have \"finite A \\<and> \\<dots> \\<longleftrightarrow> list_all finite (A # XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite A \\<and> list_all finite XS) = list_all finite (A # XS)", "by simp"], ["proof (state)\nthis:\n  (finite A \\<and> list_all finite XS) = list_all finite (A # XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       \\<lbrakk>list_all (\\<lambda>A. A \\<noteq> {}) XS \\<Longrightarrow>\n                finite (listset XS) = list_all finite XS;\n        list_all (\\<lambda>A. A \\<noteq> {}) (a # XS)\\<rbrakk>\n       \\<Longrightarrow> finite (listset (a # XS)) =\n                         list_all finite (a # XS)", "finally"], ["proof (chain)\npicking this:\n  finite (listset (A # XS)) = list_all finite (A # XS)", "show ?case"], ["proof (prove)\nusing this:\n  finite (listset (A # XS)) = list_all finite (A # XS)\n\ngoal (1 subgoal):\n 1. finite (listset (A # XS)) = list_all finite (A # XS)", "by this"], ["proof (state)\nthis:\n  finite (listset (A # XS)) = list_all finite (A # XS)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma listset_finite'[intro]:\n    assumes \"list_all finite XS\"\n    shows \"finite (listset XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (listset XS)", "using infinite_imp_nonempty assms"], ["proof (prove)\nusing this:\n  infinite ?S \\<Longrightarrow> ?S \\<noteq> {}\n  list_all finite XS\n\ngoal (1 subgoal):\n 1. finite (listset XS)", "by blast"], ["", "lemma listset_card[simp]: \"card (listset XS) = prod_list (map card XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (listset XS) = prod_list (map card XS)", "proof (induct XS)"], ["proof (state)\ngoal (2 subgoals):\n 1. card (listset []) = prod_list (map card [])\n 2. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. card (listset []) = prod_list (map card [])\n 2. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (listset []) = prod_list (map card [])", "by simp"], ["proof (state)\nthis:\n  card (listset []) = prod_list (map card [])\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "case (Cons A XS)"], ["proof (state)\nthis:\n  card (listset XS) = prod_list (map card XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "have 1: \"inj (case_prod Cons)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>(x, y). x # y)", "unfolding inj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (case x of (x, xa) \\<Rightarrow> x # xa) =\n       (case y of (x, xa) \\<Rightarrow> x # xa) \\<longrightarrow>\n       x = y", "by simp"], ["proof (state)\nthis:\n  inj (\\<lambda>(x, y). x # y)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "have \"listset (A # XS) = case_prod Cons ` (A \\<times> listset XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. listset (A # XS) = (\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)", "by (auto simp: set_Cons_def)"], ["proof (state)\nthis:\n  listset (A # XS) = (\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "also"], ["proof (state)\nthis:\n  listset (A # XS) = (\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "have \"card \\<dots> = card (A \\<times> listset XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)) =\n    card (A \\<times> listset XS)", "using card_image 1"], ["proof (prove)\nusing this:\n  inj_on ?f ?A \\<Longrightarrow> card (?f ` ?A) = card ?A\n  inj (\\<lambda>(x, y). x # y)\n\ngoal (1 subgoal):\n 1. card ((\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)) =\n    card (A \\<times> listset XS)", "by auto"], ["proof (state)\nthis:\n  card ((\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)) =\n  card (A \\<times> listset XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "also"], ["proof (state)\nthis:\n  card ((\\<lambda>(x, y). x # y) ` (A \\<times> listset XS)) =\n  card (A \\<times> listset XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "have \"\\<dots> = card A * card (listset XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (A \\<times> listset XS) = card A * card (listset XS)", "using card_cartesian_product"], ["proof (prove)\nusing this:\n  card (?A \\<times> ?B) = card ?A * card ?B\n\ngoal (1 subgoal):\n 1. card (A \\<times> listset XS) = card A * card (listset XS)", "by this"], ["proof (state)\nthis:\n  card (A \\<times> listset XS) = card A * card (listset XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "also"], ["proof (state)\nthis:\n  card (A \\<times> listset XS) = card A * card (listset XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "have \"card (listset XS) = prod_list (map card XS)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (listset XS) = prod_list (map card XS)", "using Cons"], ["proof (prove)\nusing this:\n  card (listset XS) = prod_list (map card XS)\n\ngoal (1 subgoal):\n 1. card (listset XS) = prod_list (map card XS)", "by this"], ["proof (state)\nthis:\n  card (listset XS) = prod_list (map card XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "also"], ["proof (state)\nthis:\n  card (listset XS) = prod_list (map card XS)\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "have \"card A * \\<dots> = prod_list (map card (A # XS))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A * prod_list (map card XS) = prod_list (map card (A # XS))", "by simp"], ["proof (state)\nthis:\n  card A * prod_list (map card XS) = prod_list (map card (A # XS))\n\ngoal (1 subgoal):\n 1. \\<And>a XS.\n       card (listset XS) = prod_list (map card XS) \\<Longrightarrow>\n       card (listset (a # XS)) = prod_list (map card (a # XS))", "finally"], ["proof (chain)\npicking this:\n  card (listset (A # XS)) = prod_list (map card (A # XS))", "show ?case"], ["proof (prove)\nusing this:\n  card (listset (A # XS)) = prod_list (map card (A # XS))\n\ngoal (1 subgoal):\n 1. card (listset (A # XS)) = prod_list (map card (A # XS))", "by this"], ["proof (state)\nthis:\n  card (listset (A # XS)) = prod_list (map card (A # XS))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Stream Basics\\<close>"], ["", "declare stream.map_id[simp]"], ["", "declare stream.set_map[simp]"], ["", "declare stream.set_sel(1)[intro!, simp]"], ["", "declare stream.pred_True[simp]"], ["", "declare stream.pred_map[iff]"], ["", "declare stream.rel_map[iff]"], ["", "declare shift_simps[simp del]"], ["", "declare stake_sdrop[simp]"], ["", "declare stake_siterate[simp del]"], ["", "declare sdrop_snth[simp]"], ["", "lemma stream_pred_cases:\n    assumes \"pred_stream P xs\"\n    obtains (scons) y ys where \"xs = y ## ys\" \"P y\" \"pred_stream P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        \\<lbrakk>xs = y ## ys; P y; pred_stream P ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  pred_stream P xs\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        \\<lbrakk>xs = y ## ys; P y; pred_stream P ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs) (auto)"], ["", "lemma stream_rel_coinduct[case_names stream_rel, coinduct pred: stream_all2]:\n    assumes \"R u v\"\n    assumes \"\\<And> a u b v. R (a ## u) (b ## v) \\<Longrightarrow> P a b \\<and> R u v\"\n    shows \"stream_all2 P u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P u v", "using assms"], ["proof (prove)\nusing this:\n  R u v\n  R (?a ## ?u) (?b ## ?v) \\<Longrightarrow> P ?a ?b \\<and> R ?u ?v\n\ngoal (1 subgoal):\n 1. stream_all2 P u v", "by (coinduct) (metis stream.collapse)"], ["", "lemma stream_rel_coinduct_shift[case_names stream_rel, consumes 1]:\n    assumes \"R u v\"\n    assumes \"\\<And> u v. R u v \\<Longrightarrow>\n      \\<exists> u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2. u = u\\<^sub>1 @- u\\<^sub>2 \\<and> v = v\\<^sub>1 @- v\\<^sub>2 \\<and> u\\<^sub>1 \\<noteq> [] \\<and> v\\<^sub>1 \\<noteq> [] \\<and> list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\"\n    shows \"stream_all2 P u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P u v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. stream_all2 P u v", "have \"\\<exists> u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2. u = u\\<^sub>1 @- u\\<^sub>2 \\<and> v = v\\<^sub>1 @- v\\<^sub>2 \\<and> list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n       u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n       v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n       list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2", "using assms(1)"], ["proof (prove)\nusing this:\n  R u v\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n       u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n       v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n       list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2", "by force"], ["proof (state)\nthis:\n  \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n     u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n     v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n     list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\n\ngoal (1 subgoal):\n 1. stream_all2 P u v", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n     u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n     v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n     list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n     u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n     v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n     list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\n\ngoal (1 subgoal):\n 1. stream_all2 P u v", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n     u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n     v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n     list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\n  R ?u ?v \\<Longrightarrow>\n  \\<exists>u\\<^sub>1 u\\<^sub>2 v\\<^sub>1 v\\<^sub>2.\n     ?u = u\\<^sub>1 @- u\\<^sub>2 \\<and>\n     ?v = v\\<^sub>1 @- v\\<^sub>2 \\<and>\n     u\\<^sub>1 \\<noteq> [] \\<and>\n     v\\<^sub>1 \\<noteq> [] \\<and>\n     list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> R u\\<^sub>2 v\\<^sub>2\n\ngoal (1 subgoal):\n 1. stream_all2 P u v", "by (coinduct) (force elim: list.rel_cases)"], ["proof (state)\nthis:\n  stream_all2 P u v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stream_pred_coinduct[case_names stream_pred, coinduct pred: pred_stream]:\n    assumes \"R w\"\n    assumes \"\\<And> a w. R (a ## w) \\<Longrightarrow> P a \\<and> R w\"\n    shows \"pred_stream P w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P w", "using assms"], ["proof (prove)\nusing this:\n  R w\n  R (?a ## ?w) \\<Longrightarrow> P ?a \\<and> R ?w\n\ngoal (1 subgoal):\n 1. pred_stream P w", "unfolding stream.pred_rel eq_onp_def"], ["proof (prove)\nusing this:\n  R w\n  R (?a ## ?w) \\<Longrightarrow> P ?a \\<and> R ?w\n\ngoal (1 subgoal):\n 1. stream_all2 (\\<lambda>x y. P x \\<and> x = y) w w", "by (coinduction arbitrary: w) (auto)"], ["", "lemma stream_pred_coinduct_shift[case_names stream_pred, consumes 1]:\n    assumes \"R w\"\n    assumes \"\\<And> w. R w \\<Longrightarrow> \\<exists> u v. w = u @- v \\<and> u \\<noteq> [] \\<and> list_all P u \\<and> R v\"\n    shows \"pred_stream P w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pred_stream P w", "have \"\\<exists> u v. w = u @- v \\<and> list_all P u \\<and> R v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v", "using assms(1)"], ["proof (prove)\nusing this:\n  R w\n\ngoal (1 subgoal):\n 1. \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v", "by (metis list_all_simps(2) shift.simps(1))"], ["proof (state)\nthis:\n  \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v\n\ngoal (1 subgoal):\n 1. pred_stream P w", "then"], ["proof (chain)\npicking this:\n  \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v\n\ngoal (1 subgoal):\n 1. pred_stream P w", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<exists>u v. w = u @- v \\<and> list_all P u \\<and> R v\n  R ?w \\<Longrightarrow>\n  \\<exists>u v.\n     ?w = u @- v \\<and> u \\<noteq> [] \\<and> list_all P u \\<and> R v\n\ngoal (1 subgoal):\n 1. pred_stream P w", "by (coinduct) (force elim: list_pred_cases)"], ["proof (state)\nthis:\n  pred_stream P w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stream_pred_flat_coinduct[case_names stream_pred, consumes 1]:\n    assumes \"R ws\"\n    assumes \"\\<And> w ws. R (w ## ws) \\<Longrightarrow> w \\<noteq> [] \\<and> list_all P w \\<and> R ws\"\n    shows \"pred_stream P (flat ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P (flat ws)", "using assms"], ["proof (prove)\nusing this:\n  R ws\n  R (?w ## ?ws) \\<Longrightarrow>\n  ?w \\<noteq> [] \\<and> list_all P ?w \\<and> R ?ws\n\ngoal (1 subgoal):\n 1. pred_stream P (flat ws)", "by (coinduction arbitrary: ws rule: stream_pred_coinduct_shift) (metis stream.exhaust flat_Stream)"], ["", "lemmas stream_eq_coinduct[case_names stream_eq, coinduct pred: HOL.eq] =\n    stream_rel_coinduct[where ?P = HOL.eq, unfolded stream.rel_eq]"], ["", "lemmas stream_eq_coinduct_shift[case_names stream_eq, consumes 1] =\n    stream_rel_coinduct_shift[where ?P = HOL.eq, unfolded stream.rel_eq list.rel_eq]"], ["", "lemma stream_pred_shift[iff]: \"pred_stream P (u @- v) \\<longleftrightarrow> list_all P u \\<and> pred_stream P v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P (u @- v) = (list_all P u \\<and> pred_stream P v)", "by (induct u) (auto)"], ["", "lemma stream_rel_shift[iff]:\n    assumes \"length u\\<^sub>1 = length v\\<^sub>1\"\n    shows \"stream_all2 P (u\\<^sub>1 @- u\\<^sub>2) (v\\<^sub>1 @- v\\<^sub>2) \\<longleftrightarrow> list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and> stream_all2 P u\\<^sub>2 v\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P (u\\<^sub>1 @- u\\<^sub>2) (v\\<^sub>1 @- v\\<^sub>2) =\n    (list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and>\n     stream_all2 P u\\<^sub>2 v\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  length u\\<^sub>1 = length v\\<^sub>1\n\ngoal (1 subgoal):\n 1. stream_all2 P (u\\<^sub>1 @- u\\<^sub>2) (v\\<^sub>1 @- v\\<^sub>2) =\n    (list_all2 P u\\<^sub>1 v\\<^sub>1 \\<and>\n     stream_all2 P u\\<^sub>2 v\\<^sub>2)", "by (induct rule: list_induct2) (auto)"], ["", "lemma sset_subset_stream_pred: \"sset w \\<subseteq> A \\<longleftrightarrow> pred_stream (\\<lambda> a. a \\<in> A) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sset w \\<subseteq> A) = pred_stream (\\<lambda>a. a \\<in> A) w", "unfolding stream.pred_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sset w \\<subseteq> A) = (\\<forall>a\\<in>sset w. a \\<in> A)", "by auto"], ["", "lemma eq_scons: \"w = a ## v \\<longleftrightarrow> a = shd w \\<and> v = stl w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w = a ## v) = (a = shd w \\<and> v = stl w)", "by auto"], ["", "lemma scons_eq: \"a ## v = w \\<longleftrightarrow> shd w = a \\<and> stl w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ## v = w) = (shd w = a \\<and> stl w = v)", "by auto"], ["", "lemma eq_shift: \"w = u @- v \\<longleftrightarrow> stake (length u) w = u \\<and> sdrop (length u) w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w = u @- v) = (stake (length u) w = u \\<and> sdrop (length u) w = v)", "by (induct u arbitrary: w) (force+)"], ["", "lemma shift_eq: \"u @- v = w \\<longleftrightarrow> u = stake (length u) w \\<and> v = sdrop (length u) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u @- v = w) = (u = stake (length u) w \\<and> v = sdrop (length u) w)", "by (induct u arbitrary: w) (force+)"], ["", "lemma scons_eq_shift: \"a ## w = u @- v \\<longleftrightarrow> ([] = u \\<and> a ## w = v) \\<or> (\\<exists> u'. a # u' = u \\<and> w = u' @- v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ## w = u @- v) =\n    ([] = u \\<and> a ## w = v \\<or>\n     (\\<exists>u'. a # u' = u \\<and> w = u' @- v))", "by (cases u) (auto)"], ["", "lemma shift_eq_scons: \"u @- v = a ## w \\<longleftrightarrow> (u = [] \\<and> v = a ## w) \\<or> (\\<exists> u'. u = a # u' \\<and> u' @- v = w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u @- v = a ## w) =\n    (u = [] \\<and> v = a ## w \\<or>\n     (\\<exists>u'. u = a # u' \\<and> u' @- v = w))", "by (cases u) (auto)"], ["", "lemma stream_all2_sset1:\n    assumes \"stream_all2 P xs ys\"\n    shows \"\\<forall> x \\<in> sset xs. \\<exists> y \\<in> sset ys. P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y", "have \"pred_stream (\\<lambda> x. \\<exists> y \\<in> S. P x y) xs\" if \"sset ys \\<subseteq> S\" for S"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>x. \\<exists>y\\<in>S. P x y) xs", "using assms that"], ["proof (prove)\nusing this:\n  stream_all2 P xs ys\n  sset ys \\<subseteq> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>x. \\<exists>y\\<in>S. P x y) xs", "by (coinduction arbitrary: xs ys) (force elim: stream.rel_cases)"], ["proof (state)\nthis:\n  sset ys \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>x. \\<exists>y\\<in>?S. P x y) xs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y", "then"], ["proof (chain)\npicking this:\n  sset ys \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>x. \\<exists>y\\<in>?S. P x y) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sset ys \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>x. \\<exists>y\\<in>?S. P x y) xs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  sset ys \\<subseteq> ?S \\<Longrightarrow>\n  \\<forall>x\\<in>sset xs. Bex ?S (P x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>sset xs. \\<exists>y\\<in>sset ys. P x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stream_all2_sset2:\n    assumes \"stream_all2 P xs ys\"\n    shows \"\\<forall> y \\<in> sset ys. \\<exists> x \\<in> sset xs. P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y", "have \"pred_stream (\\<lambda> y. \\<exists> x \\<in> S. P x y) ys\" if \"sset xs \\<subseteq> S\" for S"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>y. \\<exists>x\\<in>S. P x y) ys", "using assms that"], ["proof (prove)\nusing this:\n  stream_all2 P xs ys\n  sset xs \\<subseteq> S\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>y. \\<exists>x\\<in>S. P x y) ys", "by (coinduction arbitrary: xs ys) (force elim: stream.rel_cases)"], ["proof (state)\nthis:\n  sset xs \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>y. \\<exists>x\\<in>?S. P x y) ys\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y", "then"], ["proof (chain)\npicking this:\n  sset xs \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>y. \\<exists>x\\<in>?S. P x y) ys", "show ?thesis"], ["proof (prove)\nusing this:\n  sset xs \\<subseteq> ?S \\<Longrightarrow>\n  pred_stream (\\<lambda>y. \\<exists>x\\<in>?S. P x y) ys\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  sset xs \\<subseteq> ?S \\<Longrightarrow>\n  \\<forall>y\\<in>sset ys. \\<exists>x\\<in>?S. P x y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>sset ys. \\<exists>x\\<in>sset xs. P x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smap_eq_scons[iff]: \"smap f xs = y ## ys \\<longleftrightarrow> f (shd xs) = y \\<and> smap f (stl xs) = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (smap f xs = y ## ys) = (f (shd xs) = y \\<and> smap f (stl xs) = ys)", "using smap_ctr"], ["proof (prove)\nusing this:\n  (smap ?f ?s = ?x ## ?s') =\n  (?f (shd ?s) = ?x \\<and> smap ?f (stl ?s) = ?s')\n\ngoal (1 subgoal):\n 1. (smap f xs = y ## ys) = (f (shd xs) = y \\<and> smap f (stl xs) = ys)", "by metis"], ["", "lemma scons_eq_smap[iff]: \"y ## ys = smap f xs \\<longleftrightarrow> y = f (shd xs) \\<and> ys = smap f (stl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ## ys = smap f xs) = (y = f (shd xs) \\<and> ys = smap f (stl xs))", "using smap_ctr"], ["proof (prove)\nusing this:\n  (smap ?f ?s = ?x ## ?s') =\n  (?f (shd ?s) = ?x \\<and> smap ?f (stl ?s) = ?s')\n\ngoal (1 subgoal):\n 1. (y ## ys = smap f xs) = (y = f (shd xs) \\<and> ys = smap f (stl xs))", "by metis"], ["", "lemma smap_eq_shift[iff]:\n    \"smap f w = u @- v \\<longleftrightarrow> (\\<exists> w\\<^sub>1 w\\<^sub>2. w = w\\<^sub>1 @- w\\<^sub>2 \\<and> map f w\\<^sub>1 = u \\<and> smap f w\\<^sub>2 = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (smap f w = u @- v) =\n    (\\<exists>w\\<^sub>1 w\\<^sub>2.\n        w = w\\<^sub>1 @- w\\<^sub>2 \\<and>\n        map f w\\<^sub>1 = u \\<and> smap f w\\<^sub>2 = v)", "using sdrop_smap eq_shift stake_sdrop stake_smap"], ["proof (prove)\nusing this:\n  sdrop ?n (smap ?f ?s) = smap ?f (sdrop ?n ?s)\n  (?w = ?u @- ?v) =\n  (stake (length ?u) ?w = ?u \\<and> sdrop (length ?u) ?w = ?v)\n  stake ?n ?s @- sdrop ?n ?s = ?s\n  stake ?n (smap ?f ?s) = map ?f (stake ?n ?s)\n\ngoal (1 subgoal):\n 1. (smap f w = u @- v) =\n    (\\<exists>w\\<^sub>1 w\\<^sub>2.\n        w = w\\<^sub>1 @- w\\<^sub>2 \\<and>\n        map f w\\<^sub>1 = u \\<and> smap f w\\<^sub>2 = v)", "by metis"], ["", "lemma shift_eq_smap[iff]:\n    \"u @- v = smap f w \\<longleftrightarrow> (\\<exists> w\\<^sub>1 w\\<^sub>2. w = w\\<^sub>1 @- w\\<^sub>2 \\<and> u = map f w\\<^sub>1 \\<and> v = smap f w\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u @- v = smap f w) =\n    (\\<exists>w\\<^sub>1 w\\<^sub>2.\n        w = w\\<^sub>1 @- w\\<^sub>2 \\<and>\n        u = map f w\\<^sub>1 \\<and> v = smap f w\\<^sub>2)", "using sdrop_smap eq_shift stake_sdrop stake_smap"], ["proof (prove)\nusing this:\n  sdrop ?n (smap ?f ?s) = smap ?f (sdrop ?n ?s)\n  (?w = ?u @- ?v) =\n  (stake (length ?u) ?w = ?u \\<and> sdrop (length ?u) ?w = ?v)\n  stake ?n ?s @- sdrop ?n ?s = ?s\n  stake ?n (smap ?f ?s) = map ?f (stake ?n ?s)\n\ngoal (1 subgoal):\n 1. (u @- v = smap f w) =\n    (\\<exists>w\\<^sub>1 w\\<^sub>2.\n        w = w\\<^sub>1 @- w\\<^sub>2 \\<and>\n        u = map f w\\<^sub>1 \\<and> v = smap f w\\<^sub>2)", "by metis"], ["", "lemma szip_eq_scons[iff]: \"szip xs ys = z ## zs \\<longleftrightarrow> (shd xs, shd ys) = z \\<and> szip (stl xs) (stl ys) = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (szip xs ys = z ## zs) =\n    ((shd xs, shd ys) = z \\<and> szip (stl xs) (stl ys) = zs)", "using szip.ctr stream.inject"], ["proof (prove)\nusing this:\n  szip ?s1.0 ?s2.0 = (shd ?s1.0, shd ?s2.0) ## szip (stl ?s1.0) (stl ?s2.0)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (szip xs ys = z ## zs) =\n    ((shd xs, shd ys) = z \\<and> szip (stl xs) (stl ys) = zs)", "by metis"], ["", "lemma scons_eq_szip[iff]: \"z ## zs = szip xs ys \\<longleftrightarrow> z = (shd xs, shd ys) \\<and> zs = szip (stl xs) (stl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z ## zs = szip xs ys) =\n    (z = (shd xs, shd ys) \\<and> zs = szip (stl xs) (stl ys))", "using szip.ctr stream.inject"], ["proof (prove)\nusing this:\n  szip ?s1.0 ?s2.0 = (shd ?s1.0, shd ?s2.0) ## szip (stl ?s1.0) (stl ?s2.0)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (z ## zs = szip xs ys) =\n    (z = (shd xs, shd ys) \\<and> zs = szip (stl xs) (stl ys))", "by metis"], ["", "lemma siterate_eq_scons[iff]: \"siterate f s = a ## w \\<longleftrightarrow> s = a \\<and> siterate f (f s) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (siterate f s = a ## w) = (s = a \\<and> siterate f (f s) = w)", "using siterate.ctr stream.inject"], ["proof (prove)\nusing this:\n  siterate ?f ?x = ?x ## siterate ?f (?f ?x)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (siterate f s = a ## w) = (s = a \\<and> siterate f (f s) = w)", "by metis"], ["", "lemma scons_eq_siterate[iff]: \"a ## w = siterate f s \\<longleftrightarrow> a = s \\<and> w = siterate f (f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ## w = siterate f s) = (a = s \\<and> w = siterate f (f s))", "using siterate.ctr stream.inject"], ["proof (prove)\nusing this:\n  siterate ?f ?x = ?x ## siterate ?f (?f ?x)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (a ## w = siterate f s) = (a = s \\<and> w = siterate f (f s))", "by metis"], ["", "lemma snth_0: \"(a ## w) !! 0 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ## w) !! 0 = a", "by simp"], ["", "lemma eqI_snth:\n    assumes \"\\<And> i. u !! i = v !! i\"\n    shows \"u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "using assms"], ["proof (prove)\nusing this:\n  u !! ?i = v !! ?i\n\ngoal (1 subgoal):\n 1. u = v", "by (coinduction arbitrary: u v) (metis stream.sel snth.simps)"], ["", "lemma stream_pred_snth: \"pred_stream P w \\<longleftrightarrow> (\\<forall> i. P (w !! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P w = (\\<forall>i. P (w !! i))", "unfolding stream.pred_set sset_range"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (range ((!!) w)) P = (\\<forall>i. P (w !! i))", "by simp"], ["", "lemma stream_rel_snth: \"stream_all2 P u v \\<longleftrightarrow> (\\<forall> i. P (u !! i) (v !! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P u v = (\\<forall>i. P (u !! i) (v !! i))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. stream_all2 P u v \\<Longrightarrow> P (u !! i) (v !! i)\n 2. \\<forall>i. P (u !! i) (v !! i) \\<Longrightarrow> stream_all2 P u v", "show \"P (u !! i) (v !! i)\" if \"stream_all2 P u v\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (u !! i) (v !! i)", "using that"], ["proof (prove)\nusing this:\n  stream_all2 P u v\n\ngoal (1 subgoal):\n 1. P (u !! i) (v !! i)", "by (induct i arbitrary: u v) (auto elim: stream.rel_cases)"], ["proof (state)\nthis:\n  stream_all2 P u v \\<Longrightarrow> P (u !! ?i) (v !! ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. P (u !! i) (v !! i) \\<Longrightarrow> stream_all2 P u v", "show \"stream_all2 P u v\" if \"\\<forall> i. P (u !! i) (v !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P u v", "using that"], ["proof (prove)\nusing this:\n  \\<forall>i. P (u !! i) (v !! i)\n\ngoal (1 subgoal):\n 1. stream_all2 P u v", "by (coinduct) (metis snth_0 snth_Stream)"], ["proof (state)\nthis:\n  \\<forall>i. P (u !! i) (v !! i) \\<Longrightarrow> stream_all2 P u v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stream_rel_pred_szip: \"stream_all2 P u v \\<longleftrightarrow> pred_stream (case_prod P) (szip u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P u v = pred_stream (\\<lambda>(x, y). P x y) (szip u v)", "unfolding stream_pred_snth stream_rel_snth"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. P (u !! i) (v !! i)) =\n    (\\<forall>i. case szip u v !! i of (x, xa) \\<Rightarrow> P x xa)", "by simp"], ["", "lemma sconst_eq[iff]: \"sconst x = sconst y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sconst x = sconst y) = (x = y)", "by (auto) (metis siterate.simps(1))"], ["", "lemma stream_pred__sconst[iff]: \"pred_stream P (sconst x) \\<longleftrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream P (sconst x) = P x", "unfolding stream_pred_snth"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. P (sconst x !! i)) = P x", "by simp"], ["", "lemma stream_rel_sconst[iff]: \"stream_all2 P (sconst x) (sconst y) \\<longleftrightarrow> P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 P (sconst x) (sconst y) = P x y", "unfolding stream_rel_snth"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. P (sconst x !! i) (sconst y !! i)) = P x y", "by simp"], ["", "lemma set_sset_stake[intro!, simp]: \"set (stake n xs) \\<subseteq> sset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (stake n xs) \\<subseteq> sset xs", "by (metis sset_shift stake_sdrop sup_ge1)"], ["", "lemma sset_sdrop[intro!, simp]: \"sset (sdrop n xs) \\<subseteq> sset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (sdrop n xs) \\<subseteq> sset xs", "by (metis sset_shift stake_sdrop sup_ge2)"], ["", "lemma set_stake_snth: \"x \\<in> set (stake n xs) \\<longleftrightarrow> (\\<exists> i < n. xs !! i = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (stake n xs)) = (\\<exists>i<n. xs !! i = x)", "unfolding in_set_conv_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i<length (stake n xs). stake n xs ! i = x) =\n    (\\<exists>i<n. xs !! i = x)", "by auto"], ["", "(* TODO: these should be generated by the transfer option on the primcorec definitions *)\n  (* TODO: transfer_prover cannot handle corecursive definitions due to the \\<lambda>(s1, s2). undefined\n    abortion term that is never used *)"], ["", "lemma szip_transfer[transfer_rule]:\n    includes lifting_syntax\n    shows \"(stream_all2 A ===> stream_all2 B ===> stream_all2 (rel_prod A B)) szip szip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stream_all2 A ===> stream_all2 B ===> stream_all2 (rel_prod A B)) szip\n     szip", "by (intro rel_funI, coinduction) (force elim: stream.rel_cases)"], ["", "lemma siterate_transfer[transfer_rule]:\n    includes lifting_syntax\n    shows \"((A ===> A) ===> A ===> stream_all2 A) siterate siterate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A) ===> A ===> stream_all2 A) siterate siterate", "by (intro rel_funI, coinduction) (force dest: rel_funD)"], ["", "lemma split_stream_first:\n    assumes \"A \\<inter> sset xs \\<noteq> {}\"\n    obtains ys a zs\n    where \"xs = ys @- a ## zs\" \"A \\<inter> set ys = {}\" \"a \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs = ?ys2 @- ?a2 ## ?zs2\n 2. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    A \\<inter> set ?ys2 = {}\n 3. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?a2 \\<in> A", "let ?n = \"LEAST n. xs !! n \\<in> A\""], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs = ?ys2 @- ?a2 ## ?zs2\n 2. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    A \\<inter> set ?ys2 = {}\n 3. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?a2 \\<in> A", "have 1: \"xs !! n \\<notin> A\" if \"n < ?n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs !! n \\<notin> A", "using that"], ["proof (prove)\nusing this:\n  n < (LEAST n. xs !! n \\<in> A)\n\ngoal (1 subgoal):\n 1. xs !! n \\<notin> A", "by (metis (full_types) not_less_Least)"], ["proof (state)\nthis:\n  ?n < (LEAST n. xs !! n \\<in> A) \\<Longrightarrow> xs !! ?n \\<notin> A\n\ngoal (3 subgoals):\n 1. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs = ?ys2 @- ?a2 ## ?zs2\n 2. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    A \\<inter> set ?ys2 = {}\n 3. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?a2 \\<in> A", "show \"xs = stake ?n xs @- (xs !! ?n) ## sdrop (Suc ?n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    stake (LEAST n. xs !! n \\<in> A) xs @-\n    xs !! (LEAST n. xs !! n \\<in> A) ##\n    sdrop (Suc (LEAST n. xs !! n \\<in> A)) xs", "using id_stake_snth_sdrop"], ["proof (prove)\nusing this:\n  ?s = stake ?i ?s @- ?s !! ?i ## sdrop (Suc ?i) ?s\n\ngoal (1 subgoal):\n 1. xs =\n    stake (LEAST n. xs !! n \\<in> A) xs @-\n    xs !! (LEAST n. xs !! n \\<in> A) ##\n    sdrop (Suc (LEAST n. xs !! n \\<in> A)) xs", "by blast"], ["proof (state)\nthis:\n  xs =\n  stake (LEAST n. xs !! n \\<in> A) xs @-\n  xs !! (LEAST n. xs !! n \\<in> A) ##\n  sdrop (Suc (LEAST n. xs !! n \\<in> A)) xs\n\ngoal (2 subgoals):\n 1. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    A \\<inter> set (stake (LEAST n. xs !! n \\<in> A) xs) = {}\n 2. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs !! (LEAST n. xs !! n \\<in> A) \\<in> A", "show \"A \\<inter> set (stake ?n xs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> set (stake (LEAST n. xs !! n \\<in> A) xs) = {}", "using 1"], ["proof (prove)\nusing this:\n  ?n < (LEAST n. xs !! n \\<in> A) \\<Longrightarrow> xs !! ?n \\<notin> A\n\ngoal (1 subgoal):\n 1. A \\<inter> set (stake (LEAST n. xs !! n \\<in> A) xs) = {}", "by (metis (no_types, lifting) disjoint_iff_not_equal set_stake_snth)"], ["proof (state)\nthis:\n  A \\<inter> set (stake (LEAST n. xs !! n \\<in> A) xs) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>ys a zs.\n        \\<lbrakk>xs = ys @- a ## zs; A \\<inter> set ys = {};\n         a \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs !! (LEAST n. xs !! n \\<in> A) \\<in> A", "show \"xs !! ?n \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs !! (LEAST n. xs !! n \\<in> A) \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  A \\<inter> sset xs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. xs !! (LEAST n. xs !! n \\<in> A) \\<in> A", "unfolding sset_range"], ["proof (prove)\nusing this:\n  A \\<inter> range ((!!) xs) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. xs !! (LEAST n. xs !! n \\<in> A) \\<in> A", "by (auto intro: LeastI)"], ["proof (state)\nthis:\n  xs !! (LEAST n. xs !! n \\<in> A) \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_stream_first':\n    assumes \"x \\<in> sset xs\"\n    obtains ys zs\n    where \"xs = ys @- x ## zs\" \"x \\<notin> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs = ?ys2 @- x ## ?zs2\n 2. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    x \\<notin> set ?ys2", "let ?n = \"LEAST n. xs !! n = x\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs = ?ys2 @- x ## ?zs2\n 2. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    x \\<notin> set ?ys2", "have 1: \"xs !! ?n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs !! (LEAST n. xs !! n = x) = x", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> sset xs\n\ngoal (1 subgoal):\n 1. xs !! (LEAST n. xs !! n = x) = x", "unfolding sset_range"], ["proof (prove)\nusing this:\n  x \\<in> range ((!!) xs)\n\ngoal (1 subgoal):\n 1. xs !! (LEAST n. xs !! n = x) = x", "by (auto intro: LeastI)"], ["proof (state)\nthis:\n  xs !! (LEAST n. xs !! n = x) = x\n\ngoal (2 subgoals):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs = ?ys2 @- x ## ?zs2\n 2. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    x \\<notin> set ?ys2", "have 2: \"xs !! n \\<noteq> x\" if \"n < ?n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs !! n \\<noteq> x", "using that"], ["proof (prove)\nusing this:\n  n < (LEAST n. xs !! n = x)\n\ngoal (1 subgoal):\n 1. xs !! n \\<noteq> x", "by (metis (full_types) not_less_Least)"], ["proof (state)\nthis:\n  ?n < (LEAST n. xs !! n = x) \\<Longrightarrow> xs !! ?n \\<noteq> x\n\ngoal (2 subgoals):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    xs = ?ys2 @- x ## ?zs2\n 2. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    x \\<notin> set ?ys2", "show \"xs = stake ?n xs @- x ## sdrop (Suc ?n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    stake (LEAST n. xs !! n = x) xs @-\n    x ## sdrop (Suc (LEAST n. xs !! n = x)) xs", "using 1"], ["proof (prove)\nusing this:\n  xs !! (LEAST n. xs !! n = x) = x\n\ngoal (1 subgoal):\n 1. xs =\n    stake (LEAST n. xs !! n = x) xs @-\n    x ## sdrop (Suc (LEAST n. xs !! n = x)) xs", "by (metis id_stake_snth_sdrop)"], ["proof (state)\nthis:\n  xs =\n  stake (LEAST n. xs !! n = x) xs @-\n  x ## sdrop (Suc (LEAST n. xs !! n = x)) xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        \\<lbrakk>xs = ys @- x ## zs; x \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    x \\<notin> set (stake (LEAST n. xs !! n = x) xs)", "show \"x \\<notin> set (stake ?n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set (stake (LEAST n. xs !! n = x) xs)", "using 2"], ["proof (prove)\nusing this:\n  ?n < (LEAST n. xs !! n = x) \\<Longrightarrow> xs !! ?n \\<noteq> x\n\ngoal (1 subgoal):\n 1. x \\<notin> set (stake (LEAST n. xs !! n = x) xs)", "by (meson set_stake_snth)"], ["proof (state)\nthis:\n  x \\<notin> set (stake (LEAST n. xs !! n = x) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma streams_UNIV[iff]: \"streams A = UNIV \\<longleftrightarrow> A = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (streams A = UNIV) = (A = UNIV)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. streams A = UNIV \\<Longrightarrow> A = UNIV\n 2. A = UNIV \\<Longrightarrow> streams A = UNIV", "show \"A = UNIV \\<Longrightarrow> streams A = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = UNIV \\<Longrightarrow> streams A = UNIV", "by simp"], ["proof (state)\nthis:\n  A = UNIV \\<Longrightarrow> streams A = UNIV\n\ngoal (1 subgoal):\n 1. streams A = UNIV \\<Longrightarrow> A = UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. streams A = UNIV \\<Longrightarrow> A = UNIV", "assume \"streams A = UNIV\""], ["proof (state)\nthis:\n  streams A = UNIV\n\ngoal (1 subgoal):\n 1. streams A = UNIV \\<Longrightarrow> A = UNIV", "then"], ["proof (chain)\npicking this:\n  streams A = UNIV", "have \"w \\<in> streams A\" for w"], ["proof (prove)\nusing this:\n  streams A = UNIV\n\ngoal (1 subgoal):\n 1. w \\<in> streams A", "by simp"], ["proof (state)\nthis:\n  ?w \\<in> streams A\n\ngoal (1 subgoal):\n 1. streams A = UNIV \\<Longrightarrow> A = UNIV", "then"], ["proof (chain)\npicking this:\n  ?w \\<in> streams A", "have \"sset w \\<subseteq> A\" for w"], ["proof (prove)\nusing this:\n  ?w \\<in> streams A\n\ngoal (1 subgoal):\n 1. sset w \\<subseteq> A", "unfolding streams_iff_sset"], ["proof (prove)\nusing this:\n  sset ?w \\<subseteq> A\n\ngoal (1 subgoal):\n 1. sset w \\<subseteq> A", "by this"], ["proof (state)\nthis:\n  sset ?w \\<subseteq> A\n\ngoal (1 subgoal):\n 1. streams A = UNIV \\<Longrightarrow> A = UNIV", "then"], ["proof (chain)\npicking this:\n  sset ?w \\<subseteq> A", "have \"sset (sconst a) \\<subseteq> A\" for a"], ["proof (prove)\nusing this:\n  sset ?w \\<subseteq> A\n\ngoal (1 subgoal):\n 1. sset (sconst a) \\<subseteq> A", "by blast"], ["proof (state)\nthis:\n  sset (sconst ?a) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. streams A = UNIV \\<Longrightarrow> A = UNIV", "then"], ["proof (chain)\npicking this:\n  sset (sconst ?a) \\<subseteq> A", "have \"a \\<in> A\" for a"], ["proof (prove)\nusing this:\n  sset (sconst ?a) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. a \\<in> A", "by simp"], ["proof (state)\nthis:\n  ?a \\<in> A\n\ngoal (1 subgoal):\n 1. streams A = UNIV \\<Longrightarrow> A = UNIV", "then"], ["proof (chain)\npicking this:\n  ?a \\<in> A", "show \"A = UNIV\""], ["proof (prove)\nusing this:\n  ?a \\<in> A\n\ngoal (1 subgoal):\n 1. A = UNIV", "by auto"], ["proof (state)\nthis:\n  A = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma streams_int[simp]: \"streams (A \\<inter> B) = streams A \\<inter> streams B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. streams (A \\<inter> B) = streams A \\<inter> streams B", "by (auto iff: streams_iff_sset)"], ["", "lemma streams_Int[simp]: \"streams (\\<Inter> S) = \\<Inter> (streams ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. streams (\\<Inter> S) = \\<Inter> (streams ` S)", "by (auto iff: streams_iff_sset)"], ["", "lemma pred_list_listsp[pred_set_conv]: \"list_all = listsp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all = listsp", "unfolding list.pred_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>P x. Ball (set x) P) = listsp", "by auto"], ["", "lemma pred_stream_streamsp[pred_set_conv]: \"pred_stream = streamsp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream = streamsp", "unfolding stream.pred_set streams_iff_sset[to_pred]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>P x. Ball (sset x) P) =\n    (\\<lambda>A s. sset s \\<subseteq> Collect A)", "by auto"], ["", "subsection \\<open>The scan Function\\<close>"], ["", "primrec (transfer) scan :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> 'b \\<Rightarrow> 'b list\" where\n    \"scan f [] a = []\" | \"scan f (x # xs) a = f x a # scan f xs (f x a)\""], ["", "lemma scan_append[simp]: \"scan f (xs @ ys) a = scan f xs a @ scan f ys (fold f xs a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scan f (xs @ ys) a = scan f xs a @ scan f ys (fold f xs a)", "by (induct xs arbitrary: a) (auto)"], ["", "lemma scan_eq_nil[iff]: \"scan f xs a = [] \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (scan f xs a = []) = (xs = [])", "by (cases xs) (auto)"], ["", "lemma scan_eq_cons[iff]:\n    \"scan f xs a = b # w \\<longleftrightarrow> (\\<exists> y ys. xs = y # ys \\<and> f y a = b \\<and> scan f ys (f y a) = w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (scan f xs a = b # w) =\n    (\\<exists>y ys.\n        xs = y # ys \\<and> f y a = b \\<and> scan f ys (f y a) = w)", "by (cases xs) (auto)"], ["", "lemma scan_eq_append[iff]:\n    \"scan f xs a = u @ v \\<longleftrightarrow> (\\<exists> ys zs. xs = ys @ zs \\<and> scan f ys a = u \\<and> scan f zs (fold f ys a) = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (scan f xs a = u @ v) =\n    (\\<exists>ys zs.\n        xs = ys @ zs \\<and>\n        scan f ys a = u \\<and> scan f zs (fold f ys a) = v)", "by (induct u arbitrary: xs a) (auto, metis append_Cons fold_simps(2), blast)"], ["", "lemma scan_length[simp]: \"length (scan f xs a) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (scan f xs a) = length xs", "by (induct xs arbitrary: a) (auto)"], ["", "(* TODO: figure out how this is used, should it be a simp rule? or flipped? also target_alt_def *)"], ["", "lemma scan_last: \"last (a # scan f xs a) = fold f xs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (a # scan f xs a) = fold f xs a", "by (induct xs arbitrary: a) (auto simp: last.simps)"], ["", "lemma scan_butlast[simp]: \"scan f (butlast xs) a = butlast (scan f xs a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scan f (butlast xs) a = butlast (scan f xs a)", "by (induct xs arbitrary: a) (auto simp: butlast.simps)"], ["", "lemma scan_const[simp]: \"scan const xs a = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scan (\\<lambda>x _. x) xs a = xs", "by (induct xs arbitrary: a) (auto)"], ["", "lemma scan_nth[simp]:\n    assumes \"i < length (scan f xs a)\"\n    shows \"scan f xs a ! i = fold f (take (Suc i) xs) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scan f xs a ! i = fold f (take (Suc i) xs) a", "using assms"], ["proof (prove)\nusing this:\n  i < length (scan f xs a)\n\ngoal (1 subgoal):\n 1. scan f xs a ! i = fold f (take (Suc i) xs) a", "by (cases xs, simp, induct i arbitrary: xs a, auto simp: take_Suc neq_Nil_conv)"], ["", "lemma scan_map[simp]: \"scan f (map g xs) a = scan (f \\<circ> g) xs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scan f (map g xs) a = scan (f \\<circ> g) xs a", "by (induct xs arbitrary: a) (auto)"], ["", "lemma scan_take[simp]: \"take k (scan f xs a) = scan f (take k xs) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take k (scan f xs a) = scan f (take k xs) a", "by (induct k arbitrary: xs a) (auto simp: take_Suc neq_Nil_conv)"], ["", "lemma scan_drop[simp]: \"drop k (scan f xs a) = scan f (drop k xs) (fold f (take k xs) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop k (scan f xs a) = scan f (drop k xs) (fold f (take k xs) a)", "by (induct k arbitrary: xs a) (auto simp: take_Suc neq_Nil_conv)"], ["", "primcorec (transfer) sscan :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'a stream \\<Rightarrow> 'b \\<Rightarrow> 'b stream\" where\n    \"sscan f xs a = f (shd xs) a ## sscan f (stl xs) (f (shd xs) a)\""], ["", "lemma sscan_scons[simp]: \"sscan f (x ## xs) a = f x a ## sscan f xs (f x a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan f (x ## xs) a = f x a ## sscan f xs (f x a)", "by (simp add: stream.expand)"], ["", "lemma sscan_shift[simp]: \"sscan f (xs @- ys) a = scan f xs a @- sscan f ys (fold f xs a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan f (xs @- ys) a = scan f xs a @- sscan f ys (fold f xs a)", "by (induct xs arbitrary: a) (auto)"], ["", "lemma sscan_eq_scons[iff]:\n    \"sscan f xs a = b ## w \\<longleftrightarrow> f (shd xs) a = b \\<and> sscan f (stl xs) (f (shd xs) a) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sscan f xs a = b ## w) =\n    (f (shd xs) a = b \\<and> sscan f (stl xs) (f (shd xs) a) = w)", "using sscan.ctr stream.inject"], ["proof (prove)\nusing this:\n  sscan ?f ?xs ?a = ?f (shd ?xs) ?a ## sscan ?f (stl ?xs) (?f (shd ?xs) ?a)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (sscan f xs a = b ## w) =\n    (f (shd xs) a = b \\<and> sscan f (stl xs) (f (shd xs) a) = w)", "by metis"], ["", "lemma scons_eq_sscan[iff]:\n    \"b ## w = sscan f xs a \\<longleftrightarrow> b = f (shd xs) a \\<and> w = sscan f (stl xs) (f (shd xs) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b ## w = sscan f xs a) =\n    (b = f (shd xs) a \\<and> w = sscan f (stl xs) (f (shd xs) a))", "using sscan.ctr stream.inject"], ["proof (prove)\nusing this:\n  sscan ?f ?xs ?a = ?f (shd ?xs) ?a ## sscan ?f (stl ?xs) (?f (shd ?xs) ?a)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (b ## w = sscan f xs a) =\n    (b = f (shd xs) a \\<and> w = sscan f (stl xs) (f (shd xs) a))", "by metis"], ["", "lemma sscan_const[simp]: \"sscan const xs a = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan (\\<lambda>x _. x) xs a = xs", "by (coinduction arbitrary: xs a) (auto)"], ["", "lemma sscan_snth[simp]: \"sscan f xs a !! i = fold f (stake (Suc i) xs) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan f xs a !! i = fold f (stake (Suc i) xs) a", "by (induct i arbitrary: xs a) (auto)"], ["", "lemma sscan_scons_snth[simp]: \"(a ## sscan f xs a) !! i = fold f (stake i xs) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ## sscan f xs a) !! i = fold f (stake i xs) a", "by (induct i arbitrary: xs a) (auto)"], ["", "lemma sscan_smap[simp]: \"sscan f (smap g xs) a = sscan (f \\<circ> g) xs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan f (smap g xs) a = sscan (f \\<circ> g) xs a", "by (coinduction arbitrary: xs a) (auto)"], ["", "lemma sscan_stake[simp]: \"stake k (sscan f xs a) = scan f (stake k xs) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake k (sscan f xs a) = scan f (stake k xs) a", "by (induct k arbitrary: a xs) (auto)"], ["", "lemma sscan_sdrop[simp]: \"sdrop k (sscan f xs a) = sscan f (sdrop k xs) (fold f (stake k xs) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop k (sscan f xs a) = sscan f (sdrop k xs) (fold f (stake k xs) a)", "by (induct k arbitrary: a xs) (auto)"], ["", "subsection \\<open>Transposing Streams\\<close>"], ["", "primcorec (transfer) stranspose :: \"'a stream list \\<Rightarrow> 'a list stream\" where\n    \"stranspose ws = map shd ws ## stranspose (map stl ws)\""], ["", "lemma stranspose_eq_scons[iff]: \"stranspose ws = a ## w \\<longleftrightarrow> map shd ws = a \\<and> stranspose (map stl ws) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stranspose ws = a ## w) =\n    (map shd ws = a \\<and> stranspose (map stl ws) = w)", "using stranspose.ctr stream.inject"], ["proof (prove)\nusing this:\n  stranspose ?ws = map shd ?ws ## stranspose (map stl ?ws)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (stranspose ws = a ## w) =\n    (map shd ws = a \\<and> stranspose (map stl ws) = w)", "by metis"], ["", "lemma scons_eq_stranspose[iff]: \"a ## w = stranspose ws \\<longleftrightarrow> a = map shd ws \\<and> w = stranspose (map stl ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ## w = stranspose ws) =\n    (a = map shd ws \\<and> w = stranspose (map stl ws))", "using stranspose.ctr stream.inject"], ["proof (prove)\nusing this:\n  stranspose ?ws = map shd ?ws ## stranspose (map stl ?ws)\n  (?x1.0 ## ?x2.0 = ?y1.0 ## ?y2.0) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. (a ## w = stranspose ws) =\n    (a = map shd ws \\<and> w = stranspose (map stl ws))", "by metis"], ["", "lemma stranspose_nil[simp]: \"stranspose [] = sconst []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stranspose [] = sconst []", "by coinduction auto"], ["", "lemma stranspose_cons[simp]: \"stranspose (w # ws) = smap2 Cons w (stranspose ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stranspose (w # ws) = smap2 (#) w (stranspose ws)", "by (coinduction arbitrary: w ws) (metis list.simps(9) smap2.simps stranspose.simps stream.sel)"], ["", "lemma snth_stranspose[simp]: \"stranspose ws !! k = map (\\<lambda> w. w !! k) ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stranspose ws !! k = map (\\<lambda>w. w !! k) ws", "by (induct k arbitrary: ws) (auto)"], ["", "lemma stranspose_nth[simp]:\n    assumes \"k < length ws\"\n    shows \"smap (\\<lambda> xs. xs ! k) (stranspose ws) = ws ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (\\<lambda>xs. xs ! k) (stranspose ws) = ws ! k", "using assms"], ["proof (prove)\nusing this:\n  k < length ws\n\ngoal (1 subgoal):\n 1. smap (\\<lambda>xs. xs ! k) (stranspose ws) = ws ! k", "by (auto intro: eqI_snth)"], ["", "subsection \\<open>Distinct Streams\\<close>"], ["", "coinductive sdistinct :: \"'a stream \\<Rightarrow> bool\" where\n    scons[intro!]: \"x \\<notin> sset xs \\<Longrightarrow> sdistinct xs \\<Longrightarrow> sdistinct (x ## xs)\""], ["", "lemma sdistinct_scons_elim[elim!]:\n    assumes \"sdistinct (x ## xs)\"\n    obtains \"x \\<notin> sset xs\" \"sdistinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>x \\<notin> sset xs; sdistinct xs\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  sdistinct (x ## xs)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>x \\<notin> sset xs; sdistinct xs\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: sdistinct.cases)"], ["", "lemma sdistinct_coinduct[case_names sdistinct, coinduct pred: sdistinct]:\n    assumes \"P xs\"\n    assumes \"\\<And> x xs. P (x ## xs) \\<Longrightarrow> x \\<notin> sset xs \\<and> P xs\"\n    shows \"sdistinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdistinct xs", "using stream.collapse sdistinct.coinduct assms"], ["proof (prove)\nusing this:\n  shd ?stream ## stl ?stream = ?stream\n  \\<lbrakk>?X ?x;\n   \\<And>x.\n      ?X x \\<Longrightarrow>\n      \\<exists>xa xs.\n         x = xa ## xs \\<and>\n         xa \\<notin> sset xs \\<and> (?X xs \\<or> sdistinct xs)\\<rbrakk>\n  \\<Longrightarrow> sdistinct ?x\n  P xs\n  P (?x ## ?xs) \\<Longrightarrow> ?x \\<notin> sset ?xs \\<and> P ?xs\n\ngoal (1 subgoal):\n 1. sdistinct xs", "by metis"], ["", "lemma sdistinct_shift[intro!]:\n    assumes \"distinct xs\" \"sdistinct ys\" \"set xs \\<inter> sset ys = {}\"\n    shows \"sdistinct (xs @- ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdistinct (xs @- ys)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  sdistinct ys\n  set xs \\<inter> sset ys = {}\n\ngoal (1 subgoal):\n 1. sdistinct (xs @- ys)", "by (induct xs) (auto)"], ["", "lemma sdistinct_shift_elim[elim!]:\n    assumes \"sdistinct (xs @- ys)\"\n    obtains \"distinct xs\" \"sdistinct ys\" \"set xs \\<inter> sset ys = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>distinct xs; sdistinct ys;\n      set xs \\<inter> sset ys = {}\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  sdistinct (xs @- ys)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>distinct xs; sdistinct ys;\n      set xs \\<inter> sset ys = {}\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (induct xs) (auto)"], ["", "lemma sdistinct_infinite_sset:\n    assumes \"sdistinct w\"\n    shows \"infinite (sset w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (sset w)", "using assms"], ["proof (prove)\nusing this:\n  sdistinct w\n\ngoal (1 subgoal):\n 1. infinite (sset w)", "by (coinduction arbitrary: w) (force elim: sdistinct.cases)"], ["", "lemma not_sdistinct_decomp:\n    assumes \"\\<not> sdistinct w\"\n    obtains u v a w'\n    where \"w = u @- a ## v @- a ## w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u a v w'.\n        w = u @- a ## v @- a ## w' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v w'.\n                w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> False", "assume 1: \"\\<not> thesis\""], ["proof (state)\nthis:\n  \\<not> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v w'.\n                w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> False", "assume 2: \"w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis\" for u a v w'"], ["proof (state)\nthis:\n  w = ?u @- ?a ## ?v @- ?a ## ?w' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v w'.\n                w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> False", "have 3: \"\\<forall> u v a w'. w \\<noteq> u @- a ## v @- a ## w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u v a w'. w \\<noteq> u @- a ## v @- a ## w'", "using 1 2"], ["proof (prove)\nusing this:\n  \\<not> thesis\n  w = ?u @- ?a ## ?v @- ?a ## ?w' \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<forall>u v a w'. w \\<noteq> u @- a ## v @- a ## w'", "by auto"], ["proof (state)\nthis:\n  \\<forall>u v a w'. w \\<noteq> u @- a ## v @- a ## w'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v w'.\n                w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> False", "have 4: \"sdistinct w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdistinct w", "using 3"], ["proof (prove)\nusing this:\n  \\<forall>u v a w'. w \\<noteq> u @- a ## v @- a ## w'\n\ngoal (1 subgoal):\n 1. sdistinct w", "by (coinduct) (metis id_stake_snth_sdrop imageE shift.simps sset_range)"], ["proof (state)\nthis:\n  sdistinct w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v w'.\n                w = u @- a ## v @- a ## w' \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms 4"], ["proof (prove)\nusing this:\n  \\<not> sdistinct w\n  sdistinct w\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Sorted Streams\\<close>"], ["", "coinductive (in order) sascending :: \"'a stream \\<Rightarrow> bool\" where\n    \"a \\<le> b \\<Longrightarrow> sascending (b ## w) \\<Longrightarrow> sascending (a ## b ## w)\""], ["", "coinductive (in order) sdescending :: \"'a stream \\<Rightarrow> bool\" where\n    \"a \\<ge> b \\<Longrightarrow> sdescending (b ## w) \\<Longrightarrow> sdescending (a ## b ## w)\""], ["", "lemma sdescending_coinduct[case_names sdescending, coinduct pred: sdescending]:\n    assumes \"P w\"\n    assumes \"\\<And> a b w. P (a ## b ## w) \\<Longrightarrow> a \\<ge> b \\<and> P (b ## w)\"\n    shows \"sdescending w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdescending w", "using stream.collapse sdescending.coinduct assms"], ["proof (prove)\nusing this:\n  shd ?stream ## stl ?stream = ?stream\n  \\<lbrakk>?X ?x;\n   \\<And>x.\n      ?X x \\<Longrightarrow>\n      \\<exists>a b w.\n         x = a ## b ## w \\<and>\n         b \\<le> a \\<and> (?X (b ## w) \\<or> sdescending (b ## w))\\<rbrakk>\n  \\<Longrightarrow> sdescending ?x\n  P w\n  P (?a ## ?b ## ?w) \\<Longrightarrow> ?b \\<le> ?a \\<and> P (?b ## ?w)\n\ngoal (1 subgoal):\n 1. sdescending w", "by (metis (no_types))"], ["", "lemma sdescending_scons:\n    assumes \"sdescending (a ## w)\"\n    shows \"sdescending w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdescending w", "using assms"], ["proof (prove)\nusing this:\n  sdescending (a ## w)\n\ngoal (1 subgoal):\n 1. sdescending w", "by (auto elim: sdescending.cases)"], ["", "lemma sdescending_sappend:\n    assumes \"sdescending (u @- v)\"\n    obtains \"sdescending v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sdescending v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  sdescending (u @- v)\n\ngoal (1 subgoal):\n 1. (sdescending v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (induct u) (auto elim: sdescending.cases)"], ["", "lemma sdescending_sdrop:\n    assumes \"sdescending w\"\n    shows \"sdescending (sdrop k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdescending (sdrop k w)", "using assms"], ["proof (prove)\nusing this:\n  sdescending w\n\ngoal (1 subgoal):\n 1. sdescending (sdrop k w)", "by (metis sdescending_sappend stake_sdrop)"], ["", "lemma sdescending_sset_scons:\n    assumes \"sdescending (a ## w)\"\n    assumes \"b \\<in> sset w\"\n    shows \"a \\<ge> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<le> a", "have \"pred_stream (\\<lambda> b. a \\<ge> b) w\" if \"sdescending w\" \"a \\<ge> shd w\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>b. b \\<le> a) w", "using that"], ["proof (prove)\nusing this:\n  sdescending w\n  shd w \\<le> a\n\ngoal (1 subgoal):\n 1. pred_stream (\\<lambda>b. b \\<le> a) w", "by (coinduction arbitrary: w) (auto elim: sdescending.cases)"], ["proof (state)\nthis:\n  \\<lbrakk>sdescending ?w; shd ?w \\<le> a\\<rbrakk>\n  \\<Longrightarrow> pred_stream (\\<lambda>b. b \\<le> a) ?w\n\ngoal (1 subgoal):\n 1. b \\<le> a", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sdescending ?w; shd ?w \\<le> a\\<rbrakk>\n  \\<Longrightarrow> pred_stream (\\<lambda>b. b \\<le> a) ?w", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>sdescending ?w; shd ?w \\<le> a\\<rbrakk>\n  \\<Longrightarrow> pred_stream (\\<lambda>b. b \\<le> a) ?w\n\ngoal (1 subgoal):\n 1. b \\<le> a", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>sdescending ?w; shd ?w \\<le> a\\<rbrakk>\n  \\<Longrightarrow> pred_stream (\\<lambda>b. b \\<le> a) ?w\n  sdescending (a ## w)\n  b \\<in> sset w\n\ngoal (1 subgoal):\n 1. b \\<le> a", "unfolding stream.pred_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>sdescending ?w; shd ?w \\<le> a\\<rbrakk>\n  \\<Longrightarrow> \\<forall>b\\<in>sset ?w. b \\<le> a\n  sdescending (a ## w)\n  b \\<in> sset w\n\ngoal (1 subgoal):\n 1. b \\<le> a", "by force"], ["proof (state)\nthis:\n  b \\<le> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sdescending_sset_sappend:\n    assumes \"sdescending (u @- v)\"\n    assumes \"a \\<in> set u\" \"b \\<in> sset v\"\n    shows \"a \\<ge> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> a", "using assms"], ["proof (prove)\nusing this:\n  sdescending (u @- v)\n  a \\<in> set u\n  b \\<in> sset v\n\ngoal (1 subgoal):\n 1. b \\<le> a", "by (induct u) (auto elim: sdescending.cases dest: sdescending_sset_scons)"], ["", "lemma sdescending_snth_antimono:\n    assumes \"sdescending w\"\n    shows \"antimono (snth w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antimono ((!!) w)", "unfolding antimono_iff_le_Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. w !! Suc n \\<le> w !! n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. w !! Suc n \\<le> w !! n", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. w !! Suc n \\<le> w !! n", "have \"sdescending (sdrop k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdescending (sdrop k w)", "using sdescending_sdrop assms"], ["proof (prove)\nusing this:\n  sdescending ?w \\<Longrightarrow> sdescending (sdrop ?k ?w)\n  sdescending w\n\ngoal (1 subgoal):\n 1. sdescending (sdrop k w)", "by this"], ["proof (state)\nthis:\n  sdescending (sdrop k w)\n\ngoal (1 subgoal):\n 1. \\<And>n. w !! Suc n \\<le> w !! n", "then"], ["proof (chain)\npicking this:\n  sdescending (sdrop k w)", "obtain a b v where 2: \"sdrop k w = a ## b ## v\" \"a \\<ge> b\""], ["proof (prove)\nusing this:\n  sdescending (sdrop k w)\n\ngoal (1 subgoal):\n 1. (\\<And>a b v.\n        \\<lbrakk>sdrop k w = a ## b ## v; b \\<le> a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by rule"], ["proof (state)\nthis:\n  sdrop k w = a ## b ## v\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>n. w !! Suc n \\<le> w !! n", "then"], ["proof (chain)\npicking this:\n  sdrop k w = a ## b ## v\n  b \\<le> a", "show \"w !! k \\<ge> w !! Suc k\""], ["proof (prove)\nusing this:\n  sdrop k w = a ## b ## v\n  b \\<le> a\n\ngoal (1 subgoal):\n 1. w !! Suc k \\<le> w !! k", "by (metis sdrop_simps stream.sel)"], ["proof (state)\nthis:\n  w !! Suc k \\<le> w !! k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sdescending_stuck:\n    fixes w :: \"'a :: wellorder stream\"\n    assumes \"sdescending w\"\n    obtains u a\n    where \"w = u @- sconst a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u a.\n        w = u @- sconst a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  sdescending w\n\ngoal (1 subgoal):\n 1. (\\<And>u a.\n        w = u @- sconst a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct \"shd w\" arbitrary: w thesis rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w thesis.\n       \\<lbrakk>\\<And>wa thesis.\n                   \\<lbrakk>shd wa < shd w;\n                    \\<And>u a. wa = u @- sconst a \\<Longrightarrow> thesis;\n                    sdescending wa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>u a. w = u @- sconst a \\<Longrightarrow> thesis;\n        sdescending w\\<rbrakk>\n       \\<Longrightarrow> thesis", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>shd ?w < shd w;\n   \\<And>u a. ?w = u @- sconst a \\<Longrightarrow> ?thesis;\n   sdescending ?w\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  w = ?u @- sconst ?a \\<Longrightarrow> thesis\n  sdescending w\n\ngoal (1 subgoal):\n 1. \\<And>w thesis.\n       \\<lbrakk>\\<And>wa thesis.\n                   \\<lbrakk>shd wa < shd w;\n                    \\<And>u a. wa = u @- sconst a \\<Longrightarrow> thesis;\n                    sdescending wa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>u a. w = u @- sconst a \\<Longrightarrow> thesis;\n        sdescending w\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"w = sconst (shd w)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = sconst (shd w) \\<Longrightarrow> thesis\n 2. w \\<noteq> sconst (shd w) \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  w = sconst (shd w)\n\ngoal (2 subgoals):\n 1. w = sconst (shd w) \\<Longrightarrow> thesis\n 2. w \\<noteq> sconst (shd w) \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using shift_replicate_sconst less(2) True"], ["proof (prove)\nusing this:\n  replicate ?n ?x @- sconst ?x = sconst ?x\n  w = ?u @- sconst ?a \\<Longrightarrow> thesis\n  w = sconst (shd w)\n\ngoal (1 subgoal):\n 1. thesis", "by metis"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (shd w) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (shd w) \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  w \\<noteq> sconst (shd w)\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (shd w) \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  w \\<noteq> sconst (shd w)", "obtain u v where 1: \"w = u @- v\" \"u \\<noteq> []\" \"shd w \\<noteq> shd v\""], ["proof (prove)\nusing this:\n  w \\<noteq> sconst (shd w)\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; u \\<noteq> []; shd w \\<noteq> shd v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis empty_iff eqI_snth insert_iff sdrop_simps(1) shift.simps(1) snth_sset sset_sconst stake_sdrop)"], ["proof (state)\nthis:\n  w = u @- v\n  u \\<noteq> []\n  shd w \\<noteq> shd v\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (shd w) \\<Longrightarrow> thesis", "have 2: \"shd w \\<ge> shd v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd v \\<le> shd w", "using sdescending_sset_sappend less(3) 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>sdescending (?u @- ?v); ?a \\<in> set ?u;\n   ?b \\<in> sset ?v\\<rbrakk>\n  \\<Longrightarrow> ?b \\<le> ?a\n  sdescending w\n  w = u @- v\n  u \\<noteq> []\n  shd w \\<noteq> shd v\n\ngoal (1 subgoal):\n 1. shd v \\<le> shd w", "by (metis hd_in_set shd_sset shift_simps(1))"], ["proof (state)\nthis:\n  shd v \\<le> shd w\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (shd w) \\<Longrightarrow> thesis", "have 3: \"shd w > shd v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shd v < shd w", "using 1(3) 2"], ["proof (prove)\nusing this:\n  shd w \\<noteq> shd v\n  shd v \\<le> shd w\n\ngoal (1 subgoal):\n 1. shd v < shd w", "by simp"], ["proof (state)\nthis:\n  shd v < shd w\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (shd w) \\<Longrightarrow> thesis", "obtain s a where 4: \"v = s @- sconst a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s a.\n        v = s @- sconst a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sdescending_sappend less(1, 3) 1(1) 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>sdescending (?u @- ?v);\n   sdescending ?v \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>shd ?w < shd w;\n   \\<And>u a. ?w = u @- sconst a \\<Longrightarrow> ?thesis;\n   sdescending ?w\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  sdescending w\n  w = u @- v\n  shd v < shd w\n\ngoal (1 subgoal):\n 1. (\\<And>s a.\n        v = s @- sconst a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  v = s @- sconst a\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (shd w) \\<Longrightarrow> thesis", "have 5: \"w = (u @ s) @- sconst a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = (u @ s) @- sconst a", "unfolding 1(1) 4"], ["proof (prove)\ngoal (1 subgoal):\n 1. u @- s @- sconst a = (u @ s) @- sconst a", "by simp"], ["proof (state)\nthis:\n  w = (u @ s) @- sconst a\n\ngoal (1 subgoal):\n 1. w \\<noteq> sconst (shd w) \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using less(2) 5"], ["proof (prove)\nusing this:\n  w = ?u @- sconst ?a \\<Longrightarrow> thesis\n  w = (u @ s) @- sconst a\n\ngoal (1 subgoal):\n 1. thesis", "by this"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}