{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Automata/NBA/NGBA_Refine.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma ngba_param[param]:\n    \"(ngba, ngba) \\<in> \\<langle>L\\<rangle> set_rel \\<rightarrow> \\<langle>S\\<rangle> set_rel \\<rightarrow> (L \\<rightarrow> S \\<rightarrow> \\<langle>S\\<rangle> set_rel) \\<rightarrow> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow>\n      \\<langle>L, S\\<rangle> ngba_rel\"\n    \"(alphabet, alphabet) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> \\<langle>L\\<rangle> set_rel\"\n    \"(initial, initial) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> \\<langle>S\\<rangle> set_rel\"\n    \"(transition, transition) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> L \\<rightarrow> S \\<rightarrow> \\<langle>S\\<rangle> set_rel\"\n    \"(accepting, accepting) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel\"", "lemma ngba_rel_id[simp]: \"\\<langle>Id, Id\\<rangle> ngba_rel = Id\"", "lemma enableds_param[param]: \"(ngba.enableds, ngba.enableds) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> S \\<rightarrow> \\<langle>L \\<times>\\<^sub>r S\\<rangle> set_rel\"", "lemma paths_param[param]: \"(ngba.paths, ngba.paths) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> S \\<rightarrow> \\<langle>\\<langle>L \\<times>\\<^sub>r S\\<rangle> list_rel\\<rangle> set_rel\"", "lemma runs_param[param]: \"(ngba.runs, ngba.runs) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> S \\<rightarrow> \\<langle>\\<langle>L \\<times>\\<^sub>r S\\<rangle> stream_rel\\<rangle> set_rel\"", "lemma reachable_param[param]: \"(reachable, reachable) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> S \\<rightarrow> \\<langle>S\\<rangle> set_rel\"", "lemma nodes_param[param]: \"(nodes, nodes) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> \\<langle>S\\<rangle> set_rel\"", "lemma gen_param[param]: \"(gen, gen) \\<in> (A \\<rightarrow> B \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>A\\<rangle> list_rel \\<rightarrow> B \\<rightarrow> bool_rel\"", "lemma language_param[param]: \"(language, language) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> \\<langle>\\<langle>L\\<rangle> stream_rel\\<rangle> set_rel\""], "translations": [["", "lemma ngba_param[param]:\n    \"(ngba, ngba) \\<in> \\<langle>L\\<rangle> set_rel \\<rightarrow> \\<langle>S\\<rangle> set_rel \\<rightarrow> (L \\<rightarrow> S \\<rightarrow> \\<langle>S\\<rangle> set_rel) \\<rightarrow> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow>\n      \\<langle>L, S\\<rangle> ngba_rel\"\n    \"(alphabet, alphabet) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> \\<langle>L\\<rangle> set_rel\"\n    \"(initial, initial) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> \\<langle>S\\<rangle> set_rel\"\n    \"(transition, transition) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> L \\<rightarrow> S \\<rightarrow> \\<langle>S\\<rangle> set_rel\"\n    \"(accepting, accepting) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ngba, ngba)\n     \\<in> \\<langle>L\\<rangle>set_rel \\<rightarrow>\n           \\<langle>S\\<rangle>set_rel \\<rightarrow>\n           (L \\<rightarrow>\n            S \\<rightarrow> \\<langle>S\\<rangle>set_rel) \\<rightarrow>\n           \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n           \\<langle>L, S\\<rangle>ngba_rel &&&\n     (alphabet, alphabet)\n     \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n           \\<langle>L\\<rangle>set_rel) &&&\n    (initial, initial)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          \\<langle>S\\<rangle>set_rel &&&\n    (transition, transition)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          L \\<rightarrow> S \\<rightarrow> \\<langle>S\\<rangle>set_rel &&&\n    (accepting, accepting)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel", "unfolding ngba_rel_def fun_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ngba, ngba)\n     \\<in> {(f, f').\n            \\<forall>(a, a')\\<in>\\<langle>L\\<rangle>set_rel.\n               (f a, f' a')\n               \\<in> {(f, f').\n                      \\<forall>(a, a')\\<in>\\<langle>S\\<rangle>set_rel.\n                         (f a, f' a')\n                         \\<in> {(f, f').\n                                \\<forall>(a, a')\n   \\<in>{(f, f').\n         \\<forall>(a, a')\\<in>L.\n            (f a, f' a')\n            \\<in> {(f, f').\n                   \\<forall>(a, a')\\<in>S.\n                      (f a, f' a') \\<in> \\<langle>S\\<rangle>set_rel}}.\n                                   (f a, f' a')\n                                   \\<in> {(f, f').\n    \\<forall>(a, a')\n             \\<in>\\<langle>{(f, f').\n                            \\<forall>(a, a')\\<in>S.\n                               (f a, f' a')\n                               \\<in> bool_rel}\\<rangle>list_rel.\n       (f a, f' a')\n       \\<in> {(A\\<^sub>1, A\\<^sub>2).\n              (alphabet A\\<^sub>1, alphabet A\\<^sub>2)\n              \\<in> \\<langle>L\\<rangle>set_rel \\<and>\n              (initial A\\<^sub>1, initial A\\<^sub>2)\n              \\<in> \\<langle>S\\<rangle>set_rel \\<and>\n              (transition A\\<^sub>1, transition A\\<^sub>2)\n              \\<in> {(f, f').\n                     \\<forall>(a, a')\\<in>L.\n                        (f a, f' a')\n                        \\<in> {(f, f').\n                               \\<forall>(a, a')\\<in>S.\n                                  (f a, f' a')\n                                  \\<in> \\<langle>S\\<rangle>set_rel}} \\<and>\n              (accepting A\\<^sub>1, accepting A\\<^sub>2)\n              \\<in> \\<langle>{(f, f').\n                              \\<forall>(a, a')\\<in>S.\n                                 (f a, f' a')\n                                 \\<in> bool_rel}\\<rangle>list_rel}}}}} &&&\n     (alphabet, alphabet)\n     \\<in> {(f, f').\n            \\<forall>(a, a')\n                     \\<in>{(A\\<^sub>1, A\\<^sub>2).\n                           (alphabet A\\<^sub>1, alphabet A\\<^sub>2)\n                           \\<in> \\<langle>L\\<rangle>set_rel \\<and>\n                           (initial A\\<^sub>1, initial A\\<^sub>2)\n                           \\<in> \\<langle>S\\<rangle>set_rel \\<and>\n                           (transition A\\<^sub>1, transition A\\<^sub>2)\n                           \\<in> {(f, f').\n                                  \\<forall>(a, a')\\<in>L.\n                                     (f a, f' a')\n                                     \\<in> {(f, f').\n      \\<forall>(a, a')\\<in>S.\n         (f a, f' a') \\<in> \\<langle>S\\<rangle>set_rel}} \\<and>\n                           (accepting A\\<^sub>1, accepting A\\<^sub>2)\n                           \\<in> \\<langle>{(f, f').\n     \\<forall>(a, a')\\<in>S. (f a, f' a') \\<in> bool_rel}\\<rangle>list_rel}.\n               (f a, f' a') \\<in> \\<langle>L\\<rangle>set_rel}) &&&\n    (initial, initial)\n    \\<in> {(f, f').\n           \\<forall>(a, a')\n                    \\<in>{(A\\<^sub>1, A\\<^sub>2).\n                          (alphabet A\\<^sub>1, alphabet A\\<^sub>2)\n                          \\<in> \\<langle>L\\<rangle>set_rel \\<and>\n                          (initial A\\<^sub>1, initial A\\<^sub>2)\n                          \\<in> \\<langle>S\\<rangle>set_rel \\<and>\n                          (transition A\\<^sub>1, transition A\\<^sub>2)\n                          \\<in> {(f, f').\n                                 \\<forall>(a, a')\\<in>L.\n                                    (f a, f' a')\n                                    \\<in> {(f, f').\n     \\<forall>(a, a')\\<in>S.\n        (f a, f' a') \\<in> \\<langle>S\\<rangle>set_rel}} \\<and>\n                          (accepting A\\<^sub>1, accepting A\\<^sub>2)\n                          \\<in> \\<langle>{(f, f').\n    \\<forall>(a, a')\\<in>S. (f a, f' a') \\<in> bool_rel}\\<rangle>list_rel}.\n              (f a, f' a') \\<in> \\<langle>S\\<rangle>set_rel} &&&\n    (transition, transition)\n    \\<in> {(f, f').\n           \\<forall>(a, a')\n                    \\<in>{(A\\<^sub>1, A\\<^sub>2).\n                          (alphabet A\\<^sub>1, alphabet A\\<^sub>2)\n                          \\<in> \\<langle>L\\<rangle>set_rel \\<and>\n                          (initial A\\<^sub>1, initial A\\<^sub>2)\n                          \\<in> \\<langle>S\\<rangle>set_rel \\<and>\n                          (transition A\\<^sub>1, transition A\\<^sub>2)\n                          \\<in> {(f, f').\n                                 \\<forall>(a, a')\\<in>L.\n                                    (f a, f' a')\n                                    \\<in> {(f, f').\n     \\<forall>(a, a')\\<in>S.\n        (f a, f' a') \\<in> \\<langle>S\\<rangle>set_rel}} \\<and>\n                          (accepting A\\<^sub>1, accepting A\\<^sub>2)\n                          \\<in> \\<langle>{(f, f').\n    \\<forall>(a, a')\\<in>S. (f a, f' a') \\<in> bool_rel}\\<rangle>list_rel}.\n              (f a, f' a')\n              \\<in> {(f, f').\n                     \\<forall>(a, a')\\<in>L.\n                        (f a, f' a')\n                        \\<in> {(f, f').\n                               \\<forall>(a, a')\\<in>S.\n                                  (f a, f' a')\n                                  \\<in> \\<langle>S\\<rangle>set_rel}}} &&&\n    (accepting, accepting)\n    \\<in> {(f, f').\n           \\<forall>(a, a')\n                    \\<in>{(A\\<^sub>1, A\\<^sub>2).\n                          (alphabet A\\<^sub>1, alphabet A\\<^sub>2)\n                          \\<in> \\<langle>L\\<rangle>set_rel \\<and>\n                          (initial A\\<^sub>1, initial A\\<^sub>2)\n                          \\<in> \\<langle>S\\<rangle>set_rel \\<and>\n                          (transition A\\<^sub>1, transition A\\<^sub>2)\n                          \\<in> {(f, f').\n                                 \\<forall>(a, a')\\<in>L.\n                                    (f a, f' a')\n                                    \\<in> {(f, f').\n     \\<forall>(a, a')\\<in>S.\n        (f a, f' a') \\<in> \\<langle>S\\<rangle>set_rel}} \\<and>\n                          (accepting A\\<^sub>1, accepting A\\<^sub>2)\n                          \\<in> \\<langle>{(f, f').\n    \\<forall>(a, a')\\<in>S. (f a, f' a') \\<in> bool_rel}\\<rangle>list_rel}.\n              (f a, f' a')\n              \\<in> \\<langle>{(f, f').\n                              \\<forall>(a, a')\\<in>S.\n                                 (f a, f' a')\n                                 \\<in> bool_rel}\\<rangle>list_rel}", "by auto"], ["", "lemma ngba_rel_id[simp]: \"\\<langle>Id, Id\\<rangle> ngba_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id, Id\\<rangle>ngba_rel = Id", "unfolding ngba_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(A\\<^sub>1, A\\<^sub>2).\n     (alphabet A\\<^sub>1, alphabet A\\<^sub>2)\n     \\<in> \\<langle>Id\\<rangle>set_rel \\<and>\n     (initial A\\<^sub>1, initial A\\<^sub>2)\n     \\<in> \\<langle>Id\\<rangle>set_rel \\<and>\n     (transition A\\<^sub>1, transition A\\<^sub>2)\n     \\<in> Id \\<rightarrow>\n           Id \\<rightarrow> \\<langle>Id\\<rangle>set_rel \\<and>\n     (accepting A\\<^sub>1, accepting A\\<^sub>2)\n     \\<in> \\<langle>Id \\<rightarrow> bool_rel\\<rangle>list_rel} =\n    Id", "using ngba.expand"], ["proof (prove)\nusing this:\n  alphabet ?ngba = alphabet ?ngba' \\<and>\n  initial ?ngba = initial ?ngba' \\<and>\n  transition ?ngba = transition ?ngba' \\<and>\n  accepting ?ngba = accepting ?ngba' \\<Longrightarrow>\n  ?ngba = ?ngba'\n\ngoal (1 subgoal):\n 1. {(A\\<^sub>1, A\\<^sub>2).\n     (alphabet A\\<^sub>1, alphabet A\\<^sub>2)\n     \\<in> \\<langle>Id\\<rangle>set_rel \\<and>\n     (initial A\\<^sub>1, initial A\\<^sub>2)\n     \\<in> \\<langle>Id\\<rangle>set_rel \\<and>\n     (transition A\\<^sub>1, transition A\\<^sub>2)\n     \\<in> Id \\<rightarrow>\n           Id \\<rightarrow> \\<langle>Id\\<rangle>set_rel \\<and>\n     (accepting A\\<^sub>1, accepting A\\<^sub>2)\n     \\<in> \\<langle>Id \\<rightarrow> bool_rel\\<rangle>list_rel} =\n    Id", "by auto"], ["", "lemma enableds_param[param]: \"(ngba.enableds, ngba.enableds) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> S \\<rightarrow> \\<langle>L \\<times>\\<^sub>r S\\<rangle> set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ngba.enableds, ngba.enableds)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>L \\<times>\\<^sub>r S\\<rangle>set_rel", "using ngba_param(2, 4)"], ["proof (prove)\nusing this:\n  (alphabet, alphabet)\n  \\<in> \\<langle>?L, ?S\\<rangle>ngba_rel \\<rightarrow>\n        \\<langle>?L\\<rangle>set_rel\n  (transition, transition)\n  \\<in> \\<langle>?L, ?S\\<rangle>ngba_rel \\<rightarrow>\n        ?L \\<rightarrow> ?S \\<rightarrow> \\<langle>?S\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. (ngba.enableds, ngba.enableds)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>L \\<times>\\<^sub>r S\\<rangle>set_rel", "unfolding ngba.enableds_def fun_rel_def set_rel_def"], ["proof (prove)\nusing this:\n  (alphabet, alphabet)\n  \\<in> {(f, f').\n         \\<forall>(a, a')\\<in>\\<langle>?L, ?S\\<rangle>ngba_rel.\n            (f a, f' a')\n            \\<in> {(A, B).\n                   (\\<forall>x\\<in>A.\n                       \\<exists>y\\<in>B. (x, y) \\<in> ?L) \\<and>\n                   (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> ?L)}}\n  (transition, transition)\n  \\<in> {(f, f').\n         \\<forall>(a, a')\\<in>\\<langle>?L, ?S\\<rangle>ngba_rel.\n            (f a, f' a')\n            \\<in> {(f, f').\n                   \\<forall>(a, a')\\<in>?L.\n                      (f a, f' a')\n                      \\<in> {(f, f').\n                             \\<forall>(a, a')\\<in>?S.\n                                (f a, f' a')\n                                \\<in> {(A, B).\n (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> ?S) \\<and>\n (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> ?S)}}}}\n\ngoal (1 subgoal):\n 1. (\\<lambda>A p.\n        {a. fst a \\<in> alphabet A \\<and>\n            snd a \\<in> transition A (fst a) p},\n     \\<lambda>A p.\n        {a. fst a \\<in> alphabet A \\<and>\n            snd a \\<in> transition A (fst a) p})\n    \\<in> {(f, f').\n           \\<forall>(a, a')\\<in>\\<langle>L, S\\<rangle>ngba_rel.\n              (f a, f' a')\n              \\<in> {(f, f').\n                     \\<forall>(a, a')\\<in>S.\n                        (f a, f' a')\n                        \\<in> {(A, B).\n                               (\\<forall>x\\<in>A.\n                                   \\<exists>y\\<in>B.\n(x, y) \\<in> L \\<times>\\<^sub>r S) \\<and>\n                               (\\<forall>y\\<in>B.\n                                   \\<exists>x\\<in>A.\n(x, y) \\<in> L \\<times>\\<^sub>r S)}}}", "by fastforce"], ["", "lemma paths_param[param]: \"(ngba.paths, ngba.paths) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> S \\<rightarrow> \\<langle>\\<langle>L \\<times>\\<^sub>r S\\<rangle> list_rel\\<rangle> set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ngba.paths, ngba.paths)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow>\n          \\<langle>\\<langle>L \\<times>\\<^sub>r\n                            S\\<rangle>list_rel\\<rangle>set_rel", "using enableds_param[param_fo]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x1, ?x'1) \\<in> \\<langle>?L2, ?A\\<rangle>ngba_rel;\n   (?x, ?x') \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (ngba.enableds ?x1 ?x, ngba.enableds ?x'1 ?x')\n                    \\<in> \\<langle>?L2 \\<times>\\<^sub>r ?A\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. (ngba.paths, ngba.paths)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow>\n          \\<langle>\\<langle>L \\<times>\\<^sub>r\n                            S\\<rangle>list_rel\\<rangle>set_rel", "by parametricity"], ["", "lemma runs_param[param]: \"(ngba.runs, ngba.runs) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> S \\<rightarrow> \\<langle>\\<langle>L \\<times>\\<^sub>r S\\<rangle> stream_rel\\<rangle> set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ngba.runs, ngba.runs)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow>\n          \\<langle>\\<langle>L \\<times>\\<^sub>r\n                            S\\<rangle>stream_rel\\<rangle>set_rel", "using enableds_param[param_fo]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x1, ?x'1) \\<in> \\<langle>?L2, ?A\\<rangle>ngba_rel;\n   (?x, ?x') \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (ngba.enableds ?x1 ?x, ngba.enableds ?x'1 ?x')\n                    \\<in> \\<langle>?L2 \\<times>\\<^sub>r ?A\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. (ngba.runs, ngba.runs)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow>\n          \\<langle>\\<langle>L \\<times>\\<^sub>r\n                            S\\<rangle>stream_rel\\<rangle>set_rel", "by parametricity"], ["", "lemma reachable_param[param]: \"(reachable, reachable) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> S \\<rightarrow> \\<langle>S\\<rangle> set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (reachable, reachable)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>S\\<rangle>set_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (reachable, reachable)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>S\\<rangle>set_rel", "have 1: \"reachable A p = (\\<lambda> wr. target wr p) ` ngba.paths A p\" for A :: \"('label, 'state) ngba\" and p"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable A p = (\\<lambda>wr. target wr p) ` ngba.paths A p", "unfolding ngba.reachable_alt_def ngba.paths_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {target r p |r. path A r p} =\n    (\\<lambda>wr. target wr p) ` {r. path A r p}", "by auto"], ["proof (state)\nthis:\n  reachable ?A1 ?p1 = (\\<lambda>wr. target wr ?p1) ` ngba.paths ?A1 ?p1\n\ngoal (1 subgoal):\n 1. (reachable, reachable)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>S\\<rangle>set_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (reachable, reachable)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>S\\<rangle>set_rel", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A p. (\\<lambda>wr. target wr p) ` ngba.paths A p,\n     \\<lambda>A p. (\\<lambda>wr. target wr p) ` ngba.paths A p)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>S\\<rangle>set_rel", "using enableds_param[param_fo]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x1, ?x'1) \\<in> \\<langle>?L2, ?A\\<rangle>ngba_rel;\n   (?x, ?x') \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (ngba.enableds ?x1 ?x, ngba.enableds ?x'1 ?x')\n                    \\<in> \\<langle>?L2 \\<times>\\<^sub>r ?A\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. (\\<lambda>A p. (\\<lambda>wr. target wr p) ` ngba.paths A p,\n     \\<lambda>A p. (\\<lambda>wr. target wr p) ` ngba.paths A p)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>S\\<rangle>set_rel", "by parametricity"], ["proof (state)\nthis:\n  (reachable, reachable)\n  \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n        S \\<rightarrow> \\<langle>S\\<rangle>set_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nodes_param[param]: \"(nodes, nodes) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> \\<langle>S\\<rangle> set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nodes, nodes)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          \\<langle>S\\<rangle>set_rel", "unfolding ngba.nodes_alt_def Collect_mem_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. \\<Union> (reachable A ` initial A),\n     \\<lambda>A. \\<Union> (reachable A ` initial A))\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          \\<langle>S\\<rangle>set_rel", "by parametricity"], ["", "(* TODO: move *)"], ["", "lemma gen_param[param]: \"(gen, gen) \\<in> (A \\<rightarrow> B \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>A\\<rangle> list_rel \\<rightarrow> B \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen, gen)\n    \\<in> (A \\<rightarrow> B \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel \\<rightarrow> B \\<rightarrow> bool_rel", "unfolding gen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>P cs w. \\<forall>c\\<in>set cs. P c w,\n     \\<lambda>P cs w. \\<forall>c\\<in>set cs. P c w)\n    \\<in> (A \\<rightarrow> B \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel \\<rightarrow> B \\<rightarrow> bool_rel", "by parametricity"], ["", "lemma language_param[param]: \"(language, language) \\<in> \\<langle>L, S\\<rangle> ngba_rel \\<rightarrow> \\<langle>\\<langle>L\\<rangle> stream_rel\\<rangle> set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (language, language)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          \\<langle>\\<langle>L\\<rangle>stream_rel\\<rangle>set_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (language, language)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          \\<langle>\\<langle>L\\<rangle>stream_rel\\<rangle>set_rel", "have 1: \"language A = (\\<Union> p \\<in> initial A. \\<Union> wr \\<in> ngba.runs A p.\n      if gen infs (accepting A) (p ## smap snd wr) then {smap fst wr} else {})\"\n      for A :: \"('label, 'state) ngba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language A =\n    (\\<Union>p\\<in>initial A.\n        \\<Union>wr\\<in>ngba.runs A p.\n           if gen infs (accepting A) (p ## smap snd wr) then {smap fst wr}\n           else {})", "unfolding ngba.language_def ngba.runs_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>w r p.\n        uu_ = w \\<and>\n        p \\<in> initial A \\<and>\n        run A (w ||| r) p \\<and> gen infs (accepting A) (p ## r)} =\n    \\<Union>\n     {y. \\<exists>x\\<in>initial A.\n            y =\n            \\<Union>\n             {y. \\<exists>xa\\<in>{r. run A r x}.\n                    y =\n                    (if gen infs (accepting A) (x ## smap snd xa)\n                     then {smap fst xa} else {})}}", "by (auto iff: split_szip_ex simp del: alw_smap)"], ["proof (state)\nthis:\n  language ?A1 =\n  (\\<Union>p\\<in>initial ?A1.\n      \\<Union>wr\\<in>ngba.runs ?A1 p.\n         if gen infs (accepting ?A1) (p ## smap snd wr) then {smap fst wr}\n         else {})\n\ngoal (1 subgoal):\n 1. (language, language)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          \\<langle>\\<langle>L\\<rangle>stream_rel\\<rangle>set_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (language, language)\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          \\<langle>\\<langle>L\\<rangle>stream_rel\\<rangle>set_rel", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A.\n        \\<Union>p\\<in>initial A.\n           \\<Union>wr\\<in>ngba.runs A p.\n              if gen infs (accepting A) (p ## smap snd wr)\n              then {smap fst wr} else {},\n     \\<lambda>A.\n        \\<Union>p\\<in>initial A.\n           \\<Union>wr\\<in>ngba.runs A p.\n              if gen infs (accepting A) (p ## smap snd wr)\n              then {smap fst wr} else {})\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          \\<langle>\\<langle>L\\<rangle>stream_rel\\<rangle>set_rel", "using enableds_param[param_fo]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x1, ?x'1) \\<in> \\<langle>?L2, ?A\\<rangle>ngba_rel;\n   (?x, ?x') \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> (ngba.enableds ?x1 ?x, ngba.enableds ?x'1 ?x')\n                    \\<in> \\<langle>?L2 \\<times>\\<^sub>r ?A\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. (\\<lambda>A.\n        \\<Union>p\\<in>initial A.\n           \\<Union>wr\\<in>ngba.runs A p.\n              if gen infs (accepting A) (p ## smap snd wr)\n              then {smap fst wr} else {},\n     \\<lambda>A.\n        \\<Union>p\\<in>initial A.\n           \\<Union>wr\\<in>ngba.runs A p.\n              if gen infs (accepting A) (p ## smap snd wr)\n              then {smap fst wr} else {})\n    \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n          \\<langle>\\<langle>L\\<rangle>stream_rel\\<rangle>set_rel", "by parametricity"], ["proof (state)\nthis:\n  (language, language)\n  \\<in> \\<langle>L, S\\<rangle>ngba_rel \\<rightarrow>\n        \\<langle>\\<langle>L\\<rangle>stream_rel\\<rangle>set_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}