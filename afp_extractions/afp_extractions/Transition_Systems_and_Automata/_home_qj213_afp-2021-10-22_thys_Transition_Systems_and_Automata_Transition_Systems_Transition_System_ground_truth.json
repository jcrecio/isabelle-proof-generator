{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Transition_Systems/Transition_System.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma target_alt_def: \"target r p = last (p # states r p)\"", "lemma path_append[intro!]:\n      assumes \"path r p\" \"path s (target r p)\"\n      shows \"path (r @ s) p\"", "lemma path_append_elim[elim!]:\n      assumes \"path (r @ s) p\"\n      obtains \"path r p\" \"path s (target r p)\"", "lemma run_shift[intro!]:\n      assumes \"path r p\" \"run s (target r p)\"\n      shows \"run (r @- s) p\"", "lemma run_shift_elim[elim!]:\n      assumes \"run (r @- s) p\"\n      obtains \"path r p\" \"run s (target r p)\"", "lemma run_coinduct[case_names run, coinduct pred: run]:\n      assumes \"R r p\"\n      assumes \"\\<And> a r p. R (a ## r) p \\<Longrightarrow> enabled a p \\<and> R r (execute a p)\"\n      shows \"run r p\"", "lemma run_coinduct_shift[case_names run, consumes 1]:\n      assumes \"R r p\"\n      assumes \"\\<And> r p. R r p \\<Longrightarrow> \\<exists> s t. r = s @- t \\<and> s \\<noteq> [] \\<and> path s p \\<and> R t (target s p)\"\n      shows \"run r p\"", "lemma run_flat_coinduct[case_names run, consumes 1]:\n      assumes \"R rs p\"\n      assumes \"\\<And> r rs p. R (r ## rs) p \\<Longrightarrow> r \\<noteq> [] \\<and> path r p \\<and> R rs (target r p)\"\n      shows \"run (flat rs) p\"", "lemma reachable_execute'[intro]:\n      assumes \"enabled a p\" \"q \\<in> reachable (execute a p)\"\n      shows \"q \\<in> reachable p\"", "lemma reachable_elim'[elim]:\n      assumes \"q \\<in> reachable p\"\n      obtains \"q = p\" | a where \"enabled a p\" \"q \\<in> reachable (execute a p)\"", "lemma reachable_target[intro]:\n      assumes \"q \\<in> reachable p\" \"path r q\"\n      shows \"target r q \\<in> reachable p\"", "lemma reachable_target_elim[elim]:\n      assumes \"q \\<in> reachable p\"\n      obtains r\n      where \"path r p\" \"q = target r p\"", "lemma reachable_alt_def: \"reachable p = {target r p |r. path r p}\"", "lemma reachable_trans[trans]: \"q \\<in> reachable p \\<Longrightarrow> s \\<in> reachable q \\<Longrightarrow> s \\<in> reachable p\"", "lemma reachable_successors[intro!]: \"successors p \\<subseteq> reachable p\"", "lemma reachable_step: \"reachable p = insert p (\\<Union> (reachable ` successors p))\"", "lemma nodes_target[intro]:\n      assumes \"p \\<in> nodes\" \"path r p\"\n      shows \"target r p \\<in> nodes\"", "lemma nodes_target_elim[elim]:\n      assumes \"q \\<in> nodes\"\n      obtains r p\n      where \"initial p\" \"path r p\" \"q = target r p\"", "lemma nodes_alt_def: \"nodes = \\<Union> (reachable ` Collect initial)\"", "lemma nodes_trans[trans]: \"p \\<in> nodes \\<Longrightarrow> q \\<in> reachable p \\<Longrightarrow> q \\<in> nodes\""], "translations": [["", "lemma target_alt_def: \"target r p = last (p # states r p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target r p = last (p # states r p)", "using scan_last"], ["proof (prove)\nusing this:\n  last (?a # scan ?f ?xs ?a) = fold ?f ?xs ?a\n\ngoal (1 subgoal):\n 1. target r p = last (p # states r p)", "by rule"], ["", "end"], ["", "subsection \\<open>Transition Systems\\<close>"], ["", "locale transition_system =\n    transition_system_universal execute\n    for execute :: \"'transition \\<Rightarrow> 'state \\<Rightarrow> 'state\"\n    +\n    fixes enabled :: \"'transition \\<Rightarrow> 'state \\<Rightarrow> bool\"\n  begin"], ["", "abbreviation \"successors p \\<equiv> {execute a p |a. enabled a p}\""], ["", "inductive path :: \"'transition list \\<Rightarrow> 'state \\<Rightarrow> bool\" where\n      nil[intro!]: \"path [] p\" |\n      cons[intro!]: \"enabled a p \\<Longrightarrow> path r (execute a p) \\<Longrightarrow> path (a # r) p\""], ["", "inductive_cases path_cons_elim[elim!]: \"path (a # r) p\""], ["", "lemma path_append[intro!]:\n      assumes \"path r p\" \"path s (target r p)\"\n      shows \"path (r @ s) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (r @ s) p", "using assms"], ["proof (prove)\nusing this:\n  path r p\n  path s (target r p)\n\ngoal (1 subgoal):\n 1. path (r @ s) p", "by (induct r arbitrary: p) (auto)"], ["", "lemma path_append_elim[elim!]:\n      assumes \"path (r @ s) p\"\n      obtains \"path r p\" \"path s (target r p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>path r p; path s (target r p)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  path (r @ s) p\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>path r p; path s (target r p)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (induct r arbitrary: p) (auto)"], ["", "coinductive run :: \"'transition stream \\<Rightarrow> 'state \\<Rightarrow> bool\" where\n      scons[intro!]: \"enabled a p \\<Longrightarrow> run r (execute a p) \\<Longrightarrow> run (a ## r) p\""], ["", "inductive_cases run_scons_elim[elim!]: \"run (a ## r) p\""], ["", "lemma run_shift[intro!]:\n      assumes \"path r p\" \"run s (target r p)\"\n      shows \"run (r @- s) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run (r @- s) p", "using assms"], ["proof (prove)\nusing this:\n  path r p\n  run s (target r p)\n\ngoal (1 subgoal):\n 1. run (r @- s) p", "by (induct r arbitrary: p) (auto)"], ["", "lemma run_shift_elim[elim!]:\n      assumes \"run (r @- s) p\"\n      obtains \"path r p\" \"run s (target r p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>path r p; run s (target r p)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  run (r @- s) p\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>path r p; run s (target r p)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (induct r arbitrary: p) (auto)"], ["", "lemma run_coinduct[case_names run, coinduct pred: run]:\n      assumes \"R r p\"\n      assumes \"\\<And> a r p. R (a ## r) p \\<Longrightarrow> enabled a p \\<and> R r (execute a p)\"\n      shows \"run r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run r p", "using stream.collapse run.coinduct assms"], ["proof (prove)\nusing this:\n  shd ?stream ## stl ?stream = ?stream\n  \\<lbrakk>?X ?x1.0 ?x2.0;\n   \\<And>x1 x2.\n      ?X x1 x2 \\<Longrightarrow>\n      \\<exists>a p r.\n         x1 = a ## r \\<and>\n         x2 = p \\<and>\n         enabled a p \\<and>\n         (?X r (execute a p) \\<or> run r (execute a p))\\<rbrakk>\n  \\<Longrightarrow> run ?x1.0 ?x2.0\n  R r p\n  R (?a ## ?r) ?p \\<Longrightarrow>\n  enabled ?a ?p \\<and> R ?r (execute ?a ?p)\n\ngoal (1 subgoal):\n 1. run r p", "by metis"], ["", "lemma run_coinduct_shift[case_names run, consumes 1]:\n      assumes \"R r p\"\n      assumes \"\\<And> r p. R r p \\<Longrightarrow> \\<exists> s t. r = s @- t \\<and> s \\<noteq> [] \\<and> path s p \\<and> R t (target s p)\"\n      shows \"run r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run r p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. run r p", "have \"\\<exists> s t. r = s @- t \\<and> path s p \\<and> R t (target s p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s t. r = s @- t \\<and> path s p \\<and> R t (target s p)", "using assms(1)"], ["proof (prove)\nusing this:\n  R r p\n\ngoal (1 subgoal):\n 1. \\<exists>s t. r = s @- t \\<and> path s p \\<and> R t (target s p)", "by force"], ["proof (state)\nthis:\n  \\<exists>s t. r = s @- t \\<and> path s p \\<and> R t (target s p)\n\ngoal (1 subgoal):\n 1. run r p", "then"], ["proof (chain)\npicking this:\n  \\<exists>s t. r = s @- t \\<and> path s p \\<and> R t (target s p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>s t. r = s @- t \\<and> path s p \\<and> R t (target s p)\n\ngoal (1 subgoal):\n 1. run r p", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<exists>s t. r = s @- t \\<and> path s p \\<and> R t (target s p)\n  R ?r ?p \\<Longrightarrow>\n  \\<exists>s t.\n     ?r = s @- t \\<and>\n     s \\<noteq> [] \\<and> path s ?p \\<and> R t (target s ?p)\n\ngoal (1 subgoal):\n 1. run r p", "by (coinduct) (force elim: path.cases)"], ["proof (state)\nthis:\n  run r p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma run_flat_coinduct[case_names run, consumes 1]:\n      assumes \"R rs p\"\n      assumes \"\\<And> r rs p. R (r ## rs) p \\<Longrightarrow> r \\<noteq> [] \\<and> path r p \\<and> R rs (target r p)\"\n      shows \"run (flat rs) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run (flat rs) p", "using assms(1)"], ["proof (prove)\nusing this:\n  R rs p\n\ngoal (1 subgoal):\n 1. run (flat rs) p", "proof (coinduction arbitrary: rs p rule: run_coinduct_shift)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rs pa.\n       R rs pa \\<Longrightarrow>\n       \\<exists>s t.\n          flat rs = s @- t \\<and>\n          s \\<noteq> [] \\<and>\n          path s pa \\<and>\n          (\\<exists>rs p. t = flat rs \\<and> target s pa = p \\<and> R rs p)", "case (run rs p)"], ["proof (state)\nthis:\n  R rs p\n\ngoal (1 subgoal):\n 1. \\<And>rs pa.\n       R rs pa \\<Longrightarrow>\n       \\<exists>s t.\n          flat rs = s @- t \\<and>\n          s \\<noteq> [] \\<and>\n          path s pa \\<and>\n          (\\<exists>rs p. t = flat rs \\<and> target s pa = p \\<and> R rs p)", "then"], ["proof (chain)\npicking this:\n  R rs p", "show ?case"], ["proof (prove)\nusing this:\n  R rs p\n\ngoal (1 subgoal):\n 1. \\<exists>s t.\n       flat rs = s @- t \\<and>\n       s \\<noteq> [] \\<and>\n       path s p \\<and>\n       (\\<exists>rs p. t = flat rs \\<and> target s p = p \\<and> R rs p)", "using assms(2)"], ["proof (prove)\nusing this:\n  R rs p\n  R (?r ## ?rs) ?p \\<Longrightarrow>\n  ?r \\<noteq> [] \\<and> path ?r ?p \\<and> R ?rs (target ?r ?p)\n\ngoal (1 subgoal):\n 1. \\<exists>s t.\n       flat rs = s @- t \\<and>\n       s \\<noteq> [] \\<and>\n       path s p \\<and>\n       (\\<exists>rs p. t = flat rs \\<and> target s p = p \\<and> R rs p)", "by (metis stream.exhaust flat_Stream)"], ["proof (state)\nthis:\n  \\<exists>s t.\n     flat rs = s @- t \\<and>\n     s \\<noteq> [] \\<and>\n     path s p \\<and>\n     (\\<exists>rs p. t = flat rs \\<and> target s p = p \\<and> R rs p)\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive_set reachable :: \"'state \\<Rightarrow> 'state set\" for p where\n      reflexive[intro!]: \"p \\<in> reachable p\" |\n      execute[intro!]: \"q \\<in> reachable p \\<Longrightarrow> enabled a q \\<Longrightarrow> execute a q \\<in> reachable p\""], ["", "inductive_cases reachable_elim[elim]: \"q \\<in> reachable p\""], ["", "lemma reachable_execute'[intro]:\n      assumes \"enabled a p\" \"q \\<in> reachable (execute a p)\"\n      shows \"q \\<in> reachable p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> reachable p", "using assms(2, 1)"], ["proof (prove)\nusing this:\n  q \\<in> reachable (execute a p)\n  enabled a p\n\ngoal (1 subgoal):\n 1. q \\<in> reachable p", "by induct auto"], ["", "lemma reachable_elim'[elim]:\n      assumes \"q \\<in> reachable p\"\n      obtains \"q = p\" | a where \"enabled a p\" \"q \\<in> reachable (execute a p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q = p \\<Longrightarrow> thesis;\n     \\<And>a.\n        \\<lbrakk>enabled a p; q \\<in> reachable (execute a p)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> reachable p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q = p \\<Longrightarrow> thesis;\n     \\<And>a.\n        \\<lbrakk>enabled a p; q \\<in> reachable (execute a p)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by induct auto"], ["", "lemma reachable_target[intro]:\n      assumes \"q \\<in> reachable p\" \"path r q\"\n      shows \"target r q \\<in> reachable p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target r q \\<in> reachable p", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> reachable p\n  path r q\n\ngoal (1 subgoal):\n 1. target r q \\<in> reachable p", "by (induct r arbitrary: q) (auto)"], ["", "lemma reachable_target_elim[elim]:\n      assumes \"q \\<in> reachable p\"\n      obtains r\n      where \"path r p\" \"q = target r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>path r p; q = target r p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> reachable p\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>path r p; q = target r p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by induct force+"], ["", "lemma reachable_alt_def: \"reachable p = {target r p |r. path r p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable p = {target r p |r. path r p}", "by auto"], ["", "lemma reachable_trans[trans]: \"q \\<in> reachable p \\<Longrightarrow> s \\<in> reachable q \\<Longrightarrow> s \\<in> reachable p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> reachable p; s \\<in> reachable q\\<rbrakk>\n    \\<Longrightarrow> s \\<in> reachable p", "by auto"], ["", "lemma reachable_successors[intro!]: \"successors p \\<subseteq> reachable p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. successors p \\<subseteq> reachable p", "by auto"], ["", "lemma reachable_step: \"reachable p = insert p (\\<Union> (reachable ` successors p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable p = insert p (\\<Union> (reachable ` successors p))", "by auto"], ["", "end"], ["", "subsection \\<open>Transition Systems with Initial States\\<close>"], ["", "locale transition_system_initial =\n    transition_system execute enabled\n    for execute :: \"'transition \\<Rightarrow> 'state \\<Rightarrow> 'state\"\n    and enabled :: \"'transition \\<Rightarrow> 'state \\<Rightarrow> bool\"\n    +\n    fixes initial :: \"'state \\<Rightarrow> bool\"\n  begin"], ["", "inductive_set nodes :: \"'state set\" where\n      initial[intro]: \"initial p \\<Longrightarrow> p \\<in> nodes\" |\n      execute[intro!]: \"p \\<in> nodes \\<Longrightarrow> enabled a p \\<Longrightarrow> execute a p \\<in> nodes\""], ["", "lemma nodes_target[intro]:\n      assumes \"p \\<in> nodes\" \"path r p\"\n      shows \"target r p \\<in> nodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target r p \\<in> nodes", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> nodes\n  path r p\n\ngoal (1 subgoal):\n 1. target r p \\<in> nodes", "by (induct r arbitrary: p) (auto)"], ["", "lemma nodes_target_elim[elim]:\n      assumes \"q \\<in> nodes\"\n      obtains r p\n      where \"initial p\" \"path r p\" \"q = target r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p r.\n        \\<lbrakk>initial p; path r p; q = target r p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> nodes\n\ngoal (1 subgoal):\n 1. (\\<And>p r.\n        \\<lbrakk>initial p; path r p; q = target r p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by induct force+"], ["", "lemma nodes_alt_def: \"nodes = \\<Union> (reachable ` Collect initial)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes = \\<Union> (reachable ` Collect initial)", "by auto"], ["", "lemma nodes_trans[trans]: \"p \\<in> nodes \\<Longrightarrow> q \\<in> reachable p \\<Longrightarrow> q \\<in> nodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> nodes; q \\<in> reachable p\\<rbrakk>\n    \\<Longrightarrow> q \\<in> nodes", "by auto"], ["", "end"], ["", "end"]]}