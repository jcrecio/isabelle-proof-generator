{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Nodes.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma dra_G_graph[simp]: \"graph (dra_G A)\"", "lemma dra_G_reachable_nodes: \"op_reachable (dra_G A) = nodes A\"", "lemma dra_G_ahs: \"dra_G A = \\<lparr> g_V = UNIV, g_E = E_of_succ (\\<lambda> p. CAST\n      ((\\<lambda> a. transition A a p ::: S) ` alphabet A ::: \\<langle>S\\<rangle> ahs_rel bhc)), g_V0 = {initial A} \\<rparr>\"", "lemma drai_Gi_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      shows \"(DRA_Nodes.drai_Gi seq bhc hms, dra_G) \\<in> \\<langle>L, S\\<rangle> drai_dra_rel \\<rightarrow> \\<langle>unit_rel, S\\<rangle> g_impl_rel_ext\"", "lemma dra_nodes_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> drai_dra_rel\"\n      shows \"(DRA_Nodes.dra_nodes seq bhc hms Ai,\n        (OP nodes ::: \\<langle>L, S\\<rangle> drai_dra_rel \\<rightarrow> \\<langle>S\\<rangle> ahs_rel bhc) $ A) \\<in> \\<langle>S\\<rangle> ahs_rel bhc\""], "translations": [["", "lemma dra_G_graph[simp]: \"graph (dra_G A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph (dra_G A)", "unfolding dra_G_def graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. g_V0\n     \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n        g_V0 = {initial A}\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n                       g_V0 = {initial A}\\<rparr> \\<and>\n    g_E \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n           g_V0 = {initial A}\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n                       g_V0 = {initial A}\\<rparr> \\<times>\n                g_V \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n                       g_V0 = {initial A}\\<rparr>", "by simp"], ["", "lemma dra_G_reachable_nodes: \"op_reachable (dra_G A) = nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_reachable (dra_G A) = nodes A", "unfolding op_reachable_def dra_G_def graph_rec.simps E_of_succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v). v \\<in> successors A u}\\<^sup>* `` {initial A} = nodes A", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       (initial A, x)\n       \\<in> {(u, v). v \\<in> successors A u}\\<^sup>* \\<Longrightarrow>\n       x \\<in> nodes A\n 2. \\<And>x.\n       x \\<in> nodes A \\<Longrightarrow>\n       (initial A, x) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>*", "show \"p \\<in> nodes A\" if \"(initial A, p) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>*\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> nodes A", "using that"], ["proof (prove)\nusing this:\n  (initial A, p) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>*\n\ngoal (1 subgoal):\n 1. p \\<in> nodes A", "by induct auto"], ["proof (state)\nthis:\n  (initial A, ?p)\n  \\<in> {(u, v). v \\<in> successors A u}\\<^sup>* \\<Longrightarrow>\n  ?p \\<in> nodes A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> nodes A \\<Longrightarrow>\n       (initial A, x) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>*", "show \"(initial A, p) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>*\" if \"p \\<in> nodes A\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. (initial A, p) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>*", "using that"], ["proof (prove)\nusing this:\n  p \\<in> nodes A\n\ngoal (1 subgoal):\n 1. (initial A, p) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>*", "by (induct) (auto intro: rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  ?p \\<in> nodes A \\<Longrightarrow>\n  (initial A, ?p) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "by this"], ["", "lemma dra_G_ahs: \"dra_G A = \\<lparr> g_V = UNIV, g_E = E_of_succ (\\<lambda> p. CAST\n      ((\\<lambda> a. transition A a p ::: S) ` alphabet A ::: \\<langle>S\\<rangle> ahs_rel bhc)), g_V0 = {initial A} \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dra_G A =\n    \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ\n          (\\<lambda>p.\n              CAST\n               ((\\<lambda>a. transition A a p ::: S) ` alphabet A :::\n                \\<langle>S\\<rangle>ahs_rel bhc)),\n       g_V0 = {initial A}\\<rparr>", "unfolding dra_G_def CAST_def id_apply E_of_succ_def autoref_tag_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>g_V = UNIV, g_E = {(u, v). v \\<in> successors A u},\n       g_V0 = {initial A}\\<rparr> =\n    \\<lparr>g_V = UNIV,\n       g_E = {(u, v). v \\<in> (\\<lambda>a. transition A a u) ` alphabet A},\n       g_V0 = {initial A}\\<rparr>", "by auto"], ["", "schematic_goal drai_Gi:\n      notes map2set_to_list[autoref_ga_rules]\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhc\"\n      assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n      assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n      assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> drai_dra_rel\"\n      shows \"(?f :: ?'a, RETURN (dra_G A)) \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, RETURN (dra_G A)) \\<in> ?A", "unfolding dra_G_ahs[where S = S and bhc = bhc]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     RETURN\n      \\<lparr>g_V = UNIV,\n         g_E =\n           E_of_succ\n            (\\<lambda>p.\n                CAST\n                 ((\\<lambda>a. transition A a p ::: S) ` alphabet A :::\n                  \\<langle>S\\<rangle>ahs_rel bhc)),\n         g_V0 = {initial A}\\<rparr>)\n    \\<in> ?A", "by (autoref_monadic (plain))"], ["", "concrete_definition drai_Gi uses drai_Gi"], ["", "(* TODO: why are term local.drai_Gi and term BA_Nodes.drai_Gi not the same *)"], ["", "lemma drai_Gi_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      shows \"(DRA_Nodes.drai_Gi seq bhc hms, dra_G) \\<in> \\<langle>L, S\\<rangle> drai_dra_rel \\<rightarrow> \\<langle>unit_rel, S\\<rangle> g_impl_rel_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (DRA_Nodes.drai_Gi seq bhc hms, dra_G)\n    \\<in> \\<langle>L, S\\<rangle>drai_dra_rel \\<rightarrow>\n          \\<langle>unit_rel, S\\<rangle>g_impl_rel_ext", "using drai_Gi.refine[THEN RETURN_nres_relD] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_bounded_hashcode ?S1 ?seq1 ?bhc1;\n   is_valid_def_hm_size TYPE(?'a1) ?hms1;\n   (?seq1, (=)) \\<in> ?S1 \\<rightarrow> ?S1 \\<rightarrow> bool_rel;\n   (?Ai1, ?A1) \\<in> \\<langle>?L1, ?S1\\<rangle>drai_dra_rel\\<rbrakk>\n  \\<Longrightarrow> (DRA_Nodes.drai_Gi ?seq1 ?bhc1 ?hms1 ?Ai1, dra_G ?A1)\n                    \\<in> \\<langle>unit_rel, ?S1\\<rangle>g_impl_rel_ext\n  SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\n  GEN_OP seq (=) (S \\<rightarrow> S \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. (DRA_Nodes.drai_Gi seq bhc hms, dra_G)\n    \\<in> \\<langle>L, S\\<rangle>drai_dra_rel \\<rightarrow>\n          \\<langle>unit_rel, S\\<rangle>g_impl_rel_ext", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_bounded_hashcode ?S1 ?seq1 ?bhc1;\n   is_valid_def_hm_size TYPE(?'a1) ?hms1;\n   (?seq1, (=)) \\<in> ?S1 \\<rightarrow> ?S1 \\<rightarrow> bool_rel;\n   (?Ai1, ?A1) \\<in> \\<langle>?L1, ?S1\\<rangle>drai_dra_rel\\<rbrakk>\n  \\<Longrightarrow> (DRA_Nodes.drai_Gi ?seq1 ?bhc1 ?hms1 ?Ai1, dra_G ?A1)\n                    \\<in> \\<langle>unit_rel, ?S1\\<rangle>g_impl_rel_ext\n  is_bounded_hashcode S seq bhc\n  is_valid_def_hm_size TYPE('statei) hms\n  (seq, (=)) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (DRA_Nodes.drai_Gi seq bhc hms, dra_G)\n    \\<in> \\<langle>L, S\\<rangle>drai_dra_rel \\<rightarrow>\n          \\<langle>unit_rel, S\\<rangle>g_impl_rel_ext", "by blast"], ["", "schematic_goal dra_nodes:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes [simp]: \"finite ((g_E (dra_G A))\\<^sup>* `` g_V0 (dra_G A))\"\n      assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhc\"\n      assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n      assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n      assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> drai_dra_rel\"\n      shows \"(?f :: ?'a, op_reachable (dra_G A)) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, op_reachable (dra_G A)) \\<in> ?R", "by autoref"], ["", "concrete_definition dra_nodes uses dra_nodes"], ["", "lemma dra_nodes_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> drai_dra_rel\"\n      shows \"(DRA_Nodes.dra_nodes seq bhc hms Ai,\n        (OP nodes ::: \\<langle>L, S\\<rangle> drai_dra_rel \\<rightarrow> \\<langle>S\\<rangle> ahs_rel bhc) $ A) \\<in> \\<langle>S\\<rangle> ahs_rel bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (DRA_Nodes.dra_nodes seq bhc hms Ai,\n     (OP nodes :::\n      \\<langle>L, S\\<rangle>drai_dra_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (DRA_Nodes.dra_nodes seq bhc hms Ai,\n     (OP nodes :::\n      \\<langle>L, S\\<rangle>drai_dra_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "have \"finite ((g_E (dra_G A))\\<^sup>* `` g_V0 (dra_G A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((g_E (dra_G A))\\<^sup>* `` g_V0 (dra_G A))", "using assms(1)"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (finite (nodes A))\n\ngoal (1 subgoal):\n 1. finite ((g_E (dra_G A))\\<^sup>* `` g_V0 (dra_G A))", "unfolding autoref_tag_defs dra_G_reachable_nodes[symmetric]"], ["proof (prove)\nusing this:\n  finite (op_reachable (dra_G A))\n\ngoal (1 subgoal):\n 1. finite ((g_E (dra_G A))\\<^sup>* `` g_V0 (dra_G A))", "by simp"], ["proof (state)\nthis:\n  finite ((g_E (dra_G A))\\<^sup>* `` g_V0 (dra_G A))\n\ngoal (1 subgoal):\n 1. (DRA_Nodes.dra_nodes seq bhc hms Ai,\n     (OP nodes :::\n      \\<langle>L, S\\<rangle>drai_dra_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "then"], ["proof (chain)\npicking this:\n  finite ((g_E (dra_G A))\\<^sup>* `` g_V0 (dra_G A))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite ((g_E (dra_G A))\\<^sup>* `` g_V0 (dra_G A))\n\ngoal (1 subgoal):\n 1. (DRA_Nodes.dra_nodes seq bhc hms Ai,\n     (OP nodes :::\n      \\<langle>L, S\\<rangle>drai_dra_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "using dra_nodes.refine assms"], ["proof (prove)\nusing this:\n  finite ((g_E (dra_G A))\\<^sup>* `` g_V0 (dra_G A))\n  \\<lbrakk>finite ((g_E (dra_G ?A))\\<^sup>* `` g_V0 (dra_G ?A));\n   is_bounded_hashcode ?S ?seq ?bhc; is_valid_def_hm_size TYPE(?'c) ?hms;\n   (?seq, (=)) \\<in> ?S \\<rightarrow> ?S \\<rightarrow> bool_rel;\n   (?Ai, ?A) \\<in> \\<langle>?L, ?S\\<rangle>drai_dra_rel\\<rbrakk>\n  \\<Longrightarrow> (DRA_Nodes.dra_nodes ?seq ?bhc ?hms ?Ai,\n                     op_reachable (dra_G ?A))\n                    \\<in> \\<langle>?S\\<rangle>ahs_rel ?bhc\n  SIDE_PRECOND (finite (nodes A))\n  SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\n  GEN_OP seq (=) (S \\<rightarrow> S \\<rightarrow> bool_rel)\n  (Ai, A) \\<in> \\<langle>L, S\\<rangle>drai_dra_rel\n\ngoal (1 subgoal):\n 1. (DRA_Nodes.dra_nodes seq bhc hms Ai,\n     (OP nodes :::\n      \\<langle>L, S\\<rangle>drai_dra_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "unfolding autoref_tag_defs dra_G_reachable_nodes[symmetric]"], ["proof (prove)\nusing this:\n  finite ((g_E (dra_G A))\\<^sup>* `` g_V0 (dra_G A))\n  \\<lbrakk>finite ((g_E (dra_G ?A))\\<^sup>* `` g_V0 (dra_G ?A));\n   is_bounded_hashcode ?S ?seq ?bhc; is_valid_def_hm_size TYPE(?'c) ?hms;\n   (?seq, (=)) \\<in> ?S \\<rightarrow> ?S \\<rightarrow> bool_rel;\n   (?Ai, ?A) \\<in> \\<langle>?L, ?S\\<rangle>drai_dra_rel\\<rbrakk>\n  \\<Longrightarrow> (DRA_Nodes.dra_nodes ?seq ?bhc ?hms ?Ai,\n                     op_reachable (dra_G ?A))\n                    \\<in> \\<langle>?S\\<rangle>ahs_rel ?bhc\n  finite (op_reachable (dra_G A))\n  is_bounded_hashcode S seq bhc\n  is_valid_def_hm_size TYPE('statei) hms\n  (seq, (=)) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\n  (Ai, A) \\<in> \\<langle>L, S\\<rangle>drai_dra_rel\n\ngoal (1 subgoal):\n 1. (DRA_Nodes.dra_nodes seq bhc hms Ai, op_reachable (dra_G A))\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "by blast"], ["proof (state)\nthis:\n  (DRA_Nodes.dra_nodes seq bhc hms Ai,\n   (OP nodes :::\n    \\<langle>L, S\\<rangle>drai_dra_rel \\<rightarrow>\n    \\<langle>S\\<rangle>ahs_rel bhc) $\n   A)\n  \\<in> \\<langle>S\\<rangle>ahs_rel bhc\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}