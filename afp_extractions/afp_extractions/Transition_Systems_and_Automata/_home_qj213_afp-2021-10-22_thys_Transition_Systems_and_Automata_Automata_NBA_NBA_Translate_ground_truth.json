{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Automata/NBA/NBA_Translate.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma nbae_image_param[param]: \"(nbae_image, nbae_image) \\<in> (S \\<rightarrow> T) \\<rightarrow> \\<langle>L, S\\<rangle> nbae_rel \\<rightarrow> \\<langle>L, T\\<rangle> nbae_rel\"", "lemma nbae_image_id[simp]: \"nbae_image id = id\"", "lemma nbae_image_nba_nbae: \"nbae_image f (nba_nbae A) = nbae\n    (alphabet A) (f ` initial A)\n    (\\<Union> p \\<in> nodes A. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n    (f ` {p \\<in> nodes A. accepting A p})\"", "lemma trans_algo_refine:\n    assumes \"finite (nodes A)\" \"finite (alphabet A)\" \"inj_on f (nodes A)\"\n    assumes \"N = nodes A\" \"L = alphabet A\" \"S = transition A\"\n    shows \"(trans_algo N L S f, SPEC (HOL.eq (trans_spec A f))) \\<in> \\<langle>Id\\<rangle> nres_rel\"", "lemma nba_image_rel[param]:\n    assumes \"inj_on f (nodes A)\"\n    shows \"(A, nba_image f A) \\<in> \\<langle>Id_on (alphabet A), br f (\\<lambda> p. p \\<in> nodes A)\\<rangle> nba_rel\"", "lemma nba_image_nodes[simp]:\n    assumes \"inj_on f (nodes A)\"\n    shows \"nodes (nba_image f A) = f ` nodes A\"", "lemma nba_image_language[simp]:\n    assumes \"inj_on f (nodes A)\"\n    shows \"language (nba_image f A) = language A\"", "lemma nba_image_nbae:\n    assumes \"inj_on f (nodes A)\"\n    shows \"nbae_image f (nba_nbae A) = nba_nbae (nba_image f A)\"", "lemma op_translate_language:\n    assumes \"(RETURN Ai, op_translate A) \\<in> \\<langle>\\<langle>Id, nat_rel\\<rangle> nbaei_nbae_rel\\<rangle> nres_rel\"\n    shows \"language (nbae_nba (nbaei_nbae Ai)) = language A\"", "lemma to_nbaei_impl_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel\"\n      shows \"(RETURN (to_nbaei_impl seq bhc hms Ai),\n        (OP op_translate ::: \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L, nat_rel\\<rangle> nbaei_nbae_rel\\<rangle> nres_rel) $ A) \\<in>\n        \\<langle>\\<langle>L, nat_rel\\<rangle> nbaei_nbae_rel\\<rangle> nres_rel\""], "translations": [["", "lemma nbae_image_param[param]: \"(nbae_image, nbae_image) \\<in> (S \\<rightarrow> T) \\<rightarrow> \\<langle>L, S\\<rangle> nbae_rel \\<rightarrow> \\<langle>L, T\\<rangle> nbae_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nbae_image, nbae_image)\n    \\<in> (S \\<rightarrow> T) \\<rightarrow>\n          \\<langle>L, S\\<rangle>nbae_rel \\<rightarrow> \\<langle>L,\n          T\\<rangle>nbae_rel", "unfolding nbae_image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f A.\n        nbae (alphabete A) (f ` initiale A)\n         ((\\<lambda>(p, a, q). (f p, a, f q)) ` transitione A)\n         (f ` acceptinge A),\n     \\<lambda>f A.\n        nbae (alphabete A) (f ` initiale A)\n         ((\\<lambda>(p, a, q). (f p, a, f q)) ` transitione A)\n         (f ` acceptinge A))\n    \\<in> (S \\<rightarrow> T) \\<rightarrow>\n          \\<langle>L, S\\<rangle>nbae_rel \\<rightarrow> \\<langle>L,\n          T\\<rangle>nbae_rel", "by parametricity"], ["", "lemma nbae_image_id[simp]: \"nbae_image id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nbae_image id = id", "unfolding nbae_image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A.\n        nbae (alphabete A) (id ` initiale A)\n         ((\\<lambda>(p, a, q). (id p, a, id q)) ` transitione A)\n         (id ` acceptinge A)) =\n    id", "by auto"], ["", "lemma nbae_image_nba_nbae: \"nbae_image f (nba_nbae A) = nbae\n    (alphabet A) (f ` initial A)\n    (\\<Union> p \\<in> nodes A. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n    (f ` {p \\<in> nodes A. accepting A p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nbae_image f (nba_nbae A) =\n    nbae (alphabet A) (f ` initial A)\n     (\\<Union>p\\<in>nodes A.\n         \\<Union>a\\<in>alphabet A.\n            f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n     (f ` {p \\<in> nodes A. accepting A p})", "unfolding nba_nbae_def nbae_image_def nbae.simps Set.filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. alphabete\n     (nbae (alphabet A) (initial A)\n       (transitions (alphabet A) (nodes A) (transition A))\n       {a \\<in> nodes A. accepting A a}) =\n    alphabet A \\<and>\n    f `\n    initiale\n     (nbae (alphabet A) (initial A)\n       (transitions (alphabet A) (nodes A) (transition A))\n       {a \\<in> nodes A. accepting A a}) =\n    f ` initial A \\<and>\n    (\\<lambda>(p, a, q). (f p, a, f q)) `\n    transitione\n     (nbae (alphabet A) (initial A)\n       (transitions (alphabet A) (nodes A) (transition A))\n       {a \\<in> nodes A. accepting A a}) =\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) \\<and>\n    f `\n    acceptinge\n     (nbae (alphabet A) (initial A)\n       (transitions (alphabet A) (nodes A) (transition A))\n       {a \\<in> nodes A. accepting A a}) =\n    f ` {p \\<in> nodes A. accepting A p}", "by force"], ["", "section \\<open>Exploration and Translation\\<close>"], ["", "definition trans_spec where\n    \"trans_spec A f \\<equiv> \\<Union> p \\<in> nodes A. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p\""], ["", "definition trans_algo where\n    \"trans_algo N L S f \\<equiv>\n      FOREACH N (\\<lambda> p T. do {\n        ASSERT (p \\<in> N);\n        FOREACH L (\\<lambda> a T. do {\n          ASSERT (a \\<in> L);\n          FOREACH (S a p) (\\<lambda> q T. do {\n            ASSERT (q \\<in> S a p);\n            ASSERT ((f p, a, f q) \\<notin> T);\n            RETURN (insert (f p, a, f q) T) }\n          ) T }\n        ) T }\n      ) {}\""], ["", "lemma trans_algo_refine:\n    assumes \"finite (nodes A)\" \"finite (alphabet A)\" \"inj_on f (nodes A)\"\n    assumes \"N = nodes A\" \"L = alphabet A\" \"S = transition A\"\n    shows \"(trans_algo N L S f, SPEC (HOL.eq (trans_spec A f))) \\<in> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trans_algo N L S f, SPEC ((=) (trans_spec A f)))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding trans_algo_def trans_spec_def assms(4-6)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (FOREACH (nodes A)\n      (\\<lambda>p T.\n          ASSERT (p \\<in> nodes A) \\<bind>\n          (\\<lambda>_.\n              FOREACH (alphabet A)\n               (\\<lambda>a T.\n                   ASSERT (a \\<in> alphabet A) \\<bind>\n                   (\\<lambda>_.\n                       FOREACH (transition A a p)\n                        (\\<lambda>q T.\n                            ASSERT (q \\<in> transition A a p) \\<bind>\n                            (\\<lambda>_.\n                                ASSERT ((f p, a, f q) \\<notin> T) \\<bind>\n                                (\\<lambda>_.\n                                    RETURN (insert (f p, a, f q) T))))\n                        T))\n               T))\n      {},\n     SPEC\n      ((=) (\\<Union>p\\<in>nodes A.\n               \\<Union>a\\<in>alphabet A.\n                  f ` {p} \\<times> {a} \\<times> f ` transition A a p)))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "proof (refine_vcg FOREACH_rule_insert_eq)"], ["proof (state)\ngoal (11 subgoals):\n 1. finite (nodes A)\n 2. ?X2 {} = {}\n 3. ?X2 (nodes A) =\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n 4. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 5. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} = ?X2 T\n 6. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) = ?X2 (insert x T)\n 7. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> finite (transition A xa x)\n 8. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa {} = ?X5 T x Ta\n 9. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (transition A xa x) =\n                         ?X5 T x (insert xa Ta)\n 10. \\<And>T x Ta xa Tb xb.\n        \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n         x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n         xa \\<notin> Ta; xa \\<in> alphabet A;\n         Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n         xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n        \\<Longrightarrow> (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\nA total of 11 subgoals...", "show \"finite (nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes A)", "using assms(1)"], ["proof (prove)\nusing this:\n  finite (nodes A)\n\ngoal (1 subgoal):\n 1. finite (nodes A)", "by this"], ["proof (state)\nthis:\n  finite (nodes A)\n\ngoal (10 subgoals):\n 1. ?X2 {} = {}\n 2. ?X2 (nodes A) =\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n 3. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 4. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} = ?X2 T\n 5. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) = ?X2 (insert x T)\n 6. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> finite (transition A xa x)\n 7. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa {} = ?X5 T x Ta\n 8. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (transition A xa x) =\n                         ?X5 T x (insert xa Ta)\n 9. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\n 10. \\<And>T x Ta xa Tb xb.\n        \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n         x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n         xa \\<notin> Ta; xa \\<in> alphabet A;\n         Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n         xb \\<notin> Tb; xb \\<in> transition A xa x;\n         (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\\<rbrakk>\n        \\<Longrightarrow> ?X9 T x Ta xa (insert xb Tb) =\n                          insert (f x, xa, f xb) (?X9 T x Ta xa Tb)", "show \"(\\<Union> p \\<in> nodes A. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n      (\\<Union> p \\<in> nodes A. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p)", "by rule"], ["proof (state)\nthis:\n  (\\<Union>p\\<in>nodes A.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n  (\\<Union>p\\<in>nodes A.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n\ngoal (9 subgoals):\n 1. (\\<Union>p\\<in>{}.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    {}\n 2. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 3. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} =\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 4. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) =\n                         (\\<Union>p\\<in>insert x T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 5. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> finite (transition A xa x)\n 6. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa {} = ?X5 T x Ta\n 7. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (transition A xa x) =\n                         ?X5 T x (insert xa Ta)\n 8. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\n 9. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (insert xb Tb) =\n                         insert (f x, xa, f xb) (?X9 T x Ta xa Tb)", "show \"(\\<Union> p \\<in> {}. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>{}.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    {}", "by simp"], ["proof (state)\nthis:\n  (\\<Union>p\\<in>{}.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n  {}\n\ngoal (8 subgoals):\n 1. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 2. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} =\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 3. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) =\n                         (\\<Union>p\\<in>insert x T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 4. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> finite (transition A xa x)\n 5. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa {} = ?X5 T x Ta\n 6. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (transition A xa x) =\n                         ?X5 T x (insert xa Ta)\n 7. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\n 8. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (insert xb Tb) =\n                         insert (f x, xa, f xb) (?X9 T x Ta xa Tb)", "fix T x"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 2. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} =\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 3. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) =\n                         (\\<Union>p\\<in>insert x T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 4. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> finite (transition A xa x)\n 5. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa {} = ?X5 T x Ta\n 6. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (transition A xa x) =\n                         ?X5 T x (insert xa Ta)\n 7. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\n 8. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (insert xb Tb) =\n                         insert (f x, xa, f xb) (?X9 T x Ta xa Tb)", "assume 1: \"T \\<subseteq> nodes A\" \"x \\<in> nodes A\" \"x \\<notin> T\""], ["proof (state)\nthis:\n  T \\<subseteq> nodes A\n  x \\<in> nodes A\n  x \\<notin> T\n\ngoal (8 subgoals):\n 1. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 2. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} =\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 3. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) =\n                         (\\<Union>p\\<in>insert x T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 4. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> finite (transition A xa x)\n 5. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa {} = ?X5 T x Ta\n 6. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (transition A xa x) =\n                         ?X5 T x (insert xa Ta)\n 7. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\n 8. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (insert xb Tb) =\n                         insert (f x, xa, f xb) (?X9 T x Ta xa Tb)", "show \"finite (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (alphabet A)", "using assms(2)"], ["proof (prove)\nusing this:\n  finite (alphabet A)\n\ngoal (1 subgoal):\n 1. finite (alphabet A)", "by this"], ["proof (state)\nthis:\n  finite (alphabet A)\n\ngoal (7 subgoals):\n 1. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} =\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 2. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) =\n                         (\\<Union>p\\<in>insert x T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 3. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> finite (transition A xa x)\n 4. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa {} = ?X5 T x Ta\n 5. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (transition A xa x) =\n                         ?X5 T x (insert xa Ta)\n 6. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\n 7. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (insert xb Tb) =\n                         insert (f x, xa, f xb) (?X9 T x Ta xa Tb)", "show \"(\\<Union> a \\<in> {}. f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p)\"\n      \"(\\<Union> a \\<in> alphabet A. f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n      (\\<Union> p \\<in> insert x T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>{}.\n        f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) &&&\n    (\\<Union>a\\<in>alphabet A.\n        f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    (\\<Union>p\\<in>insert x T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p)", "by auto"], ["proof (state)\nthis:\n  (\\<Union>a\\<in>{}.\n      f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n  (\\<Union>a\\<in>alphabet A.\n      f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n  (\\<Union>p\\<in>insert x T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n\ngoal (5 subgoals):\n 1. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> finite (transition A xa x)\n 2. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa {} =\n                         (\\<Union>a\\<in>Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 3. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (transition A xa x) =\n                         (\\<Union>a\\<in>insert xa Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 4. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\n 5. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (insert xb Tb) =\n                         insert (f x, xa, f xb) (?X9 T x Ta xa Tb)", "fix Ta xa"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> finite (transition A xa x)\n 2. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa {} =\n                         (\\<Union>a\\<in>Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 3. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (transition A xa x) =\n                         (\\<Union>a\\<in>insert xa Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 4. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\n 5. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (insert xb Tb) =\n                         insert (f x, xa, f xb) (?X9 T x Ta xa Tb)", "assume 2: \"Ta \\<subseteq> alphabet A\" \"xa \\<in> alphabet A\" \"xa \\<notin> Ta\""], ["proof (state)\nthis:\n  Ta \\<subseteq> alphabet A\n  xa \\<in> alphabet A\n  xa \\<notin> Ta\n\ngoal (5 subgoals):\n 1. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> finite (transition A xa x)\n 2. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa {} =\n                         (\\<Union>a\\<in>Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 3. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (transition A xa x) =\n                         (\\<Union>a\\<in>insert xa Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 4. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\n 5. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (insert xb Tb) =\n                         insert (f x, xa, f xb) (?X9 T x Ta xa Tb)", "show \"finite (transition A xa x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (transition A xa x)", "using 1 2 assms(1)"], ["proof (prove)\nusing this:\n  T \\<subseteq> nodes A\n  x \\<in> nodes A\n  x \\<notin> T\n  Ta \\<subseteq> alphabet A\n  xa \\<in> alphabet A\n  xa \\<notin> Ta\n  finite (nodes A)\n\ngoal (1 subgoal):\n 1. finite (transition A xa x)", "by (meson infinite_subset nba.nodes_transition subsetI)"], ["proof (state)\nthis:\n  finite (transition A xa x)\n\ngoal (4 subgoals):\n 1. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa {} =\n                         (\\<Union>a\\<in>Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 2. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (transition A xa x) =\n                         (\\<Union>a\\<in>insert xa Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 3. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\n 4. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb) \\<notin> ?X9 T x Ta xa Tb\\<rbrakk>\n       \\<Longrightarrow> ?X9 T x Ta xa (insert xb Tb) =\n                         insert (f x, xa, f xb) (?X9 T x Ta xa Tb)", "show \"(f ` {x} \\<times> {xa} \\<times> f ` transition A xa x) \\<union>\n      (\\<Union> a \\<in> Ta. f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n      (\\<Union> a \\<in> insert xa Ta. f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` {x} \\<times> {xa} \\<times> f ` transition A xa x \\<union>\n    (\\<Union>a\\<in>Ta.\n        f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    (\\<Union>a\\<in>insert xa Ta.\n        f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p)", "by auto"], ["proof (state)\nthis:\n  f ` {x} \\<times> {xa} \\<times> f ` transition A xa x \\<union>\n  (\\<Union>a\\<in>Ta.\n      f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n  (\\<Union>a\\<in>insert xa Ta.\n      f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n\ngoal (3 subgoals):\n 1. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> f ` {x} \\<times> {xa} \\<times> f ` {} \\<union>\n                         (\\<Union>a\\<in>Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p) =\n                         (\\<Union>a\\<in>Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p)\n 2. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb)\n                         \\<notin> f ` {x} \\<times>\n                                  {xa} \\<times> f ` Tb \\<union>\n                                  (\\<Union>a\\<in>Ta.\nf ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n                                  (\\<Union>p\\<in>T.\n\\<Union>a\\<in>alphabet A.\n   f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n 3. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb)\n        \\<notin> f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n                 (\\<Union>a\\<in>Ta.\n                     f ` {x} \\<times>\n                     {a} \\<times> f ` transition A a x) \\<union>\n                 (\\<Union>p\\<in>T.\n                     \\<Union>a\\<in>alphabet A.\n                        f ` {p} \\<times>\n                        {a} \\<times> f ` transition A a p)\\<rbrakk>\n       \\<Longrightarrow> f ` {x} \\<times>\n                         {xa} \\<times> f ` insert xb Tb \\<union>\n                         (\\<Union>a\\<in>Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p) =\n                         insert (f x, xa, f xb)\n                          (f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n                           (\\<Union>a\\<in>Ta.\n                               f ` {x} \\<times>\n                               {a} \\<times> f ` transition A a x) \\<union>\n                           (\\<Union>p\\<in>T.\n                               \\<Union>a\\<in>alphabet A.\n                                  f ` {p} \\<times>\n                                  {a} \\<times> f ` transition A a p))", "show \"(f ` {x} \\<times> {xa} \\<times> f ` {}) \\<union>\n      (\\<Union> a \\<in> Ta. f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n      (\\<Union> a \\<in> Ta. f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` {x} \\<times> {xa} \\<times> f ` {} \\<union>\n    (\\<Union>a\\<in>Ta.\n        f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    (\\<Union>a\\<in>Ta.\n        f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p)", "by auto"], ["proof (state)\nthis:\n  f ` {x} \\<times> {xa} \\<times> f ` {} \\<union>\n  (\\<Union>a\\<in>Ta.\n      f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n  (\\<Union>a\\<in>Ta.\n      f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n\ngoal (2 subgoals):\n 1. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb)\n                         \\<notin> f ` {x} \\<times>\n                                  {xa} \\<times> f ` Tb \\<union>\n                                  (\\<Union>a\\<in>Ta.\nf ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n                                  (\\<Union>p\\<in>T.\n\\<Union>a\\<in>alphabet A.\n   f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n 2. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb)\n        \\<notin> f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n                 (\\<Union>a\\<in>Ta.\n                     f ` {x} \\<times>\n                     {a} \\<times> f ` transition A a x) \\<union>\n                 (\\<Union>p\\<in>T.\n                     \\<Union>a\\<in>alphabet A.\n                        f ` {p} \\<times>\n                        {a} \\<times> f ` transition A a p)\\<rbrakk>\n       \\<Longrightarrow> f ` {x} \\<times>\n                         {xa} \\<times> f ` insert xb Tb \\<union>\n                         (\\<Union>a\\<in>Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p) =\n                         insert (f x, xa, f xb)\n                          (f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n                           (\\<Union>a\\<in>Ta.\n                               f ` {x} \\<times>\n                               {a} \\<times> f ` transition A a x) \\<union>\n                           (\\<Union>p\\<in>T.\n                               \\<Union>a\\<in>alphabet A.\n                                  f ` {p} \\<times>\n                                  {a} \\<times> f ` transition A a p))", "fix Tb xb"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb)\n                         \\<notin> f ` {x} \\<times>\n                                  {xa} \\<times> f ` Tb \\<union>\n                                  (\\<Union>a\\<in>Ta.\nf ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n                                  (\\<Union>p\\<in>T.\n\\<Union>a\\<in>alphabet A.\n   f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n 2. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb)\n        \\<notin> f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n                 (\\<Union>a\\<in>Ta.\n                     f ` {x} \\<times>\n                     {a} \\<times> f ` transition A a x) \\<union>\n                 (\\<Union>p\\<in>T.\n                     \\<Union>a\\<in>alphabet A.\n                        f ` {p} \\<times>\n                        {a} \\<times> f ` transition A a p)\\<rbrakk>\n       \\<Longrightarrow> f ` {x} \\<times>\n                         {xa} \\<times> f ` insert xb Tb \\<union>\n                         (\\<Union>a\\<in>Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p) =\n                         insert (f x, xa, f xb)\n                          (f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n                           (\\<Union>a\\<in>Ta.\n                               f ` {x} \\<times>\n                               {a} \\<times> f ` transition A a x) \\<union>\n                           (\\<Union>p\\<in>T.\n                               \\<Union>a\\<in>alphabet A.\n                                  f ` {p} \\<times>\n                                  {a} \\<times> f ` transition A a p))", "assume 3: \"Tb \\<subseteq> transition A xa x\" \"xb \\<in> transition A xa x\" \"xb \\<notin> Tb\""], ["proof (state)\nthis:\n  Tb \\<subseteq> transition A xa x\n  xb \\<in> transition A xa x\n  xb \\<notin> Tb\n\ngoal (2 subgoals):\n 1. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f xb)\n                         \\<notin> f ` {x} \\<times>\n                                  {xa} \\<times> f ` Tb \\<union>\n                                  (\\<Union>a\\<in>Ta.\nf ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n                                  (\\<Union>p\\<in>T.\n\\<Union>a\\<in>alphabet A.\n   f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n 2. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb)\n        \\<notin> f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n                 (\\<Union>a\\<in>Ta.\n                     f ` {x} \\<times>\n                     {a} \\<times> f ` transition A a x) \\<union>\n                 (\\<Union>p\\<in>T.\n                     \\<Union>a\\<in>alphabet A.\n                        f ` {p} \\<times>\n                        {a} \\<times> f ` transition A a p)\\<rbrakk>\n       \\<Longrightarrow> f ` {x} \\<times>\n                         {xa} \\<times> f ` insert xb Tb \\<union>\n                         (\\<Union>a\\<in>Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p) =\n                         insert (f x, xa, f xb)\n                          (f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n                           (\\<Union>a\\<in>Ta.\n                               f ` {x} \\<times>\n                               {a} \\<times> f ` transition A a x) \\<union>\n                           (\\<Union>p\\<in>T.\n                               \\<Union>a\\<in>alphabet A.\n                                  f ` {p} \\<times>\n                                  {a} \\<times> f ` transition A a p))", "show \"(f x, xa, f xb) \\<notin> f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n      (\\<Union> a \\<in> Ta. f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x, xa, f xb)\n    \\<notin> f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n             (\\<Union>a\\<in>Ta.\n                 f ` {x} \\<times>\n                 {a} \\<times> f ` transition A a x) \\<union>\n             (\\<Union>p\\<in>T.\n                 \\<Union>a\\<in>alphabet A.\n                    f ` {p} \\<times> {a} \\<times> f ` transition A a p)", "using 1 2 3 assms(3)"], ["proof (prove)\nusing this:\n  T \\<subseteq> nodes A\n  x \\<in> nodes A\n  x \\<notin> T\n  Ta \\<subseteq> alphabet A\n  xa \\<in> alphabet A\n  xa \\<notin> Ta\n  Tb \\<subseteq> transition A xa x\n  xb \\<in> transition A xa x\n  xb \\<notin> Tb\n  inj_on f (nodes A)\n\ngoal (1 subgoal):\n 1. (f x, xa, f xb)\n    \\<notin> f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n             (\\<Union>a\\<in>Ta.\n                 f ` {x} \\<times>\n                 {a} \\<times> f ` transition A a x) \\<union>\n             (\\<Union>p\\<in>T.\n                 \\<Union>a\\<in>alphabet A.\n                    f ` {p} \\<times> {a} \\<times> f ` transition A a p)", "by (blast dest: inj_onD)"], ["proof (state)\nthis:\n  (f x, xa, f xb)\n  \\<notin> f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n           (\\<Union>a\\<in>Ta.\n               f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n           (\\<Union>p\\<in>T.\n               \\<Union>a\\<in>alphabet A.\n                  f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n\ngoal (1 subgoal):\n 1. \\<And>T x Ta xa Tb xb.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        Tb \\<subseteq> transition A xa x; xb \\<in> transition A xa x;\n        xb \\<notin> Tb; xb \\<in> transition A xa x;\n        (f x, xa, f xb)\n        \\<notin> f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n                 (\\<Union>a\\<in>Ta.\n                     f ` {x} \\<times>\n                     {a} \\<times> f ` transition A a x) \\<union>\n                 (\\<Union>p\\<in>T.\n                     \\<Union>a\\<in>alphabet A.\n                        f ` {p} \\<times>\n                        {a} \\<times> f ` transition A a p)\\<rbrakk>\n       \\<Longrightarrow> f ` {x} \\<times>\n                         {xa} \\<times> f ` insert xb Tb \\<union>\n                         (\\<Union>a\\<in>Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` transition A a x) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` transition A a p) =\n                         insert (f x, xa, f xb)\n                          (f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n                           (\\<Union>a\\<in>Ta.\n                               f ` {x} \\<times>\n                               {a} \\<times> f ` transition A a x) \\<union>\n                           (\\<Union>p\\<in>T.\n                               \\<Union>a\\<in>alphabet A.\n                                  f ` {p} \\<times>\n                                  {a} \\<times> f ` transition A a p))", "show \"f ` {x} \\<times> {xa} \\<times> f ` insert xb Tb \\<union>\n      (\\<Union> a \\<in> Ta. f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n      insert (f x, xa, f xb) (f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n      (\\<Union> a \\<in> Ta. f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` transition A a p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` {x} \\<times> {xa} \\<times> f ` insert xb Tb \\<union>\n    (\\<Union>a\\<in>Ta.\n        f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    insert (f x, xa, f xb)\n     (f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n      (\\<Union>a\\<in>Ta.\n          f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n      (\\<Union>p\\<in>T.\n          \\<Union>a\\<in>alphabet A.\n             f ` {p} \\<times> {a} \\<times> f ` transition A a p))", "by auto"], ["proof (state)\nthis:\n  f ` {x} \\<times> {xa} \\<times> f ` insert xb Tb \\<union>\n  (\\<Union>a\\<in>Ta.\n      f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n  insert (f x, xa, f xb)\n   (f ` {x} \\<times> {xa} \\<times> f ` Tb \\<union>\n    (\\<Union>a\\<in>Ta.\n        f ` {x} \\<times> {a} \\<times> f ` transition A a x) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: move this to nondeterministic automaton\n    there, it will have to be treated more elementarily\n    at least until we abstract from NBA_Refine to do that there aswell *)"], ["", "definition nba_image :: \"('state\\<^sub>1 \\<Rightarrow> 'state\\<^sub>2) \\<Rightarrow> ('label, 'state\\<^sub>1) nba \\<Rightarrow> ('label, 'state\\<^sub>2) nba\" where\n    \"nba_image f A \\<equiv> nba\n      (alphabet A)\n      (f ` initial A)\n      (\\<lambda> a p. f ` transition A a (inv_into (nodes A) f p))\n      (\\<lambda> p. accepting A (inv_into (nodes A) f p))\""], ["", "lemma nba_image_rel[param]:\n    assumes \"inj_on f (nodes A)\"\n    shows \"(A, nba_image f A) \\<in> \\<langle>Id_on (alphabet A), br f (\\<lambda> p. p \\<in> nodes A)\\<rangle> nba_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, nba_image f A) \\<in> \\<langle>Id_on (alphabet A),\n    br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A, nba_image f A) \\<in> \\<langle>Id_on (alphabet A),\n    br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel", "have \"A = nba (alphabet A) (initial A) (transition A) (accepting A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = nba (alphabet A) (initial A) (transition A) (accepting A)", "by simp"], ["proof (state)\nthis:\n  A = nba (alphabet A) (initial A) (transition A) (accepting A)\n\ngoal (1 subgoal):\n 1. (A, nba_image f A) \\<in> \\<langle>Id_on (alphabet A),\n    br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel", "also"], ["proof (state)\nthis:\n  A = nba (alphabet A) (initial A) (transition A) (accepting A)\n\ngoal (1 subgoal):\n 1. (A, nba_image f A) \\<in> \\<langle>Id_on (alphabet A),\n    br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel", "have \"(\\<dots>, nba_image f A) \\<in> \\<langle>Id_on (alphabet A), br f (\\<lambda> p. p \\<in> nodes A)\\<rangle> nba_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nba (alphabet A) (initial A) (transition A) (accepting A),\n     nba_image f A)\n    \\<in> \\<langle>Id_on (alphabet A),\n    br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel", "using assms"], ["proof (prove)\nusing this:\n  inj_on f (nodes A)\n\ngoal (1 subgoal):\n 1. (nba (alphabet A) (initial A) (transition A) (accepting A),\n     nba_image f A)\n    \\<in> \\<langle>Id_on (alphabet A),\n    br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel", "unfolding nba_image_def"], ["proof (prove)\nusing this:\n  inj_on f (nodes A)\n\ngoal (1 subgoal):\n 1. (nba (alphabet A) (initial A) (transition A) (accepting A),\n     nba (alphabet A) (f ` initial A)\n      (\\<lambda>a p. f ` transition A a (inv_into (nodes A) f p))\n      (\\<lambda>p. accepting A (inv_into (nodes A) f p)))\n    \\<in> \\<langle>Id_on (alphabet A),\n    br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel", "by (parametricity) (auto intro: nba_rel_eq simp: in_br_conv br_set_rel_alt)"], ["proof (state)\nthis:\n  (nba (alphabet A) (initial A) (transition A) (accepting A), nba_image f A)\n  \\<in> \\<langle>Id_on (alphabet A),\n  br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel\n\ngoal (1 subgoal):\n 1. (A, nba_image f A) \\<in> \\<langle>Id_on (alphabet A),\n    br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel", "finally"], ["proof (chain)\npicking this:\n  (A, nba_image f A) \\<in> \\<langle>Id_on (alphabet A),\n  br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (A, nba_image f A) \\<in> \\<langle>Id_on (alphabet A),\n  br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel\n\ngoal (1 subgoal):\n 1. (A, nba_image f A) \\<in> \\<langle>Id_on (alphabet A),\n    br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel", "by this"], ["proof (state)\nthis:\n  (A, nba_image f A) \\<in> \\<langle>Id_on (alphabet A),\n  br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>nba_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nba_image_nodes[simp]:\n    assumes \"inj_on f (nodes A)\"\n    shows \"nodes (nba_image f A) = f ` nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes (nba_image f A) = f ` nodes A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nodes (nba_image f A) = f ` nodes A", "have \"(nodes A, nodes (nba_image f A)) \\<in> \\<langle>br f (\\<lambda> p. p \\<in> nodes A)\\<rangle> set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nodes A, nodes (nba_image f A))\n    \\<in> \\<langle>br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>set_rel", "using assms"], ["proof (prove)\nusing this:\n  inj_on f (nodes A)\n\ngoal (1 subgoal):\n 1. (nodes A, nodes (nba_image f A))\n    \\<in> \\<langle>br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>set_rel", "by parametricity"], ["proof (state)\nthis:\n  (nodes A, nodes (nba_image f A))\n  \\<in> \\<langle>br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. nodes (nba_image f A) = f ` nodes A", "then"], ["proof (chain)\npicking this:\n  (nodes A, nodes (nba_image f A))\n  \\<in> \\<langle>br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>set_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (nodes A, nodes (nba_image f A))\n  \\<in> \\<langle>br f (\\<lambda>p. p \\<in> nodes A)\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. nodes (nba_image f A) = f ` nodes A", "unfolding br_set_rel_alt"], ["proof (prove)\nusing this:\n  nodes (nba_image f A) = f ` nodes A \\<and>\n  (\\<forall>p\\<in>nodes A. p \\<in> nodes A)\n\ngoal (1 subgoal):\n 1. nodes (nba_image f A) = f ` nodes A", "by simp"], ["proof (state)\nthis:\n  nodes (nba_image f A) = f ` nodes A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nba_image_language[simp]:\n    assumes \"inj_on f (nodes A)\"\n    shows \"language (nba_image f A) = language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language (nba_image f A) = language A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. language (nba_image f A) = language A", "have \"(language A, language (nba_image f A)) \\<in> \\<langle>\\<langle>Id_on (alphabet A)\\<rangle> stream_rel\\<rangle> set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (language A, language (nba_image f A))\n    \\<in> \\<langle>\\<langle>Id_on\n                             (alphabet A)\\<rangle>stream_rel\\<rangle>set_rel", "using assms"], ["proof (prove)\nusing this:\n  inj_on f (nodes A)\n\ngoal (1 subgoal):\n 1. (language A, language (nba_image f A))\n    \\<in> \\<langle>\\<langle>Id_on\n                             (alphabet A)\\<rangle>stream_rel\\<rangle>set_rel", "by parametricity"], ["proof (state)\nthis:\n  (language A, language (nba_image f A))\n  \\<in> \\<langle>\\<langle>Id_on\n                           (alphabet A)\\<rangle>stream_rel\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. language (nba_image f A) = language A", "then"], ["proof (chain)\npicking this:\n  (language A, language (nba_image f A))\n  \\<in> \\<langle>\\<langle>Id_on\n                           (alphabet A)\\<rangle>stream_rel\\<rangle>set_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (language A, language (nba_image f A))\n  \\<in> \\<langle>\\<langle>Id_on\n                           (alphabet A)\\<rangle>stream_rel\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. language (nba_image f A) = language A", "by simp"], ["proof (state)\nthis:\n  language (nba_image f A) = language A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nba_image_nbae:\n    assumes \"inj_on f (nodes A)\"\n    shows \"nbae_image f (nba_nbae A) = nba_nbae (nba_image f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nbae_image f (nba_nbae A) = nba_nbae (nba_image f A)", "unfolding nbae_image_nba_nbae"], ["proof (prove)\ngoal (1 subgoal):\n 1. nbae (alphabet A) (f ` initial A)\n     (\\<Union>p\\<in>nodes A.\n         \\<Union>a\\<in>alphabet A.\n            f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n     (f ` {p \\<in> nodes A. accepting A p}) =\n    nba_nbae (nba_image f A)", "unfolding nba_nbae_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nbae (alphabet A) (f ` initial A)\n     (\\<Union>p\\<in>nodes A.\n         \\<Union>a\\<in>alphabet A.\n            f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n     (f ` {p \\<in> nodes A. accepting A p}) =\n    nbae (alphabet (nba_image f A)) (initial (nba_image f A))\n     (transitions (alphabet (nba_image f A)) (nodes (nba_image f A))\n       (transition (nba_image f A)))\n     (Set.filter (accepting (nba_image f A)) (nodes (nba_image f A)))", "unfolding nba_image_nodes[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. nbae (alphabet A) (f ` initial A)\n     (\\<Union>p\\<in>nodes A.\n         \\<Union>a\\<in>alphabet A.\n            f ` {p} \\<times> {a} \\<times> f ` transition A a p)\n     (f ` {p \\<in> nodes A. accepting A p}) =\n    nbae (alphabet (nba_image f A)) (initial (nba_image f A))\n     (transitions (alphabet (nba_image f A)) (f ` nodes A)\n       (transition (nba_image f A)))\n     (Set.filter (accepting (nba_image f A)) (f ` nodes A))", "unfolding nbae.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. alphabet A = alphabet (nba_image f A) \\<and>\n    f ` initial A = initial (nba_image f A) \\<and>\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    transitions (alphabet (nba_image f A)) (f ` nodes A)\n     (transition (nba_image f A)) \\<and>\n    f ` {p \\<in> nodes A. accepting A p} =\n    Set.filter (accepting (nba_image f A)) (f ` nodes A)", "unfolding nba_image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. alphabet A =\n    alphabet\n     (nba (alphabet A) (f ` initial A)\n       (\\<lambda>a p. f ` transition A a (inv_into (nodes A) f p))\n       (\\<lambda>p. accepting A (inv_into (nodes A) f p))) \\<and>\n    f ` initial A =\n    initial\n     (nba (alphabet A) (f ` initial A)\n       (\\<lambda>a p. f ` transition A a (inv_into (nodes A) f p))\n       (\\<lambda>p. accepting A (inv_into (nodes A) f p))) \\<and>\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    transitions\n     (alphabet\n       (nba (alphabet A) (f ` initial A)\n         (\\<lambda>a p. f ` transition A a (inv_into (nodes A) f p))\n         (\\<lambda>p. accepting A (inv_into (nodes A) f p))))\n     (f ` nodes A)\n     (transition\n       (nba (alphabet A) (f ` initial A)\n         (\\<lambda>a p. f ` transition A a (inv_into (nodes A) f p))\n         (\\<lambda>p. accepting A (inv_into (nodes A) f p)))) \\<and>\n    f ` {p \\<in> nodes A. accepting A p} =\n    Set.filter\n     (accepting\n       (nba (alphabet A) (f ` initial A)\n         (\\<lambda>a p. f ` transition A a (inv_into (nodes A) f p))\n         (\\<lambda>p. accepting A (inv_into (nodes A) f p))))\n     (f ` nodes A)", "unfolding nba.sel"], ["proof (prove)\ngoal (1 subgoal):\n 1. alphabet A = alphabet A \\<and>\n    f ` initial A = f ` initial A \\<and>\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    transitions (alphabet A) (f ` nodes A)\n     (\\<lambda>a p. f ` transition A a (inv_into (nodes A) f p)) \\<and>\n    f ` {p \\<in> nodes A. accepting A p} =\n    Set.filter (\\<lambda>p. accepting A (inv_into (nodes A) f p))\n     (f ` nodes A)", "using assms"], ["proof (prove)\nusing this:\n  inj_on f (nodes A)\n\ngoal (1 subgoal):\n 1. alphabet A = alphabet A \\<and>\n    f ` initial A = f ` initial A \\<and>\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` transition A a p) =\n    transitions (alphabet A) (f ` nodes A)\n     (\\<lambda>a p. f ` transition A a (inv_into (nodes A) f p)) \\<and>\n    f ` {p \\<in> nodes A. accepting A p} =\n    Set.filter (\\<lambda>p. accepting A (inv_into (nodes A) f p))\n     (f ` nodes A)", "by auto"], ["", "(* TODO: with this, maybe much of the nbae infrastructure is obsolete?\n    since now there is very little happening in terms of relations, maybe we can even make do\n    with just the abstraction function *)\n  (* TODO: maybe the specification for translation is just that the translated automaton\n    is related in \\<langle>Id_on (alphabet A), ???\\<rangle> nba_rel? *)"], ["", "definition op_translate :: \"('label, 'state) nba \\<Rightarrow> ('label, nat) nbae nres\" where\n    \"op_translate A \\<equiv> SPEC (\\<lambda> B. \\<exists> f. inj_on f (nodes A) \\<and> B = nba_nbae (nba_image f A))\""], ["", "lemma op_translate_language:\n    assumes \"(RETURN Ai, op_translate A) \\<in> \\<langle>\\<langle>Id, nat_rel\\<rangle> nbaei_nbae_rel\\<rangle> nres_rel\"\n    shows \"language (nbae_nba (nbaei_nbae Ai)) = language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "(* TODO: can we leave all this inside the nres without explicit obtain? *)"], ["proof (state)\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "obtain f where 1:\n      \"(Ai, nba_nbae (nba_image f A)) \\<in> \\<langle>Id, nat_rel\\<rangle> nbaei_nbae_rel\" \"inj_on f (nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>(Ai, nba_nbae (nba_image f A)) \\<in> \\<langle>Id,\n                 nat_rel\\<rangle>nbaei_nbae_rel;\n         inj_on f (nodes A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms[unfolded in_nres_rel_iff op_translate_def, THEN RETURN_ref_SPECD]"], ["proof (prove)\nusing this:\n  (\\<And>a.\n      \\<lbrakk>(Ai, a) \\<in> \\<langle>Id, nat_rel\\<rangle>nbaei_nbae_rel;\n       \\<exists>f.\n          inj_on f (nodes A) \\<and> a = nba_nbae (nba_image f A)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>(Ai, nba_nbae (nba_image f A)) \\<in> \\<langle>Id,\n                 nat_rel\\<rangle>nbaei_nbae_rel;\n         inj_on f (nodes A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (Ai, nba_nbae (nba_image f A)) \\<in> \\<langle>Id,\n  nat_rel\\<rangle>nbaei_nbae_rel\n  inj_on f (nodes A)\n\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "let ?C = \"nba_image f A\""], ["proof (state)\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "have \"(nbae_nba (nbaei_nbae Ai), nbae_nba (id (nba_nbae ?C))) \\<in> \\<langle>Id, nat_rel\\<rangle> nba_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nbae_nba (nbaei_nbae Ai), nbae_nba (id (nba_nbae (nba_image f A))))\n    \\<in> \\<langle>Id, nat_rel\\<rangle>nba_rel", "using 1(1)"], ["proof (prove)\nusing this:\n  (Ai, nba_nbae (nba_image f A)) \\<in> \\<langle>Id,\n  nat_rel\\<rangle>nbaei_nbae_rel\n\ngoal (1 subgoal):\n 1. (nbae_nba (nbaei_nbae Ai), nbae_nba (id (nba_nbae (nba_image f A))))\n    \\<in> \\<langle>Id, nat_rel\\<rangle>nba_rel", "by parametricity auto"], ["proof (state)\nthis:\n  (nbae_nba (nbaei_nbae Ai), nbae_nba (id (nba_nbae (nba_image f A))))\n  \\<in> \\<langle>Id, nat_rel\\<rangle>nba_rel\n\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "also"], ["proof (state)\nthis:\n  (nbae_nba (nbaei_nbae Ai), nbae_nba (id (nba_nbae (nba_image f A))))\n  \\<in> \\<langle>Id, nat_rel\\<rangle>nba_rel\n\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "have \"nbae_nba (id (nba_nbae ?C)) = (nbae_nba \\<circ> nba_nbae) ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nbae_nba (id (nba_nbae (nba_image f A))) =\n    (nbae_nba \\<circ> nba_nbae) (nba_image f A)", "by simp"], ["proof (state)\nthis:\n  nbae_nba (id (nba_nbae (nba_image f A))) =\n  (nbae_nba \\<circ> nba_nbae) (nba_image f A)\n\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "also"], ["proof (state)\nthis:\n  nbae_nba (id (nba_nbae (nba_image f A))) =\n  (nbae_nba \\<circ> nba_nbae) (nba_image f A)\n\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "have \"(\\<dots>, id ?C) \\<in> \\<langle>Id_on (alphabet ?C), Id_on (nodes ?C)\\<rangle> nba_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((nbae_nba \\<circ> nba_nbae) (nba_image f A), id (nba_image f A))\n    \\<in> \\<langle>Id_on (alphabet (nba_image f A)),\n    Id_on (nodes (nba_image f A))\\<rangle>nba_rel", "by parametricity"], ["proof (state)\nthis:\n  ((nbae_nba \\<circ> nba_nbae) (nba_image f A), id (nba_image f A))\n  \\<in> \\<langle>Id_on (alphabet (nba_image f A)),\n  Id_on (nodes (nba_image f A))\\<rangle>nba_rel\n\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "finally"], ["proof (chain)\npicking this:\n  (nbae_nba (nbaei_nbae Ai), id (nba_image f A))\n  \\<in> \\<langle>Id O Id_on (alphabet (nba_image f A)),\n  nat_rel O Id_on (nodes (nba_image f A))\\<rangle>nba_rel", "have 2: \"(nbae_nba (nbaei_nbae Ai), ?C) \\<in>\n      \\<langle>Id_on (alphabet ?C), Id_on (nodes ?C)\\<rangle> nba_rel\""], ["proof (prove)\nusing this:\n  (nbae_nba (nbaei_nbae Ai), id (nba_image f A))\n  \\<in> \\<langle>Id O Id_on (alphabet (nba_image f A)),\n  nat_rel O Id_on (nodes (nba_image f A))\\<rangle>nba_rel\n\ngoal (1 subgoal):\n 1. (nbae_nba (nbaei_nbae Ai), nba_image f A)\n    \\<in> \\<langle>Id_on (alphabet (nba_image f A)),\n    Id_on (nodes (nba_image f A))\\<rangle>nba_rel", "by simp"], ["proof (state)\nthis:\n  (nbae_nba (nbaei_nbae Ai), nba_image f A)\n  \\<in> \\<langle>Id_on (alphabet (nba_image f A)),\n  Id_on (nodes (nba_image f A))\\<rangle>nba_rel\n\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "have \"(language (nbae_nba (nbaei_nbae Ai)), language ?C) \\<in>\n      \\<langle>\\<langle>Id_on (alphabet ?C)\\<rangle> stream_rel\\<rangle> set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (language (nbae_nba (nbaei_nbae Ai)), language (nba_image f A))\n    \\<in> \\<langle>\\<langle>Id_on\n                             (alphabet\n                               (nba_image f\n                                 A))\\<rangle>stream_rel\\<rangle>set_rel", "using 2"], ["proof (prove)\nusing this:\n  (nbae_nba (nbaei_nbae Ai), nba_image f A)\n  \\<in> \\<langle>Id_on (alphabet (nba_image f A)),\n  Id_on (nodes (nba_image f A))\\<rangle>nba_rel\n\ngoal (1 subgoal):\n 1. (language (nbae_nba (nbaei_nbae Ai)), language (nba_image f A))\n    \\<in> \\<langle>\\<langle>Id_on\n                             (alphabet\n                               (nba_image f\n                                 A))\\<rangle>stream_rel\\<rangle>set_rel", "by parametricity"], ["proof (state)\nthis:\n  (language (nbae_nba (nbaei_nbae Ai)), language (nba_image f A))\n  \\<in> \\<langle>\\<langle>Id_on\n                           (alphabet\n                             (nba_image f\n                               A))\\<rangle>stream_rel\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "also"], ["proof (state)\nthis:\n  (language (nbae_nba (nbaei_nbae Ai)), language (nba_image f A))\n  \\<in> \\<langle>\\<langle>Id_on\n                           (alphabet\n                             (nba_image f\n                               A))\\<rangle>stream_rel\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "have \"language ?C = language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language (nba_image f A) = language A", "using 1(2)"], ["proof (prove)\nusing this:\n  inj_on f (nodes A)\n\ngoal (1 subgoal):\n 1. language (nba_image f A) = language A", "by simp"], ["proof (state)\nthis:\n  language (nba_image f A) = language A\n\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "finally"], ["proof (chain)\npicking this:\n  (language (nbae_nba (nbaei_nbae Ai)), language A)\n  \\<in> \\<langle>\\<langle>Id_on\n                           (alphabet\n                             (nba_image f\n                               A))\\<rangle>stream_rel\\<rangle>set_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (language (nbae_nba (nbaei_nbae Ai)), language A)\n  \\<in> \\<langle>\\<langle>Id_on\n                           (alphabet\n                             (nba_image f\n                               A))\\<rangle>stream_rel\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. language (nbae_nba (nbaei_nbae Ai)) = language A", "by simp"], ["proof (state)\nthis:\n  language (nbae_nba (nbaei_nbae Ai)) = language A\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: make separate implementations for \"nba_nbae\" and \"op_set_enumerate \\<bind> nbae_image\"\n    make sure to do regression tests along the way *)\n  (* TODO: since we have translate_impl, maybe just having a good nba_nbae implementation is enough? *)"], ["", "schematic_goal to_nbaei_impl:\n    fixes S :: \"('statei \\<times> 'state) set\"\n    assumes [simp]: \"finite (nodes A)\"\n    assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhc\"\n    assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n    assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n    assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel\"\n    shows \"(?f :: ?'a, do {\n        let N = nodes A;\n        f \\<leftarrow> op_set_enumerate N;\n        ASSERT (dom f = N);\n        ASSERT (\\<forall> p \\<in> initial A. f p \\<noteq> None);\n        ASSERT (\\<forall> a \\<in> alphabet A. \\<forall> p \\<in> dom f. \\<forall> q \\<in> transition A a p. f q \\<noteq> None);\n        T \\<leftarrow> trans_algo N (alphabet A) (transition A) (\\<lambda> x. the (f x));\n        RETURN (nbae (alphabet A) ((\\<lambda> x. the (f x)) ` initial A) T\n          ((\\<lambda> x. the (f x)) ` {p \\<in> N. accepting A p}))\n      }) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     let N = nodes A\n     in op_set_enumerate N \\<bind>\n        (\\<lambda>f.\n            ASSERT (dom f = N) \\<bind>\n            (\\<lambda>_.\n                ASSERT (\\<forall>p\\<in>initial A. f p \\<noteq> None) \\<bind>\n                (\\<lambda>_.\n                    ASSERT\n                     (\\<forall>a\\<in>alphabet A.\n                         \\<forall>p\\<in>dom f.\n                            \\<forall>q\\<in>transition A a p.\n                               f q \\<noteq> None) \\<bind>\n                    (\\<lambda>_.\n                        trans_algo N (alphabet A) (transition A)\n                         (\\<lambda>x. the (f x)) \\<bind>\n                        (\\<lambda>T.\n                            RETURN\n                             (nbae (alphabet A)\n                               ((\\<lambda>x. the (f x)) ` initial A) T\n                               ((\\<lambda>x. the (f x)) `\n                                {p \\<in> N. accepting A p}))))))))\n    \\<in> ?R", "unfolding trans_algo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     let N = nodes A\n     in op_set_enumerate N \\<bind>\n        (\\<lambda>f.\n            ASSERT (dom f = N) \\<bind>\n            (\\<lambda>_.\n                ASSERT (\\<forall>p\\<in>initial A. f p \\<noteq> None) \\<bind>\n                (\\<lambda>_.\n                    ASSERT\n                     (\\<forall>a\\<in>alphabet A.\n                         \\<forall>p\\<in>dom f.\n                            \\<forall>q\\<in>transition A a p.\n                               f q \\<noteq> None) \\<bind>\n                    (\\<lambda>_.\n                        FOREACH N\n                         (\\<lambda>p T.\n                             ASSERT (p \\<in> N) \\<bind>\n                             (\\<lambda>_.\n                                 FOREACH (alphabet A)\n                                  (\\<lambda>a T.\nASSERT (a \\<in> alphabet A) \\<bind>\n(\\<lambda>_.\n    FOREACH (transition A a p)\n     (\\<lambda>q T.\n         ASSERT (q \\<in> transition A a p) \\<bind>\n         (\\<lambda>_.\n             ASSERT ((the (f p), a, the (f q)) \\<notin> T) \\<bind>\n             (\\<lambda>_. RETURN (insert (the (f p), a, the (f q)) T))))\n     T))\n                                  T))\n                         {} \\<bind>\n                        (\\<lambda>T.\n                            RETURN\n                             (nbae (alphabet A)\n                               ((\\<lambda>x. the (f x)) ` initial A) T\n                               ((\\<lambda>x. the (f x)) `\n                                {p \\<in> N. accepting A p}))))))))\n    \\<in> ?R", "by (autoref_monadic (plain))"], ["", "concrete_definition to_nbaei_impl uses to_nbaei_impl"], ["", "context\n  begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "by this"], ["", "lemma to_nbaei_impl_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel\"\n      shows \"(RETURN (to_nbaei_impl seq bhc hms Ai),\n        (OP op_translate ::: \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L, nat_rel\\<rangle> nbaei_nbae_rel\\<rangle> nres_rel) $ A) \\<in>\n        \\<langle>\\<langle>L, nat_rel\\<rangle> nbaei_nbae_rel\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "have 1: \"finite (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (alphabet A)", "using nbai_nba_param(2)[param_fo, OF assms(5)] list_set_rel_finite"], ["proof (prove)\nusing this:\n  (alphabeti Ai, alphabet A) \\<in> \\<langle>L\\<rangle>list_set_rel\n  finite_set_rel (\\<langle>?R\\<rangle>list_set_rel)\n\ngoal (1 subgoal):\n 1. finite (alphabet A)", "unfolding finite_set_rel_def"], ["proof (prove)\nusing this:\n  (alphabeti Ai, alphabet A) \\<in> \\<langle>L\\<rangle>list_set_rel\n  Range (\\<langle>?R\\<rangle>list_set_rel) \\<subseteq> Collect finite\n\ngoal (1 subgoal):\n 1. finite (alphabet A)", "by auto"], ["proof (state)\nthis:\n  finite (alphabet A)\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "note to_nbaei_impl.refine[OF assms[unfolded autoref_tag_defs]]"], ["proof (state)\nthis:\n  (RETURN (to_nbaei_impl seq bhc hms Ai),\n   let N = nodes A\n   in op_set_enumerate N \\<bind>\n      (\\<lambda>f.\n          ASSERT (dom f = N) \\<bind>\n          (\\<lambda>_.\n              ASSERT (\\<forall>p\\<in>initial A. f p \\<noteq> None) \\<bind>\n              (\\<lambda>_.\n                  ASSERT\n                   (\\<forall>a\\<in>alphabet A.\n                       \\<forall>p\\<in>dom f.\n                          \\<forall>q\\<in>transition A a p.\n                             f q \\<noteq> None) \\<bind>\n                  (\\<lambda>_.\n                      trans_algo N (alphabet A) (transition A)\n                       (\\<lambda>x. the (f x)) \\<bind>\n                      (\\<lambda>T.\n                          RETURN\n                           (nbae (alphabet A)\n                             ((\\<lambda>x. the (f x)) ` initial A) T\n                             ((\\<lambda>x. the (f x)) `\n                              {p \\<in> N. accepting A p}))))))))\n  \\<in> \\<langle>\\<langle>L, nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  (RETURN (to_nbaei_impl seq bhc hms Ai),\n   let N = nodes A\n   in op_set_enumerate N \\<bind>\n      (\\<lambda>f.\n          ASSERT (dom f = N) \\<bind>\n          (\\<lambda>_.\n              ASSERT (\\<forall>p\\<in>initial A. f p \\<noteq> None) \\<bind>\n              (\\<lambda>_.\n                  ASSERT\n                   (\\<forall>a\\<in>alphabet A.\n                       \\<forall>p\\<in>dom f.\n                          \\<forall>q\\<in>transition A a p.\n                             f q \\<noteq> None) \\<bind>\n                  (\\<lambda>_.\n                      trans_algo N (alphabet A) (transition A)\n                       (\\<lambda>x. the (f x)) \\<bind>\n                      (\\<lambda>T.\n                          RETURN\n                           (nbae (alphabet A)\n                             ((\\<lambda>x. the (f x)) ` initial A) T\n                             ((\\<lambda>x. the (f x)) `\n                              {p \\<in> N. accepting A p}))))))))\n  \\<in> \\<langle>\\<langle>L, nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "have \"(do {\n          let N = nodes A;\n          f \\<leftarrow> op_set_enumerate N;\n          ASSERT (dom f = N);\n          ASSERT (\\<forall> p \\<in> initial A. f p \\<noteq> None);\n          ASSERT (\\<forall> a \\<in> alphabet A. \\<forall> p \\<in> dom f. \\<forall> q \\<in> transition A a p. f q \\<noteq> None);\n          T \\<leftarrow> trans_algo N (alphabet A) (transition A) (\\<lambda> x. the (f x));\n          RETURN (nbae (alphabet A) ((\\<lambda> x. the (f x)) ` initial A) T ((\\<lambda> x. the (f x)) ` {p \\<in> N. accepting A p}))\n        }, do {\n          f \\<leftarrow> op_set_enumerate (nodes A);\n          T \\<leftarrow> SPEC (HOL.eq (trans_spec A (\\<lambda> x. the (f x))));\n          RETURN (nbae (alphabet A) ((\\<lambda> x. the (f x)) ` initial A) T ((\\<lambda> x. the (f x)) ` {p \\<in> nodes A. accepting A p}))\n        }) \\<in> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let N = nodes A\n     in op_set_enumerate N \\<bind>\n        (\\<lambda>f.\n            ASSERT (dom f = N) \\<bind>\n            (\\<lambda>_.\n                ASSERT (\\<forall>p\\<in>initial A. f p \\<noteq> None) \\<bind>\n                (\\<lambda>_.\n                    ASSERT\n                     (\\<forall>a\\<in>alphabet A.\n                         \\<forall>p\\<in>dom f.\n                            \\<forall>q\\<in>transition A a p.\n                               f q \\<noteq> None) \\<bind>\n                    (\\<lambda>_.\n                        trans_algo N (alphabet A) (transition A)\n                         (\\<lambda>x. the (f x)) \\<bind>\n                        (\\<lambda>T.\n                            RETURN\n                             (nbae (alphabet A)\n                               ((\\<lambda>x. the (f x)) ` initial A) T\n                               ((\\<lambda>x. the (f x)) `\n                                {p \\<in> N. accepting A p}))))))),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f.\n         SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n         (\\<lambda>T.\n             RETURN\n              (nbae (alphabet A) ((\\<lambda>x. the (f x)) ` initial A) T\n                ((\\<lambda>x. the (f x)) `\n                 {p \\<in> nodes A. accepting A p})))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding Let_def comp_apply op_set_enumerate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPEC (\\<lambda>f. dom f = nodes A \\<and> inj_on f (nodes A)) \\<bind>\n     (\\<lambda>f.\n         ASSERT (dom f = nodes A) \\<bind>\n         (\\<lambda>_.\n             ASSERT (\\<forall>p\\<in>initial A. f p \\<noteq> None) \\<bind>\n             (\\<lambda>_.\n                 ASSERT\n                  (\\<forall>a\\<in>alphabet A.\n                      \\<forall>p\\<in>dom f.\n                         \\<forall>q\\<in>transition A a p.\n                            f q \\<noteq> None) \\<bind>\n                 (\\<lambda>_.\n                     trans_algo (nodes A) (alphabet A) (transition A)\n                      (\\<lambda>x. the (f x)) \\<bind>\n                     (\\<lambda>T.\n                         RETURN\n                          (nbae (alphabet A)\n                            ((\\<lambda>x. the (f x)) ` initial A) T\n                            ((\\<lambda>x. the (f x)) `\n                             {p \\<in> nodes A. accepting A p}))))))),\n     SPEC (\\<lambda>f. dom f = nodes A \\<and> inj_on f (nodes A)) \\<bind>\n     (\\<lambda>f.\n         SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n         (\\<lambda>T.\n             RETURN\n              (nbae (alphabet A) ((\\<lambda>x. the (f x)) ` initial A) T\n                ((\\<lambda>x. the (f x)) `\n                 {p \\<in> nodes A. accepting A p})))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "using assms(1) 1"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (finite (nodes A))\n  finite (alphabet A)\n\ngoal (1 subgoal):\n 1. (SPEC (\\<lambda>f. dom f = nodes A \\<and> inj_on f (nodes A)) \\<bind>\n     (\\<lambda>f.\n         ASSERT (dom f = nodes A) \\<bind>\n         (\\<lambda>_.\n             ASSERT (\\<forall>p\\<in>initial A. f p \\<noteq> None) \\<bind>\n             (\\<lambda>_.\n                 ASSERT\n                  (\\<forall>a\\<in>alphabet A.\n                      \\<forall>p\\<in>dom f.\n                         \\<forall>q\\<in>transition A a p.\n                            f q \\<noteq> None) \\<bind>\n                 (\\<lambda>_.\n                     trans_algo (nodes A) (alphabet A) (transition A)\n                      (\\<lambda>x. the (f x)) \\<bind>\n                     (\\<lambda>T.\n                         RETURN\n                          (nbae (alphabet A)\n                            ((\\<lambda>x. the (f x)) ` initial A) T\n                            ((\\<lambda>x. the (f x)) `\n                             {p \\<in> nodes A. accepting A p}))))))),\n     SPEC (\\<lambda>f. dom f = nodes A \\<and> inj_on f (nodes A)) \\<bind>\n     (\\<lambda>f.\n         SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n         (\\<lambda>T.\n             RETURN\n              (nbae (alphabet A) ((\\<lambda>x. the (f x)) ` initial A) T\n                ((\\<lambda>x. the (f x)) `\n                 {p \\<in> nodes A. accepting A p})))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "by (refine_vcg vcg0[OF trans_algo_refine]) (auto intro!: inj_on_map_the[unfolded comp_apply])"], ["proof (state)\nthis:\n  (let N = nodes A\n   in op_set_enumerate N \\<bind>\n      (\\<lambda>f.\n          ASSERT (dom f = N) \\<bind>\n          (\\<lambda>_.\n              ASSERT (\\<forall>p\\<in>initial A. f p \\<noteq> None) \\<bind>\n              (\\<lambda>_.\n                  ASSERT\n                   (\\<forall>a\\<in>alphabet A.\n                       \\<forall>p\\<in>dom f.\n                          \\<forall>q\\<in>transition A a p.\n                             f q \\<noteq> None) \\<bind>\n                  (\\<lambda>_.\n                      trans_algo N (alphabet A) (transition A)\n                       (\\<lambda>x. the (f x)) \\<bind>\n                      (\\<lambda>T.\n                          RETURN\n                           (nbae (alphabet A)\n                             ((\\<lambda>x. the (f x)) ` initial A) T\n                             ((\\<lambda>x. the (f x)) `\n                              {p \\<in> N. accepting A p}))))))),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f.\n       SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n       (\\<lambda>T.\n           RETURN\n            (nbae (alphabet A) ((\\<lambda>x. the (f x)) ` initial A) T\n              ((\\<lambda>x. the (f x)) `\n               {p \\<in> nodes A. accepting A p})))))\n  \\<in> \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  (let N = nodes A\n   in op_set_enumerate N \\<bind>\n      (\\<lambda>f.\n          ASSERT (dom f = N) \\<bind>\n          (\\<lambda>_.\n              ASSERT (\\<forall>p\\<in>initial A. f p \\<noteq> None) \\<bind>\n              (\\<lambda>_.\n                  ASSERT\n                   (\\<forall>a\\<in>alphabet A.\n                       \\<forall>p\\<in>dom f.\n                          \\<forall>q\\<in>transition A a p.\n                             f q \\<noteq> None) \\<bind>\n                  (\\<lambda>_.\n                      trans_algo N (alphabet A) (transition A)\n                       (\\<lambda>x. the (f x)) \\<bind>\n                      (\\<lambda>T.\n                          RETURN\n                           (nbae (alphabet A)\n                             ((\\<lambda>x. the (f x)) ` initial A) T\n                             ((\\<lambda>x. the (f x)) `\n                              {p \\<in> N. accepting A p}))))))),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f.\n       SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n       (\\<lambda>T.\n           RETURN\n            (nbae (alphabet A) ((\\<lambda>x. the (f x)) ` initial A) T\n              ((\\<lambda>x. the (f x)) `\n               {p \\<in> nodes A. accepting A p})))))\n  \\<in> \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "have \"(do {\n          f \\<leftarrow> op_set_enumerate (nodes A);\n          T \\<leftarrow> SPEC (HOL.eq (trans_spec A (\\<lambda> x. the (f x))));\n          RETURN (nbae (alphabet A) ((\\<lambda> x. the (f x)) ` initial A) T ((\\<lambda> x. the (f x)) ` {p \\<in> nodes A. accepting A p}))\n        }, do {\n          f \\<leftarrow> op_set_enumerate (nodes A);\n          RETURN (nbae_image (the \\<circ> f) (nba_nbae A))\n        }) \\<in> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f.\n         SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n         (\\<lambda>T.\n             RETURN\n              (nbae (alphabet A) ((\\<lambda>x. the (f x)) ` initial A) T\n                ((\\<lambda>x. the (f x)) `\n                 {p \\<in> nodes A. accepting A p})))),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (nbae_image (the \\<circ> f) (nba_nbae A))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding trans_spec_def nbae_image_nba_nbae"], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f.\n         SPEC\n          ((=) (\\<Union>p\\<in>nodes A.\n                   \\<Union>a\\<in>alphabet A.\n                      (\\<lambda>x. the (f x)) ` {p} \\<times>\n                      {a} \\<times>\n                      (\\<lambda>x. the (f x)) ` transition A a p)) \\<bind>\n         (\\<lambda>T.\n             RETURN\n              (nbae (alphabet A) ((\\<lambda>x. the (f x)) ` initial A) T\n                ((\\<lambda>x. the (f x)) `\n                 {p \\<in> nodes A. accepting A p})))),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f.\n         RETURN\n          (nbae (alphabet A) ((the \\<circ> f) ` initial A)\n            (\\<Union>p\\<in>nodes A.\n                \\<Union>a\\<in>alphabet A.\n                   (the \\<circ> f) ` {p} \\<times>\n                   {a} \\<times> (the \\<circ> f) ` transition A a p)\n            ((the \\<circ> f) ` {p \\<in> nodes A. accepting A p}))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "by refine_vcg force"], ["proof (state)\nthis:\n  (op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f.\n       SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n       (\\<lambda>T.\n           RETURN\n            (nbae (alphabet A) ((\\<lambda>x. the (f x)) ` initial A) T\n              ((\\<lambda>x. the (f x)) `\n               {p \\<in> nodes A. accepting A p})))),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (nbae_image (the \\<circ> f) (nba_nbae A))))\n  \\<in> \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  (op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f.\n       SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n       (\\<lambda>T.\n           RETURN\n            (nbae (alphabet A) ((\\<lambda>x. the (f x)) ` initial A) T\n              ((\\<lambda>x. the (f x)) `\n               {p \\<in> nodes A. accepting A p})))),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (nbae_image (the \\<circ> f) (nba_nbae A))))\n  \\<in> \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "have \"(do {\n          f \\<leftarrow> op_set_enumerate (nodes A);\n          RETURN (nbae_image (the \\<circ> f) (nba_nbae A))\n        }, do {\n          f \\<leftarrow> op_set_enumerate (nodes A);\n          RETURN (nba_nbae (nba_image (the \\<circ> f) A))\n        }) \\<in> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (nbae_image (the \\<circ> f) (nba_nbae A))),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (nba_nbae (nba_image (the \\<circ> f) A))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding op_set_enumerate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPEC (\\<lambda>f. dom f = nodes A \\<and> inj_on f (nodes A)) \\<bind>\n     (\\<lambda>f. RETURN (nbae_image (the \\<circ> f) (nba_nbae A))),\n     SPEC (\\<lambda>f. dom f = nodes A \\<and> inj_on f (nodes A)) \\<bind>\n     (\\<lambda>f. RETURN (nba_nbae (nba_image (the \\<circ> f) A))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "by (refine_vcg) (simp add: inj_on_map_the nba_image_nbae)"], ["proof (state)\nthis:\n  (op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (nbae_image (the \\<circ> f) (nba_nbae A))),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (nba_nbae (nba_image (the \\<circ> f) A))))\n  \\<in> \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  (op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (nbae_image (the \\<circ> f) (nba_nbae A))),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (nba_nbae (nba_image (the \\<circ> f) A))))\n  \\<in> \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "have \"(do {\n          f \\<leftarrow> op_set_enumerate (nodes A);\n          RETURN (nba_nbae (nba_image (the \\<circ> f) A))\n        }, op_translate A) \\<in> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (nba_nbae (nba_image (the \\<circ> f) A))),\n     op_translate A)\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding op_set_enumerate_def op_translate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPEC (\\<lambda>f. dom f = nodes A \\<and> inj_on f (nodes A)) \\<bind>\n     (\\<lambda>f. RETURN (nba_nbae (nba_image (the \\<circ> f) A))),\n     SPEC\n      (\\<lambda>B.\n          \\<exists>f.\n             inj_on f (nodes A) \\<and> B = nba_nbae (nba_image f A)))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "by (refine_vcg) (metis Collect_mem_eq inj_on_map_the subset_Collect_conv)"], ["proof (state)\nthis:\n  (op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (nba_nbae (nba_image (the \\<circ> f) A))),\n   op_translate A)\n  \\<in> \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "finally"], ["proof (chain)\npicking this:\n  (RETURN (to_nbaei_impl seq bhc hms Ai), op_translate A)\n  \\<in> (((\\<langle>\\<langle>L,\n           nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel O\n           \\<langle>Id\\<rangle>nres_rel) O\n          \\<langle>Id\\<rangle>nres_rel) O\n         \\<langle>Id\\<rangle>nres_rel) O\n        \\<langle>Id\\<rangle>nres_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (RETURN (to_nbaei_impl seq bhc hms Ai), op_translate A)\n  \\<in> (((\\<langle>\\<langle>L,\n           nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel O\n           \\<langle>Id\\<rangle>nres_rel) O\n          \\<langle>Id\\<rangle>nres_rel) O\n         \\<langle>Id\\<rangle>nres_rel) O\n        \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "unfolding nres_rel_comp"], ["proof (prove)\nusing this:\n  (RETURN (to_nbaei_impl seq bhc hms Ai), op_translate A)\n  \\<in> \\<langle>(((\\<langle>L, nat_rel\\<rangle>nbaei_nbae_rel O Id) O Id) O\n                  Id) O\n                 Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_nbaei_impl seq bhc hms Ai),\n     (OP op_translate :::\n      \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n      nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n     A)\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel", "by simp"], ["proof (state)\nthis:\n  (RETURN (to_nbaei_impl seq bhc hms Ai),\n   (OP op_translate :::\n    \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel) $\n   A)\n  \\<in> \\<langle>\\<langle>L, nat_rel\\<rangle>nbaei_nbae_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}