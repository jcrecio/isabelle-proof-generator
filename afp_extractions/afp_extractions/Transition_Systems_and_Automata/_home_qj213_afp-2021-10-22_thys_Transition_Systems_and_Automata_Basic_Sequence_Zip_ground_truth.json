{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Basic/Sequence_Zip.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemmas [simp] = zip_map_fst_snd", "lemma split_zip[no_atp]: \"(\\<And> x. PROP P x) \\<equiv> (\\<And> y z. length y = length z \\<Longrightarrow> PROP P (y || z))\"", "lemma split_zip_all[no_atp]: \"(\\<forall> x. P x) \\<longleftrightarrow> (\\<forall> y z. length y = length z \\<longrightarrow> P (y || z))\"", "lemma split_zip_ex[no_atp]: \"(\\<exists> x. P x) \\<longleftrightarrow> (\\<exists> y z. length y = length z \\<and> P (y || z))\"", "lemma zip_eq[iff]:\n    assumes \"length u = length v\" \"length r = length s\"\n    shows \"u || v = r || s \\<longleftrightarrow> u = r \\<and> v = s\"", "lemma list_rel_pred_zip: \"list_all2 P xs ys \\<longleftrightarrow> length xs = length ys \\<and> list_all (case_prod P) (xs || ys)\"", "lemma list_choice_zip: \"list_all (\\<lambda> x. \\<exists> y. P x y) xs \\<longleftrightarrow>\n    (\\<exists> ys. length ys = length xs \\<and> list_all (case_prod P) (xs || ys))\"", "lemma list_choice_pair: \"list_all (\\<lambda> xy. case_prod (\\<lambda> x y. \\<exists> z. P x y z) xy) (xs || ys) \\<longleftrightarrow>\n    (\\<exists> zs. length zs = min (length xs) (length ys) \\<and> list_all (\\<lambda> (x, y, z). P x y z) (xs || ys || zs))\"", "lemma list_rel_zip[iff]:\n    assumes \"length u = length v\" \"length r = length s\"\n    shows \"list_all2 (rel_prod A B) (u || v) (r || s) \\<longleftrightarrow> list_all2 A u r \\<and> list_all2 B v s\"", "lemma zip_last[simp]:\n    assumes \"xs || ys \\<noteq> []\" \"length xs = length ys\"\n    shows \"last (xs || ys) = (last xs, last ys)\"", "lemmas [simp] = szip_unfold", "lemma smap_szip_same: \"smap f (xs ||| xs) = smap (\\<lambda> x. f (x, x)) xs\"", "lemma szip_smap[simp]: \"smap fst zs ||| smap snd zs = zs\"", "lemma szip_smap_fst[simp]: \"smap fst (xs ||| ys) = xs\"", "lemma szip_smap_snd[simp]: \"smap snd (xs ||| ys) = ys\"", "lemma szip_smap_both: \"smap f xs ||| smap g ys = smap (map_prod f g) (xs ||| ys)\"", "lemma szip_smap_left: \"smap f xs ||| ys = smap (apfst f) (xs ||| ys)\"", "lemma szip_smap_right: \"xs ||| smap f ys = smap (apsnd f) (xs ||| ys)\"", "lemmas szip_smap_fold = szip_smap_both szip_smap_left szip_smap_right", "lemma szip_sconst_smap_fst: \"sconst a ||| xs = smap (Pair a) xs\"", "lemma szip_sconst_smap_snd: \"xs ||| sconst a = smap (prod.swap \\<circ> Pair a) xs\"", "lemma split_szip[no_atp]: \"(\\<And> x. PROP P x) \\<equiv> (\\<And> y z. PROP P (y ||| z))\"", "lemma split_szip_all[no_atp]: \"(\\<forall> x. P x) \\<longleftrightarrow> (\\<forall> y z. P (y ||| z))\"", "lemma split_szip_ex[no_atp]: \"(\\<exists> x. P x) \\<longleftrightarrow> (\\<exists> y z. P (y ||| z))\"", "lemma szip_eq[iff]: \"u ||| v = r ||| s \\<longleftrightarrow> u = r \\<and> v = s\"", "lemma stream_rel_szip[iff]:\n    \"stream_all2 (rel_prod A B) (u ||| v) (r ||| s) \\<longleftrightarrow> stream_all2 A u r \\<and> stream_all2 B v s\"", "lemma szip_shift[simp]:\n    assumes \"length u = length s\"\n    shows \"u @- v ||| s @- t = (u || s) @- (v ||| t)\"", "lemma szip_sset_fst[simp]: \"fst ` sset (u ||| v) = sset u\"", "lemma szip_sset_snd[simp]: \"snd ` sset (u ||| v) = sset v\"", "lemma szip_sset_elim[elim]:\n    assumes \"(a, b) \\<in> sset (u ||| v)\"\n    obtains \"a \\<in> sset u\" \"b \\<in> sset v\"", "lemma szip_sset[simp]: \"sset (u ||| v) \\<subseteq> sset u \\<times> sset v\"", "lemma sset_szip_finite[iff]: \"finite (sset (u ||| v)) \\<longleftrightarrow> finite (sset u) \\<and> finite (sset v)\"", "lemma infs_szip_fst[iff]: \"infs (P \\<circ> fst) (u ||| v) \\<longleftrightarrow> infs P u\"", "lemma infs_szip_snd[iff]: \"infs (P \\<circ> snd) (u ||| v) \\<longleftrightarrow> infs P v\""], "translations": [["", "lemmas [simp] = zip_map_fst_snd"], ["", "lemma split_zip[no_atp]: \"(\\<And> x. PROP P x) \\<equiv> (\\<And> y z. length y = length z \\<Longrightarrow> PROP P (y || z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. PROP P x) \\<equiv>\n    (\\<And>y z. length y = length z \\<Longrightarrow> PROP P (y || z))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>\\<And>x. PROP P x; length y = length z\\<rbrakk>\n       \\<Longrightarrow> PROP P (y || z)\n 2. \\<And>x.\n       (\\<And>y z.\n           length y = length z \\<Longrightarrow>\n           PROP P (y || z)) \\<Longrightarrow>\n       PROP P x", "fix y z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>\\<And>x. PROP P x; length y = length z\\<rbrakk>\n       \\<Longrightarrow> PROP P (y || z)\n 2. \\<And>x.\n       (\\<And>y z.\n           length y = length z \\<Longrightarrow>\n           PROP P (y || z)) \\<Longrightarrow>\n       PROP P x", "assume 1: \"\\<And> x. PROP P x\""], ["proof (state)\nthis:\n  PROP P ?x\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>\\<And>x. PROP P x; length y = length z\\<rbrakk>\n       \\<Longrightarrow> PROP P (y || z)\n 2. \\<And>x.\n       (\\<And>y z.\n           length y = length z \\<Longrightarrow>\n           PROP P (y || z)) \\<Longrightarrow>\n       PROP P x", "show \"PROP P (y || z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROP P (y || z)", "using 1"], ["proof (prove)\nusing this:\n  PROP P ?x\n\ngoal (1 subgoal):\n 1. PROP P (y || z)", "by this"], ["proof (state)\nthis:\n  PROP P (y || z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y z.\n           length y = length z \\<Longrightarrow>\n           PROP P (y || z)) \\<Longrightarrow>\n       PROP P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y z.\n           length y = length z \\<Longrightarrow>\n           PROP P (y || z)) \\<Longrightarrow>\n       PROP P x", "fix x :: \"('a \\<times> 'b) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y z.\n           length y = length z \\<Longrightarrow>\n           PROP P (y || z)) \\<Longrightarrow>\n       PROP P x", "assume 1: \"\\<And> y z. length y = length z \\<Longrightarrow> PROP P (y || z)\""], ["proof (state)\nthis:\n  length ?y = length ?z \\<Longrightarrow> PROP P (?y || ?z)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y z.\n           length y = length z \\<Longrightarrow>\n           PROP P (y || z)) \\<Longrightarrow>\n       PROP P x", "have 2: \"length (map fst x) = length (map snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map fst x) = length (map snd x)", "by simp"], ["proof (state)\nthis:\n  length (map fst x) = length (map snd x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y z.\n           length y = length z \\<Longrightarrow>\n           PROP P (y || z)) \\<Longrightarrow>\n       PROP P x", "have 3: \"PROP P (map fst x || map snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROP P (map fst x || map snd x)", "using 1 2"], ["proof (prove)\nusing this:\n  length ?y = length ?z \\<Longrightarrow> PROP P (?y || ?z)\n  length (map fst x) = length (map snd x)\n\ngoal (1 subgoal):\n 1. PROP P (map fst x || map snd x)", "by this"], ["proof (state)\nthis:\n  PROP P (map fst x || map snd x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y z.\n           length y = length z \\<Longrightarrow>\n           PROP P (y || z)) \\<Longrightarrow>\n       PROP P x", "show \"PROP P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROP P x", "using 3"], ["proof (prove)\nusing this:\n  PROP P (map fst x || map snd x)\n\ngoal (1 subgoal):\n 1. PROP P x", "by simp"], ["proof (state)\nthis:\n  PROP P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_zip_all[no_atp]: \"(\\<forall> x. P x) \\<longleftrightarrow> (\\<forall> y z. length y = length z \\<longrightarrow> P (y || z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. P x) =\n    (\\<forall>y z. length y = length z \\<longrightarrow> P (y || z))", "by (fastforce iff: split_zip)"], ["", "lemma split_zip_ex[no_atp]: \"(\\<exists> x. P x) \\<longleftrightarrow> (\\<exists> y z. length y = length z \\<and> P (y || z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. P x) =\n    (\\<exists>y z. length y = length z \\<and> P (y || z))", "by (fastforce iff: split_zip)"], ["", "lemma zip_eq[iff]:\n    assumes \"length u = length v\" \"length r = length s\"\n    shows \"u || v = r || s \\<longleftrightarrow> u = r \\<and> v = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u || v = r || s) = (u = r \\<and> v = s)", "using assms zip_eq_conv"], ["proof (prove)\nusing this:\n  length u = length v\n  length r = length s\n  length ?xs = length ?ys \\<Longrightarrow>\n  (?xs || ?ys = ?zs) = (map fst ?zs = ?xs \\<and> map snd ?zs = ?ys)\n\ngoal (1 subgoal):\n 1. (u || v = r || s) = (u = r \\<and> v = s)", "by metis"], ["", "lemma list_rel_pred_zip: \"list_all2 P xs ys \\<longleftrightarrow> length xs = length ys \\<and> list_all (case_prod P) (xs || ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 P xs ys =\n    (length xs = length ys \\<and>\n     list_all (\\<lambda>(x, y). P x y) (xs || ys))", "unfolding list_all2_conv_all_nth list_all_length"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs = length ys \\<and>\n     (\\<forall>i<length xs. P (xs ! i) (ys ! i))) =\n    (length xs = length ys \\<and>\n     (\\<forall>n<length (xs || ys).\n         case (xs || ys) ! n of (x, xa) \\<Rightarrow> P x xa))", "by auto"], ["", "lemma list_choice_zip: \"list_all (\\<lambda> x. \\<exists> y. P x y) xs \\<longleftrightarrow>\n    (\\<exists> ys. length ys = length xs \\<and> list_all (case_prod P) (xs || ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. \\<exists>y. P x y) xs =\n    (\\<exists>ys.\n        length ys = length xs \\<and>\n        list_all (\\<lambda>(x, y). P x y) (xs || ys))", "unfolding list_choice list_rel_pred_zip"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ys.\n        length xs = length ys \\<and>\n        list_all (\\<lambda>(x, y). P x y) (xs || ys)) =\n    (\\<exists>ys.\n        length ys = length xs \\<and>\n        list_all (\\<lambda>(x, y). P x y) (xs || ys))", "by metis"], ["", "lemma list_choice_pair: \"list_all (\\<lambda> xy. case_prod (\\<lambda> x y. \\<exists> z. P x y z) xy) (xs || ys) \\<longleftrightarrow>\n    (\\<exists> zs. length zs = min (length xs) (length ys) \\<and> list_all (\\<lambda> (x, y, z). P x y z) (xs || ys || zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>xy. case xy of (x, y) \\<Rightarrow> \\<exists>z. P x y z)\n     (xs || ys) =\n    (\\<exists>zs.\n        length zs = min (length xs) (length ys) \\<and>\n        list_all (\\<lambda>(x, y, z). P x y z) (xs || ys || zs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>xy. case xy of (x, y) \\<Rightarrow> \\<exists>z. P x y z)\n     (xs || ys) =\n    (\\<exists>zs.\n        length zs = min (length xs) (length ys) \\<and>\n        list_all (\\<lambda>(x, y, z). P x y z) (xs || ys || zs))", "have 1: \"list_all (\\<lambda> (xy, z). case xy of (x, y) \\<Rightarrow> P x y z) ((xs || ys) || zs) \\<longleftrightarrow>\n      list_all (\\<lambda> (x, y, z). P x y z) (xs || ys || zs)\" for zs"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(xy, z). case xy of (x, y) \\<Rightarrow> P x y z)\n     ((xs || ys) || zs) =\n    list_all (\\<lambda>(x, y, z). P x y z) (xs || ys || zs)", "unfolding zip_assoc list.pred_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(xy, z). case xy of (x, y) \\<Rightarrow> P x y z)\n     ((xs || ys) || zs) =\n    list_all\n     ((\\<lambda>(x, xa, y). P x xa y) \\<circ>\n      (\\<lambda>((x, y), z). (x, y, z)))\n     ((xs || ys) || zs)", "by (auto intro!: list.pred_cong)"], ["proof (state)\nthis:\n  list_all (\\<lambda>(xy, z). case xy of (x, y) \\<Rightarrow> P x y z)\n   ((xs || ys) || ?zs) =\n  list_all (\\<lambda>(x, y, z). P x y z) (xs || ys || ?zs)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>xy. case xy of (x, y) \\<Rightarrow> \\<exists>z. P x y z)\n     (xs || ys) =\n    (\\<exists>zs.\n        length zs = min (length xs) (length ys) \\<and>\n        list_all (\\<lambda>(x, y, z). P x y z) (xs || ys || zs))", "have 2: \"(\\<lambda> (x, y). \\<exists> z. P x y z) = (\\<lambda> xy. \\<exists> z. case xy of (x, y) \\<Rightarrow> P x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). \\<exists>z. P x y z) =\n    (\\<lambda>xy. \\<exists>z. case xy of (x, y) \\<Rightarrow> P x y z)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). \\<exists>z. P x y z) =\n  (\\<lambda>xy. \\<exists>z. case xy of (x, y) \\<Rightarrow> P x y z)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>xy. case xy of (x, y) \\<Rightarrow> \\<exists>z. P x y z)\n     (xs || ys) =\n    (\\<exists>zs.\n        length zs = min (length xs) (length ys) \\<and>\n        list_all (\\<lambda>(x, y, z). P x y z) (xs || ys || zs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>xy. case xy of (x, y) \\<Rightarrow> \\<exists>z. P x y z)\n     (xs || ys) =\n    (\\<exists>zs.\n        length zs = min (length xs) (length ys) \\<and>\n        list_all (\\<lambda>(x, y, z). P x y z) (xs || ys || zs))", "unfolding list_choice_zip 1 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ysa.\n        length ysa = length (xs || ys) \\<and>\n        list_all (\\<lambda>(x, xa, y). P x xa y) (xs || ys || ysa)) =\n    (\\<exists>zs.\n        length zs = min (length xs) (length ys) \\<and>\n        list_all (\\<lambda>(x, y, z). P x y z) (xs || ys || zs))", "by force"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>xy. case xy of (x, y) \\<Rightarrow> \\<exists>z. P x y z)\n   (xs || ys) =\n  (\\<exists>zs.\n      length zs = min (length xs) (length ys) \\<and>\n      list_all (\\<lambda>(x, y, z). P x y z) (xs || ys || zs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_rel_zip[iff]:\n    assumes \"length u = length v\" \"length r = length s\"\n    shows \"list_all2 (rel_prod A B) (u || v) (r || s) \\<longleftrightarrow> list_all2 A u r \\<and> list_all2 B v s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod A B) (u || v) (r || s) =\n    (list_all2 A u r \\<and> list_all2 B v s)", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. list_all2 (rel_prod A B) (u || v) (r || s) \\<Longrightarrow>\n    list_all2 A u r\n 2. list_all2 (rel_prod A B) (u || v) (r || s) \\<Longrightarrow>\n    list_all2 B v s\n 3. \\<lbrakk>list_all2 A u r; list_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> list_all2 (rel_prod A B) (u || v) (r || s)", "assume [transfer_rule]: \"list_all2 (rel_prod A B) (u || v) (r || s)\""], ["proof (state)\nthis:\n  list_all2 (rel_prod A B) (u || v) (r || s)\n\ngoal (3 subgoals):\n 1. list_all2 (rel_prod A B) (u || v) (r || s) \\<Longrightarrow>\n    list_all2 A u r\n 2. list_all2 (rel_prod A B) (u || v) (r || s) \\<Longrightarrow>\n    list_all2 B v s\n 3. \\<lbrakk>list_all2 A u r; list_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> list_all2 (rel_prod A B) (u || v) (r || s)", "have \"list_all2 A (map fst (u || v)) (map fst (r || s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 A (map fst (u || v)) (map fst (r || s))", "by transfer_prover"], ["proof (state)\nthis:\n  list_all2 A (map fst (u || v)) (map fst (r || s))\n\ngoal (3 subgoals):\n 1. list_all2 (rel_prod A B) (u || v) (r || s) \\<Longrightarrow>\n    list_all2 A u r\n 2. list_all2 (rel_prod A B) (u || v) (r || s) \\<Longrightarrow>\n    list_all2 B v s\n 3. \\<lbrakk>list_all2 A u r; list_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> list_all2 (rel_prod A B) (u || v) (r || s)", "then"], ["proof (chain)\npicking this:\n  list_all2 A (map fst (u || v)) (map fst (r || s))", "show \"list_all2 A u r\""], ["proof (prove)\nusing this:\n  list_all2 A (map fst (u || v)) (map fst (r || s))\n\ngoal (1 subgoal):\n 1. list_all2 A u r", "using assms"], ["proof (prove)\nusing this:\n  list_all2 A (map fst (u || v)) (map fst (r || s))\n  length u = length v\n  length r = length s\n\ngoal (1 subgoal):\n 1. list_all2 A u r", "by simp"], ["proof (state)\nthis:\n  list_all2 A u r\n\ngoal (2 subgoals):\n 1. list_all2 (rel_prod A B) (u || v) (r || s) \\<Longrightarrow>\n    list_all2 B v s\n 2. \\<lbrakk>list_all2 A u r; list_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> list_all2 (rel_prod A B) (u || v) (r || s)", "have \"list_all2 B (map snd (u || v)) (map snd (r || s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 B (map snd (u || v)) (map snd (r || s))", "by transfer_prover"], ["proof (state)\nthis:\n  list_all2 B (map snd (u || v)) (map snd (r || s))\n\ngoal (2 subgoals):\n 1. list_all2 (rel_prod A B) (u || v) (r || s) \\<Longrightarrow>\n    list_all2 B v s\n 2. \\<lbrakk>list_all2 A u r; list_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> list_all2 (rel_prod A B) (u || v) (r || s)", "then"], ["proof (chain)\npicking this:\n  list_all2 B (map snd (u || v)) (map snd (r || s))", "show \"list_all2 B v s\""], ["proof (prove)\nusing this:\n  list_all2 B (map snd (u || v)) (map snd (r || s))\n\ngoal (1 subgoal):\n 1. list_all2 B v s", "using assms"], ["proof (prove)\nusing this:\n  list_all2 B (map snd (u || v)) (map snd (r || s))\n  length u = length v\n  length r = length s\n\ngoal (1 subgoal):\n 1. list_all2 B v s", "by simp"], ["proof (state)\nthis:\n  list_all2 B v s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 A u r; list_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> list_all2 (rel_prod A B) (u || v) (r || s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 A u r; list_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> list_all2 (rel_prod A B) (u || v) (r || s)", "assume [transfer_rule]: \"list_all2 A u r\" \"list_all2 B v s\""], ["proof (state)\nthis:\n  list_all2 A u r\n  list_all2 B v s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 A u r; list_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> list_all2 (rel_prod A B) (u || v) (r || s)", "show \"list_all2 (rel_prod A B) (u || v) (r || s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (rel_prod A B) (u || v) (r || s)", "by transfer_prover"], ["proof (state)\nthis:\n  list_all2 (rel_prod A B) (u || v) (r || s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zip_last[simp]:\n    assumes \"xs || ys \\<noteq> []\" \"length xs = length ys\"\n    shows \"last (xs || ys) = (last xs, last ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (xs || ys) = (last xs, last ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. last (xs || ys) = (last xs, last ys)", "have 1: \"xs \\<noteq> []\" \"ys \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] &&& ys \\<noteq> []", "using assms(1)"], ["proof (prove)\nusing this:\n  xs || ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] &&& ys \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (xs || ys) = (last xs, last ys)", "have \"last (xs || ys) = (xs || ys) ! (length (xs || ys) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (xs || ys) = (xs || ys) ! (length (xs || ys) - 1)", "using last_conv_nth assms"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> last ?xs = ?xs ! (length ?xs - 1)\n  xs || ys \\<noteq> []\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. last (xs || ys) = (xs || ys) ! (length (xs || ys) - 1)", "by blast"], ["proof (state)\nthis:\n  last (xs || ys) = (xs || ys) ! (length (xs || ys) - 1)\n\ngoal (1 subgoal):\n 1. last (xs || ys) = (last xs, last ys)", "also"], ["proof (state)\nthis:\n  last (xs || ys) = (xs || ys) ! (length (xs || ys) - 1)\n\ngoal (1 subgoal):\n 1. last (xs || ys) = (last xs, last ys)", "have \"\\<dots> = (xs ! (length (xs || ys) - 1), ys ! (length (xs || ys) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs || ys) ! (length (xs || ys) - 1) =\n    (xs ! (length (xs || ys) - 1), ys ! (length (xs || ys) - 1))", "using assms 1"], ["proof (prove)\nusing this:\n  xs || ys \\<noteq> []\n  length xs = length ys\n  xs \\<noteq> []\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (xs || ys) ! (length (xs || ys) - 1) =\n    (xs ! (length (xs || ys) - 1), ys ! (length (xs || ys) - 1))", "by simp"], ["proof (state)\nthis:\n  (xs || ys) ! (length (xs || ys) - 1) =\n  (xs ! (length (xs || ys) - 1), ys ! (length (xs || ys) - 1))\n\ngoal (1 subgoal):\n 1. last (xs || ys) = (last xs, last ys)", "also"], ["proof (state)\nthis:\n  (xs || ys) ! (length (xs || ys) - 1) =\n  (xs ! (length (xs || ys) - 1), ys ! (length (xs || ys) - 1))\n\ngoal (1 subgoal):\n 1. last (xs || ys) = (last xs, last ys)", "have \"\\<dots> = (xs ! (length xs - 1), ys ! (length ys - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs ! (length (xs || ys) - 1), ys ! (length (xs || ys) - 1)) =\n    (xs ! (length xs - 1), ys ! (length ys - 1))", "using assms(2)"], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. (xs ! (length (xs || ys) - 1), ys ! (length (xs || ys) - 1)) =\n    (xs ! (length xs - 1), ys ! (length ys - 1))", "by simp"], ["proof (state)\nthis:\n  (xs ! (length (xs || ys) - 1), ys ! (length (xs || ys) - 1)) =\n  (xs ! (length xs - 1), ys ! (length ys - 1))\n\ngoal (1 subgoal):\n 1. last (xs || ys) = (last xs, last ys)", "also"], ["proof (state)\nthis:\n  (xs ! (length (xs || ys) - 1), ys ! (length (xs || ys) - 1)) =\n  (xs ! (length xs - 1), ys ! (length ys - 1))\n\ngoal (1 subgoal):\n 1. last (xs || ys) = (last xs, last ys)", "have \"\\<dots> = (last xs, last ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs ! (length xs - 1), ys ! (length ys - 1)) = (last xs, last ys)", "using last_conv_nth 1"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> last ?xs = ?xs ! (length ?xs - 1)\n  xs \\<noteq> []\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (xs ! (length xs - 1), ys ! (length ys - 1)) = (last xs, last ys)", "by metis"], ["proof (state)\nthis:\n  (xs ! (length xs - 1), ys ! (length ys - 1)) = (last xs, last ys)\n\ngoal (1 subgoal):\n 1. last (xs || ys) = (last xs, last ys)", "finally"], ["proof (chain)\npicking this:\n  last (xs || ys) = (last xs, last ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  last (xs || ys) = (last xs, last ys)\n\ngoal (1 subgoal):\n 1. last (xs || ys) = (last xs, last ys)", "by this"], ["proof (state)\nthis:\n  last (xs || ys) = (last xs, last ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Zipping Streams\\<close>"], ["", "notation szip (infixr \"|||\" 51)"], ["", "lemmas [simp] = szip_unfold"], ["", "lemma smap_szip_same: \"smap f (xs ||| xs) = smap (\\<lambda> x. f (x, x)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap f (xs ||| xs) = smap (\\<lambda>x. f (x, x)) xs", "by (coinduction arbitrary: xs) (auto)"], ["", "lemma szip_smap[simp]: \"smap fst zs ||| smap snd zs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap fst zs ||| smap snd zs = zs", "by (coinduction arbitrary: zs) (auto)"], ["", "lemma szip_smap_fst[simp]: \"smap fst (xs ||| ys) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap fst (xs ||| ys) = xs", "by (coinduction arbitrary: xs ys) (auto)"], ["", "lemma szip_smap_snd[simp]: \"smap snd (xs ||| ys) = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap snd (xs ||| ys) = ys", "by (coinduction arbitrary: xs ys) (auto)"], ["", "lemma szip_smap_both: \"smap f xs ||| smap g ys = smap (map_prod f g) (xs ||| ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap f xs ||| smap g ys = smap (map_prod f g) (xs ||| ys)", "by (coinduction arbitrary: xs ys) (auto)"], ["", "lemma szip_smap_left: \"smap f xs ||| ys = smap (apfst f) (xs ||| ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap f xs ||| ys = smap (apfst f) (xs ||| ys)", "by (coinduction arbitrary: xs ys) (auto)"], ["", "lemma szip_smap_right: \"xs ||| smap f ys = smap (apsnd f) (xs ||| ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ||| smap f ys = smap (apsnd f) (xs ||| ys)", "by (coinduction arbitrary: xs ys) (auto)"], ["", "lemmas szip_smap_fold = szip_smap_both szip_smap_left szip_smap_right"], ["", "lemma szip_sconst_smap_fst: \"sconst a ||| xs = smap (Pair a) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconst a ||| xs = smap (Pair a) xs", "by (coinduction arbitrary: xs) (auto)"], ["", "lemma szip_sconst_smap_snd: \"xs ||| sconst a = smap (prod.swap \\<circ> Pair a) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ||| sconst a = smap (prod.swap \\<circ> Pair a) xs", "by (coinduction arbitrary: xs) (auto)"], ["", "lemma split_szip[no_atp]: \"(\\<And> x. PROP P x) \\<equiv> (\\<And> y z. PROP P (y ||| z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. PROP P x) \\<equiv> (\\<And>y z. PROP P (y ||| z))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z. (\\<And>x. PROP P x) \\<Longrightarrow> PROP P (y ||| z)\n 2. \\<And>x. (\\<And>y z. PROP P (y ||| z)) \\<Longrightarrow> PROP P x", "fix y z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z. (\\<And>x. PROP P x) \\<Longrightarrow> PROP P (y ||| z)\n 2. \\<And>x. (\\<And>y z. PROP P (y ||| z)) \\<Longrightarrow> PROP P x", "assume 1: \"\\<And> x. PROP P x\""], ["proof (state)\nthis:\n  PROP P ?x\n\ngoal (2 subgoals):\n 1. \\<And>y z. (\\<And>x. PROP P x) \\<Longrightarrow> PROP P (y ||| z)\n 2. \\<And>x. (\\<And>y z. PROP P (y ||| z)) \\<Longrightarrow> PROP P x", "show \"PROP P (y ||| z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROP P (y ||| z)", "using 1"], ["proof (prove)\nusing this:\n  PROP P ?x\n\ngoal (1 subgoal):\n 1. PROP P (y ||| z)", "by this"], ["proof (state)\nthis:\n  PROP P (y ||| z)\n\ngoal (1 subgoal):\n 1. \\<And>x. (\\<And>y z. PROP P (y ||| z)) \\<Longrightarrow> PROP P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<And>y z. PROP P (y ||| z)) \\<Longrightarrow> PROP P x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<And>y z. PROP P (y ||| z)) \\<Longrightarrow> PROP P x", "assume 1: \"\\<And> y z. PROP P (y ||| z)\""], ["proof (state)\nthis:\n  PROP P (?y ||| ?z)\n\ngoal (1 subgoal):\n 1. \\<And>x. (\\<And>y z. PROP P (y ||| z)) \\<Longrightarrow> PROP P x", "have 2: \"PROP P (smap fst x ||| smap snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROP P (smap fst x ||| smap snd x)", "using 1"], ["proof (prove)\nusing this:\n  PROP P (?y ||| ?z)\n\ngoal (1 subgoal):\n 1. PROP P (smap fst x ||| smap snd x)", "by this"], ["proof (state)\nthis:\n  PROP P (smap fst x ||| smap snd x)\n\ngoal (1 subgoal):\n 1. \\<And>x. (\\<And>y z. PROP P (y ||| z)) \\<Longrightarrow> PROP P x", "show \"PROP P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROP P x", "using 2"], ["proof (prove)\nusing this:\n  PROP P (smap fst x ||| smap snd x)\n\ngoal (1 subgoal):\n 1. PROP P x", "by simp"], ["proof (state)\nthis:\n  PROP P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_szip_all[no_atp]: \"(\\<forall> x. P x) \\<longleftrightarrow> (\\<forall> y z. P (y ||| z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. P x) = (\\<forall>y z. P (y ||| z))", "by (fastforce iff: split_szip)"], ["", "lemma split_szip_ex[no_atp]: \"(\\<exists> x. P x) \\<longleftrightarrow> (\\<exists> y z. P (y ||| z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. P x) = (\\<exists>y z. P (y ||| z))", "by (fastforce iff: split_szip)"], ["", "lemma szip_eq[iff]: \"u ||| v = r ||| s \\<longleftrightarrow> u = r \\<and> v = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u ||| v = r ||| s) = (u = r \\<and> v = s)", "using szip_smap_fst szip_smap_snd"], ["proof (prove)\nusing this:\n  smap fst (?xs ||| ?ys) = ?xs\n  smap snd (?xs ||| ?ys) = ?ys\n\ngoal (1 subgoal):\n 1. (u ||| v = r ||| s) = (u = r \\<and> v = s)", "by metis"], ["", "lemma stream_rel_szip[iff]:\n    \"stream_all2 (rel_prod A B) (u ||| v) (r ||| s) \\<longleftrightarrow> stream_all2 A u r \\<and> stream_all2 B v s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 (rel_prod A B) (u ||| v) (r ||| s) =\n    (stream_all2 A u r \\<and> stream_all2 B v s)", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. stream_all2 (rel_prod A B) (u ||| v) (r ||| s) \\<Longrightarrow>\n    stream_all2 A u r\n 2. stream_all2 (rel_prod A B) (u ||| v) (r ||| s) \\<Longrightarrow>\n    stream_all2 B v s\n 3. \\<lbrakk>stream_all2 A u r; stream_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> stream_all2 (rel_prod A B) (u ||| v) (r ||| s)", "assume [transfer_rule]: \"stream_all2 (rel_prod A B) (u ||| v) (r ||| s)\""], ["proof (state)\nthis:\n  stream_all2 (rel_prod A B) (u ||| v) (r ||| s)\n\ngoal (3 subgoals):\n 1. stream_all2 (rel_prod A B) (u ||| v) (r ||| s) \\<Longrightarrow>\n    stream_all2 A u r\n 2. stream_all2 (rel_prod A B) (u ||| v) (r ||| s) \\<Longrightarrow>\n    stream_all2 B v s\n 3. \\<lbrakk>stream_all2 A u r; stream_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> stream_all2 (rel_prod A B) (u ||| v) (r ||| s)", "have \"stream_all2 A (smap fst (u ||| v)) (smap fst (r ||| s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 A (smap fst (u ||| v)) (smap fst (r ||| s))", "by transfer_prover"], ["proof (state)\nthis:\n  stream_all2 A (smap fst (u ||| v)) (smap fst (r ||| s))\n\ngoal (3 subgoals):\n 1. stream_all2 (rel_prod A B) (u ||| v) (r ||| s) \\<Longrightarrow>\n    stream_all2 A u r\n 2. stream_all2 (rel_prod A B) (u ||| v) (r ||| s) \\<Longrightarrow>\n    stream_all2 B v s\n 3. \\<lbrakk>stream_all2 A u r; stream_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> stream_all2 (rel_prod A B) (u ||| v) (r ||| s)", "then"], ["proof (chain)\npicking this:\n  stream_all2 A (smap fst (u ||| v)) (smap fst (r ||| s))", "show \"stream_all2 A u r\""], ["proof (prove)\nusing this:\n  stream_all2 A (smap fst (u ||| v)) (smap fst (r ||| s))\n\ngoal (1 subgoal):\n 1. stream_all2 A u r", "by simp"], ["proof (state)\nthis:\n  stream_all2 A u r\n\ngoal (2 subgoals):\n 1. stream_all2 (rel_prod A B) (u ||| v) (r ||| s) \\<Longrightarrow>\n    stream_all2 B v s\n 2. \\<lbrakk>stream_all2 A u r; stream_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> stream_all2 (rel_prod A B) (u ||| v) (r ||| s)", "have \"stream_all2 B (smap snd (u ||| v)) (smap snd (r ||| s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 B (smap snd (u ||| v)) (smap snd (r ||| s))", "by transfer_prover"], ["proof (state)\nthis:\n  stream_all2 B (smap snd (u ||| v)) (smap snd (r ||| s))\n\ngoal (2 subgoals):\n 1. stream_all2 (rel_prod A B) (u ||| v) (r ||| s) \\<Longrightarrow>\n    stream_all2 B v s\n 2. \\<lbrakk>stream_all2 A u r; stream_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> stream_all2 (rel_prod A B) (u ||| v) (r ||| s)", "then"], ["proof (chain)\npicking this:\n  stream_all2 B (smap snd (u ||| v)) (smap snd (r ||| s))", "show \"stream_all2 B v s\""], ["proof (prove)\nusing this:\n  stream_all2 B (smap snd (u ||| v)) (smap snd (r ||| s))\n\ngoal (1 subgoal):\n 1. stream_all2 B v s", "by simp"], ["proof (state)\nthis:\n  stream_all2 B v s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>stream_all2 A u r; stream_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> stream_all2 (rel_prod A B) (u ||| v) (r ||| s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>stream_all2 A u r; stream_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> stream_all2 (rel_prod A B) (u ||| v) (r ||| s)", "assume [transfer_rule]: \"stream_all2 A u r\" \"stream_all2 B v s\""], ["proof (state)\nthis:\n  stream_all2 A u r\n  stream_all2 B v s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>stream_all2 A u r; stream_all2 B v s\\<rbrakk>\n    \\<Longrightarrow> stream_all2 (rel_prod A B) (u ||| v) (r ||| s)", "show \"stream_all2 (rel_prod A B) (u ||| v) (r ||| s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stream_all2 (rel_prod A B) (u ||| v) (r ||| s)", "by transfer_prover"], ["proof (state)\nthis:\n  stream_all2 (rel_prod A B) (u ||| v) (r ||| s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma szip_shift[simp]:\n    assumes \"length u = length s\"\n    shows \"u @- v ||| s @- t = (u || s) @- (v ||| t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u @- v ||| s @- t = (u || s) @- (v ||| t)", "using assms"], ["proof (prove)\nusing this:\n  length u = length s\n\ngoal (1 subgoal):\n 1. u @- v ||| s @- t = (u || s) @- (v ||| t)", "by (simp add: eq_shift stake_shift sdrop_shift)"], ["", "lemma szip_sset_fst[simp]: \"fst ` sset (u ||| v) = sset u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` sset (u ||| v) = sset u", "by (metis stream.set_map szip_smap_fst)"], ["", "lemma szip_sset_snd[simp]: \"snd ` sset (u ||| v) = sset v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` sset (u ||| v) = sset v", "by (metis stream.set_map szip_smap_snd)"], ["", "lemma szip_sset_elim[elim]:\n    assumes \"(a, b) \\<in> sset (u ||| v)\"\n    obtains \"a \\<in> sset u\" \"b \\<in> sset v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>a \\<in> sset u; b \\<in> sset v\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (a, b) \\<in> sset (u ||| v)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>a \\<in> sset u; b \\<in> sset v\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis image_eqI fst_conv snd_conv szip_sset_fst szip_sset_snd)"], ["", "lemma szip_sset[simp]: \"sset (u ||| v) \\<subseteq> sset u \\<times> sset v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (u ||| v) \\<subseteq> sset u \\<times> sset v", "by auto"], ["", "lemma sset_szip_finite[iff]: \"finite (sset (u ||| v)) \\<longleftrightarrow> finite (sset u) \\<and> finite (sset v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (sset (u ||| v)) = (finite (sset u) \\<and> finite (sset v))", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (sset (u ||| v)) \\<Longrightarrow> finite (sset u)\n 2. finite (sset (u ||| v)) \\<Longrightarrow> finite (sset v)\n 3. \\<lbrakk>finite (sset u); finite (sset v)\\<rbrakk>\n    \\<Longrightarrow> finite (sset (u ||| v))", "assume 1: \"finite (sset (u ||| v))\""], ["proof (state)\nthis:\n  finite (sset (u ||| v))\n\ngoal (3 subgoals):\n 1. finite (sset (u ||| v)) \\<Longrightarrow> finite (sset u)\n 2. finite (sset (u ||| v)) \\<Longrightarrow> finite (sset v)\n 3. \\<lbrakk>finite (sset u); finite (sset v)\\<rbrakk>\n    \\<Longrightarrow> finite (sset (u ||| v))", "have 2: \"finite (fst ` sset (u ||| v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fst ` sset (u ||| v))", "using 1"], ["proof (prove)\nusing this:\n  finite (sset (u ||| v))\n\ngoal (1 subgoal):\n 1. finite (fst ` sset (u ||| v))", "by blast"], ["proof (state)\nthis:\n  finite (fst ` sset (u ||| v))\n\ngoal (3 subgoals):\n 1. finite (sset (u ||| v)) \\<Longrightarrow> finite (sset u)\n 2. finite (sset (u ||| v)) \\<Longrightarrow> finite (sset v)\n 3. \\<lbrakk>finite (sset u); finite (sset v)\\<rbrakk>\n    \\<Longrightarrow> finite (sset (u ||| v))", "have 3: \"finite (snd ` sset (u ||| v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (snd ` sset (u ||| v))", "using 1"], ["proof (prove)\nusing this:\n  finite (sset (u ||| v))\n\ngoal (1 subgoal):\n 1. finite (snd ` sset (u ||| v))", "by blast"], ["proof (state)\nthis:\n  finite (snd ` sset (u ||| v))\n\ngoal (3 subgoals):\n 1. finite (sset (u ||| v)) \\<Longrightarrow> finite (sset u)\n 2. finite (sset (u ||| v)) \\<Longrightarrow> finite (sset v)\n 3. \\<lbrakk>finite (sset u); finite (sset v)\\<rbrakk>\n    \\<Longrightarrow> finite (sset (u ||| v))", "show \"finite (sset u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (sset u)", "using 2"], ["proof (prove)\nusing this:\n  finite (fst ` sset (u ||| v))\n\ngoal (1 subgoal):\n 1. finite (sset u)", "by simp"], ["proof (state)\nthis:\n  finite (sset u)\n\ngoal (2 subgoals):\n 1. finite (sset (u ||| v)) \\<Longrightarrow> finite (sset v)\n 2. \\<lbrakk>finite (sset u); finite (sset v)\\<rbrakk>\n    \\<Longrightarrow> finite (sset (u ||| v))", "show \"finite (sset v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (sset v)", "using 3"], ["proof (prove)\nusing this:\n  finite (snd ` sset (u ||| v))\n\ngoal (1 subgoal):\n 1. finite (sset v)", "by simp"], ["proof (state)\nthis:\n  finite (sset v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (sset u); finite (sset v)\\<rbrakk>\n    \\<Longrightarrow> finite (sset (u ||| v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (sset u); finite (sset v)\\<rbrakk>\n    \\<Longrightarrow> finite (sset (u ||| v))", "assume 1: \"finite (sset u)\" \"finite (sset v)\""], ["proof (state)\nthis:\n  finite (sset u)\n  finite (sset v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (sset u); finite (sset v)\\<rbrakk>\n    \\<Longrightarrow> finite (sset (u ||| v))", "have \"sset (u ||| v) \\<subseteq> sset u \\<times> sset v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (u ||| v) \\<subseteq> sset u \\<times> sset v", "by simp"], ["proof (state)\nthis:\n  sset (u ||| v) \\<subseteq> sset u \\<times> sset v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (sset u); finite (sset v)\\<rbrakk>\n    \\<Longrightarrow> finite (sset (u ||| v))", "also"], ["proof (state)\nthis:\n  sset (u ||| v) \\<subseteq> sset u \\<times> sset v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (sset u); finite (sset v)\\<rbrakk>\n    \\<Longrightarrow> finite (sset (u ||| v))", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (sset u \\<times> sset v)", "using 1"], ["proof (prove)\nusing this:\n  finite (sset u)\n  finite (sset v)\n\ngoal (1 subgoal):\n 1. finite (sset u \\<times> sset v)", "by simp"], ["proof (state)\nthis:\n  finite (sset u \\<times> sset v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (sset u); finite (sset v)\\<rbrakk>\n    \\<Longrightarrow> finite (sset (u ||| v))", "finally"], ["proof (chain)\npicking this:\n  finite (sset (u ||| v))", "show \"finite (sset (u ||| v))\""], ["proof (prove)\nusing this:\n  finite (sset (u ||| v))\n\ngoal (1 subgoal):\n 1. finite (sset (u ||| v))", "by this"], ["proof (state)\nthis:\n  finite (sset (u ||| v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infs_szip_fst[iff]: \"infs (P \\<circ> fst) (u ||| v) \\<longleftrightarrow> infs P u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (P \\<circ> fst) (u ||| v) = infs P u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infs (P \\<circ> fst) (u ||| v) = infs P u", "have \"infs (P \\<circ> fst) (u ||| v) \\<longleftrightarrow> infs P (smap fst (u ||| v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (P \\<circ> fst) (u ||| v) = infs P (smap fst (u ||| v))", "by (simp add: comp_def del: szip_smap_fst)"], ["proof (state)\nthis:\n  infs (P \\<circ> fst) (u ||| v) = infs P (smap fst (u ||| v))\n\ngoal (1 subgoal):\n 1. infs (P \\<circ> fst) (u ||| v) = infs P u", "also"], ["proof (state)\nthis:\n  infs (P \\<circ> fst) (u ||| v) = infs P (smap fst (u ||| v))\n\ngoal (1 subgoal):\n 1. infs (P \\<circ> fst) (u ||| v) = infs P u", "have \"\\<dots> \\<longleftrightarrow> infs P u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P (smap fst (u ||| v)) = infs P u", "by simp"], ["proof (state)\nthis:\n  infs P (smap fst (u ||| v)) = infs P u\n\ngoal (1 subgoal):\n 1. infs (P \\<circ> fst) (u ||| v) = infs P u", "finally"], ["proof (chain)\npicking this:\n  infs (P \\<circ> fst) (u ||| v) = infs P u", "show ?thesis"], ["proof (prove)\nusing this:\n  infs (P \\<circ> fst) (u ||| v) = infs P u\n\ngoal (1 subgoal):\n 1. infs (P \\<circ> fst) (u ||| v) = infs P u", "by this"], ["proof (state)\nthis:\n  infs (P \\<circ> fst) (u ||| v) = infs P u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infs_szip_snd[iff]: \"infs (P \\<circ> snd) (u ||| v) \\<longleftrightarrow> infs P v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (P \\<circ> snd) (u ||| v) = infs P v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infs (P \\<circ> snd) (u ||| v) = infs P v", "have \"infs (P \\<circ> snd) (u ||| v) \\<longleftrightarrow> infs P (smap snd (u ||| v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (P \\<circ> snd) (u ||| v) = infs P (smap snd (u ||| v))", "by (simp add: comp_def del: szip_smap_snd)"], ["proof (state)\nthis:\n  infs (P \\<circ> snd) (u ||| v) = infs P (smap snd (u ||| v))\n\ngoal (1 subgoal):\n 1. infs (P \\<circ> snd) (u ||| v) = infs P v", "also"], ["proof (state)\nthis:\n  infs (P \\<circ> snd) (u ||| v) = infs P (smap snd (u ||| v))\n\ngoal (1 subgoal):\n 1. infs (P \\<circ> snd) (u ||| v) = infs P v", "have \"\\<dots> \\<longleftrightarrow> infs P v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P (smap snd (u ||| v)) = infs P v", "by simp"], ["proof (state)\nthis:\n  infs P (smap snd (u ||| v)) = infs P v\n\ngoal (1 subgoal):\n 1. infs (P \\<circ> snd) (u ||| v) = infs P v", "finally"], ["proof (chain)\npicking this:\n  infs (P \\<circ> snd) (u ||| v) = infs P v", "show ?thesis"], ["proof (prove)\nusing this:\n  infs (P \\<circ> snd) (u ||| v) = infs P v\n\ngoal (1 subgoal):\n 1. infs (P \\<circ> snd) (u ||| v) = infs P v", "by this"], ["proof (state)\nthis:\n  infs (P \\<circ> snd) (u ||| v) = infs P v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}