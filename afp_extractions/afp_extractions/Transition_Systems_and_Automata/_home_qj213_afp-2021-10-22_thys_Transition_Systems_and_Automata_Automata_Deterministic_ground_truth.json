{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Automata/Deterministic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma path_alt_def: \"path A w p \\<longleftrightarrow> w \\<in> lists (alphabet A)\"", "lemma run_alt_def: \"run A w p \\<longleftrightarrow> w \\<in> streams (alphabet A)\"", "lemma language[intro]:\n      assumes \"path A w (initial A)\" \"test (condition A) w (states A w (initial A)) (initial A)\"\n      shows \"w \\<in> language A\"", "lemma language_elim[elim]:\n      assumes \"w \\<in> language A\"\n      obtains \"path A w (initial A)\" \"test (condition A) w (states A w (initial A)) (initial A)\"", "lemma language_alphabet: \"language A \\<subseteq> lists (alphabet A)\"", "lemma language[intro]:\n      assumes \"run A w (initial A)\" \"test (condition A) w (trace A w (initial A)) (initial A)\"\n      shows \"w \\<in> language A\"", "lemma language_elim[elim]:\n      assumes \"w \\<in> language A\"\n      obtains \"run A w (initial A)\" \"test (condition A) w (trace A w (initial A)) (initial A)\"", "lemma language_alphabet: \"language A \\<subseteq> streams (alphabet A)\"", "lemma degeneralize_simps[simp]:\n      \"alphabet\\<^sub>2 (degeneralize A) = alphabet\\<^sub>1 A\"\n      \"initial\\<^sub>2 (degeneralize A) = (initial\\<^sub>1 A, 0)\"\n      \"transition\\<^sub>2 (degeneralize A) a (p, k) =\n        (transition\\<^sub>1 A a p, count (condition\\<^sub>1 A) (item (p, a, transition\\<^sub>1 A a p)) k)\"\n      \"condition\\<^sub>2 (degeneralize A) = degen (condition\\<^sub>1 A) \\<circ> translate\"", "lemma degeneralize_target[simp]: \"b.target (degeneralize A) w (p, k) =\n      (a.target A w p, fold (count (condition\\<^sub>1 A) \\<circ> item) (p # a.states A w p || w || a.states A w p) k)\"", "lemma degeneralize_states[simp]: \"b.states (degeneralize A) w (p, k) =\n      a.states A w p || scan (count (condition\\<^sub>1 A) \\<circ> item) (p # a.states A w p || w || a.states A w p) k\"", "lemma degeneralize_trace[simp]: \"b.trace (degeneralize A) w (p, k) =\n      a.trace A w p ||| sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## a.trace A w p ||| w ||| a.trace A w p) k\"", "lemma degeneralize_path[iff]: \"b.path (degeneralize A) w (p, k) \\<longleftrightarrow> a.path A w p\"", "lemma degeneralize_run[iff]: \"b.run (degeneralize A) w (p, k) \\<longleftrightarrow> a.run A w p\"", "lemma degeneralize_reachable_fst[simp]: \"fst ` b.reachable (degeneralize A) (p, k) = a.reachable A p\"", "lemma degeneralize_reachable_snd_empty[simp]:\n      assumes \"condition\\<^sub>1 A = []\"\n      shows \"snd ` b.reachable (degeneralize A) (p, k) = {k}\"", "lemma degeneralize_reachable_empty[simp]:\n      assumes \"condition\\<^sub>1 A = []\"\n      shows \"b.reachable (degeneralize A) (p, k) = a.reachable A p \\<times> {k}\"", "lemma degeneralize_reachable_snd:\n      \"snd ` b.reachable (degeneralize A) (p, k) \\<subseteq> insert k {0 ..< length (condition\\<^sub>1 A)}\"", "lemma degeneralize_reachable:\n      \"b.reachable (degeneralize A) (p, k) \\<subseteq> a.reachable A p \\<times> insert k {0 ..< length (condition\\<^sub>1 A)}\"", "lemma degeneralize_nodes_fst[simp]: \"fst ` b.nodes (degeneralize A) = a.nodes A\"", "lemma degeneralize_nodes_snd_empty:\n      assumes \"condition\\<^sub>1 A = []\"\n      shows \"snd ` b.nodes (degeneralize A) = {0}\"", "lemma degeneralize_nodes_empty:\n      assumes \"condition\\<^sub>1 A = []\"\n      shows \"b.nodes (degeneralize A) = a.nodes A \\<times> {0}\"", "lemma degeneralize_nodes_snd:\n      \"snd ` b.nodes (degeneralize A) \\<subseteq> insert 0 {0 ..< length (condition\\<^sub>1 A)}\"", "lemma degeneralize_nodes:\n      \"b.nodes (degeneralize A) \\<subseteq> a.nodes A \\<times> insert 0 {0 ..< length (condition\\<^sub>1 A)}\"", "lemma degeneralize_nodes_finite[iff]: \"finite (b.nodes (degeneralize A)) \\<longleftrightarrow> finite (a.nodes A)\"", "lemma degeneralize_nodes_card: \"card (b.nodes (degeneralize A)) \\<le>\n      max 1 (length (condition\\<^sub>1 A)) * card (a.nodes A)\"", "lemma degeneralize_language[simp]: \"b.language (degeneralize A) = a.language A\"", "lemma product_simps[simp]:\n      \"alphabet\\<^sub>3 (product A B) = alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B\"\n      \"initial\\<^sub>3 (product A B) = (initial\\<^sub>1 A, initial\\<^sub>2 B)\"\n      \"transition\\<^sub>3 (product A B) a (p, q) = (transition\\<^sub>1 A a p, transition\\<^sub>2 B a q)\"\n      \"condition\\<^sub>3 (product A B) = condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)\"", "lemma product_target[simp]: \"c.target (product A B) w (p, q) = (a.target A w p, b.target B w q)\"", "lemma product_states[simp]: \"c.states (product A B) w (p, q) = a.states A w p || b.states B w q\"", "lemma product_trace[simp]: \"c.trace (product A B) w (p, q) = a.trace A w p ||| b.trace B w q\"", "lemma product_path[iff]: \"c.path (product A B) w (p, q) \\<longleftrightarrow> a.path A w p \\<and> b.path B w q\"", "lemma product_run[iff]: \"c.run (product A B) w (p, q) \\<longleftrightarrow> a.run A w p \\<and> b.run B w q\"", "lemma product_reachable[simp]: \"c.reachable (product A B) (p, q) \\<subseteq> a.reachable A p \\<times> b.reachable B q\"", "lemma product_nodes[simp]: \"c.nodes (product A B) \\<subseteq> a.nodes A \\<times> b.nodes B\"", "lemma product_reachable_fst[simp]:\n      assumes \"alphabet\\<^sub>1 A \\<subseteq> alphabet\\<^sub>2 B\"\n      shows \"fst ` c.reachable (product A B) (p, q) = a.reachable A p\"", "lemma product_reachable_snd[simp]:\n      assumes \"alphabet\\<^sub>1 A \\<supseteq> alphabet\\<^sub>2 B\"\n      shows \"snd ` c.reachable (product A B) (p, q) = b.reachable B q\"", "lemma product_nodes_fst[simp]:\n      assumes \"alphabet\\<^sub>1 A \\<subseteq> alphabet\\<^sub>2 B\"\n      shows \"fst ` c.nodes (product A B) = a.nodes A\"", "lemma product_nodes_snd[simp]:\n      assumes \"alphabet\\<^sub>1 A \\<supseteq> alphabet\\<^sub>2 B\"\n      shows \"snd ` c.nodes (product A B) = b.nodes B\"", "lemma product_nodes_finite[intro]:\n      assumes \"finite (a.nodes A)\" \"finite (b.nodes B)\"\n      shows \"finite (c.nodes (product A B))\"", "lemma product_nodes_finite_strong[iff]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"finite (c.nodes (product A B)) \\<longleftrightarrow> finite (a.nodes A) \\<and> finite (b.nodes B)\"", "lemma product_nodes_card[intro]:\n      assumes \"finite (a.nodes A)\" \"finite (b.nodes B)\"\n      shows \"card (c.nodes (product A B)) \\<le> card (a.nodes A) * card (b.nodes B)\"", "lemma product_nodes_card_strong[intro]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"card (c.nodes (product A B)) \\<le> card (a.nodes A) * card (b.nodes B)\"", "lemma product_language[simp]: \"c.language (product A B) = a.language A \\<inter> b.language B\"", "lemma product_language[simp]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"c.language (product A B) = a.language A \\<union> b.language B\"", "lemma product_language[simp]: \"c.language (product A B) = a.language A \\<inter> b.language B\"", "lemma product_language[simp]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"c.language (product A B) = a.language A \\<union> b.language B\"", "lemma product_simps[simp]:\n      \"alphabet\\<^sub>2 (product AA) = \\<Inter> (alphabet\\<^sub>1 ` set AA)\"\n      \"initial\\<^sub>2 (product AA) = map initial\\<^sub>1 AA\"\n      \"transition\\<^sub>2 (product AA) a ps = map2 (\\<lambda> A p. transition\\<^sub>1 A a p) AA ps\"\n      \"condition\\<^sub>2 (product AA) = condition (map condition\\<^sub>1 AA)\"", "lemma product_trace_smap:\n      assumes \"length ps = length AA\" \"k < length AA\"\n      shows \"smap (\\<lambda> ps. ps ! k) (b.trace (product AA) w ps) = a.trace (AA ! k) w (ps ! k)\"", "lemma product_nodes: \"b.nodes (product AA) \\<subseteq> listset (map a.nodes AA)\"", "lemma product_nodes_finite[intro]:\n      assumes \"list_all (finite \\<circ> a.nodes) AA\"\n      shows \"finite (b.nodes (product AA))\"", "lemma product_nodes_card:\n      assumes \"list_all (finite \\<circ> a.nodes) AA\"\n      shows \"card (b.nodes (product AA)) \\<le> prod_list (map (card \\<circ> a.nodes) AA)\"", "lemma product_language[simp]: \"b.language (product AA) = \\<Inter> (a.language ` set AA)\"", "lemma product_language[simp]:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      shows \"b.language (product AA) = \\<Union> (a.language ` set AA)\"", "lemma combine_simps[simp]:\n      \"alphabet\\<^sub>2 (complement A) = alphabet\\<^sub>1 A\"\n      \"initial\\<^sub>2 (complement A) = initial\\<^sub>1 A\"\n      \"transition\\<^sub>2 (complement A) = transition\\<^sub>1 A\"\n      \"condition\\<^sub>2 (complement A) = condition (condition\\<^sub>1 A)\"", "lemma complement_language[simp]: \"b.language (complement A) = lists (alphabet\\<^sub>1 A) - a.language A\"", "lemma complement_language[simp]: \"b.language (complement A) = streams (alphabet\\<^sub>1 A) - a.language A\""], "translations": [["", "lemma path_alt_def: \"path A w p \\<longleftrightarrow> w \\<in> lists (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path' A w p = (w \\<in> lists (alphabet A))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. path' A w p \\<Longrightarrow> w \\<in> lists (alphabet A)\n 2. w \\<in> lists (alphabet A) \\<Longrightarrow> path' A w p", "show \"w \\<in> lists (alphabet A)\" if \"path A w p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> lists (alphabet A)", "using that"], ["proof (prove)\nusing this:\n  path' A w p\n\ngoal (1 subgoal):\n 1. w \\<in> lists (alphabet A)", "by (induct arbitrary: p) (auto)"], ["proof (state)\nthis:\n  path' A w p \\<Longrightarrow> w \\<in> lists (alphabet A)\n\ngoal (1 subgoal):\n 1. w \\<in> lists (alphabet A) \\<Longrightarrow> path' A w p", "show \"path A w p\" if \"w \\<in> lists (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path' A w p", "using that"], ["proof (prove)\nusing this:\n  w \\<in> lists (alphabet A)\n\ngoal (1 subgoal):\n 1. path' A w p", "by (induct arbitrary: p) (auto)"], ["proof (state)\nthis:\n  w \\<in> lists (alphabet A) \\<Longrightarrow> path' A w p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma run_alt_def: \"run A w p \\<longleftrightarrow> w \\<in> streams (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run' A w p = (w \\<in> streams (alphabet A))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. run' A w p \\<Longrightarrow> w \\<in> streams (alphabet A)\n 2. w \\<in> streams (alphabet A) \\<Longrightarrow> run' A w p", "show \"w \\<in> streams (alphabet A)\" if \"run A w p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> streams (alphabet A)", "using that"], ["proof (prove)\nusing this:\n  run' A w p\n\ngoal (1 subgoal):\n 1. w \\<in> streams (alphabet A)", "by (coinduction arbitrary: w p) (force elim: run.cases)"], ["proof (state)\nthis:\n  run' A w p \\<Longrightarrow> w \\<in> streams (alphabet A)\n\ngoal (1 subgoal):\n 1. w \\<in> streams (alphabet A) \\<Longrightarrow> run' A w p", "show \"run A w p\" if \"w \\<in> streams (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run' A w p", "using that"], ["proof (prove)\nusing this:\n  w \\<in> streams (alphabet A)\n\ngoal (1 subgoal):\n 1. run' A w p", "by (coinduction arbitrary: w p) (force elim: streams.cases)"], ["proof (state)\nthis:\n  w \\<in> streams (alphabet A) \\<Longrightarrow> run' A w p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale automaton_path =\n    automaton automaton alphabet initial transition condition\n    for automaton :: \"'label set \\<Rightarrow> 'state \\<Rightarrow> ('label \\<Rightarrow> 'state \\<Rightarrow> 'state) \\<Rightarrow> 'condition \\<Rightarrow> 'automaton\"\n    and alphabet initial transition condition\n    +\n    fixes test :: \"'condition \\<Rightarrow> 'label list \\<Rightarrow> 'state list \\<Rightarrow> 'state \\<Rightarrow> bool\"\n  begin"], ["", "definition language :: \"'automaton \\<Rightarrow> 'label list set\" where\n      \"language A \\<equiv> {w. path A w (initial A) \\<and> test (condition A) w (states A w (initial A)) (initial A)}\""], ["", "lemma language[intro]:\n      assumes \"path A w (initial A)\" \"test (condition A) w (states A w (initial A)) (initial A)\"\n      shows \"w \\<in> language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> language A", "using assms"], ["proof (prove)\nusing this:\n  path' A w (initial A)\n  test (condition A) w (states A w (initial A)) (initial A)\n\ngoal (1 subgoal):\n 1. w \\<in> language A", "unfolding language_def"], ["proof (prove)\nusing this:\n  path' A w (initial A)\n  test (condition A) w (states A w (initial A)) (initial A)\n\ngoal (1 subgoal):\n 1. w \\<in> {w. path' A w (initial A) \\<and>\n                test (condition A) w (states A w (initial A)) (initial A)}", "by auto"], ["", "lemma language_elim[elim]:\n      assumes \"w \\<in> language A\"\n      obtains \"path A w (initial A)\" \"test (condition A) w (states A w (initial A)) (initial A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>path' A w (initial A);\n      test (condition A) w (states A w (initial A)) (initial A)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  w \\<in> language A\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>path' A w (initial A);\n      test (condition A) w (states A w (initial A)) (initial A)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding language_def"], ["proof (prove)\nusing this:\n  w \\<in> {w. path' A w (initial A) \\<and>\n              test (condition A) w (states A w (initial A)) (initial A)}\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>path' A w (initial A);\n      test (condition A) w (states A w (initial A)) (initial A)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma language_alphabet: \"language A \\<subseteq> lists (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language A \\<subseteq> lists (alphabet A)", "using path_alt_def"], ["proof (prove)\nusing this:\n  path' ?A ?w ?p = (?w \\<in> lists (alphabet ?A))\n\ngoal (1 subgoal):\n 1. language A \\<subseteq> lists (alphabet A)", "by auto"], ["", "end"], ["", "locale automaton_run =\n    automaton automaton alphabet initial transition condition\n    for automaton :: \"'label set \\<Rightarrow> 'state \\<Rightarrow> ('label \\<Rightarrow> 'state \\<Rightarrow> 'state) \\<Rightarrow> 'condition \\<Rightarrow> 'automaton\"\n    and alphabet initial transition condition\n    +\n    fixes test :: \"'condition \\<Rightarrow> 'label stream \\<Rightarrow> 'state stream \\<Rightarrow> 'state \\<Rightarrow> bool\"\n  begin"], ["", "definition language :: \"'automaton \\<Rightarrow> 'label stream set\" where\n      \"language A \\<equiv> {w. run A w (initial A) \\<and> test (condition A) w (trace A w (initial A)) (initial A)}\""], ["", "lemma language[intro]:\n      assumes \"run A w (initial A)\" \"test (condition A) w (trace A w (initial A)) (initial A)\"\n      shows \"w \\<in> language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> language A", "using assms"], ["proof (prove)\nusing this:\n  run' A w (initial A)\n  test (condition A) w (trace A w (initial A)) (initial A)\n\ngoal (1 subgoal):\n 1. w \\<in> language A", "unfolding language_def"], ["proof (prove)\nusing this:\n  run' A w (initial A)\n  test (condition A) w (trace A w (initial A)) (initial A)\n\ngoal (1 subgoal):\n 1. w \\<in> {w. run' A w (initial A) \\<and>\n                test (condition A) w (trace A w (initial A)) (initial A)}", "by auto"], ["", "lemma language_elim[elim]:\n      assumes \"w \\<in> language A\"\n      obtains \"run A w (initial A)\" \"test (condition A) w (trace A w (initial A)) (initial A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>run' A w (initial A);\n      test (condition A) w (trace A w (initial A)) (initial A)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  w \\<in> language A\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>run' A w (initial A);\n      test (condition A) w (trace A w (initial A)) (initial A)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding language_def"], ["proof (prove)\nusing this:\n  w \\<in> {w. run' A w (initial A) \\<and>\n              test (condition A) w (trace A w (initial A)) (initial A)}\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>run' A w (initial A);\n      test (condition A) w (trace A w (initial A)) (initial A)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma language_alphabet: \"language A \\<subseteq> streams (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language A \\<subseteq> streams (alphabet A)", "using run_alt_def"], ["proof (prove)\nusing this:\n  run' ?A ?w ?p = (?w \\<in> streams (alphabet ?A))\n\ngoal (1 subgoal):\n 1. language A \\<subseteq> streams (alphabet A)", "by auto"], ["", "end"], ["", "locale automaton_degeneralization =\n    a: automaton automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 +\n    b: automaton automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    for automaton\\<^sub>1 :: \"'label set \\<Rightarrow> 'state \\<Rightarrow> ('label \\<Rightarrow> 'state \\<Rightarrow> 'state) \\<Rightarrow> 'item pred gen \\<Rightarrow> 'automaton\\<^sub>1\"\n    and alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n    and automaton\\<^sub>2 :: \"'label set \\<Rightarrow> 'state degen \\<Rightarrow> ('label \\<Rightarrow> 'state degen \\<Rightarrow> 'state degen) \\<Rightarrow> 'item_degen pred \\<Rightarrow> 'automaton\\<^sub>2\"\n    and alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    +\n    fixes item :: \"'state \\<times> 'label \\<times> 'state \\<Rightarrow> 'item\"\n    fixes translate :: \"'item_degen \\<Rightarrow> 'item degen\"\n  begin"], ["", "definition degeneralize :: \"'automaton\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>2\" where\n      \"degeneralize A \\<equiv> automaton\\<^sub>2\n        (alphabet\\<^sub>1 A)\n        (initial\\<^sub>1 A, 0)\n        (\\<lambda> a (p, k). (transition\\<^sub>1 A a p, count (condition\\<^sub>1 A) (item (p, a, transition\\<^sub>1 A a p)) k))\n        (degen (condition\\<^sub>1 A) \\<circ> translate)\""], ["", "lemma degeneralize_simps[simp]:\n      \"alphabet\\<^sub>2 (degeneralize A) = alphabet\\<^sub>1 A\"\n      \"initial\\<^sub>2 (degeneralize A) = (initial\\<^sub>1 A, 0)\"\n      \"transition\\<^sub>2 (degeneralize A) a (p, k) =\n        (transition\\<^sub>1 A a p, count (condition\\<^sub>1 A) (item (p, a, transition\\<^sub>1 A a p)) k)\"\n      \"condition\\<^sub>2 (degeneralize A) = degen (condition\\<^sub>1 A) \\<circ> translate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2 (degeneralize A) = alphabet\\<^sub>1 A &&&\n     initial\\<^sub>2 (degeneralize A) = (initial\\<^sub>1 A, 0)) &&&\n    transition\\<^sub>2 (degeneralize A) a (p, k) =\n    (transition\\<^sub>1 A a p,\n     count (condition\\<^sub>1 A) (item (p, a, transition\\<^sub>1 A a p))\n      k) &&&\n    condition\\<^sub>2 (degeneralize A) =\n    degen (condition\\<^sub>1 A) \\<circ> translate", "unfolding degeneralize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2\n      (automaton\\<^sub>2 (alphabet\\<^sub>1 A) (initial\\<^sub>1 A, 0)\n        (\\<lambda>a (p, k).\n            (transition\\<^sub>1 A a p,\n             count (condition\\<^sub>1 A)\n              (item (p, a, transition\\<^sub>1 A a p)) k))\n        (degen (condition\\<^sub>1 A) \\<circ> translate)) =\n     alphabet\\<^sub>1 A &&&\n     initial\\<^sub>2\n      (automaton\\<^sub>2 (alphabet\\<^sub>1 A) (initial\\<^sub>1 A, 0)\n        (\\<lambda>a (p, k).\n            (transition\\<^sub>1 A a p,\n             count (condition\\<^sub>1 A)\n              (item (p, a, transition\\<^sub>1 A a p)) k))\n        (degen (condition\\<^sub>1 A) \\<circ> translate)) =\n     (initial\\<^sub>1 A, 0)) &&&\n    transition\\<^sub>2\n     (automaton\\<^sub>2 (alphabet\\<^sub>1 A) (initial\\<^sub>1 A, 0)\n       (\\<lambda>a (p, k).\n           (transition\\<^sub>1 A a p,\n            count (condition\\<^sub>1 A)\n             (item (p, a, transition\\<^sub>1 A a p)) k))\n       (degen (condition\\<^sub>1 A) \\<circ> translate))\n     a (p, k) =\n    (transition\\<^sub>1 A a p,\n     count (condition\\<^sub>1 A) (item (p, a, transition\\<^sub>1 A a p))\n      k) &&&\n    condition\\<^sub>2\n     (automaton\\<^sub>2 (alphabet\\<^sub>1 A) (initial\\<^sub>1 A, 0)\n       (\\<lambda>a (p, k).\n           (transition\\<^sub>1 A a p,\n            count (condition\\<^sub>1 A)\n             (item (p, a, transition\\<^sub>1 A a p)) k))\n       (degen (condition\\<^sub>1 A) \\<circ> translate)) =\n    degen (condition\\<^sub>1 A) \\<circ> translate", "by auto"], ["", "lemma degeneralize_target[simp]: \"b.target (degeneralize A) w (p, k) =\n      (a.target A w p, fold (count (condition\\<^sub>1 A) \\<circ> item) (p # a.states A w p || w || a.states A w p) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.target (degeneralize A) w (p, k) =\n    (a.target A w p,\n     fold (count (condition\\<^sub>1 A) \\<circ> item)\n      (p # a.states A w p || w || a.states A w p) k)", "by (induct w arbitrary: p k) (auto)"], ["", "lemma degeneralize_states[simp]: \"b.states (degeneralize A) w (p, k) =\n      a.states A w p || scan (count (condition\\<^sub>1 A) \\<circ> item) (p # a.states A w p || w || a.states A w p) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.states (degeneralize A) w (p, k) =\n    a.states A w p ||\n    scan (count (condition\\<^sub>1 A) \\<circ> item)\n     (p # a.states A w p || w || a.states A w p) k", "by (induct w arbitrary: p k) (auto)"], ["", "lemma degeneralize_trace[simp]: \"b.trace (degeneralize A) w (p, k) =\n      a.trace A w p ||| sscan (count (condition\\<^sub>1 A) \\<circ> item) (p ## a.trace A w p ||| w ||| a.trace A w p) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.trace (degeneralize A) w (p, k) =\n    a.trace A w p |||\n    sscan (count (condition\\<^sub>1 A) \\<circ> item)\n     (p ## a.trace A w p ||| w ||| a.trace A w p) k", "by (coinduction arbitrary: w p k) (auto, metis sscan.code)"], ["", "lemma degeneralize_path[iff]: \"b.path (degeneralize A) w (p, k) \\<longleftrightarrow> a.path A w p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.path' (degeneralize A) w (p, k) = a.path' A w p", "unfolding a.path_alt_def b.path_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> lists (alphabet\\<^sub>2 (degeneralize A))) =\n    (w \\<in> lists (alphabet\\<^sub>1 A))", "by simp"], ["", "lemma degeneralize_run[iff]: \"b.run (degeneralize A) w (p, k) \\<longleftrightarrow> a.run A w p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.run' (degeneralize A) w (p, k) = a.run' A w p", "unfolding a.run_alt_def b.run_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> streams (alphabet\\<^sub>2 (degeneralize A))) =\n    (w \\<in> streams (alphabet\\<^sub>1 A))", "by simp"], ["", "lemma degeneralize_reachable_fst[simp]: \"fst ` b.reachable (degeneralize A) (p, k) = a.reachable A p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` b.reachable' (degeneralize A) (p, k) = a.reachable' A p", "unfolding a.reachable_alt_def b.reachable_alt_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{b.target (degeneralize A) r (p, k) |r.\n                        b.path' (degeneralize A) r (p, k)}.\n           y = fst x} =\n    {a.target A r p |r. a.path' A r p}", "by simp"], ["", "lemma degeneralize_reachable_snd_empty[simp]:\n      assumes \"condition\\<^sub>1 A = []\"\n      shows \"snd ` b.reachable (degeneralize A) (p, k) = {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` b.reachable' (degeneralize A) (p, k) = {k}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. snd ` b.reachable' (degeneralize A) (p, k) = {k}", "have \"snd ql = k\" if \"ql \\<in> b.reachable (degeneralize A) (p, k)\" for ql"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ql = k", "using that assms"], ["proof (prove)\nusing this:\n  ql \\<in> b.reachable' (degeneralize A) (p, k)\n  condition\\<^sub>1 A = []\n\ngoal (1 subgoal):\n 1. snd ql = k", "by induct auto"], ["proof (state)\nthis:\n  ?ql \\<in> b.reachable' (degeneralize A) (p, k) \\<Longrightarrow>\n  snd ?ql = k\n\ngoal (1 subgoal):\n 1. snd ` b.reachable' (degeneralize A) (p, k) = {k}", "then"], ["proof (chain)\npicking this:\n  ?ql \\<in> b.reachable' (degeneralize A) (p, k) \\<Longrightarrow>\n  snd ?ql = k", "show ?thesis"], ["proof (prove)\nusing this:\n  ?ql \\<in> b.reachable' (degeneralize A) (p, k) \\<Longrightarrow>\n  snd ?ql = k\n\ngoal (1 subgoal):\n 1. snd ` b.reachable' (degeneralize A) (p, k) = {k}", "by auto"], ["proof (state)\nthis:\n  snd ` b.reachable' (degeneralize A) (p, k) = {k}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degeneralize_reachable_empty[simp]:\n      assumes \"condition\\<^sub>1 A = []\"\n      shows \"b.reachable (degeneralize A) (p, k) = a.reachable A p \\<times> {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.reachable' (degeneralize A) (p, k) = a.reachable' A p \\<times> {k}", "using degeneralize_reachable_fst degeneralize_reachable_snd_empty assms"], ["proof (prove)\nusing this:\n  fst ` b.reachable' (degeneralize ?A) (?p, ?k) = a.reachable' ?A ?p\n  condition\\<^sub>1 ?A = [] \\<Longrightarrow>\n  snd ` b.reachable' (degeneralize ?A) (?p, ?k) = {?k}\n  condition\\<^sub>1 A = []\n\ngoal (1 subgoal):\n 1. b.reachable' (degeneralize A) (p, k) = a.reachable' A p \\<times> {k}", "by (metis prod_singleton(2))"], ["", "lemma degeneralize_reachable_snd:\n      \"snd ` b.reachable (degeneralize A) (p, k) \\<subseteq> insert k {0 ..< length (condition\\<^sub>1 A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` b.reachable' (degeneralize A) (p, k)\n    \\<subseteq> insert k {0..<length (condition\\<^sub>1 A)}", "by (cases \"condition\\<^sub>1 A = []\") (auto)"], ["", "lemma degeneralize_reachable:\n      \"b.reachable (degeneralize A) (p, k) \\<subseteq> a.reachable A p \\<times> insert k {0 ..< length (condition\\<^sub>1 A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.reachable' (degeneralize A) (p, k)\n    \\<subseteq> a.reachable' A p \\<times>\n                insert k {0..<length (condition\\<^sub>1 A)}", "by (cases \"condition\\<^sub>1 A = []\") (auto 0 3)"], ["", "lemma degeneralize_nodes_fst[simp]: \"fst ` b.nodes (degeneralize A) = a.nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` b.nodes' (degeneralize A) = a.nodes' A", "unfolding a.nodes_alt_def b.nodes_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    \\<Union>\n     (b.reachable' (degeneralize A) `\n      {p. p = initial\\<^sub>2 (degeneralize A)}) =\n    \\<Union> (a.reachable' A ` {p. p = initial\\<^sub>1 A})", "by simp"], ["", "lemma degeneralize_nodes_snd_empty:\n      assumes \"condition\\<^sub>1 A = []\"\n      shows \"snd ` b.nodes (degeneralize A) = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` b.nodes' (degeneralize A) = {0}", "using assms"], ["proof (prove)\nusing this:\n  condition\\<^sub>1 A = []\n\ngoal (1 subgoal):\n 1. snd ` b.nodes' (degeneralize A) = {0}", "unfolding b.nodes_alt_def"], ["proof (prove)\nusing this:\n  condition\\<^sub>1 A = []\n\ngoal (1 subgoal):\n 1. snd `\n    \\<Union>\n     (b.reachable' (degeneralize A) `\n      {p. p = initial\\<^sub>2 (degeneralize A)}) =\n    {0}", "by auto"], ["", "lemma degeneralize_nodes_empty:\n      assumes \"condition\\<^sub>1 A = []\"\n      shows \"b.nodes (degeneralize A) = a.nodes A \\<times> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.nodes' (degeneralize A) = a.nodes' A \\<times> {0}", "using assms"], ["proof (prove)\nusing this:\n  condition\\<^sub>1 A = []\n\ngoal (1 subgoal):\n 1. b.nodes' (degeneralize A) = a.nodes' A \\<times> {0}", "unfolding b.nodes_alt_def"], ["proof (prove)\nusing this:\n  condition\\<^sub>1 A = []\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (b.reachable' (degeneralize A) `\n      {p. p = initial\\<^sub>2 (degeneralize A)}) =\n    a.nodes' A \\<times> {0}", "by auto"], ["", "lemma degeneralize_nodes_snd:\n      \"snd ` b.nodes (degeneralize A) \\<subseteq> insert 0 {0 ..< length (condition\\<^sub>1 A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` b.nodes' (degeneralize A)\n    \\<subseteq> insert 0 {0..<length (condition\\<^sub>1 A)}", "using degeneralize_reachable_snd"], ["proof (prove)\nusing this:\n  snd ` b.reachable' (degeneralize ?A) (?p, ?k)\n  \\<subseteq> insert ?k {0..<length (condition\\<^sub>1 ?A)}\n\ngoal (1 subgoal):\n 1. snd ` b.nodes' (degeneralize A)\n    \\<subseteq> insert 0 {0..<length (condition\\<^sub>1 A)}", "unfolding b.nodes_alt_def"], ["proof (prove)\nusing this:\n  snd ` b.reachable' (degeneralize ?A) (?p, ?k)\n  \\<subseteq> insert ?k {0..<length (condition\\<^sub>1 ?A)}\n\ngoal (1 subgoal):\n 1. snd `\n    \\<Union>\n     (b.reachable' (degeneralize A) `\n      {p. p = initial\\<^sub>2 (degeneralize A)})\n    \\<subseteq> insert 0 {0..<length (condition\\<^sub>1 A)}", "by auto"], ["", "lemma degeneralize_nodes:\n      \"b.nodes (degeneralize A) \\<subseteq> a.nodes A \\<times> insert 0 {0 ..< length (condition\\<^sub>1 A)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.nodes' (degeneralize A)\n    \\<subseteq> a.nodes' A \\<times>\n                insert 0 {0..<length (condition\\<^sub>1 A)}", "using degeneralize_reachable"], ["proof (prove)\nusing this:\n  b.reachable' (degeneralize ?A) (?p, ?k)\n  \\<subseteq> a.reachable' ?A ?p \\<times>\n              insert ?k {0..<length (condition\\<^sub>1 ?A)}\n\ngoal (1 subgoal):\n 1. b.nodes' (degeneralize A)\n    \\<subseteq> a.nodes' A \\<times>\n                insert 0 {0..<length (condition\\<^sub>1 A)}", "unfolding a.nodes_alt_def b.nodes_alt_def"], ["proof (prove)\nusing this:\n  b.reachable' (degeneralize ?A) (?p, ?k)\n  \\<subseteq> a.reachable' ?A ?p \\<times>\n              insert ?k {0..<length (condition\\<^sub>1 ?A)}\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (b.reachable' (degeneralize A) `\n      {p. p = initial\\<^sub>2 (degeneralize A)})\n    \\<subseteq> \\<Union>\n                 (a.reachable' A ` {p. p = initial\\<^sub>1 A}) \\<times>\n                insert 0 {0..<length (condition\\<^sub>1 A)}", "by simp"], ["", "lemma degeneralize_nodes_finite[iff]: \"finite (b.nodes (degeneralize A)) \\<longleftrightarrow> finite (a.nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (b.nodes' (degeneralize A)) = finite (a.nodes' A)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (b.nodes' (degeneralize A)) \\<Longrightarrow> finite (a.nodes' A)\n 2. finite (a.nodes' A) \\<Longrightarrow> finite (b.nodes' (degeneralize A))", "show \"finite (a.nodes A)\" if \"finite (b.nodes (degeneralize A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (a.nodes' A)", "using that"], ["proof (prove)\nusing this:\n  finite (b.nodes' (degeneralize A))\n\ngoal (1 subgoal):\n 1. finite (a.nodes' A)", "by (auto simp flip: degeneralize_nodes_fst)"], ["proof (state)\nthis:\n  finite (b.nodes' (degeneralize A)) \\<Longrightarrow> finite (a.nodes' A)\n\ngoal (1 subgoal):\n 1. finite (a.nodes' A) \\<Longrightarrow> finite (b.nodes' (degeneralize A))", "show \"finite (b.nodes (degeneralize A))\" if \"finite (a.nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (b.nodes' (degeneralize A))", "using finite_subset degeneralize_nodes that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  b.nodes' (degeneralize ?A)\n  \\<subseteq> a.nodes' ?A \\<times>\n              insert 0 {0..<length (condition\\<^sub>1 ?A)}\n  finite (a.nodes' A)\n\ngoal (1 subgoal):\n 1. finite (b.nodes' (degeneralize A))", "by blast"], ["proof (state)\nthis:\n  finite (a.nodes' A) \\<Longrightarrow> finite (b.nodes' (degeneralize A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degeneralize_nodes_card: \"card (b.nodes (degeneralize A)) \\<le>\n      max 1 (length (condition\\<^sub>1 A)) * card (a.nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "proof (cases \"finite (a.nodes A)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)\n 2. infinite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "case True"], ["proof (state)\nthis:\n  finite (a.nodes' A)\n\ngoal (2 subgoals):\n 1. finite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)\n 2. infinite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "have \"card (b.nodes (degeneralize A)) \\<le> card (a.nodes A \\<times> insert 0 {0 ..< length (condition\\<^sub>1 A)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (b.nodes' (degeneralize A))\n    \\<le> card\n           (a.nodes' A \\<times> insert 0 {0..<length (condition\\<^sub>1 A)})", "using degeneralize_nodes True"], ["proof (prove)\nusing this:\n  b.nodes' (degeneralize ?A)\n  \\<subseteq> a.nodes' ?A \\<times>\n              insert 0 {0..<length (condition\\<^sub>1 ?A)}\n  finite (a.nodes' A)\n\ngoal (1 subgoal):\n 1. card (b.nodes' (degeneralize A))\n    \\<le> card\n           (a.nodes' A \\<times> insert 0 {0..<length (condition\\<^sub>1 A)})", "by (blast intro: card_mono)"], ["proof (state)\nthis:\n  card (b.nodes' (degeneralize A))\n  \\<le> card\n         (a.nodes' A \\<times> insert 0 {0..<length (condition\\<^sub>1 A)})\n\ngoal (2 subgoals):\n 1. finite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)\n 2. infinite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "also"], ["proof (state)\nthis:\n  card (b.nodes' (degeneralize A))\n  \\<le> card\n         (a.nodes' A \\<times> insert 0 {0..<length (condition\\<^sub>1 A)})\n\ngoal (2 subgoals):\n 1. finite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)\n 2. infinite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "have \"\\<dots> = card (insert 0 {0 ..< length (condition\\<^sub>1 A)}) * card (a.nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (a.nodes' A \\<times> insert 0 {0..<length (condition\\<^sub>1 A)}) =\n    card (insert 0 {0..<length (condition\\<^sub>1 A)}) * card (a.nodes' A)", "unfolding card_cartesian_product"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (a.nodes' A) * card (insert 0 {0..<length (condition\\<^sub>1 A)}) =\n    card (insert 0 {0..<length (condition\\<^sub>1 A)}) * card (a.nodes' A)", "by simp"], ["proof (state)\nthis:\n  card (a.nodes' A \\<times> insert 0 {0..<length (condition\\<^sub>1 A)}) =\n  card (insert 0 {0..<length (condition\\<^sub>1 A)}) * card (a.nodes' A)\n\ngoal (2 subgoals):\n 1. finite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)\n 2. infinite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "also"], ["proof (state)\nthis:\n  card (a.nodes' A \\<times> insert 0 {0..<length (condition\\<^sub>1 A)}) =\n  card (insert 0 {0..<length (condition\\<^sub>1 A)}) * card (a.nodes' A)\n\ngoal (2 subgoals):\n 1. finite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)\n 2. infinite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "have \"card (insert 0 {0 ..< length (condition\\<^sub>1 A)}) = max 1 (length (condition\\<^sub>1 A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert 0 {0..<length (condition\\<^sub>1 A)}) =\n    max 1 (length (condition\\<^sub>1 A))", "by (simp add: card_insert_if Suc_leI max_absorb2)"], ["proof (state)\nthis:\n  card (insert 0 {0..<length (condition\\<^sub>1 A)}) =\n  max 1 (length (condition\\<^sub>1 A))\n\ngoal (2 subgoals):\n 1. finite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)\n 2. infinite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "finally"], ["proof (chain)\npicking this:\n  card (b.nodes' (degeneralize A))\n  \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (b.nodes' (degeneralize A))\n  \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)\n\ngoal (1 subgoal):\n 1. card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "by this"], ["proof (state)\nthis:\n  card (b.nodes' (degeneralize A))\n  \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)\n\ngoal (1 subgoal):\n 1. infinite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "case False"], ["proof (state)\nthis:\n  infinite (a.nodes' A)\n\ngoal (1 subgoal):\n 1. infinite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "then"], ["proof (chain)\npicking this:\n  infinite (a.nodes' A)", "have \"card (a.nodes A) = 0\" \"card (b.nodes (degeneralize A)) = 0\""], ["proof (prove)\nusing this:\n  infinite (a.nodes' A)\n\ngoal (1 subgoal):\n 1. card (a.nodes' A) = 0 &&& card (b.nodes' (degeneralize A)) = 0", "by auto"], ["proof (state)\nthis:\n  card (a.nodes' A) = 0\n  card (b.nodes' (degeneralize A)) = 0\n\ngoal (1 subgoal):\n 1. infinite (a.nodes' A) \\<Longrightarrow>\n    card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "then"], ["proof (chain)\npicking this:\n  card (a.nodes' A) = 0\n  card (b.nodes' (degeneralize A)) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  card (a.nodes' A) = 0\n  card (b.nodes' (degeneralize A)) = 0\n\ngoal (1 subgoal):\n 1. card (b.nodes' (degeneralize A))\n    \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)", "by simp"], ["proof (state)\nthis:\n  card (b.nodes' (degeneralize A))\n  \\<le> max 1 (length (condition\\<^sub>1 A)) * card (a.nodes' A)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale automaton_degeneralization_run =\n    automaton_degeneralization\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      item translate +\n    a: automaton_run automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_run automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and item translate\n    +\n    assumes test[iff]: \"test\\<^sub>2 (degen cs \\<circ> translate) w\n      (r ||| sscan (count cs \\<circ> item) (p ## r ||| w ||| r) k) (p, k) \\<longleftrightarrow> test\\<^sub>1 cs w r p\"\n  begin"], ["", "lemma degeneralize_language[simp]: \"b.language (degeneralize A) = a.language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.language (degeneralize A) = a.language A", "by force"], ["", "end"], ["", "locale automaton_product =\n    a: automaton automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 +\n    b: automaton automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 +\n    c: automaton automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n    for automaton\\<^sub>1 :: \"'label set \\<Rightarrow> 'state\\<^sub>1 \\<Rightarrow> ('label \\<Rightarrow> 'state\\<^sub>1 \\<Rightarrow> 'state\\<^sub>1) \\<Rightarrow> 'condition\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>1\"\n    and alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n    and automaton\\<^sub>2 :: \"'label set \\<Rightarrow> 'state\\<^sub>2 \\<Rightarrow> ('label \\<Rightarrow> 'state\\<^sub>2 \\<Rightarrow> 'state\\<^sub>2) \\<Rightarrow> 'condition\\<^sub>2 \\<Rightarrow> 'automaton\\<^sub>2\"\n    and alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    and automaton\\<^sub>3 :: \"'label set \\<Rightarrow> 'state\\<^sub>1 \\<times> 'state\\<^sub>2 \\<Rightarrow> ('label \\<Rightarrow> 'state\\<^sub>1 \\<times> 'state\\<^sub>2 \\<Rightarrow> 'state\\<^sub>1 \\<times> 'state\\<^sub>2) \\<Rightarrow> 'condition\\<^sub>3 \\<Rightarrow> 'automaton\\<^sub>3\"\n    and alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n    +\n    fixes condition :: \"'condition\\<^sub>1 \\<Rightarrow> 'condition\\<^sub>2 \\<Rightarrow> 'condition\\<^sub>3\"\n  begin"], ["", "definition product :: \"'automaton\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>2 \\<Rightarrow> 'automaton\\<^sub>3\" where\n      \"product A B \\<equiv> automaton\\<^sub>3\n        (alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B)\n        (initial\\<^sub>1 A, initial\\<^sub>2 B)\n        (\\<lambda> a (p, q). (transition\\<^sub>1 A a p, transition\\<^sub>2 B a q))\n        (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))\""], ["", "lemma product_simps[simp]:\n      \"alphabet\\<^sub>3 (product A B) = alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B\"\n      \"initial\\<^sub>3 (product A B) = (initial\\<^sub>1 A, initial\\<^sub>2 B)\"\n      \"transition\\<^sub>3 (product A B) a (p, q) = (transition\\<^sub>1 A a p, transition\\<^sub>2 B a q)\"\n      \"condition\\<^sub>3 (product A B) = condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>3 (product A B) =\n     alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B &&&\n     initial\\<^sub>3 (product A B) =\n     (initial\\<^sub>1 A, initial\\<^sub>2 B)) &&&\n    transition\\<^sub>3 (product A B) a (p, q) =\n    (transition\\<^sub>1 A a p, transition\\<^sub>2 B a q) &&&\n    condition\\<^sub>3 (product A B) =\n    condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)", "unfolding product_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>3\n      (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B)\n        (initial\\<^sub>1 A, initial\\<^sub>2 B)\n        (\\<lambda>a (p, q).\n            (transition\\<^sub>1 A a p, transition\\<^sub>2 B a q))\n        (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))) =\n     alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B &&&\n     initial\\<^sub>3\n      (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B)\n        (initial\\<^sub>1 A, initial\\<^sub>2 B)\n        (\\<lambda>a (p, q).\n            (transition\\<^sub>1 A a p, transition\\<^sub>2 B a q))\n        (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))) =\n     (initial\\<^sub>1 A, initial\\<^sub>2 B)) &&&\n    transition\\<^sub>3\n     (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B)\n       (initial\\<^sub>1 A, initial\\<^sub>2 B)\n       (\\<lambda>a (p, q).\n           (transition\\<^sub>1 A a p, transition\\<^sub>2 B a q))\n       (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)))\n     a (p, q) =\n    (transition\\<^sub>1 A a p, transition\\<^sub>2 B a q) &&&\n    condition\\<^sub>3\n     (automaton\\<^sub>3 (alphabet\\<^sub>1 A \\<inter> alphabet\\<^sub>2 B)\n       (initial\\<^sub>1 A, initial\\<^sub>2 B)\n       (\\<lambda>a (p, q).\n           (transition\\<^sub>1 A a p, transition\\<^sub>2 B a q))\n       (condition (condition\\<^sub>1 A) (condition\\<^sub>2 B))) =\n    condition (condition\\<^sub>1 A) (condition\\<^sub>2 B)", "by auto"], ["", "lemma product_target[simp]: \"c.target (product A B) w (p, q) = (a.target A w p, b.target B w q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.target (product A B) w (p, q) = (a.target A w p, b.target B w q)", "by (induct w arbitrary: p q) (auto)"], ["", "lemma product_states[simp]: \"c.states (product A B) w (p, q) = a.states A w p || b.states B w q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.states (product A B) w (p, q) = a.states A w p || b.states B w q", "by (induct w arbitrary: p q) (auto)"], ["", "lemma product_trace[simp]: \"c.trace (product A B) w (p, q) = a.trace A w p ||| b.trace B w q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.trace (product A B) w (p, q) = a.trace A w p ||| b.trace B w q", "by (coinduction arbitrary: w p q) (auto)"], ["", "lemma product_path[iff]: \"c.path (product A B) w (p, q) \\<longleftrightarrow> a.path A w p \\<and> b.path B w q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.path' (product A B) w (p, q) = (a.path' A w p \\<and> b.path' B w q)", "unfolding a.path_alt_def b.path_alt_def c.path_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> lists (alphabet\\<^sub>3 (product A B))) =\n    (w \\<in> lists (alphabet\\<^sub>1 A) \\<and>\n     w \\<in> lists (alphabet\\<^sub>2 B))", "by simp"], ["", "lemma product_run[iff]: \"c.run (product A B) w (p, q) \\<longleftrightarrow> a.run A w p \\<and> b.run B w q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.run' (product A B) w (p, q) = (a.run' A w p \\<and> b.run' B w q)", "unfolding a.run_alt_def b.run_alt_def c.run_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<in> streams (alphabet\\<^sub>3 (product A B))) =\n    (w \\<in> streams (alphabet\\<^sub>1 A) \\<and>\n     w \\<in> streams (alphabet\\<^sub>2 B))", "by simp"], ["", "lemma product_reachable[simp]: \"c.reachable (product A B) (p, q) \\<subseteq> a.reachable A p \\<times> b.reachable B q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.reachable' (product A B) (p, q)\n    \\<subseteq> a.reachable' A p \\<times> b.reachable' B q", "unfolding c.reachable_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {c.target (product A B) r (p, q) |r. c.path' (product A B) r (p, q)}\n    \\<subseteq> a.reachable' A p \\<times> b.reachable' B q", "by auto"], ["", "lemma product_nodes[simp]: \"c.nodes (product A B) \\<subseteq> a.nodes A \\<times> b.nodes B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.nodes' (product A B) \\<subseteq> a.nodes' A \\<times> b.nodes' B", "unfolding a.nodes_alt_def b.nodes_alt_def c.nodes_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (c.reachable' (product A B) ` {p. p = initial\\<^sub>3 (product A B)})\n    \\<subseteq> \\<Union>\n                 (a.reachable' A ` {p. p = initial\\<^sub>1 A}) \\<times>\n                \\<Union> (b.reachable' B ` {p. p = initial\\<^sub>2 B})", "by auto"], ["", "lemma product_reachable_fst[simp]:\n      assumes \"alphabet\\<^sub>1 A \\<subseteq> alphabet\\<^sub>2 B\"\n      shows \"fst ` c.reachable (product A B) (p, q) = a.reachable A p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` c.reachable' (product A B) (p, q) = a.reachable' A p", "using assms"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A \\<subseteq> alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. fst ` c.reachable' (product A B) (p, q) = a.reachable' A p", "unfolding a.reachable_alt_def a.path_alt_def"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A \\<subseteq> alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. fst ` c.reachable' (product A B) (p, q) =\n    {a.target A r p |r. r \\<in> lists (alphabet\\<^sub>1 A)}", "unfolding b.reachable_alt_def b.path_alt_def"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A \\<subseteq> alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. fst ` c.reachable' (product A B) (p, q) =\n    {a.target A r p |r. r \\<in> lists (alphabet\\<^sub>1 A)}", "unfolding c.reachable_alt_def c.path_alt_def"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A \\<subseteq> alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. fst `\n    {c.target (product A B) r (p, q) |r.\n     r \\<in> lists (alphabet\\<^sub>3 (product A B))} =\n    {a.target A r p |r. r \\<in> lists (alphabet\\<^sub>1 A)}", "by auto force"], ["", "lemma product_reachable_snd[simp]:\n      assumes \"alphabet\\<^sub>1 A \\<supseteq> alphabet\\<^sub>2 B\"\n      shows \"snd ` c.reachable (product A B) (p, q) = b.reachable B q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` c.reachable' (product A B) (p, q) = b.reachable' B q", "using assms"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>2 B \\<subseteq> alphabet\\<^sub>1 A\n\ngoal (1 subgoal):\n 1. snd ` c.reachable' (product A B) (p, q) = b.reachable' B q", "unfolding a.reachable_alt_def a.path_alt_def"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>2 B \\<subseteq> alphabet\\<^sub>1 A\n\ngoal (1 subgoal):\n 1. snd ` c.reachable' (product A B) (p, q) = b.reachable' B q", "unfolding b.reachable_alt_def b.path_alt_def"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>2 B \\<subseteq> alphabet\\<^sub>1 A\n\ngoal (1 subgoal):\n 1. snd ` c.reachable' (product A B) (p, q) =\n    {b.target B r q |r. r \\<in> lists (alphabet\\<^sub>2 B)}", "unfolding c.reachable_alt_def c.path_alt_def"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>2 B \\<subseteq> alphabet\\<^sub>1 A\n\ngoal (1 subgoal):\n 1. snd `\n    {c.target (product A B) r (p, q) |r.\n     r \\<in> lists (alphabet\\<^sub>3 (product A B))} =\n    {b.target B r q |r. r \\<in> lists (alphabet\\<^sub>2 B)}", "by auto force"], ["", "lemma product_nodes_fst[simp]:\n      assumes \"alphabet\\<^sub>1 A \\<subseteq> alphabet\\<^sub>2 B\"\n      shows \"fst ` c.nodes (product A B) = a.nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` c.nodes' (product A B) = a.nodes' A", "using assms product_reachable_fst"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A \\<subseteq> alphabet\\<^sub>2 B\n  alphabet\\<^sub>1 ?A \\<subseteq> alphabet\\<^sub>2 ?B \\<Longrightarrow>\n  fst ` c.reachable' (product ?A ?B) (?p, ?q) = a.reachable' ?A ?p\n\ngoal (1 subgoal):\n 1. fst ` c.nodes' (product A B) = a.nodes' A", "unfolding a.nodes_alt_def b.nodes_alt_def c.nodes_alt_def"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A \\<subseteq> alphabet\\<^sub>2 B\n  alphabet\\<^sub>1 ?A \\<subseteq> alphabet\\<^sub>2 ?B \\<Longrightarrow>\n  fst ` c.reachable' (product ?A ?B) (?p, ?q) = a.reachable' ?A ?p\n\ngoal (1 subgoal):\n 1. fst `\n    \\<Union>\n     (c.reachable' (product A B) ` {p. p = initial\\<^sub>3 (product A B)}) =\n    \\<Union> (a.reachable' A ` {p. p = initial\\<^sub>1 A})", "by fastforce"], ["", "lemma product_nodes_snd[simp]:\n      assumes \"alphabet\\<^sub>1 A \\<supseteq> alphabet\\<^sub>2 B\"\n      shows \"snd ` c.nodes (product A B) = b.nodes B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` c.nodes' (product A B) = b.nodes' B", "using assms product_reachable_snd"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>2 B \\<subseteq> alphabet\\<^sub>1 A\n  alphabet\\<^sub>2 ?B \\<subseteq> alphabet\\<^sub>1 ?A \\<Longrightarrow>\n  snd ` c.reachable' (product ?A ?B) (?p, ?q) = b.reachable' ?B ?q\n\ngoal (1 subgoal):\n 1. snd ` c.nodes' (product A B) = b.nodes' B", "unfolding a.nodes_alt_def b.nodes_alt_def c.nodes_alt_def"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>2 B \\<subseteq> alphabet\\<^sub>1 A\n  alphabet\\<^sub>2 ?B \\<subseteq> alphabet\\<^sub>1 ?A \\<Longrightarrow>\n  snd ` c.reachable' (product ?A ?B) (?p, ?q) = b.reachable' ?B ?q\n\ngoal (1 subgoal):\n 1. snd `\n    \\<Union>\n     (c.reachable' (product A B) ` {p. p = initial\\<^sub>3 (product A B)}) =\n    \\<Union> (b.reachable' B ` {p. p = initial\\<^sub>2 B})", "by fastforce"], ["", "lemma product_nodes_finite[intro]:\n      assumes \"finite (a.nodes A)\" \"finite (b.nodes B)\"\n      shows \"finite (c.nodes (product A B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (c.nodes' (product A B))", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. c.nodes' (product A B) \\<subseteq> ?B\n 2. finite ?B", "show \"c.nodes (product A B) \\<subseteq> a.nodes A \\<times> b.nodes B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.nodes' (product A B) \\<subseteq> a.nodes' A \\<times> b.nodes' B", "using product_nodes"], ["proof (prove)\nusing this:\n  c.nodes' (product ?A ?B) \\<subseteq> a.nodes' ?A \\<times> b.nodes' ?B\n\ngoal (1 subgoal):\n 1. c.nodes' (product A B) \\<subseteq> a.nodes' A \\<times> b.nodes' B", "by this"], ["proof (state)\nthis:\n  c.nodes' (product A B) \\<subseteq> a.nodes' A \\<times> b.nodes' B\n\ngoal (1 subgoal):\n 1. finite (a.nodes' A \\<times> b.nodes' B)", "show \"finite (a.nodes A \\<times> b.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (a.nodes' A \\<times> b.nodes' B)", "using assms"], ["proof (prove)\nusing this:\n  finite (a.nodes' A)\n  finite (b.nodes' B)\n\ngoal (1 subgoal):\n 1. finite (a.nodes' A \\<times> b.nodes' B)", "by simp"], ["proof (state)\nthis:\n  finite (a.nodes' A \\<times> b.nodes' B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_nodes_finite_strong[iff]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"finite (c.nodes (product A B)) \\<longleftrightarrow> finite (a.nodes A) \\<and> finite (b.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (c.nodes' (product A B)) =\n    (finite (a.nodes' A) \\<and> finite (b.nodes' B))", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (c.nodes' (product A B)) \\<Longrightarrow> finite (a.nodes' A)\n 2. finite (c.nodes' (product A B)) \\<Longrightarrow> finite (b.nodes' B)\n 3. \\<lbrakk>finite (a.nodes' A); finite (b.nodes' B)\\<rbrakk>\n    \\<Longrightarrow> finite (c.nodes' (product A B))", "show \"finite (a.nodes A)\" if \"finite (c.nodes (product A B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (a.nodes' A)", "using product_nodes_fst assms that"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 ?A \\<subseteq> alphabet\\<^sub>2 ?B \\<Longrightarrow>\n  fst ` c.nodes' (product ?A ?B) = a.nodes' ?A\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n  finite (c.nodes' (product A B))\n\ngoal (1 subgoal):\n 1. finite (a.nodes' A)", "by (metis finite_imageI equalityD1)"], ["proof (state)\nthis:\n  finite (c.nodes' (product A B)) \\<Longrightarrow> finite (a.nodes' A)\n\ngoal (2 subgoals):\n 1. finite (c.nodes' (product A B)) \\<Longrightarrow> finite (b.nodes' B)\n 2. \\<lbrakk>finite (a.nodes' A); finite (b.nodes' B)\\<rbrakk>\n    \\<Longrightarrow> finite (c.nodes' (product A B))", "show \"finite (b.nodes B)\" if \"finite (c.nodes (product A B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (b.nodes' B)", "using product_nodes_snd assms that"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>2 ?B \\<subseteq> alphabet\\<^sub>1 ?A \\<Longrightarrow>\n  snd ` c.nodes' (product ?A ?B) = b.nodes' ?B\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n  finite (c.nodes' (product A B))\n\ngoal (1 subgoal):\n 1. finite (b.nodes' B)", "by (metis finite_imageI equalityD2)"], ["proof (state)\nthis:\n  finite (c.nodes' (product A B)) \\<Longrightarrow> finite (b.nodes' B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (a.nodes' A); finite (b.nodes' B)\\<rbrakk>\n    \\<Longrightarrow> finite (c.nodes' (product A B))", "show \"finite (c.nodes (product A B))\" if \"finite (a.nodes A)\" \"finite (b.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (c.nodes' (product A B))", "using that"], ["proof (prove)\nusing this:\n  finite (a.nodes' A)\n  finite (b.nodes' B)\n\ngoal (1 subgoal):\n 1. finite (c.nodes' (product A B))", "by rule"], ["proof (state)\nthis:\n  \\<lbrakk>finite (a.nodes' A); finite (b.nodes' B)\\<rbrakk>\n  \\<Longrightarrow> finite (c.nodes' (product A B))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_nodes_card[intro]:\n      assumes \"finite (a.nodes A)\" \"finite (b.nodes B)\"\n      shows \"card (c.nodes (product A B)) \\<le> card (a.nodes A) * card (b.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "have \"card (c.nodes (product A B)) \\<le> card (a.nodes A \\<times> b.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A \\<times> b.nodes' B)", "proof (rule card_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (a.nodes' A \\<times> b.nodes' B)\n 2. c.nodes' (product A B) \\<subseteq> a.nodes' A \\<times> b.nodes' B", "show \"finite (a.nodes A \\<times> b.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (a.nodes' A \\<times> b.nodes' B)", "using assms"], ["proof (prove)\nusing this:\n  finite (a.nodes' A)\n  finite (b.nodes' B)\n\ngoal (1 subgoal):\n 1. finite (a.nodes' A \\<times> b.nodes' B)", "by simp"], ["proof (state)\nthis:\n  finite (a.nodes' A \\<times> b.nodes' B)\n\ngoal (1 subgoal):\n 1. c.nodes' (product A B) \\<subseteq> a.nodes' A \\<times> b.nodes' B", "show \"c.nodes (product A B) \\<subseteq> a.nodes A \\<times> b.nodes B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.nodes' (product A B) \\<subseteq> a.nodes' A \\<times> b.nodes' B", "using product_nodes"], ["proof (prove)\nusing this:\n  c.nodes' (product ?A ?B) \\<subseteq> a.nodes' ?A \\<times> b.nodes' ?B\n\ngoal (1 subgoal):\n 1. c.nodes' (product A B) \\<subseteq> a.nodes' A \\<times> b.nodes' B", "by this"], ["proof (state)\nthis:\n  c.nodes' (product A B) \\<subseteq> a.nodes' A \\<times> b.nodes' B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (c.nodes' (product A B)) \\<le> card (a.nodes' A \\<times> b.nodes' B)\n\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "also"], ["proof (state)\nthis:\n  card (c.nodes' (product A B)) \\<le> card (a.nodes' A \\<times> b.nodes' B)\n\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "have \"\\<dots> = card (a.nodes A) * card (b.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (a.nodes' A \\<times> b.nodes' B) =\n    card (a.nodes' A) * card (b.nodes' B)", "using card_cartesian_product"], ["proof (prove)\nusing this:\n  card (?A \\<times> ?B) = card ?A * card ?B\n\ngoal (1 subgoal):\n 1. card (a.nodes' A \\<times> b.nodes' B) =\n    card (a.nodes' A) * card (b.nodes' B)", "by this"], ["proof (state)\nthis:\n  card (a.nodes' A \\<times> b.nodes' B) =\n  card (a.nodes' A) * card (b.nodes' B)\n\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "finally"], ["proof (chain)\npicking this:\n  card (c.nodes' (product A B)) \\<le> card (a.nodes' A) * card (b.nodes' B)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (c.nodes' (product A B)) \\<le> card (a.nodes' A) * card (b.nodes' B)\n\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "by this"], ["proof (state)\nthis:\n  card (c.nodes' (product A B)) \\<le> card (a.nodes' A) * card (b.nodes' B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_nodes_card_strong[intro]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"card (c.nodes (product A B)) \\<le> card (a.nodes A) * card (b.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "proof (cases \"finite (a.nodes A) \\<and> finite (b.nodes B)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (a.nodes' A) \\<and> finite (b.nodes' B) \\<Longrightarrow>\n    card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)\n 2. \\<not> (finite (a.nodes' A) \\<and>\n            finite (b.nodes' B)) \\<Longrightarrow>\n    card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "case True"], ["proof (state)\nthis:\n  finite (a.nodes' A) \\<and> finite (b.nodes' B)\n\ngoal (2 subgoals):\n 1. finite (a.nodes' A) \\<and> finite (b.nodes' B) \\<Longrightarrow>\n    card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)\n 2. \\<not> (finite (a.nodes' A) \\<and>\n            finite (b.nodes' B)) \\<Longrightarrow>\n    card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "using True"], ["proof (prove)\nusing this:\n  finite (a.nodes' A) \\<and> finite (b.nodes' B)\n\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "by auto"], ["proof (state)\nthis:\n  card (c.nodes' (product A B)) \\<le> card (a.nodes' A) * card (b.nodes' B)\n\ngoal (1 subgoal):\n 1. \\<not> (finite (a.nodes' A) \\<and>\n            finite (b.nodes' B)) \\<Longrightarrow>\n    card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (finite (a.nodes' A) \\<and>\n            finite (b.nodes' B)) \\<Longrightarrow>\n    card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "case False"], ["proof (state)\nthis:\n  \\<not> (finite (a.nodes' A) \\<and> finite (b.nodes' B))\n\ngoal (1 subgoal):\n 1. \\<not> (finite (a.nodes' A) \\<and>\n            finite (b.nodes' B)) \\<Longrightarrow>\n    card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "have 1: \"card (c.nodes (product A B)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B)) = 0", "using False assms"], ["proof (prove)\nusing this:\n  \\<not> (finite (a.nodes' A) \\<and> finite (b.nodes' B))\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B)) = 0", "by simp"], ["proof (state)\nthis:\n  card (c.nodes' (product A B)) = 0\n\ngoal (1 subgoal):\n 1. \\<not> (finite (a.nodes' A) \\<and>\n            finite (b.nodes' B)) \\<Longrightarrow>\n    card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "have 2: \"card (a.nodes A) * card (b.nodes B) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (a.nodes' A) * card (b.nodes' B) = 0", "using False"], ["proof (prove)\nusing this:\n  \\<not> (finite (a.nodes' A) \\<and> finite (b.nodes' B))\n\ngoal (1 subgoal):\n 1. card (a.nodes' A) * card (b.nodes' B) = 0", "by auto"], ["proof (state)\nthis:\n  card (a.nodes' A) * card (b.nodes' B) = 0\n\ngoal (1 subgoal):\n 1. \\<not> (finite (a.nodes' A) \\<and>\n            finite (b.nodes' B)) \\<Longrightarrow>\n    card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "using 1 2"], ["proof (prove)\nusing this:\n  card (c.nodes' (product A B)) = 0\n  card (a.nodes' A) * card (b.nodes' B) = 0\n\ngoal (1 subgoal):\n 1. card (c.nodes' (product A B))\n    \\<le> card (a.nodes' A) * card (b.nodes' B)", "by simp"], ["proof (state)\nthis:\n  card (c.nodes' (product A B)) \\<le> card (a.nodes' A) * card (b.nodes' B)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale automaton_intersection_path =\n    automaton_product\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n      condition +\n    a: automaton_path automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_path automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2 +\n    c: automaton_path automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    and condition\n    +\n    assumes test[iff]: \"length r = length s \\<Longrightarrow>\n      test\\<^sub>3 (condition c\\<^sub>1 c\\<^sub>2) w (r || s) (p, q) \\<longleftrightarrow> test\\<^sub>1 c\\<^sub>1 w r p \\<and> test\\<^sub>2 c\\<^sub>2 w s q\"\n  begin"], ["", "lemma product_language[simp]: \"c.language (product A B) = a.language A \\<inter> b.language B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.language (product A B) = a.language A \\<inter> b.language B", "by force"], ["", "end"], ["", "locale automaton_union_path =\n    automaton_product\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n      condition +\n    a: automaton_path automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_path automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2 +\n    c: automaton_path automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    and condition\n    +\n    assumes test[iff]: \"length r = length s \\<Longrightarrow>\n      test\\<^sub>3 (condition c\\<^sub>1 c\\<^sub>2) w (r || s) (p, q) \\<longleftrightarrow> test\\<^sub>1 c\\<^sub>1 w r p \\<or> test\\<^sub>2 c\\<^sub>2 w s q\"\n  begin"], ["", "lemma product_language[simp]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"c.language (product A B) = a.language A \\<union> b.language B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.language (product A B) = a.language A \\<union> b.language B", "using assms"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. c.language (product A B) = a.language A \\<union> b.language B", "by (force simp: a.path_alt_def b.path_alt_def)"], ["", "end"], ["", "locale automaton_intersection_run =\n    automaton_product\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n      condition +\n    a: automaton_run automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_run automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2 +\n    c: automaton_run automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    and condition\n    +\n    assumes test[iff]: \"test\\<^sub>3 (condition c\\<^sub>1 c\\<^sub>2) w (r ||| s) (p, q) \\<longleftrightarrow> test\\<^sub>1 c\\<^sub>1 w r p \\<and> test\\<^sub>2 c\\<^sub>2 w s q\"\n  begin"], ["", "lemma product_language[simp]: \"c.language (product A B) = a.language A \\<inter> b.language B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.language (product A B) = a.language A \\<inter> b.language B", "by force"], ["", "end"], ["", "locale automaton_union_run =\n    automaton_product\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3\n      condition +\n    a: automaton_run automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_run automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2 +\n    c: automaton_run automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and automaton\\<^sub>3 alphabet\\<^sub>3 initial\\<^sub>3 transition\\<^sub>3 condition\\<^sub>3 test\\<^sub>3\n    and condition\n    +\n    assumes test[iff]: \"test\\<^sub>3 (condition c\\<^sub>1 c\\<^sub>2) w (r ||| s) (p, q) \\<longleftrightarrow> test\\<^sub>1 c\\<^sub>1 w r p \\<or> test\\<^sub>2 c\\<^sub>2 w s q\"\n  begin"], ["", "lemma product_language[simp]:\n      assumes \"alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\"\n      shows \"c.language (product A B) = a.language A \\<union> b.language B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c.language (product A B) = a.language A \\<union> b.language B", "using assms"], ["proof (prove)\nusing this:\n  alphabet\\<^sub>1 A = alphabet\\<^sub>2 B\n\ngoal (1 subgoal):\n 1. c.language (product A B) = a.language A \\<union> b.language B", "by (force simp: a.run_alt_def b.run_alt_def)"], ["", "end"], ["", "(* TODO: complete this in analogy to the pair case *)"], ["", "locale automaton_product_list =\n    a: automaton automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 +\n    b: automaton automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    for automaton\\<^sub>1 :: \"'label set \\<Rightarrow> 'state \\<Rightarrow> ('label \\<Rightarrow> 'state \\<Rightarrow> 'state) \\<Rightarrow> 'condition\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>1\"\n    and alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n    and automaton\\<^sub>2 :: \"'label set \\<Rightarrow> 'state list \\<Rightarrow> ('label \\<Rightarrow> 'state list \\<Rightarrow> 'state list) \\<Rightarrow> 'condition\\<^sub>2 \\<Rightarrow> 'automaton\\<^sub>2\"\n    and alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    +\n    fixes condition :: \"'condition\\<^sub>1 list \\<Rightarrow> 'condition\\<^sub>2\"\n  begin"], ["", "definition product :: \"'automaton\\<^sub>1 list \\<Rightarrow> 'automaton\\<^sub>2\" where\n      \"product AA \\<equiv> automaton\\<^sub>2\n        (\\<Inter> (alphabet\\<^sub>1 ` set AA))\n        (map initial\\<^sub>1 AA)\n        (\\<lambda> a ps. map2 (\\<lambda> A p. transition\\<^sub>1 A a p) AA ps)\n        (condition (map condition\\<^sub>1 AA))\""], ["", "lemma product_simps[simp]:\n      \"alphabet\\<^sub>2 (product AA) = \\<Inter> (alphabet\\<^sub>1 ` set AA)\"\n      \"initial\\<^sub>2 (product AA) = map initial\\<^sub>1 AA\"\n      \"transition\\<^sub>2 (product AA) a ps = map2 (\\<lambda> A p. transition\\<^sub>1 A a p) AA ps\"\n      \"condition\\<^sub>2 (product AA) = condition (map condition\\<^sub>1 AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2 (product AA) =\n     \\<Inter> (alphabet\\<^sub>1 ` set AA) &&&\n     initial\\<^sub>2 (product AA) = map initial\\<^sub>1 AA) &&&\n    transition\\<^sub>2 (product AA) a ps =\n    map2 (\\<lambda>x. transition\\<^sub>1 x a) AA ps &&&\n    condition\\<^sub>2 (product AA) = condition (map condition\\<^sub>1 AA)", "unfolding product_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2\n      (automaton\\<^sub>2 (\\<Inter> (alphabet\\<^sub>1 ` set AA))\n        (map initial\\<^sub>1 AA)\n        (\\<lambda>a. map2 (\\<lambda>x. transition\\<^sub>1 x a) AA)\n        (condition (map condition\\<^sub>1 AA))) =\n     \\<Inter> (alphabet\\<^sub>1 ` set AA) &&&\n     initial\\<^sub>2\n      (automaton\\<^sub>2 (\\<Inter> (alphabet\\<^sub>1 ` set AA))\n        (map initial\\<^sub>1 AA)\n        (\\<lambda>a. map2 (\\<lambda>x. transition\\<^sub>1 x a) AA)\n        (condition (map condition\\<^sub>1 AA))) =\n     map initial\\<^sub>1 AA) &&&\n    transition\\<^sub>2\n     (automaton\\<^sub>2 (\\<Inter> (alphabet\\<^sub>1 ` set AA))\n       (map initial\\<^sub>1 AA)\n       (\\<lambda>a. map2 (\\<lambda>x. transition\\<^sub>1 x a) AA)\n       (condition (map condition\\<^sub>1 AA)))\n     a ps =\n    map2 (\\<lambda>x. transition\\<^sub>1 x a) AA ps &&&\n    condition\\<^sub>2\n     (automaton\\<^sub>2 (\\<Inter> (alphabet\\<^sub>1 ` set AA))\n       (map initial\\<^sub>1 AA)\n       (\\<lambda>a. map2 (\\<lambda>x. transition\\<^sub>1 x a) AA)\n       (condition (map condition\\<^sub>1 AA))) =\n    condition (map condition\\<^sub>1 AA)", "by auto"], ["", "(* TODO: get rid of indices, express this using stranspose and listset *)"], ["", "lemma product_trace_smap:\n      assumes \"length ps = length AA\" \"k < length AA\"\n      shows \"smap (\\<lambda> ps. ps ! k) (b.trace (product AA) w ps) = a.trace (AA ! k) w (ps ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (\\<lambda>ps. ps ! k) (b.trace (product AA) w ps) =\n    a.trace (AA ! k) w (ps ! k)", "using assms"], ["proof (prove)\nusing this:\n  length ps = length AA\n  k < length AA\n\ngoal (1 subgoal):\n 1. smap (\\<lambda>ps. ps ! k) (b.trace (product AA) w ps) =\n    a.trace (AA ! k) w (ps ! k)", "by (coinduction arbitrary: w ps) (force)"], ["", "lemma product_nodes: \"b.nodes (product AA) \\<subseteq> listset (map a.nodes AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.nodes' (product AA) \\<subseteq> listset (map a.nodes' AA)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> b.nodes' (product AA) \\<Longrightarrow>\n       x \\<in> listset (map a.nodes' AA)", "show \"ps \\<in> listset (map a.nodes AA)\" if \"ps \\<in> b.nodes (product AA)\" for ps"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<in> listset (map a.nodes' AA)", "using that"], ["proof (prove)\nusing this:\n  ps \\<in> b.nodes' (product AA)\n\ngoal (1 subgoal):\n 1. ps \\<in> listset (map a.nodes' AA)", "by (induct) (auto simp: listset_member list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  ?ps \\<in> b.nodes' (product AA) \\<Longrightarrow>\n  ?ps \\<in> listset (map a.nodes' AA)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_nodes_finite[intro]:\n      assumes \"list_all (finite \\<circ> a.nodes) AA\"\n      shows \"finite (b.nodes (product AA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (b.nodes' (product AA))", "using list.pred_map product_nodes assms"], ["proof (prove)\nusing this:\n  list_all ?Q (map ?f ?x) = list_all (?Q \\<circ> ?f) ?x\n  b.nodes' (product ?AA) \\<subseteq> listset (map a.nodes' ?AA)\n  list_all (finite \\<circ> a.nodes') AA\n\ngoal (1 subgoal):\n 1. finite (b.nodes' (product AA))", "by (blast dest: finite_subset)"], ["", "lemma product_nodes_card:\n      assumes \"list_all (finite \\<circ> a.nodes) AA\"\n      shows \"card (b.nodes (product AA)) \\<le> prod_list (map (card \\<circ> a.nodes) AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "have \"card (b.nodes (product AA)) \\<le> card (listset (map a.nodes AA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA)) \\<le> card (listset (map a.nodes' AA))", "using list.pred_map product_nodes assms"], ["proof (prove)\nusing this:\n  list_all ?Q (map ?f ?x) = list_all (?Q \\<circ> ?f) ?x\n  b.nodes' (product ?AA) \\<subseteq> listset (map a.nodes' ?AA)\n  list_all (finite \\<circ> a.nodes') AA\n\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA)) \\<le> card (listset (map a.nodes' AA))", "by (blast intro: card_mono)"], ["proof (state)\nthis:\n  card (b.nodes' (product AA)) \\<le> card (listset (map a.nodes' AA))\n\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "also"], ["proof (state)\nthis:\n  card (b.nodes' (product AA)) \\<le> card (listset (map a.nodes' AA))\n\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "have \"\\<dots> = prod_list (map (card \\<circ> a.nodes) AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (listset (map a.nodes' AA)) =\n    prod_list (map (card \\<circ> a.nodes') AA)", "by simp"], ["proof (state)\nthis:\n  card (listset (map a.nodes' AA)) =\n  prod_list (map (card \\<circ> a.nodes') AA)\n\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "finally"], ["proof (chain)\npicking this:\n  card (b.nodes' (product AA))\n  \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (b.nodes' (product AA))\n  \\<le> prod_list (map (card \\<circ> a.nodes') AA)\n\ngoal (1 subgoal):\n 1. card (b.nodes' (product AA))\n    \\<le> prod_list (map (card \\<circ> a.nodes') AA)", "by this"], ["proof (state)\nthis:\n  card (b.nodes' (product AA))\n  \\<le> prod_list (map (card \\<circ> a.nodes') AA)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale automaton_intersection_list_run =\n    automaton_product_list\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      condition +\n    a: automaton_run automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_run automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and condition\n    +\n    assumes test[iff]: \"test\\<^sub>2 (condition cs) w rs ps \\<longleftrightarrow>\n      (\\<forall> k < length cs. test\\<^sub>1 (cs ! k) w (smap (\\<lambda> ps. ps ! k) rs) (ps ! k))\"\n  begin"], ["", "lemma product_language[simp]: \"b.language (product AA) = \\<Inter> (a.language ` set AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.language (product AA) = \\<Inter> (a.language ` set AA)", "unfolding a.language_def b.language_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {w. b.run' (product AA) w (initial\\<^sub>2 (product AA)) \\<and>\n        test\\<^sub>2 (condition\\<^sub>2 (product AA)) w\n         (b.trace (product AA) w (initial\\<^sub>2 (product AA)))\n         (initial\\<^sub>2 (product AA))} =\n    (\\<Inter>A\\<in>set AA.\n        {w. a.run' A w (initial\\<^sub>1 A) \\<and>\n            test\\<^sub>1 (condition\\<^sub>1 A) w\n             (a.trace A w (initial\\<^sub>1 A)) (initial\\<^sub>1 A)})", "unfolding a.run_alt_def b.run_alt_def streams_iff_sset"], ["proof (prove)\ngoal (1 subgoal):\n 1. {w. sset w \\<subseteq> alphabet\\<^sub>2 (product AA) \\<and>\n        test\\<^sub>2 (condition\\<^sub>2 (product AA)) w\n         (b.trace (product AA) w (initial\\<^sub>2 (product AA)))\n         (initial\\<^sub>2 (product AA))} =\n    (\\<Inter>A\\<in>set AA.\n        {w. sset w \\<subseteq> alphabet\\<^sub>1 A \\<and>\n            test\\<^sub>1 (condition\\<^sub>1 A) w\n             (a.trace A w (initial\\<^sub>1 A)) (initial\\<^sub>1 A)})", "by (fastforce simp: set_conv_nth product_trace_smap)"], ["", "end"], ["", "locale automaton_union_list_run =\n    automaton_product_list\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      condition +\n    a: automaton_run automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_run automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and condition\n    +\n    assumes test[iff]: \"test\\<^sub>2 (condition cs) w rs ps \\<longleftrightarrow>\n      (\\<exists> k < length cs. test\\<^sub>1 (cs ! k) w (smap (\\<lambda> ps. ps ! k) rs) (ps ! k))\"\n  begin"], ["", "lemma product_language[simp]:\n      assumes \"\\<Inter> (alphabet\\<^sub>1 ` set AA) = \\<Union> (alphabet\\<^sub>1 ` set AA)\"\n      shows \"b.language (product AA) = \\<Union> (a.language ` set AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.language (product AA) = \\<Union> (a.language ` set AA)", "using assms"], ["proof (prove)\nusing this:\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n\ngoal (1 subgoal):\n 1. b.language (product AA) = \\<Union> (a.language ` set AA)", "unfolding a.language_def b.language_def"], ["proof (prove)\nusing this:\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n\ngoal (1 subgoal):\n 1. {w. b.run' (product AA) w (initial\\<^sub>2 (product AA)) \\<and>\n        test\\<^sub>2 (condition\\<^sub>2 (product AA)) w\n         (b.trace (product AA) w (initial\\<^sub>2 (product AA)))\n         (initial\\<^sub>2 (product AA))} =\n    (\\<Union>A\\<in>set AA.\n        {w. a.run' A w (initial\\<^sub>1 A) \\<and>\n            test\\<^sub>1 (condition\\<^sub>1 A) w\n             (a.trace A w (initial\\<^sub>1 A)) (initial\\<^sub>1 A)})", "unfolding a.run_alt_def b.run_alt_def streams_iff_sset"], ["proof (prove)\nusing this:\n  \\<Inter> (alphabet\\<^sub>1 ` set AA) =\n  \\<Union> (alphabet\\<^sub>1 ` set AA)\n\ngoal (1 subgoal):\n 1. {w. sset w \\<subseteq> alphabet\\<^sub>2 (product AA) \\<and>\n        test\\<^sub>2 (condition\\<^sub>2 (product AA)) w\n         (b.trace (product AA) w (initial\\<^sub>2 (product AA)))\n         (initial\\<^sub>2 (product AA))} =\n    (\\<Union>A\\<in>set AA.\n        {w. sset w \\<subseteq> alphabet\\<^sub>1 A \\<and>\n            test\\<^sub>1 (condition\\<^sub>1 A) w\n             (a.trace A w (initial\\<^sub>1 A)) (initial\\<^sub>1 A)})", "by (fastforce simp: set_conv_nth product_trace_smap)"], ["", "end"], ["", "locale automaton_complement =\n    a: automaton automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 +\n    b: automaton automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    for automaton\\<^sub>1 :: \"'label set \\<Rightarrow> 'state \\<Rightarrow> ('label \\<Rightarrow> 'state \\<Rightarrow> 'state) \\<Rightarrow> 'condition\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>1\"\n    and alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n    and automaton\\<^sub>2 :: \"'label set \\<Rightarrow> 'state \\<Rightarrow> ('label \\<Rightarrow> 'state \\<Rightarrow> 'state) \\<Rightarrow> 'condition\\<^sub>2 \\<Rightarrow> 'automaton\\<^sub>2\"\n    and alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n    +\n    fixes condition :: \"'condition\\<^sub>1 \\<Rightarrow> 'condition\\<^sub>2\"\n  begin"], ["", "definition complement :: \"'automaton\\<^sub>1 \\<Rightarrow> 'automaton\\<^sub>2\" where\n      \"complement A \\<equiv> automaton\\<^sub>2 (alphabet\\<^sub>1 A) (initial\\<^sub>1 A) (transition\\<^sub>1 A) (condition (condition\\<^sub>1 A))\""], ["", "lemma combine_simps[simp]:\n      \"alphabet\\<^sub>2 (complement A) = alphabet\\<^sub>1 A\"\n      \"initial\\<^sub>2 (complement A) = initial\\<^sub>1 A\"\n      \"transition\\<^sub>2 (complement A) = transition\\<^sub>1 A\"\n      \"condition\\<^sub>2 (complement A) = condition (condition\\<^sub>1 A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2 (complement A) = alphabet\\<^sub>1 A &&&\n     initial\\<^sub>2 (complement A) = initial\\<^sub>1 A) &&&\n    transition\\<^sub>2 (complement A) = transition\\<^sub>1 A &&&\n    condition\\<^sub>2 (complement A) = condition (condition\\<^sub>1 A)", "unfolding complement_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (alphabet\\<^sub>2\n      (automaton\\<^sub>2 (alphabet\\<^sub>1 A) (initial\\<^sub>1 A)\n        (transition\\<^sub>1 A) (condition (condition\\<^sub>1 A))) =\n     alphabet\\<^sub>1 A &&&\n     initial\\<^sub>2\n      (automaton\\<^sub>2 (alphabet\\<^sub>1 A) (initial\\<^sub>1 A)\n        (transition\\<^sub>1 A) (condition (condition\\<^sub>1 A))) =\n     initial\\<^sub>1 A) &&&\n    transition\\<^sub>2\n     (automaton\\<^sub>2 (alphabet\\<^sub>1 A) (initial\\<^sub>1 A)\n       (transition\\<^sub>1 A) (condition (condition\\<^sub>1 A))) =\n    transition\\<^sub>1 A &&&\n    condition\\<^sub>2\n     (automaton\\<^sub>2 (alphabet\\<^sub>1 A) (initial\\<^sub>1 A)\n       (transition\\<^sub>1 A) (condition (condition\\<^sub>1 A))) =\n    condition (condition\\<^sub>1 A)", "by auto"], ["", "end"], ["", "locale automaton_complement_path =\n    automaton_complement\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      condition +\n    a: automaton_path automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_path automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and condition\n    +\n    assumes test[iff]: \"test\\<^sub>2 (condition c) w r p \\<longleftrightarrow> \\<not> test\\<^sub>1 c w r p\"\n  begin"], ["", "lemma complement_language[simp]: \"b.language (complement A) = lists (alphabet\\<^sub>1 A) - a.language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.language (complement A) = lists (alphabet\\<^sub>1 A) - a.language A", "unfolding a.language_def b.language_def a.path_alt_def b.path_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {w \\<in> lists (alphabet\\<^sub>2 (complement A)).\n     test\\<^sub>2 (condition\\<^sub>2 (complement A)) w\n      (b.states (complement A) w (initial\\<^sub>2 (complement A)))\n      (initial\\<^sub>2 (complement A))} =\n    lists (alphabet\\<^sub>1 A) -\n    {w \\<in> lists (alphabet\\<^sub>1 A).\n     test\\<^sub>1 (condition\\<^sub>1 A) w (a.states A w (initial\\<^sub>1 A))\n      (initial\\<^sub>1 A)}", "by auto"], ["", "end"], ["", "locale automaton_complement_run =\n    automaton_complement\n      automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1\n      automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2\n      condition +\n    a: automaton_run automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1 +\n    b: automaton_run automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    for automaton\\<^sub>1 alphabet\\<^sub>1 initial\\<^sub>1 transition\\<^sub>1 condition\\<^sub>1 test\\<^sub>1\n    and automaton\\<^sub>2 alphabet\\<^sub>2 initial\\<^sub>2 transition\\<^sub>2 condition\\<^sub>2 test\\<^sub>2\n    and condition\n    +\n    assumes test[iff]: \"test\\<^sub>2 (condition c) w r p \\<longleftrightarrow> \\<not> test\\<^sub>1 c w r p\"\n  begin"], ["", "lemma complement_language[simp]: \"b.language (complement A) = streams (alphabet\\<^sub>1 A) - a.language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b.language (complement A) = streams (alphabet\\<^sub>1 A) - a.language A", "unfolding a.language_def b.language_def a.run_alt_def b.run_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {w \\<in> streams (alphabet\\<^sub>2 (complement A)).\n     test\\<^sub>2 (condition\\<^sub>2 (complement A)) w\n      (b.trace (complement A) w (initial\\<^sub>2 (complement A)))\n      (initial\\<^sub>2 (complement A))} =\n    streams (alphabet\\<^sub>1 A) -\n    {w \\<in> streams (alphabet\\<^sub>1 A).\n     test\\<^sub>1 (condition\\<^sub>1 A) w (a.trace A w (initial\\<^sub>1 A))\n      (initial\\<^sub>1 A)}", "by auto"], ["", "end"], ["", "end"]]}