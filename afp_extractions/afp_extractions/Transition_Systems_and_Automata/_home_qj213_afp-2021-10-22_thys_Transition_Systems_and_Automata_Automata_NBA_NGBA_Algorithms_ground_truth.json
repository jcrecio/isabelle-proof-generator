{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Automata/NBA/NGBA_Algorithms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemmas [autoref_op_pat] = op_language_empty_def[symmetric]", "lemma ngba_g_ahs: \"ngba_g A = \\<lparr> g_V = UNIV, g_E = E_of_succ (\\<lambda> p. CAST\n      ((\\<Union> a \\<in> ngba.alphabet A. ngba.transition A a p ::: \\<langle>S\\<rangle> list_set_rel) ::: \\<langle>S\\<rangle> ahs_rel bhc)),\n      g_V0 = ngba.initial A \\<rparr>\"", "lemma ngbai_gi_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      shows \"(NGBA_Algorithms.ngbai_gi seq bhc hms, ngba_g) \\<in>\n        \\<langle>L, S\\<rangle> ngbai_ngba_rel \\<rightarrow> \\<langle>unit_rel, S\\<rangle> g_impl_rel_ext\"", "lemma ngba_nodes_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (NGBA.nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> ngbai_ngba_rel\"\n      shows \"(NGBA_Algorithms.ngba_nodes seq bhc hms Ai,\n        (OP NGBA.nodes ::: \\<langle>L, S\\<rangle> ngbai_ngba_rel \\<rightarrow> \\<langle>S\\<rangle> ahs_rel bhc) $ A) \\<in> \\<langle>S\\<rangle> ahs_rel bhc\"", "lemma ngba_igbg_ahs: \"ngba_igbg A = \\<lparr> g_V = UNIV, g_E = E_of_succ (\\<lambda> p. CAST\n      ((\\<Union> a \\<in> NGBA.alphabet A. NGBA.transition A a p ::: \\<langle>S\\<rangle> list_set_rel) ::: \\<langle>S\\<rangle> ahs_rel bhc)), g_V0 = NGBA.initial A,\n      igbg_num_acc = length (NGBA.accepting A), igbg_acc = ngba_acc (NGBA.accepting A) \\<rparr>\"", "lemma ngba_acc_bs_empty[simp]: \"ngba_acc_bs [] p = bs_empty ()\"", "lemma ngba_acc_bs_insert[simp]:\n      assumes \"c p\"\n      shows \"ngba_acc_bs (cs @ [c]) p = bs_insert (length cs) (ngba_acc_bs cs p)\"", "lemma ngba_acc_bs_skip[simp]:\n      assumes \"\\<not> c p\"\n      shows \"ngba_acc_bs (cs @ [c]) p = ngba_acc_bs cs p\"", "lemma ngba_acc_bs_correct[simp]: \"bs_\\<alpha> (ngba_acc_bs cs p) = ngba_acc cs p\"", "lemma ngba_acc_impl_bs[autoref_rules]: \"(ngba_acc_bs, ngba_acc) \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow> S \\<rightarrow> \\<langle>nat_rel\\<rangle> bs_set_rel\"", "lemma ngbai_igbgi_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      shows \"(NGBA_Algorithms.ngbai_igbgi seq bhc hms, ngba_igbg) \\<in>\n        \\<langle>L, S\\<rangle> ngbai_ngba_rel \\<rightarrow> igbg_impl_rel_ext unit_rel S\"", "lemma nba_language_empty_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (NGBA.nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> ngbai_ngba_rel\"\n      shows \"(NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n        (OP op_language_empty ::: \\<langle>L, S\\<rangle> ngbai_ngba_rel \\<rightarrow> bool_rel) $ A) \\<in> bool_rel\"", "lemma degeneralize_alt_def: \"degeneralize A = nba\n      (ngba.alphabet A)\n      ((\\<lambda> p. (p, 0)) ` ngba.initial A)\n      (\\<lambda> a (p, k). (\\<lambda> q. (q, Degeneralization.count (ngba.accepting A) p k)) ` ngba.transition A a p)\n      (degen (ngba.accepting A))\"", "lemmas ngba_degeneralize_refine[autoref_rules] = ngba_degeneralize.refine", "lemma nba_intersect'_refine[autoref_rules]:\n      assumes \"GEN_OP seq HOL.eq (L \\<rightarrow> L \\<rightarrow> bool_rel)\"\n      shows \"(nba_intersect' seq, intersect') \\<in>\n        \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>L, T\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>L, S \\<times>\\<^sub>r T\\<rangle> ngbai_ngba_rel\""], "translations": [["", "lemmas [autoref_op_pat] = op_language_empty_def[symmetric]"], ["", "subsection \\<open>Implementations\\<close>"], ["", "context\n  begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "by this"], ["", "lemma ngba_g_ahs: \"ngba_g A = \\<lparr> g_V = UNIV, g_E = E_of_succ (\\<lambda> p. CAST\n      ((\\<Union> a \\<in> ngba.alphabet A. ngba.transition A a p ::: \\<langle>S\\<rangle> list_set_rel) ::: \\<langle>S\\<rangle> ahs_rel bhc)),\n      g_V0 = ngba.initial A \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ngba_g A =\n    \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ\n          (\\<lambda>p.\n              CAST\n               ((\\<Union>a\\<in>ngba.alphabet A.\n                    ngba.transition A a p :::\n                    \\<langle>S\\<rangle>list_set_rel) :::\n                \\<langle>S\\<rangle>ahs_rel bhc)),\n       g_V0 = ngba.initial A\\<rparr>", "unfolding ngba_g_def ngba.successors_alt_def CAST_def id_apply autoref_tag_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ\n          (\\<lambda>p.\n              \\<Union>a\\<in>ngba.alphabet A. ngba.transition A a p),\n       g_V0 = ngba.initial A\\<rparr> =\n    \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ\n          (\\<lambda>p.\n              \\<Union>a\\<in>ngba.alphabet A. ngba.transition A a p),\n       g_V0 = ngba.initial A\\<rparr>", "by rule"], ["", "schematic_goal ngbai_gi:\n      notes [autoref_ga_rules] = map2set_to_list\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhc\"\n      assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n      assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n      assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> ngbai_ngba_rel\"\n      shows \"(?f :: ?'a, RETURN (ngba_g A)) \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, RETURN (ngba_g A)) \\<in> ?A", "unfolding ngba_g_ahs[where S = S and bhc = bhc]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     RETURN\n      \\<lparr>g_V = UNIV,\n         g_E =\n           E_of_succ\n            (\\<lambda>p.\n                CAST\n                 ((\\<Union>a\\<in>ngba.alphabet A.\n                      ngba.transition A a p :::\n                      \\<langle>S\\<rangle>list_set_rel) :::\n                  \\<langle>S\\<rangle>ahs_rel bhc)),\n         g_V0 = ngba.initial A\\<rparr>)\n    \\<in> ?A", "by (autoref_monadic (plain))"], ["", "concrete_definition ngbai_gi uses ngbai_gi"], ["", "lemma ngbai_gi_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      shows \"(NGBA_Algorithms.ngbai_gi seq bhc hms, ngba_g) \\<in>\n        \\<langle>L, S\\<rangle> ngbai_ngba_rel \\<rightarrow> \\<langle>unit_rel, S\\<rangle> g_impl_rel_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngbai_gi seq bhc hms, ngba_g)\n    \\<in> \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n          \\<langle>unit_rel, S\\<rangle>g_impl_rel_ext", "using ngbai_gi.refine[THEN RETURN_nres_relD] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_bounded_hashcode ?S1 ?seq1 ?bhc1;\n   is_valid_def_hm_size TYPE(?'a1) ?hms1;\n   (?seq1, (=)) \\<in> ?S1 \\<rightarrow> ?S1 \\<rightarrow> bool_rel;\n   (?Ai1, ?A1) \\<in> \\<langle>?L1, ?S1\\<rangle>ngbai_ngba_rel\\<rbrakk>\n  \\<Longrightarrow> (NGBA_Algorithms.ngbai_gi ?seq1 ?bhc1 ?hms1 ?Ai1,\n                     ngba_g ?A1)\n                    \\<in> \\<langle>unit_rel, ?S1\\<rangle>g_impl_rel_ext\n  SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\n  GEN_OP seq (=) (S \\<rightarrow> S \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngbai_gi seq bhc hms, ngba_g)\n    \\<in> \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n          \\<langle>unit_rel, S\\<rangle>g_impl_rel_ext", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_bounded_hashcode ?S1 ?seq1 ?bhc1;\n   is_valid_def_hm_size TYPE(?'a1) ?hms1;\n   (?seq1, (=)) \\<in> ?S1 \\<rightarrow> ?S1 \\<rightarrow> bool_rel;\n   (?Ai1, ?A1) \\<in> \\<langle>?L1, ?S1\\<rangle>ngbai_ngba_rel\\<rbrakk>\n  \\<Longrightarrow> (NGBA_Algorithms.ngbai_gi ?seq1 ?bhc1 ?hms1 ?Ai1,\n                     ngba_g ?A1)\n                    \\<in> \\<langle>unit_rel, ?S1\\<rangle>g_impl_rel_ext\n  is_bounded_hashcode S seq bhc\n  is_valid_def_hm_size TYPE('statei) hms\n  (seq, (=)) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngbai_gi seq bhc hms, ngba_g)\n    \\<in> \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n          \\<langle>unit_rel, S\\<rangle>g_impl_rel_ext", "by blast"], ["", "schematic_goal ngba_nodes:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes [simp]: \"finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))\"\n      assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhc\"\n      assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n      assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n      assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> ngbai_ngba_rel\"\n      shows \"(?f :: ?'a, op_reachable (ngba_g A)) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, op_reachable (ngba_g A)) \\<in> ?R", "by autoref"], ["", "concrete_definition ngba_nodes uses ngba_nodes"], ["", "lemma ngba_nodes_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (NGBA.nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> ngbai_ngba_rel\"\n      shows \"(NGBA_Algorithms.ngba_nodes seq bhc hms Ai,\n        (OP NGBA.nodes ::: \\<langle>L, S\\<rangle> ngbai_ngba_rel \\<rightarrow> \\<langle>S\\<rangle> ahs_rel bhc) $ A) \\<in> \\<langle>S\\<rangle> ahs_rel bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_nodes seq bhc hms Ai,\n     (OP NGBA.nodes :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_nodes seq bhc hms Ai,\n     (OP NGBA.nodes :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "have 1: \"NGBA.nodes A = op_reachable (ngba_g A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NGBA.nodes A = op_reachable (ngba_g A)", "by (auto simp: ngba_g_V0 ngba_g_E_rtrancl)"], ["proof (state)\nthis:\n  NGBA.nodes A = op_reachable (ngba_g A)\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_nodes seq bhc hms Ai,\n     (OP NGBA.nodes :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "have 2: \"finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))", "using assms(1)"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (finite (NGBA.nodes A))\n\ngoal (1 subgoal):\n 1. finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))", "unfolding 1"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (finite (op_reachable (ngba_g A)))\n\ngoal (1 subgoal):\n 1. finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))", "by simp"], ["proof (state)\nthis:\n  finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_nodes seq bhc hms Ai,\n     (OP NGBA.nodes :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_nodes seq bhc hms Ai,\n     (OP NGBA.nodes :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "using ngba_nodes.refine assms 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ((g_E (ngba_g ?A))\\<^sup>* `` g_V0 (ngba_g ?A));\n   is_bounded_hashcode ?S ?seq ?bhc; is_valid_def_hm_size TYPE(?'c) ?hms;\n   (?seq, (=)) \\<in> ?S \\<rightarrow> ?S \\<rightarrow> bool_rel;\n   (?Ai, ?A) \\<in> \\<langle>?L, ?S\\<rangle>ngbai_ngba_rel\\<rbrakk>\n  \\<Longrightarrow> (NGBA_Algorithms.ngba_nodes ?seq ?bhc ?hms ?Ai,\n                     op_reachable (ngba_g ?A))\n                    \\<in> \\<langle>?S\\<rangle>ahs_rel ?bhc\n  SIDE_PRECOND (finite (NGBA.nodes A))\n  SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\n  GEN_OP seq (=) (S \\<rightarrow> S \\<rightarrow> bool_rel)\n  (Ai, A) \\<in> \\<langle>L, S\\<rangle>ngbai_ngba_rel\n  finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_nodes seq bhc hms Ai,\n     (OP NGBA.nodes :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n      \\<langle>S\\<rangle>ahs_rel bhc) $\n     A)\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "unfolding autoref_tag_defs 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ((g_E (ngba_g ?A))\\<^sup>* `` g_V0 (ngba_g ?A));\n   is_bounded_hashcode ?S ?seq ?bhc; is_valid_def_hm_size TYPE(?'c) ?hms;\n   (?seq, (=)) \\<in> ?S \\<rightarrow> ?S \\<rightarrow> bool_rel;\n   (?Ai, ?A) \\<in> \\<langle>?L, ?S\\<rangle>ngbai_ngba_rel\\<rbrakk>\n  \\<Longrightarrow> (NGBA_Algorithms.ngba_nodes ?seq ?bhc ?hms ?Ai,\n                     op_reachable (ngba_g ?A))\n                    \\<in> \\<langle>?S\\<rangle>ahs_rel ?bhc\n  finite (op_reachable (ngba_g A))\n  is_bounded_hashcode S seq bhc\n  is_valid_def_hm_size TYPE('statei) hms\n  (seq, (=)) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\n  (Ai, A) \\<in> \\<langle>L, S\\<rangle>ngbai_ngba_rel\n  finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_nodes seq bhc hms Ai, op_reachable (ngba_g A))\n    \\<in> \\<langle>S\\<rangle>ahs_rel bhc", "by blast"], ["proof (state)\nthis:\n  (NGBA_Algorithms.ngba_nodes seq bhc hms Ai,\n   (OP NGBA.nodes :::\n    \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n    \\<langle>S\\<rangle>ahs_rel bhc) $\n   A)\n  \\<in> \\<langle>S\\<rangle>ahs_rel bhc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ngba_igbg_ahs: \"ngba_igbg A = \\<lparr> g_V = UNIV, g_E = E_of_succ (\\<lambda> p. CAST\n      ((\\<Union> a \\<in> NGBA.alphabet A. NGBA.transition A a p ::: \\<langle>S\\<rangle> list_set_rel) ::: \\<langle>S\\<rangle> ahs_rel bhc)), g_V0 = NGBA.initial A,\n      igbg_num_acc = length (NGBA.accepting A), igbg_acc = ngba_acc (NGBA.accepting A) \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ngba_igbg A =\n    \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ\n          (\\<lambda>p.\n              CAST\n               ((\\<Union>a\\<in>ngba.alphabet A.\n                    ngba.transition A a p :::\n                    \\<langle>S\\<rangle>list_set_rel) :::\n                \\<langle>S\\<rangle>ahs_rel bhc)),\n       g_V0 = ngba.initial A, igbg_num_acc = length (ngba.accepting A),\n       igbg_acc = ngba_acc (ngba.accepting A)\\<rparr>", "unfolding ngba_g_def ngba_igbg_def ngba.successors_alt_def CAST_def id_apply autoref_tag_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_rec.extend\n     \\<lparr>g_V = UNIV,\n        g_E =\n          E_of_succ\n           (\\<lambda>p.\n               \\<Union>a\\<in>ngba.alphabet A. ngba.transition A a p),\n        g_V0 = ngba.initial A\\<rparr>\n     \\<lparr>igbg_num_acc = length (ngba.accepting A),\n        igbg_acc = ngba_acc (ngba.accepting A)\\<rparr> =\n    \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ\n          (\\<lambda>p.\n              \\<Union>a\\<in>ngba.alphabet A. ngba.transition A a p),\n       g_V0 = ngba.initial A, igbg_num_acc = length (ngba.accepting A),\n       igbg_acc = ngba_acc (ngba.accepting A)\\<rparr>", "unfolding graph_rec.defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>g_V =\n              g_V \\<lparr>g_V = UNIV,\n                     g_E =\n                       E_of_succ\n                        (\\<lambda>p.\n                            \\<Union>a\\<in>ngba.alphabet A.\n                               ngba.transition A a p),\n                     g_V0 = ngba.initial A\\<rparr>,\n       g_E =\n         g_E \\<lparr>g_V = UNIV,\n                g_E =\n                  E_of_succ\n                   (\\<lambda>p.\n                       \\<Union>a\\<in>ngba.alphabet A.\n                          ngba.transition A a p),\n                g_V0 = ngba.initial A\\<rparr>,\n       g_V0 =\n         g_V0\n          \\<lparr>g_V = UNIV,\n             g_E =\n               E_of_succ\n                (\\<lambda>p.\n                    \\<Union>a\\<in>ngba.alphabet A. ngba.transition A a p),\n             g_V0 = ngba.initial A\\<rparr>,\n       igbg_num_acc = length (ngba.accepting A),\n       igbg_acc = ngba_acc (ngba.accepting A)\\<rparr> =\n    \\<lparr>g_V = UNIV,\n       g_E =\n         E_of_succ\n          (\\<lambda>p.\n              \\<Union>a\\<in>ngba.alphabet A. ngba.transition A a p),\n       g_V0 = ngba.initial A, igbg_num_acc = length (ngba.accepting A),\n       igbg_acc = ngba_acc (ngba.accepting A)\\<rparr>", "by simp"], ["", "definition \"ngba_acc_bs cs p \\<equiv> fold (\\<lambda> (k, c) bs. if c p then bs_insert k bs else bs) (List.enumerate 0 cs) (bs_empty ())\""], ["", "lemma ngba_acc_bs_empty[simp]: \"ngba_acc_bs [] p = bs_empty ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ngba_acc_bs [] p = bs_empty ()", "unfolding ngba_acc_bs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, c) bs. if c p then bs_insert k bs else bs)\n     (List.enumerate 0 []) (bs_empty ()) =\n    bs_empty ()", "by simp"], ["", "lemma ngba_acc_bs_insert[simp]:\n      assumes \"c p\"\n      shows \"ngba_acc_bs (cs @ [c]) p = bs_insert (length cs) (ngba_acc_bs cs p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ngba_acc_bs (cs @ [c]) p = bs_insert (length cs) (ngba_acc_bs cs p)", "using assms"], ["proof (prove)\nusing this:\n  c p\n\ngoal (1 subgoal):\n 1. ngba_acc_bs (cs @ [c]) p = bs_insert (length cs) (ngba_acc_bs cs p)", "unfolding ngba_acc_bs_def"], ["proof (prove)\nusing this:\n  c p\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, c) bs. if c p then bs_insert k bs else bs)\n     (List.enumerate 0 (cs @ [c])) (bs_empty ()) =\n    bs_insert (length cs)\n     (fold (\\<lambda>(k, c) bs. if c p then bs_insert k bs else bs)\n       (List.enumerate 0 cs) (bs_empty ()))", "by (simp add: enumerate_append_eq)"], ["", "lemma ngba_acc_bs_skip[simp]:\n      assumes \"\\<not> c p\"\n      shows \"ngba_acc_bs (cs @ [c]) p = ngba_acc_bs cs p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ngba_acc_bs (cs @ [c]) p = ngba_acc_bs cs p", "using assms"], ["proof (prove)\nusing this:\n  \\<not> c p\n\ngoal (1 subgoal):\n 1. ngba_acc_bs (cs @ [c]) p = ngba_acc_bs cs p", "unfolding ngba_acc_bs_def"], ["proof (prove)\nusing this:\n  \\<not> c p\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, c) bs. if c p then bs_insert k bs else bs)\n     (List.enumerate 0 (cs @ [c])) (bs_empty ()) =\n    fold (\\<lambda>(k, c) bs. if c p then bs_insert k bs else bs)\n     (List.enumerate 0 cs) (bs_empty ())", "by (simp add: enumerate_append_eq)"], ["", "lemma ngba_acc_bs_correct[simp]: \"bs_\\<alpha> (ngba_acc_bs cs p) = ngba_acc cs p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (ngba_acc_bs cs p) = ngba_acc cs p", "proof (induct cs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. bs_\\<alpha> (ngba_acc_bs [] p) = ngba_acc [] p\n 2. \\<And>x xs.\n       bs_\\<alpha> (ngba_acc_bs xs p) = ngba_acc xs p \\<Longrightarrow>\n       bs_\\<alpha> (ngba_acc_bs (xs @ [x]) p) = ngba_acc (xs @ [x]) p", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. bs_\\<alpha> (ngba_acc_bs [] p) = ngba_acc [] p\n 2. \\<And>x xs.\n       bs_\\<alpha> (ngba_acc_bs xs p) = ngba_acc xs p \\<Longrightarrow>\n       bs_\\<alpha> (ngba_acc_bs (xs @ [x]) p) = ngba_acc (xs @ [x]) p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (ngba_acc_bs [] p) = ngba_acc [] p", "unfolding ngba_acc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (ngba_acc_bs [] p) = {k \\<in> {0..<length []}. ([] ! k) p}", "by simp"], ["proof (state)\nthis:\n  bs_\\<alpha> (ngba_acc_bs [] p) = ngba_acc [] p\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       bs_\\<alpha> (ngba_acc_bs xs p) = ngba_acc xs p \\<Longrightarrow>\n       bs_\\<alpha> (ngba_acc_bs (xs @ [x]) p) = ngba_acc (xs @ [x]) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       bs_\\<alpha> (ngba_acc_bs xs p) = ngba_acc xs p \\<Longrightarrow>\n       bs_\\<alpha> (ngba_acc_bs (xs @ [x]) p) = ngba_acc (xs @ [x]) p", "case (snoc c cs)"], ["proof (state)\nthis:\n  bs_\\<alpha> (ngba_acc_bs cs p) = ngba_acc cs p\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       bs_\\<alpha> (ngba_acc_bs xs p) = ngba_acc xs p \\<Longrightarrow>\n       bs_\\<alpha> (ngba_acc_bs (xs @ [x]) p) = ngba_acc (xs @ [x]) p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (ngba_acc_bs (cs @ [c]) p) = ngba_acc (cs @ [c]) p", "using less_Suc_eq snoc"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n  bs_\\<alpha> (ngba_acc_bs cs p) = ngba_acc cs p\n\ngoal (1 subgoal):\n 1. bs_\\<alpha> (ngba_acc_bs (cs @ [c]) p) = ngba_acc (cs @ [c]) p", "by (cases \"c p\") (force simp: ngba_acc_def)+"], ["proof (state)\nthis:\n  bs_\\<alpha> (ngba_acc_bs (cs @ [c]) p) = ngba_acc (cs @ [c]) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ngba_acc_impl_bs[autoref_rules]: \"(ngba_acc_bs, ngba_acc) \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow> S \\<rightarrow> \\<langle>nat_rel\\<rangle> bs_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ngba_acc_bs, ngba_acc)\n    \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ngba_acc_bs, ngba_acc)\n    \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel", "have \"(ngba_acc_bs, ngba_acc) \\<in> \\<langle>Id \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow> Id \\<rightarrow> \\<langle>nat_rel\\<rangle> bs_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ngba_acc_bs, ngba_acc)\n    \\<in> \\<langle>Id \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          Id \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel", "by (auto simp: bs_set_rel_def in_br_conv)"], ["proof (state)\nthis:\n  (ngba_acc_bs, ngba_acc)\n  \\<in> \\<langle>Id \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n        Id \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\n\ngoal (1 subgoal):\n 1. (ngba_acc_bs, ngba_acc)\n    \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel", "also"], ["proof (state)\nthis:\n  (ngba_acc_bs, ngba_acc)\n  \\<in> \\<langle>Id \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n        Id \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\n\ngoal (1 subgoal):\n 1. (ngba_acc_bs, ngba_acc)\n    \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel", "have \"(ngba_acc, ngba_acc) \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow> S \\<rightarrow> \\<langle>nat_rel\\<rangle> set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ngba_acc, ngba_acc)\n    \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>nat_rel\\<rangle>set_rel", "by parametricity"], ["proof (state)\nthis:\n  (ngba_acc, ngba_acc)\n  \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n        S \\<rightarrow> \\<langle>nat_rel\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. (ngba_acc_bs, ngba_acc)\n    \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel", "finally"], ["proof (chain)\npicking this:\n  (ngba_acc_bs, ngba_acc)\n  \\<in> \\<langle>Id \\<rightarrow> bool_rel\\<rangle>list_rel O\n        \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n        Id O S \\<rightarrow>\n        \\<langle>nat_rel\\<rangle>bs_set_rel O\n        \\<langle>nat_rel\\<rangle>set_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (ngba_acc_bs, ngba_acc)\n  \\<in> \\<langle>Id \\<rightarrow> bool_rel\\<rangle>list_rel O\n        \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n        Id O S \\<rightarrow>\n        \\<langle>nat_rel\\<rangle>bs_set_rel O\n        \\<langle>nat_rel\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. (ngba_acc_bs, ngba_acc)\n    \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel", "by simp"], ["proof (state)\nthis:\n  (ngba_acc_bs, ngba_acc)\n  \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n        S \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "schematic_goal ngbai_igbgi:\n      notes [autoref_ga_rules] = map2set_to_list\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhc\"\n      assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n      assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n      assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> ngbai_ngba_rel\"\n      shows \"(?f :: ?'a, RETURN (ngba_igbg A)) \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, RETURN (ngba_igbg A)) \\<in> ?A", "unfolding ngba_igbg_ahs[where S = S and bhc = bhc]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     RETURN\n      \\<lparr>g_V = UNIV,\n         g_E =\n           E_of_succ\n            (\\<lambda>p.\n                CAST\n                 ((\\<Union>a\\<in>ngba.alphabet A.\n                      ngba.transition A a p :::\n                      \\<langle>S\\<rangle>list_set_rel) :::\n                  \\<langle>S\\<rangle>ahs_rel bhc)),\n         g_V0 = ngba.initial A, igbg_num_acc = length (ngba.accepting A),\n         igbg_acc = ngba_acc (ngba.accepting A)\\<rparr>)\n    \\<in> ?A", "by (autoref_monadic (plain))"], ["", "concrete_definition ngbai_igbgi uses ngbai_igbgi"], ["", "lemma ngbai_igbgi_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      shows \"(NGBA_Algorithms.ngbai_igbgi seq bhc hms, ngba_igbg) \\<in>\n        \\<langle>L, S\\<rangle> ngbai_ngba_rel \\<rightarrow> igbg_impl_rel_ext unit_rel S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngbai_igbgi seq bhc hms, ngba_igbg)\n    \\<in> \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n          igbg_impl_rel_ext unit_rel S", "using ngbai_igbgi.refine[THEN RETURN_nres_relD] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_bounded_hashcode ?S1 ?seq1 ?bhc1;\n   is_valid_def_hm_size TYPE(?'a1) ?hms1;\n   (?seq1, (=)) \\<in> ?S1 \\<rightarrow> ?S1 \\<rightarrow> bool_rel;\n   (?Ai1, ?A1) \\<in> \\<langle>?L1, ?S1\\<rangle>ngbai_ngba_rel\\<rbrakk>\n  \\<Longrightarrow> (NGBA_Algorithms.ngbai_igbgi ?seq1 ?bhc1 ?hms1 ?Ai1,\n                     ngba_igbg ?A1)\n                    \\<in> igbg_impl_rel_ext unit_rel ?S1\n  SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\n  GEN_OP seq (=) (S \\<rightarrow> S \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngbai_igbgi seq bhc hms, ngba_igbg)\n    \\<in> \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n          igbg_impl_rel_ext unit_rel S", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_bounded_hashcode ?S1 ?seq1 ?bhc1;\n   is_valid_def_hm_size TYPE(?'a1) ?hms1;\n   (?seq1, (=)) \\<in> ?S1 \\<rightarrow> ?S1 \\<rightarrow> bool_rel;\n   (?Ai1, ?A1) \\<in> \\<langle>?L1, ?S1\\<rangle>ngbai_ngba_rel\\<rbrakk>\n  \\<Longrightarrow> (NGBA_Algorithms.ngbai_igbgi ?seq1 ?bhc1 ?hms1 ?Ai1,\n                     ngba_igbg ?A1)\n                    \\<in> igbg_impl_rel_ext unit_rel ?S1\n  is_bounded_hashcode S seq bhc\n  is_valid_def_hm_size TYPE('statei) hms\n  (seq, (=)) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngbai_igbgi seq bhc hms, ngba_igbg)\n    \\<in> \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow>\n          igbg_impl_rel_ext unit_rel S", "by blast"], ["", "schematic_goal ngba_language_empty:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes [simp]: \"igb_fr_graph (ngba_igbg A)\"\n      assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhs\"\n      assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n      assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n      assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> ngbai_ngba_rel\"\n      shows \"(?f :: ?'a, do { r \\<leftarrow> op_find_lasso_spec (ngba_igbg A); RETURN (r = None)}) \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     op_find_lasso_spec (ngba_igbg A) \\<bind>\n     (\\<lambda>r. RETURN (r = None)))\n    \\<in> ?A", "by (autoref_monadic (plain))"], ["", "concrete_definition ngba_language_empty uses ngba_language_empty"], ["", "lemma nba_language_empty_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (NGBA.nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> ngbai_ngba_rel\"\n      shows \"(NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n        (OP op_language_empty ::: \\<langle>L, S\\<rangle> ngbai_ngba_rel \\<rightarrow> bool_rel) $ A) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have 1: \"NGBA.nodes A = op_reachable (ngba_g A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NGBA.nodes A = op_reachable (ngba_g A)", "by (auto simp: ngba_g_V0 ngba_g_E_rtrancl)"], ["proof (state)\nthis:\n  NGBA.nodes A = op_reachable (ngba_g A)\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have 2: \"finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))", "using assms(1)"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (finite (NGBA.nodes A))\n\ngoal (1 subgoal):\n 1. finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))", "unfolding 1"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (finite (op_reachable (ngba_g A)))\n\ngoal (1 subgoal):\n 1. finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))", "by simp"], ["proof (state)\nthis:\n  finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "interpret igb_fr_graph \"ngba_igbg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_fr_graph (ngba_igbg A)", "using 2"], ["proof (prove)\nusing this:\n  finite ((g_E (ngba_g A))\\<^sup>* `` g_V0 (ngba_g A))\n\ngoal (1 subgoal):\n 1. igb_fr_graph (ngba_igbg A)", "unfolding ngba_igbg_def ngba_g_def graph_rec.defs ngba_acc_def"], ["proof (prove)\nusing this:\n  finite\n   ((g_E \\<lparr>g_V = UNIV, g_E = E_of_succ (NGBA.successors A),\n            g_V0 = ngba.initial A\\<rparr>)\\<^sup>* ``\n    g_V0\n     \\<lparr>g_V = UNIV, g_E = E_of_succ (NGBA.successors A),\n        g_V0 = ngba.initial A\\<rparr>)\n\ngoal (1 subgoal):\n 1. igb_fr_graph\n     \\<lparr>g_V =\n               g_V \\<lparr>g_V = UNIV, g_E = E_of_succ (NGBA.successors A),\n                      g_V0 = ngba.initial A\\<rparr>,\n        g_E =\n          g_E \\<lparr>g_V = UNIV, g_E = E_of_succ (NGBA.successors A),\n                 g_V0 = ngba.initial A\\<rparr>,\n        g_V0 =\n          g_V0\n           \\<lparr>g_V = UNIV, g_E = E_of_succ (NGBA.successors A),\n              g_V0 = ngba.initial A\\<rparr>,\n        igbg_num_acc = length (ngba.accepting A),\n        igbg_acc =\n          \\<lambda>p.\n             {k \\<in> {0..<length (ngba.accepting A)}.\n              (ngba.accepting A ! k) p}\\<rparr>", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have \"(RETURN (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai),\n        do { r \\<leftarrow> find_lasso_spec; RETURN (r = None) }) \\<in> \\<langle>bool_rel\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai),\n     find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "using ngba_language_empty.refine assms igb_fr_graph_axioms"], ["proof (prove)\nusing this:\n  \\<lbrakk>igb_fr_graph (ngba_igbg ?A); is_bounded_hashcode ?S ?seq ?bhs;\n   is_valid_def_hm_size TYPE(?'c) ?hms;\n   (?seq, (=)) \\<in> ?S \\<rightarrow> ?S \\<rightarrow> bool_rel;\n   (?Ai, ?A) \\<in> \\<langle>?L, ?S\\<rangle>ngbai_ngba_rel\\<rbrakk>\n  \\<Longrightarrow> (RETURN\n                      (NGBA_Algorithms.ngba_language_empty ?seq ?bhs ?hms\n                        ?Ai),\n                     op_find_lasso_spec (ngba_igbg ?A) \\<bind>\n                     (\\<lambda>r. RETURN (r = None)))\n                    \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n  SIDE_PRECOND (finite (NGBA.nodes A))\n  SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\n  GEN_OP seq (=) (S \\<rightarrow> S \\<rightarrow> bool_rel)\n  (Ai, A) \\<in> \\<langle>L, S\\<rangle>ngbai_ngba_rel\n  igb_fr_graph (ngba_igbg A)\n\ngoal (1 subgoal):\n 1. (RETURN (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai),\n     find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "by simp"], ["proof (state)\nthis:\n  (RETURN (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai),\n   find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "also"], ["proof (state)\nthis:\n  (RETURN (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai),\n   find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have \"(do { r \\<leftarrow> find_lasso_spec; RETURN (r = None) },\n        RETURN (\\<not> Ex is_lasso_prpl)) \\<in> \\<langle>bool_rel\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)),\n     RETURN (\\<not> Ex is_lasso_prpl))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "unfolding find_lasso_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPEC\n      (\\<lambda>r.\n          case r of\n          None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n          | Some x \\<Rightarrow> is_lasso_prpl x) \\<bind>\n     (\\<lambda>r. RETURN (r = None)),\n     RETURN (\\<not> Ex is_lasso_prpl))\n    \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "by (refine_vcg) (auto split: option.splits)"], ["proof (state)\nthis:\n  (find_lasso_spec \\<bind> (\\<lambda>r. RETURN (r = None)),\n   RETURN (\\<not> Ex is_lasso_prpl))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "finally"], ["proof (chain)\npicking this:\n  (RETURN (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai),\n   RETURN (\\<not> Ex is_lasso_prpl))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel O\n        \\<langle>bool_rel\\<rangle>nres_rel", "have \"NGBA_Algorithms.ngba_language_empty seq bhc hms Ai \\<longleftrightarrow> \\<not> Ex is_lasso_prpl\""], ["proof (prove)\nusing this:\n  (RETURN (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai),\n   RETURN (\\<not> Ex is_lasso_prpl))\n  \\<in> \\<langle>bool_rel\\<rangle>nres_rel O\n        \\<langle>bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. NGBA_Algorithms.ngba_language_empty seq bhc hms Ai =\n    (\\<not> Ex is_lasso_prpl)", "unfolding nres_rel_comp"], ["proof (prove)\nusing this:\n  (RETURN (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai),\n   RETURN (\\<not> Ex is_lasso_prpl))\n  \\<in> \\<langle>bool_rel O bool_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. NGBA_Algorithms.ngba_language_empty seq bhc hms Ai =\n    (\\<not> Ex is_lasso_prpl)", "using RETURN_nres_relD"], ["proof (prove)\nusing this:\n  (RETURN (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai),\n   RETURN (\\<not> Ex is_lasso_prpl))\n  \\<in> \\<langle>bool_rel O bool_rel\\<rangle>nres_rel\n  (RETURN ?x, RETURN ?y)\n  \\<in> \\<langle>?A\\<rangle>nres_rel \\<Longrightarrow>\n  (?x, ?y) \\<in> ?A\n\ngoal (1 subgoal):\n 1. NGBA_Algorithms.ngba_language_empty seq bhc hms Ai =\n    (\\<not> Ex is_lasso_prpl)", "by force"], ["proof (state)\nthis:\n  NGBA_Algorithms.ngba_language_empty seq bhc hms Ai =\n  (\\<not> Ex is_lasso_prpl)\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "also"], ["proof (state)\nthis:\n  NGBA_Algorithms.ngba_language_empty seq bhc hms Ai =\n  (\\<not> Ex is_lasso_prpl)\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have \"\\<dots> \\<longleftrightarrow> \\<not> Ex is_acc_run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> Ex is_lasso_prpl) = (\\<not> Ex is_acc_run)", "using lasso_prpl_acc_run_iff"], ["proof (prove)\nusing this:\n  Ex is_lasso_prpl = Ex is_acc_run\n\ngoal (1 subgoal):\n 1. (\\<not> Ex is_lasso_prpl) = (\\<not> Ex is_acc_run)", "by auto"], ["proof (state)\nthis:\n  (\\<not> Ex is_lasso_prpl) = (\\<not> Ex is_acc_run)\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "also"], ["proof (state)\nthis:\n  (\\<not> Ex is_lasso_prpl) = (\\<not> Ex is_acc_run)\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "have \"\\<dots> \\<longleftrightarrow> NGBA.language A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> Ex is_acc_run) = (NGBA.language A = {})", "using NGBA_Graphs.acc_run_language is_igb_graph"], ["proof (prove)\nusing this:\n  igb_graph (ngba_igbg ?A) \\<Longrightarrow>\n  Ex (igb_graph.is_acc_run (ngba_igbg ?A)) = (NGBA.language ?A \\<noteq> {})\n  igb_graph (ngba_igbg A)\n\ngoal (1 subgoal):\n 1. (\\<not> Ex is_acc_run) = (NGBA.language A = {})", "by auto"], ["proof (state)\nthis:\n  (\\<not> Ex is_acc_run) = (NGBA.language A = {})\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "finally"], ["proof (chain)\npicking this:\n  NGBA_Algorithms.ngba_language_empty seq bhc hms Ai =\n  (NGBA.language A = {})", "show ?thesis"], ["proof (prove)\nusing this:\n  NGBA_Algorithms.ngba_language_empty seq bhc hms Ai =\n  (NGBA.language A = {})\n\ngoal (1 subgoal):\n 1. (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n     (OP NGBA_Algorithms.op_language_empty :::\n      \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n     A)\n    \\<in> bool_rel", "by simp"], ["proof (state)\nthis:\n  (NGBA_Algorithms.ngba_language_empty seq bhc hms Ai,\n   (OP NGBA_Algorithms.op_language_empty :::\n    \\<langle>L, S\\<rangle>ngbai_ngba_rel \\<rightarrow> bool_rel) $\n   A)\n  \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degeneralize_alt_def: \"degeneralize A = nba\n      (ngba.alphabet A)\n      ((\\<lambda> p. (p, 0)) ` ngba.initial A)\n      (\\<lambda> a (p, k). (\\<lambda> q. (q, Degeneralization.count (ngba.accepting A) p k)) ` ngba.transition A a p)\n      (degen (ngba.accepting A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degeneralize A =\n    nba (ngba.alphabet A) ((\\<lambda>p. (p, 0)) ` ngba.initial A)\n     (\\<lambda>a (p, k).\n         (\\<lambda>q. (q, Degeneralization.count (ngba.accepting A) p k)) `\n         ngba.transition A a p)\n     (degen (ngba.accepting A))", "unfolding degeneralization.degeneralize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nba (ngba.alphabet A) (ngba.initial A \\<times> {0})\n     (\\<lambda>a (p, k).\n         {(q, Degeneralization.count (ngba.accepting A) (fst (p, a, q)) k) |\n          q. q \\<in> ngba.transition A a p})\n     (degen (ngba.accepting A) \\<circ> id) =\n    nba (ngba.alphabet A) ((\\<lambda>p. (p, 0)) ` ngba.initial A)\n     (\\<lambda>a (p, k).\n         (\\<lambda>q. (q, Degeneralization.count (ngba.accepting A) p k)) `\n         ngba.transition A a p)\n     (degen (ngba.accepting A))", "by auto"], ["", "schematic_goal ngba_degeneralize: \"(?f :: ?'a, degeneralize) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, degeneralize) \\<in> ?R", "unfolding degeneralize_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     \\<lambda>A.\n        nba (ngba.alphabet A) ((\\<lambda>p. (p, 0)) ` ngba.initial A)\n         (\\<lambda>a (p, k).\n             (\\<lambda>q.\n                 (q, Degeneralization.count (ngba.accepting A) p k)) `\n             ngba.transition A a p)\n         (degen (ngba.accepting A)))\n    \\<in> ?R", "using degen_param[autoref_rules] count_param[autoref_rules]"], ["proof (prove)\nusing this:\n  (degen, degen)\n  \\<in> \\<langle>?S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n        ?S \\<times>\\<^sub>r nat_rel \\<rightarrow> bool_rel\n  (Degeneralization.count, Degeneralization.count)\n  \\<in> \\<langle>?A \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n        ?A \\<rightarrow> nat_rel \\<rightarrow> nat_rel\n\ngoal (1 subgoal):\n 1. (?f,\n     \\<lambda>A.\n        nba (ngba.alphabet A) ((\\<lambda>p. (p, 0)) ` ngba.initial A)\n         (\\<lambda>a (p, k).\n             (\\<lambda>q.\n                 (q, Degeneralization.count (ngba.accepting A) p k)) `\n             ngba.transition A a p)\n         (degen (ngba.accepting A)))\n    \\<in> ?R", "by autoref"], ["", "concrete_definition ngba_degeneralize uses ngba_degeneralize"], ["", "lemmas ngba_degeneralize_refine[autoref_rules] = ngba_degeneralize.refine"], ["", "schematic_goal nba_intersect':\n      assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> L \\<rightarrow> L \\<rightarrow> bool_rel\"\n      shows \"(?f, intersect') \\<in> \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>L, T\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>L, S \\<times>\\<^sub>r T\\<rangle> ngbai_ngba_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, intersect')\n    \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n          \\<langle>L, T\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>L,\n          S \\<times>\\<^sub>r T\\<rangle>ngbai_ngba_rel", "unfolding intersection.product_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     \\<lambda>A B.\n        ngba (nba.alphabet A \\<inter> nba.alphabet B)\n         (nba.initial A \\<times> nba.initial B)\n         (\\<lambda>a (p, q).\n             nba.transition A a p \\<times> nba.transition B a q)\n         [nba.accepting A \\<circ> fst, nba.accepting B \\<circ> snd])\n    \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n          \\<langle>L, T\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>L,\n          S \\<times>\\<^sub>r T\\<rangle>ngbai_ngba_rel", "by autoref"], ["", "concrete_definition nba_intersect' uses nba_intersect'"], ["", "lemma nba_intersect'_refine[autoref_rules]:\n      assumes \"GEN_OP seq HOL.eq (L \\<rightarrow> L \\<rightarrow> bool_rel)\"\n      shows \"(nba_intersect' seq, intersect') \\<in>\n        \\<langle>L, S\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>L, T\\<rangle> nbai_nba_rel \\<rightarrow> \\<langle>L, S \\<times>\\<^sub>r T\\<rangle> ngbai_ngba_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.nba_intersect' seq, intersect')\n    \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n          \\<langle>L, T\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>L,\n          S \\<times>\\<^sub>r T\\<rangle>ngbai_ngba_rel", "using nba_intersect'.refine assms"], ["proof (prove)\nusing this:\n  (?seq, (=))\n  \\<in> ?L \\<rightarrow> ?L \\<rightarrow> bool_rel \\<Longrightarrow>\n  (local.nba_intersect' ?seq, intersect')\n  \\<in> \\<langle>?L, ?S\\<rangle>nbai_nba_rel \\<rightarrow>\n        \\<langle>?L, ?T\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>?L,\n        ?S \\<times>\\<^sub>r ?T\\<rangle>ngbai_ngba_rel\n  GEN_OP seq (=) (L \\<rightarrow> L \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. (local.nba_intersect' seq, intersect')\n    \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n          \\<langle>L, T\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>L,\n          S \\<times>\\<^sub>r T\\<rangle>ngbai_ngba_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  (?seq, (=))\n  \\<in> ?L \\<rightarrow> ?L \\<rightarrow> bool_rel \\<Longrightarrow>\n  (local.nba_intersect' ?seq, intersect')\n  \\<in> \\<langle>?L, ?S\\<rangle>nbai_nba_rel \\<rightarrow>\n        \\<langle>?L, ?T\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>?L,\n        ?S \\<times>\\<^sub>r ?T\\<rangle>ngbai_ngba_rel\n  (seq, (=)) \\<in> L \\<rightarrow> L \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (local.nba_intersect' seq, intersect')\n    \\<in> \\<langle>L, S\\<rangle>nbai_nba_rel \\<rightarrow>\n          \\<langle>L, T\\<rangle>nbai_nba_rel \\<rightarrow> \\<langle>L,\n          S \\<times>\\<^sub>r T\\<rangle>ngbai_ngba_rel", "by this"], ["", "end"], ["", "end"]]}