{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Automata/DRA/DRA_Translate.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma drae_image_param[param]: \"(drae_image, drae_image) \\<in> (S \\<rightarrow> T) \\<rightarrow> \\<langle>L, S\\<rangle> drae_rel \\<rightarrow> \\<langle>L, T\\<rangle> drae_rel\"", "lemma drae_image_id[simp]: \"drae_image id = id\"", "lemma drae_image_dra_drae: \"drae_image f (dra_drae A) = drae\n    (alphabet A) (f (initial A))\n    (\\<Union> p \\<in> nodes A. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n    (map (\\<lambda> (P, Q). (f ` {p \\<in> nodes A. P p}, f ` {p \\<in> nodes A. Q p})) (condition A))\"", "lemma trans_algo_refine:\n    assumes \"finite (nodes A)\" \"finite (alphabet A)\" \"inj_on f (nodes A)\"\n    assumes \"N = nodes A\" \"L = alphabet A\" \"S = transition A\"\n    shows \"(trans_algo N L S f, SPEC (HOL.eq (trans_spec A f))) \\<in> \\<langle>Id\\<rangle> nres_rel\"", "lemma to_draei_impl_refine'':\n    fixes S :: \"('statei \\<times> 'state) set\"\n    assumes \"finite (nodes A)\"\n    assumes \"is_bounded_hashcode S seq bhc\"\n    assumes \"is_valid_def_hm_size TYPE('statei) hms\"\n    assumes \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n    assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> drai_dra_rel\"\n    shows \"(RETURN (to_draei_impl seq bhc hms Ai), do {\n        f \\<leftarrow> op_set_enumerate (nodes A);\n        RETURN (drae_image (the \\<circ> f) (dra_drae A))\n      }) \\<in> \\<langle>\\<langle>L, nat_rel\\<rangle> draei_drae_rel\\<rangle> nres_rel\"", "lemma 1: \"\\<exists> f'. (to_draei_impl seq bhc hms Ai, drae_image (the \\<circ> f') (dra_drae A)) \\<in>\n      \\<langle>Id, nat_rel\\<rangle> draei_drae_rel \\<and> dom f' = nodes A \\<and> inj_on f' (nodes A)\"", "lemma f'_refine: \"(to_draei_impl seq bhc hms Ai, drae_image (the \\<circ> f') (dra_drae A)) \\<in>\n      \\<langle>Id, nat_rel\\<rangle> draei_drae_rel\"", "lemma f'_dom: \"dom f' = nodes A\"", "lemma f'_inj: \"inj_on f' (nodes A)\"", "lemma inj_f[intro!, simp]: \"inj_on f (nodes A)\"", "lemma inj_g[intro!, simp]: \"inj_on g (f ` nodes A)\"", "lemma rel_alt_def: \"rel = (br f (\\<lambda> p. p \\<in> nodes A))\\<inverse>\"", "lemma rel_inv_def: \"rel = br g (\\<lambda> k. k \\<in> f ` nodes A)\"", "lemma rel_domain[simp]: \"Domain rel = f ` nodes A\"", "lemma rel_range[simp]: \"Range rel = nodes A\"", "lemma [intro!, simp]: \"bijective rel\"", "lemma [simp]: \"Id_on (f ` nodes A) O rel = rel\"", "lemma [simp]: \"rel O Id_on (nodes A) = rel\"", "lemma [param]: \"(f, f) \\<in> Id_on (Range rel) \\<rightarrow> Id_on (Domain rel)\"", "lemma [param]: \"(g, g) \\<in> Id_on (Domain rel) \\<rightarrow> Id_on (Range rel)\"", "lemma [param]: \"(id, f) \\<in> rel \\<rightarrow> Id_on (Domain rel)\"", "lemma [param]: \"(f, id) \\<in> Id_on (Range rel) \\<rightarrow> rel\"", "lemma [param]: \"(id, g) \\<in> Id_on (Domain rel) \\<rightarrow> rel\"", "lemma [param]: \"(g, id) \\<in> rel \\<rightarrow> Id_on (Range rel)\"", "lemma to_draei_impl_refine':\n      \"(to_draei_impl seq bhc hms Ai, to_draei A) \\<in> \\<langle>Id_on (alphabet A), rel\\<rangle> draei_dra_rel\"", "lemma to_draei_impl_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>Id, S\\<rangle> drai_dra_rel\"\n      shows \"(to_draei_impl seq bhc hms Ai,\n        (OP to_draei ::: \\<langle>Id, S\\<rangle> drai_dra_rel \\<rightarrow>\n        \\<langle>Id_on (alphabet A), rel Ai A seq bhc hms\\<rangle> draei_dra_rel) $ A) \\<in>\n        \\<langle>Id_on (alphabet A), rel Ai A seq bhc hms\\<rangle> draei_dra_rel\""], "translations": [["", "lemma drae_image_param[param]: \"(drae_image, drae_image) \\<in> (S \\<rightarrow> T) \\<rightarrow> \\<langle>L, S\\<rangle> drae_rel \\<rightarrow> \\<langle>L, T\\<rangle> drae_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (drae_image, drae_image)\n    \\<in> (S \\<rightarrow> T) \\<rightarrow>\n          \\<langle>L, S\\<rangle>drae_rel \\<rightarrow> \\<langle>L,\n          T\\<rangle>drae_rel", "unfolding drae_image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f A.\n        drae (alphabete A) (f (initiale A))\n         ((\\<lambda>(p, a, q). (f p, a, f q)) ` transitione A)\n         (map (map_prod ((`) f) ((`) f)) (conditione A)),\n     \\<lambda>f A.\n        drae (alphabete A) (f (initiale A))\n         ((\\<lambda>(p, a, q). (f p, a, f q)) ` transitione A)\n         (map (map_prod ((`) f) ((`) f)) (conditione A)))\n    \\<in> (S \\<rightarrow> T) \\<rightarrow>\n          \\<langle>L, S\\<rangle>drae_rel \\<rightarrow> \\<langle>L,\n          T\\<rangle>drae_rel", "by parametricity"], ["", "lemma drae_image_id[simp]: \"drae_image id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drae_image id = id", "unfolding drae_image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A.\n        drae (alphabete A) (id (initiale A))\n         ((\\<lambda>(p, a, q). (id p, a, id q)) ` transitione A)\n         (map (map_prod ((`) id) ((`) id)) (conditione A))) =\n    id", "by auto"], ["", "lemma drae_image_dra_drae: \"drae_image f (dra_drae A) = drae\n    (alphabet A) (f (initial A))\n    (\\<Union> p \\<in> nodes A. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n    (map (\\<lambda> (P, Q). (f ` {p \\<in> nodes A. P p}, f ` {p \\<in> nodes A. Q p})) (condition A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drae_image f (dra_drae A) =\n    drae (alphabet A) (f (initial A))\n     (\\<Union>p\\<in>nodes A.\n         \\<Union>a\\<in>alphabet A.\n            f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n     (map (\\<lambda>(P, Q).\n              (f ` {p \\<in> nodes A. P p}, f ` {p \\<in> nodes A. Q p}))\n       (condition A))", "unfolding dra_drae_def drae_image_def drae.simps Set.filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. alphabete\n     (drae (alphabet A) (initial A)\n       (transitions (alphabet A) (nodes A) (transition A))\n       (map (\\<lambda>(P, Q).\n                ({a \\<in> nodes A. P a}, {a \\<in> nodes A. Q a}))\n         (condition A))) =\n    alphabet A \\<and>\n    f (initiale\n        (drae (alphabet A) (initial A)\n          (transitions (alphabet A) (nodes A) (transition A))\n          (map (\\<lambda>(P, Q).\n                   ({a \\<in> nodes A. P a}, {a \\<in> nodes A. Q a}))\n            (condition A)))) =\n    f (initial A) \\<and>\n    (\\<lambda>(p, a, q). (f p, a, f q)) `\n    transitione\n     (drae (alphabet A) (initial A)\n       (transitions (alphabet A) (nodes A) (transition A))\n       (map (\\<lambda>(P, Q).\n                ({a \\<in> nodes A. P a}, {a \\<in> nodes A. Q a}))\n         (condition A))) =\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) \\<and>\n    map (map_prod ((`) f) ((`) f))\n     (conditione\n       (drae (alphabet A) (initial A)\n         (transitions (alphabet A) (nodes A) (transition A))\n         (map (\\<lambda>(P, Q).\n                  ({a \\<in> nodes A. P a}, {a \\<in> nodes A. Q a}))\n           (condition A)))) =\n    map (\\<lambda>(P, Q).\n            (f ` {p \\<in> nodes A. P p}, f ` {p \\<in> nodes A. Q p}))\n     (condition A)", "by force"], ["", "section \\<open>Exploration and Translation\\<close>"], ["", "definition trans_spec where\n    \"trans_spec A f \\<equiv> \\<Union> p \\<in> nodes A. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p}\""], ["", "definition trans_algo where\n    \"trans_algo N L S f \\<equiv>\n      FOREACH N (\\<lambda> p T. do {\n        ASSERT (p \\<in> N);\n        FOREACH L (\\<lambda> a T. do {\n          ASSERT (a \\<in> L);\n          let q = S a p;\n          ASSERT ((f p, a, f q) \\<notin> T);\n          RETURN (insert (f p, a, f q) T) }\n        ) T }\n      ) {}\""], ["", "lemma trans_algo_refine:\n    assumes \"finite (nodes A)\" \"finite (alphabet A)\" \"inj_on f (nodes A)\"\n    assumes \"N = nodes A\" \"L = alphabet A\" \"S = transition A\"\n    shows \"(trans_algo N L S f, SPEC (HOL.eq (trans_spec A f))) \\<in> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trans_algo N L S f, SPEC ((=) (trans_spec A f)))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding trans_algo_def trans_spec_def assms(4-6)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (FOREACH (nodes A)\n      (\\<lambda>p T.\n          ASSERT (p \\<in> nodes A) \\<bind>\n          (\\<lambda>_.\n              FOREACH (alphabet A)\n               (\\<lambda>a T.\n                   ASSERT (a \\<in> alphabet A) \\<bind>\n                   (\\<lambda>_.\n                       let q = transition A a p\n                       in ASSERT ((f p, a, f q) \\<notin> T) \\<bind>\n                          (\\<lambda>_. RETURN (insert (f p, a, f q) T))))\n               T))\n      {},\n     SPEC\n      ((=) (\\<Union>p\\<in>nodes A.\n               \\<Union>a\\<in>alphabet A.\n                  f ` {p} \\<times> {a} \\<times> f ` {transition A a p})))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "proof (refine_vcg FOREACH_rule_insert_eq)"], ["proof (state)\ngoal (8 subgoals):\n 1. finite (nodes A)\n 2. ?X2 {} = {}\n 3. ?X2 (nodes A) =\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n 4. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 5. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} = ?X2 T\n 6. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) = ?X2 (insert x T)\n 7. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f (transition A xa x))\n                         \\<notin> ?X5 T x Ta\n 8. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        (f x, xa, f (transition A xa x)) \\<notin> ?X5 T x Ta\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (insert xa Ta) =\n                         insert (f x, xa, f (transition A xa x))\n                          (?X5 T x Ta)", "show \"finite (nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (nodes A)", "using assms(1)"], ["proof (prove)\nusing this:\n  finite (nodes A)\n\ngoal (1 subgoal):\n 1. finite (nodes A)", "by this"], ["proof (state)\nthis:\n  finite (nodes A)\n\ngoal (7 subgoals):\n 1. ?X2 {} = {}\n 2. ?X2 (nodes A) =\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n 3. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 4. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} = ?X2 T\n 5. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) = ?X2 (insert x T)\n 6. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f (transition A xa x))\n                         \\<notin> ?X5 T x Ta\n 7. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        (f x, xa, f (transition A xa x)) \\<notin> ?X5 T x Ta\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (insert xa Ta) =\n                         insert (f x, xa, f (transition A xa x))\n                          (?X5 T x Ta)", "show \"(\\<Union> p \\<in> nodes A. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n      (\\<Union> p \\<in> nodes A. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n    (\\<Union>p\\<in>nodes A.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p})", "by rule"], ["proof (state)\nthis:\n  (\\<Union>p\\<in>nodes A.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n  (\\<Union>p\\<in>nodes A.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n\ngoal (6 subgoals):\n 1. (\\<Union>p\\<in>{}.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n    {}\n 2. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 3. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} =\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p})\n 4. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) =\n                         (\\<Union>p\\<in>insert x T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p})\n 5. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f (transition A xa x))\n                         \\<notin> ?X5 T x Ta\n 6. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        (f x, xa, f (transition A xa x)) \\<notin> ?X5 T x Ta\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (insert xa Ta) =\n                         insert (f x, xa, f (transition A xa x))\n                          (?X5 T x Ta)", "show \"(\\<Union> p \\<in> {}. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>{}.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n    {}", "by simp"], ["proof (state)\nthis:\n  (\\<Union>p\\<in>{}.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n  {}\n\ngoal (5 subgoals):\n 1. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 2. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} =\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p})\n 3. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) =\n                         (\\<Union>p\\<in>insert x T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p})\n 4. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f (transition A xa x))\n                         \\<notin> ?X5 T x Ta\n 5. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        (f x, xa, f (transition A xa x)) \\<notin> ?X5 T x Ta\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (insert xa Ta) =\n                         insert (f x, xa, f (transition A xa x))\n                          (?X5 T x Ta)", "fix T x"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 2. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} =\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p})\n 3. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) =\n                         (\\<Union>p\\<in>insert x T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p})\n 4. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f (transition A xa x))\n                         \\<notin> ?X5 T x Ta\n 5. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        (f x, xa, f (transition A xa x)) \\<notin> ?X5 T x Ta\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (insert xa Ta) =\n                         insert (f x, xa, f (transition A xa x))\n                          (?X5 T x Ta)", "assume 1: \"T \\<subseteq> nodes A\" \"x \\<in> nodes A\" \"x \\<notin> T\""], ["proof (state)\nthis:\n  T \\<subseteq> nodes A\n  x \\<in> nodes A\n  x \\<notin> T\n\ngoal (5 subgoals):\n 1. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> finite (alphabet A)\n 2. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} =\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p})\n 3. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) =\n                         (\\<Union>p\\<in>insert x T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p})\n 4. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f (transition A xa x))\n                         \\<notin> ?X5 T x Ta\n 5. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        (f x, xa, f (transition A xa x)) \\<notin> ?X5 T x Ta\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (insert xa Ta) =\n                         insert (f x, xa, f (transition A xa x))\n                          (?X5 T x Ta)", "show \"finite (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (alphabet A)", "using assms(2)"], ["proof (prove)\nusing this:\n  finite (alphabet A)\n\ngoal (1 subgoal):\n 1. finite (alphabet A)", "by this"], ["proof (state)\nthis:\n  finite (alphabet A)\n\ngoal (4 subgoals):\n 1. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x {} =\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p})\n 2. \\<And>T x.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (alphabet A) =\n                         (\\<Union>p\\<in>insert x T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p})\n 3. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f (transition A xa x))\n                         \\<notin> ?X5 T x Ta\n 4. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        (f x, xa, f (transition A xa x)) \\<notin> ?X5 T x Ta\\<rbrakk>\n       \\<Longrightarrow> ?X5 T x (insert xa Ta) =\n                         insert (f x, xa, f (transition A xa x))\n                          (?X5 T x Ta)", "show \"(\\<Union> a \\<in> {}. f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\"\n      \"(\\<Union> a \\<in> alphabet A. f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n      (\\<Union> p \\<in> insert x T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>{}.\n        f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) &&&\n    (\\<Union>a\\<in>alphabet A.\n        f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n    (\\<Union>p\\<in>insert x T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p})", "by auto"], ["proof (state)\nthis:\n  (\\<Union>a\\<in>{}.\n      f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n  (\\<Union>a\\<in>alphabet A.\n      f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n  (\\<Union>p\\<in>insert x T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n\ngoal (2 subgoals):\n 1. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f (transition A xa x))\n                         \\<notin> (\\<Union>a\\<in>Ta.\nf ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n                                  (\\<Union>p\\<in>T.\n\\<Union>a\\<in>alphabet A.\n   f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n 2. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        (f x, xa, f (transition A xa x))\n        \\<notin> (\\<Union>a\\<in>Ta.\n                     f ` {x} \\<times>\n                     {a} \\<times> f ` {transition A a x}) \\<union>\n                 (\\<Union>p\\<in>T.\n                     \\<Union>a\\<in>alphabet A.\n                        f ` {p} \\<times>\n                        {a} \\<times> f ` {transition A a p})\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>insert xa Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` {transition A a x}) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p}) =\n                         insert (f x, xa, f (transition A xa x))\n                          ((\\<Union>a\\<in>Ta.\n                               f ` {x} \\<times>\n                               {a} \\<times> f ` {transition A a x}) \\<union>\n                           (\\<Union>p\\<in>T.\n                               \\<Union>a\\<in>alphabet A.\n                                  f ` {p} \\<times>\n                                  {a} \\<times> f ` {transition A a p}))", "fix Ta xa"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f (transition A xa x))\n                         \\<notin> (\\<Union>a\\<in>Ta.\nf ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n                                  (\\<Union>p\\<in>T.\n\\<Union>a\\<in>alphabet A.\n   f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n 2. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        (f x, xa, f (transition A xa x))\n        \\<notin> (\\<Union>a\\<in>Ta.\n                     f ` {x} \\<times>\n                     {a} \\<times> f ` {transition A a x}) \\<union>\n                 (\\<Union>p\\<in>T.\n                     \\<Union>a\\<in>alphabet A.\n                        f ` {p} \\<times>\n                        {a} \\<times> f ` {transition A a p})\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>insert xa Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` {transition A a x}) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p}) =\n                         insert (f x, xa, f (transition A xa x))\n                          ((\\<Union>a\\<in>Ta.\n                               f ` {x} \\<times>\n                               {a} \\<times> f ` {transition A a x}) \\<union>\n                           (\\<Union>p\\<in>T.\n                               \\<Union>a\\<in>alphabet A.\n                                  f ` {p} \\<times>\n                                  {a} \\<times> f ` {transition A a p}))", "assume 2: \"Ta \\<subseteq> alphabet A\" \"xa \\<in> alphabet A\" \"xa \\<notin> Ta\""], ["proof (state)\nthis:\n  Ta \\<subseteq> alphabet A\n  xa \\<in> alphabet A\n  xa \\<notin> Ta\n\ngoal (2 subgoals):\n 1. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A\\<rbrakk>\n       \\<Longrightarrow> (f x, xa, f (transition A xa x))\n                         \\<notin> (\\<Union>a\\<in>Ta.\nf ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n                                  (\\<Union>p\\<in>T.\n\\<Union>a\\<in>alphabet A.\n   f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n 2. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        (f x, xa, f (transition A xa x))\n        \\<notin> (\\<Union>a\\<in>Ta.\n                     f ` {x} \\<times>\n                     {a} \\<times> f ` {transition A a x}) \\<union>\n                 (\\<Union>p\\<in>T.\n                     \\<Union>a\\<in>alphabet A.\n                        f ` {p} \\<times>\n                        {a} \\<times> f ` {transition A a p})\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>insert xa Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` {transition A a x}) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p}) =\n                         insert (f x, xa, f (transition A xa x))\n                          ((\\<Union>a\\<in>Ta.\n                               f ` {x} \\<times>\n                               {a} \\<times> f ` {transition A a x}) \\<union>\n                           (\\<Union>p\\<in>T.\n                               \\<Union>a\\<in>alphabet A.\n                                  f ` {p} \\<times>\n                                  {a} \\<times> f ` {transition A a p}))", "show \"(f x, xa, f (transition A xa x)) \\<notin> (\\<Union> a \\<in> Ta. f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x, xa, f (transition A xa x))\n    \\<notin> (\\<Union>a\\<in>Ta.\n                 f ` {x} \\<times>\n                 {a} \\<times> f ` {transition A a x}) \\<union>\n             (\\<Union>p\\<in>T.\n                 \\<Union>a\\<in>alphabet A.\n                    f ` {p} \\<times> {a} \\<times> f ` {transition A a p})", "using 1 2(3) assms(3)"], ["proof (prove)\nusing this:\n  T \\<subseteq> nodes A\n  x \\<in> nodes A\n  x \\<notin> T\n  xa \\<notin> Ta\n  inj_on f (nodes A)\n\ngoal (1 subgoal):\n 1. (f x, xa, f (transition A xa x))\n    \\<notin> (\\<Union>a\\<in>Ta.\n                 f ` {x} \\<times>\n                 {a} \\<times> f ` {transition A a x}) \\<union>\n             (\\<Union>p\\<in>T.\n                 \\<Union>a\\<in>alphabet A.\n                    f ` {p} \\<times> {a} \\<times> f ` {transition A a p})", "by (auto dest: inj_onD)"], ["proof (state)\nthis:\n  (f x, xa, f (transition A xa x))\n  \\<notin> (\\<Union>a\\<in>Ta.\n               f ` {x} \\<times>\n               {a} \\<times> f ` {transition A a x}) \\<union>\n           (\\<Union>p\\<in>T.\n               \\<Union>a\\<in>alphabet A.\n                  f ` {p} \\<times> {a} \\<times> f ` {transition A a p})\n\ngoal (1 subgoal):\n 1. \\<And>T x Ta xa.\n       \\<lbrakk>T \\<subseteq> nodes A; x \\<in> nodes A; x \\<notin> T;\n        x \\<in> nodes A; Ta \\<subseteq> alphabet A; xa \\<in> alphabet A;\n        xa \\<notin> Ta; xa \\<in> alphabet A;\n        (f x, xa, f (transition A xa x))\n        \\<notin> (\\<Union>a\\<in>Ta.\n                     f ` {x} \\<times>\n                     {a} \\<times> f ` {transition A a x}) \\<union>\n                 (\\<Union>p\\<in>T.\n                     \\<Union>a\\<in>alphabet A.\n                        f ` {p} \\<times>\n                        {a} \\<times> f ` {transition A a p})\\<rbrakk>\n       \\<Longrightarrow> (\\<Union>a\\<in>insert xa Ta.\n                             f ` {x} \\<times>\n                             {a} \\<times> f ` {transition A a x}) \\<union>\n                         (\\<Union>p\\<in>T.\n                             \\<Union>a\\<in>alphabet A.\n                                f ` {p} \\<times>\n                                {a} \\<times> f ` {transition A a p}) =\n                         insert (f x, xa, f (transition A xa x))\n                          ((\\<Union>a\\<in>Ta.\n                               f ` {x} \\<times>\n                               {a} \\<times> f ` {transition A a x}) \\<union>\n                           (\\<Union>p\\<in>T.\n                               \\<Union>a\\<in>alphabet A.\n                                  f ` {p} \\<times>\n                                  {a} \\<times> f ` {transition A a p}))", "show \"(\\<Union> a \\<in> insert xa Ta. f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n      insert (f x, xa, f (transition A xa x)) ((\\<Union> a \\<in> Ta. f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n      (\\<Union> p \\<in> T. \\<Union> a \\<in> alphabet A. f ` {p} \\<times> {a} \\<times> f ` {transition A a p}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>insert xa Ta.\n        f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n    insert (f x, xa, f (transition A xa x))\n     ((\\<Union>a\\<in>Ta.\n          f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n      (\\<Union>p\\<in>T.\n          \\<Union>a\\<in>alphabet A.\n             f ` {p} \\<times> {a} \\<times> f ` {transition A a p}))", "by simp"], ["proof (state)\nthis:\n  (\\<Union>a\\<in>insert xa Ta.\n      f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n  (\\<Union>p\\<in>T.\n      \\<Union>a\\<in>alphabet A.\n         f ` {p} \\<times> {a} \\<times> f ` {transition A a p}) =\n  insert (f x, xa, f (transition A xa x))\n   ((\\<Union>a\\<in>Ta.\n        f ` {x} \\<times> {a} \\<times> f ` {transition A a x}) \\<union>\n    (\\<Union>p\\<in>T.\n        \\<Union>a\\<in>alphabet A.\n           f ` {p} \\<times> {a} \\<times> f ` {transition A a p}))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition to_draei :: \"('state, 'label) dra \\<Rightarrow> ('state, 'label) dra\"\n    where \"to_draei \\<equiv> id\""], ["", "(* TODO: make separate implementations for \"dra_drae\" and \"op_set_enumerate \\<bind> drae_image\" *)"], ["", "schematic_goal to_draei_impl:\n    fixes S :: \"('statei \\<times> 'state) set\"\n    assumes [simp]: \"finite (nodes A)\"\n    assumes [autoref_ga_rules]: \"is_bounded_hashcode S seq bhc\"\n    assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('statei) hms\"\n    assumes [autoref_rules]: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n    assumes [autoref_rules]: \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> drai_dra_rel\"\n    shows \"(?f :: ?'a, do {\n        let N = nodes A;\n        f \\<leftarrow> op_set_enumerate N;\n        ASSERT (dom f = N);\n        ASSERT (f (initial A) \\<noteq> None);\n        ASSERT (\\<forall> a \\<in> alphabet A. \\<forall> p \\<in> dom f. f (transition A a p) \\<noteq> None);\n        T \\<leftarrow> trans_algo N (alphabet A) (transition A) (\\<lambda> x. the (f x));\n        RETURN (drae (alphabet A) ((\\<lambda> x. the (f x)) (initial A)) T\n          (map (\\<lambda> (P, Q). ((\\<lambda> x. the (f x)) ` {p \\<in> N. P p}, (\\<lambda> x. the (f x)) ` {p \\<in> N. Q p})) (condition A)))\n      }) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     let N = nodes A\n     in op_set_enumerate N \\<bind>\n        (\\<lambda>f.\n            ASSERT (dom f = N) \\<bind>\n            (\\<lambda>_.\n                ASSERT (f (initial A) \\<noteq> None) \\<bind>\n                (\\<lambda>_.\n                    ASSERT\n                     (\\<forall>a\\<in>alphabet A.\n                         \\<forall>p\\<in>dom f.\n                            f (transition A a p) \\<noteq> None) \\<bind>\n                    (\\<lambda>_.\n                        trans_algo N (alphabet A) (transition A)\n                         (\\<lambda>x. the (f x)) \\<bind>\n                        (\\<lambda>T.\n                            RETURN\n                             (drae (alphabet A) (the (f (initial A))) T\n                               (map (\\<lambda>(P, Q).\n  ((\\<lambda>x. the (f x)) ` {p \\<in> N. P p},\n   (\\<lambda>x. the (f x)) ` {p \\<in> N. Q p}))\n                                 (condition A)))))))))\n    \\<in> ?R", "unfolding trans_algo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     let N = nodes A\n     in op_set_enumerate N \\<bind>\n        (\\<lambda>f.\n            ASSERT (dom f = N) \\<bind>\n            (\\<lambda>_.\n                ASSERT (f (initial A) \\<noteq> None) \\<bind>\n                (\\<lambda>_.\n                    ASSERT\n                     (\\<forall>a\\<in>alphabet A.\n                         \\<forall>p\\<in>dom f.\n                            f (transition A a p) \\<noteq> None) \\<bind>\n                    (\\<lambda>_.\n                        FOREACH N\n                         (\\<lambda>p T.\n                             ASSERT (p \\<in> N) \\<bind>\n                             (\\<lambda>_.\n                                 FOREACH (alphabet A)\n                                  (\\<lambda>a T.\nASSERT (a \\<in> alphabet A) \\<bind>\n(\\<lambda>_.\n    let q = transition A a p\n    in ASSERT ((the (f p), a, the (f q)) \\<notin> T) \\<bind>\n       (\\<lambda>_. RETURN (insert (the (f p), a, the (f q)) T))))\n                                  T))\n                         {} \\<bind>\n                        (\\<lambda>T.\n                            RETURN\n                             (drae (alphabet A) (the (f (initial A))) T\n                               (map (\\<lambda>(P, Q).\n  ((\\<lambda>x. the (f x)) ` {p \\<in> N. P p},\n   (\\<lambda>x. the (f x)) ` {p \\<in> N. Q p}))\n                                 (condition A)))))))))\n    \\<in> ?R", "by (autoref_monadic (plain))"], ["", "concrete_definition to_draei_impl uses to_draei_impl"], ["", "lemma to_draei_impl_refine'':\n    fixes S :: \"('statei \\<times> 'state) set\"\n    assumes \"finite (nodes A)\"\n    assumes \"is_bounded_hashcode S seq bhc\"\n    assumes \"is_valid_def_hm_size TYPE('statei) hms\"\n    assumes \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n    assumes \"(Ai, A) \\<in> \\<langle>L, S\\<rangle> drai_dra_rel\"\n    shows \"(RETURN (to_draei_impl seq bhc hms Ai), do {\n        f \\<leftarrow> op_set_enumerate (nodes A);\n        RETURN (drae_image (the \\<circ> f) (dra_drae A))\n      }) \\<in> \\<langle>\\<langle>L, nat_rel\\<rangle> draei_drae_rel\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (to_draei_impl seq bhc hms Ai),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (RETURN (to_draei_impl seq bhc hms Ai),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel", "have 1: \"finite (alphabet A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (alphabet A)", "using drai_dra_param(2)[param_fo, OF assms(5)] list_set_rel_finite"], ["proof (prove)\nusing this:\n  (alphabeti Ai, alphabet A) \\<in> \\<langle>L\\<rangle>list_set_rel\n  finite_set_rel (\\<langle>?R\\<rangle>list_set_rel)\n\ngoal (1 subgoal):\n 1. finite (alphabet A)", "unfolding finite_set_rel_def"], ["proof (prove)\nusing this:\n  (alphabeti Ai, alphabet A) \\<in> \\<langle>L\\<rangle>list_set_rel\n  Range (\\<langle>?R\\<rangle>list_set_rel) \\<subseteq> Collect finite\n\ngoal (1 subgoal):\n 1. finite (alphabet A)", "by auto"], ["proof (state)\nthis:\n  finite (alphabet A)\n\ngoal (1 subgoal):\n 1. (RETURN (to_draei_impl seq bhc hms Ai),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel", "note to_draei_impl.refine[OF assms]"], ["proof (state)\nthis:\n  (RETURN (to_draei_impl seq bhc hms Ai),\n   let N = nodes A\n   in op_set_enumerate N \\<bind>\n      (\\<lambda>f.\n          ASSERT (dom f = N) \\<bind>\n          (\\<lambda>_.\n              ASSERT (f (initial A) \\<noteq> None) \\<bind>\n              (\\<lambda>_.\n                  ASSERT\n                   (\\<forall>a\\<in>alphabet A.\n                       \\<forall>p\\<in>dom f.\n                          f (transition A a p) \\<noteq> None) \\<bind>\n                  (\\<lambda>_.\n                      trans_algo N (alphabet A) (transition A)\n                       (\\<lambda>x. the (f x)) \\<bind>\n                      (\\<lambda>T.\n                          RETURN\n                           (drae (alphabet A) (the (f (initial A))) T\n                             (map (\\<lambda>(P, Q).\n((\\<lambda>x. the (f x)) ` {p \\<in> N. P p},\n (\\<lambda>x. the (f x)) ` {p \\<in> N. Q p}))\n                               (condition A)))))))))\n  \\<in> \\<langle>\\<langle>L, nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_draei_impl seq bhc hms Ai),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  (RETURN (to_draei_impl seq bhc hms Ai),\n   let N = nodes A\n   in op_set_enumerate N \\<bind>\n      (\\<lambda>f.\n          ASSERT (dom f = N) \\<bind>\n          (\\<lambda>_.\n              ASSERT (f (initial A) \\<noteq> None) \\<bind>\n              (\\<lambda>_.\n                  ASSERT\n                   (\\<forall>a\\<in>alphabet A.\n                       \\<forall>p\\<in>dom f.\n                          f (transition A a p) \\<noteq> None) \\<bind>\n                  (\\<lambda>_.\n                      trans_algo N (alphabet A) (transition A)\n                       (\\<lambda>x. the (f x)) \\<bind>\n                      (\\<lambda>T.\n                          RETURN\n                           (drae (alphabet A) (the (f (initial A))) T\n                             (map (\\<lambda>(P, Q).\n((\\<lambda>x. the (f x)) ` {p \\<in> N. P p},\n (\\<lambda>x. the (f x)) ` {p \\<in> N. Q p}))\n                               (condition A)))))))))\n  \\<in> \\<langle>\\<langle>L, nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_draei_impl seq bhc hms Ai),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel", "have \"(do {\n        let N = nodes A;\n        f \\<leftarrow> op_set_enumerate N;\n        ASSERT (dom f = N);\n        ASSERT (f (initial A) \\<noteq> None);\n        ASSERT (\\<forall> a \\<in> alphabet A. \\<forall> p \\<in> dom f. f (transition A a p) \\<noteq> None);\n        T \\<leftarrow> trans_algo N (alphabet A) (transition A) (\\<lambda> x. the (f x));\n        RETURN (drae (alphabet A) ((\\<lambda> x. the (f x)) (initial A)) T\n          (map (\\<lambda> (P, Q). ((\\<lambda> x. the (f x)) ` {p \\<in> N. P p}, (\\<lambda> x. the (f x)) ` {p \\<in> N. Q p})) (condition A)))\n      }, do {\n        f \\<leftarrow> op_set_enumerate (nodes A);\n        T \\<leftarrow> SPEC (HOL.eq (trans_spec A (\\<lambda> x. the (f x))));\n        RETURN (drae (alphabet A) ((\\<lambda> x. the (f x)) (initial A)) T\n          (map (\\<lambda> (P, Q). ((\\<lambda> x. the (f x)) ` {p \\<in> nodes A. P p}, (\\<lambda> x. the (f x)) ` {p \\<in> nodes A. Q p})) (condition A)))\n      }) \\<in> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let N = nodes A\n     in op_set_enumerate N \\<bind>\n        (\\<lambda>f.\n            ASSERT (dom f = N) \\<bind>\n            (\\<lambda>_.\n                ASSERT (f (initial A) \\<noteq> None) \\<bind>\n                (\\<lambda>_.\n                    ASSERT\n                     (\\<forall>a\\<in>alphabet A.\n                         \\<forall>p\\<in>dom f.\n                            f (transition A a p) \\<noteq> None) \\<bind>\n                    (\\<lambda>_.\n                        trans_algo N (alphabet A) (transition A)\n                         (\\<lambda>x. the (f x)) \\<bind>\n                        (\\<lambda>T.\n                            RETURN\n                             (drae (alphabet A) (the (f (initial A))) T\n                               (map (\\<lambda>(P, Q).\n  ((\\<lambda>x. the (f x)) ` {p \\<in> N. P p},\n   (\\<lambda>x. the (f x)) ` {p \\<in> N. Q p}))\n                                 (condition A)))))))),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f.\n         SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n         (\\<lambda>T.\n             RETURN\n              (drae (alphabet A) (the (f (initial A))) T\n                (map (\\<lambda>(P, Q).\n                         ((\\<lambda>x. the (f x)) ` {p \\<in> nodes A. P p},\n                          (\\<lambda>x. the (f x)) ` {p \\<in> nodes A. Q p}))\n                  (condition A))))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding Let_def comp_apply op_set_enumerate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPEC (\\<lambda>f. dom f = nodes A \\<and> inj_on f (nodes A)) \\<bind>\n     (\\<lambda>f.\n         ASSERT (dom f = nodes A) \\<bind>\n         (\\<lambda>_.\n             ASSERT (f (initial A) \\<noteq> None) \\<bind>\n             (\\<lambda>_.\n                 ASSERT\n                  (\\<forall>a\\<in>alphabet A.\n                      \\<forall>p\\<in>dom f.\n                         f (transition A a p) \\<noteq> None) \\<bind>\n                 (\\<lambda>_.\n                     trans_algo (nodes A) (alphabet A) (transition A)\n                      (\\<lambda>x. the (f x)) \\<bind>\n                     (\\<lambda>T.\n                         RETURN\n                          (drae (alphabet A) (the (f (initial A))) T\n                            (map (\\<lambda>(P, Q).\n                                     ((\\<lambda>x. the (f x)) `\n{p \\<in> nodes A. P p},\n(\\<lambda>x. the (f x)) ` {p \\<in> nodes A. Q p}))\n                              (condition A)))))))),\n     SPEC (\\<lambda>f. dom f = nodes A \\<and> inj_on f (nodes A)) \\<bind>\n     (\\<lambda>f.\n         SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n         (\\<lambda>T.\n             RETURN\n              (drae (alphabet A) (the (f (initial A))) T\n                (map (\\<lambda>(P, Q).\n                         ((\\<lambda>x. the (f x)) ` {p \\<in> nodes A. P p},\n                          (\\<lambda>x. the (f x)) ` {p \\<in> nodes A. Q p}))\n                  (condition A))))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "using assms(1) 1"], ["proof (prove)\nusing this:\n  finite (nodes A)\n  finite (alphabet A)\n\ngoal (1 subgoal):\n 1. (SPEC (\\<lambda>f. dom f = nodes A \\<and> inj_on f (nodes A)) \\<bind>\n     (\\<lambda>f.\n         ASSERT (dom f = nodes A) \\<bind>\n         (\\<lambda>_.\n             ASSERT (f (initial A) \\<noteq> None) \\<bind>\n             (\\<lambda>_.\n                 ASSERT\n                  (\\<forall>a\\<in>alphabet A.\n                      \\<forall>p\\<in>dom f.\n                         f (transition A a p) \\<noteq> None) \\<bind>\n                 (\\<lambda>_.\n                     trans_algo (nodes A) (alphabet A) (transition A)\n                      (\\<lambda>x. the (f x)) \\<bind>\n                     (\\<lambda>T.\n                         RETURN\n                          (drae (alphabet A) (the (f (initial A))) T\n                            (map (\\<lambda>(P, Q).\n                                     ((\\<lambda>x. the (f x)) `\n{p \\<in> nodes A. P p},\n(\\<lambda>x. the (f x)) ` {p \\<in> nodes A. Q p}))\n                              (condition A)))))))),\n     SPEC (\\<lambda>f. dom f = nodes A \\<and> inj_on f (nodes A)) \\<bind>\n     (\\<lambda>f.\n         SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n         (\\<lambda>T.\n             RETURN\n              (drae (alphabet A) (the (f (initial A))) T\n                (map (\\<lambda>(P, Q).\n                         ((\\<lambda>x. the (f x)) ` {p \\<in> nodes A. P p},\n                          (\\<lambda>x. the (f x)) ` {p \\<in> nodes A. Q p}))\n                  (condition A))))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "by (refine_vcg vcg0[OF trans_algo_refine]) (auto intro!: inj_on_map_the[unfolded comp_apply])"], ["proof (state)\nthis:\n  (let N = nodes A\n   in op_set_enumerate N \\<bind>\n      (\\<lambda>f.\n          ASSERT (dom f = N) \\<bind>\n          (\\<lambda>_.\n              ASSERT (f (initial A) \\<noteq> None) \\<bind>\n              (\\<lambda>_.\n                  ASSERT\n                   (\\<forall>a\\<in>alphabet A.\n                       \\<forall>p\\<in>dom f.\n                          f (transition A a p) \\<noteq> None) \\<bind>\n                  (\\<lambda>_.\n                      trans_algo N (alphabet A) (transition A)\n                       (\\<lambda>x. the (f x)) \\<bind>\n                      (\\<lambda>T.\n                          RETURN\n                           (drae (alphabet A) (the (f (initial A))) T\n                             (map (\\<lambda>(P, Q).\n((\\<lambda>x. the (f x)) ` {p \\<in> N. P p},\n (\\<lambda>x. the (f x)) ` {p \\<in> N. Q p}))\n                               (condition A)))))))),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f.\n       SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n       (\\<lambda>T.\n           RETURN\n            (drae (alphabet A) (the (f (initial A))) T\n              (map (\\<lambda>(P, Q).\n                       ((\\<lambda>x. the (f x)) ` {p \\<in> nodes A. P p},\n                        (\\<lambda>x. the (f x)) ` {p \\<in> nodes A. Q p}))\n                (condition A))))))\n  \\<in> \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_draei_impl seq bhc hms Ai),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  (let N = nodes A\n   in op_set_enumerate N \\<bind>\n      (\\<lambda>f.\n          ASSERT (dom f = N) \\<bind>\n          (\\<lambda>_.\n              ASSERT (f (initial A) \\<noteq> None) \\<bind>\n              (\\<lambda>_.\n                  ASSERT\n                   (\\<forall>a\\<in>alphabet A.\n                       \\<forall>p\\<in>dom f.\n                          f (transition A a p) \\<noteq> None) \\<bind>\n                  (\\<lambda>_.\n                      trans_algo N (alphabet A) (transition A)\n                       (\\<lambda>x. the (f x)) \\<bind>\n                      (\\<lambda>T.\n                          RETURN\n                           (drae (alphabet A) (the (f (initial A))) T\n                             (map (\\<lambda>(P, Q).\n((\\<lambda>x. the (f x)) ` {p \\<in> N. P p},\n (\\<lambda>x. the (f x)) ` {p \\<in> N. Q p}))\n                               (condition A)))))))),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f.\n       SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n       (\\<lambda>T.\n           RETURN\n            (drae (alphabet A) (the (f (initial A))) T\n              (map (\\<lambda>(P, Q).\n                       ((\\<lambda>x. the (f x)) ` {p \\<in> nodes A. P p},\n                        (\\<lambda>x. the (f x)) ` {p \\<in> nodes A. Q p}))\n                (condition A))))))\n  \\<in> \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_draei_impl seq bhc hms Ai),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel", "have \"(do {\n        f \\<leftarrow> op_set_enumerate (nodes A);\n        T \\<leftarrow> SPEC (HOL.eq (trans_spec A (\\<lambda> x. the (f x))));\n        RETURN (drae (alphabet A) ((\\<lambda> x. the (f x)) (initial A)) T\n          (map (\\<lambda> (P, Q). ((\\<lambda> x. the (f x)) ` {p \\<in> nodes A. P p}, (\\<lambda> x. the (f x)) ` {p \\<in> nodes A. Q p})) (condition A)))\n      },  do {\n        f \\<leftarrow> op_set_enumerate (nodes A);\n        RETURN (drae_image (the \\<circ> f) (dra_drae A))\n      }) \\<in> \\<langle>Id\\<rangle> nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f.\n         SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n         (\\<lambda>T.\n             RETURN\n              (drae (alphabet A) (the (f (initial A))) T\n                (map (\\<lambda>(P, Q).\n                         ((\\<lambda>x. the (f x)) ` {p \\<in> nodes A. P p},\n                          (\\<lambda>x. the (f x)) ` {p \\<in> nodes A. Q p}))\n                  (condition A))))),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding trans_spec_def drae_image_dra_drae"], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f.\n         SPEC\n          ((=) (\\<Union>p\\<in>nodes A.\n                   \\<Union>a\\<in>alphabet A.\n                      (\\<lambda>x. the (f x)) ` {p} \\<times>\n                      {a} \\<times>\n                      (\\<lambda>x. the (f x)) ` {transition A a p})) \\<bind>\n         (\\<lambda>T.\n             RETURN\n              (drae (alphabet A) (the (f (initial A))) T\n                (map (\\<lambda>(P, Q).\n                         ((\\<lambda>x. the (f x)) ` {p \\<in> nodes A. P p},\n                          (\\<lambda>x. the (f x)) ` {p \\<in> nodes A. Q p}))\n                  (condition A))))),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f.\n         RETURN\n          (drae (alphabet A) ((the \\<circ> f) (initial A))\n            (\\<Union>p\\<in>nodes A.\n                \\<Union>a\\<in>alphabet A.\n                   (the \\<circ> f) ` {p} \\<times>\n                   {a} \\<times> (the \\<circ> f) ` {transition A a p})\n            (map (\\<lambda>(P, Q).\n                     ((the \\<circ> f) ` {p \\<in> nodes A. P p},\n                      (the \\<circ> f) ` {p \\<in> nodes A. Q p}))\n              (condition A)))))\n    \\<in> \\<langle>Id\\<rangle>nres_rel", "by refine_vcg force"], ["proof (state)\nthis:\n  (op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f.\n       SPEC ((=) (trans_spec A (\\<lambda>x. the (f x)))) \\<bind>\n       (\\<lambda>T.\n           RETURN\n            (drae (alphabet A) (the (f (initial A))) T\n              (map (\\<lambda>(P, Q).\n                       ((\\<lambda>x. the (f x)) ` {p \\<in> nodes A. P p},\n                        (\\<lambda>x. the (f x)) ` {p \\<in> nodes A. Q p}))\n                (condition A))))),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n  \\<in> \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_draei_impl seq bhc hms Ai),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel", "finally"], ["proof (chain)\npicking this:\n  (RETURN (to_draei_impl seq bhc hms Ai),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n  \\<in> (\\<langle>\\<langle>L,\n         nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel O\n         \\<langle>Id\\<rangle>nres_rel) O\n        \\<langle>Id\\<rangle>nres_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (RETURN (to_draei_impl seq bhc hms Ai),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n  \\<in> (\\<langle>\\<langle>L,\n         nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel O\n         \\<langle>Id\\<rangle>nres_rel) O\n        \\<langle>Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_draei_impl seq bhc hms Ai),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel", "unfolding nres_rel_comp"], ["proof (prove)\nusing this:\n  (RETURN (to_draei_impl seq bhc hms Ai),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n  \\<in> \\<langle>(\\<langle>L, nat_rel\\<rangle>draei_drae_rel O Id) O\n                 Id\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (to_draei_impl seq bhc hms Ai),\n     op_set_enumerate (nodes A) \\<bind>\n     (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n    \\<in> \\<langle>\\<langle>L,\n    nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel", "by simp"], ["proof (state)\nthis:\n  (RETURN (to_draei_impl seq bhc hms Ai),\n   op_set_enumerate (nodes A) \\<bind>\n   (\\<lambda>f. RETURN (drae_image (the \\<circ> f) (dra_drae A))))\n  \\<in> \\<langle>\\<langle>L, nat_rel\\<rangle>draei_drae_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: generalize L *)"], ["", "context\n    fixes Ai A\n    fixes seq bhc hms\n    fixes S :: \"('statei \\<times> 'state) set\"\n    assumes a: \"finite (nodes A)\"\n    assumes b: \"is_bounded_hashcode S seq bhc\"\n    assumes c: \"is_valid_def_hm_size TYPE('statei) hms\"\n    assumes d: \"(seq, HOL.eq) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\"\n    assumes e: \"(Ai, A) \\<in> \\<langle>Id, S\\<rangle> drai_dra_rel\"\n  begin"], ["", "definition f' where \"f' \\<equiv> SOME f'.\n      (to_draei_impl seq bhc hms Ai, drae_image (the \\<circ> f') (dra_drae A)) \\<in> \\<langle>Id, nat_rel\\<rangle> draei_drae_rel \\<and>\n      dom f' = nodes A \\<and> inj_on f' (nodes A)\""], ["", "lemma 1: \"\\<exists> f'. (to_draei_impl seq bhc hms Ai, drae_image (the \\<circ> f') (dra_drae A)) \\<in>\n      \\<langle>Id, nat_rel\\<rangle> draei_drae_rel \\<and> dom f' = nodes A \\<and> inj_on f' (nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f'.\n       (to_draei_impl seq bhc hms Ai,\n        drae_image (the \\<circ> f') (dra_drae A))\n       \\<in> \\<langle>Id, nat_rel\\<rangle>draei_drae_rel \\<and>\n       dom f' = nodes A \\<and> inj_on f' (nodes A)", "using to_draei_impl_refine''[\n        OF a b c d e,\n        unfolded op_set_enumerate_def bind_RES_RETURN_eq,\n        THEN nres_relD,\n        THEN RETURN_ref_SPECD]"], ["proof (prove)\nusing this:\n  (\\<And>a.\n      \\<lbrakk>(to_draei_impl seq bhc hms Ai, a) \\<in> \\<langle>Id,\n               nat_rel\\<rangle>draei_drae_rel;\n       \\<exists>f.\n          a = drae_image (the \\<circ> f) (dra_drae A) \\<and>\n          f \\<in> {f. dom f = nodes A \\<and> inj_on f (nodes A)}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>f'.\n       (to_draei_impl seq bhc hms Ai,\n        drae_image (the \\<circ> f') (dra_drae A))\n       \\<in> \\<langle>Id, nat_rel\\<rangle>draei_drae_rel \\<and>\n       dom f' = nodes A \\<and> inj_on f' (nodes A)", "by force"], ["", "lemma f'_refine: \"(to_draei_impl seq bhc hms Ai, drae_image (the \\<circ> f') (dra_drae A)) \\<in>\n      \\<langle>Id, nat_rel\\<rangle> draei_drae_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai,\n     drae_image\n      ((the \\<circ>\\<circ>\\<circ> DRA_Translate.f' Ai A seq) bhc hms)\n      (dra_drae A))\n    \\<in> \\<langle>Id, nat_rel\\<rangle>draei_drae_rel", "using someI_ex[OF 1, folded f'_def]"], ["proof (prove)\nusing this:\n  (to_draei_impl seq bhc hms Ai,\n   drae_image\n    ((the \\<circ>\\<circ>\\<circ> DRA_Translate.f' Ai A seq) bhc hms)\n    (dra_drae A))\n  \\<in> \\<langle>Id, nat_rel\\<rangle>draei_drae_rel \\<and>\n  dom local.f' = nodes A \\<and> inj_on local.f' (nodes A)\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai,\n     drae_image\n      ((the \\<circ>\\<circ>\\<circ> DRA_Translate.f' Ai A seq) bhc hms)\n      (dra_drae A))\n    \\<in> \\<langle>Id, nat_rel\\<rangle>draei_drae_rel", "by auto"], ["", "lemma f'_dom: \"dom f' = nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom local.f' = nodes A", "using someI_ex[OF 1, folded f'_def]"], ["proof (prove)\nusing this:\n  (to_draei_impl seq bhc hms Ai,\n   drae_image\n    ((the \\<circ>\\<circ>\\<circ> DRA_Translate.f' Ai A seq) bhc hms)\n    (dra_drae A))\n  \\<in> \\<langle>Id, nat_rel\\<rangle>draei_drae_rel \\<and>\n  dom local.f' = nodes A \\<and> inj_on local.f' (nodes A)\n\ngoal (1 subgoal):\n 1. dom local.f' = nodes A", "by auto"], ["", "lemma f'_inj: \"inj_on f' (nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on local.f' (nodes A)", "using someI_ex[OF 1, folded f'_def]"], ["proof (prove)\nusing this:\n  (to_draei_impl seq bhc hms Ai,\n   drae_image\n    ((the \\<circ>\\<circ>\\<circ> DRA_Translate.f' Ai A seq) bhc hms)\n    (dra_drae A))\n  \\<in> \\<langle>Id, nat_rel\\<rangle>draei_drae_rel \\<and>\n  dom local.f' = nodes A \\<and> inj_on local.f' (nodes A)\n\ngoal (1 subgoal):\n 1. inj_on local.f' (nodes A)", "by auto"], ["", "definition f where \"f \\<equiv> the \\<circ> f'\""], ["", "definition g where \"g = inv_into (nodes A) f\""], ["", "lemma inj_f[intro!, simp]: \"inj_on f (nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on local.f (nodes A)", "using f'_inj f'_dom"], ["proof (prove)\nusing this:\n  inj_on local.f' (nodes A)\n  dom local.f' = nodes A\n\ngoal (1 subgoal):\n 1. inj_on local.f (nodes A)", "unfolding f_def"], ["proof (prove)\nusing this:\n  inj_on local.f' (nodes A)\n  dom local.f' = nodes A\n\ngoal (1 subgoal):\n 1. inj_on ((the \\<circ>\\<circ>\\<circ> DRA_Translate.f' Ai A seq) bhc hms)\n     (nodes A)", "by (simp add: inj_on_map_the)"], ["", "lemma inj_g[intro!, simp]: \"inj_on g (f ` nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on local.g (local.f ` nodes A)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (inv_into (nodes A) local.f) (local.f ` nodes A)", "by (simp add: inj_on_inv_into)"], ["", "definition rel where \"rel \\<equiv> {(f p, p) |p. p \\<in> nodes A}\""], ["", "lemma rel_alt_def: \"rel = (br f (\\<lambda> p. p \\<in> nodes A))\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel = (br local.f (\\<lambda>p. p \\<in> nodes A))\\<inverse>", "unfolding rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(local.f p, p) |p. p \\<in> nodes A} =\n    (br local.f (\\<lambda>p. p \\<in> nodes A))\\<inverse>", "by (auto simp: in_br_conv)"], ["", "lemma rel_inv_def: \"rel = br g (\\<lambda> k. k \\<in> f ` nodes A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel = br local.g (\\<lambda>k. k \\<in> local.f ` nodes A)", "unfolding rel_alt_def g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (br local.f (\\<lambda>p. p \\<in> nodes A))\\<inverse> =\n    br (inv_into (nodes A) local.f) (\\<lambda>k. k \\<in> local.f ` nodes A)", "by (auto simp: in_br_conv)"], ["", "lemma rel_domain[simp]: \"Domain rel = f ` nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain local.rel = local.f ` nodes A", "unfolding rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain {(local.f p, p) |p. p \\<in> nodes A} = local.f ` nodes A", "by force"], ["", "lemma rel_range[simp]: \"Range rel = nodes A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range local.rel = nodes A", "unfolding rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Range {(local.f p, p) |p. p \\<in> nodes A} = nodes A", "by auto"], ["", "lemma [intro!, simp]: \"bijective rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective local.rel", "unfolding rel_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective (br local.g (\\<lambda>k. k \\<in> local.f ` nodes A))", "by (simp add: bijective_alt)"], ["", "lemma [simp]: \"Id_on (f ` nodes A) O rel = rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Id_on (local.f ` nodes A) O local.rel = local.rel", "unfolding rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Id_on (local.f ` nodes A) O {(local.f p, p) |p. p \\<in> nodes A} =\n    {(local.f p, p) |p. p \\<in> nodes A}", "by auto"], ["", "lemma [simp]: \"rel O Id_on (nodes A) = rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel O Id_on (nodes A) = local.rel", "unfolding rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(local.f p, p) |p. p \\<in> nodes A} O Id_on (nodes A) =\n    {(local.f p, p) |p. p \\<in> nodes A}", "by auto"], ["", "lemma [param]: \"(f, f) \\<in> Id_on (Range rel) \\<rightarrow> Id_on (Domain rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.f, local.f)\n    \\<in> Id_on (Range local.rel) \\<rightarrow> Id_on (Domain local.rel)", "unfolding rel_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.f, local.f)\n    \\<in> Id_on\n           (Range\n             ((br local.f\n                (\\<lambda>p. p \\<in> nodes A))\\<inverse>)) \\<rightarrow>\n          Id_on\n           (Domain ((br local.f (\\<lambda>p. p \\<in> nodes A))\\<inverse>))", "by auto"], ["", "lemma [param]: \"(g, g) \\<in> Id_on (Domain rel) \\<rightarrow> Id_on (Range rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.g, local.g)\n    \\<in> Id_on (Domain local.rel) \\<rightarrow> Id_on (Range local.rel)", "unfolding rel_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.g, local.g)\n    \\<in> Id_on\n           (Domain\n             (br local.g\n               (\\<lambda>k. k \\<in> local.f ` nodes A))) \\<rightarrow>\n          Id_on (Range (br local.g (\\<lambda>k. k \\<in> local.f ` nodes A)))", "by auto"], ["", "lemma [param]: \"(id, f) \\<in> rel \\<rightarrow> Id_on (Domain rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id, local.f) \\<in> local.rel \\<rightarrow> Id_on (Domain local.rel)", "unfolding rel_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id, local.f)\n    \\<in> (br local.f (\\<lambda>p. p \\<in> nodes A))\\<inverse> \\<rightarrow>\n          Id_on\n           (Domain ((br local.f (\\<lambda>p. p \\<in> nodes A))\\<inverse>))", "by (auto simp: in_br_conv)"], ["", "lemma [param]: \"(f, id) \\<in> Id_on (Range rel) \\<rightarrow> rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.f, id) \\<in> Id_on (Range local.rel) \\<rightarrow> local.rel", "unfolding rel_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.f, id)\n    \\<in> Id_on\n           (Range\n             ((br local.f\n                (\\<lambda>p. p \\<in> nodes A))\\<inverse>)) \\<rightarrow>\n          (br local.f (\\<lambda>p. p \\<in> nodes A))\\<inverse>", "by (auto simp: in_br_conv)"], ["", "lemma [param]: \"(id, g) \\<in> Id_on (Domain rel) \\<rightarrow> rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id, local.g) \\<in> Id_on (Domain local.rel) \\<rightarrow> local.rel", "unfolding rel_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id, local.g)\n    \\<in> Id_on\n           (Domain\n             (br local.g\n               (\\<lambda>k. k \\<in> local.f ` nodes A))) \\<rightarrow>\n          br local.g (\\<lambda>k. k \\<in> local.f ` nodes A)", "by (auto simp: in_br_conv)"], ["", "lemma [param]: \"(g, id) \\<in> rel \\<rightarrow> Id_on (Range rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.g, id) \\<in> local.rel \\<rightarrow> Id_on (Range local.rel)", "unfolding rel_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.g, id)\n    \\<in> br local.g (\\<lambda>k. k \\<in> local.f ` nodes A) \\<rightarrow>\n          Id_on (Range (br local.g (\\<lambda>k. k \\<in> local.f ` nodes A)))", "by (auto simp: in_br_conv)"], ["", "lemma to_draei_impl_refine':\n      \"(to_draei_impl seq bhc hms Ai, to_draei A) \\<in> \\<langle>Id_on (alphabet A), rel\\<rangle> draei_dra_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "have 1: \"(draei_drae (to_draei_impl seq bhc hms Ai), id (drae_image f (dra_drae A))) \\<in>\n        \\<langle>Id, nat_rel\\<rangle> drae_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (draei_drae (to_draei_impl seq bhc hms Ai),\n     id (drae_image local.f (dra_drae A)))\n    \\<in> \\<langle>Id, nat_rel\\<rangle>drae_rel", "using f'_refine[folded f_def]"], ["proof (prove)\nusing this:\n  (to_draei_impl seq bhc hms Ai, drae_image local.f (dra_drae A))\n  \\<in> \\<langle>Id, nat_rel\\<rangle>draei_drae_rel\n\ngoal (1 subgoal):\n 1. (draei_drae (to_draei_impl seq bhc hms Ai),\n     id (drae_image local.f (dra_drae A)))\n    \\<in> \\<langle>Id, nat_rel\\<rangle>drae_rel", "by parametricity"], ["proof (state)\nthis:\n  (draei_drae (to_draei_impl seq bhc hms Ai),\n   id (drae_image local.f (dra_drae A)))\n  \\<in> \\<langle>Id, nat_rel\\<rangle>drae_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "have 2: \"(draei_drae (to_draei_impl seq bhc hms Ai), id (drae_image f (dra_drae A))) \\<in>\n        \\<langle>Id_on (alphabet A), Id_on (f ` nodes A)\\<rangle> drae_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (draei_drae (to_draei_impl seq bhc hms Ai),\n     id (drae_image local.f (dra_drae A)))\n    \\<in> \\<langle>Id_on (alphabet A),\n    Id_on (local.f ` nodes A)\\<rangle>drae_rel", "using 1"], ["proof (prove)\nusing this:\n  (draei_drae (to_draei_impl seq bhc hms Ai),\n   id (drae_image local.f (dra_drae A)))\n  \\<in> \\<langle>Id, nat_rel\\<rangle>drae_rel\n\ngoal (1 subgoal):\n 1. (draei_drae (to_draei_impl seq bhc hms Ai),\n     id (drae_image local.f (dra_drae A)))\n    \\<in> \\<langle>Id_on (alphabet A),\n    Id_on (local.f ` nodes A)\\<rangle>drae_rel", "unfolding drae_rel_def dra_drae_def drae_image_def"], ["proof (prove)\nusing this:\n  (draei_drae (to_draei_impl seq bhc hms Ai),\n   id (drae\n        (alphabete\n          (drae (alphabet A) (initial A)\n            (transitions (alphabet A) (nodes A) (transition A))\n            (map (\\<lambda>(P, Q).\n                     (Set.filter P (nodes A), Set.filter Q (nodes A)))\n              (condition A))))\n        (local.f\n          (initiale\n            (drae (alphabet A) (initial A)\n              (transitions (alphabet A) (nodes A) (transition A))\n              (map (\\<lambda>(P, Q).\n                       (Set.filter P (nodes A), Set.filter Q (nodes A)))\n                (condition A)))))\n        ((\\<lambda>(p, a, q). (local.f p, a, local.f q)) `\n         transitione\n          (drae (alphabet A) (initial A)\n            (transitions (alphabet A) (nodes A) (transition A))\n            (map (\\<lambda>(P, Q).\n                     (Set.filter P (nodes A), Set.filter Q (nodes A)))\n              (condition A))))\n        (map (map_prod ((`) local.f) ((`) local.f))\n          (conditione\n            (drae (alphabet A) (initial A)\n              (transitions (alphabet A) (nodes A) (transition A))\n              (map (\\<lambda>(P, Q).\n                       (Set.filter P (nodes A), Set.filter Q (nodes A)))\n                (condition A)))))))\n  \\<in> {(A\\<^sub>1, A\\<^sub>2).\n         (alphabete A\\<^sub>1, alphabete A\\<^sub>2)\n         \\<in> \\<langle>Id\\<rangle>set_rel \\<and>\n         (initiale A\\<^sub>1, initiale A\\<^sub>2) \\<in> nat_rel \\<and>\n         (transitione A\\<^sub>1, transitione A\\<^sub>2)\n         \\<in> \\<langle>nat_rel \\<times>\\<^sub>r\n                        Id \\<times>\\<^sub>r nat_rel\\<rangle>set_rel \\<and>\n         (conditione A\\<^sub>1, conditione A\\<^sub>2)\n         \\<in> \\<langle>\\<langle>nat_rel\\<rangle>set_rel \\<times>\\<^sub>r\n                        \\<langle>nat_rel\\<rangle>set_rel\\<rangle>list_rel}\n\ngoal (1 subgoal):\n 1. (draei_drae (to_draei_impl seq bhc hms Ai),\n     id (drae\n          (alphabete\n            (drae (alphabet A) (initial A)\n              (transitions (alphabet A) (nodes A) (transition A))\n              (map (\\<lambda>(P, Q).\n                       (Set.filter P (nodes A), Set.filter Q (nodes A)))\n                (condition A))))\n          (local.f\n            (initiale\n              (drae (alphabet A) (initial A)\n                (transitions (alphabet A) (nodes A) (transition A))\n                (map (\\<lambda>(P, Q).\n                         (Set.filter P (nodes A), Set.filter Q (nodes A)))\n                  (condition A)))))\n          ((\\<lambda>(p, a, q). (local.f p, a, local.f q)) `\n           transitione\n            (drae (alphabet A) (initial A)\n              (transitions (alphabet A) (nodes A) (transition A))\n              (map (\\<lambda>(P, Q).\n                       (Set.filter P (nodes A), Set.filter Q (nodes A)))\n                (condition A))))\n          (map (map_prod ((`) local.f) ((`) local.f))\n            (conditione\n              (drae (alphabet A) (initial A)\n                (transitions (alphabet A) (nodes A) (transition A))\n                (map (\\<lambda>(P, Q).\n                         (Set.filter P (nodes A), Set.filter Q (nodes A)))\n                  (condition A)))))))\n    \\<in> {(A\\<^sub>1, A\\<^sub>2).\n           (alphabete A\\<^sub>1, alphabete A\\<^sub>2)\n           \\<in> \\<langle>Id_on (alphabet A)\\<rangle>set_rel \\<and>\n           (initiale A\\<^sub>1, initiale A\\<^sub>2)\n           \\<in> Id_on (local.f ` nodes A) \\<and>\n           (transitione A\\<^sub>1, transitione A\\<^sub>2)\n           \\<in> \\<langle>Id_on (local.f ` nodes A) \\<times>\\<^sub>r\n                          Id_on (alphabet A) \\<times>\\<^sub>r\n                          Id_on (local.f ` nodes A)\\<rangle>set_rel \\<and>\n           (conditione A\\<^sub>1, conditione A\\<^sub>2)\n           \\<in> \\<langle>\\<langle>Id_on\n                                    (local.f `\n                                     nodes\nA)\\<rangle>set_rel \\<times>\\<^sub>r\n                          \\<langle>Id_on\n                                    (local.f `\n                                     nodes\nA)\\<rangle>set_rel\\<rangle>list_rel}", "by auto"], ["proof (state)\nthis:\n  (draei_drae (to_draei_impl seq bhc hms Ai),\n   id (drae_image local.f (dra_drae A)))\n  \\<in> \\<langle>Id_on (alphabet A),\n  Id_on (local.f ` nodes A)\\<rangle>drae_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "have 3: \"wft (alphabet A) (nodes A) (transitione (dra_drae A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wft (alphabet A) (nodes A) (transitione (dra_drae A))", "using wft_transitions"], ["proof (prove)\nusing this:\n  wft ?L ?S (transitions ?L ?S ?s)\n\ngoal (1 subgoal):\n 1. wft (alphabet A) (nodes A) (transitione (dra_drae A))", "unfolding dra_drae_def drae.sel"], ["proof (prove)\nusing this:\n  wft ?L ?S (transitions ?L ?S ?s)\n\ngoal (1 subgoal):\n 1. wft (alphabet A) (nodes A)\n     (transitions (alphabet A) (nodes A) (transition A))", "by this"], ["proof (state)\nthis:\n  wft (alphabet A) (nodes A) (transitione (dra_drae A))\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "have 4: \"(wft (alphabet A) (f ` nodes A) (transitione (drae_image f (dra_drae A))),\n        wft (alphabet A) (id ` nodes A) (transitione (drae_image id (dra_drae A)))) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wft (alphabet A) (local.f ` nodes A)\n      (transitione (drae_image local.f (dra_drae A))),\n     wft (alphabet A) (id ` nodes A)\n      (transitione (drae_image id (dra_drae A))))\n    \\<in> bool_rel", "using dra_rel_eq"], ["proof (prove)\nusing this:\n  (?A, ?A) \\<in> \\<langle>Id_on (alphabet ?A),\n  Id_on (nodes ?A)\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (wft (alphabet A) (local.f ` nodes A)\n      (transitione (drae_image local.f (dra_drae A))),\n     wft (alphabet A) (id ` nodes A)\n      (transitione (drae_image id (dra_drae A))))\n    \\<in> bool_rel", "by parametricity auto"], ["proof (state)\nthis:\n  (wft (alphabet A) (local.f ` nodes A)\n    (transitione (drae_image local.f (dra_drae A))),\n   wft (alphabet A) (id ` nodes A)\n    (transitione (drae_image id (dra_drae A))))\n  \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "have 5: \"wft (alphabet A) (f ` nodes A) (transitione (drae_image f (dra_drae A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wft (alphabet A) (local.f ` nodes A)\n     (transitione (drae_image local.f (dra_drae A)))", "using 3 4"], ["proof (prove)\nusing this:\n  wft (alphabet A) (nodes A) (transitione (dra_drae A))\n  (wft (alphabet A) (local.f ` nodes A)\n    (transitione (drae_image local.f (dra_drae A))),\n   wft (alphabet A) (id ` nodes A)\n    (transitione (drae_image id (dra_drae A))))\n  \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. wft (alphabet A) (local.f ` nodes A)\n     (transitione (drae_image local.f (dra_drae A)))", "by simp"], ["proof (state)\nthis:\n  wft (alphabet A) (local.f ` nodes A)\n   (transitione (drae_image local.f (dra_drae A)))\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "have \"(drae_dra (draei_drae (to_draei_impl seq bhc hms Ai)), drae_dra (id (drae_image f (dra_drae A)))) \\<in>\n        \\<langle>Id_on (alphabet A), Id_on (f ` nodes A)\\<rangle> dra_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (drae_dra (draei_drae (to_draei_impl seq bhc hms Ai)),\n     drae_dra (id (drae_image local.f (dra_drae A))))\n    \\<in> \\<langle>Id_on (alphabet A),\n    Id_on (local.f ` nodes A)\\<rangle>dra_rel", "using 2 5"], ["proof (prove)\nusing this:\n  (draei_drae (to_draei_impl seq bhc hms Ai),\n   id (drae_image local.f (dra_drae A)))\n  \\<in> \\<langle>Id_on (alphabet A),\n  Id_on (local.f ` nodes A)\\<rangle>drae_rel\n  wft (alphabet A) (local.f ` nodes A)\n   (transitione (drae_image local.f (dra_drae A)))\n\ngoal (1 subgoal):\n 1. (drae_dra (draei_drae (to_draei_impl seq bhc hms Ai)),\n     drae_dra (id (drae_image local.f (dra_drae A))))\n    \\<in> \\<langle>Id_on (alphabet A),\n    Id_on (local.f ` nodes A)\\<rangle>dra_rel", "by parametricity auto"], ["proof (state)\nthis:\n  (drae_dra (draei_drae (to_draei_impl seq bhc hms Ai)),\n   drae_dra (id (drae_image local.f (dra_drae A))))\n  \\<in> \\<langle>Id_on (alphabet A),\n  Id_on (local.f ` nodes A)\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "also"], ["proof (state)\nthis:\n  (drae_dra (draei_drae (to_draei_impl seq bhc hms Ai)),\n   drae_dra (id (drae_image local.f (dra_drae A))))\n  \\<in> \\<langle>Id_on (alphabet A),\n  Id_on (local.f ` nodes A)\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "have \"(drae_dra (id (drae_image f (dra_drae A))), drae_dra (id (drae_image id (dra_drae A)))) \\<in>\n        \\<langle>Id_on (alphabet A), rel\\<rangle> dra_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (drae_dra (id (drae_image local.f (dra_drae A))),\n     drae_dra (id (drae_image id (dra_drae A))))\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>dra_rel", "using dra_rel_eq 3"], ["proof (prove)\nusing this:\n  (?A, ?A) \\<in> \\<langle>Id_on (alphabet ?A),\n  Id_on (nodes ?A)\\<rangle>dra_rel\n  wft (alphabet A) (nodes A) (transitione (dra_drae A))\n\ngoal (1 subgoal):\n 1. (drae_dra (id (drae_image local.f (dra_drae A))),\n     drae_dra (id (drae_image id (dra_drae A))))\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>dra_rel", "by parametricity auto"], ["proof (state)\nthis:\n  (drae_dra (id (drae_image local.f (dra_drae A))),\n   drae_dra (id (drae_image id (dra_drae A))))\n  \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "also"], ["proof (state)\nthis:\n  (drae_dra (id (drae_image local.f (dra_drae A))),\n   drae_dra (id (drae_image id (dra_drae A))))\n  \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "have \"drae_dra (id (drae_image id (dra_drae A))) = (drae_dra \\<circ> dra_drae) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drae_dra (id (drae_image id (dra_drae A))) =\n    (drae_dra \\<circ> dra_drae) A", "by simp"], ["proof (state)\nthis:\n  drae_dra (id (drae_image id (dra_drae A))) = (drae_dra \\<circ> dra_drae) A\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "also"], ["proof (state)\nthis:\n  drae_dra (id (drae_image id (dra_drae A))) = (drae_dra \\<circ> dra_drae) A\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "have \"(\\<dots>, id A) \\<in> \\<langle>Id_on (alphabet A), Id_on (nodes A)\\<rangle> dra_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((drae_dra \\<circ> dra_drae) A, id A) \\<in> \\<langle>Id_on (alphabet A),\n    Id_on (nodes A)\\<rangle>dra_rel", "by parametricity"], ["proof (state)\nthis:\n  ((drae_dra \\<circ> dra_drae) A, id A) \\<in> \\<langle>Id_on (alphabet A),\n  Id_on (nodes A)\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "also"], ["proof (state)\nthis:\n  ((drae_dra \\<circ> dra_drae) A, id A) \\<in> \\<langle>Id_on (alphabet A),\n  Id_on (nodes A)\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "have \"id A = to_draei A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id A = to_draei A", "unfolding to_draei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. id A = id A", "by simp"], ["proof (state)\nthis:\n  id A = to_draei A\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "finally"], ["proof (chain)\npicking this:\n  (drae_dra (draei_drae (to_draei_impl seq bhc hms Ai)), to_draei A)\n  \\<in> \\<langle>(Id_on (alphabet A) O Id_on (alphabet A)) O\n                 Id_on (alphabet A),\n  (Id_on (local.f ` nodes A) O local.rel) O Id_on (nodes A)\\<rangle>dra_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (drae_dra (draei_drae (to_draei_impl seq bhc hms Ai)), to_draei A)\n  \\<in> \\<langle>(Id_on (alphabet A) O Id_on (alphabet A)) O\n                 Id_on (alphabet A),\n  (Id_on (local.f ` nodes A) O local.rel) O Id_on (nodes A)\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel", "unfolding draei_dra_rel_def"], ["proof (prove)\nusing this:\n  (drae_dra (draei_drae (to_draei_impl seq bhc hms Ai)), to_draei A)\n  \\<in> \\<langle>(Id_on (alphabet A) O Id_on (alphabet A)) O\n                 Id_on (alphabet A),\n  (Id_on (local.f ` nodes A) O local.rel) O Id_on (nodes A)\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> {(Ae, Aa).\n           (drae_dra (draei_drae Ae), Aa) \\<in> \\<langle>Id_on (alphabet A),\n           local.rel\\<rangle>dra_rel}", "by simp"], ["proof (state)\nthis:\n  (to_draei_impl seq bhc hms Ai, to_draei A)\n  \\<in> \\<langle>Id_on (alphabet A), local.rel\\<rangle>draei_dra_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context\n  begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "by this"], ["", "lemma to_draei_impl_refine[autoref_rules]:\n      fixes S :: \"('statei \\<times> 'state) set\"\n      assumes \"SIDE_PRECOND (finite (nodes A))\"\n      assumes \"SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\"\n      assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\"\n      assumes \"GEN_OP seq HOL.eq (S \\<rightarrow> S \\<rightarrow> bool_rel)\"\n      assumes \"(Ai, A) \\<in> \\<langle>Id, S\\<rangle> drai_dra_rel\"\n      shows \"(to_draei_impl seq bhc hms Ai,\n        (OP to_draei ::: \\<langle>Id, S\\<rangle> drai_dra_rel \\<rightarrow>\n        \\<langle>Id_on (alphabet A), rel Ai A seq bhc hms\\<rangle> draei_dra_rel) $ A) \\<in>\n        \\<langle>Id_on (alphabet A), rel Ai A seq bhc hms\\<rangle> draei_dra_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai,\n     (OP to_draei :::\n      \\<langle>Id, S\\<rangle>drai_dra_rel \\<rightarrow>\n      \\<langle>Id_on (alphabet A),\n      rel Ai A seq bhc hms\\<rangle>draei_dra_rel) $\n     A)\n    \\<in> \\<langle>Id_on (alphabet A),\n    rel Ai A seq bhc hms\\<rangle>draei_dra_rel", "using to_draei_impl_refine' assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (nodes ?A); is_bounded_hashcode ?S ?seq ?bhc;\n   is_valid_def_hm_size TYPE(?'statei) ?hms;\n   (?seq, (=)) \\<in> ?S \\<rightarrow> ?S \\<rightarrow> bool_rel;\n   (?Ai, ?A) \\<in> \\<langle>Id, ?S\\<rangle>drai_dra_rel\\<rbrakk>\n  \\<Longrightarrow> (to_draei_impl ?seq ?bhc ?hms ?Ai, to_draei ?A)\n                    \\<in> \\<langle>Id_on (alphabet ?A),\n                    rel ?Ai ?A ?seq ?bhc ?hms\\<rangle>draei_dra_rel\n  SIDE_PRECOND (finite (nodes A))\n  SIDE_GEN_ALGO (is_bounded_hashcode S seq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('statei) hms)\n  GEN_OP seq (=) (S \\<rightarrow> S \\<rightarrow> bool_rel)\n  (Ai, A) \\<in> \\<langle>Id, S\\<rangle>drai_dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai,\n     (OP to_draei :::\n      \\<langle>Id, S\\<rangle>drai_dra_rel \\<rightarrow>\n      \\<langle>Id_on (alphabet A),\n      rel Ai A seq bhc hms\\<rangle>draei_dra_rel) $\n     A)\n    \\<in> \\<langle>Id_on (alphabet A),\n    rel Ai A seq bhc hms\\<rangle>draei_dra_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (nodes ?A); is_bounded_hashcode ?S ?seq ?bhc;\n   is_valid_def_hm_size TYPE(?'statei) ?hms;\n   (?seq, (=)) \\<in> ?S \\<rightarrow> ?S \\<rightarrow> bool_rel;\n   (?Ai, ?A) \\<in> \\<langle>Id, ?S\\<rangle>drai_dra_rel\\<rbrakk>\n  \\<Longrightarrow> (to_draei_impl ?seq ?bhc ?hms ?Ai, to_draei ?A)\n                    \\<in> \\<langle>Id_on (alphabet ?A),\n                    rel ?Ai ?A ?seq ?bhc ?hms\\<rangle>draei_dra_rel\n  finite (nodes A)\n  is_bounded_hashcode S seq bhc\n  is_valid_def_hm_size TYPE('statei) hms\n  (seq, (=)) \\<in> S \\<rightarrow> S \\<rightarrow> bool_rel\n  (Ai, A) \\<in> \\<langle>Id, S\\<rangle>drai_dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl seq bhc hms Ai, to_draei A)\n    \\<in> \\<langle>Id_on (alphabet A),\n    rel Ai A seq bhc hms\\<rangle>draei_dra_rel", "by this"], ["", "end"], ["", "end"]]}