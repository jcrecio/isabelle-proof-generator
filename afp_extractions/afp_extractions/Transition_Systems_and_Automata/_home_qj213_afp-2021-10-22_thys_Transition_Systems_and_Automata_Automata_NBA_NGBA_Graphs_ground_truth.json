{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Automata/NBA/NGBA_Graphs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma ngba_g_graph[simp]: \"graph (ngba_g A)\"", "lemma ngba_g_V0: \"g_V0 (ngba_g A) = initial A\"", "lemma ngba_g_E_rtrancl: \"(g_E (ngba_g A))\\<^sup>* = {(p, q). q \\<in> reachable A p}\"", "lemma ngba_g_rtrancl_path: \"(g_E (ngba_g A))\\<^sup>* = {(p, target r p) |r p. NGBA.path A r p}\"", "lemma ngba_g_trancl_path: \"(g_E (ngba_g A))\\<^sup>+ = {(p, target r p) |r p. NGBA.path A r p \\<and> r \\<noteq> []}\"", "lemma ngba_g_ipath_run:\n    assumes \"ipath (g_E (ngba_g A)) r\"\n    obtains w\n    where \"run A (w ||| smap (r \\<circ> Suc) nats) (r 0)\"", "lemma ngba_g_run_ipath:\n    assumes \"run A (w ||| r) p\"\n    shows \"ipath (g_E (ngba_g A)) (snth (p ## r))\"", "lemma ngba_acc_param[param]: \"(ngba_acc, ngba_acc) \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow> S \\<rightarrow> \\<langle>nat_rel\\<rangle> set_rel\"", "lemma acc_run_language:\n    assumes \"igb_graph (ngba_igbg A)\"\n    shows \"Ex (igb_graph.is_acc_run (ngba_igbg A)) \\<longleftrightarrow> language A \\<noteq> {}\""], "translations": [["", "lemma ngba_g_graph[simp]: \"graph (ngba_g A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph (ngba_g A)", "unfolding ngba_g_def graph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. g_V0\n     \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n        g_V0 = initial A\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n                       g_V0 = initial A\\<rparr> \\<and>\n    g_E \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n           g_V0 = initial A\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n                       g_V0 = initial A\\<rparr> \\<times>\n                g_V \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n                       g_V0 = initial A\\<rparr>", "by simp"], ["", "lemma ngba_g_V0: \"g_V0 (ngba_g A) = initial A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_V0 (ngba_g A) = initial A", "unfolding ngba_g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. g_V0\n     \\<lparr>g_V = UNIV, g_E = E_of_succ (successors A),\n        g_V0 = initial A\\<rparr> =\n    initial A", "by simp"], ["", "lemma ngba_g_E_rtrancl: \"(g_E (ngba_g A))\\<^sup>* = {(p, q). q \\<in> reachable A p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g_E (ngba_g A))\\<^sup>* = {(p, q). q \\<in> reachable A p}", "unfolding ngba_g_def graph_rec.simps E_of_succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v). v \\<in> successors A u}\\<^sup>* =\n    {(p, q). q \\<in> reachable A p}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> {(u, v). v \\<in> successors A u}\\<^sup>* \\<Longrightarrow>\n       b \\<in> reachable A a\n 2. \\<And>a b.\n       b \\<in> reachable A a \\<Longrightarrow>\n       (a, b) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>*", "show \"(p, q) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>*\" if \"q \\<in> reachable A p\" for p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p, q) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>*", "using that"], ["proof (prove)\nusing this:\n  q \\<in> reachable A p\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>*", "by (induct) (auto intro: rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  ?q \\<in> reachable A ?p \\<Longrightarrow>\n  (?p, ?q) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> {(u, v). v \\<in> successors A u}\\<^sup>* \\<Longrightarrow>\n       b \\<in> reachable A a", "show \"q \\<in> reachable A p\" if \"(p, q) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>*\" for p q"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> reachable A p", "using that"], ["proof (prove)\nusing this:\n  (p, q) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>*\n\ngoal (1 subgoal):\n 1. q \\<in> reachable A p", "by induct auto"], ["proof (state)\nthis:\n  (?p, ?q) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>* \\<Longrightarrow>\n  ?q \\<in> reachable A ?p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ngba_g_rtrancl_path: \"(g_E (ngba_g A))\\<^sup>* = {(p, target r p) |r p. NGBA.path A r p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g_E (ngba_g A))\\<^sup>* = {(p, target r p) |r p. NGBA.path A r p}", "unfolding ngba_g_E_rtrancl"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(p, q). q \\<in> reachable A p} =\n    {(p, target r p) |r p. NGBA.path A r p}", "by blast"], ["", "lemma ngba_g_trancl_path: \"(g_E (ngba_g A))\\<^sup>+ = {(p, target r p) |r p. NGBA.path A r p \\<and> r \\<noteq> []}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g_E (ngba_g A))\\<^sup>+ =\n    {(p, target r p) |r p. NGBA.path A r p \\<and> r \\<noteq> []}", "unfolding ngba_g_def graph_rec.simps E_of_succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v). v \\<in> successors A u}\\<^sup>+ =\n    {(p, target r p) |r p. NGBA.path A r p \\<and> r \\<noteq> []}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> {(u, v). v \\<in> successors A u}\\<^sup>+ \\<Longrightarrow>\n       \\<exists>r p.\n          (a, b) = (p, target r p) \\<and>\n          NGBA.path A r p \\<and> r \\<noteq> []\n 2. \\<And>a b r p.\n       \\<lbrakk>NGBA.path A r p; r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (p, target r p)\n                         \\<in> {(u, v). v \\<in> successors A u}\\<^sup>+", "show \"\\<exists> r p. (x, y) = (p, target r p) \\<and> NGBA.path A r p \\<and> r \\<noteq> []\"\n      if \"(x, y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r p.\n       (x, y) = (p, target r p) \\<and> NGBA.path A r p \\<and> r \\<noteq> []", "using that"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<exists>r p.\n       (x, y) = (p, target r p) \\<and> NGBA.path A r p \\<and> r \\<noteq> []", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       (x, y) \\<in> {(p, q). q \\<in> successors A p} \\<Longrightarrow>\n       \\<exists>r p.\n          (x, y) = (p, target r p) \\<and>\n          NGBA.path A r p \\<and> r \\<noteq> []\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+;\n        (y, z) \\<in> {(p, q). q \\<in> successors A p};\n        \\<exists>r p.\n           (x, y) = (p, target r p) \\<and>\n           NGBA.path A r p \\<and> r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r p.\n                            (x, z) = (p, target r p) \\<and>\n                            NGBA.path A r p \\<and> r \\<noteq> []", "case (base y)"], ["proof (state)\nthis:\n  (x, y) \\<in> {(p, q). q \\<in> successors A p}\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       (x, y) \\<in> {(p, q). q \\<in> successors A p} \\<Longrightarrow>\n       \\<exists>r p.\n          (x, y) = (p, target r p) \\<and>\n          NGBA.path A r p \\<and> r \\<noteq> []\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+;\n        (y, z) \\<in> {(p, q). q \\<in> successors A p};\n        \\<exists>r p.\n           (x, y) = (p, target r p) \\<and>\n           NGBA.path A r p \\<and> r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r p.\n                            (x, z) = (p, target r p) \\<and>\n                            NGBA.path A r p \\<and> r \\<noteq> []", "obtain a where 1: \"a \\<in> alphabet A\" \"y \\<in> transition A a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> alphabet A; y \\<in> transition A a x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using base"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {(p, q). q \\<in> successors A p}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> alphabet A; y \\<in> transition A a x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> alphabet A\n  y \\<in> transition A a x\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       (x, y) \\<in> {(p, q). q \\<in> successors A p} \\<Longrightarrow>\n       \\<exists>r p.\n          (x, y) = (p, target r p) \\<and>\n          NGBA.path A r p \\<and> r \\<noteq> []\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+;\n        (y, z) \\<in> {(p, q). q \\<in> successors A p};\n        \\<exists>r p.\n           (x, y) = (p, target r p) \\<and>\n           NGBA.path A r p \\<and> r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r p.\n                            (x, z) = (p, target r p) \\<and>\n                            NGBA.path A r p \\<and> r \\<noteq> []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r p.\n       (x, y) = (p, target r p) \\<and> NGBA.path A r p \\<and> r \\<noteq> []", "proof (intro exI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. (x, y) = (?p1, target ?r ?p1)\n 2. NGBA.path A ?r ?p1\n 3. ?r \\<noteq> []", "show \"(x, y) = (x, target [(a, y)] x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) = (x, target [(a, y)] x)", "by simp"], ["proof (state)\nthis:\n  (x, y) = (x, target [(a, y)] x)\n\ngoal (2 subgoals):\n 1. NGBA.path A [(a, y)] x\n 2. [(a, y)] \\<noteq> []", "show \"NGBA.path A [(a, y)] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NGBA.path A [(a, y)] x", "using 1"], ["proof (prove)\nusing this:\n  a \\<in> alphabet A\n  y \\<in> transition A a x\n\ngoal (1 subgoal):\n 1. NGBA.path A [(a, y)] x", "by auto"], ["proof (state)\nthis:\n  NGBA.path A [(a, y)] x\n\ngoal (1 subgoal):\n 1. [(a, y)] \\<noteq> []", "show \"[(a, y)] \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(a, y)] \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  [(a, y)] \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r p.\n     (x, y) = (p, target r p) \\<and> NGBA.path A r p \\<and> r \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+;\n        (y, z) \\<in> {(p, q). q \\<in> successors A p};\n        \\<exists>r p.\n           (x, y) = (p, target r p) \\<and>\n           NGBA.path A r p \\<and> r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r p.\n                            (x, z) = (p, target r p) \\<and>\n                            NGBA.path A r p \\<and> r \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+;\n        (y, z) \\<in> {(p, q). q \\<in> successors A p};\n        \\<exists>r p.\n           (x, y) = (p, target r p) \\<and>\n           NGBA.path A r p \\<and> r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r p.\n                            (x, z) = (p, target r p) \\<and>\n                            NGBA.path A r p \\<and> r \\<noteq> []", "case (step y z)"], ["proof (state)\nthis:\n  (x, y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+\n  (y, z) \\<in> {(p, q). q \\<in> successors A p}\n  \\<exists>r p.\n     (x, y) = (p, target r p) \\<and> NGBA.path A r p \\<and> r \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+;\n        (y, z) \\<in> {(p, q). q \\<in> successors A p};\n        \\<exists>r p.\n           (x, y) = (p, target r p) \\<and>\n           NGBA.path A r p \\<and> r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r p.\n                            (x, z) = (p, target r p) \\<and>\n                            NGBA.path A r p \\<and> r \\<noteq> []", "obtain r where 1: \"y = target r x\" \"NGBA.path A r x\" \"r \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>y = target r x; NGBA.path A r x; r \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step(3)"], ["proof (prove)\nusing this:\n  \\<exists>r p.\n     (x, y) = (p, target r p) \\<and> NGBA.path A r p \\<and> r \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>y = target r x; NGBA.path A r x; r \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = target r x\n  NGBA.path A r x\n  r \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+;\n        (y, z) \\<in> {(p, q). q \\<in> successors A p};\n        \\<exists>r p.\n           (x, y) = (p, target r p) \\<and>\n           NGBA.path A r p \\<and> r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r p.\n                            (x, z) = (p, target r p) \\<and>\n                            NGBA.path A r p \\<and> r \\<noteq> []", "obtain a where 2: \"a \\<in> alphabet A\" \"z \\<in> transition A a y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> alphabet A; z \\<in> transition A a y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step(2)"], ["proof (prove)\nusing this:\n  (y, z) \\<in> {(p, q). q \\<in> successors A p}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> alphabet A; z \\<in> transition A a y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> alphabet A\n  z \\<in> transition A a y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+;\n        (y, z) \\<in> {(p, q). q \\<in> successors A p};\n        \\<exists>r p.\n           (x, y) = (p, target r p) \\<and>\n           NGBA.path A r p \\<and> r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r p.\n                            (x, z) = (p, target r p) \\<and>\n                            NGBA.path A r p \\<and> r \\<noteq> []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r p.\n       (x, z) = (p, target r p) \\<and> NGBA.path A r p \\<and> r \\<noteq> []", "proof (intro exI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. (x, z) = (?p1, target ?r ?p1)\n 2. NGBA.path A ?r ?p1\n 3. ?r \\<noteq> []", "show \"(x, z) = (x, target (r @ [(a, z)]) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, z) = (x, target (r @ [(a, z)]) x)", "by simp"], ["proof (state)\nthis:\n  (x, z) = (x, target (r @ [(a, z)]) x)\n\ngoal (2 subgoals):\n 1. NGBA.path A (r @ [(a, z)]) x\n 2. r @ [(a, z)] \\<noteq> []", "show \"NGBA.path A (r @ [(a, z)]) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NGBA.path A (r @ [(a, z)]) x", "using 1 2"], ["proof (prove)\nusing this:\n  y = target r x\n  NGBA.path A r x\n  r \\<noteq> []\n  a \\<in> alphabet A\n  z \\<in> transition A a y\n\ngoal (1 subgoal):\n 1. NGBA.path A (r @ [(a, z)]) x", "by auto"], ["proof (state)\nthis:\n  NGBA.path A (r @ [(a, z)]) x\n\ngoal (1 subgoal):\n 1. r @ [(a, z)] \\<noteq> []", "show \"r @ [(a, z)] \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r @ [(a, z)] \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  r @ [(a, z)] \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r p.\n     (x, z) = (p, target r p) \\<and> NGBA.path A r p \\<and> r \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> {(p, q). q \\<in> successors A p}\\<^sup>+ \\<Longrightarrow>\n  \\<exists>r p.\n     (?x, ?y) = (p, target r p) \\<and> NGBA.path A r p \\<and> r \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a b r p.\n       \\<lbrakk>NGBA.path A r p; r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (p, target r p)\n                         \\<in> {(u, v). v \\<in> successors A u}\\<^sup>+", "show \"(p, target r p) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>+\" if \"NGBA.path A r p\" \"r \\<noteq> []\" for r p"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p, target r p) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>+", "using that"], ["proof (prove)\nusing this:\n  NGBA.path A r p\n  r \\<noteq> []\n\ngoal (1 subgoal):\n 1. (p, target r p) \\<in> {(u, v). v \\<in> successors A u}\\<^sup>+", "by (induct) (fastforce intro: trancl_into_trancl2)+"], ["proof (state)\nthis:\n  \\<lbrakk>NGBA.path A ?r ?p; ?r \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?p, target ?r ?p)\n                    \\<in> {(u, v). v \\<in> successors A u}\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ngba_g_ipath_run:\n    assumes \"ipath (g_E (ngba_g A)) r\"\n    obtains w\n    where \"run A (w ||| smap (r \\<circ> Suc) nats) (r 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        run A (w ||| smap (r \\<circ> Suc) nats) (r 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        run A (w ||| smap (r \\<circ> Suc) nats) (r 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have 1: \"\\<exists> a \\<in> alphabet A. r (Suc i) \\<in> transition A a (r i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>alphabet A. r (Suc i) \\<in> transition A a (r i)", "using assms"], ["proof (prove)\nusing this:\n  ipath (g_E (ngba_g A)) r\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>alphabet A. r (Suc i) \\<in> transition A a (r i)", "unfolding ipath_def ngba_g_def E_of_succ_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (r i, r (Suc i))\n     \\<in> g_E \\<lparr>g_V = UNIV, g_E = {(u, v). v \\<in> successors A u},\n                  g_V0 = initial A\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>alphabet A. r (Suc i) \\<in> transition A a (r i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>a\\<in>alphabet A. r (Suc ?i) \\<in> transition A a (r ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        run A (w ||| smap (r \\<circ> Suc) nats) (r 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain wr where 2: \"run A wr (r 0)\" \"\\<And> i. target (stake i wr) (r 0) = r i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>wr.\n        \\<lbrakk>run A wr (r 0);\n         \\<And>i. target (stake i wr) (r 0) = r i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule ngba.invariant_run_index)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>wr.\n        \\<lbrakk>run A wr (r 0);\n         \\<And>i. target (stake i wr) (r 0) = r i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?P2 ?n2 ?p2\n 2. \\<And>n p.\n       \\<lbrakk>\\<And>wr.\n                   \\<lbrakk>run A wr (r 0);\n                    \\<And>i. target (stake i wr) (r 0) = r i\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ?P2 n p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (fst a \\<in> alphabet ?A2 \\<and>\n                             snd a \\<in> transition ?A2 (fst a) p) \\<and>\n                            ?P2 (Suc n) (snd a) \\<and> ?Q2 n p a\n 3. \\<And>ra.\n       \\<lbrakk>\\<And>wr.\n                   \\<lbrakk>run A wr (r 0);\n                    \\<And>i. target (stake i wr) (r 0) = r i\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        run ?A2 ra ?p2; \\<And>i. ?P2 (?n2 + i) (target (stake i ra) ?p2);\n        \\<And>i. ?Q2 (?n2 + i) (target (stake i ra) ?p2) (ra !! i)\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"\\<exists> aq. (fst aq \\<in> alphabet A \\<and> snd aq \\<in> transition A (fst aq) p) \\<and> snd aq = r (Suc i) \\<and> True\"\n        if \"p = r i\" for i p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>aq.\n       (fst aq \\<in> alphabet A \\<and>\n        snd aq \\<in> transition A (fst aq) p) \\<and>\n       snd aq = r (Suc i) \\<and> True", "using that 1"], ["proof (prove)\nusing this:\n  p = r i\n  \\<exists>a\\<in>alphabet A. r (Suc ?i) \\<in> transition A a (r ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>aq.\n       (fst aq \\<in> alphabet A \\<and>\n        snd aq \\<in> transition A (fst aq) p) \\<and>\n       snd aq = r (Suc i) \\<and> True", "by auto"], ["proof (state)\nthis:\n  ?p = r ?i \\<Longrightarrow>\n  \\<exists>aq.\n     (fst aq \\<in> alphabet A \\<and>\n      snd aq \\<in> transition A (fst aq) ?p) \\<and>\n     snd aq = r (Suc ?i) \\<and> True\n\ngoal (2 subgoals):\n 1. (\\<And>wr.\n        \\<lbrakk>run A wr (r 0);\n         \\<And>i. target (stake i wr) (r 0) = r i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?p2 = r ?n2\n 2. \\<And>ra.\n       \\<lbrakk>\\<And>wr.\n                   \\<lbrakk>run A wr (r 0);\n                    \\<And>i. target (stake i wr) (r 0) = r i\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        run A ra ?p2; \\<And>i. target (stake i ra) ?p2 = r (?n2 + i);\n        \\<And>i. True\\<rbrakk>\n       \\<Longrightarrow> thesis", "show \"r 0 = r 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r 0 = r 0", "by rule"], ["proof (state)\nthis:\n  r 0 = r 0\n\ngoal (1 subgoal):\n 1. \\<And>ra.\n       \\<lbrakk>\\<And>wr.\n                   \\<lbrakk>run A wr (r 0);\n                    \\<And>i. target (stake i wr) (r 0) = r i\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        run A ra (r 0); \\<And>i. target (stake i ra) (r 0) = r (0 + i);\n        \\<And>i. True\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed auto"], ["proof (state)\nthis:\n  run A wr (r 0)\n  target (stake ?i wr) (r 0) = r ?i\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        run A (w ||| smap (r \\<circ> Suc) nats) (r 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have 3: \"smap (r \\<circ> Suc) nats = smap snd wr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (r \\<circ> Suc) nats = smap snd wr", "proof (rule eqI_snth)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. smap (r \\<circ> Suc) nats !! i = smap snd wr !! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. smap (r \\<circ> Suc) nats !! i = smap snd wr !! i", "have \"smap (r \\<circ> Suc) nats !! i = r (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (r \\<circ> Suc) nats !! i = r (Suc i)", "by simp"], ["proof (state)\nthis:\n  smap (r \\<circ> Suc) nats !! i = r (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i. smap (r \\<circ> Suc) nats !! i = smap snd wr !! i", "also"], ["proof (state)\nthis:\n  smap (r \\<circ> Suc) nats !! i = r (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i. smap (r \\<circ> Suc) nats !! i = smap snd wr !! i", "have \"\\<dots> = target (stake (Suc i) wr) (r 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r (Suc i) = target (stake (Suc i) wr) (r 0)", "unfolding 2(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r (Suc i) = r (Suc i)", "by rule"], ["proof (state)\nthis:\n  r (Suc i) = target (stake (Suc i) wr) (r 0)\n\ngoal (1 subgoal):\n 1. \\<And>i. smap (r \\<circ> Suc) nats !! i = smap snd wr !! i", "also"], ["proof (state)\nthis:\n  r (Suc i) = target (stake (Suc i) wr) (r 0)\n\ngoal (1 subgoal):\n 1. \\<And>i. smap (r \\<circ> Suc) nats !! i = smap snd wr !! i", "have \"\\<dots> = (r 0 ## trace wr (r 0)) !! Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. target (stake (Suc i) wr) (r 0) = (r 0 ## trace wr (r 0)) !! Suc i", "by simp"], ["proof (state)\nthis:\n  target (stake (Suc i) wr) (r 0) = (r 0 ## trace wr (r 0)) !! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i. smap (r \\<circ> Suc) nats !! i = smap snd wr !! i", "also"], ["proof (state)\nthis:\n  target (stake (Suc i) wr) (r 0) = (r 0 ## trace wr (r 0)) !! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i. smap (r \\<circ> Suc) nats !! i = smap snd wr !! i", "have \"\\<dots> = smap snd wr !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r 0 ## trace wr (r 0)) !! Suc i = smap snd wr !! i", "unfolding ngba.trace_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r 0 ## smap snd wr) !! Suc i = smap snd wr !! i", "by simp"], ["proof (state)\nthis:\n  (r 0 ## trace wr (r 0)) !! Suc i = smap snd wr !! i\n\ngoal (1 subgoal):\n 1. \\<And>i. smap (r \\<circ> Suc) nats !! i = smap snd wr !! i", "finally"], ["proof (chain)\npicking this:\n  smap (r \\<circ> Suc) nats !! i = smap snd wr !! i", "show \"smap (r \\<circ> Suc) nats !! i = smap snd wr !! i\""], ["proof (prove)\nusing this:\n  smap (r \\<circ> Suc) nats !! i = smap snd wr !! i\n\ngoal (1 subgoal):\n 1. smap (r \\<circ> Suc) nats !! i = smap snd wr !! i", "by this"], ["proof (state)\nthis:\n  smap (r \\<circ> Suc) nats !! i = smap snd wr !! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  smap (r \\<circ> Suc) nats = smap snd wr\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        run A (w ||| smap (r \\<circ> Suc) nats) (r 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. run A (?w ||| smap (r \\<circ> Suc) nats) (r 0)", "show \"run A (smap fst wr ||| smap (r \\<circ> Suc) nats) (r 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run A (smap fst wr ||| smap (r \\<circ> Suc) nats) (r 0)", "using 2(1)"], ["proof (prove)\nusing this:\n  run A wr (r 0)\n\ngoal (1 subgoal):\n 1. run A (smap fst wr ||| smap (r \\<circ> Suc) nats) (r 0)", "unfolding 3"], ["proof (prove)\nusing this:\n  run A wr (r 0)\n\ngoal (1 subgoal):\n 1. run A (smap fst wr ||| smap snd wr) (r 0)", "by auto"], ["proof (state)\nthis:\n  run A (smap fst wr ||| smap (r \\<circ> Suc) nats) (r 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ngba_g_run_ipath:\n    assumes \"run A (w ||| r) p\"\n    shows \"ipath (g_E (ngba_g A)) (snth (p ## r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath (g_E (ngba_g A)) ((!!) (p ## r))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. ((p ## r) !! i, (p ## r) !! Suc i) \\<in> g_E (ngba_g A)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. ((p ## r) !! i, (p ## r) !! Suc i) \\<in> g_E (ngba_g A)", "have 1: \"w !! i \\<in> alphabet A\" \"r !! i \\<in> transition A (w !! i) (target (stake i (w ||| r)) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w !! i \\<in> alphabet A &&&\n    r !! i \\<in> transition A (w !! i) (target (stake i (w ||| r)) p)", "using assms"], ["proof (prove)\nusing this:\n  run A (w ||| r) p\n\ngoal (1 subgoal):\n 1. w !! i \\<in> alphabet A &&&\n    r !! i \\<in> transition A (w !! i) (target (stake i (w ||| r)) p)", "by (auto dest: ngba.run_snth)"], ["proof (state)\nthis:\n  w !! i \\<in> alphabet A\n  r !! i \\<in> transition A (w !! i) (target (stake i (w ||| r)) p)\n\ngoal (1 subgoal):\n 1. \\<And>i. ((p ## r) !! i, (p ## r) !! Suc i) \\<in> g_E (ngba_g A)", "have 2: \"r !! i \\<in> successors A ((p ## r) !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r !! i \\<in> successors A ((p ## r) !! i)", "using 1"], ["proof (prove)\nusing this:\n  w !! i \\<in> alphabet A\n  r !! i \\<in> transition A (w !! i) (target (stake i (w ||| r)) p)\n\ngoal (1 subgoal):\n 1. r !! i \\<in> successors A ((p ## r) !! i)", "unfolding sscan_scons_snth[symmetric] ngba.trace_alt_def"], ["proof (prove)\nusing this:\n  w !! i \\<in> alphabet A\n  r !! i \\<in> transition A (w !! i) ((p ## smap snd (w ||| r)) !! i)\n\ngoal (1 subgoal):\n 1. r !! i \\<in> successors A ((p ## r) !! i)", "by auto"], ["proof (state)\nthis:\n  r !! i \\<in> successors A ((p ## r) !! i)\n\ngoal (1 subgoal):\n 1. \\<And>i. ((p ## r) !! i, (p ## r) !! Suc i) \\<in> g_E (ngba_g A)", "show \"((p ## r) !! i, (p ## r) !! Suc i) \\<in> g_E (ngba_g A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((p ## r) !! i, (p ## r) !! Suc i) \\<in> g_E (ngba_g A)", "using 2"], ["proof (prove)\nusing this:\n  r !! i \\<in> successors A ((p ## r) !! i)\n\ngoal (1 subgoal):\n 1. ((p ## r) !! i, (p ## r) !! Suc i) \\<in> g_E (ngba_g A)", "unfolding ngba_g_def graph_rec.simps E_of_succ_def"], ["proof (prove)\nusing this:\n  r !! i \\<in> successors A ((p ## r) !! i)\n\ngoal (1 subgoal):\n 1. ((p ## r) !! i, (p ## r) !! Suc i)\n    \\<in> {(u, v). v \\<in> successors A u}", "by simp"], ["proof (state)\nthis:\n  ((p ## r) !! i, (p ## r) !! Suc i) \\<in> g_E (ngba_g A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Indexed Generalized B?chi Graphs\\<close>"], ["", "definition ngba_acc :: \"'state pred gen \\<Rightarrow> 'state \\<Rightarrow> nat set\" where\n    \"ngba_acc cs p \\<equiv> {k \\<in> {0 ..< length cs}. (cs ! k) p}\""], ["", "lemma ngba_acc_param[param]: \"(ngba_acc, ngba_acc) \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow> S \\<rightarrow> \\<langle>nat_rel\\<rangle> set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ngba_acc, ngba_acc)\n    \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          S \\<rightarrow> \\<langle>nat_rel\\<rangle>set_rel", "unfolding ngba_acc_def list_rel_def list_all2_conv_all_nth fun_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>cs p. {k \\<in> {0..<length cs}. (cs ! k) p},\n     \\<lambda>cs p. {k \\<in> {0..<length cs}. (cs ! k) p})\n    \\<in> {(f, f').\n           \\<forall>(a, a')\n                    \\<in>{(l, l').\n                          length l = length l' \\<and>\n                          (\\<forall>i<length l.\n                              (l ! i, l' ! i)\n                              \\<in> {(f, f').\n                                     \\<forall>(a, a')\\<in>S.\n  (f a, f' a') \\<in> bool_rel})}.\n              (f a, f' a')\n              \\<in> {(f, f').\n                     \\<forall>(a, a')\\<in>S.\n                        (f a, f' a')\n                        \\<in> \\<langle>nat_rel\\<rangle>set_rel}}", "by auto"], ["", "definition ngba_igbg :: \"('label, 'state) ngba \\<Rightarrow> 'state igb_graph_rec\" where\n    \"ngba_igbg A \\<equiv> graph_rec.extend (ngba_g A) \\<lparr> igbg_num_acc = length (accepting A), igbg_acc = ngba_acc (accepting A) \\<rparr>\""], ["", "lemma acc_run_language:\n    assumes \"igb_graph (ngba_igbg A)\"\n    shows \"Ex (igb_graph.is_acc_run (ngba_igbg A)) \\<longleftrightarrow> language A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex (igb_graph.is_acc_run (ngba_igbg A)) = (language A \\<noteq> {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Ex (igb_graph.is_acc_run (ngba_igbg A)) \\<Longrightarrow>\n    language A \\<noteq> {}\n 2. language A \\<noteq> {} \\<Longrightarrow>\n    Ex (igb_graph.is_acc_run (ngba_igbg A))", "interpret igb_graph \"ngba_igbg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_graph (ngba_igbg A)", "using assms"], ["proof (prove)\nusing this:\n  igb_graph (ngba_igbg A)\n\ngoal (1 subgoal):\n 1. igb_graph (ngba_igbg A)", "by this"], ["proof (state)\ngoal (2 subgoals):\n 1. Ex is_acc_run \\<Longrightarrow> language A \\<noteq> {}\n 2. language A \\<noteq> {} \\<Longrightarrow> Ex is_acc_run", "have [simp]: \"V0 = g_V0 (ngba_g A)\" \"E = g_E (ngba_g A)\" \"num_acc = length (accepting A)\"\n      \"k \\<in> acc p \\<longleftrightarrow> k < length (accepting A) \\<and> (accepting A ! k) p\" for p k"], ["proof (prove)\ngoal (1 subgoal):\n 1. (V0 = g_V0 (ngba_g A) &&& E = g_E (ngba_g A)) &&&\n    num_acc = length (accepting A) &&&\n    (k \\<in> acc p) = (k < length (accepting A) \\<and> (accepting A ! k) p)", "unfolding ngba_igbg_def ngba_acc_def graph_rec.defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g_V0\n      \\<lparr>g_V = g_V (ngba_g A), g_E = g_E (ngba_g A),\n         g_V0 = g_V0 (ngba_g A), igbg_num_acc = length (accepting A),\n         igbg_acc =\n           \\<lambda>p.\n              {k \\<in> {0..<length (accepting A)}.\n               (accepting A ! k) p}\\<rparr> =\n     g_V0 (ngba_g A) &&&\n     g_E \\<lparr>g_V = g_V (ngba_g A), g_E = g_E (ngba_g A),\n            g_V0 = g_V0 (ngba_g A), igbg_num_acc = length (accepting A),\n            igbg_acc =\n              \\<lambda>p.\n                 {k \\<in> {0..<length (accepting A)}.\n                  (accepting A ! k) p}\\<rparr> =\n     g_E (ngba_g A)) &&&\n    igbg_num_acc\n     \\<lparr>g_V = g_V (ngba_g A), g_E = g_E (ngba_g A),\n        g_V0 = g_V0 (ngba_g A), igbg_num_acc = length (accepting A),\n        igbg_acc =\n          \\<lambda>p.\n             {k \\<in> {0..<length (accepting A)}.\n              (accepting A ! k) p}\\<rparr> =\n    length (accepting A) &&&\n    (k \\<in> igbg_acc\n              \\<lparr>g_V = g_V (ngba_g A), g_E = g_E (ngba_g A),\n                 g_V0 = g_V0 (ngba_g A),\n                 igbg_num_acc = length (accepting A),\n                 igbg_acc =\n                   \\<lambda>p.\n                      {k \\<in> {0..<length (accepting A)}.\n                       (accepting A ! k) p}\\<rparr>\n              p) =\n    (k < length (accepting A) \\<and> (accepting A ! k) p)", "by simp+"], ["proof (state)\nthis:\n  V0 = g_V0 (ngba_g A)\n  E = g_E (ngba_g A)\n  num_acc = length (accepting A)\n  (?k1 \\<in> acc ?p1) =\n  (?k1 < length (accepting A) \\<and> (accepting A ! ?k1) ?p1)\n\ngoal (2 subgoals):\n 1. Ex is_acc_run \\<Longrightarrow> language A \\<noteq> {}\n 2. language A \\<noteq> {} \\<Longrightarrow> Ex is_acc_run", "show \"language A \\<noteq> {}\" if run: \"Ex is_acc_run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language A \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. language A \\<noteq> {}", "obtain r where 1: \"is_acc_run r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r. is_acc_run r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using run"], ["proof (prove)\nusing this:\n  Ex is_acc_run\n\ngoal (1 subgoal):\n 1. (\\<And>r. is_acc_run r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by rule"], ["proof (state)\nthis:\n  is_acc_run r\n\ngoal (1 subgoal):\n 1. language A \\<noteq> {}", "have 2: \"r 0 \\<in> V0\" \"ipath E r\" \"is_acc r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r 0 \\<in> V0 &&& ipath E r &&& is_acc r", "using 1"], ["proof (prove)\nusing this:\n  is_acc_run r\n\ngoal (1 subgoal):\n 1. r 0 \\<in> V0 &&& ipath E r &&& is_acc r", "unfolding is_acc_run_def graph_defs.is_run_def"], ["proof (prove)\nusing this:\n  (r 0 \\<in> V0 \\<and> ipath E r) \\<and> is_acc r\n\ngoal (1 subgoal):\n 1. r 0 \\<in> V0 &&& ipath E r &&& is_acc r", "by auto"], ["proof (state)\nthis:\n  r 0 \\<in> V0\n  ipath E r\n  is_acc r\n\ngoal (1 subgoal):\n 1. language A \\<noteq> {}", "obtain w where 3: \"run A (w ||| smap (r \\<circ> Suc) nats) (r 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        run A (w ||| smap (r \\<circ> Suc) nats) (r 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ngba_g_ipath_run 2(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>ipath (g_E (ngba_g ?A)) ?r;\n   \\<And>w.\n      run ?A (w ||| smap (?r \\<circ> Suc) nats) (?r 0) \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ipath E r\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        run A (w ||| smap (r \\<circ> Suc) nats) (r 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  run A (w ||| smap (r \\<circ> Suc) nats) (r 0)\n\ngoal (1 subgoal):\n 1. language A \\<noteq> {}", "have 4: \"r 0 ## smap (r \\<circ> Suc) nats = smap r nats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r 0 ## smap (r \\<circ> Suc) nats = smap r nats", "by (simp) (metis stream.map_comp smap_siterate)"], ["proof (state)\nthis:\n  r 0 ## smap (r \\<circ> Suc) nats = smap r nats\n\ngoal (1 subgoal):\n 1. language A \\<noteq> {}", "have 5: \"infs (accepting A ! k) (r 0 ## smap (r \\<circ> Suc) nats)\" if \"k < length (accepting A)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (accepting A ! k) (r 0 ## smap (r \\<circ> Suc) nats)", "using 2(3) that"], ["proof (prove)\nusing this:\n  is_acc r\n  k < length (accepting A)\n\ngoal (1 subgoal):\n 1. infs (accepting A ! k) (r 0 ## smap (r \\<circ> Suc) nats)", "unfolding infs_infm is_acc_def 4"], ["proof (prove)\nusing this:\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i)\n  k < length (accepting A)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>i. (accepting A ! k) (smap r nats !! i)", "by simp"], ["proof (state)\nthis:\n  ?k1 < length (accepting A) \\<Longrightarrow>\n  infs (accepting A ! ?k1) (r 0 ## smap (r \\<circ> Suc) nats)\n\ngoal (1 subgoal):\n 1. language A \\<noteq> {}", "have \"w \\<in> language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> language A", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?p \\<in> initial A\n 2. run A (w ||| ?r) ?p\n 3. gen infs (accepting A) (?p ## ?r)", "show \"r 0 \\<in> initial A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r 0 \\<in> initial A", "using ngba_g_V0 2(1)"], ["proof (prove)\nusing this:\n  g_V0 (ngba_g ?A) = initial ?A\n  r 0 \\<in> V0\n\ngoal (1 subgoal):\n 1. r 0 \\<in> initial A", "by force"], ["proof (state)\nthis:\n  r 0 \\<in> initial A\n\ngoal (2 subgoals):\n 1. run A (w ||| ?r) (r 0)\n 2. gen infs (accepting A) (r 0 ## ?r)", "show \"run A (w ||| smap (r \\<circ> Suc) nats) (r 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run A (w ||| smap (r \\<circ> Suc) nats) (r 0)", "using 3"], ["proof (prove)\nusing this:\n  run A (w ||| smap (r \\<circ> Suc) nats) (r 0)\n\ngoal (1 subgoal):\n 1. run A (w ||| smap (r \\<circ> Suc) nats) (r 0)", "by this"], ["proof (state)\nthis:\n  run A (w ||| smap (r \\<circ> Suc) nats) (r 0)\n\ngoal (1 subgoal):\n 1. gen infs (accepting A) (r 0 ## smap (r \\<circ> Suc) nats)", "show \"gen infs (accepting A) (r 0 ## smap (r \\<circ> Suc) nats)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen infs (accepting A) (r 0 ## smap (r \\<circ> Suc) nats)", "unfolding gen_def all_set_conv_all_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (accepting A).\n       infs (accepting A ! i) (r 0 ## smap (r \\<circ> Suc) nats)", "using 5"], ["proof (prove)\nusing this:\n  ?k1 < length (accepting A) \\<Longrightarrow>\n  infs (accepting A ! ?k1) (r 0 ## smap (r \\<circ> Suc) nats)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (accepting A).\n       infs (accepting A ! i) (r 0 ## smap (r \\<circ> Suc) nats)", "by simp"], ["proof (state)\nthis:\n  gen infs (accepting A) (r 0 ## smap (r \\<circ> Suc) nats)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w \\<in> language A\n\ngoal (1 subgoal):\n 1. language A \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  w \\<in> language A", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<in> language A\n\ngoal (1 subgoal):\n 1. language A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  language A \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ex is_acc_run \\<Longrightarrow> language A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. language A \\<noteq> {} \\<Longrightarrow> Ex is_acc_run", "show \"Ex is_acc_run\" if language: \"language A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex is_acc_run", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex is_acc_run", "obtain w where 1: \"w \\<in> language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> language A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using language"], ["proof (prove)\nusing this:\n  language A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> language A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> language A\n\ngoal (1 subgoal):\n 1. Ex is_acc_run", "obtain r p where 2: \"p \\<in> initial A\" \"run A (w ||| r) p\" \"gen infs (accepting A) (p ## r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p r.\n        \\<lbrakk>p \\<in> initial A; run A (w ||| r) p;\n         gen infs (accepting A) (p ## r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1"], ["proof (prove)\nusing this:\n  w \\<in> language A\n\ngoal (1 subgoal):\n 1. (\\<And>p r.\n        \\<lbrakk>p \\<in> initial A; run A (w ||| r) p;\n         gen infs (accepting A) (p ## r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by rule"], ["proof (state)\nthis:\n  p \\<in> initial A\n  run A (w ||| r) p\n  gen infs (accepting A) (p ## r)\n\ngoal (1 subgoal):\n 1. Ex is_acc_run", "have \"is_acc_run (snth (p ## r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc_run ((!!) (p ## r))", "unfolding is_acc_run_def graph_defs.is_run_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((p ## r) !! 0 \\<in> V0 \\<and> ipath E ((!!) (p ## r))) \\<and>\n    is_acc ((!!) (p ## r))", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. (p ## r) !! 0 \\<in> V0\n 2. ipath E ((!!) (p ## r))\n 3. is_acc ((!!) (p ## r))", "show \"(p ## r) !! 0 \\<in> V0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p ## r) !! 0 \\<in> V0", "using ngba_g_V0 2(1)"], ["proof (prove)\nusing this:\n  g_V0 (ngba_g ?A) = initial ?A\n  p \\<in> initial A\n\ngoal (1 subgoal):\n 1. (p ## r) !! 0 \\<in> V0", "by force"], ["proof (state)\nthis:\n  (p ## r) !! 0 \\<in> V0\n\ngoal (2 subgoals):\n 1. ipath E ((!!) (p ## r))\n 2. is_acc ((!!) (p ## r))", "show \"ipath E (snth (p ## r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath E ((!!) (p ## r))", "using ngba_g_run_ipath 2(2)"], ["proof (prove)\nusing this:\n  run ?A (?w ||| ?r) ?p \\<Longrightarrow>\n  ipath (g_E (ngba_g ?A)) ((!!) (?p ## ?r))\n  run A (w ||| r) p\n\ngoal (1 subgoal):\n 1. ipath E ((!!) (p ## r))", "by force"], ["proof (state)\nthis:\n  ipath E ((!!) (p ## r))\n\ngoal (1 subgoal):\n 1. is_acc ((!!) (p ## r))", "show \"is_acc (snth (p ## r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc ((!!) (p ## r))", "using 2(3)"], ["proof (prove)\nusing this:\n  gen infs (accepting A) (p ## r)\n\ngoal (1 subgoal):\n 1. is_acc ((!!) (p ## r))", "unfolding gen_def infs_infm is_acc_def"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set (accepting A).\n     \\<exists>\\<^sub>\\<infinity>i. c ((p ## r) !! i)\n\ngoal (1 subgoal):\n 1. \\<forall>n<num_acc.\n       \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc ((p ## r) !! i)", "by simp"], ["proof (state)\nthis:\n  is_acc ((!!) (p ## r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_acc_run ((!!) (p ## r))\n\ngoal (1 subgoal):\n 1. Ex is_acc_run", "then"], ["proof (chain)\npicking this:\n  is_acc_run ((!!) (p ## r))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_acc_run ((!!) (p ## r))\n\ngoal (1 subgoal):\n 1. Ex is_acc_run", "by auto"], ["proof (state)\nthis:\n  Ex is_acc_run\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  language A \\<noteq> {} \\<Longrightarrow> Ex is_acc_run\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}