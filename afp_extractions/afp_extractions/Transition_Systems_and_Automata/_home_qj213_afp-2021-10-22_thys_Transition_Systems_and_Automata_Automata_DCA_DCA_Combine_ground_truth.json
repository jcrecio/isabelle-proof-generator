{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Automata/DCA/DCA_Combine.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemmas degeneralize_language[simp] = degeneralization.degeneralize_language[folded DCA.language_def]", "lemmas degeneralize_nodes_finite[iff] = degeneralization.degeneralize_nodes_finite[folded DCA.nodes_def]", "lemmas degeneralize_nodes_card = degeneralization.degeneralize_nodes_card[folded DCA.nodes_def]", "lemmas intersect_language = intersection.product_language", "lemmas intersect_nodes_finite = intersection.product_nodes_finite", "lemmas intersect_nodes_card = intersection.product_nodes_card", "lemmas union'_language[simp] = union.product_language[folded DGCA.language_def]", "lemmas union'_nodes_finite = union.product_nodes_finite[folded DGCA.nodes_def]", "lemmas union'_nodes_card = union.product_nodes_card[folded DGCA.nodes_def]", "lemmas intersect_list_language = intersection_list.product_language", "lemmas intersect_list_nodes_finite = intersection_list.product_nodes_finite", "lemmas intersect_list_nodes_card = intersection_list.product_nodes_card", "lemmas union_list'_language[simp] = union_list.product_language[folded DGCA.language_def]", "lemmas union_list'_nodes_finite = union_list.product_nodes_finite[folded DGCA.nodes_def]", "lemmas union_list'_nodes_card = union_list.product_nodes_card[folded DGCA.nodes_def]", "lemma union_language[simp]:\n    assumes \"dca.alphabet A = dca.alphabet B\"\n    shows \"DCA.language (union A B) = DCA.language A \\<union> DCA.language B\"", "lemma union_nodes_finite:\n    assumes \"finite (DCA.nodes A)\" \"finite (DCA.nodes B)\"\n    shows \"finite (DCA.nodes (union A B))\"", "lemma union_nodes_card:\n    assumes \"finite (DCA.nodes A)\" \"finite (DCA.nodes B)\"\n    shows \"card (DCA.nodes (union A B)) \\<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)\"", "lemma union_list_language[simp]:\n    assumes \"\\<Inter> (dca.alphabet ` set AA) = \\<Union> (dca.alphabet ` set AA)\"\n    shows \"DCA.language (union_list AA) = \\<Union> (DCA.language ` set AA)\"", "lemma union_list_nodes_finite:\n    assumes \"list_all (finite \\<circ> DCA.nodes) AA\"\n    shows \"finite (DCA.nodes (union_list AA))\"", "lemma union_list_nodes_card:\n    assumes \"list_all (finite \\<circ> DCA.nodes) AA\"\n    shows \"card (DCA.nodes (union_list AA)) \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)\""], "translations": [["", "lemmas degeneralize_language[simp] = degeneralization.degeneralize_language[folded DCA.language_def]"], ["", "lemmas degeneralize_nodes_finite[iff] = degeneralization.degeneralize_nodes_finite[folded DCA.nodes_def]"], ["", "lemmas degeneralize_nodes_card = degeneralization.degeneralize_nodes_card[folded DCA.nodes_def]"], ["", "global_interpretation intersection: automaton_intersection_run\n    dca.dca dca.alphabet dca.initial dca.transition dca.rejecting \"\\<lambda> P w r p. fins P (p ## r)\"\n    dca.dca dca.alphabet dca.initial dca.transition dca.rejecting \"\\<lambda> P w r p. fins P (p ## r)\"\n    dca.dca dca.alphabet dca.initial dca.transition dca.rejecting \"\\<lambda> P w r p. fins P (p ## r)\"\n    \"\\<lambda> c\\<^sub>1 c\\<^sub>2 pq. (c\\<^sub>1 \\<circ> fst) pq \\<or> (c\\<^sub>2 \\<circ> snd) pq\"\n    defines intersect = intersection.product"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton_intersection_run dca dca.alphabet dca.initial dca.transition\n     dca.rejecting (\\<lambda>P w r p. fins P (p ## r)) dca dca.alphabet\n     dca.initial dca.transition dca.rejecting\n     (\\<lambda>P w r p. fins P (p ## r)) dca dca.alphabet dca.initial\n     dca.transition dca.rejecting (\\<lambda>P w r p. fins P (p ## r))\n     (\\<lambda>c\\<^sub>1 c\\<^sub>2 pq.\n         (c\\<^sub>1 \\<circ> fst) pq \\<or> (c\\<^sub>2 \\<circ> snd) pq)", "by (unfold_locales) (simp del: comp_apply)"], ["", "lemmas intersect_language = intersection.product_language"], ["", "lemmas intersect_nodes_finite = intersection.product_nodes_finite"], ["", "lemmas intersect_nodes_card = intersection.product_nodes_card"], ["", "global_interpretation union: automaton_union_run\n    dca.dca dca.alphabet dca.initial dca.transition dca.rejecting \"\\<lambda> P w r p. fins P (p ## r)\"\n    dca.dca dca.alphabet dca.initial dca.transition dca.rejecting \"\\<lambda> P w r p. fins P (p ## r)\"\n    dgca.dgca dgca.alphabet dgca.initial dgca.transition dgca.rejecting \"\\<lambda> P w r p. cogen fins P (p ## r)\"\n    \"\\<lambda> c\\<^sub>1 c\\<^sub>2. [c\\<^sub>1 \\<circ> fst, c\\<^sub>2 \\<circ> snd]\"\n    defines union' = union.product"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton_union_run dca dca.alphabet dca.initial dca.transition\n     dca.rejecting (\\<lambda>P w r p. fins P (p ## r)) dca dca.alphabet\n     dca.initial dca.transition dca.rejecting\n     (\\<lambda>P w r p. fins P (p ## r)) dgca dgca.alphabet dgca.initial\n     dgca.transition dgca.rejecting\n     (\\<lambda>P w r p. cogen fins P (p ## r))\n     (\\<lambda>c\\<^sub>1 c\\<^sub>2.\n         [c\\<^sub>1 \\<circ> fst, c\\<^sub>2 \\<circ> snd])", "by unfold_locales auto"], ["", "lemmas union'_language[simp] = union.product_language[folded DGCA.language_def]"], ["", "lemmas union'_nodes_finite = union.product_nodes_finite[folded DGCA.nodes_def]"], ["", "lemmas union'_nodes_card = union.product_nodes_card[folded DGCA.nodes_def]"], ["", "global_interpretation intersection_list: automaton_intersection_list_run\n    dca.dca dca.alphabet dca.initial dca.transition dca.rejecting \"\\<lambda> P w r p. fins P (p ## r)\"\n    dca.dca dca.alphabet dca.initial dca.transition dca.rejecting \"\\<lambda> P w r p. fins P (p ## r)\"\n    \"\\<lambda> cs pp. \\<exists> k < length cs. (cs ! k) (pp ! k)\"\n    defines intersect_list = intersection_list.product"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton_intersection_list_run dca dca.alphabet dca.initial\n     dca.transition dca.rejecting (\\<lambda>P w r p. fins P (p ## r)) dca\n     dca.alphabet dca.initial dca.transition dca.rejecting\n     (\\<lambda>P w r p. fins P (p ## r))\n     (\\<lambda>cs pp. \\<exists>k<length cs. (cs ! k) (pp ! k))", "by (unfold_locales) (simp add: comp_def)"], ["", "lemmas intersect_list_language = intersection_list.product_language"], ["", "lemmas intersect_list_nodes_finite = intersection_list.product_nodes_finite"], ["", "lemmas intersect_list_nodes_card = intersection_list.product_nodes_card"], ["", "global_interpretation union_list: automaton_union_list_run\n    dca.dca dca.alphabet dca.initial dca.transition dca.rejecting \"\\<lambda> P w r p. fins P (p ## r)\"\n    dgca.dgca dgca.alphabet dgca.initial dgca.transition dgca.rejecting \"\\<lambda> P w r p. cogen fins P (p ## r)\"\n    \"\\<lambda> cs. map (\\<lambda> k pp. (cs ! k) (pp ! k)) [0 ..< length cs]\"\n    defines union_list' = union_list.product"], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton_union_list_run dca dca.alphabet dca.initial dca.transition\n     dca.rejecting (\\<lambda>P w r p. fins P (p ## r)) dgca dgca.alphabet\n     dgca.initial dgca.transition dgca.rejecting\n     (\\<lambda>P w r p. cogen fins P (p ## r))\n     (\\<lambda>cs. map (\\<lambda>k pp. (cs ! k) (pp ! k)) [0..<length cs])", "by (unfold_locales) (auto simp: cogen_def comp_def)"], ["", "lemmas union_list'_language[simp] = union_list.product_language[folded DGCA.language_def]"], ["", "lemmas union_list'_nodes_finite = union_list.product_nodes_finite[folded DGCA.nodes_def]"], ["", "lemmas union_list'_nodes_card = union_list.product_nodes_card[folded DGCA.nodes_def]"], ["", "abbreviation union where \"union A B \\<equiv> degeneralize (union' A B)\""], ["", "lemma union_language[simp]:\n    assumes \"dca.alphabet A = dca.alphabet B\"\n    shows \"DCA.language (union A B) = DCA.language A \\<union> DCA.language B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DCA.language (DCA_Combine.union A B) =\n    DCA.language A \\<union> DCA.language B", "using assms"], ["proof (prove)\nusing this:\n  dca.alphabet A = dca.alphabet B\n\ngoal (1 subgoal):\n 1. DCA.language (DCA_Combine.union A B) =\n    DCA.language A \\<union> DCA.language B", "by simp"], ["", "lemma union_nodes_finite:\n    assumes \"finite (DCA.nodes A)\" \"finite (DCA.nodes B)\"\n    shows \"finite (DCA.nodes (union A B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DCA.nodes (DCA_Combine.union A B))", "using union'_nodes_finite assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (DCA.nodes ?A); finite (DCA.nodes ?B)\\<rbrakk>\n  \\<Longrightarrow> finite (DGCA.nodes (union' ?A ?B))\n  finite (DCA.nodes A)\n  finite (DCA.nodes B)\n\ngoal (1 subgoal):\n 1. finite (DCA.nodes (DCA_Combine.union A B))", "by simp"], ["", "lemma union_nodes_card:\n    assumes \"finite (DCA.nodes A)\" \"finite (DCA.nodes B)\"\n    shows \"card (DCA.nodes (union A B)) \\<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DCA.nodes (DCA_Combine.union A B))\n    \\<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (DCA.nodes (DCA_Combine.union A B))\n    \\<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)", "have \"card (DCA.nodes (union A B)) \\<le>\n      max 1 (length (dgca.rejecting (union' A B))) * card (DGCA.nodes (union' A B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DCA.nodes (DCA_Combine.union A B))\n    \\<le> max 1 (length (dgca.rejecting (union' A B))) *\n          card (DGCA.nodes (union' A B))", "using degeneralize_nodes_card"], ["proof (prove)\nusing this:\n  card (DCA.nodes (degeneralize ?A))\n  \\<le> max 1 (length (dgca.rejecting ?A)) * card (DGCA.nodes ?A)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (DCA_Combine.union A B))\n    \\<le> max 1 (length (dgca.rejecting (union' A B))) *\n          card (DGCA.nodes (union' A B))", "by this"], ["proof (state)\nthis:\n  card (DCA.nodes (DCA_Combine.union A B))\n  \\<le> max 1 (length (dgca.rejecting (union' A B))) *\n        card (DGCA.nodes (union' A B))\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (DCA_Combine.union A B))\n    \\<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)", "also"], ["proof (state)\nthis:\n  card (DCA.nodes (DCA_Combine.union A B))\n  \\<le> max 1 (length (dgca.rejecting (union' A B))) *\n        card (DGCA.nodes (union' A B))\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (DCA_Combine.union A B))\n    \\<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)", "have \"length (dgca.rejecting (union' A B)) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (dgca.rejecting (union' A B)) = 2", "by simp"], ["proof (state)\nthis:\n  length (dgca.rejecting (union' A B)) = 2\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (DCA_Combine.union A B))\n    \\<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)", "also"], ["proof (state)\nthis:\n  length (dgca.rejecting (union' A B)) = 2\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (DCA_Combine.union A B))\n    \\<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)", "have \"card (DGCA.nodes (union' A B)) \\<le> card (DCA.nodes A) * card (DCA.nodes B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DGCA.nodes (union' A B))\n    \\<le> card (DCA.nodes A) * card (DCA.nodes B)", "using union'_nodes_card assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (DCA.nodes ?A); finite (DCA.nodes ?B)\\<rbrakk>\n  \\<Longrightarrow> card (DGCA.nodes (union' ?A ?B))\n                    \\<le> card (DCA.nodes ?A) * card (DCA.nodes ?B)\n  finite (DCA.nodes A)\n  finite (DCA.nodes B)\n\ngoal (1 subgoal):\n 1. card (DGCA.nodes (union' A B))\n    \\<le> card (DCA.nodes A) * card (DCA.nodes B)", "by this"], ["proof (state)\nthis:\n  card (DGCA.nodes (union' A B))\n  \\<le> card (DCA.nodes A) * card (DCA.nodes B)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (DCA_Combine.union A B))\n    \\<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max 1 2 * x \\<le> max 1 2 * y) \\<Longrightarrow>\n  card (DCA.nodes (DCA_Combine.union A B))\n  \\<le> max 1 2 * (card (DCA.nodes A) * card (DCA.nodes B))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max 1 2 * x \\<le> max 1 2 * y) \\<Longrightarrow>\n  card (DCA.nodes (DCA_Combine.union A B))\n  \\<le> max 1 2 * (card (DCA.nodes A) * card (DCA.nodes B))\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (DCA_Combine.union A B))\n    \\<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)", "by simp"], ["proof (state)\nthis:\n  card (DCA.nodes (DCA_Combine.union A B))\n  \\<le> 2 * card (DCA.nodes A) * card (DCA.nodes B)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation union_list where \"union_list AA \\<equiv> degeneralize (union_list' AA)\""], ["", "lemma union_list_language[simp]:\n    assumes \"\\<Inter> (dca.alphabet ` set AA) = \\<Union> (dca.alphabet ` set AA)\"\n    shows \"DCA.language (union_list AA) = \\<Union> (DCA.language ` set AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DCA.language (union_list AA) = \\<Union> (DCA.language ` set AA)", "using assms"], ["proof (prove)\nusing this:\n  \\<Inter> (dca.alphabet ` set AA) = \\<Union> (dca.alphabet ` set AA)\n\ngoal (1 subgoal):\n 1. DCA.language (union_list AA) = \\<Union> (DCA.language ` set AA)", "by simp"], ["", "lemma union_list_nodes_finite:\n    assumes \"list_all (finite \\<circ> DCA.nodes) AA\"\n    shows \"finite (DCA.nodes (union_list AA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DCA.nodes (union_list AA))", "using union_list'_nodes_finite assms"], ["proof (prove)\nusing this:\n  list_all (finite \\<circ> DCA.nodes) ?AA \\<Longrightarrow>\n  finite (DGCA.nodes (union_list' ?AA))\n  list_all (finite \\<circ> DCA.nodes) AA\n\ngoal (1 subgoal):\n 1. finite (DCA.nodes (union_list AA))", "by simp"], ["", "lemma union_list_nodes_card:\n    assumes \"list_all (finite \\<circ> DCA.nodes) AA\"\n    shows \"card (DCA.nodes (union_list AA)) \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DCA.nodes (union_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (DCA.nodes (union_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)", "have \"card (DCA.nodes (union_list AA)) \\<le>\n      max 1 (length (dgca.rejecting (union_list' AA))) * card (DGCA.nodes (union_list' AA))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DCA.nodes (union_list AA))\n    \\<le> max 1 (length (dgca.rejecting (union_list' AA))) *\n          card (DGCA.nodes (union_list' AA))", "using degeneralize_nodes_card"], ["proof (prove)\nusing this:\n  card (DCA.nodes (degeneralize ?A))\n  \\<le> max 1 (length (dgca.rejecting ?A)) * card (DGCA.nodes ?A)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (union_list AA))\n    \\<le> max 1 (length (dgca.rejecting (union_list' AA))) *\n          card (DGCA.nodes (union_list' AA))", "by this"], ["proof (state)\nthis:\n  card (DCA.nodes (union_list AA))\n  \\<le> max 1 (length (dgca.rejecting (union_list' AA))) *\n        card (DGCA.nodes (union_list' AA))\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (union_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)", "also"], ["proof (state)\nthis:\n  card (DCA.nodes (union_list AA))\n  \\<le> max 1 (length (dgca.rejecting (union_list' AA))) *\n        card (DGCA.nodes (union_list' AA))\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (union_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)", "have \"length (dgca.rejecting (union_list' AA)) = length AA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (dgca.rejecting (union_list' AA)) = length AA", "by simp"], ["proof (state)\nthis:\n  length (dgca.rejecting (union_list' AA)) = length AA\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (union_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)", "also"], ["proof (state)\nthis:\n  length (dgca.rejecting (union_list' AA)) = length AA\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (union_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)", "have \"card (DGCA.nodes (union_list' AA)) \\<le> prod_list (map (card \\<circ> DCA.nodes) AA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DGCA.nodes (union_list' AA))\n    \\<le> prod_list (map (card \\<circ> DCA.nodes) AA)", "using union_list'_nodes_card assms"], ["proof (prove)\nusing this:\n  list_all (finite \\<circ> DCA.nodes) ?AA \\<Longrightarrow>\n  card (DGCA.nodes (union_list' ?AA))\n  \\<le> prod_list (map (card \\<circ> DCA.nodes) ?AA)\n  list_all (finite \\<circ> DCA.nodes) AA\n\ngoal (1 subgoal):\n 1. card (DGCA.nodes (union_list' AA))\n    \\<le> prod_list (map (card \\<circ> DCA.nodes) AA)", "by this"], ["proof (state)\nthis:\n  card (DGCA.nodes (union_list' AA))\n  \\<le> prod_list (map (card \\<circ> DCA.nodes) AA)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (union_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max 1 (length AA) * x \\<le> max 1 (length AA) * y) \\<Longrightarrow>\n  card (DCA.nodes (union_list AA))\n  \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      max 1 (length AA) * x \\<le> max 1 (length AA) * y) \\<Longrightarrow>\n  card (DCA.nodes (union_list AA))\n  \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (union_list AA))\n    \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)", "by simp"], ["proof (state)\nthis:\n  card (DCA.nodes (union_list AA))\n  \\<le> max 1 (length AA) * prod_list (map (card \\<circ> DCA.nodes) AA)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}