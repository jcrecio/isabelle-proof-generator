{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Basic/Degeneralization.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma degen_simps[iff]: \"degen cs (a, k) \\<longleftrightarrow> k \\<ge> length cs \\<or> (cs ! k) a\"", "lemma count_empty[simp]: \"count [] a k = k\"", "lemma count_nonempty[simp]: \"cs \\<noteq> [] \\<Longrightarrow> count cs a k < length cs\"", "lemma count_constant_1:\n    assumes \"k < length cs\"\n    assumes \"\\<And> a. a \\<in> set w \\<Longrightarrow> \\<not> (cs ! k) a\"\n    shows \"fold (count cs) w k = k\"", "lemma count_constant_2:\n    assumes \"k < length cs\"\n    assumes \"\\<And> a. a \\<in> set (w || k # scan (count cs) w k) \\<Longrightarrow> \\<not> degen cs a\"\n    shows \"fold (count cs) w k = k\"", "lemma count_step:\n    assumes \"k < length cs\"\n    assumes \"(cs ! k) a\"\n    shows \"count cs a k = Suc k mod length cs\"", "lemma degen_skip_condition:\n    assumes \"k < length cs\"\n    assumes \"infs (degen cs) (w ||| k ## sscan (count cs) w k)\"\n    obtains u a v\n    where \"w = u @- a ## v\" \"fold (count cs) u k = k\" \"(cs ! k) a\"", "lemma degen_skip_arbitrary:\n    assumes \"k < length cs\" \"l < length cs\"\n    assumes \"infs (degen cs) (w ||| k ## sscan (count cs) w k)\"\n    obtains u v\n    where \"w = u @- v\" \"fold (count cs) u k = l\"", "lemma degen_skip_arbitrary_condition:\n    assumes \"l < length cs\"\n    assumes \"infs (degen cs) (w ||| k ## sscan (count cs) w k)\"\n    obtains u a v\n    where \"w = u @- a ## v\" \"fold (count cs) u k = l\" \"(cs ! l) a\"", "lemma gen_degen_step:\n    assumes \"gen infs cs w\"\n    obtains u a v\n    where \"w = u @- a ## v\" \"degen cs (a, fold (count cs) u k)\"", "lemma degen_infs[iff]: \"infs (degen cs) (w ||| k ## sscan (count cs) w k) \\<longleftrightarrow> gen infs cs w\""], "translations": [["", "lemma degen_simps[iff]: \"degen cs (a, k) \\<longleftrightarrow> k \\<ge> length cs \\<or> (cs ! k) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degen cs (a, k) = (length cs \\<le> k \\<or> (cs ! k) a)", "unfolding degen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (a, k) of\n     (a, k) \\<Rightarrow> length cs \\<le> k \\<or> (cs ! k) a) =\n    (length cs \\<le> k \\<or> (cs ! k) a)", "by simp"], ["", "definition count :: \"'a pred gen \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> nat\" where\n    \"count cs a k \\<equiv>\n      if k < length cs\n      then if (cs ! k) a then Suc k mod length cs else k\n      else if cs = [] then k else 0\""], ["", "lemma count_empty[simp]: \"count [] a k = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count [] a k = k", "unfolding count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k < length [] then if ([] ! k) a then Suc k mod length [] else k\n     else if [] = [] then k else 0) =\n    k", "by simp"], ["", "lemma count_nonempty[simp]: \"cs \\<noteq> [] \\<Longrightarrow> count cs a k < length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs \\<noteq> [] \\<Longrightarrow> count cs a k < length cs", "unfolding count_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cs \\<noteq> [] \\<Longrightarrow>\n    (if k < length cs then if (cs ! k) a then Suc k mod length cs else k\n     else if cs = [] then k else 0)\n    < length cs", "by simp"], ["", "lemma count_constant_1:\n    assumes \"k < length cs\"\n    assumes \"\\<And> a. a \\<in> set w \\<Longrightarrow> \\<not> (cs ! k) a\"\n    shows \"fold (count cs) w k = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (count cs) w k = k", "using assms"], ["proof (prove)\nusing this:\n  k < length cs\n  ?a \\<in> set w \\<Longrightarrow> \\<not> (cs ! k) ?a\n\ngoal (1 subgoal):\n 1. fold (count cs) w k = k", "unfolding count_def"], ["proof (prove)\nusing this:\n  k < length cs\n  ?a \\<in> set w \\<Longrightarrow> \\<not> (cs ! k) ?a\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>a k.\n         if k < length cs then if (cs ! k) a then Suc k mod length cs else k\n         else if cs = [] then k else 0)\n     w k =\n    k", "by (induct w) (auto)"], ["", "lemma count_constant_2:\n    assumes \"k < length cs\"\n    assumes \"\\<And> a. a \\<in> set (w || k # scan (count cs) w k) \\<Longrightarrow> \\<not> degen cs a\"\n    shows \"fold (count cs) w k = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (count cs) w k = k", "using assms"], ["proof (prove)\nusing this:\n  k < length cs\n  ?a \\<in> set (w || k # scan (count cs) w k) \\<Longrightarrow>\n  \\<not> degen cs ?a\n\ngoal (1 subgoal):\n 1. fold (count cs) w k = k", "unfolding count_def"], ["proof (prove)\nusing this:\n  k < length cs\n  ?a \\<in> set (w ||\n                k #\n                scan\n                 (\\<lambda>a k.\n                     if k < length cs\n                     then if (cs ! k) a then Suc k mod length cs else k\n                     else if cs = [] then k else 0)\n                 w k) \\<Longrightarrow>\n  \\<not> degen cs ?a\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>a k.\n         if k < length cs then if (cs ! k) a then Suc k mod length cs else k\n         else if cs = [] then k else 0)\n     w k =\n    k", "by (induct w) (auto)"], ["", "lemma count_step:\n    assumes \"k < length cs\"\n    assumes \"(cs ! k) a\"\n    shows \"count cs a k = Suc k mod length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count cs a k = Suc k mod length cs", "using assms"], ["proof (prove)\nusing this:\n  k < length cs\n  (cs ! k) a\n\ngoal (1 subgoal):\n 1. count cs a k = Suc k mod length cs", "unfolding count_def"], ["proof (prove)\nusing this:\n  k < length cs\n  (cs ! k) a\n\ngoal (1 subgoal):\n 1. (if k < length cs then if (cs ! k) a then Suc k mod length cs else k\n     else if cs = [] then k else 0) =\n    Suc k mod length cs", "by simp"], ["", "lemma degen_skip_condition:\n    assumes \"k < length cs\"\n    assumes \"infs (degen cs) (w ||| k ## sscan (count cs) w k)\"\n    obtains u a v\n    where \"w = u @- a ## v\" \"fold (count cs) u k = k\" \"(cs ! k) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \"Collect (degen cs) \\<inter> sset (w ||| k ## sscan (count cs) w k) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (degen cs) \\<inter>\n    sset (w ||| k ## sscan (count cs) w k) \\<noteq>\n    {}", "using infs_any assms(2)"], ["proof (prove)\nusing this:\n  infs ?P ?w \\<Longrightarrow> Bex (sset ?w) ?P\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. Collect (degen cs) \\<inter>\n    sset (w ||| k ## sscan (count cs) w k) \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  Collect (degen cs) \\<inter>\n  sset (w ||| k ## sscan (count cs) w k) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain ys x zs where 2:\n      \"w ||| k ## sscan (count cs) w k = ys @- x ## zs\"\n      \"Collect (degen cs) \\<inter> set ys = {}\"\n      \"x \\<in> Collect (degen cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys x zs.\n        \\<lbrakk>w ||| k ## sscan (count cs) w k = ys @- x ## zs;\n         Collect (degen cs) \\<inter> set ys = {};\n         x \\<in> Collect (degen cs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_stream_first 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<inter> sset ?xs \\<noteq> {};\n   \\<And>ys a zs.\n      \\<lbrakk>?xs = ys @- a ## zs; ?A \\<inter> set ys = {};\n       a \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Collect (degen cs) \\<inter>\n  sset (w ||| k ## sscan (count cs) w k) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>ys x zs.\n        \\<lbrakk>w ||| k ## sscan (count cs) w k = ys @- x ## zs;\n         Collect (degen cs) \\<inter> set ys = {};\n         x \\<in> Collect (degen cs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  w ||| k ## sscan (count cs) w k = ys @- x ## zs\n  Collect (degen cs) \\<inter> set ys = {}\n  x \\<in> Collect (degen cs)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define u where \"u \\<equiv> stake (length ys) w\""], ["proof (state)\nthis:\n  u \\<equiv> stake (length ys) w\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define a where \"a \\<equiv> w !! length ys\""], ["proof (state)\nthis:\n  a \\<equiv> w !! length ys\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define v where \"v \\<equiv> sdrop (Suc (length ys)) w\""], ["proof (state)\nthis:\n  v \\<equiv> sdrop (Suc (length ys)) w\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"ys = stake (length ys) (w ||| k ## sscan (count cs) w k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = stake (length ys) (w ||| k ## sscan (count cs) w k)", "using shift_eq 2(1)"], ["proof (prove)\nusing this:\n  (?u @- ?v = ?w) =\n  (?u = stake (length ?u) ?w \\<and> ?v = sdrop (length ?u) ?w)\n  w ||| k ## sscan (count cs) w k = ys @- x ## zs\n\ngoal (1 subgoal):\n 1. ys = stake (length ys) (w ||| k ## sscan (count cs) w k)", "by auto"], ["proof (state)\nthis:\n  ys = stake (length ys) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  ys = stake (length ys) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = stake (length ys) w || stake (length ys) (k ## sscan (count cs) w k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake (length ys) (w ||| k ## sscan (count cs) w k) =\n    stake (length ys) w || stake (length ys) (k ## sscan (count cs) w k)", "by simp"], ["proof (state)\nthis:\n  stake (length ys) (w ||| k ## sscan (count cs) w k) =\n  stake (length ys) w || stake (length ys) (k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  stake (length ys) (w ||| k ## sscan (count cs) w k) =\n  stake (length ys) w || stake (length ys) (k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = take (length ys) u || take (length ys) (k # scan (count cs) u k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake (length ys) w || stake (length ys) (k ## sscan (count cs) w k) =\n    take (length ys) u || take (length ys) (k # scan (count cs) u k)", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. stake (length ys) w || stake (length ys) (k ## sscan (count cs) w k) =\n    take (length ys) (stake (length ys) w) ||\n    take (length ys) (k # scan (count cs) (stake (length ys) w) k)", "using append_eq_conv_conj length_stake length_zip stream.sel"], ["proof (prove)\nusing this:\n  (?xs @ ?ys = ?zs) =\n  (?xs = take (length ?xs) ?zs \\<and> ?ys = drop (length ?xs) ?zs)\n  length (stake ?n ?s) = ?n\n  length (?xs || ?ys) = min (length ?xs) (length ?ys)\n  shd (?x1.0 ## ?x2.0) = ?x1.0\n  stl (?x1.0 ## ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. stake (length ys) w || stake (length ys) (k ## sscan (count cs) w k) =\n    take (length ys) (stake (length ys) w) ||\n    take (length ys) (k # scan (count cs) (stake (length ys) w) k)", "using sscan_stake stake.simps(2) stake_Suc stake_szip take_stake"], ["proof (prove)\nusing this:\n  (?xs @ ?ys = ?zs) =\n  (?xs = take (length ?xs) ?zs \\<and> ?ys = drop (length ?xs) ?zs)\n  length (stake ?n ?s) = ?n\n  length (?xs || ?ys) = min (length ?xs) (length ?ys)\n  shd (?x1.0 ## ?x2.0) = ?x1.0\n  stl (?x1.0 ## ?x2.0) = ?x2.0\n  stake ?k (sscan ?f ?xs ?a) = scan ?f (stake ?k ?xs) ?a\n  stake (Suc ?n) ?s = shd ?s # stake ?n (stl ?s)\n  stake (Suc ?n) ?s = stake ?n ?s @ [?s !! ?n]\n  stake ?n (?s1.0 ||| ?s2.0) = stake ?n ?s1.0 || stake ?n ?s2.0\n  take ?n (stake ?m ?s) = stake (min ?n ?m) ?s\n\ngoal (1 subgoal):\n 1. stake (length ys) w || stake (length ys) (k ## sscan (count cs) w k) =\n    take (length ys) (stake (length ys) w) ||\n    take (length ys) (k # scan (count cs) (stake (length ys) w) k)", "by metis"], ["proof (state)\nthis:\n  stake (length ys) w || stake (length ys) (k ## sscan (count cs) w k) =\n  take (length ys) u || take (length ys) (k # scan (count cs) u k)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  stake (length ys) w || stake (length ys) (k ## sscan (count cs) w k) =\n  take (length ys) u || take (length ys) (k # scan (count cs) u k)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = take (length ys) (u || k # scan (count cs) u k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length ys) u || take (length ys) (k # scan (count cs) u k) =\n    take (length ys) (u || k # scan (count cs) u k)", "using take_zip"], ["proof (prove)\nusing this:\n  take ?n (?xs || ?ys) = take ?n ?xs || take ?n ?ys\n\ngoal (1 subgoal):\n 1. take (length ys) u || take (length ys) (k # scan (count cs) u k) =\n    take (length ys) (u || k # scan (count cs) u k)", "by rule"], ["proof (state)\nthis:\n  take (length ys) u || take (length ys) (k # scan (count cs) u k) =\n  take (length ys) (u || k # scan (count cs) u k)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  take (length ys) u || take (length ys) (k # scan (count cs) u k) =\n  take (length ys) (u || k # scan (count cs) u k)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = u || k # scan (count cs) u k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length ys) (u || k # scan (count cs) u k) =\n    u || k # scan (count cs) u k", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length ys)\n     (stake (length ys) w || k # scan (count cs) (stake (length ys) w) k) =\n    stake (length ys) w || k # scan (count cs) (stake (length ys) w) k", "by simp"], ["proof (state)\nthis:\n  take (length ys) (u || k # scan (count cs) u k) =\n  u || k # scan (count cs) u k\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  ys = u || k # scan (count cs) u k", "have 3: \"ys = u || k # scan (count cs) u k\""], ["proof (prove)\nusing this:\n  ys = u || k # scan (count cs) u k\n\ngoal (1 subgoal):\n 1. ys = u || k # scan (count cs) u k", "by this"], ["proof (state)\nthis:\n  ys = u || k # scan (count cs) u k\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"x = (w ||| k ## sscan (count cs) w k) !! length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (w ||| k ## sscan (count cs) w k) !! length ys", "unfolding 2(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (ys @- x ## zs) !! length ys", "by simp"], ["proof (state)\nthis:\n  x = (w ||| k ## sscan (count cs) w k) !! length ys\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  x = (w ||| k ## sscan (count cs) w k) !! length ys\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = (w !! length ys, (k ## sscan (count cs) w k) !! length ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w ||| k ## sscan (count cs) w k) !! length ys =\n    (w !! length ys, (k ## sscan (count cs) w k) !! length ys)", "by simp"], ["proof (state)\nthis:\n  (w ||| k ## sscan (count cs) w k) !! length ys =\n  (w !! length ys, (k ## sscan (count cs) w k) !! length ys)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (w ||| k ## sscan (count cs) w k) !! length ys =\n  (w !! length ys, (k ## sscan (count cs) w k) !! length ys)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = (a, fold (count cs) u k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w !! length ys, (k ## sscan (count cs) w k) !! length ys) =\n    (a, fold (count cs) u k)", "unfolding u_def a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (w !! length ys, (k ## sscan (count cs) w k) !! length ys) =\n    (w !! length ys, fold (count cs) (stake (length ys) w) k)", "by simp"], ["proof (state)\nthis:\n  (w !! length ys, (k ## sscan (count cs) w k) !! length ys) =\n  (a, fold (count cs) u k)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  x = (a, fold (count cs) u k)", "have 4: \"x = (a, fold (count cs) u k)\""], ["proof (prove)\nusing this:\n  x = (a, fold (count cs) u k)\n\ngoal (1 subgoal):\n 1. x = (a, fold (count cs) u k)", "by this"], ["proof (state)\nthis:\n  x = (a, fold (count cs) u k)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 5: \"fold (count cs) u k = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (count cs) u k = k", "using count_constant_2 assms(1) 2(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k < length ?cs;\n   \\<And>a.\n      a \\<in> set (?w || ?k # scan (count ?cs) ?w ?k) \\<Longrightarrow>\n      \\<not> degen ?cs a\\<rbrakk>\n  \\<Longrightarrow> fold (count ?cs) ?w ?k = ?k\n  k < length cs\n  Collect (degen cs) \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. fold (count cs) u k = k", "unfolding 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k < length ?cs;\n   \\<And>a.\n      a \\<in> set (?w || ?k # scan (count ?cs) ?w ?k) \\<Longrightarrow>\n      \\<not> degen ?cs a\\<rbrakk>\n  \\<Longrightarrow> fold (count ?cs) ?w ?k = ?k\n  k < length cs\n  Collect (degen cs) \\<inter> set (u || k # scan (count cs) u k) = {}\n\ngoal (1 subgoal):\n 1. fold (count cs) u k = k", "by blast"], ["proof (state)\nthis:\n  fold (count cs) u k = k\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = k;\n         (cs ! k) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. w = ?u @- ?a ## ?v\n 2. fold (count cs) ?u k = k\n 3. (cs ! k) ?a", "show \"w = u @- a ## v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = u @- a ## v", "unfolding u_def a_def v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. w = stake (length ys) w @- w !! length ys ## sdrop (Suc (length ys)) w", "using id_stake_snth_sdrop"], ["proof (prove)\nusing this:\n  ?s = stake ?i ?s @- ?s !! ?i ## sdrop (Suc ?i) ?s\n\ngoal (1 subgoal):\n 1. w = stake (length ys) w @- w !! length ys ## sdrop (Suc (length ys)) w", "by this"], ["proof (state)\nthis:\n  w = u @- a ## v\n\ngoal (2 subgoals):\n 1. fold (count cs) u k = k\n 2. (cs ! k) a", "show \"fold (count cs) u k = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (count cs) u k = k", "using 5"], ["proof (prove)\nusing this:\n  fold (count cs) u k = k\n\ngoal (1 subgoal):\n 1. fold (count cs) u k = k", "by this"], ["proof (state)\nthis:\n  fold (count cs) u k = k\n\ngoal (1 subgoal):\n 1. (cs ! k) a", "show \"(cs ! k) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cs ! k) a", "using assms(1) 2(3)"], ["proof (prove)\nusing this:\n  k < length cs\n  x \\<in> Collect (degen cs)\n\ngoal (1 subgoal):\n 1. (cs ! k) a", "unfolding 4 5"], ["proof (prove)\nusing this:\n  k < length cs\n  (a, k) \\<in> Collect (degen cs)\n\ngoal (1 subgoal):\n 1. (cs ! k) a", "by simp"], ["proof (state)\nthis:\n  (cs ! k) a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_skip_arbitrary:\n    assumes \"k < length cs\" \"l < length cs\"\n    assumes \"infs (degen cs) (w ||| k ## sscan (count cs) w k)\"\n    obtains u v\n    where \"w = u @- v\" \"fold (count cs) u k = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  k < length cs\n  l < length cs\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct \"nat ((int l - int k) mod length cs)\" arbitrary: l thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l thesis.\n       \\<lbrakk>0 = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (0)"], ["proof (state)\nthis:\n  0 = nat ((int l - int k) mod int (length cs))\n  \\<lbrakk>w = ?u @- ?v; fold (count cs) ?u k = l\\<rbrakk>\n  \\<Longrightarrow> thesis\n  k < length cs\n  l < length cs\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (2 subgoals):\n 1. \\<And>l thesis.\n       \\<lbrakk>0 = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 1: \"length cs > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length cs", "using assms(1)"], ["proof (prove)\nusing this:\n  k < length cs\n\ngoal (1 subgoal):\n 1. 0 < length cs", "by auto"], ["proof (state)\nthis:\n  0 < length cs\n\ngoal (2 subgoals):\n 1. \\<And>l thesis.\n       \\<lbrakk>0 = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 2: \"(int l - int k) mod length cs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int l - int k) mod int (length cs) = 0", "using 0(1) 1"], ["proof (prove)\nusing this:\n  0 = nat ((int l - int k) mod int (length cs))\n  0 < length cs\n\ngoal (1 subgoal):\n 1. (int l - int k) mod int (length cs) = 0", "by (auto intro: antisym)"], ["proof (state)\nthis:\n  (int l - int k) mod int (length cs) = 0\n\ngoal (2 subgoals):\n 1. \\<And>l thesis.\n       \\<lbrakk>0 = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 3: \"int l mod length cs = int k mod length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int l mod int (length cs) = int k mod int (length cs)", "using mod_eq_dvd_iff 2"], ["proof (prove)\nusing this:\n  (?a mod ?c = ?b mod ?c) = (?c dvd ?a - ?b)\n  (int l - int k) mod int (length cs) = 0\n\ngoal (1 subgoal):\n 1. int l mod int (length cs) = int k mod int (length cs)", "by force"], ["proof (state)\nthis:\n  int l mod int (length cs) = int k mod int (length cs)\n\ngoal (2 subgoals):\n 1. \\<And>l thesis.\n       \\<lbrakk>0 = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 4: \"k = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = l", "using 0(3, 4) 3"], ["proof (prove)\nusing this:\n  k < length cs\n  l < length cs\n  int l mod int (length cs) = int k mod int (length cs)\n\ngoal (1 subgoal):\n 1. k = l", "by simp"], ["proof (state)\nthis:\n  k = l\n\ngoal (2 subgoals):\n 1. \\<And>l thesis.\n       \\<lbrakk>0 = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule 0(2))"], ["proof (state)\ngoal (2 subgoals):\n 1. w = ?u @- ?v\n 2. fold (count cs) ?u k = l", "show \"w = [] @- w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = [] @- w", "by simp"], ["proof (state)\nthis:\n  w = [] @- w\n\ngoal (1 subgoal):\n 1. fold (count cs) [] k = l", "show \"fold (count cs) [] k = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (count cs) [] k = l", "using 4"], ["proof (prove)\nusing this:\n  k = l\n\ngoal (1 subgoal):\n 1. fold (count cs) [] k = l", "by simp"], ["proof (state)\nthis:\n  fold (count cs) [] k = l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = nat ((int ?l - int k) mod int (length cs));\n   \\<And>u v.\n      \\<lbrakk>w = u @- v; fold (count cs) u k = ?l\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   k < length cs; ?l < length cs;\n   infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Suc n = nat ((int l - int k) mod int (length cs))\n  \\<lbrakk>w = ?u @- ?v; fold (count cs) ?u k = l\\<rbrakk>\n  \\<Longrightarrow> thesis\n  k < length cs\n  l < length cs\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 1: \"length cs > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length cs", "using assms(1)"], ["proof (prove)\nusing this:\n  k < length cs\n\ngoal (1 subgoal):\n 1. 0 < length cs", "by auto"], ["proof (state)\nthis:\n  0 < length cs\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "define l' where \"l' = nat ((int l - 1) mod length cs)\""], ["proof (state)\nthis:\n  l' = nat ((int l - 1) mod int (length cs))\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain u v where 2: \"w = u @- v\" \"fold (count cs) u k = l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule Suc(1))"], ["proof (state)\ngoal (5 subgoals):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    n = nat ((int ?l2 - int k) mod int (length cs))\n 2. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = ?l2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 < length cs\n 5. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "have 2: \"Suc n < length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n < length cs", "using nat_less_iff Suc(2) 1"], ["proof (prove)\nusing this:\n  0 \\<le> ?w \\<Longrightarrow> (nat ?w < ?m) = (?w < int ?m)\n  Suc n = nat ((int l - int k) mod int (length cs))\n  0 < length cs\n\ngoal (1 subgoal):\n 1. Suc n < length cs", "by simp"], ["proof (state)\nthis:\n  Suc n < length cs\n\ngoal (5 subgoals):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    n = nat ((int ?l2 - int k) mod int (length cs))\n 2. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = ?l2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 < length cs\n 5. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "have \"n = nat (int n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = nat (int n)", "by simp"], ["proof (state)\nthis:\n  n = nat (int n)\n\ngoal (5 subgoals):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    n = nat ((int ?l2 - int k) mod int (length cs))\n 2. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = ?l2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 < length cs\n 5. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "also"], ["proof (state)\nthis:\n  n = nat (int n)\n\ngoal (5 subgoals):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    n = nat ((int ?l2 - int k) mod int (length cs))\n 2. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = ?l2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 < length cs\n 5. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "have \"int n = (int (Suc n) - 1) mod length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int n = (int (Suc n) - 1) mod int (length cs)", "using 2"], ["proof (prove)\nusing this:\n  Suc n < length cs\n\ngoal (1 subgoal):\n 1. int n = (int (Suc n) - 1) mod int (length cs)", "by simp"], ["proof (state)\nthis:\n  int n = (int (Suc n) - 1) mod int (length cs)\n\ngoal (5 subgoals):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    n = nat ((int ?l2 - int k) mod int (length cs))\n 2. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = ?l2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 < length cs\n 5. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "also"], ["proof (state)\nthis:\n  int n = (int (Suc n) - 1) mod int (length cs)\n\ngoal (5 subgoals):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    n = nat ((int ?l2 - int k) mod int (length cs))\n 2. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = ?l2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 < length cs\n 5. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "have \"\\<dots> = (int l - int k - 1) mod length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int (Suc n) - 1) mod int (length cs) =\n    (int l - int k - 1) mod int (length cs)", "using Suc(2)"], ["proof (prove)\nusing this:\n  Suc n = nat ((int l - int k) mod int (length cs))\n\ngoal (1 subgoal):\n 1. (int (Suc n) - 1) mod int (length cs) =\n    (int l - int k - 1) mod int (length cs)", "by (simp add: mod_simps)"], ["proof (state)\nthis:\n  (int (Suc n) - 1) mod int (length cs) =\n  (int l - int k - 1) mod int (length cs)\n\ngoal (5 subgoals):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    n = nat ((int ?l2 - int k) mod int (length cs))\n 2. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = ?l2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 < length cs\n 5. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "also"], ["proof (state)\nthis:\n  (int (Suc n) - 1) mod int (length cs) =\n  (int l - int k - 1) mod int (length cs)\n\ngoal (5 subgoals):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    n = nat ((int ?l2 - int k) mod int (length cs))\n 2. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = ?l2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 < length cs\n 5. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "have \"\\<dots> = (int l - 1 - int k) mod length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int l - int k - 1) mod int (length cs) =\n    (int l - 1 - int k) mod int (length cs)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (int l - int k - 1) mod int (length cs) =\n  (int l - 1 - int k) mod int (length cs)\n\ngoal (5 subgoals):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    n = nat ((int ?l2 - int k) mod int (length cs))\n 2. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = ?l2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 < length cs\n 5. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "also"], ["proof (state)\nthis:\n  (int l - int k - 1) mod int (length cs) =\n  (int l - 1 - int k) mod int (length cs)\n\ngoal (5 subgoals):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    n = nat ((int ?l2 - int k) mod int (length cs))\n 2. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = ?l2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 < length cs\n 5. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "have \"\\<dots> = (int l' - int k) mod length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int l - 1 - int k) mod int (length cs) =\n    (int l' - int k) mod int (length cs)", "using l'_def 1"], ["proof (prove)\nusing this:\n  l' = nat ((int l - 1) mod int (length cs))\n  0 < length cs\n\ngoal (1 subgoal):\n 1. (int l - 1 - int k) mod int (length cs) =\n    (int l' - int k) mod int (length cs)", "by (simp add: mod_simps)"], ["proof (state)\nthis:\n  (int l - 1 - int k) mod int (length cs) =\n  (int l' - int k) mod int (length cs)\n\ngoal (5 subgoals):\n 1. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    n = nat ((int ?l2 - int k) mod int (length cs))\n 2. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = ?l2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?l2 < length cs\n 5. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "finally"], ["proof (chain)\npicking this:\n  n = nat ((int l' - int k) mod int (length cs))", "show \"n = nat ((int l' - int k) mod length cs)\""], ["proof (prove)\nusing this:\n  n = nat ((int l' - int k) mod int (length cs))\n\ngoal (1 subgoal):\n 1. n = nat ((int l' - int k) mod int (length cs))", "by this"], ["proof (state)\nthis:\n  n = nat ((int l' - int k) mod int (length cs))\n\ngoal (4 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    k < length cs\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    l' < length cs\n 4. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "show \"k < length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length cs", "using Suc(4)"], ["proof (prove)\nusing this:\n  k < length cs\n\ngoal (1 subgoal):\n 1. k < length cs", "by this"], ["proof (state)\nthis:\n  k < length cs\n\ngoal (3 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    l' < length cs\n 3. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "show \"l' < length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' < length cs", "using nat_less_iff l'_def 1"], ["proof (prove)\nusing this:\n  0 \\<le> ?w \\<Longrightarrow> (nat ?w < ?m) = (?w < int ?m)\n  l' = nat ((int l - 1) mod int (length cs))\n  0 < length cs\n\ngoal (1 subgoal):\n 1. l' < length cs", "by simp"], ["proof (state)\nthis:\n  l' < length cs\n\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. (\\<And>u v.\n        \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "show \"infs (degen cs) (w ||| k ## sscan (count cs) w k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (degen cs) (w ||| k ## sscan (count cs) w k)", "using Suc(6)"], ["proof (prove)\nusing this:\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. infs (degen cs) (w ||| k ## sscan (count cs) w k)", "by this"], ["proof (state)\nthis:\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w = u @- v; fold (count cs) u k = l'\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed"], ["proof (state)\nthis:\n  w = u @- v\n  fold (count cs) u k = l'\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 3: \"l' < length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' < length cs", "using nat_less_iff l'_def 1"], ["proof (prove)\nusing this:\n  0 \\<le> ?w \\<Longrightarrow> (nat ?w < ?m) = (?w < int ?m)\n  l' = nat ((int l - 1) mod int (length cs))\n  0 < length cs\n\ngoal (1 subgoal):\n 1. l' < length cs", "by simp"], ["proof (state)\nthis:\n  l' < length cs\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 4: \"v ||| l' ## sscan (count cs) v l' = sdrop (length u) (w ||| k ## sscan (count cs) w k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ||| l' ## sscan (count cs) v l' =\n    sdrop (length u) (w ||| k ## sscan (count cs) w k)", "using 2 eq_scons eq_shift"], ["proof (prove)\nusing this:\n  w = u @- v\n  fold (count cs) u k = l'\n  (?w = ?a ## ?v) = (?a = shd ?w \\<and> ?v = stl ?w)\n  (?w = ?u @- ?v) =\n  (stake (length ?u) ?w = ?u \\<and> sdrop (length ?u) ?w = ?v)\n\ngoal (1 subgoal):\n 1. v ||| l' ## sscan (count cs) v l' =\n    sdrop (length u) (w ||| k ## sscan (count cs) w k)", "by (metis sdrop.simps(2) sdrop_simps sdrop_szip sscan_scons_snth sscan_sdrop stream.sel(2))"], ["proof (state)\nthis:\n  v ||| l' ## sscan (count cs) v l' =\n  sdrop (length u) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have 5: \"infs (degen cs) (v ||| l' ## sscan (count cs) v l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (degen cs) (v ||| l' ## sscan (count cs) v l')", "using Suc(6)"], ["proof (prove)\nusing this:\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. infs (degen cs) (v ||| l' ## sscan (count cs) v l')", "unfolding 4"], ["proof (prove)\nusing this:\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. infs (degen cs) (sdrop (length u) (w ||| k ## sscan (count cs) w k))", "by blast"], ["proof (state)\nthis:\n  infs (degen cs) (v ||| l' ## sscan (count cs) v l')\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain vu a vv where 6: \"v = vu @- a ## vv\" \"fold (count cs) vu l' = l'\" \"(cs ! l') a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vu a vv.\n        \\<lbrakk>v = vu @- a ## vv; fold (count cs) vu l' = l';\n         (cs ! l') a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using degen_skip_condition 3 5"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k < length ?cs;\n   infs (degen ?cs) (?w ||| ?k ## sscan (count ?cs) ?w ?k);\n   \\<And>u a v.\n      \\<lbrakk>?w = u @- a ## v; fold (count ?cs) u ?k = ?k;\n       (?cs ! ?k) a\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  l' < length cs\n  infs (degen cs) (v ||| l' ## sscan (count cs) v l')\n\ngoal (1 subgoal):\n 1. (\\<And>vu a vv.\n        \\<lbrakk>v = vu @- a ## vv; fold (count cs) vu l' = l';\n         (cs ! l') a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  v = vu @- a ## vv\n  fold (count cs) vu l' = l'\n  (cs ! l') a\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"l = nat (int l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = nat (int l)", "by simp"], ["proof (state)\nthis:\n  l = nat (int l)\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  l = nat (int l)\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"int l = int l mod length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int l = int l mod int (length cs)", "using Suc(5)"], ["proof (prove)\nusing this:\n  l < length cs\n\ngoal (1 subgoal):\n 1. int l = int l mod int (length cs)", "by simp"], ["proof (state)\nthis:\n  int l = int l mod int (length cs)\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  int l = int l mod int (length cs)\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"\\<dots> = int (Suc l') mod length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int l mod int (length cs) = int (Suc l') mod int (length cs)", "using l'_def 1"], ["proof (prove)\nusing this:\n  l' = nat ((int l - 1) mod int (length cs))\n  0 < length cs\n\ngoal (1 subgoal):\n 1. int l mod int (length cs) = int (Suc l') mod int (length cs)", "by (simp add: mod_simps)"], ["proof (state)\nthis:\n  int l mod int (length cs) = int (Suc l') mod int (length cs)\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  l = nat (int (Suc l') mod int (length cs))", "have 7: \"l = Suc l' mod length cs\""], ["proof (prove)\nusing this:\n  l = nat (int (Suc l') mod int (length cs))\n\ngoal (1 subgoal):\n 1. l = Suc l' mod length cs", "using nat_mod_as_int"], ["proof (prove)\nusing this:\n  l = nat (int (Suc l') mod int (length cs))\n  (mod) = (\\<lambda>a b. nat (int a mod int b))\n\ngoal (1 subgoal):\n 1. l = Suc l' mod length cs", "by metis"], ["proof (state)\nthis:\n  l = Suc l' mod length cs\n\ngoal (1 subgoal):\n 1. \\<And>x l thesis.\n       \\<lbrakk>\\<And>l thesis.\n                   \\<lbrakk>x = nat ((int l - int k) mod int (length cs));\n                    \\<And>u v.\n                       \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    k < length cs; l < length cs;\n                    infs (degen cs)\n                     (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc x = nat ((int l - int k) mod int (length cs));\n        \\<And>u v.\n           \\<lbrakk>w = u @- v; fold (count cs) u k = l\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        k < length cs; l < length cs;\n        infs (degen cs) (w ||| k ## sscan (count cs) w k)\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule Suc(3))"], ["proof (state)\ngoal (2 subgoals):\n 1. w = ?u @- ?v\n 2. fold (count cs) ?u k = l", "show \"w = (u @ vu @ [a]) @- vv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = (u @ vu @ [a]) @- vv", "unfolding 2(1) 6(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. u @- vu @- a ## vv = (u @ vu @ [a]) @- vv", "by simp"], ["proof (state)\nthis:\n  w = (u @ vu @ [a]) @- vv\n\ngoal (1 subgoal):\n 1. fold (count cs) (u @ vu @ [a]) k = l", "show \"fold (count cs) (u @ vu @ [a]) k = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (count cs) (u @ vu @ [a]) k = l", "using 2(2) 3 6(2, 3) 7 count_step"], ["proof (prove)\nusing this:\n  fold (count cs) u k = l'\n  l' < length cs\n  fold (count cs) vu l' = l'\n  (cs ! l') a\n  l = Suc l' mod length cs\n  \\<lbrakk>?k < length ?cs; (?cs ! ?k) ?a\\<rbrakk>\n  \\<Longrightarrow> count ?cs ?a ?k = Suc ?k mod length ?cs\n\ngoal (1 subgoal):\n 1. fold (count cs) (u @ vu @ [a]) k = l", "by simp"], ["proof (state)\nthis:\n  fold (count cs) (u @ vu @ [a]) k = l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_skip_arbitrary_condition:\n    assumes \"l < length cs\"\n    assumes \"infs (degen cs) (w ||| k ## sscan (count cs) w k)\"\n    obtains u a v\n    where \"w = u @- a ## v\" \"fold (count cs) u k = l\" \"(cs ! l) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = l;\n         (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = l;\n         (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 0: \"cs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs \\<noteq> []", "using assms(1)"], ["proof (prove)\nusing this:\n  l < length cs\n\ngoal (1 subgoal):\n 1. cs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = l;\n         (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \"count cs (shd w) k < length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count cs (shd w) k < length cs", "using 0"], ["proof (prove)\nusing this:\n  cs \\<noteq> []\n\ngoal (1 subgoal):\n 1. count cs (shd w) k < length cs", "by simp"], ["proof (state)\nthis:\n  count cs (shd w) k < length cs\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = l;\n         (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 2: \"infs (degen cs) (stl w ||| count cs (shd w) k ## sscan (count cs) (stl w) (count cs (shd w) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (degen cs)\n     (stl w |||\n      count cs (shd w) k ## sscan (count cs) (stl w) (count cs (shd w) k))", "using assms(2)"], ["proof (prove)\nusing this:\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. infs (degen cs)\n     (stl w |||\n      count cs (shd w) k ## sscan (count cs) (stl w) (count cs (shd w) k))", "by (metis alw.cases sscan.code stream.sel(2) szip.simps(2))"], ["proof (state)\nthis:\n  infs (degen cs)\n   (stl w |||\n    count cs (shd w) k ## sscan (count cs) (stl w) (count cs (shd w) k))\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = l;\n         (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain u v where 3: \"stl w = u @- v\" \"fold (count cs) u (count cs (shd w) k) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>stl w = u @- v;\n         fold (count cs) u (count cs (shd w) k) = l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using degen_skip_arbitrary 1 assms(1) 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k < length ?cs; ?l < length ?cs;\n   infs (degen ?cs) (?w ||| ?k ## sscan (count ?cs) ?w ?k);\n   \\<And>u v.\n      \\<lbrakk>?w = u @- v; fold (count ?cs) u ?k = ?l\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  count cs (shd w) k < length cs\n  l < length cs\n  infs (degen cs)\n   (stl w |||\n    count cs (shd w) k ## sscan (count cs) (stl w) (count cs (shd w) k))\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>stl w = u @- v;\n         fold (count cs) u (count cs (shd w) k) = l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  stl w = u @- v\n  fold (count cs) u (count cs (shd w) k) = l\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = l;\n         (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 4: \"v ||| l ## sscan (count cs) v l =\n      sdrop (length u) (stl w ||| count cs (shd w) k ## sscan (count cs) (stl w) (count cs (shd w) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v ||| l ## sscan (count cs) v l =\n    sdrop (length u)\n     (stl w |||\n      count cs (shd w) k ## sscan (count cs) (stl w) (count cs (shd w) k))", "using 3 eq_scons eq_shift"], ["proof (prove)\nusing this:\n  stl w = u @- v\n  fold (count cs) u (count cs (shd w) k) = l\n  (?w = ?a ## ?v) = (?a = shd ?w \\<and> ?v = stl ?w)\n  (?w = ?u @- ?v) =\n  (stake (length ?u) ?w = ?u \\<and> sdrop (length ?u) ?w = ?v)\n\ngoal (1 subgoal):\n 1. v ||| l ## sscan (count cs) v l =\n    sdrop (length u)\n     (stl w |||\n      count cs (shd w) k ## sscan (count cs) (stl w) (count cs (shd w) k))", "by (metis sdrop.simps(2) sdrop_simps sdrop_szip sscan_scons_snth sscan_sdrop stream.sel(2))"], ["proof (state)\nthis:\n  v ||| l ## sscan (count cs) v l =\n  sdrop (length u)\n   (stl w |||\n    count cs (shd w) k ## sscan (count cs) (stl w) (count cs (shd w) k))\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = l;\n         (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 5: \"infs (degen cs) (v ||| l ## sscan (count cs) v l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (degen cs) (v ||| l ## sscan (count cs) v l)", "using 2"], ["proof (prove)\nusing this:\n  infs (degen cs)\n   (stl w |||\n    count cs (shd w) k ## sscan (count cs) (stl w) (count cs (shd w) k))\n\ngoal (1 subgoal):\n 1. infs (degen cs) (v ||| l ## sscan (count cs) v l)", "unfolding 4"], ["proof (prove)\nusing this:\n  infs (degen cs)\n   (stl w |||\n    count cs (shd w) k ## sscan (count cs) (stl w) (count cs (shd w) k))\n\ngoal (1 subgoal):\n 1. infs (degen cs)\n     (sdrop (length u)\n       (stl w |||\n        count cs (shd w) k ##\n        sscan (count cs) (stl w) (count cs (shd w) k)))", "by blast"], ["proof (state)\nthis:\n  infs (degen cs) (v ||| l ## sscan (count cs) v l)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = l;\n         (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain vu a vv where 6: \"v = vu @- a ## vv\" \"fold (count cs) vu l = l\" \"(cs ! l) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vu a vv.\n        \\<lbrakk>v = vu @- a ## vv; fold (count cs) vu l = l;\n         (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using degen_skip_condition assms(1) 5"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k < length ?cs;\n   infs (degen ?cs) (?w ||| ?k ## sscan (count ?cs) ?w ?k);\n   \\<And>u a v.\n      \\<lbrakk>?w = u @- a ## v; fold (count ?cs) u ?k = ?k;\n       (?cs ! ?k) a\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  l < length cs\n  infs (degen cs) (v ||| l ## sscan (count cs) v l)\n\ngoal (1 subgoal):\n 1. (\\<And>vu a vv.\n        \\<lbrakk>v = vu @- a ## vv; fold (count cs) vu l = l;\n         (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  v = vu @- a ## vv\n  fold (count cs) vu l = l\n  (cs ! l) a\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; fold (count cs) u k = l;\n         (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. w = ?u @- ?a ## ?v\n 2. fold (count cs) ?u k = l\n 3. (cs ! l) ?a", "show \"w = (shd w # u @ vu) @- a ## vv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = (shd w # u @ vu) @- a ## vv", "using 3(1) 6(1)"], ["proof (prove)\nusing this:\n  stl w = u @- v\n  v = vu @- a ## vv\n\ngoal (1 subgoal):\n 1. w = (shd w # u @ vu) @- a ## vv", "by (simp add: eq_scons)"], ["proof (state)\nthis:\n  w = (shd w # u @ vu) @- a ## vv\n\ngoal (2 subgoals):\n 1. fold (count cs) (shd w # u @ vu) k = l\n 2. (cs ! l) a", "show \"fold (count cs) (shd w # u @ vu) k = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (count cs) (shd w # u @ vu) k = l", "using 3(2) 6(2)"], ["proof (prove)\nusing this:\n  fold (count cs) u (count cs (shd w) k) = l\n  fold (count cs) vu l = l\n\ngoal (1 subgoal):\n 1. fold (count cs) (shd w # u @ vu) k = l", "by simp"], ["proof (state)\nthis:\n  fold (count cs) (shd w # u @ vu) k = l\n\ngoal (1 subgoal):\n 1. (cs ! l) a", "show \"(cs ! l) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cs ! l) a", "using 6(3)"], ["proof (prove)\nusing this:\n  (cs ! l) a\n\ngoal (1 subgoal):\n 1. (cs ! l) a", "by this"], ["proof (state)\nthis:\n  (cs ! l) a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gen_degen_step:\n    assumes \"gen infs cs w\"\n    obtains u a v\n    where \"w = u @- a ## v\" \"degen cs (a, fold (count cs) u k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; degen cs (a, fold (count cs) u k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"k < length cs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  k < length cs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "have 1: \"infs (cs ! k) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (cs ! k) w", "using assms True"], ["proof (prove)\nusing this:\n  gen infs cs w\n  k < length cs\n\ngoal (1 subgoal):\n 1. infs (cs ! k) w", "by auto"], ["proof (state)\nthis:\n  infs (cs ! k) w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "have 2: \"{a. (cs ! k) a} \\<inter> sset w \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. (cs ! k) a} \\<inter> sset w \\<noteq> {}", "using infs_any 1"], ["proof (prove)\nusing this:\n  infs ?P ?w \\<Longrightarrow> Bex (sset ?w) ?P\n  infs (cs ! k) w\n\ngoal (1 subgoal):\n 1. {a. (cs ! k) a} \\<inter> sset w \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {a. (cs ! k) a} \\<inter> sset w \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain u a v where 3: \"w = u @- a ## v\" \"{a. (cs ! k) a} \\<inter> set u = {}\" \"a \\<in> {a. (cs ! k) a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; {a. (cs ! k) a} \\<inter> set u = {};\n         a \\<in> {a. (cs ! k) a}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_stream_first 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<inter> sset ?xs \\<noteq> {};\n   \\<And>ys a zs.\n      \\<lbrakk>?xs = ys @- a ## zs; ?A \\<inter> set ys = {};\n       a \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  {a. (cs ! k) a} \\<inter> sset w \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; {a. (cs ! k) a} \\<inter> set u = {};\n         a \\<in> {a. (cs ! k) a}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  w = u @- a ## v\n  {a. (cs ! k) a} \\<inter> set u = {}\n  a \\<in> {a. (cs ! k) a}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "have 4: \"fold (count cs) u k = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (count cs) u k = k", "using count_constant_1 True 3(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k < length ?cs;\n   \\<And>a. a \\<in> set ?w \\<Longrightarrow> \\<not> (?cs ! ?k) a\\<rbrakk>\n  \\<Longrightarrow> fold (count ?cs) ?w ?k = ?k\n  k < length cs\n  {a. (cs ! k) a} \\<inter> set u = {}\n\ngoal (1 subgoal):\n 1. fold (count cs) u k = k", "by auto"], ["proof (state)\nthis:\n  fold (count cs) u k = k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using 3(1, 3) 4 that"], ["proof (prove)\nusing this:\n  w = u @- a ## v\n  a \\<in> {a. (cs ! k) a}\n  fold (count cs) u k = k\n  \\<lbrakk>w = ?u @- ?a ## ?v; degen cs (?a, fold (count cs) ?u k)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> k < length cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u a v.\n                \\<lbrakk>w = u @- a ## v;\n                 degen cs (a, fold (count cs) u k)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> k < length cs\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. w = ?u @- ?a ## ?v\n 2. degen cs (?a, fold (count cs) ?u k)", "show \"w = [] @- shd w ## stl w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = [] @- shd w ## stl w", "by simp"], ["proof (state)\nthis:\n  w = [] @- shd w ## stl w\n\ngoal (1 subgoal):\n 1. degen cs (shd w, fold (count cs) [] k)", "show \"degen cs (shd w, fold (count cs) [] k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degen cs (shd w, fold (count cs) [] k)", "using False"], ["proof (prove)\nusing this:\n  \\<not> k < length cs\n\ngoal (1 subgoal):\n 1. degen cs (shd w, fold (count cs) [] k)", "by simp"], ["proof (state)\nthis:\n  degen cs (shd w, fold (count cs) [] k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_infs[iff]: \"infs (degen cs) (w ||| k ## sscan (count cs) w k) \\<longleftrightarrow> gen infs cs w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (degen cs) (w ||| k ## sscan (count cs) w k) = gen infs cs w", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. infs (degen cs) (w ||| k ## sscan (count cs) w k) \\<Longrightarrow>\n    gen infs cs w\n 2. gen infs cs w \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "show \"gen infs cs w\" if \"infs (degen cs) (w ||| k ## sscan (count cs) w k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen infs cs w", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> set cs \\<Longrightarrow> infs c w", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> set cs \\<Longrightarrow> infs c w", "assume 1: \"c \\<in> set cs\""], ["proof (state)\nthis:\n  c \\<in> set cs\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> set cs \\<Longrightarrow> infs c w", "obtain l where 2: \"c = cs ! l\" \"l < length cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>c = cs ! l; l < length cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_set_conv_nth 1"], ["proof (prove)\nusing this:\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n  c \\<in> set cs\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>c = cs ! l; l < length cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  c = cs ! l\n  l < length cs\n\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> set cs \\<Longrightarrow> infs c w", "show \"infs c w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs c w", "using that"], ["proof (prove)\nusing this:\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. infs c w", "unfolding 2(1)"], ["proof (prove)\nusing this:\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. infs (cs ! l) w", "proof (coinduction arbitrary: w k rule: infs_coinduct_shift)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       infs (degen cs) (wa ||| k ## sscan (count cs) wa k) \\<Longrightarrow>\n       \\<exists>u v.\n          wa = u @- v \\<and>\n          Bex (set u) (cs ! l) \\<and>\n          (\\<exists>w k.\n              v = w \\<and>\n              infs (degen cs) (w ||| k ## sscan (count cs) w k))", "case (infs w k)"], ["proof (state)\nthis:\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       infs (degen cs) (wa ||| k ## sscan (count cs) wa k) \\<Longrightarrow>\n       \\<exists>u v.\n          wa = u @- v \\<and>\n          Bex (set u) (cs ! l) \\<and>\n          (\\<exists>w k.\n              v = w \\<and>\n              infs (degen cs) (w ||| k ## sscan (count cs) w k))", "obtain u a v where 3: \"w = u @- a ## v\" \"(cs ! l) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using degen_skip_arbitrary_condition 2(2) infs"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l < length ?cs;\n   infs (degen ?cs) (?w ||| ?k ## sscan (count ?cs) ?w ?k);\n   \\<And>u a v.\n      \\<lbrakk>?w = u @- a ## v; fold (count ?cs) u ?k = ?l;\n       (?cs ! ?l) a\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  l < length cs\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; (cs ! l) a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  w = u @- a ## v\n  (cs ! l) a\n\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       infs (degen cs) (wa ||| k ## sscan (count cs) wa k) \\<Longrightarrow>\n       \\<exists>u v.\n          wa = u @- v \\<and>\n          Bex (set u) (cs ! l) \\<and>\n          (\\<exists>w k.\n              v = w \\<and>\n              infs (degen cs) (w ||| k ## sscan (count cs) w k))", "let ?k = \"fold (count cs) u k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       infs (degen cs) (wa ||| k ## sscan (count cs) wa k) \\<Longrightarrow>\n       \\<exists>u v.\n          wa = u @- v \\<and>\n          Bex (set u) (cs ! l) \\<and>\n          (\\<exists>w k.\n              v = w \\<and>\n              infs (degen cs) (w ||| k ## sscan (count cs) w k))", "let ?l = \"fold (count cs) (u @ [a]) k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       infs (degen cs) (wa ||| k ## sscan (count cs) wa k) \\<Longrightarrow>\n       \\<exists>u v.\n          wa = u @- v \\<and>\n          Bex (set u) (cs ! l) \\<and>\n          (\\<exists>w k.\n              v = w \\<and>\n              infs (degen cs) (w ||| k ## sscan (count cs) w k))", "have 4: \"a ## v ||| ?k ## sscan (count cs) (a ## v) ?k =\n          sdrop (length u) (w ||| k ## sscan (count cs) w k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ## v |||\n    fold (count cs) u k ## sscan (count cs) (a ## v) (fold (count cs) u k) =\n    sdrop (length u) (w ||| k ## sscan (count cs) w k)", "using 3(1) eq_shift scons_eq"], ["proof (prove)\nusing this:\n  w = u @- a ## v\n  (?w = ?u @- ?v) =\n  (stake (length ?u) ?w = ?u \\<and> sdrop (length ?u) ?w = ?v)\n  (?a ## ?v = ?w) = (shd ?w = ?a \\<and> stl ?w = ?v)\n\ngoal (1 subgoal):\n 1. a ## v |||\n    fold (count cs) u k ## sscan (count cs) (a ## v) (fold (count cs) u k) =\n    sdrop (length u) (w ||| k ## sscan (count cs) w k)", "by (metis sdrop_simps(1) sdrop_stl sdrop_szip sscan_scons_snth sscan_sdrop stream.sel(2))"], ["proof (state)\nthis:\n  a ## v |||\n  fold (count cs) u k ## sscan (count cs) (a ## v) (fold (count cs) u k) =\n  sdrop (length u) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       infs (degen cs) (wa ||| k ## sscan (count cs) wa k) \\<Longrightarrow>\n       \\<exists>u v.\n          wa = u @- v \\<and>\n          Bex (set u) (cs ! l) \\<and>\n          (\\<exists>w k.\n              v = w \\<and>\n              infs (degen cs) (w ||| k ## sscan (count cs) w k))", "have 5: \"infs (degen cs) (a ## v ||| ?k ## sscan (count cs) (a ## v) ?k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (degen cs)\n     (a ## v |||\n      fold (count cs) u k ##\n      sscan (count cs) (a ## v) (fold (count cs) u k))", "using infs"], ["proof (prove)\nusing this:\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. infs (degen cs)\n     (a ## v |||\n      fold (count cs) u k ##\n      sscan (count cs) (a ## v) (fold (count cs) u k))", "unfolding 4"], ["proof (prove)\nusing this:\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal (1 subgoal):\n 1. infs (degen cs) (sdrop (length u) (w ||| k ## sscan (count cs) w k))", "by blast"], ["proof (state)\nthis:\n  infs (degen cs)\n   (a ## v |||\n    fold (count cs) u k ## sscan (count cs) (a ## v) (fold (count cs) u k))\n\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       infs (degen cs) (wa ||| k ## sscan (count cs) wa k) \\<Longrightarrow>\n       \\<exists>u v.\n          wa = u @- v \\<and>\n          Bex (set u) (cs ! l) \\<and>\n          (\\<exists>w k.\n              v = w \\<and>\n              infs (degen cs) (w ||| k ## sscan (count cs) w k))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       w = u @- v \\<and>\n       Bex (set u) (cs ! l) \\<and>\n       (\\<exists>w k.\n           v = w \\<and> infs (degen cs) (w ||| k ## sscan (count cs) w k))", "proof (intro exI conjI bexI)"], ["proof (state)\ngoal (5 subgoals):\n 1. w = ?u @- ?v1\n 2. (cs ! l) ?x7\n 3. ?x7 \\<in> set ?u\n 4. ?v1 = ?w4\n 5. infs (degen cs) (?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5)", "show \"w = (u @ [a]) @- v\" \"(cs ! l) a\" \"a \\<in> set (u @ [a])\" \"v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w = (u @ [a]) @- v &&& (cs ! l) a) &&& a \\<in> set (u @ [a]) &&& v = v", "using 3"], ["proof (prove)\nusing this:\n  w = u @- a ## v\n  (cs ! l) a\n\ngoal (1 subgoal):\n 1. (w = (u @ [a]) @- v &&& (cs ! l) a) &&& a \\<in> set (u @ [a]) &&& v = v", "by auto"], ["proof (state)\nthis:\n  w = (u @ [a]) @- v\n  (cs ! l) a\n  a \\<in> set (u @ [a])\n  v = v\n\ngoal (1 subgoal):\n 1. infs (degen cs) (v ||| ?k5 ## sscan (count cs) v ?k5)", "show \"infs (degen cs) (v ||| ?l ## sscan (count cs) v ?l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (degen cs)\n     (v |||\n      fold (count cs) (u @ [a]) k ##\n      sscan (count cs) v (fold (count cs) (u @ [a]) k))", "using 5"], ["proof (prove)\nusing this:\n  infs (degen cs)\n   (a ## v |||\n    fold (count cs) u k ## sscan (count cs) (a ## v) (fold (count cs) u k))\n\ngoal (1 subgoal):\n 1. infs (degen cs)\n     (v |||\n      fold (count cs) (u @ [a]) k ##\n      sscan (count cs) v (fold (count cs) (u @ [a]) k))", "by simp"], ["proof (state)\nthis:\n  infs (degen cs)\n   (v |||\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u v.\n     w = u @- v \\<and>\n     Bex (set u) (cs ! l) \\<and>\n     (\\<exists>w k.\n         v = w \\<and> infs (degen cs) (w ||| k ## sscan (count cs) w k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infs c w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infs (degen cs) (w ||| k ## sscan (count cs) w k) \\<Longrightarrow>\n  gen infs cs w\n\ngoal (1 subgoal):\n 1. gen infs cs w \\<Longrightarrow>\n    infs (degen cs) (w ||| k ## sscan (count cs) w k)", "show \"infs (degen cs) (w ||| k ## sscan (count cs) w k)\" if \"gen infs cs w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (degen cs) (w ||| k ## sscan (count cs) w k)", "using that"], ["proof (prove)\nusing this:\n  gen infs cs w\n\ngoal (1 subgoal):\n 1. infs (degen cs) (w ||| k ## sscan (count cs) w k)", "proof (coinduction arbitrary: w k rule: infs_coinduct_shift)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       gen infs cs wa \\<Longrightarrow>\n       \\<exists>u v.\n          wa ||| k ## sscan (count cs) wa k = u @- v \\<and>\n          Bex (set u) (degen cs) \\<and>\n          (\\<exists>w k.\n              v = w ||| k ## sscan (count cs) w k \\<and> gen infs cs w)", "case (infs w k)"], ["proof (state)\nthis:\n  gen infs cs w\n\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       gen infs cs wa \\<Longrightarrow>\n       \\<exists>u v.\n          wa ||| k ## sscan (count cs) wa k = u @- v \\<and>\n          Bex (set u) (degen cs) \\<and>\n          (\\<exists>w k.\n              v = w ||| k ## sscan (count cs) w k \\<and> gen infs cs w)", "obtain u a v where 1: \"w = u @- a ## v\" \"degen cs (a, fold (count cs) u k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; degen cs (a, fold (count cs) u k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gen_degen_step infs"], ["proof (prove)\nusing this:\n  \\<lbrakk>gen infs ?cs ?w;\n   \\<And>u a v.\n      \\<lbrakk>?w = u @- a ## v;\n       degen ?cs (a, fold (count ?cs) u ?k)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  gen infs cs w\n\ngoal (1 subgoal):\n 1. (\\<And>u a v.\n        \\<lbrakk>w = u @- a ## v; degen cs (a, fold (count cs) u k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by this"], ["proof (state)\nthis:\n  w = u @- a ## v\n  degen cs (a, fold (count cs) u k)\n\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       gen infs cs wa \\<Longrightarrow>\n       \\<exists>u v.\n          wa ||| k ## sscan (count cs) wa k = u @- v \\<and>\n          Bex (set u) (degen cs) \\<and>\n          (\\<exists>w k.\n              v = w ||| k ## sscan (count cs) w k \\<and> gen infs cs w)", "let ?u = \"u @ [a] || k # scan (count cs) u k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       gen infs cs wa \\<Longrightarrow>\n       \\<exists>u v.\n          wa ||| k ## sscan (count cs) wa k = u @- v \\<and>\n          Bex (set u) (degen cs) \\<and>\n          (\\<exists>w k.\n              v = w ||| k ## sscan (count cs) w k \\<and> gen infs cs w)", "let ?l = \"fold (count cs) (u @ [a]) k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa k.\n       gen infs cs wa \\<Longrightarrow>\n       \\<exists>u v.\n          wa ||| k ## sscan (count cs) wa k = u @- v \\<and>\n          Bex (set u) (degen cs) \\<and>\n          (\\<exists>w k.\n              v = w ||| k ## sscan (count cs) w k \\<and> gen infs cs w)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       w ||| k ## sscan (count cs) w k = u @- v \\<and>\n       Bex (set u) (degen cs) \\<and>\n       (\\<exists>w k.\n           v = w ||| k ## sscan (count cs) w k \\<and> gen infs cs w)", "proof (intro exI conjI bexI)"], ["proof (state)\ngoal (5 subgoals):\n 1. w ||| k ## sscan (count cs) w k = ?u @- ?v1\n 2. degen cs ?x7\n 3. ?x7 \\<in> set ?u\n 4. ?v1 = ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 5. gen infs cs ?w4", "have \"w ||| k ## sscan (count cs) w k =\n          (u @ [a]) @- v ||| k ## scan (count cs) u k @- ?l ## sscan (count cs) v ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w ||| k ## sscan (count cs) w k =\n    (u @ [a]) @- v |||\n    k ##\n    scan (count cs) u k @-\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k)", "unfolding 1(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. u @- a ## v ||| k ## sscan (count cs) (u @- a ## v) k =\n    (u @ [a]) @- v |||\n    k ##\n    scan (count cs) u k @-\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k)", "by simp"], ["proof (state)\nthis:\n  w ||| k ## sscan (count cs) w k =\n  (u @ [a]) @- v |||\n  k ##\n  scan (count cs) u k @-\n  fold (count cs) (u @ [a]) k ##\n  sscan (count cs) v (fold (count cs) (u @ [a]) k)\n\ngoal (5 subgoals):\n 1. w ||| k ## sscan (count cs) w k = ?u @- ?v1\n 2. degen cs ?x7\n 3. ?x7 \\<in> set ?u\n 4. ?v1 = ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 5. gen infs cs ?w4", "also"], ["proof (state)\nthis:\n  w ||| k ## sscan (count cs) w k =\n  (u @ [a]) @- v |||\n  k ##\n  scan (count cs) u k @-\n  fold (count cs) (u @ [a]) k ##\n  sscan (count cs) v (fold (count cs) (u @ [a]) k)\n\ngoal (5 subgoals):\n 1. w ||| k ## sscan (count cs) w k = ?u @- ?v1\n 2. degen cs ?x7\n 3. ?x7 \\<in> set ?u\n 4. ?v1 = ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 5. gen infs cs ?w4", "have \"\\<dots> = ?u @- (v ||| ?l ## sscan (count cs) v ?l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u @ [a]) @- v |||\n    k ##\n    scan (count cs) u k @-\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n    (u @ [a] || k # scan (count cs) u k) @-\n    (v |||\n     fold (count cs) (u @ [a]) k ##\n     sscan (count cs) v (fold (count cs) (u @ [a]) k))", "by (metis length_Cons length_append_singleton scan_length shift.simps(2) szip_shift)"], ["proof (state)\nthis:\n  (u @ [a]) @- v |||\n  k ##\n  scan (count cs) u k @-\n  fold (count cs) (u @ [a]) k ##\n  sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n  (u @ [a] || k # scan (count cs) u k) @-\n  (v |||\n   fold (count cs) (u @ [a]) k ##\n   sscan (count cs) v (fold (count cs) (u @ [a]) k))\n\ngoal (5 subgoals):\n 1. w ||| k ## sscan (count cs) w k = ?u @- ?v1\n 2. degen cs ?x7\n 3. ?x7 \\<in> set ?u\n 4. ?v1 = ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 5. gen infs cs ?w4", "finally"], ["proof (chain)\npicking this:\n  w ||| k ## sscan (count cs) w k =\n  (u @ [a] || k # scan (count cs) u k) @-\n  (v |||\n   fold (count cs) (u @ [a]) k ##\n   sscan (count cs) v (fold (count cs) (u @ [a]) k))", "show \"w ||| k ## sscan (count cs) w k = ?u @- (v ||| ?l ## sscan (count cs) v ?l)\""], ["proof (prove)\nusing this:\n  w ||| k ## sscan (count cs) w k =\n  (u @ [a] || k # scan (count cs) u k) @-\n  (v |||\n   fold (count cs) (u @ [a]) k ##\n   sscan (count cs) v (fold (count cs) (u @ [a]) k))\n\ngoal (1 subgoal):\n 1. w ||| k ## sscan (count cs) w k =\n    (u @ [a] || k # scan (count cs) u k) @-\n    (v |||\n     fold (count cs) (u @ [a]) k ##\n     sscan (count cs) v (fold (count cs) (u @ [a]) k))", "by this"], ["proof (state)\nthis:\n  w ||| k ## sscan (count cs) w k =\n  (u @ [a] || k # scan (count cs) u k) @-\n  (v |||\n   fold (count cs) (u @ [a]) k ##\n   sscan (count cs) v (fold (count cs) (u @ [a]) k))\n\ngoal (4 subgoals):\n 1. degen cs ?x7\n 2. ?x7 \\<in> set (u @ [a] || k # scan (count cs) u k)\n 3. v |||\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n    ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 4. gen infs cs ?w4", "show \"degen cs (a, fold (count cs) u k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degen cs (a, fold (count cs) u k)", "using 1(2)"], ["proof (prove)\nusing this:\n  degen cs (a, fold (count cs) u k)\n\ngoal (1 subgoal):\n 1. degen cs (a, fold (count cs) u k)", "by this"], ["proof (state)\nthis:\n  degen cs (a, fold (count cs) u k)\n\ngoal (3 subgoals):\n 1. (a, fold (count cs) u k) \\<in> set (u @ [a] || k # scan (count cs) u k)\n 2. v |||\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n    ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 3. gen infs cs ?w4", "have \"(a, fold (count cs) u k) = (last (u @ [a]), last (k # scan (count cs) u k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, fold (count cs) u k) =\n    (last (u @ [a]), last (k # scan (count cs) u k))", "unfolding scan_last"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, fold (count cs) u k) = (last (u @ [a]), fold (count cs) u k)", "by simp"], ["proof (state)\nthis:\n  (a, fold (count cs) u k) =\n  (last (u @ [a]), last (k # scan (count cs) u k))\n\ngoal (3 subgoals):\n 1. (a, fold (count cs) u k) \\<in> set (u @ [a] || k # scan (count cs) u k)\n 2. v |||\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n    ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 3. gen infs cs ?w4", "also"], ["proof (state)\nthis:\n  (a, fold (count cs) u k) =\n  (last (u @ [a]), last (k # scan (count cs) u k))\n\ngoal (3 subgoals):\n 1. (a, fold (count cs) u k) \\<in> set (u @ [a] || k # scan (count cs) u k)\n 2. v |||\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n    ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 3. gen infs cs ?w4", "have \"\\<dots> = last ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (last (u @ [a]), last (k # scan (count cs) u k)) =\n    last (u @ [a] || k # scan (count cs) u k)", "by (simp add: zip_eq_Nil_iff)"], ["proof (state)\nthis:\n  (last (u @ [a]), last (k # scan (count cs) u k)) =\n  last (u @ [a] || k # scan (count cs) u k)\n\ngoal (3 subgoals):\n 1. (a, fold (count cs) u k) \\<in> set (u @ [a] || k # scan (count cs) u k)\n 2. v |||\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n    ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 3. gen infs cs ?w4", "also"], ["proof (state)\nthis:\n  (last (u @ [a]), last (k # scan (count cs) u k)) =\n  last (u @ [a] || k # scan (count cs) u k)\n\ngoal (3 subgoals):\n 1. (a, fold (count cs) u k) \\<in> set (u @ [a] || k # scan (count cs) u k)\n 2. v |||\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n    ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 3. gen infs cs ?w4", "have \"\\<dots> \\<in> set ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (u @ [a] || k # scan (count cs) u k)\n    \\<in> set (u @ [a] || k # scan (count cs) u k)", "by (fastforce intro: last_in_set simp: zip_eq_Nil_iff)"], ["proof (state)\nthis:\n  last (u @ [a] || k # scan (count cs) u k)\n  \\<in> set (u @ [a] || k # scan (count cs) u k)\n\ngoal (3 subgoals):\n 1. (a, fold (count cs) u k) \\<in> set (u @ [a] || k # scan (count cs) u k)\n 2. v |||\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n    ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 3. gen infs cs ?w4", "finally"], ["proof (chain)\npicking this:\n  (a, fold (count cs) u k) \\<in> set (u @ [a] || k # scan (count cs) u k)", "show \"(a, fold (count cs) u k) \\<in> set ?u\""], ["proof (prove)\nusing this:\n  (a, fold (count cs) u k) \\<in> set (u @ [a] || k # scan (count cs) u k)\n\ngoal (1 subgoal):\n 1. (a, fold (count cs) u k) \\<in> set (u @ [a] || k # scan (count cs) u k)", "by this"], ["proof (state)\nthis:\n  (a, fold (count cs) u k) \\<in> set (u @ [a] || k # scan (count cs) u k)\n\ngoal (2 subgoals):\n 1. v |||\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n    ?w4 ||| ?k5 ## sscan (count cs) ?w4 ?k5\n 2. gen infs cs ?w4", "show \"v ||| ?l ## sscan (count cs) v ?l = v ||| ?l ## sscan (count cs) v ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v |||\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n    v |||\n    fold (count cs) (u @ [a]) k ##\n    sscan (count cs) v (fold (count cs) (u @ [a]) k)", "by rule"], ["proof (state)\nthis:\n  v |||\n  fold (count cs) (u @ [a]) k ##\n  sscan (count cs) v (fold (count cs) (u @ [a]) k) =\n  v |||\n  fold (count cs) (u @ [a]) k ##\n  sscan (count cs) v (fold (count cs) (u @ [a]) k)\n\ngoal (1 subgoal):\n 1. gen infs cs v", "show \"gen infs cs v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen infs cs v", "using infs"], ["proof (prove)\nusing this:\n  gen infs cs w\n\ngoal (1 subgoal):\n 1. gen infs cs v", "unfolding 1(1)"], ["proof (prove)\nusing this:\n  gen infs cs (u @- a ## v)\n\ngoal (1 subgoal):\n 1. gen infs cs v", "by auto"], ["proof (state)\nthis:\n  gen infs cs v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u v.\n     w ||| k ## sscan (count cs) w k = u @- v \\<and>\n     Bex (set u) (degen cs) \\<and>\n     (\\<exists>w k.\n         v = w ||| k ## sscan (count cs) w k \\<and> gen infs cs w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gen infs cs w \\<Longrightarrow>\n  infs (degen cs) (w ||| k ## sscan (count cs) w k)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}