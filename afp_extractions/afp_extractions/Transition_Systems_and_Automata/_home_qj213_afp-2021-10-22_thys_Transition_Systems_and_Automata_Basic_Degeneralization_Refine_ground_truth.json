{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Basic/Degeneralization_Refine.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemma degen_param[param]: \"(degen, degen) \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow> S \\<times>\\<^sub>r nat_rel \\<rightarrow> bool_rel\"", "lemma count_param[param]: \"(Degeneralization.count, Degeneralization.count) \\<in>\n    \\<langle>A \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow> A \\<rightarrow> nat_rel \\<rightarrow> nat_rel\""], "translations": [["", "lemma degen_param[param]: \"(degen, degen) \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow> S \\<times>\\<^sub>r nat_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (degen, degen)\n    \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          S \\<times>\\<^sub>r nat_rel \\<rightarrow> bool_rel", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a')\n                \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel;\n        (aa, a'a) \\<in> S \\<times>\\<^sub>r nat_rel\\<rbrakk>\n       \\<Longrightarrow> (degen a aa, degen a' a'a) \\<in> bool_rel", "fix cs ds ak bl"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a')\n                \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel;\n        (aa, a'a) \\<in> S \\<times>\\<^sub>r nat_rel\\<rbrakk>\n       \\<Longrightarrow> (degen a aa, degen a' a'a) \\<in> bool_rel", "assume \"(cs, ds) \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle> list_rel\" \"(ak, bl) \\<in>  S \\<times>\\<^sub>r nat_rel\""], ["proof (state)\nthis:\n  (cs, ds) \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel\n  (ak, bl) \\<in> S \\<times>\\<^sub>r nat_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a')\n                \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel;\n        (aa, a'a) \\<in> S \\<times>\\<^sub>r nat_rel\\<rbrakk>\n       \\<Longrightarrow> (degen a aa, degen a' a'a) \\<in> bool_rel", "then"], ["proof (chain)\npicking this:\n  (cs, ds) \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel\n  (ak, bl) \\<in> S \\<times>\\<^sub>r nat_rel", "show \"(degen cs ak, degen ds bl) \\<in> bool_rel\""], ["proof (prove)\nusing this:\n  (cs, ds) \\<in> \\<langle>S \\<rightarrow> bool_rel\\<rangle>list_rel\n  (ak, bl) \\<in> S \\<times>\\<^sub>r nat_rel\n\ngoal (1 subgoal):\n 1. (degen cs ak, degen ds bl) \\<in> bool_rel", "unfolding degen_def list_rel_def fun_rel_def list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  (cs, ds)\n  \\<in> {(l, l').\n         length l = length l' \\<and>\n         (\\<forall>i<length l.\n             (l ! i, l' ! i)\n             \\<in> {(f, f').\n                    \\<forall>(a, a')\\<in>S. (f a, f' a') \\<in> bool_rel})}\n  (ak, bl) \\<in> S \\<times>\\<^sub>r nat_rel\n\ngoal (1 subgoal):\n 1. (case ak of (a, k) \\<Rightarrow> length cs \\<le> k \\<or> (cs ! k) a,\n     case bl of (a, k) \\<Rightarrow> length ds \\<le> k \\<or> (ds ! k) a)\n    \\<in> bool_rel", "by (cases \"snd ak < length cs\") (auto 0 3)"], ["proof (state)\nthis:\n  (degen cs ak, degen ds bl) \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_param[param]: \"(Degeneralization.count, Degeneralization.count) \\<in>\n    \\<langle>A \\<rightarrow> bool_rel\\<rangle> list_rel \\<rightarrow> A \\<rightarrow> nat_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Degeneralization.count, Degeneralization.count)\n    \\<in> \\<langle>A \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          A \\<rightarrow> nat_rel \\<rightarrow> nat_rel", "unfolding count_def null_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>cs a k.\n        if k < length cs then if (cs ! k) a then Suc k mod length cs else k\n        else if List.null cs then k else 0,\n     \\<lambda>cs a k.\n        if k < length cs then if (cs ! k) a then Suc k mod length cs else k\n        else if List.null cs then k else 0)\n    \\<in> \\<langle>A \\<rightarrow> bool_rel\\<rangle>list_rel \\<rightarrow>\n          A \\<rightarrow> nat_rel \\<rightarrow> nat_rel", "by parametricity"], ["", "end"]]}