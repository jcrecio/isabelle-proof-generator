{"file_name": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata/Basic/Sequence_LTL.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transition_Systems_and_Automata", "problem_names": ["lemmas [simp del] = holds.simps holds_eq1 holds_eq2 not_holds_eq", "lemma ev_smap[iff]: \"ev P (smap f w) \\<longleftrightarrow> ev (P \\<circ> smap f) w\"", "lemma alw_smap[iff]: \"alw P (smap f w) \\<longleftrightarrow> alw (P \\<circ> smap f) w\"", "lemma holds_smap[iff]: \"holds P (smap f w) \\<longleftrightarrow> holds (P \\<circ> f) w\"", "lemmas [iff] = ev_sconst alw_sconst hld_smap'", "lemmas [iff] = alw_ev_stl", "lemma alw_ev_sdrop[iff]: \"alw (ev P) (sdrop n w) \\<longleftrightarrow> alw (ev P) w\"", "lemma alw_ev_scons[iff]: \"alw (ev P) (a ## w) \\<longleftrightarrow> alw (ev P) w\"", "lemma alw_ev_shift[iff]: \"alw (ev P) (u @- v) \\<longleftrightarrow> alw (ev P) v\"", "lemmas [simp del, iff] = ev_alw_stl", "lemma ev_alw_sdrop[iff]: \"ev (alw P) (sdrop n w) \\<longleftrightarrow> ev (alw P) w\"", "lemma ev_alw_scons[iff]: \"ev (alw P) (a ## w) \\<longleftrightarrow> ev (alw P) w\"", "lemma ev_alw_shift[iff]: \"ev (alw P) (u @- v) \\<longleftrightarrow> ev (alw P) v\"", "lemma holds_sconst[iff]: \"holds P (sconst a) \\<longleftrightarrow> P a\"", "lemma HLD_sconst[iff]: \"HLD A (sconst a) \\<longleftrightarrow> a \\<in> A\"", "lemma ev_alt_def: \"ev \\<phi> w \\<longleftrightarrow> (\\<exists> u v. w = u @- v \\<and> \\<phi> v)\"", "lemma ev_stl_alt_def: \"ev \\<phi> (stl w) \\<longleftrightarrow> (\\<exists> u v. w = u @- v \\<and> u \\<noteq> [] \\<and> \\<phi> v)\"", "lemma ev_HLD_sset: \"ev (HLD A) w \\<longleftrightarrow> sset w \\<inter> A \\<noteq> {}\"", "lemma alw_ev_coinduct[case_names alw_ev, consumes 1]:\n    assumes \"R w\"\n    assumes \"\\<And> w. R w \\<Longrightarrow> ev \\<phi> w \\<and> ev R (stl w)\"\n    shows \"alw (ev \\<phi>) w\"", "lemma infs_suffix: \"infs P w \\<longleftrightarrow> (\\<forall> u v. w = u @- v \\<longrightarrow> Bex (sset v) P)\"", "lemma infs_snth: \"infs P w \\<longleftrightarrow> (\\<forall> n. \\<exists> k \\<ge> n. P (w !! k))\"", "lemma infs_infm: \"infs P w \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P (w !! i))\"", "lemma infs_coinduct[case_names infs, coinduct pred: infs]:\n    assumes \"R w\"\n    assumes \"\\<And> w. R w \\<Longrightarrow> Bex (sset w) P \\<and> ev R (stl w)\"\n    shows \"infs P w\"", "lemma infs_coinduct_shift[case_names infs, consumes 1]:\n    assumes \"R w\"\n    assumes \"\\<And> w. R w \\<Longrightarrow> \\<exists> u v. w = u @- v \\<and> Bex (set u) P \\<and> R v\"\n    shows \"infs P w\"", "lemma infs_flat_coinduct[case_names infs_flat, consumes 1]:\n    assumes \"R w\"\n    assumes \"\\<And> u v. R (u ## v) \\<Longrightarrow> Bex (set u) P \\<and> R v\"\n    shows \"infs P (flat w)\"", "lemma infs_sscan_coinduct[case_names infs_sscan, consumes 1]:\n    assumes \"R w a\"\n    assumes \"\\<And> w a. R w a \\<Longrightarrow> P a \\<and> (\\<exists> u v. w = u @- v \\<and> u \\<noteq> [] \\<and> R v (fold f u a))\"\n    shows \"infs P (a ## sscan f w a)\"", "lemma infs_mono: \"(\\<And> a. a \\<in> sset w \\<Longrightarrow> P a \\<Longrightarrow> Q a) \\<Longrightarrow> infs P w \\<Longrightarrow> infs Q w\"", "lemma infs_mono_strong: \"stream_all2 (\\<lambda> a b. P a \\<longrightarrow> Q b) u v \\<Longrightarrow> infs P u \\<Longrightarrow> infs Q v\"", "lemma infs_all: \"Ball (sset w) P \\<Longrightarrow> infs P w\"", "lemma infs_any: \"infs P w \\<Longrightarrow> Bex (sset w) P\"", "lemma infs_bot[iff]: \"infs bot w \\<longleftrightarrow> False\"", "lemma infs_top[iff]: \"infs top w \\<longleftrightarrow> True\"", "lemma infs_disj[iff]: \"infs (\\<lambda> a. P a \\<or> Q a) w \\<longleftrightarrow> infs P w \\<or> infs Q w\"", "lemma infs_bex[iff]:\n    assumes \"finite S\"\n    shows \"infs (\\<lambda> a. \\<exists> x \\<in> S. P x a) w \\<longleftrightarrow> (\\<exists> x \\<in> S. infs (P x) w)\"", "lemma infs_bex_le_nat[iff]: \"infs (\\<lambda> a. \\<exists> k < n :: nat. P k a) w \\<longleftrightarrow> (\\<exists> k < n. infs (P k) w)\"", "lemma infs_cycle[iff]:\n    assumes \"w \\<noteq> []\"\n    shows \"infs P (cycle w) \\<longleftrightarrow> Bex (set w) P\""], "translations": [["", "lemmas [simp del] = holds.simps holds_eq1 holds_eq2 not_holds_eq"], ["", "(* TODO: these cannot be applied successively to simplify infs due to introduction of \\<circ>\n    avoid or add extra simplification rules for infs *)"], ["", "lemma ev_smap[iff]: \"ev P (smap f w) \\<longleftrightarrow> ev (P \\<circ> smap f) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev P (smap f w) = ev (P \\<circ> smap f) w", "using ev_smap"], ["proof (prove)\nusing this:\n  ev ?P (smap ?f ?s) = ev (\\<lambda>x. ?P (smap ?f x)) ?s\n\ngoal (1 subgoal):\n 1. ev P (smap f w) = ev (P \\<circ> smap f) w", "unfolding comp_apply"], ["proof (prove)\nusing this:\n  ev ?P (smap ?f ?s) = ev (\\<lambda>x. ?P (smap ?f x)) ?s\n\ngoal (1 subgoal):\n 1. ev P (smap f w) = ev (\\<lambda>x. P (smap f x)) w", "by this"], ["", "lemma alw_smap[iff]: \"alw P (smap f w) \\<longleftrightarrow> alw (P \\<circ> smap f) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw P (smap f w) = alw (P \\<circ> smap f) w", "using alw_smap"], ["proof (prove)\nusing this:\n  alw ?P (smap ?f ?s) = alw (\\<lambda>x. ?P (smap ?f x)) ?s\n\ngoal (1 subgoal):\n 1. alw P (smap f w) = alw (P \\<circ> smap f) w", "unfolding comp_apply"], ["proof (prove)\nusing this:\n  alw ?P (smap ?f ?s) = alw (\\<lambda>x. ?P (smap ?f x)) ?s\n\ngoal (1 subgoal):\n 1. alw P (smap f w) = alw (\\<lambda>x. P (smap f x)) w", "by this"], ["", "lemma holds_smap[iff]: \"holds P (smap f w) \\<longleftrightarrow> holds (P \\<circ> f) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. holds P (smap f w) = holds (P \\<circ> f) w", "unfolding holds.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (shd (smap f w)) = (P \\<circ> f) (shd w)", "by simp"], ["", "lemmas [iff] = ev_sconst alw_sconst hld_smap'"], ["", "lemmas [iff] = alw_ev_stl"], ["", "lemma alw_ev_sdrop[iff]: \"alw (ev P) (sdrop n w) \\<longleftrightarrow> alw (ev P) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (ev P) (sdrop n w) = alw (ev P) w", "using alw_ev_sdrop alw_sdrop"], ["proof (prove)\nusing this:\n  alw (ev ?\\<phi>) (sdrop ?m ?xs) \\<Longrightarrow> alw (ev ?\\<phi>) ?xs\n  alw ?\\<phi> ?xs \\<Longrightarrow> alw ?\\<phi> (sdrop ?n ?xs)\n\ngoal (1 subgoal):\n 1. alw (ev P) (sdrop n w) = alw (ev P) w", "by blast"], ["", "lemma alw_ev_scons[iff]: \"alw (ev P) (a ## w) \\<longleftrightarrow> alw (ev P) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (ev P) (a ## w) = alw (ev P) w", "by (metis alw_ev_stl stream.sel(2))"], ["", "lemma alw_ev_shift[iff]: \"alw (ev P) (u @- v) \\<longleftrightarrow> alw (ev P) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (ev P) (u @- v) = alw (ev P) v", "by (induct u) (auto)"], ["", "lemmas [simp del, iff] = ev_alw_stl"], ["", "lemma ev_alw_sdrop[iff]: \"ev (alw P) (sdrop n w) \\<longleftrightarrow> ev (alw P) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (alw P) (sdrop n w) = ev (alw P) w", "using alwD alw_alw alw_sdrop ev_alw_imp_alw_ev not_ev_iff"], ["proof (prove)\nusing this:\n  alw ?P ?x \\<Longrightarrow> ?P ?x\n  alw (alw ?\\<phi>) = alw ?\\<phi>\n  alw ?\\<phi> ?xs \\<Longrightarrow> alw ?\\<phi> (sdrop ?n ?xs)\n  ev (alw ?\\<phi>) ?xs \\<Longrightarrow> alw (ev ?\\<phi>) ?xs\n  (\\<not> ev ?P ?\\<omega>) = alw (\\<lambda>xs. \\<not> ?P xs) ?\\<omega>\n\ngoal (1 subgoal):\n 1. ev (alw P) (sdrop n w) = ev (alw P) w", "by metis"], ["", "lemma ev_alw_scons[iff]: \"ev (alw P) (a ## w) \\<longleftrightarrow> ev (alw P) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (alw P) (a ## w) = ev (alw P) w", "by (metis ev_alw_stl stream.sel(2))"], ["", "lemma ev_alw_shift[iff]: \"ev (alw P) (u @- v) \\<longleftrightarrow> ev (alw P) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (alw P) (u @- v) = ev (alw P) v", "by (induct u) (auto)"], ["", "lemma holds_sconst[iff]: \"holds P (sconst a) \\<longleftrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. holds P (sconst a) = P a", "unfolding holds.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (shd (sconst a)) = P a", "by simp"], ["", "lemma HLD_sconst[iff]: \"HLD A (sconst a) \\<longleftrightarrow> a \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HLD A (sconst a) = (a \\<in> A)", "unfolding HLD_def holds.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (shd (sconst a) \\<in> A) = (a \\<in> A)", "by simp"], ["", "lemma ev_alt_def: \"ev \\<phi> w \\<longleftrightarrow> (\\<exists> u v. w = u @- v \\<and> \\<phi> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev \\<phi> w = (\\<exists>u v. w = u @- v \\<and> \\<phi> v)", "using ev.base ev_shift ev_imp_shift"], ["proof (prove)\nusing this:\n  ?\\<phi> ?xs \\<Longrightarrow> ev ?\\<phi> ?xs\n  ev ?\\<phi> ?xs \\<Longrightarrow> ev ?\\<phi> (?xl @- ?xs)\n  ev ?\\<phi> ?xs \\<Longrightarrow>\n  \\<exists>xl xs2. ?xs = xl @- xs2 \\<and> ?\\<phi> xs2\n\ngoal (1 subgoal):\n 1. ev \\<phi> w = (\\<exists>u v. w = u @- v \\<and> \\<phi> v)", "by metis"], ["", "lemma ev_stl_alt_def: \"ev \\<phi> (stl w) \\<longleftrightarrow> (\\<exists> u v. w = u @- v \\<and> u \\<noteq> [] \\<and> \\<phi> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev \\<phi> (stl w) =\n    (\\<exists>u v. w = u @- v \\<and> u \\<noteq> [] \\<and> \\<phi> v)", "unfolding ev_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u v. stl w = u @- v \\<and> \\<phi> v) =\n    (\\<exists>u v. w = u @- v \\<and> u \\<noteq> [] \\<and> \\<phi> v)", "by (cases w) (force simp: scons_eq)"], ["", "lemma ev_HLD_sset: \"ev (HLD A) w \\<longleftrightarrow> sset w \\<inter> A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (HLD A) w = (sset w \\<inter> A \\<noteq> {})", "unfolding HLD_def ev_holds_sset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x\\<in>sset w. x \\<in> A) = (sset w \\<inter> A \\<noteq> {})", "by auto"], ["", "lemma alw_ev_coinduct[case_names alw_ev, consumes 1]:\n    assumes \"R w\"\n    assumes \"\\<And> w. R w \\<Longrightarrow> ev \\<phi> w \\<and> ev R (stl w)\"\n    shows \"alw (ev \\<phi>) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (ev \\<phi>) w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alw (ev \\<phi>) w", "have \"ev R w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev R w", "using assms(1)"], ["proof (prove)\nusing this:\n  R w\n\ngoal (1 subgoal):\n 1. ev R w", "by rule"], ["proof (state)\nthis:\n  ev R w\n\ngoal (1 subgoal):\n 1. alw (ev \\<phi>) w", "then"], ["proof (chain)\npicking this:\n  ev R w", "show ?thesis"], ["proof (prove)\nusing this:\n  ev R w\n\ngoal (1 subgoal):\n 1. alw (ev \\<phi>) w", "using assms(2)"], ["proof (prove)\nusing this:\n  ev R w\n  R ?w \\<Longrightarrow> ev \\<phi> ?w \\<and> ev R (stl ?w)\n\ngoal (1 subgoal):\n 1. alw (ev \\<phi>) w", "by (coinduct) (metis alw_sdrop not_ev_iff sdrop_stl sdrop_wait)"], ["proof (state)\nthis:\n  alw (ev \\<phi>) w\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Infinite Occurrence\\<close>"], ["", "abbreviation \"infs P w \\<equiv> alw (ev (holds P)) w\""], ["", "abbreviation \"fins P w \\<equiv> \\<not> infs P w\""], ["", "lemma infs_suffix: \"infs P w \\<longleftrightarrow> (\\<forall> u v. w = u @- v \\<longrightarrow> Bex (sset v) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P w = (\\<forall>u v. w = u @- v \\<longrightarrow> Bex (sset v) P)", "using alwD alw_iff_sdrop alw_shift ev_holds_sset stake_sdrop"], ["proof (prove)\nusing this:\n  alw ?P ?x \\<Longrightarrow> ?P ?x\n  alw ?P ?\\<omega> = (\\<forall>m. ?P (sdrop m ?\\<omega>))\n  alw ?\\<phi> (?xl @- ?xs) \\<Longrightarrow> alw ?\\<phi> ?xs\n  ev (holds ?P) ?xs = (\\<exists>x\\<in>sset ?xs. ?P x)\n  stake ?n ?s @- sdrop ?n ?s = ?s\n\ngoal (1 subgoal):\n 1. infs P w = (\\<forall>u v. w = u @- v \\<longrightarrow> Bex (sset v) P)", "by (metis (mono_tags, hide_lams))"], ["", "lemma infs_snth: \"infs P w \\<longleftrightarrow> (\\<forall> n. \\<exists> k \\<ge> n. P (w !! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P w = (\\<forall>n. \\<exists>k\\<ge>n. P (w !! k))", "by (auto simp: alw_iff_sdrop ev_iff_sdrop holds.simps intro: le_add1 dest: le_Suc_ex)"], ["", "lemma infs_infm: \"infs P w \\<longleftrightarrow> (\\<exists>\\<^sub>\\<infinity> i. P (w !! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P w = (\\<exists>\\<^sub>\\<infinity>i. P (w !! i))", "unfolding infs_snth INFM_nat_le"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n. \\<exists>k\\<ge>n. P (w !! k)) =\n    (\\<forall>m. \\<exists>n\\<ge>m. P (w !! n))", "by rule"], ["", "lemma infs_coinduct[case_names infs, coinduct pred: infs]:\n    assumes \"R w\"\n    assumes \"\\<And> w. R w \\<Longrightarrow> Bex (sset w) P \\<and> ev R (stl w)\"\n    shows \"infs P w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P w", "using assms"], ["proof (prove)\nusing this:\n  R w\n  R ?w \\<Longrightarrow> Bex (sset ?w) P \\<and> ev R (stl ?w)\n\ngoal (1 subgoal):\n 1. infs P w", "by (coinduct rule: alw_ev_coinduct) (auto simp: ev_holds_sset)"], ["", "lemma infs_coinduct_shift[case_names infs, consumes 1]:\n    assumes \"R w\"\n    assumes \"\\<And> w. R w \\<Longrightarrow> \\<exists> u v. w = u @- v \\<and> Bex (set u) P \\<and> R v\"\n    shows \"infs P w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P w", "using assms"], ["proof (prove)\nusing this:\n  R w\n  R ?w \\<Longrightarrow>\n  \\<exists>u v. ?w = u @- v \\<and> Bex (set u) P \\<and> R v\n\ngoal (1 subgoal):\n 1. infs P w", "by (coinduct) (force simp: ev_stl_alt_def)"], ["", "lemma infs_flat_coinduct[case_names infs_flat, consumes 1]:\n    assumes \"R w\"\n    assumes \"\\<And> u v. R (u ## v) \\<Longrightarrow> Bex (set u) P \\<and> R v\"\n    shows \"infs P (flat w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P (flat w)", "using assms"], ["proof (prove)\nusing this:\n  R w\n  R (?u ## ?v) \\<Longrightarrow> Bex (set ?u) P \\<and> R ?v\n\ngoal (1 subgoal):\n 1. infs P (flat w)", "by (coinduction arbitrary: w rule: infs_coinduct_shift)\n      (metis empty_iff flat_Stream list.set(1) stream.exhaust)"], ["", "lemma infs_sscan_coinduct[case_names infs_sscan, consumes 1]:\n    assumes \"R w a\"\n    assumes \"\\<And> w a. R w a \\<Longrightarrow> P a \\<and> (\\<exists> u v. w = u @- v \\<and> u \\<noteq> [] \\<and> R v (fold f u a))\"\n    shows \"infs P (a ## sscan f w a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P (a ## sscan f w a)", "using assms(1)"], ["proof (prove)\nusing this:\n  R w a\n\ngoal (1 subgoal):\n 1. infs P (a ## sscan f w a)", "proof (coinduction arbitrary: w a rule: infs_coinduct_shift)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa a.\n       R wa a \\<Longrightarrow>\n       \\<exists>u v.\n          a ## sscan f wa a = u @- v \\<and>\n          Bex (set u) P \\<and>\n          (\\<exists>w a. v = a ## sscan f w a \\<and> R w a)", "case (infs w a)"], ["proof (state)\nthis:\n  R w a\n\ngoal (1 subgoal):\n 1. \\<And>wa a.\n       R wa a \\<Longrightarrow>\n       \\<exists>u v.\n          a ## sscan f wa a = u @- v \\<and>\n          Bex (set u) P \\<and>\n          (\\<exists>w a. v = a ## sscan f w a \\<and> R w a)", "obtain u v where 1: \"P a\" \"w = u @- v\" \"u \\<noteq> []\" \"R v (fold f u a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>P a; w = u @- v; u \\<noteq> []; R v (fold f u a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using infs assms(2)"], ["proof (prove)\nusing this:\n  R w a\n  R ?w ?a \\<Longrightarrow>\n  P ?a \\<and>\n  (\\<exists>u v. ?w = u @- v \\<and> u \\<noteq> [] \\<and> R v (fold f u ?a))\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>P a; w = u @- v; u \\<noteq> []; R v (fold f u a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P a\n  w = u @- v\n  u \\<noteq> []\n  R v (fold f u a)\n\ngoal (1 subgoal):\n 1. \\<And>wa a.\n       R wa a \\<Longrightarrow>\n       \\<exists>u v.\n          a ## sscan f wa a = u @- v \\<and>\n          Bex (set u) P \\<and>\n          (\\<exists>w a. v = a ## sscan f w a \\<and> R w a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u v.\n       a ## sscan f w a = u @- v \\<and>\n       Bex (set u) P \\<and>\n       (\\<exists>w a. v = a ## sscan f w a \\<and> R w a)", "proof (intro exI conjI bexI)"], ["proof (state)\ngoal (5 subgoals):\n 1. a ## sscan f w a = ?u @- ?v1\n 2. P ?x7\n 3. ?x7 \\<in> set ?u\n 4. ?v1 = ?a5 ## sscan f ?w4 ?a5\n 5. R ?w4 ?a5", "have \"sscan f w a = scan f u a @- sscan f v (fold f u a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan f w a = scan f u a @- sscan f v (fold f u a)", "unfolding 1(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sscan f (u @- v) a = scan f u a @- sscan f v (fold f u a)", "by simp"], ["proof (state)\nthis:\n  sscan f w a = scan f u a @- sscan f v (fold f u a)\n\ngoal (5 subgoals):\n 1. a ## sscan f w a = ?u @- ?v1\n 2. P ?x7\n 3. ?x7 \\<in> set ?u\n 4. ?v1 = ?a5 ## sscan f ?w4 ?a5\n 5. R ?w4 ?a5", "also"], ["proof (state)\nthis:\n  sscan f w a = scan f u a @- sscan f v (fold f u a)\n\ngoal (5 subgoals):\n 1. a ## sscan f w a = ?u @- ?v1\n 2. P ?x7\n 3. ?x7 \\<in> set ?u\n 4. ?v1 = ?a5 ## sscan f ?w4 ?a5\n 5. R ?w4 ?a5", "have \"scan f u a = butlast (scan f u a) @ [fold f u a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scan f u a = butlast (scan f u a) @ [fold f u a]", "using 1(3)"], ["proof (prove)\nusing this:\n  u \\<noteq> []\n\ngoal (1 subgoal):\n 1. scan f u a = butlast (scan f u a) @ [fold f u a]", "by (metis last_ConsR scan_eq_nil scan_last snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  scan f u a = butlast (scan f u a) @ [fold f u a]\n\ngoal (5 subgoals):\n 1. a ## sscan f w a = ?u @- ?v1\n 2. P ?x7\n 3. ?x7 \\<in> set ?u\n 4. ?v1 = ?a5 ## sscan f ?w4 ?a5\n 5. R ?w4 ?a5", "also"], ["proof (state)\nthis:\n  scan f u a = butlast (scan f u a) @ [fold f u a]\n\ngoal (5 subgoals):\n 1. a ## sscan f w a = ?u @- ?v1\n 2. P ?x7\n 3. ?x7 \\<in> set ?u\n 4. ?v1 = ?a5 ## sscan f ?w4 ?a5\n 5. R ?w4 ?a5", "have \"a ## \\<dots> @- sscan f v (fold f u a) =\n        (a # butlast (scan f u a)) @- fold f u a ## sscan f v (fold f u a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ## (butlast (scan f u a) @ [fold f u a]) @- sscan f v (fold f u a) =\n    (a # butlast (scan f u a)) @- fold f u a ## sscan f v (fold f u a)", "by simp"], ["proof (state)\nthis:\n  a ## (butlast (scan f u a) @ [fold f u a]) @- sscan f v (fold f u a) =\n  (a # butlast (scan f u a)) @- fold f u a ## sscan f v (fold f u a)\n\ngoal (5 subgoals):\n 1. a ## sscan f w a = ?u @- ?v1\n 2. P ?x7\n 3. ?x7 \\<in> set ?u\n 4. ?v1 = ?a5 ## sscan f ?w4 ?a5\n 5. R ?w4 ?a5", "finally"], ["proof (chain)\npicking this:\n  a ## sscan f w a =\n  (a # butlast (scan f u a)) @- fold f u a ## sscan f v (fold f u a)", "show \"a ## sscan f w a = (a # butlast (scan f u a)) @- fold f u a ## sscan f v (fold f u a)\""], ["proof (prove)\nusing this:\n  a ## sscan f w a =\n  (a # butlast (scan f u a)) @- fold f u a ## sscan f v (fold f u a)\n\ngoal (1 subgoal):\n 1. a ## sscan f w a =\n    (a # butlast (scan f u a)) @- fold f u a ## sscan f v (fold f u a)", "by this"], ["proof (state)\nthis:\n  a ## sscan f w a =\n  (a # butlast (scan f u a)) @- fold f u a ## sscan f v (fold f u a)\n\ngoal (4 subgoals):\n 1. P ?x7\n 2. ?x7 \\<in> set (a # butlast (scan f u a))\n 3. fold f u a ## sscan f v (fold f u a) = ?a5 ## sscan f ?w4 ?a5\n 4. R ?w4 ?a5", "show \"P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a", "using 1(1)"], ["proof (prove)\nusing this:\n  P a\n\ngoal (1 subgoal):\n 1. P a", "by this"], ["proof (state)\nthis:\n  P a\n\ngoal (3 subgoals):\n 1. a \\<in> set (a # butlast (scan f u a))\n 2. fold f u a ## sscan f v (fold f u a) = ?a5 ## sscan f ?w4 ?a5\n 3. R ?w4 ?a5", "show \"a \\<in> set (a # butlast (scan f u a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (a # butlast (scan f u a))", "by simp"], ["proof (state)\nthis:\n  a \\<in> set (a # butlast (scan f u a))\n\ngoal (2 subgoals):\n 1. fold f u a ## sscan f v (fold f u a) = ?a5 ## sscan f ?w4 ?a5\n 2. R ?w4 ?a5", "show \"R v (fold f u a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R v (fold f u a)", "using 1(4)"], ["proof (prove)\nusing this:\n  R v (fold f u a)\n\ngoal (1 subgoal):\n 1. R v (fold f u a)", "by this"], ["proof (state)\nthis:\n  R v (fold f u a)\n\ngoal (1 subgoal):\n 1. fold f u a ## sscan f v (fold f u a) =\n    fold f u a ## sscan f v (fold f u a)", "qed rule"], ["proof (state)\nthis:\n  \\<exists>u v.\n     a ## sscan f w a = u @- v \\<and>\n     Bex (set u) P \\<and> (\\<exists>w a. v = a ## sscan f w a \\<and> R w a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infs_mono: \"(\\<And> a. a \\<in> sset w \\<Longrightarrow> P a \\<Longrightarrow> Q a) \\<Longrightarrow> infs P w \\<Longrightarrow> infs Q w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a.\n                \\<lbrakk>a \\<in> sset w; P a\\<rbrakk> \\<Longrightarrow> Q a;\n     infs P w\\<rbrakk>\n    \\<Longrightarrow> infs Q w", "unfolding infs_snth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a.\n                \\<lbrakk>a \\<in> sset w; P a\\<rbrakk> \\<Longrightarrow> Q a;\n     \\<forall>n. \\<exists>k\\<ge>n. P (w !! k)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<exists>k\\<ge>n. Q (w !! k)", "by force"], ["", "lemma infs_mono_strong: \"stream_all2 (\\<lambda> a b. P a \\<longrightarrow> Q b) u v \\<Longrightarrow> infs P u \\<Longrightarrow> infs Q v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stream_all2 (\\<lambda>a b. P a \\<longrightarrow> Q b) u v;\n     infs P u\\<rbrakk>\n    \\<Longrightarrow> infs Q v", "unfolding stream_rel_snth infs_snth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i. P (u !! i) \\<longrightarrow> Q (v !! i);\n     \\<forall>n. \\<exists>k\\<ge>n. P (u !! k)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<exists>k\\<ge>n. Q (v !! k)", "by blast"], ["", "lemma infs_all: \"Ball (sset w) P \\<Longrightarrow> infs P w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (sset w) P \\<Longrightarrow> infs P w", "unfolding infs_snth"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (sset w) P \\<Longrightarrow>\n    \\<forall>n. \\<exists>k\\<ge>n. P (w !! k)", "by auto"], ["", "lemma infs_any: \"infs P w \\<Longrightarrow> Bex (sset w) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P w \\<Longrightarrow> Bex (sset w) P", "unfolding ev_holds_sset"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>xs. Bex (sset xs) P) w \\<Longrightarrow> Bex (sset w) P", "by auto"], ["", "lemma infs_bot[iff]: \"infs bot w \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs bot w = False", "using infs_any"], ["proof (prove)\nusing this:\n  infs ?P ?w \\<Longrightarrow> Bex (sset ?w) ?P\n\ngoal (1 subgoal):\n 1. infs bot w = False", "by auto"], ["", "lemma infs_top[iff]: \"infs top w \\<longleftrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs top w = True", "by (simp add: infs_all)"], ["", "lemma infs_disj[iff]: \"infs (\\<lambda> a. P a \\<or> Q a) w \\<longleftrightarrow> infs P w \\<or> infs Q w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. P a \\<or> Q a) w = (infs P w \\<or> infs Q w)", "unfolding infs_snth"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n. \\<exists>k\\<ge>n. P (w !! k) \\<or> Q (w !! k)) =\n    ((\\<forall>n. \\<exists>k\\<ge>n. P (w !! k)) \\<or>\n     (\\<forall>n. \\<exists>k\\<ge>n. Q (w !! k)))", "using le_trans le_cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk> \\<Longrightarrow> ?i \\<le> ?k\n  \\<lbrakk>?x \\<le> ?y \\<Longrightarrow> ?P;\n   ?y \\<le> ?x \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<forall>n. \\<exists>k\\<ge>n. P (w !! k) \\<or> Q (w !! k)) =\n    ((\\<forall>n. \\<exists>k\\<ge>n. P (w !! k)) \\<or>\n     (\\<forall>n. \\<exists>k\\<ge>n. Q (w !! k)))", "by metis"], ["", "lemma infs_bex[iff]:\n    assumes \"finite S\"\n    shows \"infs (\\<lambda> a. \\<exists> x \\<in> S. P x a) w \\<longleftrightarrow> (\\<exists> x \\<in> S. infs (P x) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>x\\<in>S. P x a) w =\n    (\\<exists>x\\<in>S. infs (P x) w)", "using assms infs_any"], ["proof (prove)\nusing this:\n  finite S\n  infs ?P ?w \\<Longrightarrow> Bex (sset ?w) ?P\n\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>x\\<in>S. P x a) w =\n    (\\<exists>x\\<in>S. infs (P x) w)", "by induct auto"], ["", "lemma infs_bex_le_nat[iff]: \"infs (\\<lambda> a. \\<exists> k < n :: nat. P k a) w \\<longleftrightarrow> (\\<exists> k < n. infs (P k) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>k<n. P k a) w = (\\<exists>k<n. infs (P k) w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>k<n. P k a) w = (\\<exists>k<n. infs (P k) w)", "have \"infs (\\<lambda> a. \\<exists> k < n. P k a) w \\<longleftrightarrow> infs (\\<lambda> a. \\<exists> k \\<in> {k. k < n}. P k a) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>k<n. P k a) w =\n    infs (\\<lambda>a. \\<exists>k\\<in>{k. k < n}. P k a) w", "by simp"], ["proof (state)\nthis:\n  infs (\\<lambda>a. \\<exists>k<n. P k a) w =\n  infs (\\<lambda>a. \\<exists>k\\<in>{k. k < n}. P k a) w\n\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>k<n. P k a) w = (\\<exists>k<n. infs (P k) w)", "also"], ["proof (state)\nthis:\n  infs (\\<lambda>a. \\<exists>k<n. P k a) w =\n  infs (\\<lambda>a. \\<exists>k\\<in>{k. k < n}. P k a) w\n\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>k<n. P k a) w = (\\<exists>k<n. infs (P k) w)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists> k \\<in> {k. k < n}. infs (P k) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>k\\<in>{k. k < n}. P k a) w =\n    (\\<exists>k\\<in>{k. k < n}. infs (P k) w)", "by blast"], ["proof (state)\nthis:\n  infs (\\<lambda>a. \\<exists>k\\<in>{k. k < n}. P k a) w =\n  (\\<exists>k\\<in>{k. k < n}. infs (P k) w)\n\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>k<n. P k a) w = (\\<exists>k<n. infs (P k) w)", "also"], ["proof (state)\nthis:\n  infs (\\<lambda>a. \\<exists>k\\<in>{k. k < n}. P k a) w =\n  (\\<exists>k\\<in>{k. k < n}. infs (P k) w)\n\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>k<n. P k a) w = (\\<exists>k<n. infs (P k) w)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists> k < n. infs (P k) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>k\\<in>{k. k < n}. infs (P k) w) = (\\<exists>k<n. infs (P k) w)", "by simp"], ["proof (state)\nthis:\n  (\\<exists>k\\<in>{k. k < n}. infs (P k) w) = (\\<exists>k<n. infs (P k) w)\n\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>k<n. P k a) w = (\\<exists>k<n. infs (P k) w)", "finally"], ["proof (chain)\npicking this:\n  infs (\\<lambda>a. \\<exists>k<n. P k a) w = (\\<exists>k<n. infs (P k) w)", "show ?thesis"], ["proof (prove)\nusing this:\n  infs (\\<lambda>a. \\<exists>k<n. P k a) w = (\\<exists>k<n. infs (P k) w)\n\ngoal (1 subgoal):\n 1. infs (\\<lambda>a. \\<exists>k<n. P k a) w = (\\<exists>k<n. infs (P k) w)", "by this"], ["proof (state)\nthis:\n  infs (\\<lambda>a. \\<exists>k<n. P k a) w = (\\<exists>k<n. infs (P k) w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infs_cycle[iff]:\n    assumes \"w \\<noteq> []\"\n    shows \"infs P (cycle w) \\<longleftrightarrow> Bex (set w) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P (cycle w) = Bex (set w) P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. infs P (cycle w) \\<Longrightarrow> Bex (set w) P\n 2. Bex (set w) P \\<Longrightarrow> infs P (cycle w)", "show \"infs P (cycle w) \\<Longrightarrow> Bex (set w) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs P (cycle w) \\<Longrightarrow> Bex (set w) P", "using assms"], ["proof (prove)\nusing this:\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. infs P (cycle w) \\<Longrightarrow> Bex (set w) P", "by (auto simp: ev_holds_sset dest: alwD)"], ["proof (state)\nthis:\n  infs P (cycle w) \\<Longrightarrow> Bex (set w) P\n\ngoal (1 subgoal):\n 1. Bex (set w) P \\<Longrightarrow> infs P (cycle w)", "show \"Bex (set w) P \\<Longrightarrow> infs P (cycle w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex (set w) P \\<Longrightarrow> infs P (cycle w)", "using assms"], ["proof (prove)\nusing this:\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. Bex (set w) P \\<Longrightarrow> infs P (cycle w)", "by (coinduction rule: infs_coinduct_shift) (blast dest: cycle_decomp)"], ["proof (state)\nthis:\n  Bex (set w) P \\<Longrightarrow> infs P (cycle w)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}