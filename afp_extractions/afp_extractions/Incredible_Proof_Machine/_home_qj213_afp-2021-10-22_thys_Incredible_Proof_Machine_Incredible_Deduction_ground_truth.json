{"file_name": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine/Incredible_Deduction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine", "problem_names": ["lemma edge_begin_tup: \"edge_begin x = fst (fst x)\"", "lemma edge_end_tup: \"edge_end x = fst (snd x)\"", "lemma path_cons_simp: \"path v v' (e # pth) \\<longleftrightarrow> fst (fst e) = v \\<and> e \\<in> edges \\<and> path (fst (snd e)) v' pth\"", "lemma path_appendI: \"path v v' pth1 \\<Longrightarrow> path v' v'' pth2 \\<Longrightarrow> path v v'' (pth1@pth2)\"", "lemma path_split: \"path v v' (pth1@[e]@pth2) \\<longleftrightarrow> path v (edge_end e) (pth1@[e]) \\<and> path (edge_end e) v' pth2\"", "lemma path_split2: \"path v v' (pth1@(e#pth2)) \\<longleftrightarrow> path v (edge_begin e) pth1 \\<and> path (edge_begin e) v' (e#pth2)\"", "lemma path_snoc: \"path v v' (pth1@[e]) \\<longleftrightarrow> e \\<in> edges \\<and> path v (edge_begin e) pth1 \\<and> edge_end e = v'\"", "lemma scope_find:\n    assumes \"v \\<in> scope ps\"\n    assumes \"terminal_vertex v'\"\n    assumes \"path v v' pth\"\n    shows \"ps \\<in> snd ` set pth\"", "lemma snd_set_split:\n    assumes \"ps \\<in> snd ` set pth\"\n    obtains pth1 pth2 e  where \"pth = pth1@[e]@pth2\" and \"snd e = ps\" and \"ps \\<notin> snd ` set pth1\"", "lemma scope_split:\n    assumes \"v \\<in> scope ps\"\n    assumes \"path v v' pth\"\n    assumes \"terminal_vertex v'\"\n    obtains pth1 e pth2\n    where \"pth = (pth1@[e])@pth2\" and \"path v (fst ps) (pth1@[e])\" and \"path (fst ps) v' pth2\" and \"snd e = ps\" and \"ps \\<notin> snd ` set pth1\"", "lemma snd_set_path_verties: \"path v v' pth \\<Longrightarrow> fst ` snd ` set pth \\<subseteq> fset vertices\"", "lemma fst_set_path_verties: \"path v v' pth \\<Longrightarrow> fst ` fst ` set pth \\<subseteq> fset vertices\"", "lemma scopes_not_refl:\n    assumes \"v |\\<in>| vertices\"\n    shows \"v \\<notin> scope (v,p)\"", "lemma scopes_nest:\n    fixes ps1 ps2\n    shows \"scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\"", "lemma hyps_free_Nil[simp]: \"hyps_free []\"", "lemma hyps_free_Cons[simp]: \"hyps_free (e#pth) \\<longleftrightarrow> hyps_free pth \\<and> hyps (nodeOf (fst (fst e))) (snd (fst e)) = None\"", "lemma path_vertices_shift:\n  assumes \"path v v' pth\"\n  shows \"map fst (map fst pth)@[v'] = v#map fst (map snd pth)\"", "lemma terminal_path_is_path:\n  assumes \"terminal_path v v' pth\"\n  shows \"path v v' pth\"", "lemma terminal_path_is_hyps_free:\n  assumes \"terminal_path v v' pth\"\n  shows \"hyps_free pth\"", "lemma terminal_path_end_is_terminal:\n  assumes \"terminal_path v v' pth\"\n  shows \"terminal_vertex v'\"", "lemma terminal_pathI:\n  assumes \"path v v' pth\"\n  assumes \"hyps_free pth\"\n  assumes \"terminal_vertex v'\"\n  shows \"terminal_path v v' pth\"", "lemma hyps_free_vertices_distinct:\n  assumes \"terminal_path v v' pth\"\n  shows \"distinct (map fst (map fst pth)@[v'])\"", "lemma hyps_free_vertices_distinct':\n  assumes \"terminal_path v v' pth\"\n  shows \"distinct (v # map fst (map snd pth))\"", "lemma hyps_free_limited:\n  assumes \"terminal_path v v' pth\"\n  shows \"length pth \\<le> fcard vertices\"", "lemma hyps_free_path_not_in_scope:\n  assumes \"terminal_path v t pth\"\n  assumes \"(v',p') \\<in> snd ` set pth\"\n  shows   \"v' \\<notin> scope (v, p)\"", "lemma out_of_scope: \"valid_in_port (v,p) \\<Longrightarrow> v' |\\<in>| vertices \\<Longrightarrow> v' \\<notin> scope (v,p) \\<Longrightarrow> freshenLC (vidx v) ` local_vars (nodeOf v) p \\<inter> subst_lconsts (inst v') = {}\""], "translations": [["", "lemma edge_begin_tup: \"edge_begin x = fst (fst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_begin x = fst (fst x)", "by (metis edge_begin.simps prod.collapse)"], ["", "lemma edge_end_tup: \"edge_end x = fst (snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_end x = fst (snd x)", "by (metis edge_end.simps prod.collapse)"], ["", "inductive path :: \"'v \\<Rightarrow> 'v \\<Rightarrow> ('v, 'outPort, 'inPort) edge list \\<Rightarrow> bool\"   where\n    path_empty: \"path v v []\" |\n    path_cons: \"e \\<in> edges \\<Longrightarrow> path (edge_end e) v' pth \\<Longrightarrow> path (edge_begin e) v' (e#pth)\""], ["", "inductive_simps path_cons_simp': \"path v v' (e#pth)\""], ["", "inductive_simps path_empty_simp[simp]: \"path v v' []\""], ["", "lemma path_cons_simp: \"path v v' (e # pth) \\<longleftrightarrow> fst (fst e) = v \\<and> e \\<in> edges \\<and> path (fst (snd e)) v' pth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path v v' (e # pth) =\n    (fst (fst e) = v \\<and> e \\<in> edges \\<and> path (fst (snd e)) v' pth)", "by(auto simp add: path_cons_simp', metis prod.collapse)"], ["", "lemma path_appendI: \"path v v' pth1 \\<Longrightarrow> path v' v'' pth2 \\<Longrightarrow> path v v'' (pth1@pth2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path v v' pth1; path v' v'' pth2\\<rbrakk>\n    \\<Longrightarrow> path v v'' (pth1 @ pth2)", "by (induction pth1 arbitrary: v) (auto simp add: path_cons_simp )"], ["", "lemma path_split: \"path v v' (pth1@[e]@pth2) \\<longleftrightarrow> path v (edge_end e) (pth1@[e]) \\<and> path (edge_end e) v' pth2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path v v' (pth1 @ [e] @ pth2) =\n    (path v (edge_end e) (pth1 @ [e]) \\<and> path (edge_end e) v' pth2)", "by (induction pth1 arbitrary: v) (auto simp add: path_cons_simp edge_end_tup intro: path_empty)"], ["", "lemma path_split2: \"path v v' (pth1@(e#pth2)) \\<longleftrightarrow> path v (edge_begin e) pth1 \\<and> path (edge_begin e) v' (e#pth2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path v v' (pth1 @ e # pth2) =\n    (path v (edge_begin e) pth1 \\<and> path (edge_begin e) v' (e # pth2))", "by (induction pth1 arbitrary: v) (auto simp add: path_cons_simp edge_begin_tup intro: path_empty)"], ["", "lemma path_snoc: \"path v v' (pth1@[e]) \\<longleftrightarrow> e \\<in> edges \\<and> path v (edge_begin e) pth1 \\<and> edge_end e = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path v v' (pth1 @ [e]) =\n    (e \\<in> edges \\<and> path v (edge_begin e) pth1 \\<and> edge_end e = v')", "by (auto simp add: path_split2 path_cons_simp edge_end_tup edge_begin_tup)"], ["", "inductive_set scope :: \"'v \\<times> 'inPort \\<Rightarrow> 'v set\" for ps where\n    \"v |\\<in>| vertices \\<Longrightarrow> (\\<And> pth v'.  path v v' pth \\<Longrightarrow> terminal_vertex v' \\<Longrightarrow> ps \\<in> snd ` set pth)\n    \\<Longrightarrow> v \\<in> scope ps\""], ["", "lemma scope_find:\n    assumes \"v \\<in> scope ps\"\n    assumes \"terminal_vertex v'\"\n    assumes \"path v v' pth\"\n    shows \"ps \\<in> snd ` set pth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<in> snd ` set pth", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> scope ps\n  terminal_vertex v'\n  path v v' pth\n\ngoal (1 subgoal):\n 1. ps \\<in> snd ` set pth", "by (auto simp add: scope.simps)"], ["", "lemma snd_set_split:\n    assumes \"ps \\<in> snd ` set pth\"\n    obtains pth1 pth2 e  where \"pth = pth1@[e]@pth2\" and \"snd e = ps\" and \"ps \\<notin> snd ` set pth1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pth1 e pth2.\n        \\<lbrakk>pth = pth1 @ [e] @ pth2; snd e = ps;\n         ps \\<notin> snd ` set pth1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ps \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. (\\<And>pth1 e pth2.\n        \\<lbrakk>pth = pth1 @ [e] @ pth2; snd e = ps;\n         ps \\<notin> snd ` set pth1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (atomize_elim, induction pth)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ps \\<in> snd ` set []; ps \\<in> snd ` set []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pth1 e pth2.\n                         [] = pth1 @ [e] @ pth2 \\<and>\n                         snd e = ps \\<and> ps \\<notin> snd ` set pth1\n 2. \\<And>a pth.\n       \\<lbrakk>\\<lbrakk>ps \\<in> snd ` set pth;\n                 ps \\<in> snd ` set pth\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pth1 e pth2.\n                                     pth = pth1 @ [e] @ pth2 \\<and>\n                                     snd e = ps \\<and>\n                                     ps \\<notin> snd ` set pth1;\n        ps \\<in> snd ` set (a # pth); ps \\<in> snd ` set (a # pth)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth1 e pth2.\n                            a # pth = pth1 @ [e] @ pth2 \\<and>\n                            snd e = ps \\<and> ps \\<notin> snd ` set pth1", "case Nil"], ["proof (state)\nthis:\n  ps \\<in> snd ` set []\n  ps \\<in> snd ` set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ps \\<in> snd ` set []; ps \\<in> snd ` set []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pth1 e pth2.\n                         [] = pth1 @ [e] @ pth2 \\<and>\n                         snd e = ps \\<and> ps \\<notin> snd ` set pth1\n 2. \\<And>a pth.\n       \\<lbrakk>\\<lbrakk>ps \\<in> snd ` set pth;\n                 ps \\<in> snd ` set pth\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pth1 e pth2.\n                                     pth = pth1 @ [e] @ pth2 \\<and>\n                                     snd e = ps \\<and>\n                                     ps \\<notin> snd ` set pth1;\n        ps \\<in> snd ` set (a # pth); ps \\<in> snd ` set (a # pth)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth1 e pth2.\n                            a # pth = pth1 @ [e] @ pth2 \\<and>\n                            snd e = ps \\<and> ps \\<notin> snd ` set pth1", "thus ?case"], ["proof (prove)\nusing this:\n  ps \\<in> snd ` set []\n  ps \\<in> snd ` set []\n\ngoal (1 subgoal):\n 1. \\<exists>pth1 e pth2.\n       [] = pth1 @ [e] @ pth2 \\<and>\n       snd e = ps \\<and> ps \\<notin> snd ` set pth1", "by simp"], ["proof (state)\nthis:\n  \\<exists>pth1 e pth2.\n     [] = pth1 @ [e] @ pth2 \\<and>\n     snd e = ps \\<and> ps \\<notin> snd ` set pth1\n\ngoal (1 subgoal):\n 1. \\<And>a pth.\n       \\<lbrakk>\\<lbrakk>ps \\<in> snd ` set pth;\n                 ps \\<in> snd ` set pth\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pth1 e pth2.\n                                     pth = pth1 @ [e] @ pth2 \\<and>\n                                     snd e = ps \\<and>\n                                     ps \\<notin> snd ` set pth1;\n        ps \\<in> snd ` set (a # pth); ps \\<in> snd ` set (a # pth)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth1 e pth2.\n                            a # pth = pth1 @ [e] @ pth2 \\<and>\n                            snd e = ps \\<and> ps \\<notin> snd ` set pth1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a pth.\n       \\<lbrakk>\\<lbrakk>ps \\<in> snd ` set pth;\n                 ps \\<in> snd ` set pth\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pth1 e pth2.\n                                     pth = pth1 @ [e] @ pth2 \\<and>\n                                     snd e = ps \\<and>\n                                     ps \\<notin> snd ` set pth1;\n        ps \\<in> snd ` set (a # pth); ps \\<in> snd ` set (a # pth)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth1 e pth2.\n                            a # pth = pth1 @ [e] @ pth2 \\<and>\n                            snd e = ps \\<and> ps \\<notin> snd ` set pth1", "case (Cons e pth)"], ["proof (state)\nthis:\n  \\<lbrakk>ps \\<in> snd ` set pth; ps \\<in> snd ` set pth\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pth1 e pth2.\n                       pth = pth1 @ [e] @ pth2 \\<and>\n                       snd e = ps \\<and> ps \\<notin> snd ` set pth1\n  ps \\<in> snd ` set (e # pth)\n  ps \\<in> snd ` set (e # pth)\n\ngoal (1 subgoal):\n 1. \\<And>a pth.\n       \\<lbrakk>\\<lbrakk>ps \\<in> snd ` set pth;\n                 ps \\<in> snd ` set pth\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pth1 e pth2.\n                                     pth = pth1 @ [e] @ pth2 \\<and>\n                                     snd e = ps \\<and>\n                                     ps \\<notin> snd ` set pth1;\n        ps \\<in> snd ` set (a # pth); ps \\<in> snd ` set (a # pth)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth1 e pth2.\n                            a # pth = pth1 @ [e] @ pth2 \\<and>\n                            snd e = ps \\<and> ps \\<notin> snd ` set pth1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "proof(cases \"snd e = ps\")"], ["proof (state)\ngoal (2 subgoals):\n 1. snd e = ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1\n 2. snd e \\<noteq> ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "case True"], ["proof (state)\nthis:\n  snd e = ps\n\ngoal (2 subgoals):\n 1. snd e = ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1\n 2. snd e \\<noteq> ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "hence \"e # pth = [] @ [e] @ pth \\<and> snd e = ps \\<and> ps \\<notin> snd ` set []\""], ["proof (prove)\nusing this:\n  snd e = ps\n\ngoal (1 subgoal):\n 1. e # pth = [] @ [e] @ pth \\<and>\n    snd e = ps \\<and> ps \\<notin> snd ` set []", "by auto"], ["proof (state)\nthis:\n  e # pth = [] @ [e] @ pth \\<and> snd e = ps \\<and> ps \\<notin> snd ` set []\n\ngoal (2 subgoals):\n 1. snd e = ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1\n 2. snd e \\<noteq> ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "thus ?thesis"], ["proof (prove)\nusing this:\n  e # pth = [] @ [e] @ pth \\<and> snd e = ps \\<and> ps \\<notin> snd ` set []\n\ngoal (1 subgoal):\n 1. \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "by (intro exI)"], ["proof (state)\nthis:\n  \\<exists>pth1 ea pth2.\n     e # pth = pth1 @ [ea] @ pth2 \\<and>\n     snd ea = ps \\<and> ps \\<notin> snd ` set pth1\n\ngoal (1 subgoal):\n 1. snd e \\<noteq> ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd e \\<noteq> ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "case False"], ["proof (state)\nthis:\n  snd e \\<noteq> ps\n\ngoal (1 subgoal):\n 1. snd e \\<noteq> ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "with Cons(2)"], ["proof (chain)\npicking this:\n  ps \\<in> snd ` set (e # pth)\n  snd e \\<noteq> ps", "have \"ps \\<in> snd ` set pth\""], ["proof (prove)\nusing this:\n  ps \\<in> snd ` set (e # pth)\n  snd e \\<noteq> ps\n\ngoal (1 subgoal):\n 1. ps \\<in> snd ` set pth", "by auto"], ["proof (state)\nthis:\n  ps \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. snd e \\<noteq> ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "from Cons.IH[OF this this]"], ["proof (chain)\npicking this:\n  \\<exists>pth1 e pth2.\n     pth = pth1 @ [e] @ pth2 \\<and>\n     snd e = ps \\<and> ps \\<notin> snd ` set pth1", "obtain pth1 e' pth2 where \"pth = pth1 @ [e'] @ pth2 \\<and> snd e' = ps \\<and> ps \\<notin> snd ` set pth1\""], ["proof (prove)\nusing this:\n  \\<exists>pth1 e pth2.\n     pth = pth1 @ [e] @ pth2 \\<and>\n     snd e = ps \\<and> ps \\<notin> snd ` set pth1\n\ngoal (1 subgoal):\n 1. (\\<And>pth1 e' pth2.\n        pth = pth1 @ [e'] @ pth2 \\<and>\n        snd e' = ps \\<and> ps \\<notin> snd ` set pth1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pth = pth1 @ [e'] @ pth2 \\<and>\n  snd e' = ps \\<and> ps \\<notin> snd ` set pth1\n\ngoal (1 subgoal):\n 1. snd e \\<noteq> ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "with False"], ["proof (chain)\npicking this:\n  snd e \\<noteq> ps\n  pth = pth1 @ [e'] @ pth2 \\<and>\n  snd e' = ps \\<and> ps \\<notin> snd ` set pth1", "have \"e#pth = (e# pth1) @ [e'] @ pth2 \\<and> snd e' = ps \\<and> ps \\<notin> snd ` set (e#pth1)\""], ["proof (prove)\nusing this:\n  snd e \\<noteq> ps\n  pth = pth1 @ [e'] @ pth2 \\<and>\n  snd e' = ps \\<and> ps \\<notin> snd ` set pth1\n\ngoal (1 subgoal):\n 1. e # pth = (e # pth1) @ [e'] @ pth2 \\<and>\n    snd e' = ps \\<and> ps \\<notin> snd ` set (e # pth1)", "by auto"], ["proof (state)\nthis:\n  e # pth = (e # pth1) @ [e'] @ pth2 \\<and>\n  snd e' = ps \\<and> ps \\<notin> snd ` set (e # pth1)\n\ngoal (1 subgoal):\n 1. snd e \\<noteq> ps \\<Longrightarrow>\n    \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "thus ?thesis"], ["proof (prove)\nusing this:\n  e # pth = (e # pth1) @ [e'] @ pth2 \\<and>\n  snd e' = ps \\<and> ps \\<notin> snd ` set (e # pth1)\n\ngoal (1 subgoal):\n 1. \\<exists>pth1 ea pth2.\n       e # pth = pth1 @ [ea] @ pth2 \\<and>\n       snd ea = ps \\<and> ps \\<notin> snd ` set pth1", "by blast"], ["proof (state)\nthis:\n  \\<exists>pth1 ea pth2.\n     e # pth = pth1 @ [ea] @ pth2 \\<and>\n     snd ea = ps \\<and> ps \\<notin> snd ` set pth1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pth1 ea pth2.\n     e # pth = pth1 @ [ea] @ pth2 \\<and>\n     snd ea = ps \\<and> ps \\<notin> snd ` set pth1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scope_split:\n    assumes \"v \\<in> scope ps\"\n    assumes \"path v v' pth\"\n    assumes \"terminal_vertex v'\"\n    obtains pth1 e pth2\n    where \"pth = (pth1@[e])@pth2\" and \"path v (fst ps) (pth1@[e])\" and \"path (fst ps) v' pth2\" and \"snd e = ps\" and \"ps \\<notin> snd ` set pth1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pth1 e pth2.\n        \\<lbrakk>pth = (pth1 @ [e]) @ pth2; path v (fst ps) (pth1 @ [e]);\n         path (fst ps) v' pth2; snd e = ps;\n         ps \\<notin> snd ` set pth1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>pth1 e pth2.\n        \\<lbrakk>pth = (pth1 @ [e]) @ pth2; path v (fst ps) (pth1 @ [e]);\n         path (fst ps) v' pth2; snd e = ps;\n         ps \\<notin> snd ` set pth1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  v \\<in> scope ps\n  path v v' pth\n  terminal_vertex v'", "have \"ps \\<in> snd ` set pth\""], ["proof (prove)\nusing this:\n  v \\<in> scope ps\n  path v v' pth\n  terminal_vertex v'\n\ngoal (1 subgoal):\n 1. ps \\<in> snd ` set pth", "by (auto simp add: scope.simps)"], ["proof (state)\nthis:\n  ps \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. (\\<And>pth1 e pth2.\n        \\<lbrakk>pth = (pth1 @ [e]) @ pth2; path v (fst ps) (pth1 @ [e]);\n         path (fst ps) v' pth2; snd e = ps;\n         ps \\<notin> snd ` set pth1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  ps \\<in> snd ` set pth", "obtain pth1 pth2 e  where \"pth = pth1@[e]@pth2\" and \"snd e = ps\" and \"ps \\<notin> snd ` set pth1\""], ["proof (prove)\nusing this:\n  ps \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. (\\<And>pth1 e pth2.\n        \\<lbrakk>pth = pth1 @ [e] @ pth2; snd e = ps;\n         ps \\<notin> snd ` set pth1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule snd_set_split)"], ["proof (state)\nthis:\n  pth = pth1 @ [e] @ pth2\n  snd e = ps\n  ps \\<notin> snd ` set pth1\n\ngoal (1 subgoal):\n 1. (\\<And>pth1 e pth2.\n        \\<lbrakk>pth = (pth1 @ [e]) @ pth2; path v (fst ps) (pth1 @ [e]);\n         path (fst ps) v' pth2; snd e = ps;\n         ps \\<notin> snd ` set pth1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>path _ _ _\\<close> and \\<open>pth = pth1@[e]@pth2\\<close>"], ["proof (chain)\npicking this:\n  path v v' pth\n  pth = pth1 @ [e] @ pth2", "have \"path v (edge_end e) (pth1@[e])\" and \"path (edge_end e) v' pth2\""], ["proof (prove)\nusing this:\n  path v v' pth\n  pth = pth1 @ [e] @ pth2\n\ngoal (1 subgoal):\n 1. path v (edge_end e) (pth1 @ [e]) &&& path (edge_end e) v' pth2", "by (metis path_split)+"], ["proof (state)\nthis:\n  path v (edge_end e) (pth1 @ [e])\n  path (edge_end e) v' pth2\n\ngoal (1 subgoal):\n 1. (\\<And>pth1 e pth2.\n        \\<lbrakk>pth = (pth1 @ [e]) @ pth2; path v (fst ps) (pth1 @ [e]);\n         path (fst ps) v' pth2; snd e = ps;\n         ps \\<notin> snd ` set pth1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof(rule that)"], ["proof (state)\ngoal (5 subgoals):\n 1. pth = (?pth1.0 @ [?e]) @ ?pth2.0\n 2. path v (fst ps) (?pth1.0 @ [?e])\n 3. path (fst ps) v' ?pth2.0\n 4. snd ?e = ps\n 5. ps \\<notin> snd ` set ?pth1.0", "show \"pth = (pth1@[e])@pth2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pth = (pth1 @ [e]) @ pth2", "using \\<open>pth= _\\<close>"], ["proof (prove)\nusing this:\n  pth = pth1 @ [e] @ pth2\n\ngoal (1 subgoal):\n 1. pth = (pth1 @ [e]) @ pth2", "by simp"], ["proof (state)\nthis:\n  pth = (pth1 @ [e]) @ pth2\n\ngoal (4 subgoals):\n 1. path v (fst ps) (pth1 @ [e])\n 2. path (fst ps) v' pth2\n 3. snd e = ps\n 4. ps \\<notin> snd ` set pth1", "show \"path v (fst ps) (pth1@[e])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path v (fst ps) (pth1 @ [e])", "using \\<open>path v (edge_end e) (pth1@[e])\\<close>  \\<open>snd e = ps\\<close>"], ["proof (prove)\nusing this:\n  path v (edge_end e) (pth1 @ [e])\n  snd e = ps\n\ngoal (1 subgoal):\n 1. path v (fst ps) (pth1 @ [e])", "by (simp add: edge_end_tup)"], ["proof (state)\nthis:\n  path v (fst ps) (pth1 @ [e])\n\ngoal (3 subgoals):\n 1. path (fst ps) v' pth2\n 2. snd e = ps\n 3. ps \\<notin> snd ` set pth1", "show \"path (fst ps) v' pth2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (fst ps) v' pth2", "using \\<open>path (edge_end e) v' pth2\\<close>  \\<open>snd e = ps\\<close>"], ["proof (prove)\nusing this:\n  path (edge_end e) v' pth2\n  snd e = ps\n\ngoal (1 subgoal):\n 1. path (fst ps) v' pth2", "by (simp add: edge_end_tup)"], ["proof (state)\nthis:\n  path (fst ps) v' pth2\n\ngoal (2 subgoals):\n 1. snd e = ps\n 2. ps \\<notin> snd ` set pth1", "show \"ps \\<notin> snd ` set pth1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<notin> snd ` set pth1", "by fact"], ["proof (state)\nthis:\n  ps \\<notin> snd ` set pth1\n\ngoal (1 subgoal):\n 1. snd e = ps", "show \"snd e = ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd e = ps", "by fact"], ["proof (state)\nthis:\n  snd e = ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>This adds well-formedness conditions to the edges and vertices.\\<close>"], ["", "locale Port_Graph = Pre_Port_Graph +\n  assumes valid_nodes: \"nodeOf ` fset vertices  \\<subseteq> sset nodes\"\n  assumes valid_edges: \"\\<forall> (ps1,ps2) \\<in> edges. valid_out_port ps1 \\<and> valid_in_port ps2\"\nbegin"], ["", "lemma snd_set_path_verties: \"path v v' pth \\<Longrightarrow> fst ` snd ` set pth \\<subseteq> fset vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path v v' pth \\<Longrightarrow>\n    fst ` snd ` set pth \\<subseteq> fset vertices", "apply (induction rule: path.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v. fst ` snd ` set [] \\<subseteq> fset vertices\n 2. \\<And>e v' pth.\n       \\<lbrakk>e \\<in> edges; path (edge_end e) v' pth;\n        fst ` snd ` set pth \\<subseteq> fset vertices\\<rbrakk>\n       \\<Longrightarrow> fst ` snd ` set (e # pth) \\<subseteq> fset vertices", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba v' pth.\n       \\<lbrakk>((a, b), aa, ba) \\<in> edges; path aa v' pth;\n        fst ` snd ` set pth \\<subseteq> fset vertices\\<rbrakk>\n       \\<Longrightarrow> aa \\<in> fset vertices", "apply (metis valid_in_port.elims(2) edge_end.simps notin_fset case_prodD valid_edges)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fst_set_path_verties: \"path v v' pth \\<Longrightarrow> fst ` fst ` set pth \\<subseteq> fset vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path v v' pth \\<Longrightarrow>\n    fst ` fst ` set pth \\<subseteq> fset vertices", "apply (induction rule: path.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v. fst ` fst ` set [] \\<subseteq> fset vertices\n 2. \\<And>e v' pth.\n       \\<lbrakk>e \\<in> edges; path (edge_end e) v' pth;\n        fst ` fst ` set pth \\<subseteq> fset vertices\\<rbrakk>\n       \\<Longrightarrow> fst ` fst ` set (e # pth) \\<subseteq> fset vertices", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba v' pth.\n       \\<lbrakk>((a, b), aa, ba) \\<in> edges; path aa v' pth;\n        fst ` fst ` set pth \\<subseteq> fset vertices\\<rbrakk>\n       \\<Longrightarrow> a \\<in> fset vertices", "apply (metis valid_out_port.elims(2) edge_begin.simps notin_fset case_prodD valid_edges)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>A pruned graph is one where every node has a path to a terminal node (which will be the conclusions).\\<close>"], ["", "locale Pruned_Port_Graph = Port_Graph +\n  assumes pruned: \"\\<And>v.  v |\\<in>| vertices \\<Longrightarrow> (\\<exists>pth v'. path v v' pth \\<and> terminal_vertex v')\"\nbegin"], ["", "lemma scopes_not_refl:\n    assumes \"v |\\<in>| vertices\"\n    shows \"v \\<notin> scope (v,p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> scope (v, p)", "proof(rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> scope (v, p) \\<Longrightarrow> False", "assume \"v \\<in> scope (v,p)\""], ["proof (state)\nthis:\n  v \\<in> scope (v, p)\n\ngoal (1 subgoal):\n 1. v \\<in> scope (v, p) \\<Longrightarrow> False", "from pruned[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>pth v'. path v v' pth \\<and> terminal_vertex v'", "obtain pth t where \"terminal_vertex t\" and \"path v t pth\" and least: \"\\<forall> pth'. path v t pth' \\<longrightarrow> length pth \\<le> length pth'\""], ["proof (prove)\nusing this:\n  \\<exists>pth v'. path v v' pth \\<and> terminal_vertex v'\n\ngoal (1 subgoal):\n 1. (\\<And>t pth.\n        \\<lbrakk>terminal_vertex t; path v t pth;\n         \\<forall>pth'.\n            path v t pth' \\<longrightarrow>\n            length pth \\<le> length pth'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto simp del: terminal_vertex.simps elim: ex_has_least_nat)"], ["proof (state)\nthis:\n  terminal_vertex t\n  path v t pth\n  \\<forall>pth'.\n     path v t pth' \\<longrightarrow> length pth \\<le> length pth'\n\ngoal (1 subgoal):\n 1. v \\<in> scope (v, p) \\<Longrightarrow> False", "from scope_split[OF \\<open>v \\<in> scope (v,p)\\<close> \\<open>path v t pth\\<close> \\<open>terminal_vertex t\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>pth1 e pth2.\n      \\<lbrakk>pth = (pth1 @ [e]) @ pth2; path v (fst (v, p)) (pth1 @ [e]);\n       path (fst (v, p)) t pth2; snd e = (v, p);\n       (v, p) \\<notin> snd ` set pth1\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain pth1 e pth2 where \"pth = (pth1 @ [e]) @ pth2\" \"path v t pth2\""], ["proof (prove)\nusing this:\n  (\\<And>pth1 e pth2.\n      \\<lbrakk>pth = (pth1 @ [e]) @ pth2; path v (fst (v, p)) (pth1 @ [e]);\n       path (fst (v, p)) t pth2; snd e = (v, p);\n       (v, p) \\<notin> snd ` set pth1\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>pth1 e pth2.\n        \\<lbrakk>pth = (pth1 @ [e]) @ pth2; path v t pth2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis fst_conv)"], ["proof (state)\nthis:\n  pth = (pth1 @ [e]) @ pth2\n  path v t pth2\n\ngoal (1 subgoal):\n 1. v \\<in> scope (v, p) \\<Longrightarrow> False", "from this(2) least"], ["proof (chain)\npicking this:\n  path v t pth2\n  \\<forall>pth'.\n     path v t pth' \\<longrightarrow> length pth \\<le> length pth'", "have \"length pth \\<le> length pth2\""], ["proof (prove)\nusing this:\n  path v t pth2\n  \\<forall>pth'.\n     path v t pth' \\<longrightarrow> length pth \\<le> length pth'\n\ngoal (1 subgoal):\n 1. length pth \\<le> length pth2", "by auto"], ["proof (state)\nthis:\n  length pth \\<le> length pth2\n\ngoal (1 subgoal):\n 1. v \\<in> scope (v, p) \\<Longrightarrow> False", "with \\<open>pth = _\\<close>"], ["proof (chain)\npicking this:\n  pth = (pth1 @ [e]) @ pth2\n  length pth \\<le> length pth2", "show False"], ["proof (prove)\nusing this:\n  pth = (pth1 @ [e]) @ pth2\n  length pth \\<le> length pth2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This lemma can be found in \\cite{incredible}, but it is otherwise inconsequential.\\<close>"], ["", "lemma scopes_nest:\n    fixes ps1 ps2\n    shows \"scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "proof(cases \"ps1 = ps2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "assume \"ps1 \\<noteq> ps2\""], ["proof (state)\nthis:\n  ps1 \\<noteq> ps2\n\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "{"], ["proof (state)\nthis:\n  ps1 \\<noteq> ps2\n\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "assume \"v \\<in> scope ps1 \\<inter> scope ps2\""], ["proof (state)\nthis:\n  v \\<in> scope ps1 \\<inter> scope ps2\n\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "hence \"v |\\<in>| vertices\""], ["proof (prove)\nusing this:\n  v \\<in> scope ps1 \\<inter> scope ps2\n\ngoal (1 subgoal):\n 1. v |\\<in>| vertices", "using scope.simps"], ["proof (prove)\nusing this:\n  v \\<in> scope ps1 \\<inter> scope ps2\n  (?a \\<in> scope ?ps) =\n  (\\<exists>v.\n      ?a = v \\<and>\n      v |\\<in>| vertices \\<and>\n      (\\<forall>x xa.\n          path v xa x \\<longrightarrow>\n          terminal_vertex xa \\<longrightarrow> ?ps \\<in> snd ` set x))\n\ngoal (1 subgoal):\n 1. v |\\<in>| vertices", "by auto"], ["proof (state)\nthis:\n  v |\\<in>| vertices\n\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "then"], ["proof (chain)\npicking this:\n  v |\\<in>| vertices", "obtain pth t where \"path v t pth\" and \"terminal_vertex t\""], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. (\\<And>t pth.\n        \\<lbrakk>path v t pth; terminal_vertex t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pruned"], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n  ?v |\\<in>| vertices \\<Longrightarrow>\n  \\<exists>pth v'. path ?v v' pth \\<and> terminal_vertex v'\n\ngoal (1 subgoal):\n 1. (\\<And>t pth.\n        \\<lbrakk>path v t pth; terminal_vertex t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path v t pth\n  terminal_vertex t\n\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "from \\<open>path v t pth\\<close> and \\<open>terminal_vertex t\\<close> and \\<open>v \\<in> scope ps1 \\<inter> scope ps2\\<close>"], ["proof (chain)\npicking this:\n  path v t pth\n  terminal_vertex t\n  v \\<in> scope ps1 \\<inter> scope ps2", "obtain pth1a e1 pth1b  where \"pth = (pth1a@[e1])@pth1b\" and \"path v (fst ps1) (pth1a@[e1])\" and \"snd e1 = ps1\" and \"ps1 \\<notin> snd ` set pth1a\""], ["proof (prove)\nusing this:\n  path v t pth\n  terminal_vertex t\n  v \\<in> scope ps1 \\<inter> scope ps2\n\ngoal (1 subgoal):\n 1. (\\<And>pth1a e1 pth1b.\n        \\<lbrakk>pth = (pth1a @ [e1]) @ pth1b;\n         path v (fst ps1) (pth1a @ [e1]); snd e1 = ps1;\n         ps1 \\<notin> snd ` set pth1a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: scope_split)"], ["proof (state)\nthis:\n  pth = (pth1a @ [e1]) @ pth1b\n  path v (fst ps1) (pth1a @ [e1])\n  snd e1 = ps1\n  ps1 \\<notin> snd ` set pth1a\n\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "from \\<open>path v t pth\\<close> and \\<open>terminal_vertex t\\<close> and \\<open>v \\<in> scope ps1 \\<inter> scope ps2\\<close>"], ["proof (chain)\npicking this:\n  path v t pth\n  terminal_vertex t\n  v \\<in> scope ps1 \\<inter> scope ps2", "obtain pth2a e2 pth2b  where \"pth = (pth2a@[e2])@pth2b\" and \"path v (fst ps2) (pth2a@[e2])\" and \"snd e2 = ps2\" and \"ps2 \\<notin> snd ` set pth2a\""], ["proof (prove)\nusing this:\n  path v t pth\n  terminal_vertex t\n  v \\<in> scope ps1 \\<inter> scope ps2\n\ngoal (1 subgoal):\n 1. (\\<And>pth2a e2 pth2b.\n        \\<lbrakk>pth = (pth2a @ [e2]) @ pth2b;\n         path v (fst ps2) (pth2a @ [e2]); snd e2 = ps2;\n         ps2 \\<notin> snd ` set pth2a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: scope_split)"], ["proof (state)\nthis:\n  pth = (pth2a @ [e2]) @ pth2b\n  path v (fst ps2) (pth2a @ [e2])\n  snd e2 = ps2\n  ps2 \\<notin> snd ` set pth2a\n\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "from \\<open>pth = (pth1a@[e1])@pth1b\\<close> \\<open>pth = (pth2a@[e2])@pth2b\\<close>"], ["proof (chain)\npicking this:\n  pth = (pth1a @ [e1]) @ pth1b\n  pth = (pth2a @ [e2]) @ pth2b", "have \"set pth1a \\<subseteq> set pth2a \\<or> set pth2a \\<subseteq> set pth1a\""], ["proof (prove)\nusing this:\n  pth = (pth1a @ [e1]) @ pth1b\n  pth = (pth2a @ [e2]) @ pth2b\n\ngoal (1 subgoal):\n 1. set pth1a \\<subseteq> set pth2a \\<or> set pth2a \\<subseteq> set pth1a", "by (auto simp add: append_eq_append_conv2)"], ["proof (state)\nthis:\n  set pth1a \\<subseteq> set pth2a \\<or> set pth2a \\<subseteq> set pth1a\n\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "hence \"scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1\""], ["proof (prove)\nusing this:\n  set pth1a \\<subseteq> set pth2a \\<or> set pth2a \\<subseteq> set pth1a\n\ngoal (1 subgoal):\n 1. scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. set pth1a \\<subseteq> set pth2a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1\n 2. set pth2a \\<subseteq> set pth1a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "assume \"set pth1a \\<subseteq> set pth2a\""], ["proof (state)\nthis:\n  set pth1a \\<subseteq> set pth2a\n\ngoal (2 subgoals):\n 1. set pth1a \\<subseteq> set pth2a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1\n 2. set pth2a \\<subseteq> set pth1a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "with \\<open>ps2 \\<notin> _\\<close>"], ["proof (chain)\npicking this:\n  ps2 \\<notin> snd ` set pth2a\n  set pth1a \\<subseteq> set pth2a", "have \"ps2 \\<notin> snd ` set (pth1a@[e1])\""], ["proof (prove)\nusing this:\n  ps2 \\<notin> snd ` set pth2a\n  set pth1a \\<subseteq> set pth2a\n\ngoal (1 subgoal):\n 1. ps2 \\<notin> snd ` set (pth1a @ [e1])", "using \\<open>ps1 \\<noteq> ps2\\<close> \\<open>snd e1 = ps1\\<close>"], ["proof (prove)\nusing this:\n  ps2 \\<notin> snd ` set pth2a\n  set pth1a \\<subseteq> set pth2a\n  ps1 \\<noteq> ps2\n  snd e1 = ps1\n\ngoal (1 subgoal):\n 1. ps2 \\<notin> snd ` set (pth1a @ [e1])", "by auto"], ["proof (state)\nthis:\n  ps2 \\<notin> snd ` set (pth1a @ [e1])\n\ngoal (2 subgoals):\n 1. set pth1a \\<subseteq> set pth2a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1\n 2. set pth2a \\<subseteq> set pth1a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "have \"scope ps1 \\<subseteq> scope ps2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scope ps1 \\<subseteq> scope ps2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> scope ps1 \\<Longrightarrow> x \\<in> scope ps2", "fix v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> scope ps1 \\<Longrightarrow> x \\<in> scope ps2", "assume \"v' \\<in> scope ps1\""], ["proof (state)\nthis:\n  v' \\<in> scope ps1\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> scope ps1 \\<Longrightarrow> x \\<in> scope ps2", "hence \"v' |\\<in>| vertices\""], ["proof (prove)\nusing this:\n  v' \\<in> scope ps1\n\ngoal (1 subgoal):\n 1. v' |\\<in>| vertices", "using scope.simps"], ["proof (prove)\nusing this:\n  v' \\<in> scope ps1\n  (?a \\<in> scope ?ps) =\n  (\\<exists>v.\n      ?a = v \\<and>\n      v |\\<in>| vertices \\<and>\n      (\\<forall>x xa.\n          path v xa x \\<longrightarrow>\n          terminal_vertex xa \\<longrightarrow> ?ps \\<in> snd ` set x))\n\ngoal (1 subgoal):\n 1. v' |\\<in>| vertices", "by auto"], ["proof (state)\nthis:\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> scope ps1 \\<Longrightarrow> x \\<in> scope ps2", "thus \"v' \\<in> scope ps2\""], ["proof (prove)\nusing this:\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. v' \\<in> scope ps2", "proof(rule scope.intros)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps2 \\<in> snd ` set pth", "fix pth' t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps2 \\<in> snd ` set pth", "assume \"path v' t' pth'\" and \"terminal_vertex t'\""], ["proof (state)\nthis:\n  path v' t' pth'\n  terminal_vertex t'\n\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps2 \\<in> snd ` set pth", "with \\<open>v' \\<in> scope ps1\\<close>"], ["proof (chain)\npicking this:\n  v' \\<in> scope ps1\n  path v' t' pth'\n  terminal_vertex t'", "obtain pth3a e3 pth3b where \"pth' = (pth3a@[e3])@pth3b\" and \"path (fst ps1) t' pth3b\""], ["proof (prove)\nusing this:\n  v' \\<in> scope ps1\n  path v' t' pth'\n  terminal_vertex t'\n\ngoal (1 subgoal):\n 1. (\\<And>pth3a e3 pth3b.\n        \\<lbrakk>pth' = (pth3a @ [e3]) @ pth3b;\n         path (fst ps1) t' pth3b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: scope_split)"], ["proof (state)\nthis:\n  pth' = (pth3a @ [e3]) @ pth3b\n  path (fst ps1) t' pth3b\n\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps2 \\<in> snd ` set pth", "have \"path v t' ((pth1a@[e1]) @ pth3b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path v t' ((pth1a @ [e1]) @ pth3b)", "using \\<open>path v (fst ps1) (pth1a@[e1])\\<close> and \\<open>path (fst ps1) t' pth3b\\<close>"], ["proof (prove)\nusing this:\n  path v (fst ps1) (pth1a @ [e1])\n  path (fst ps1) t' pth3b\n\ngoal (1 subgoal):\n 1. path v t' ((pth1a @ [e1]) @ pth3b)", "by (rule path_appendI)"], ["proof (state)\nthis:\n  path v t' ((pth1a @ [e1]) @ pth3b)\n\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps2 \\<in> snd ` set pth", "with \\<open>terminal_vertex t'\\<close> \\<open>v \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  terminal_vertex t'\n  v \\<in> scope ps1 \\<inter> scope ps2\n  path v t' ((pth1a @ [e1]) @ pth3b)", "have \"ps2 \\<in> snd ` set ((pth1a@[e1]) @ pth3b)\""], ["proof (prove)\nusing this:\n  terminal_vertex t'\n  v \\<in> scope ps1 \\<inter> scope ps2\n  path v t' ((pth1a @ [e1]) @ pth3b)\n\ngoal (1 subgoal):\n 1. ps2 \\<in> snd ` set ((pth1a @ [e1]) @ pth3b)", "by (meson IntD2 scope.cases)"], ["proof (state)\nthis:\n  ps2 \\<in> snd ` set ((pth1a @ [e1]) @ pth3b)\n\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps2 \\<in> snd ` set pth", "hence \"ps2 \\<in> snd ` set pth3b\""], ["proof (prove)\nusing this:\n  ps2 \\<in> snd ` set ((pth1a @ [e1]) @ pth3b)\n\ngoal (1 subgoal):\n 1. ps2 \\<in> snd ` set pth3b", "using \\<open>ps2 \\<notin> snd ` set (pth1a@[e1])\\<close>"], ["proof (prove)\nusing this:\n  ps2 \\<in> snd ` set ((pth1a @ [e1]) @ pth3b)\n  ps2 \\<notin> snd ` set (pth1a @ [e1])\n\ngoal (1 subgoal):\n 1. ps2 \\<in> snd ` set pth3b", "by auto"], ["proof (state)\nthis:\n  ps2 \\<in> snd ` set pth3b\n\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps2 \\<in> snd ` set pth", "thus \"ps2 \\<in> snd ` set pth'\""], ["proof (prove)\nusing this:\n  ps2 \\<in> snd ` set pth3b\n\ngoal (1 subgoal):\n 1. ps2 \\<in> snd ` set pth'", "using \\<open>pth'=_\\<close>"], ["proof (prove)\nusing this:\n  ps2 \\<in> snd ` set pth3b\n  pth' = (pth3a @ [e3]) @ pth3b\n\ngoal (1 subgoal):\n 1. ps2 \\<in> snd ` set pth'", "by auto"], ["proof (state)\nthis:\n  ps2 \\<in> snd ` set pth'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v' \\<in> scope ps2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  scope ps1 \\<subseteq> scope ps2\n\ngoal (2 subgoals):\n 1. set pth1a \\<subseteq> set pth2a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1\n 2. set pth2a \\<subseteq> set pth1a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "thus ?thesis"], ["proof (prove)\nusing this:\n  scope ps1 \\<subseteq> scope ps2\n\ngoal (1 subgoal):\n 1. scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "by simp"], ["proof (state)\nthis:\n  scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1\n\ngoal (1 subgoal):\n 1. set pth2a \\<subseteq> set pth1a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set pth2a \\<subseteq> set pth1a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "assume \"set pth2a \\<subseteq> set pth1a\""], ["proof (state)\nthis:\n  set pth2a \\<subseteq> set pth1a\n\ngoal (1 subgoal):\n 1. set pth2a \\<subseteq> set pth1a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "with \\<open>ps1 \\<notin> _\\<close>"], ["proof (chain)\npicking this:\n  ps1 \\<notin> snd ` set pth1a\n  set pth2a \\<subseteq> set pth1a", "have \"ps1 \\<notin> snd ` set (pth2a@[e2])\""], ["proof (prove)\nusing this:\n  ps1 \\<notin> snd ` set pth1a\n  set pth2a \\<subseteq> set pth1a\n\ngoal (1 subgoal):\n 1. ps1 \\<notin> snd ` set (pth2a @ [e2])", "using \\<open>ps1 \\<noteq> ps2\\<close> \\<open>snd e2 = ps2\\<close>"], ["proof (prove)\nusing this:\n  ps1 \\<notin> snd ` set pth1a\n  set pth2a \\<subseteq> set pth1a\n  ps1 \\<noteq> ps2\n  snd e2 = ps2\n\ngoal (1 subgoal):\n 1. ps1 \\<notin> snd ` set (pth2a @ [e2])", "by auto"], ["proof (state)\nthis:\n  ps1 \\<notin> snd ` set (pth2a @ [e2])\n\ngoal (1 subgoal):\n 1. set pth2a \\<subseteq> set pth1a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "have \"scope ps2 \\<subseteq> scope ps1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scope ps2 \\<subseteq> scope ps1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> scope ps2 \\<Longrightarrow> x \\<in> scope ps1", "fix v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> scope ps2 \\<Longrightarrow> x \\<in> scope ps1", "assume \"v' \\<in> scope ps2\""], ["proof (state)\nthis:\n  v' \\<in> scope ps2\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> scope ps2 \\<Longrightarrow> x \\<in> scope ps1", "hence \"v' |\\<in>| vertices\""], ["proof (prove)\nusing this:\n  v' \\<in> scope ps2\n\ngoal (1 subgoal):\n 1. v' |\\<in>| vertices", "using scope.simps"], ["proof (prove)\nusing this:\n  v' \\<in> scope ps2\n  (?a \\<in> scope ?ps) =\n  (\\<exists>v.\n      ?a = v \\<and>\n      v |\\<in>| vertices \\<and>\n      (\\<forall>x xa.\n          path v xa x \\<longrightarrow>\n          terminal_vertex xa \\<longrightarrow> ?ps \\<in> snd ` set x))\n\ngoal (1 subgoal):\n 1. v' |\\<in>| vertices", "by auto"], ["proof (state)\nthis:\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> scope ps2 \\<Longrightarrow> x \\<in> scope ps1", "thus \"v' \\<in> scope ps1\""], ["proof (prove)\nusing this:\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. v' \\<in> scope ps1", "proof(rule scope.intros)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps1 \\<in> snd ` set pth", "fix pth' t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps1 \\<in> snd ` set pth", "assume \"path v' t' pth'\" and \"terminal_vertex t'\""], ["proof (state)\nthis:\n  path v' t' pth'\n  terminal_vertex t'\n\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps1 \\<in> snd ` set pth", "with \\<open>v' \\<in> scope ps2\\<close>"], ["proof (chain)\npicking this:\n  v' \\<in> scope ps2\n  path v' t' pth'\n  terminal_vertex t'", "obtain pth3a e3 pth3b where \"pth' = (pth3a@[e3])@pth3b\" and \"path (fst ps2) t' pth3b\""], ["proof (prove)\nusing this:\n  v' \\<in> scope ps2\n  path v' t' pth'\n  terminal_vertex t'\n\ngoal (1 subgoal):\n 1. (\\<And>pth3a e3 pth3b.\n        \\<lbrakk>pth' = (pth3a @ [e3]) @ pth3b;\n         path (fst ps2) t' pth3b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: scope_split)"], ["proof (state)\nthis:\n  pth' = (pth3a @ [e3]) @ pth3b\n  path (fst ps2) t' pth3b\n\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps1 \\<in> snd ` set pth", "have \"path v t' ((pth2a@[e2]) @ pth3b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path v t' ((pth2a @ [e2]) @ pth3b)", "using \\<open>path v (fst ps2) (pth2a@[e2])\\<close> and \\<open>path (fst ps2) t' pth3b\\<close>"], ["proof (prove)\nusing this:\n  path v (fst ps2) (pth2a @ [e2])\n  path (fst ps2) t' pth3b\n\ngoal (1 subgoal):\n 1. path v t' ((pth2a @ [e2]) @ pth3b)", "by (rule path_appendI)"], ["proof (state)\nthis:\n  path v t' ((pth2a @ [e2]) @ pth3b)\n\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps1 \\<in> snd ` set pth", "with \\<open>terminal_vertex t'\\<close> \\<open>v \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  terminal_vertex t'\n  v \\<in> scope ps1 \\<inter> scope ps2\n  path v t' ((pth2a @ [e2]) @ pth3b)", "have \"ps1 \\<in> snd ` set ((pth2a@[e2]) @ pth3b)\""], ["proof (prove)\nusing this:\n  terminal_vertex t'\n  v \\<in> scope ps1 \\<inter> scope ps2\n  path v t' ((pth2a @ [e2]) @ pth3b)\n\ngoal (1 subgoal):\n 1. ps1 \\<in> snd ` set ((pth2a @ [e2]) @ pth3b)", "by (meson IntD1 scope.cases)"], ["proof (state)\nthis:\n  ps1 \\<in> snd ` set ((pth2a @ [e2]) @ pth3b)\n\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps1 \\<in> snd ` set pth", "hence \"ps1 \\<in> snd ` set pth3b\""], ["proof (prove)\nusing this:\n  ps1 \\<in> snd ` set ((pth2a @ [e2]) @ pth3b)\n\ngoal (1 subgoal):\n 1. ps1 \\<in> snd ` set pth3b", "using \\<open>ps1 \\<notin> snd ` set (pth2a@[e2])\\<close>"], ["proof (prove)\nusing this:\n  ps1 \\<in> snd ` set ((pth2a @ [e2]) @ pth3b)\n  ps1 \\<notin> snd ` set (pth2a @ [e2])\n\ngoal (1 subgoal):\n 1. ps1 \\<in> snd ` set pth3b", "by auto"], ["proof (state)\nthis:\n  ps1 \\<in> snd ` set pth3b\n\ngoal (1 subgoal):\n 1. \\<And>pth v'a.\n       \\<lbrakk>path v' v'a pth; terminal_vertex v'a\\<rbrakk>\n       \\<Longrightarrow> ps1 \\<in> snd ` set pth", "thus \"ps1 \\<in> snd ` set pth'\""], ["proof (prove)\nusing this:\n  ps1 \\<in> snd ` set pth3b\n\ngoal (1 subgoal):\n 1. ps1 \\<in> snd ` set pth'", "using \\<open>pth'=_\\<close>"], ["proof (prove)\nusing this:\n  ps1 \\<in> snd ` set pth3b\n  pth' = (pth3a @ [e3]) @ pth3b\n\ngoal (1 subgoal):\n 1. ps1 \\<in> snd ` set pth'", "by auto"], ["proof (state)\nthis:\n  ps1 \\<in> snd ` set pth'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v' \\<in> scope ps1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  scope ps2 \\<subseteq> scope ps1\n\ngoal (1 subgoal):\n 1. set pth2a \\<subseteq> set pth1a \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "thus ?thesis"], ["proof (prove)\nusing this:\n  scope ps2 \\<subseteq> scope ps1\n\ngoal (1 subgoal):\n 1. scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1", "by simp"], ["proof (state)\nthis:\n  scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1\n\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> scope ps1 \\<inter> scope ps2 \\<Longrightarrow>\n  scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1\n\ngoal (2 subgoals):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n 2. ps1 \\<noteq> ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?v2 \\<in> scope ps1 \\<inter> scope ps2 \\<Longrightarrow>\n  scope ps1 \\<subseteq> scope ps2 \\<or> scope ps2 \\<subseteq> scope ps1\n\ngoal (1 subgoal):\n 1. scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "by blast"], ["proof (state)\nthis:\n  scope ps1 \\<subseteq> scope ps2 \\<or>\n  scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}\n\ngoal (1 subgoal):\n 1. ps1 = ps2 \\<Longrightarrow>\n    scope ps1 \\<subseteq> scope ps2 \\<or>\n    scope ps2 \\<subseteq> scope ps1 \\<or> scope ps1 \\<inter> scope ps2 = {}", "qed simp"], ["", "end"], ["", "text \\<open>A well-scoped graph is one where a port marked to be a local hypothesis is only connected to\nthe corresponding input port, either directly or via a path. It must not be, however, that there is\na a path from such a hypothesis to a terminal node that does not pass by the dedicated input port;\nthis is expressed via scopes.\n\\<close>"], ["", "locale Scoped_Graph = Port_Graph + Port_Graph_Signature_Scoped"], ["", "locale Well_Scoped_Graph = Scoped_Graph +\n  assumes well_scoped: \"((v\\<^sub>1,p\\<^sub>1),(v\\<^sub>2,p\\<^sub>2)) \\<in> edges \\<Longrightarrow> hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p' \\<Longrightarrow> (v\\<^sub>2,p\\<^sub>2) = (v\\<^sub>1,p') \\<or> v\\<^sub>2 \\<in> scope (v\\<^sub>1,p')\""], ["", "context Scoped_Graph\nbegin"], ["", "definition hyps_free where\n  \"hyps_free pth = (\\<forall> v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2. ((v\\<^sub>1,p\\<^sub>1),(v\\<^sub>2,p\\<^sub>2)) \\<in> set pth \\<longrightarrow> hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None)\""], ["", "lemma hyps_free_Nil[simp]: \"hyps_free []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hyps_free []", "by (simp add: hyps_free_def)"], ["", "lemma hyps_free_Cons[simp]: \"hyps_free (e#pth) \\<longleftrightarrow> hyps_free pth \\<and> hyps (nodeOf (fst (fst e))) (snd (fst e)) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hyps_free (e # pth) =\n    (hyps_free pth \\<and> hyps (nodeOf (fst (fst e))) (snd (fst e)) = None)", "by (auto simp add: hyps_free_def) (metis prod.collapse)"], ["", "lemma path_vertices_shift:\n  assumes \"path v v' pth\"\n  shows \"map fst (map fst pth)@[v'] = v#map fst (map snd pth)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map fst pth) @ [v'] = v # map fst (map snd pth)", "using assms"], ["proof (prove)\nusing this:\n  path v v' pth\n\ngoal (1 subgoal):\n 1. map fst (map fst pth) @ [v'] = v # map fst (map snd pth)", "by induction auto"], ["", "inductive terminal_path where\n    terminal_path_empty: \"terminal_vertex v \\<Longrightarrow> terminal_path v v []\" |\n    terminal_path_cons: \"((v\\<^sub>1,p\\<^sub>1),(v\\<^sub>2,p\\<^sub>2)) \\<in> edges \\<Longrightarrow> terminal_path v\\<^sub>2 v' pth \\<Longrightarrow> hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<Longrightarrow> terminal_path v\\<^sub>1 v' (((v\\<^sub>1,p\\<^sub>1),(v\\<^sub>2,p\\<^sub>2))#pth)\""], ["", "lemma terminal_path_is_path:\n  assumes \"terminal_path v v' pth\"\n  shows \"path v v' pth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path v v' pth", "using assms"], ["proof (prove)\nusing this:\n  terminal_path v v' pth\n\ngoal (1 subgoal):\n 1. path v v' pth", "by induction (auto simp add: path_cons_simp)"], ["", "lemma terminal_path_is_hyps_free:\n  assumes \"terminal_path v v' pth\"\n  shows \"hyps_free pth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hyps_free pth", "using assms"], ["proof (prove)\nusing this:\n  terminal_path v v' pth\n\ngoal (1 subgoal):\n 1. hyps_free pth", "by induction (auto simp add: hyps_free_def)"], ["", "lemma terminal_path_end_is_terminal:\n  assumes \"terminal_path v v' pth\"\n  shows \"terminal_vertex v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_vertex v'", "using assms"], ["proof (prove)\nusing this:\n  terminal_path v v' pth\n\ngoal (1 subgoal):\n 1. terminal_vertex v'", "by induction"], ["", "lemma terminal_pathI:\n  assumes \"path v v' pth\"\n  assumes \"hyps_free pth\"\n  assumes \"terminal_vertex v'\"\n  shows \"terminal_path v v' pth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_path v v' pth", "using assms"], ["proof (prove)\nusing this:\n  path v v' pth\n  hyps_free pth\n  terminal_vertex v'\n\ngoal (1 subgoal):\n 1. terminal_path v v' pth", "by induction (auto intro: terminal_path.intros)"], ["", "end"], ["", "text \\<open>An acyclic graph is one where there are no non-trivial cyclic paths (disregarding\nedges that are local hypotheses -- these are naturally and benignly cyclic).\\<close>"], ["", "locale Acyclic_Graph = Scoped_Graph +\n  assumes hyps_free_acyclic: \"path v v pth \\<Longrightarrow> hyps_free pth \\<Longrightarrow> pth = []\"\nbegin"], ["", "lemma hyps_free_vertices_distinct:\n  assumes \"terminal_path v v' pth\"\n  shows \"distinct (map fst (map fst pth)@[v'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (map fst pth) @ [v'])", "using assms"], ["proof (prove)\nusing this:\n  terminal_path v v' pth\n\ngoal (1 subgoal):\n 1. distinct (map fst (map fst pth) @ [v'])", "proof(induction v v' pth)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       terminal_vertex v \\<Longrightarrow>\n       distinct (map fst (map fst []) @ [v])\n 2. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 v' pth.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        terminal_path v\\<^sub>2 v' pth;\n        distinct (map fst (map fst pth) @ [v']);\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map fst\n                              (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                                p\\<^sub>2) #\n                               pth)) @\n                           [v'])", "case terminal_path_empty"], ["proof (state)\nthis:\n  terminal_vertex v_\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       terminal_vertex v \\<Longrightarrow>\n       distinct (map fst (map fst []) @ [v])\n 2. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 v' pth.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        terminal_path v\\<^sub>2 v' pth;\n        distinct (map fst (map fst pth) @ [v']);\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map fst\n                              (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                                p\\<^sub>2) #\n                               pth)) @\n                           [v'])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (map fst []) @ [v_])", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (map fst []) @ [v_])\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 v' pth.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        terminal_path v\\<^sub>2 v' pth;\n        distinct (map fst (map fst pth) @ [v']);\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map fst\n                              (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                                p\\<^sub>2) #\n                               pth)) @\n                           [v'])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 v' pth.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        terminal_path v\\<^sub>2 v' pth;\n        distinct (map fst (map fst pth) @ [v']);\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map fst\n                              (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                                p\\<^sub>2) #\n                               pth)) @\n                           [v'])", "case (terminal_path_cons v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 v' pth)"], ["proof (state)\nthis:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n  terminal_path v\\<^sub>2 v' pth\n  hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\n  distinct (map fst (map fst pth) @ [v'])\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 v' pth.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        terminal_path v\\<^sub>2 v' pth;\n        distinct (map fst (map fst pth) @ [v']);\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map fst\n                              (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                                p\\<^sub>2) #\n                               pth)) @\n                           [v'])", "note terminal_path_cons.IH"], ["proof (state)\nthis:\n  distinct (map fst (map fst pth) @ [v'])\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 v' pth.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        terminal_path v\\<^sub>2 v' pth;\n        distinct (map fst (map fst pth) @ [v']);\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map fst\n                              (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                                p\\<^sub>2) #\n                               pth)) @\n                           [v'])", "moreover"], ["proof (state)\nthis:\n  distinct (map fst (map fst pth) @ [v'])\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 v' pth.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        terminal_path v\\<^sub>2 v' pth;\n        distinct (map fst (map fst pth) @ [v']);\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map fst\n                              (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                                p\\<^sub>2) #\n                               pth)) @\n                           [v'])", "have \"v\\<^sub>1 \\<notin> fst ` fst ` set pth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>1 \\<notin> fst ` fst ` set pth", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow> False", "assume \"v\\<^sub>1 \\<in> fst ` fst ` set pth\""], ["proof (state)\nthis:\n  v\\<^sub>1 \\<in> fst ` fst ` set pth\n\ngoal (1 subgoal):\n 1. v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v\\<^sub>1 \\<in> fst ` fst ` set pth", "obtain pth1 e' pth2 where \"pth = pth1@[e']@pth2\" and \"v\\<^sub>1 = fst (fst e')\""], ["proof (prove)\nusing this:\n  v\\<^sub>1 \\<in> fst ` fst ` set pth\n\ngoal (1 subgoal):\n 1. (\\<And>pth1 e' pth2.\n        \\<lbrakk>pth = pth1 @ [e'] @ pth2; v\\<^sub>1 = fst (fst e')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (atomize_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow>\n    \\<exists>pth1 e' pth2.\n       pth = pth1 @ [e'] @ pth2 \\<and> v\\<^sub>1 = fst (fst e')", "apply (induction pth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. v\\<^sub>1 \\<in> fst ` fst ` set [] \\<Longrightarrow>\n    \\<exists>pth1 e' pth2.\n       [] = pth1 @ [e'] @ pth2 \\<and> v\\<^sub>1 = fst (fst e')\n 2. \\<And>a pth.\n       \\<lbrakk>v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow>\n                \\<exists>pth1 e' pth2.\n                   pth = pth1 @ [e'] @ pth2 \\<and> v\\<^sub>1 = fst (fst e');\n        v\\<^sub>1 \\<in> fst ` fst ` set (a # pth)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth1 e' pth2.\n                            a # pth = pth1 @ [e'] @ pth2 \\<and>\n                            v\\<^sub>1 = fst (fst e')", "apply (solves simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a pth.\n       \\<lbrakk>v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow>\n                \\<exists>pth1 e' pth2.\n                   pth = pth1 @ [e'] @ pth2 \\<and> v\\<^sub>1 = fst (fst e');\n        v\\<^sub>1 \\<in> fst ` fst ` set (a # pth)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth1 e' pth2.\n                            a # pth = pth1 @ [e'] @ pth2 \\<and>\n                            v\\<^sub>1 = fst (fst e')", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b aa ba pth.\n       (v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow>\n        \\<exists>pth1 b a ba pth2.\n           pth = pth1 @ ((v\\<^sub>1, b), a, ba) # pth2) \\<Longrightarrow>\n       \\<exists>pth1 bb a bc pth2.\n          ((v\\<^sub>1, b), aa, ba) # pth =\n          pth1 @ ((v\\<^sub>1, bb), a, bc) # pth2\n 2. \\<And>a b aa ba pth bb ad bc.\n       \\<lbrakk>v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow>\n                \\<exists>pth1 b a ba pth2.\n                   pth = pth1 @ ((v\\<^sub>1, b), a, ba) # pth2;\n        ((v\\<^sub>1, bb), ad, bc) \\<in> set pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth1 bb ab bc pth2.\n                            ((a, b), aa, ba) # pth =\n                            pth1 @ ((v\\<^sub>1, bb), ab, bc) # pth2", "apply (solves \\<open>rule exI[where x = \"[]\"]; simp\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba pth bb ad bc.\n       \\<lbrakk>v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow>\n                \\<exists>pth1 b a ba pth2.\n                   pth = pth1 @ ((v\\<^sub>1, b), a, ba) # pth2;\n        ((v\\<^sub>1, bb), ad, bc) \\<in> set pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth1 bb ab bc pth2.\n                            ((a, b), aa, ba) # pth =\n                            pth1 @ ((v\\<^sub>1, bb), ab, bc) # pth2", "apply (metis Cons_eq_appendI image_eqI prod.sel(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pth = pth1 @ [e'] @ pth2\n  v\\<^sub>1 = fst (fst e')\n\ngoal (1 subgoal):\n 1. v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow> False", "with terminal_path_is_path[OF \\<open>terminal_path v\\<^sub>2 v' pth\\<close>]"], ["proof (chain)\npicking this:\n  path v\\<^sub>2 v' pth\n  pth = pth1 @ [e'] @ pth2\n  v\\<^sub>1 = fst (fst e')", "have \"path v\\<^sub>2 v\\<^sub>1 pth1\""], ["proof (prove)\nusing this:\n  path v\\<^sub>2 v' pth\n  pth = pth1 @ [e'] @ pth2\n  v\\<^sub>1 = fst (fst e')\n\ngoal (1 subgoal):\n 1. path v\\<^sub>2 v\\<^sub>1 pth1", "by (simp add:  path_split2 edge_begin_tup)"], ["proof (state)\nthis:\n  path v\\<^sub>2 v\\<^sub>1 pth1\n\ngoal (1 subgoal):\n 1. v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow> False", "with \\<open>((v\\<^sub>1, p\\<^sub>1), (v\\<^sub>2, p\\<^sub>2)) \\<in> _\\<close>"], ["proof (chain)\npicking this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n  path v\\<^sub>2 v\\<^sub>1 pth1", "have \"path v\\<^sub>1 v\\<^sub>1 (((v\\<^sub>1, p\\<^sub>1), (v\\<^sub>2, p\\<^sub>2)) # pth1)\""], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n  path v\\<^sub>2 v\\<^sub>1 pth1\n\ngoal (1 subgoal):\n 1. path v\\<^sub>1 v\\<^sub>1\n     (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth1)", "by (simp add: path_cons_simp)"], ["proof (state)\nthis:\n  path v\\<^sub>1 v\\<^sub>1\n   (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth1)\n\ngoal (1 subgoal):\n 1. v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  path v\\<^sub>1 v\\<^sub>1\n   (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth1)\n\ngoal (1 subgoal):\n 1. v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow> False", "from terminal_path_is_hyps_free[OF \\<open>terminal_path v\\<^sub>2 v' pth\\<close>]\n         \\<open>hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\\<close>\n         \\<open>pth = pth1@[e']@pth2\\<close>"], ["proof (chain)\npicking this:\n  hyps_free pth\n  hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\n  pth = pth1 @ [e'] @ pth2", "have \"hyps_free(((v\\<^sub>1, p\\<^sub>1), (v\\<^sub>2, p\\<^sub>2)) # pth1)\""], ["proof (prove)\nusing this:\n  hyps_free pth\n  hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\n  pth = pth1 @ [e'] @ pth2\n\ngoal (1 subgoal):\n 1. hyps_free (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth1)", "by (auto simp add: hyps_free_def)"], ["proof (state)\nthis:\n  hyps_free (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth1)\n\ngoal (1 subgoal):\n 1. v\\<^sub>1 \\<in> fst ` fst ` set pth \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  path v\\<^sub>1 v\\<^sub>1\n   (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth1)\n  hyps_free (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth1)", "show False"], ["proof (prove)\nusing this:\n  path v\\<^sub>1 v\\<^sub>1\n   (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth1)\n  hyps_free (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth1)\n\ngoal (1 subgoal):\n 1. False", "using hyps_free_acyclic"], ["proof (prove)\nusing this:\n  path v\\<^sub>1 v\\<^sub>1\n   (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth1)\n  hyps_free (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth1)\n  \\<lbrakk>path ?v ?v ?pth; hyps_free ?pth\\<rbrakk>\n  \\<Longrightarrow> ?pth = []\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v\\<^sub>1 \\<notin> fst ` fst ` set pth\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 v' pth.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        terminal_path v\\<^sub>2 v' pth;\n        distinct (map fst (map fst pth) @ [v']);\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map fst\n                              (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                                p\\<^sub>2) #\n                               pth)) @\n                           [v'])", "moreover"], ["proof (state)\nthis:\n  v\\<^sub>1 \\<notin> fst ` fst ` set pth\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 v' pth.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        terminal_path v\\<^sub>2 v' pth;\n        distinct (map fst (map fst pth) @ [v']);\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map fst\n                              (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                                p\\<^sub>2) #\n                               pth)) @\n                           [v'])", "have \"v\\<^sub>1 \\<noteq> v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>1 \\<noteq> v'", "using hyps_free_acyclic path_cons terminal_path_cons.hyps(1) terminal_path_cons.hyps(2) terminal_path_cons.hyps(3) terminal_path_is_hyps_free terminal_path_is_path"], ["proof (prove)\nusing this:\n  \\<lbrakk>path ?v ?v ?pth; hyps_free ?pth\\<rbrakk>\n  \\<Longrightarrow> ?pth = []\n  \\<lbrakk>?e \\<in> edges; path (edge_end ?e) ?v' ?pth\\<rbrakk>\n  \\<Longrightarrow> path (edge_begin ?e) ?v' (?e # ?pth)\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n  terminal_path v\\<^sub>2 v' pth\n  hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\n  terminal_path ?v ?v' ?pth \\<Longrightarrow> hyps_free ?pth\n  terminal_path ?v ?v' ?pth \\<Longrightarrow> path ?v ?v' ?pth\n\ngoal (1 subgoal):\n 1. v\\<^sub>1 \\<noteq> v'", "by fastforce"], ["proof (state)\nthis:\n  v\\<^sub>1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 v' pth.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        terminal_path v\\<^sub>2 v' pth;\n        distinct (map fst (map fst pth) @ [v']);\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (map fst\n                              (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                                p\\<^sub>2) #\n                               pth)) @\n                           [v'])", "ultimately"], ["proof (chain)\npicking this:\n  distinct (map fst (map fst pth) @ [v'])\n  v\\<^sub>1 \\<notin> fst ` fst ` set pth\n  v\\<^sub>1 \\<noteq> v'", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst (map fst pth) @ [v'])\n  v\\<^sub>1 \\<notin> fst ` fst ` set pth\n  v\\<^sub>1 \\<noteq> v'\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (map fst (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth)) @\n      [v'])", "by (auto simp add: comp_def)"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (map fst (((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) # pth)) @\n    [v'])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hyps_free_vertices_distinct':\n  assumes \"terminal_path v v' pth\"\n  shows \"distinct (v # map fst (map snd pth))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (v # map fst (map snd pth))", "using hyps_free_vertices_distinct[OF assms]"], ["proof (prove)\nusing this:\n  distinct (map fst (map fst pth) @ [v'])\n\ngoal (1 subgoal):\n 1. distinct (v # map fst (map snd pth))", "unfolding path_vertices_shift[OF terminal_path_is_path[OF assms]]"], ["proof (prove)\nusing this:\n  distinct (v # map fst (map snd pth))\n\ngoal (1 subgoal):\n 1. distinct (v # map fst (map snd pth))", "."], ["", "lemma hyps_free_limited:\n  assumes \"terminal_path v v' pth\"\n  shows \"length pth \\<le> fcard vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length pth \\<le> fcard vertices", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. length pth \\<le> fcard vertices", "have \"length pth = length (map fst (map fst pth))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length pth = length (map fst (map fst pth))", "by simp"], ["proof (state)\nthis:\n  length pth = length (map fst (map fst pth))\n\ngoal (1 subgoal):\n 1. length pth \\<le> fcard vertices", "also"], ["proof (state)\nthis:\n  length pth = length (map fst (map fst pth))\n\ngoal (1 subgoal):\n 1. length pth \\<le> fcard vertices", "from hyps_free_vertices_distinct[OF assms]"], ["proof (chain)\npicking this:\n  distinct (map fst (map fst pth) @ [v'])", "have \"distinct (map fst (map fst pth))\""], ["proof (prove)\nusing this:\n  distinct (map fst (map fst pth) @ [v'])\n\ngoal (1 subgoal):\n 1. distinct (map fst (map fst pth))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (map fst pth))\n\ngoal (1 subgoal):\n 1. length pth \\<le> fcard vertices", "hence \"length (map fst (map fst pth)) = card (set (map fst (map fst pth)))\""], ["proof (prove)\nusing this:\n  distinct (map fst (map fst pth))\n\ngoal (1 subgoal):\n 1. length (map fst (map fst pth)) = card (set (map fst (map fst pth)))", "by (rule distinct_card[symmetric])"], ["proof (state)\nthis:\n  length (map fst (map fst pth)) = card (set (map fst (map fst pth)))\n\ngoal (1 subgoal):\n 1. length pth \\<le> fcard vertices", "also"], ["proof (state)\nthis:\n  length (map fst (map fst pth)) = card (set (map fst (map fst pth)))\n\ngoal (1 subgoal):\n 1. length pth \\<le> fcard vertices", "have \"\\<dots> \\<le> card (fset vertices)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (map fst (map fst pth))) \\<le> card (fset vertices)", "proof (rule card_mono[OF finite_fset])"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map fst (map fst pth)) \\<subseteq> fset vertices", "from assms(1)"], ["proof (chain)\npicking this:\n  terminal_path v v' pth", "show \"set (map fst (map fst pth)) \\<subseteq> fset vertices\""], ["proof (prove)\nusing this:\n  terminal_path v v' pth\n\ngoal (1 subgoal):\n 1. set (map fst (map fst pth)) \\<subseteq> fset vertices", "by (induction v v' pth) (auto, metis valid_edges notin_fset case_prodD valid_out_port.simps)"], ["proof (state)\nthis:\n  set (map fst (map fst pth)) \\<subseteq> fset vertices\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (set (map fst (map fst pth))) \\<le> card (fset vertices)\n\ngoal (1 subgoal):\n 1. length pth \\<le> fcard vertices", "also"], ["proof (state)\nthis:\n  card (set (map fst (map fst pth))) \\<le> card (fset vertices)\n\ngoal (1 subgoal):\n 1. length pth \\<le> fcard vertices", "have \"\\<dots> = fcard vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (fset vertices) = fcard vertices", "by (simp add: fcard.rep_eq)"], ["proof (state)\nthis:\n  card (fset vertices) = fcard vertices\n\ngoal (1 subgoal):\n 1. length pth \\<le> fcard vertices", "finally"], ["proof (chain)\npicking this:\n  length pth \\<le> fcard vertices", "show ?thesis"], ["proof (prove)\nusing this:\n  length pth \\<le> fcard vertices\n\ngoal (1 subgoal):\n 1. length pth \\<le> fcard vertices", "."], ["proof (state)\nthis:\n  length pth \\<le> fcard vertices\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hyps_free_path_not_in_scope:\n  assumes \"terminal_path v t pth\"\n  assumes \"(v',p') \\<in> snd ` set pth\"\n  shows   \"v' \\<notin> scope (v, p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<notin> scope (v, p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p) \\<Longrightarrow> False", "assume \"v' \\<in> scope (v,p)\""], ["proof (state)\nthis:\n  v' \\<in> scope (v, p)\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p) \\<Longrightarrow> False", "from \\<open>(v',p') \\<in> snd ` set pth\\<close>"], ["proof (chain)\npicking this:\n  (v', p') \\<in> snd ` set pth", "obtain pth1 pth2 e  where \"pth = pth1@[e]@pth2\" and \"snd e = (v',p')\""], ["proof (prove)\nusing this:\n  (v', p') \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. (\\<And>pth1 e pth2.\n        \\<lbrakk>pth = pth1 @ [e] @ pth2; snd e = (v', p')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule snd_set_split)"], ["proof (state)\nthis:\n  pth = pth1 @ [e] @ pth2\n  snd e = (v', p')\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p) \\<Longrightarrow> False", "from terminal_path_is_path[OF assms(1), unfolded \\<open>pth = _ \\<close>] \\<open>snd e = _\\<close>"], ["proof (chain)\npicking this:\n  path v t (pth1 @ [e] @ pth2)\n  snd e = (v', p')", "have \"path v v' (pth1@[e])\" and \"path v' t pth2\""], ["proof (prove)\nusing this:\n  path v t (pth1 @ [e] @ pth2)\n  snd e = (v', p')\n\ngoal (1 subgoal):\n 1. path v v' (pth1 @ [e]) &&& path v' t pth2", "unfolding path_split"], ["proof (prove)\nusing this:\n  path v (edge_end e) (pth1 @ [e]) \\<and> path (edge_end e) t pth2\n  snd e = (v', p')\n\ngoal (1 subgoal):\n 1. path v v' (pth1 @ [e]) &&& path v' t pth2", "by (auto simp add: edge_end_tup)"], ["proof (state)\nthis:\n  path v v' (pth1 @ [e])\n  path v' t pth2\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p) \\<Longrightarrow> False", "from \\<open>v' \\<in> scope (v,p)\\<close> terminal_path_end_is_terminal[OF assms(1)] \\<open>path v' t pth2\\<close>"], ["proof (chain)\npicking this:\n  v' \\<in> scope (v, p)\n  terminal_vertex t\n  path v' t pth2", "have \"(v,p) \\<in> snd ` set pth2\""], ["proof (prove)\nusing this:\n  v' \\<in> scope (v, p)\n  terminal_vertex t\n  path v' t pth2\n\ngoal (1 subgoal):\n 1. (v, p) \\<in> snd ` set pth2", "by (rule scope_find)"], ["proof (state)\nthis:\n  (v, p) \\<in> snd ` set pth2\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (v, p) \\<in> snd ` set pth2", "obtain pth2a e' pth2b  where \"pth2 = pth2a@[e']@pth2b\" and \"snd e' = (v,p)\""], ["proof (prove)\nusing this:\n  (v, p) \\<in> snd ` set pth2\n\ngoal (1 subgoal):\n 1. (\\<And>pth2a e' pth2b.\n        \\<lbrakk>pth2 = pth2a @ [e'] @ pth2b; snd e' = (v, p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule snd_set_split)"], ["proof (state)\nthis:\n  pth2 = pth2a @ [e'] @ pth2b\n  snd e' = (v, p)\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p) \\<Longrightarrow> False", "from \\<open>path v' t pth2\\<close>[unfolded \\<open>pth2 = _ \\<close>] \\<open>snd e' = _\\<close>"], ["proof (chain)\npicking this:\n  path v' t (pth2a @ [e'] @ pth2b)\n  snd e' = (v, p)", "have \"path v' v (pth2a@[e'])\" and \"path v t pth2b\""], ["proof (prove)\nusing this:\n  path v' t (pth2a @ [e'] @ pth2b)\n  snd e' = (v, p)\n\ngoal (1 subgoal):\n 1. path v' v (pth2a @ [e']) &&& path v t pth2b", "unfolding path_split"], ["proof (prove)\nusing this:\n  path v' (edge_end e') (pth2a @ [e']) \\<and> path (edge_end e') t pth2b\n  snd e' = (v, p)\n\ngoal (1 subgoal):\n 1. path v' v (pth2a @ [e']) &&& path v t pth2b", "by (auto simp add: edge_end_tup)"], ["proof (state)\nthis:\n  path v' v (pth2a @ [e'])\n  path v t pth2b\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p) \\<Longrightarrow> False", "from \\<open>path v v' (pth1@[e])\\<close> \\<open>path v' v (pth2a@[e'])\\<close>"], ["proof (chain)\npicking this:\n  path v v' (pth1 @ [e])\n  path v' v (pth2a @ [e'])", "have \"path v v ((pth1@[e])@(pth2a@[e']))\""], ["proof (prove)\nusing this:\n  path v v' (pth1 @ [e])\n  path v' v (pth2a @ [e'])\n\ngoal (1 subgoal):\n 1. path v v ((pth1 @ [e]) @ pth2a @ [e'])", "by (rule path_appendI)"], ["proof (state)\nthis:\n  path v v ((pth1 @ [e]) @ pth2a @ [e'])\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  path v v ((pth1 @ [e]) @ pth2a @ [e'])\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p) \\<Longrightarrow> False", "from terminal_path_is_hyps_free[OF assms(1)] \\<open>pth = _\\<close> \\<open>pth2 = _\\<close>"], ["proof (chain)\npicking this:\n  hyps_free pth\n  pth = pth1 @ [e] @ pth2\n  pth2 = pth2a @ [e'] @ pth2b", "have \"hyps_free ((pth1@[e])@(pth2a@[e']))\""], ["proof (prove)\nusing this:\n  hyps_free pth\n  pth = pth1 @ [e] @ pth2\n  pth2 = pth2a @ [e'] @ pth2b\n\ngoal (1 subgoal):\n 1. hyps_free ((pth1 @ [e]) @ pth2a @ [e'])", "by (auto simp add: hyps_free_def)"], ["proof (state)\nthis:\n  hyps_free ((pth1 @ [e]) @ pth2a @ [e'])\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  path v v ((pth1 @ [e]) @ pth2a @ [e'])\n  hyps_free ((pth1 @ [e]) @ pth2a @ [e'])", "have \"((pth1@[e])@(pth2a@[e'])) = []\""], ["proof (prove)\nusing this:\n  path v v ((pth1 @ [e]) @ pth2a @ [e'])\n  hyps_free ((pth1 @ [e]) @ pth2a @ [e'])\n\ngoal (1 subgoal):\n 1. (pth1 @ [e]) @ pth2a @ [e'] = []", "by (rule hyps_free_acyclic)"], ["proof (state)\nthis:\n  (pth1 @ [e]) @ pth2a @ [e'] = []\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  (pth1 @ [e]) @ pth2a @ [e'] = []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>A saturated graph is one where every input port is incident to an edge.\\<close>"], ["", "locale Saturated_Graph = Port_Graph +\n  assumes saturated: \"valid_in_port (v,p) \\<Longrightarrow> \\<exists> e \\<in> edges . snd e = (v,p)\""], ["", "text \\<open>These four conditions make up a well-shaped graph.\\<close>"], ["", "locale Well_Shaped_Graph =  Well_Scoped_Graph + Acyclic_Graph + Saturated_Graph + Pruned_Port_Graph"], ["", "text \\<open>Next we demand an instantiation. This consists of a unique natural number per vertex,\nin order to rename the local constants apart, and furthermore a substitution per block\nwhich instantiates the schematic formulas given in @{term Labeled_Signature}.\\<close>"], ["", "locale Instantiation =\n  Vertex_Graph nodes _ _ vertices _ +\n  Labeled_Signature nodes  _ _ _ labelsIn labelsOut +\n  Abstract_Formulas freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP\n  for nodes :: \"'node stream\" and edges :: \"('vertex, 'outPort, 'inPort) edge set\" and vertices :: \"'vertex fset\" and labelsIn :: \"'node \\<Rightarrow> 'inPort \\<Rightarrow> 'form\" and labelsOut :: \"'node \\<Rightarrow> 'outPort \\<Rightarrow> 'form\" \n  and  freshenLC :: \"nat \\<Rightarrow> 'var \\<Rightarrow> 'var\" \n    and renameLCs :: \"('var \\<Rightarrow> 'var) \\<Rightarrow> 'form \\<Rightarrow> 'form\" \n    and lconsts :: \"'form \\<Rightarrow> 'var set\" \n    and closed :: \"'form \\<Rightarrow> bool\"\n    and subst :: \"'subst \\<Rightarrow> 'form \\<Rightarrow> 'form\" \n    and subst_lconsts :: \"'subst \\<Rightarrow> 'var set\" \n    and subst_renameLCs :: \"('var \\<Rightarrow> 'var) \\<Rightarrow> ('subst \\<Rightarrow> 'subst)\"\n    and anyP :: \"'form\" +\n  fixes vidx :: \"'vertex \\<Rightarrow> nat\"\n    and inst :: \"'vertex \\<Rightarrow> 'subst\"\n  assumes vidx_inj: \"inj_on vidx (fset vertices)\"\nbegin"], ["", "definition labelAtIn :: \"'vertex \\<Rightarrow> 'inPort \\<Rightarrow> 'form\"  where\n    \"labelAtIn v p = subst (inst v) (freshen (vidx v) (labelsIn (nodeOf v) p))\""], ["", "definition labelAtOut :: \"'vertex \\<Rightarrow> 'outPort \\<Rightarrow> 'form\"  where\n    \"labelAtOut v p = subst (inst v) (freshen (vidx v) (labelsOut (nodeOf v) p))\""], ["", "end"], ["", "text \\<open>A solution is an instantiation where on every edge, both incident ports are labeld with\nthe same formula.\\<close>"], ["", "locale Solution =\n  Instantiation _ _ _ _ _ edges for edges :: \"(('vertex \\<times> 'outPort) \\<times> 'vertex \\<times> 'inPort) set\" +\n  assumes solved: \"((v\\<^sub>1,p\\<^sub>1),(v\\<^sub>2,p\\<^sub>2)) \\<in> edges \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\""], ["", "locale Proof_Graph =  Well_Shaped_Graph + Solution"], ["", "text \\<open>If we have locally scoped constants, we demand that only blocks in the scope of the \ncorresponding input port may mention such a locally scoped variable in its substitution.\\<close>"], ["", "locale Well_Scoped_Instantiation =\n   Pre_Port_Graph  nodes inPorts outPorts vertices nodeOf edges +\n   Instantiation  inPorts outPorts nodeOf hyps nodes edges  vertices labelsIn labelsOut freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP vidx inst +\n   Port_Graph_Signature_Scoped_Vars nodes inPorts outPorts freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP local_vars\n   for freshenLC :: \"nat \\<Rightarrow> 'var \\<Rightarrow> 'var\" \n    and renameLCs :: \"('var \\<Rightarrow> 'var) \\<Rightarrow> 'form \\<Rightarrow> 'form\" \n    and lconsts :: \"'form \\<Rightarrow> 'var set\" \n    and closed :: \"'form \\<Rightarrow> bool\"\n    and subst :: \"'subst \\<Rightarrow> 'form \\<Rightarrow> 'form\" \n    and subst_lconsts :: \"'subst \\<Rightarrow> 'var set\" \n    and subst_renameLCs :: \"('var \\<Rightarrow> 'var) \\<Rightarrow> ('subst \\<Rightarrow> 'subst)\"\n    and anyP :: \"'form\"\n    and inPorts :: \"'node \\<Rightarrow> 'inPort fset\" \n    and outPorts :: \"'node \\<Rightarrow> 'outPort fset\" \n    and nodeOf :: \"'vertex \\<Rightarrow> 'node\" \n    and hyps :: \"'node \\<Rightarrow> 'outPort \\<Rightarrow> 'inPort option\" \n    and nodes :: \"'node stream\" \n    and vertices :: \"'vertex fset\" \n    and labelsIn :: \"'node \\<Rightarrow> 'inPort \\<Rightarrow> 'form\" \n    and labelsOut :: \"'node \\<Rightarrow> 'outPort \\<Rightarrow> 'form\" \n    and vidx :: \"'vertex \\<Rightarrow> nat\" \n    and inst :: \"'vertex \\<Rightarrow> 'subst\" \n    and edges :: \"('vertex, 'outPort, 'inPort) edge set\" \n    and local_vars :: \"'node \\<Rightarrow> 'inPort \\<Rightarrow> 'var set\" +\n  assumes well_scoped_inst:\n    \"valid_in_port (v,p) \\<Longrightarrow>\n     var \\<in> local_vars (nodeOf v) p \\<Longrightarrow>\n     v' |\\<in>| vertices \\<Longrightarrow>\n     freshenLC (vidx v) var \\<in> subst_lconsts (inst v') \\<Longrightarrow>\n     v' \\<in> scope (v,p)\"\nbegin"], ["", "lemma out_of_scope: \"valid_in_port (v,p) \\<Longrightarrow> v' |\\<in>| vertices \\<Longrightarrow> v' \\<notin> scope (v,p) \\<Longrightarrow> freshenLC (vidx v) ` local_vars (nodeOf v) p \\<inter> subst_lconsts (inst v') = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_in_port (v, p); v' |\\<in>| vertices;\n     v' \\<notin> scope (v, p)\\<rbrakk>\n    \\<Longrightarrow> freshenLC (vidx v) ` local_vars (nodeOf v) p \\<inter>\n                      subst_lconsts (inst v') =\n                      {}", "using well_scoped_inst"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_in_port (?v, ?p); ?var \\<in> local_vars (nodeOf ?v) ?p;\n   ?v' |\\<in>| vertices;\n   freshenLC (vidx ?v) ?var \\<in> subst_lconsts (inst ?v')\\<rbrakk>\n  \\<Longrightarrow> ?v' \\<in> scope (?v, ?p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_in_port (v, p); v' |\\<in>| vertices;\n     v' \\<notin> scope (v, p)\\<rbrakk>\n    \\<Longrightarrow> freshenLC (vidx v) ` local_vars (nodeOf v) p \\<inter>\n                      subst_lconsts (inst v') =\n                      {}", "by auto"], ["", "end"], ["", "text \\<open>The following locale assembles all these conditions.\\<close>"], ["", "locale Scoped_Proof_Graph =\n  Instantiation  inPorts outPorts nodeOf hyps nodes edges  vertices labelsIn labelsOut freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP vidx inst +\n  Well_Shaped_Graph  nodes inPorts outPorts vertices nodeOf edges hyps  +\n  Solution inPorts outPorts nodeOf hyps nodes vertices  labelsIn labelsOut freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP vidx inst edges +\n  Well_Scoped_Instantiation  freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP inPorts outPorts nodeOf hyps  nodes vertices labelsIn labelsOut vidx inst edges local_vars\n   for freshenLC :: \"nat \\<Rightarrow> 'var \\<Rightarrow> 'var\" \n    and renameLCs :: \"('var \\<Rightarrow> 'var) \\<Rightarrow> 'form \\<Rightarrow> 'form\" \n    and lconsts :: \"'form \\<Rightarrow> 'var set\" \n    and closed :: \"'form \\<Rightarrow> bool\"\n    and subst :: \"'subst \\<Rightarrow> 'form \\<Rightarrow> 'form\" \n    and subst_lconsts :: \"'subst \\<Rightarrow> 'var set\" \n    and subst_renameLCs :: \"('var \\<Rightarrow> 'var) \\<Rightarrow> ('subst \\<Rightarrow> 'subst)\"\n    and anyP :: \"'form\"\n    and inPorts :: \"'node \\<Rightarrow> 'inPort fset\" \n    and outPorts :: \"'node \\<Rightarrow> 'outPort fset\" \n    and nodeOf :: \"'vertex \\<Rightarrow> 'node\" \n    and hyps :: \"'node \\<Rightarrow> 'outPort \\<Rightarrow> 'inPort option\" \n    and nodes :: \"'node stream\" \n    and vertices :: \"'vertex fset\" \n    and labelsIn :: \"'node \\<Rightarrow> 'inPort \\<Rightarrow> 'form\" \n    and labelsOut :: \"'node \\<Rightarrow> 'outPort \\<Rightarrow> 'form\" \n    and vidx :: \"'vertex \\<Rightarrow> nat\" \n    and inst :: \"'vertex \\<Rightarrow> 'subst\" \n    and edges :: \"('vertex, 'outPort, 'inPort) edge  set\" \n    and local_vars :: \"'node \\<Rightarrow> 'inPort \\<Rightarrow> 'var set\""], ["", "end"]]}