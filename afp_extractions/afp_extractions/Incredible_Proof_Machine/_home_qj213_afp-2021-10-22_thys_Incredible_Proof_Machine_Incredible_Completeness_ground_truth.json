{"file_name": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine/Incredible_Completeness.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine", "problem_names": ["lemma\n  assumes \"c |\\<in>| conc_forms\"\n  shows ts_conc: \"snd (fst (root (ts c))) = c\"\n  and   ts_context: \"fst (fst (root (ts c))) |\\<subseteq>| ass_forms\"\n  and   ts_wf: \"wf (ts c)\"\n  and   ts_finite[simp]: \"tfinite (ts c)\"", "lemma iwf_it:\n  assumes \"c \\<in> set conclusions\"\n  shows \"plain_iwf (it' c) (fst (root (ts c)))\"", "lemma mem_vertices: \"v |\\<in>| vertices \\<longleftrightarrow>  (fst v \\<in> set conclusions \\<and> (snd v = [] \\<or> snd v \\<in> ((#) 0) ` it_paths (it' (fst v))))\"", "lemma prefixeq_vertices: \"(c,is) |\\<in>| vertices \\<Longrightarrow> prefix is' is \\<Longrightarrow> (c, is') |\\<in>| vertices\"", "lemma none_vertices[simp]: \"(c, []) |\\<in>| vertices \\<longleftrightarrow> c \\<in> set conclusions\"", "lemma some_vertices[simp]: \"(c, i#is) |\\<in>| vertices \\<longleftrightarrow> c \\<in> set conclusions \\<and> i = 0 \\<and> is \\<in> it_paths (it' c)\"", "lemma vertices_cases[consumes 1, case_names None Some]:\n  assumes \"v |\\<in>| vertices\"\n  obtains c where \"c \\<in> set conclusions\" and \"v = (c, [])\"\n      |   c \"is\" where \"c \\<in> set conclusions\" and \"is \\<in> it_paths (it' c)\" and \"v = (c, 0#is)\"", "lemma vertices_induct[consumes 1, case_names None Some]:\n  assumes \"v |\\<in>| vertices\"\n  assumes \"\\<And> c. c \\<in> set conclusions \\<Longrightarrow> P (c, [])\"\n  assumes \"\\<And> c is . c \\<in> set conclusions \\<Longrightarrow> is \\<in> it_paths (it' c) \\<Longrightarrow> P (c, 0#is)\"\n  shows \"P v\"", "lemma terminal_is_nil[simp]: \"v |\\<in>| vertices \\<Longrightarrow> outPorts (nodeOf v) = {||} \\<longleftrightarrow> snd v = []\"", "lemma fst_edge_from[simp]: \"fst (edge_from c is) = (c, 0 # is)\"", "lemma edge_to_Nil[simp]: \"edge_to c [] = ((c, []), plain_ant c)\"", "lemma edge_to_Snoc[simp]: \"edge_to c (is@[i]) = ((c, 0 # is), in_port_at ((c, 0 # is)) i)\"", "lemma fst_edge_at[simp]: \"fst (edge_at c is) = edge_from c is\"", "lemma snd_edge_at[simp]: \"snd (edge_at c is) = edge_to c is\"", "lemma hyps_exist':\n  assumes \"c \\<in> set conclusions\"\n  assumes \"is \\<in> it_paths (it' c)\"\n  assumes \"tree_at (it' c) is = (HNode i s ants)\"\n  shows \"subst s (freshen i anyP) \\<in> hyps_along (it' c) is\"", "lemma fst_hyp_edge_at[simp]:\n  \"fst (hyp_edge_at c is n s) = hyp_edge_from c is n s\"", "lemma snd_hyp_edge_at[simp]:\n  \"snd (hyp_edge_at c is n s) = hyp_edge_to c is\"", "lemma edge_from_valid_out_port:\n  assumes \"p \\<in> it_paths (it' c)\"\n  assumes \"c \\<in> set conclusions\"\n  shows \"valid_out_port (edge_from c p)\"", "lemma edge_to_valid_in_port:\n  assumes \"p \\<in> it_paths (it' c)\"\n  assumes \"c \\<in> set conclusions\"\n  shows \"valid_in_port (edge_to c p)\"", "lemma hyp_edge_from_valid_out_port:\n  assumes \"is \\<in> it_paths (it' c)\"\n  assumes \"c \\<in> set conclusions\"\n  assumes \"tree_at (it' c) is = HNode n s ants\"\n  shows \"valid_out_port (hyp_edge_from c is n s)\"", "lemma hyp_edge_to_valid_in_port:\n  assumes \"is \\<in> it_paths (it' c)\"\n  assumes \"c \\<in> set conclusions\"\n  assumes \"tree_at (it' c) is = HNode n s ants\"\n  shows \"valid_in_port (hyp_edge_to c is)\"", "lemma scope_valid:\n  \"scope' v i v' \\<Longrightarrow> v' |\\<in>| vertices\"", "lemma scope_valid_inport:\n  \"v' |\\<in>| vertices \\<Longrightarrow> scope' v ip  v' \\<longleftrightarrow> (\\<exists> i. fst v = fst v' \\<and> prefix (snd v@[i]) (snd v') \\<and> ip = in_port_at v i)\"", "lemma terminal_path_from_Nil[simp]:\n  \"terminal_path_from c [] = [edge_at c []]\"", "lemma terminal_path_from_Snoc[simp]:\n  \"terminal_path_from c (is @ [i]) = edge_at  c (is@[i]) # terminal_path_from c is\"", "lemma path_terminal_path_from:\n  \"c \\<in> set conclusions \\<Longrightarrow>\n  is \\<in> it_paths (it' c) \\<Longrightarrow>\n  path (c, 0 # is) (c, []) (terminal_path_from c is)\"", "lemma edge_step:\n  assumes \"(((a, b), ba), ((aa, bb), bc)) \\<in> edges\"\n  obtains \n    i where \"a = aa\" and \"b = bb@[i]\" and \"bc = in_port_at (aa,bb) i\"  and \"hyps (nodeOf (a, b)) ba = None\"\n  | i where \"a = aa\" and \"prefix (b@[i]) bb\" and \"hyps (nodeOf (a, b)) ba = Some (in_port_at (a,b) i)\"", "lemma path_has_prefixes:\n  assumes \"path v v' pth\"\n  assumes \"snd v' = []\"\n  assumes \"prefix (is' @ [i]) (snd v)\"\n  shows \"((fst v, is'), (in_port_at (fst v, is') i)) \\<in> snd ` set pth\"", "lemma in_scope: \"valid_in_port (v', p') \\<Longrightarrow> v \\<in> scope (v', p') \\<longleftrightarrow> scope' v' p' v\"", "lemma hyps_free_path_length:\n  assumes \"path v v' pth\"\n  assumes \"hyps_free pth\"\n  shows \"length pth + length (snd v') = length (snd v)\"", "lemma my_vidx_inj: \"inj_on vidx (fset vertices)\"", "lemma vidx_not_v_away[simp]: \"v |\\<in>| vertices \\<Longrightarrow> vidx v \\<noteq> v_away\"", "lemma node_disjoint_fresh_vars:\n  assumes \"n \\<in> sset nodes\"\n  assumes \"i < length (inPorts' n)\"\n  assumes \"i' < length (inPorts' n)\"\n  shows \"a_fresh (inPorts' n ! i) \\<inter> a_fresh (inPorts' n ! i') = {} \\<or> i = i'\""], "translations": [["", "lemma\n  assumes \"c |\\<in>| conc_forms\"\n  shows ts_conc: \"snd (fst (root (ts c))) = c\"\n  and   ts_context: \"fst (fst (root (ts c))) |\\<subseteq>| ass_forms\"\n  and   ts_wf: \"wf (ts c)\"\n  and   ts_finite[simp]: \"tfinite (ts c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd (fst (tree.root (ts c))) = c &&&\n     fst (fst (tree.root (ts c))) |\\<subseteq>| ass_forms) &&&\n    local.wf (ts c) &&& tfinite (ts c)", "unfolding atomize_conj conj_assoc ts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (tree.root\n               (SOME t.\n                   snd (fst (tree.root t)) = c \\<and>\n                   fst (fst (tree.root t)) |\\<subseteq>| ass_forms \\<and>\n                   local.wf t \\<and> tfinite t))) =\n    c \\<and>\n    fst (fst (tree.root\n               (SOME t.\n                   snd (fst (tree.root t)) = c \\<and>\n                   fst (fst (tree.root t)) |\\<subseteq>| ass_forms \\<and>\n                   local.wf t \\<and> tfinite t))) |\\<subseteq>|\n    ass_forms \\<and>\n    local.wf\n     (SOME t.\n         snd (fst (tree.root t)) = c \\<and>\n         fst (fst (tree.root t)) |\\<subseteq>| ass_forms \\<and>\n         local.wf t \\<and> tfinite t) \\<and>\n    tfinite\n     (SOME t.\n         snd (fst (tree.root t)) = c \\<and>\n         fst (fst (tree.root t)) |\\<subseteq>| ass_forms \\<and>\n         local.wf t \\<and> tfinite t)", "apply (rule someI_ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       snd (fst (tree.root x)) = c \\<and>\n       fst (fst (tree.root x)) |\\<subseteq>| ass_forms \\<and>\n       local.wf x \\<and> tfinite x", "using solved assms"], ["proof (prove)\nusing this:\n  solved\n  c |\\<in>| conc_forms\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       snd (fst (tree.root x)) = c \\<and>\n       fst (fst (tree.root x)) |\\<subseteq>| ass_forms \\<and>\n       local.wf x \\<and> tfinite x", "by (force simp add: solved_def)"], ["", "abbreviation it' where\n  \"it' c \\<equiv> globalize [fidx conc_forms c, 0] (freshenLC v_away) (to_it (ts c))\""], ["", "lemma iwf_it:\n  assumes \"c \\<in> set conclusions\"\n  shows \"plain_iwf (it' c) (fst (root (ts c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plain_iwf (it' c) (fst (tree.root (ts c)))", "using assms"], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. plain_iwf (it' c) (fst (tree.root (ts c)))", "apply (auto simp add: ts_conc conclusions_closed intro!: iwf_globalize' iwf_to_it ts_finite ts_wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<in> set conclusions;\n        x |\\<in>| fst (fst (tree.root (ts c)))\\<rbrakk>\n       \\<Longrightarrow> closed x", "by (meson assumptions_closed fset_mp mem_ass_forms mem_conc_forms ts_context)"], ["", "definition vertices :: \"'form vertex fset\"  where\n  \"vertices = Abs_fset (Union ( set (map (\\<lambda> c. insert (c, []) ((\\<lambda> p. (c, 0 # p)) ` (it_paths (it' c))))  conclusions)))\""], ["", "lemma mem_vertices: \"v |\\<in>| vertices \\<longleftrightarrow>  (fst v \\<in> set conclusions \\<and> (snd v = [] \\<or> snd v \\<in> ((#) 0) ` it_paths (it' (fst v))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v |\\<in>| vertices) =\n    (fst v \\<in> set conclusions \\<and>\n     (snd v = [] \\<or> snd v \\<in> (#) 0 ` it_paths (it' (fst v))))", "unfolding vertices_def fmember.rep_eq ffUnion.rep_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> fset\n              (Abs_fset\n                (\\<Union>\n                  (set (map (\\<lambda>c.\n                                insert (c, [])\n                                 ((\\<lambda>p. (c, 0 # p)) `\n                                  it_paths (it' c)))\n                         conclusions))))) =\n    (fst v \\<in> set conclusions \\<and>\n     (snd v = [] \\<or> snd v \\<in> (#) 0 ` it_paths (it' (fst v))))", "by (cases v)(auto simp add: Abs_fset_inverse Bex_def )"], ["", "lemma prefixeq_vertices: \"(c,is) |\\<in>| vertices \\<Longrightarrow> prefix is' is \\<Longrightarrow> (c, is') |\\<in>| vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(c, is) |\\<in>| vertices; prefix is' is\\<rbrakk>\n    \\<Longrightarrow> (c, is') |\\<in>| vertices", "by (cases is') (auto simp add: mem_vertices intro!: imageI elim: it_paths_prefix)"], ["", "lemma none_vertices[simp]: \"(c, []) |\\<in>| vertices \\<longleftrightarrow> c \\<in> set conclusions\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((c, []) |\\<in>| vertices) = (c \\<in> set conclusions)", "by (simp add: mem_vertices)"], ["", "lemma some_vertices[simp]: \"(c, i#is) |\\<in>| vertices \\<longleftrightarrow> c \\<in> set conclusions \\<and> i = 0 \\<and> is \\<in> it_paths (it' c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((c, i # is) |\\<in>| vertices) =\n    (c \\<in> set conclusions \\<and> i = 0 \\<and> is \\<in> it_paths (it' c))", "by (auto simp add: mem_vertices)"], ["", "lemma vertices_cases[consumes 1, case_names None Some]:\n  assumes \"v |\\<in>| vertices\"\n  obtains c where \"c \\<in> set conclusions\" and \"v = (c, [])\"\n      |   c \"is\" where \"c \\<in> set conclusions\" and \"is \\<in> it_paths (it' c)\" and \"v = (c, 0#is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c.\n                \\<lbrakk>c \\<in> set conclusions; v = (c, [])\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>c is.\n        \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n         v = (c, 0 # is)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c.\n                \\<lbrakk>c \\<in> set conclusions; v = (c, [])\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>c is.\n        \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n         v = (c, 0 # is)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases v; rename_tac \"is\"; case_tac \"is\"; auto)"], ["", "lemma vertices_induct[consumes 1, case_names None Some]:\n  assumes \"v |\\<in>| vertices\"\n  assumes \"\\<And> c. c \\<in> set conclusions \\<Longrightarrow> P (c, [])\"\n  assumes \"\\<And> c is . c \\<in> set conclusions \\<Longrightarrow> is \\<in> it_paths (it' c) \\<Longrightarrow> P (c, 0#is)\"\n  shows \"P v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P v", "using assms"], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n  ?c9 \\<in> set conclusions \\<Longrightarrow> P (?c9, [])\n  \\<lbrakk>?c9 \\<in> set conclusions; ?is9 \\<in> it_paths (it' ?c9)\\<rbrakk>\n  \\<Longrightarrow> P (?c9, 0 # ?is9)\n\ngoal (1 subgoal):\n 1. P v", "by (cases v; rename_tac \"is\"; case_tac \"is\"; auto)"], ["", "fun nodeOf :: \"'form vertex \\<Rightarrow> ('form, 'rule) graph_node\" where\n  \"nodeOf (pf, []) = Conclusion pf\"\n| \"nodeOf (pf, i#is) = iNodeOf (tree_at (it' pf) is)\""], ["", "fun inst where\n  \"inst (c,[]) = empty_subst\"\n |\"inst (c, i#is) = iSubst (tree_at (it' c) is)\""], ["", "lemma terminal_is_nil[simp]: \"v |\\<in>| vertices \\<Longrightarrow> outPorts (nodeOf v) = {||} \\<longleftrightarrow> snd v = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v |\\<in>| vertices \\<Longrightarrow>\n    (outPorts (nodeOf v) = {||}) = (snd v = [])", "by (induction v rule: nodeOf.induct)\n    (auto elim: iNodeOf_outPorts[rotated] iwf_it)"], ["", "sublocale Vertex_Graph nodes inPorts outPorts vertices nodeOf"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition edge_from :: \"'form \\<Rightarrow> nat list => ('form vertex \\<times> ('form,'var) out_port)\" where \n  \"edge_from c is = ((c, 0 # is),  Reg (iOutPort (tree_at (it' c) is)))\""], ["", "lemma fst_edge_from[simp]: \"fst (edge_from c is) = (c, 0 # is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (edge_from c is) = (c, 0 # is)", "by (simp add: edge_from_def)"], ["", "fun in_port_at :: \"('form \\<times> nat list) \\<Rightarrow> nat \\<Rightarrow> ('form,'var) in_port\" where\n    \"in_port_at (c, [])  _  = plain_ant c\"\n  | \"in_port_at (c, _#is) i = inPorts' (iNodeOf (tree_at (it' c) is)) ! i\""], ["", "definition edge_to :: \"'form \\<Rightarrow> nat list => ('form vertex \\<times> ('form,'var) in_port)\"  where\n \"edge_to c is =\n    (case rev is of   []   \\<Rightarrow> ((c, []),           in_port_at (c, []) 0)\n                    | i#is \\<Rightarrow> ((c, 0 # (rev is)), in_port_at (c, (0#rev is)) i))\""], ["", "lemma edge_to_Nil[simp]: \"edge_to c [] = ((c, []), plain_ant c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_to c [] = ((c, []), plain_ant c)", "by (simp add: edge_to_def)"], ["", "lemma edge_to_Snoc[simp]: \"edge_to c (is@[i]) = ((c, 0 # is), in_port_at ((c, 0 # is)) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edge_to c (is @ [i]) = ((c, 0 # is), in_port_at (c, 0 # is) i)", "by (simp add: edge_to_def)"], ["", "definition edge_at :: \"'form \\<Rightarrow> nat list => ('form, 'var) edge''\"  where\n   \"edge_at c is = (edge_from c is, edge_to c is)\""], ["", "lemma fst_edge_at[simp]: \"fst (edge_at c is) = edge_from c is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (edge_at c is) = edge_from c is", "by (simp add: edge_at_def)"], ["", "lemma snd_edge_at[simp]: \"snd (edge_at c is) = edge_to c is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (edge_at c is) = edge_to c is", "by (simp add: edge_at_def)"], ["", "lemma hyps_exist':\n  assumes \"c \\<in> set conclusions\"\n  assumes \"is \\<in> it_paths (it' c)\"\n  assumes \"tree_at (it' c) is = (HNode i s ants)\"\n  shows \"subst s (freshen i anyP) \\<in> hyps_along (it' c) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along (it' c) is", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along (it' c) is", "from assms(1)"], ["proof (chain)\npicking this:\n  c \\<in> set conclusions", "have \"plain_iwf (it' c) (fst (root (ts c)))\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. plain_iwf (it' c) (fst (tree.root (ts c)))", "by (rule iwf_it)"], ["proof (state)\nthis:\n  plain_iwf (it' c) (fst (tree.root (ts c)))\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along (it' c) is", "moreover"], ["proof (state)\nthis:\n  plain_iwf (it' c) (fst (tree.root (ts c)))\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along (it' c) is", "note assms(2,3)"], ["proof (state)\nthis:\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode i s ants\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along (it' c) is", "moreover"], ["proof (state)\nthis:\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode i s ants\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along (it' c) is", "have \"fst (fst (root (ts c))) |\\<subseteq>| ass_forms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst (tree.root (ts c))) |\\<subseteq>| ass_forms", "by (simp add: assms(1) ts_context)"], ["proof (state)\nthis:\n  fst (fst (tree.root (ts c))) |\\<subseteq>| ass_forms\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along (it' c) is", "ultimately"], ["proof (chain)\npicking this:\n  plain_iwf (it' c) (fst (tree.root (ts c)))\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode i s ants\n  fst (fst (tree.root (ts c))) |\\<subseteq>| ass_forms", "show ?thesis"], ["proof (prove)\nusing this:\n  plain_iwf (it' c) (fst (tree.root (ts c)))\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode i s ants\n  fst (fst (tree.root (ts c))) |\\<subseteq>| ass_forms\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along (it' c) is", "by (rule iwf_hyps_exist)"], ["proof (state)\nthis:\n  subst s (freshen i anyP) \\<in> hyps_along (it' c) is\n\ngoal:\nNo subgoals!", "qed"], ["", "definition hyp_edge_to :: \"'form \\<Rightarrow> nat list => ('form vertex \\<times> ('form,'var) in_port)\" where\n  \"hyp_edge_to c is = ((c, 0 # is),  plain_ant anyP)\""], ["", "(* TODO: Replace n and s by \"subst s (freshen n anyP)\" *)"], ["", "definition hyp_edge_from :: \"'form \\<Rightarrow> nat list => nat \\<Rightarrow> 'subst \\<Rightarrow> ('form vertex \\<times> ('form,'var) out_port)\" where\n  \"hyp_edge_from c is n s = \n    ((c, 0 # hyp_port_path_for (it' c) is (subst s (freshen n anyP))),\n     hyp_port_h_for (it' c) is (subst s (freshen n anyP)))\""], ["", "definition hyp_edge_at  :: \"'form \\<Rightarrow> nat list => nat \\<Rightarrow> 'subst \\<Rightarrow> ('form, 'var) edge''\" where\n  \"hyp_edge_at c is n s = (hyp_edge_from c is n s, hyp_edge_to c is)\""], ["", "lemma fst_hyp_edge_at[simp]:\n  \"fst (hyp_edge_at c is n s) = hyp_edge_from c is n s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (hyp_edge_at c is n s) = hyp_edge_from c is n s", "by (simp add:hyp_edge_at_def)"], ["", "lemma snd_hyp_edge_at[simp]:\n  \"snd (hyp_edge_at c is n s) = hyp_edge_to c is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (hyp_edge_at c is n s) = hyp_edge_to c is", "by (simp add:hyp_edge_at_def)"], ["", "inductive_set edges where\n  regular_edge: \"c \\<in> set conclusions \\<Longrightarrow> is \\<in> it_paths (it' c) \\<Longrightarrow> edge_at c is \\<in> edges\"\n  | hyp_edge: \"c \\<in> set conclusions \\<Longrightarrow> is \\<in> it_paths (it' c) \\<Longrightarrow> tree_at (it' c) is = HNode n s ants \\<Longrightarrow> hyp_edge_at c is n s \\<in> edges\""], ["", "sublocale Pre_Port_Graph nodes inPorts outPorts vertices nodeOf edges"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma edge_from_valid_out_port:\n  assumes \"p \\<in> it_paths (it' c)\"\n  assumes \"c \\<in> set conclusions\"\n  shows \"valid_out_port (edge_from c p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_out_port (edge_from c p)", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> it_paths (it' c)\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. valid_out_port (edge_from c p)", "by (auto simp add: edge_from_def intro: iwf_outPort iwf_it)"], ["", "lemma edge_to_valid_in_port:\n  assumes \"p \\<in> it_paths (it' c)\"\n  assumes \"c \\<in> set conclusions\"\n  shows \"valid_in_port (edge_to c p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in_port (edge_to c p)", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> it_paths (it' c)\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. valid_in_port (edge_to c p)", "apply (auto simp add: edge_to_def inPorts_fset_of split: list.split elim!: it_paths_SnocE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>c \\<in> set conclusions; p = rev x22 @ [x21];\n        rev x22 \\<in> it_paths (it' c);\n        x21 < length (children (tree_at (it' c) (rev x22)))\\<rbrakk>\n       \\<Longrightarrow> inPorts' (iNodeOf (tree_at (it' c) (rev x22))) !\n                         x21\n                         \\<in> set (inPorts'\n                                     (iNodeOf (tree_at (it' c) (rev x22))))", "apply (rule nth_mem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>c \\<in> set conclusions; p = rev x22 @ [x21];\n        rev x22 \\<in> it_paths (it' c);\n        x21 < length (children (tree_at (it' c) (rev x22)))\\<rbrakk>\n       \\<Longrightarrow> x21\n                         < length\n                            (inPorts' (iNodeOf (tree_at (it' c) (rev x22))))", "apply (drule (1) iwf_length_inPorts[OF iwf_it])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>p = rev x22 @ [x21]; rev x22 \\<in> it_paths (it' c);\n        x21 < length (children (tree_at (it' c) (rev x22)));\n        length (iAnts (tree_at (it' c) (rev x22)))\n        \\<le> length\n               (inPorts' (iNodeOf (tree_at (it' c) (rev x22))))\\<rbrakk>\n       \\<Longrightarrow> x21\n                         < length\n                            (inPorts' (iNodeOf (tree_at (it' c) (rev x22))))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hyp_edge_from_valid_out_port:\n  assumes \"is \\<in> it_paths (it' c)\"\n  assumes \"c \\<in> set conclusions\"\n  assumes \"tree_at (it' c) is = HNode n s ants\"\n  shows \"valid_out_port (hyp_edge_from c is n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_out_port (hyp_edge_from c is n s)", "using assms"], ["proof (prove)\nusing this:\n  is \\<in> it_paths (it' c)\n  c \\<in> set conclusions\n  tree_at (it' c) is = HNode n s ants\n\ngoal (1 subgoal):\n 1. valid_out_port (hyp_edge_from c is n s)", "by(auto simp add: hyp_edge_from_def intro: hyp_port_outPort it_paths_strict_prefix hyp_port_strict_prefix hyps_exist')"], ["", "lemma hyp_edge_to_valid_in_port:\n  assumes \"is \\<in> it_paths (it' c)\"\n  assumes \"c \\<in> set conclusions\"\n  assumes \"tree_at (it' c) is = HNode n s ants\"\n  shows \"valid_in_port (hyp_edge_to c is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in_port (hyp_edge_to c is)", "using assms"], ["proof (prove)\nusing this:\n  is \\<in> it_paths (it' c)\n  c \\<in> set conclusions\n  tree_at (it' c) is = HNode n s ants\n\ngoal (1 subgoal):\n 1. valid_in_port (hyp_edge_to c is)", "by (auto simp add: hyp_edge_to_def)"], ["", "inductive scope' :: \"'form vertex \\<Rightarrow> ('form,'var) in_port \\<Rightarrow> 'form \\<times> nat list \\<Rightarrow> bool\" where\n  \"c \\<in> set conclusions \\<Longrightarrow>\n   is' \\<in> ((#) 0) ` it_paths (it' c) \\<Longrightarrow>\n   prefix (is@[i]) is' \\<Longrightarrow> \n   ip = in_port_at (c,is) i \\<Longrightarrow>\n   scope' (c, is) ip (c, is')\""], ["", "inductive_simps scope_simp: \"scope' v i v'\""], ["", "inductive_cases scope_cases: \"scope' v i v'\""], ["", "lemma scope_valid:\n  \"scope' v i v' \\<Longrightarrow> v' |\\<in>| vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scope' v i v' \\<Longrightarrow> v' |\\<in>| vertices", "by (auto elim: scope_cases)"], ["", "lemma scope_valid_inport:\n  \"v' |\\<in>| vertices \\<Longrightarrow> scope' v ip  v' \\<longleftrightarrow> (\\<exists> i. fst v = fst v' \\<and> prefix (snd v@[i]) (snd v') \\<and> ip = in_port_at v i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' |\\<in>| vertices \\<Longrightarrow>\n    scope' v ip v' =\n    (\\<exists>i.\n        fst v = fst v' \\<and>\n        prefix (snd v @ [i]) (snd v') \\<and> ip = in_port_at v i)", "by (cases v; cases v')  (auto simp add: scope'.simps mem_vertices)"], ["", "definition terminal_path_from :: \"'form \\<Rightarrow> nat list => ('form, 'var) edge'' list\" where\n   \"terminal_path_from c is = map (edge_at c) (rev (prefixes is))\""], ["", "lemma terminal_path_from_Nil[simp]:\n  \"terminal_path_from c [] = [edge_at c []]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_path_from c [] = [edge_at c []]", "by (simp add: terminal_path_from_def)"], ["", "lemma terminal_path_from_Snoc[simp]:\n  \"terminal_path_from c (is @ [i]) = edge_at  c (is@[i]) # terminal_path_from c is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_path_from c (is @ [i]) =\n    edge_at c (is @ [i]) # terminal_path_from c is", "by (simp add: terminal_path_from_def)"], ["", "lemma path_terminal_path_from:\n  \"c \\<in> set conclusions \\<Longrightarrow>\n  is \\<in> it_paths (it' c) \\<Longrightarrow>\n  path (c, 0 # is) (c, []) (terminal_path_from c is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n    \\<Longrightarrow> path (c, 0 # is) (c, []) (terminal_path_from c is)", "by (induction \"is\" rule: rev_induct)\n   (auto simp add: path_cons_simp intro!: regular_edge elim: it_paths_SnocE)"], ["", "lemma edge_step:\n  assumes \"(((a, b), ba), ((aa, bb), bc)) \\<in> edges\"\n  obtains \n    i where \"a = aa\" and \"b = bb@[i]\" and \"bc = in_port_at (aa,bb) i\"  and \"hyps (nodeOf (a, b)) ba = None\"\n  | i where \"a = aa\" and \"prefix (b@[i]) bb\" and \"hyps (nodeOf (a, b)) ba = Some (in_port_at (a,b) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>a = aa; b = bb @ [i]; bc = in_port_at (aa, bb) i;\n                 hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>i.\n        \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n         hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  (((a, b), ba), (aa, bb), bc) \\<in> edges\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i.\n                \\<lbrakk>a = aa; b = bb @ [i]; bc = in_port_at (aa, bb) i;\n                 hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>i.\n        \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n         hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof(cases rule: edges.cases[consumes 1, case_names Reg Hyp])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c is.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>a = aa; b = bb @ [i];\n                    bc = in_port_at (aa, bb) i;\n                    hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n            hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (((a, b), ba), (aa, bb), bc) = edge_at c is;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c is n s ants.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>a = aa; b = bb @ [i];\n                    bc = in_port_at (aa, bb) i;\n                    hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n            hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (((a, b), ba), (aa, bb), bc) = hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Reg c \"is\")"], ["proof (state)\nthis:\n  (((a, b), ba), (aa, bb), bc) = edge_at c is\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n\ngoal (2 subgoals):\n 1. \\<And>c is.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>a = aa; b = bb @ [i];\n                    bc = in_port_at (aa, bb) i;\n                    hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n            hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (((a, b), ba), (aa, bb), bc) = edge_at c is;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c is n s ants.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>a = aa; b = bb @ [i];\n                    bc = in_port_at (aa, bb) i;\n                    hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n            hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (((a, b), ba), (aa, bb), bc) = hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  (((a, b), ba), (aa, bb), bc) = edge_at c is\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)", "obtain i where  \"a = aa\" and \"b = bb@[i]\" and \"bc = in_port_at (aa,bb) i\"  and \"hyps (nodeOf (a, b)) ba = None\""], ["proof (prove)\nusing this:\n  (((a, b), ba), (aa, bb), bc) = edge_at c is\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>a = aa; b = bb @ [i]; bc = in_port_at (aa, bb) i;\n         hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: edges.cases simp add: edge_at_def edge_from_def edge_to_def split: list.split list.split_asm)"], ["proof (state)\nthis:\n  a = aa\n  b = bb @ [i]\n  bc = in_port_at (aa, bb) i\n  hyps (nodeOf (a, b)) ba = None\n\ngoal (2 subgoals):\n 1. \\<And>c is.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>a = aa; b = bb @ [i];\n                    bc = in_port_at (aa, bb) i;\n                    hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n            hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (((a, b), ba), (aa, bb), bc) = edge_at c is;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>c is n s ants.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>a = aa; b = bb @ [i];\n                    bc = in_port_at (aa, bb) i;\n                    hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n            hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (((a, b), ba), (aa, bb), bc) = hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  a = aa\n  b = bb @ [i]\n  bc = in_port_at (aa, bb) i\n  hyps (nodeOf (a, b)) ba = None\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>a = aa; b = bb @ [i];\n                    bc = in_port_at (aa, bb) i;\n                    hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n            hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (((a, b), ba), (aa, bb), bc) = hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>a = aa; b = bb @ [i];\n                    bc = in_port_at (aa, bb) i;\n                    hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n            hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (((a, b), ba), (aa, bb), bc) = hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Hyp c \"is\" n s)"], ["proof (state)\nthis:\n  (((a, b), ba), (aa, bb), bc) = hyp_edge_at c is n s\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode n s ants_\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>a = aa; b = bb @ [i];\n                    bc = in_port_at (aa, bb) i;\n                    hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n            hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (((a, b), ba), (aa, bb), bc) = hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> thesis", "let ?i = \"hyp_port_i_for (it' c) is (subst s (freshen n anyP))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>a = aa; b = bb @ [i];\n                    bc = in_port_at (aa, bb) i;\n                    hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n            hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (((a, b), ba), (aa, bb), bc) = hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> thesis", "from Hyp"], ["proof (chain)\npicking this:\n  (((a, b), ba), (aa, bb), bc) = hyp_edge_at c is n s\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode n s ants_", "have \"a = aa\" and \"prefix (b@[?i]) bb\" and\n    \"hyps (nodeOf (a, b)) ba = Some (in_port_at (a,b) ?i)\""], ["proof (prove)\nusing this:\n  (((a, b), ba), (aa, bb), bc) = hyp_edge_at c is n s\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode n s ants_\n\ngoal (1 subgoal):\n 1. a = aa &&&\n    prefix (b @ [hyp_port_i_for (it' c) is (subst s (freshen n anyP))])\n     bb &&&\n    hyps (nodeOf (a, b)) ba =\n    Some\n     (in_port_at (a, b)\n       (hyp_port_i_for (it' c) is (subst s (freshen n anyP))))", "by (auto simp add: edge_at_def edge_from_def edge_to_def hyp_edge_at_def hyp_edge_to_def hyp_edge_from_def\n      intro: hyp_port_prefix hyps_exist' hyp_port_hyps)"], ["proof (state)\nthis:\n  a = aa\n  prefix (b @ [hyp_port_i_for (it' c) is (subst s (freshen n anyP))]) bb\n  hyps (nodeOf (a, b)) ba =\n  Some\n   (in_port_at (a, b)\n     (hyp_port_i_for (it' c) is (subst s (freshen n anyP))))\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>a = aa; b = bb @ [i];\n                    bc = in_port_at (aa, bb) i;\n                    hyps (nodeOf (a, b)) ba = None\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i.\n           \\<lbrakk>a = aa; prefix (b @ [i]) bb;\n            hyps (nodeOf (a, b)) ba = Some (in_port_at (a, b) i)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (((a, b), ba), (aa, bb), bc) = hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  a = aa\n  prefix (b @ [hyp_port_i_for (it' c) is (subst s (freshen n anyP))]) bb\n  hyps (nodeOf (a, b)) ba =\n  Some\n   (in_port_at (a, b)\n     (hyp_port_i_for (it' c) is (subst s (freshen n anyP))))\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_has_prefixes:\n  assumes \"path v v' pth\"\n  assumes \"snd v' = []\"\n  assumes \"prefix (is' @ [i]) (snd v)\"\n  shows \"((fst v, is'), (in_port_at (fst v, is') i)) \\<in> snd ` set pth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((fst v, is'), in_port_at (fst v, is') i) \\<in> snd ` set pth", "using assms"], ["proof (prove)\nusing this:\n  path v v' pth\n  snd v' = []\n  prefix (is' @ [i]) (snd v)\n\ngoal (1 subgoal):\n 1. ((fst v, is'), in_port_at (fst v, is') i) \\<in> snd ` set pth", "by (induction rule: path.induct)(auto elim!: edge_step dest: prefix_snocD)"], ["", "lemma in_scope: \"valid_in_port (v', p') \\<Longrightarrow> v \\<in> scope (v', p') \\<longleftrightarrow> scope' v' p' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in_port (v', p') \\<Longrightarrow>\n    (v \\<in> scope (v', p')) = scope' v' p' v", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_in_port (v', p'); v \\<in> scope (v', p')\\<rbrakk>\n    \\<Longrightarrow> scope' v' p' v\n 2. \\<lbrakk>valid_in_port (v', p'); scope' v' p' v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> scope (v', p')", "assume \"v \\<in> scope (v', p')\""], ["proof (state)\nthis:\n  v \\<in> scope (v', p')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_in_port (v', p'); v \\<in> scope (v', p')\\<rbrakk>\n    \\<Longrightarrow> scope' v' p' v\n 2. \\<lbrakk>valid_in_port (v', p'); scope' v' p' v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> scope (v', p')", "hence \"v |\\<in>| vertices\" and \"\\<And> pth t.  path v t pth \\<Longrightarrow> terminal_vertex t \\<Longrightarrow> (v', p') \\<in> snd ` set pth\""], ["proof (prove)\nusing this:\n  v \\<in> scope (v', p')\n\ngoal (1 subgoal):\n 1. v |\\<in>| vertices &&&\n    (\\<And>pth t.\n        \\<lbrakk>path v t pth; terminal_vertex t\\<rbrakk>\n        \\<Longrightarrow> (v', p') \\<in> snd ` set pth)", "by (auto simp add: scope.simps)"], ["proof (state)\nthis:\n  v |\\<in>| vertices\n  \\<lbrakk>path v ?t9 ?pth9; terminal_vertex ?t9\\<rbrakk>\n  \\<Longrightarrow> (v', p') \\<in> snd ` set ?pth9\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_in_port (v', p'); v \\<in> scope (v', p')\\<rbrakk>\n    \\<Longrightarrow> scope' v' p' v\n 2. \\<lbrakk>valid_in_port (v', p'); scope' v' p' v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> scope (v', p')", "from this"], ["proof (chain)\npicking this:\n  v |\\<in>| vertices\n  \\<lbrakk>path v ?t9 ?pth9; terminal_vertex ?t9\\<rbrakk>\n  \\<Longrightarrow> (v', p') \\<in> snd ` set ?pth9", "show \"scope' v' p' v\""], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n  \\<lbrakk>path v ?t9 ?pth9; terminal_vertex ?t9\\<rbrakk>\n  \\<Longrightarrow> (v', p') \\<in> snd ` set ?pth9\n\ngoal (1 subgoal):\n 1. scope' v' p' v", "proof (induction  rule: vertices_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>c \\<in> set conclusions;\n        \\<And>t pth.\n           \\<lbrakk>path (c, []) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, [])\n 2. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "case (None c)"], ["proof (state)\nthis:\n  c \\<in> set conclusions\n  \\<lbrakk>path (c, []) ?t9 ?pth9; terminal_vertex ?t9\\<rbrakk>\n  \\<Longrightarrow> (v', p') \\<in> snd ` set ?pth9\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>c \\<in> set conclusions;\n        \\<And>t pth.\n           \\<lbrakk>path (c, []) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, [])\n 2. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "from None(2)[of \"(c, [])\" \"[]\", simplified, OF None(1)]"], ["proof (chain)\npicking this:\n  False", "have False"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>c \\<in> set conclusions;\n        \\<And>t pth.\n           \\<lbrakk>path (c, []) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, [])\n 2. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "thus \"scope' v' p' (c, [])\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. scope' v' p' (c, [])", ".."], ["proof (state)\nthis:\n  scope' v' p' (c, [])\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "case (Some c \"is\")"], ["proof (state)\nthis:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  \\<lbrakk>path (c, 0 # is) ?t9 ?pth9; terminal_vertex ?t9\\<rbrakk>\n  \\<Longrightarrow> (v', p') \\<in> snd ` set ?pth9\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "from \\<open>c \\<in> set conclusions\\<close> \\<open>is \\<in> it_paths (it' c)\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)", "have \"path (c, 0#is) (c, []) (terminal_path_from c is)\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n\ngoal (1 subgoal):\n 1. path (c, 0 # is) (c, []) (terminal_path_from c is)", "by (rule path_terminal_path_from)"], ["proof (state)\nthis:\n  path (c, 0 # is) (c, []) (terminal_path_from c is)\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "moreover"], ["proof (state)\nthis:\n  path (c, 0 # is) (c, []) (terminal_path_from c is)\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "from \\<open>c \\<in> set conclusions\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> set conclusions", "have \"terminal_vertex (c, [])\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. terminal_vertex (c, [])", "by simp"], ["proof (state)\nthis:\n  terminal_vertex (c, [])\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "ultimately"], ["proof (chain)\npicking this:\n  path (c, 0 # is) (c, []) (terminal_path_from c is)\n  terminal_vertex (c, [])", "have \"(v', p') \\<in> snd ` set (terminal_path_from c is)\""], ["proof (prove)\nusing this:\n  path (c, 0 # is) (c, []) (terminal_path_from c is)\n  terminal_vertex (c, [])\n\ngoal (1 subgoal):\n 1. (v', p') \\<in> snd ` set (terminal_path_from c is)", "by (rule Some(3))"], ["proof (state)\nthis:\n  (v', p') \\<in> snd ` set (terminal_path_from c is)\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "hence \"(v',p') \\<in> set (map (edge_to c) (prefixes is))\""], ["proof (prove)\nusing this:\n  (v', p') \\<in> snd ` set (terminal_path_from c is)\n\ngoal (1 subgoal):\n 1. (v', p') \\<in> set (map (edge_to c) (prefixes is))", "unfolding terminal_path_from_def"], ["proof (prove)\nusing this:\n  (v', p') \\<in> snd ` set (map (edge_at c) (rev (prefixes is)))\n\ngoal (1 subgoal):\n 1. (v', p') \\<in> set (map (edge_to c) (prefixes is))", "by auto"], ["proof (state)\nthis:\n  (v', p') \\<in> set (map (edge_to c) (prefixes is))\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "then"], ["proof (chain)\npicking this:\n  (v', p') \\<in> set (map (edge_to c) (prefixes is))", "obtain is' where \"prefix is' is\" and \"(v',p') = edge_to c is'\""], ["proof (prove)\nusing this:\n  (v', p') \\<in> set (map (edge_to c) (prefixes is))\n\ngoal (1 subgoal):\n 1. (\\<And>is'.\n        \\<lbrakk>prefix is' is; (v', p') = edge_to c is'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prefix is' is\n  (v', p') = edge_to c is'\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        \\<And>t pth.\n           \\<lbrakk>path (c, 0 # is) t pth; terminal_vertex t\\<rbrakk>\n           \\<Longrightarrow> (v', p') \\<in> snd ` set pth\\<rbrakk>\n       \\<Longrightarrow> scope' v' p' (c, 0 # is)", "show \"scope' v' p' (c, 0#is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scope' v' p' (c, 0 # is)", "proof(cases \"is'\" rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. is' = [] \\<Longrightarrow> scope' v' p' (c, 0 # is)\n 2. \\<And>ys y. is' = ys @ [y] \\<Longrightarrow> scope' v' p' (c, 0 # is)", "case Nil"], ["proof (state)\nthis:\n  is' = []\n\ngoal (2 subgoals):\n 1. is' = [] \\<Longrightarrow> scope' v' p' (c, 0 # is)\n 2. \\<And>ys y. is' = ys @ [y] \\<Longrightarrow> scope' v' p' (c, 0 # is)", "with \\<open>(v',p') = edge_to c is'\\<close>"], ["proof (chain)\npicking this:\n  (v', p') = edge_to c is'\n  is' = []", "have \"v' = (c, [])\" and \"p' = plain_ant c\""], ["proof (prove)\nusing this:\n  (v', p') = edge_to c is'\n  is' = []\n\ngoal (1 subgoal):\n 1. v' = (c, []) &&& p' = plain_ant c", "by (auto simp add: edge_to_def)"], ["proof (state)\nthis:\n  v' = (c, [])\n  p' = plain_ant c\n\ngoal (2 subgoals):\n 1. is' = [] \\<Longrightarrow> scope' v' p' (c, 0 # is)\n 2. \\<And>ys y. is' = ys @ [y] \\<Longrightarrow> scope' v' p' (c, 0 # is)", "with \\<open>c \\<in> set conclusions\\<close> \\<open>is \\<in> it_paths (it' c)\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  v' = (c, [])\n  p' = plain_ant c", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  v' = (c, [])\n  p' = plain_ant c\n\ngoal (1 subgoal):\n 1. scope' v' p' (c, 0 # is)", "by (auto intro!: scope'.intros)"], ["proof (state)\nthis:\n  scope' v' p' (c, 0 # is)\n\ngoal (1 subgoal):\n 1. \\<And>ys y. is' = ys @ [y] \\<Longrightarrow> scope' v' p' (c, 0 # is)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y. is' = ys @ [y] \\<Longrightarrow> scope' v' p' (c, 0 # is)", "case (snoc is'' i)"], ["proof (state)\nthis:\n  is' = is'' @ [i]\n\ngoal (1 subgoal):\n 1. \\<And>ys y. is' = ys @ [y] \\<Longrightarrow> scope' v' p' (c, 0 # is)", "with \\<open>(v',p') = edge_to c is'\\<close>"], ["proof (chain)\npicking this:\n  (v', p') = edge_to c is'\n  is' = is'' @ [i]", "have \"v' = (c, 0 # is'')\" and \"p' = in_port_at v' i\""], ["proof (prove)\nusing this:\n  (v', p') = edge_to c is'\n  is' = is'' @ [i]\n\ngoal (1 subgoal):\n 1. v' = (c, 0 # is'') &&& p' = in_port_at v' i", "by (auto simp add: edge_to_def)"], ["proof (state)\nthis:\n  v' = (c, 0 # is'')\n  p' = in_port_at v' i\n\ngoal (1 subgoal):\n 1. \\<And>ys y. is' = ys @ [y] \\<Longrightarrow> scope' v' p' (c, 0 # is)", "with \\<open>c \\<in> set conclusions\\<close> \\<open>is \\<in> it_paths (it' c)\\<close> \\<open>prefix is' is\\<close>[unfolded snoc]"], ["proof (chain)\npicking this:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  prefix (is'' @ [i]) is\n  v' = (c, 0 # is'')\n  p' = in_port_at v' i", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  prefix (is'' @ [i]) is\n  v' = (c, 0 # is'')\n  p' = in_port_at v' i\n\ngoal (1 subgoal):\n 1. scope' v' p' (c, 0 # is)", "by (auto intro!: scope'.intros)"], ["proof (state)\nthis:\n  scope' v' p' (c, 0 # is)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  scope' v' p' (c, 0 # is)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  scope' v' p' v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_in_port (v', p'); scope' v' p' v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> scope (v', p')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_in_port (v', p'); scope' v' p' v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> scope (v', p')", "assume \"valid_in_port (v', p')\""], ["proof (state)\nthis:\n  valid_in_port (v', p')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_in_port (v', p'); scope' v' p' v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> scope (v', p')", "assume \"scope' v' p' v\""], ["proof (state)\nthis:\n  scope' v' p' v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_in_port (v', p'); scope' v' p' v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> scope (v', p')", "then"], ["proof (chain)\npicking this:\n  scope' v' p' v", "obtain c is' i \"is\" where\n    \"v' = (c, is')\" and \"v = (c, is)\" and \"c \\<in> set conclusions\" and\n    \"p' = in_port_at v' i\" and\n    \"is \\<in> (#) 0 ` it_paths (it' c)\" and  \"prefix (is' @ [i]) is\""], ["proof (prove)\nusing this:\n  scope' v' p' v\n\ngoal (1 subgoal):\n 1. (\\<And>c is' is i.\n        \\<lbrakk>v' = (c, is'); v = (c, is); c \\<in> set conclusions;\n         p' = in_port_at v' i; is \\<in> (#) 0 ` it_paths (it' c);\n         prefix (is' @ [i]) is\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: scope'.simps)"], ["proof (state)\nthis:\n  v' = (c, is')\n  v = (c, is)\n  c \\<in> set conclusions\n  p' = in_port_at v' i\n  is \\<in> (#) 0 ` it_paths (it' c)\n  prefix (is' @ [i]) is\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_in_port (v', p'); scope' v' p' v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> scope (v', p')", "from \\<open>scope' v' p' v\\<close>"], ["proof (chain)\npicking this:\n  scope' v' p' v", "have \"(c, is) |\\<in>| vertices\""], ["proof (prove)\nusing this:\n  scope' v' p' v\n\ngoal (1 subgoal):\n 1. (c, is) |\\<in>| vertices", "unfolding \\<open>v = _\\<close>"], ["proof (prove)\nusing this:\n  scope' v' p' (c, is)\n\ngoal (1 subgoal):\n 1. (c, is) |\\<in>| vertices", "by (rule scope_valid)"], ["proof (state)\nthis:\n  (c, is) |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_in_port (v', p'); scope' v' p' v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> scope (v', p')", "hence \"(c, is) \\<in> scope ((c, is'), p')\""], ["proof (prove)\nusing this:\n  (c, is) |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. (c, is) \\<in> scope ((c, is'), p')", "proof(rule scope.intros)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pth v'.\n       \\<lbrakk>path (c, is) v' pth; terminal_vertex v'\\<rbrakk>\n       \\<Longrightarrow> ((c, is'), p') \\<in> snd ` set pth", "fix pth t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pth v'.\n       \\<lbrakk>path (c, is) v' pth; terminal_vertex v'\\<rbrakk>\n       \\<Longrightarrow> ((c, is'), p') \\<in> snd ` set pth", "assume \"path (c,is) t pth\""], ["proof (state)\nthis:\n  path (c, is) t pth\n\ngoal (1 subgoal):\n 1. \\<And>pth v'.\n       \\<lbrakk>path (c, is) v' pth; terminal_vertex v'\\<rbrakk>\n       \\<Longrightarrow> ((c, is'), p') \\<in> snd ` set pth", "assume \"terminal_vertex t\""], ["proof (state)\nthis:\n  terminal_vertex t\n\ngoal (1 subgoal):\n 1. \\<And>pth v'.\n       \\<lbrakk>path (c, is) v' pth; terminal_vertex v'\\<rbrakk>\n       \\<Longrightarrow> ((c, is'), p') \\<in> snd ` set pth", "hence \"snd t = []\""], ["proof (prove)\nusing this:\n  terminal_vertex t\n\ngoal (1 subgoal):\n 1. snd t = []", "by auto"], ["proof (state)\nthis:\n  snd t = []\n\ngoal (1 subgoal):\n 1. \\<And>pth v'.\n       \\<lbrakk>path (c, is) v' pth; terminal_vertex v'\\<rbrakk>\n       \\<Longrightarrow> ((c, is'), p') \\<in> snd ` set pth", "from path_has_prefixes[OF \\<open>path (c,is) t pth\\<close> \\<open>snd t = []\\<close>, simplified, OF \\<open>prefix (is' @ [i]) is\\<close>]"], ["proof (chain)\npicking this:\n  ((c, is'), in_port_at (c, is') i) \\<in> snd ` set pth", "show \"((c, is'), p') \\<in> snd ` set pth\""], ["proof (prove)\nusing this:\n  ((c, is'), in_port_at (c, is') i) \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. ((c, is'), p') \\<in> snd ` set pth", "unfolding \\<open>p' = _ \\<close> \\<open>v' = _ \\<close>"], ["proof (prove)\nusing this:\n  ((c, is'), in_port_at (c, is') i) \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. ((c, is'), in_port_at (c, is') i) \\<in> snd ` set pth", "."], ["proof (state)\nthis:\n  ((c, is'), p') \\<in> snd ` set pth\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (c, is) \\<in> scope ((c, is'), p')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_in_port (v', p'); scope' v' p' v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> scope (v', p')", "thus \"v \\<in> scope (v', p')\""], ["proof (prove)\nusing this:\n  (c, is) \\<in> scope ((c, is'), p')\n\ngoal (1 subgoal):\n 1. v \\<in> scope (v', p')", "using \\<open>v =_\\<close> \\<open>v' = _\\<close>"], ["proof (prove)\nusing this:\n  (c, is) \\<in> scope ((c, is'), p')\n  v = (c, is)\n  v' = (c, is')\n\ngoal (1 subgoal):\n 1. v \\<in> scope (v', p')", "by simp"], ["proof (state)\nthis:\n  v \\<in> scope (v', p')\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale Port_Graph nodes inPorts outPorts vertices nodeOf edges"], ["proof (prove)\ngoal (1 subgoal):\n 1. Port_Graph nodes inPorts outPorts vertices nodeOf edges", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nodeOf ` fset vertices \\<subseteq> i.R nodes\n 2. \\<forall>(ps1, ps2)\\<in>edges.\n       valid_out_port ps1 \\<and> valid_in_port ps2", "show \"nodeOf ` fset vertices \\<subseteq> sset nodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodeOf ` fset vertices \\<subseteq> i.R nodes", "apply (auto simp add: fmember.rep_eq[symmetric] mem_vertices)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>a \\<in> set conclusions; x \\<in> it_paths (it' a)\\<rbrakk>\n       \\<Longrightarrow> iNodeOf (tree_at (it' a) x) \\<in> i.R nodes", "apply (auto simp add: stream.set_map dest: iNodeOf_tree_at[OF iwf_it])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nodeOf ` fset vertices \\<subseteq> i.R nodes\n\ngoal (1 subgoal):\n 1. \\<forall>(ps1, ps2)\\<in>edges.\n       valid_out_port ps1 \\<and> valid_in_port ps2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(ps1, ps2)\\<in>edges.\n       valid_out_port ps1 \\<and> valid_in_port ps2", "have \"\\<forall> e \\<in> edges. valid_out_port (fst e) \\<and> valid_in_port (snd e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>edges.\n       valid_out_port (fst e) \\<and> valid_in_port (snd e)", "by (auto elim!: edges.cases simp add: edge_at_def\n        dest: edge_from_valid_out_port edge_to_valid_in_port\n        dest: hyp_edge_from_valid_out_port hyp_edge_to_valid_in_port)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>edges. valid_out_port (fst e) \\<and> valid_in_port (snd e)\n\ngoal (1 subgoal):\n 1. \\<forall>(ps1, ps2)\\<in>edges.\n       valid_out_port ps1 \\<and> valid_in_port ps2", "thus \"\\<forall>(ps1, ps2)\\<in>edges. valid_out_port ps1 \\<and> valid_in_port ps2\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>edges. valid_out_port (fst e) \\<and> valid_in_port (snd e)\n\ngoal (1 subgoal):\n 1. \\<forall>(ps1, ps2)\\<in>edges.\n       valid_out_port ps1 \\<and> valid_in_port ps2", "by auto"], ["proof (state)\nthis:\n  \\<forall>(ps1, ps2)\\<in>edges. valid_out_port ps1 \\<and> valid_in_port ps2\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale Scoped_Graph nodes inPorts outPorts vertices nodeOf edges hyps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Scoped_Graph nodes inPorts outPorts vertices nodeOf edges hyps", ".."], ["", "lemma hyps_free_path_length:\n  assumes \"path v v' pth\"\n  assumes \"hyps_free pth\"\n  shows \"length pth + length (snd v') = length (snd v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length pth + length (snd v') = length (snd v)", "using assms"], ["proof (prove)\nusing this:\n  path v v' pth\n  hyps_free pth\n\ngoal (1 subgoal):\n 1. length pth + length (snd v') = length (snd v)", "by induction (auto elim!: edge_step )"], ["", "fun vidx :: \"'form vertex \\<Rightarrow> nat\" where\n   \"vidx (c, [])   = isidx [fidx conc_forms c]\"\n  |\"vidx (c, _#is) = iAnnot (tree_at (it' c) is)\""], ["", "lemma my_vidx_inj: \"inj_on vidx (fset vertices)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on vidx (fset vertices)", "by (rule inj_onI)\n     (auto simp add:  mem_vertices[unfolded fmember.rep_eq] iAnnot_globalize simp del: iAnnot.simps)"], ["", "lemma vidx_not_v_away[simp]: \"v |\\<in>| vertices \\<Longrightarrow> vidx v \\<noteq> v_away\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v |\\<in>| vertices \\<Longrightarrow> vidx v \\<noteq> v_away", "by (cases v rule:vidx.cases) (auto simp add: iAnnot_globalize  simp del: iAnnot.simps)"], ["", "sublocale Instantiation inPorts outPorts nodeOf hyps  nodes edges vertices labelsIn labelsOut freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP vidx inst"], ["proof (prove)\ngoal (1 subgoal):\n 1. Instantiation inPorts outPorts hyps vertices freshenLC renameLCs lconsts\n     closed subst subst_lconsts subst_renameLCs anyP vidx", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on vidx (fset vertices)", "show \"inj_on vidx (fset vertices)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on vidx (fset vertices)", "by (rule my_vidx_inj)"], ["proof (state)\nthis:\n  inj_on vidx (fset vertices)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale  Well_Scoped_Graph nodes inPorts outPorts vertices nodeOf edges hyps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Well_Scoped_Graph nodes inPorts outPorts vertices nodeOf edges hyps", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 p'.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p'\\<rbrakk>\n       \\<Longrightarrow> (v\\<^sub>2, p\\<^sub>2) = (v\\<^sub>1, p') \\<or>\n                         v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')", "fix v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 p'.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p'\\<rbrakk>\n       \\<Longrightarrow> (v\\<^sub>2, p\\<^sub>2) = (v\\<^sub>1, p') \\<or>\n                         v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')", "assume assms: \"((v\\<^sub>1, p\\<^sub>1), (v\\<^sub>2, p\\<^sub>2)) \\<in> edges\" \"hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p'\""], ["proof (state)\nthis:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n  hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p'\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 p'.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p'\\<rbrakk>\n       \\<Longrightarrow> (v\\<^sub>2, p\\<^sub>2) = (v\\<^sub>1, p') \\<or>\n                         v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')", "from assms(1) hyps_correct[OF assms(2)]"], ["proof (chain)\npicking this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n  p\\<^sub>1 |\\<in>| outPorts (nodeOf v\\<^sub>1) \\<and>\n  p' |\\<in>| inPorts (nodeOf v\\<^sub>1)", "have \"valid_out_port (v\\<^sub>1, p\\<^sub>1)\" and \"valid_in_port (v\\<^sub>2, p\\<^sub>2)\" and \"valid_in_port (v\\<^sub>1, p')\" and \"v\\<^sub>2 |\\<in>| vertices\""], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n  p\\<^sub>1 |\\<in>| outPorts (nodeOf v\\<^sub>1) \\<and>\n  p' |\\<in>| inPorts (nodeOf v\\<^sub>1)\n\ngoal (1 subgoal):\n 1. (valid_out_port (v\\<^sub>1, p\\<^sub>1) &&&\n     valid_in_port (v\\<^sub>2, p\\<^sub>2)) &&&\n    valid_in_port (v\\<^sub>1, p') &&& v\\<^sub>2 |\\<in>| vertices", "using valid_edges"], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n  p\\<^sub>1 |\\<in>| outPorts (nodeOf v\\<^sub>1) \\<and>\n  p' |\\<in>| inPorts (nodeOf v\\<^sub>1)\n  \\<forall>(ps1, ps2)\\<in>edges. valid_out_port ps1 \\<and> valid_in_port ps2\n\ngoal (1 subgoal):\n 1. (valid_out_port (v\\<^sub>1, p\\<^sub>1) &&&\n     valid_in_port (v\\<^sub>2, p\\<^sub>2)) &&&\n    valid_in_port (v\\<^sub>1, p') &&& v\\<^sub>2 |\\<in>| vertices", "by auto"], ["proof (state)\nthis:\n  valid_out_port (v\\<^sub>1, p\\<^sub>1)\n  valid_in_port (v\\<^sub>2, p\\<^sub>2)\n  valid_in_port (v\\<^sub>1, p')\n  v\\<^sub>2 |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 p'.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p'\\<rbrakk>\n       \\<Longrightarrow> (v\\<^sub>2, p\\<^sub>2) = (v\\<^sub>1, p') \\<or>\n                         v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')", "from assms"], ["proof (chain)\npicking this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n  hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p'", "have \"\\<exists> i. fst v\\<^sub>1 = fst v\\<^sub>2 \\<and> prefix (snd v\\<^sub>1@[i]) (snd v\\<^sub>2) \\<and> p' = in_port_at v\\<^sub>1 i\""], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n  hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p'\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       fst v\\<^sub>1 = fst v\\<^sub>2 \\<and>\n       prefix (snd v\\<^sub>1 @ [i]) (snd v\\<^sub>2) \\<and>\n       p' = in_port_at v\\<^sub>1 i", "by (cases v\\<^sub>1; cases v\\<^sub>2; auto elim!: edge_step)"], ["proof (state)\nthis:\n  \\<exists>i.\n     fst v\\<^sub>1 = fst v\\<^sub>2 \\<and>\n     prefix (snd v\\<^sub>1 @ [i]) (snd v\\<^sub>2) \\<and>\n     p' = in_port_at v\\<^sub>1 i\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 p'.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p'\\<rbrakk>\n       \\<Longrightarrow> (v\\<^sub>2, p\\<^sub>2) = (v\\<^sub>1, p') \\<or>\n                         v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')", "hence \"scope' v\\<^sub>1 p' v\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<exists>i.\n     fst v\\<^sub>1 = fst v\\<^sub>2 \\<and>\n     prefix (snd v\\<^sub>1 @ [i]) (snd v\\<^sub>2) \\<and>\n     p' = in_port_at v\\<^sub>1 i\n\ngoal (1 subgoal):\n 1. scope' v\\<^sub>1 p' v\\<^sub>2", "unfolding scope_valid_inport[OF \\<open>v\\<^sub>2 |\\<in>| vertices\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>i.\n     fst v\\<^sub>1 = fst v\\<^sub>2 \\<and>\n     prefix (snd v\\<^sub>1 @ [i]) (snd v\\<^sub>2) \\<and>\n     p' = in_port_at v\\<^sub>1 i\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       fst v\\<^sub>1 = fst v\\<^sub>2 \\<and>\n       prefix (snd v\\<^sub>1 @ [i]) (snd v\\<^sub>2) \\<and>\n       p' = in_port_at v\\<^sub>1 i", "."], ["proof (state)\nthis:\n  scope' v\\<^sub>1 p' v\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 p'.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p'\\<rbrakk>\n       \\<Longrightarrow> (v\\<^sub>2, p\\<^sub>2) = (v\\<^sub>1, p') \\<or>\n                         v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')", "hence \"v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')\""], ["proof (prove)\nusing this:\n  scope' v\\<^sub>1 p' v\\<^sub>2\n\ngoal (1 subgoal):\n 1. v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')", "unfolding in_scope[OF \\<open>valid_in_port (v\\<^sub>1, p')\\<close>]"], ["proof (prove)\nusing this:\n  scope' v\\<^sub>1 p' v\\<^sub>2\n\ngoal (1 subgoal):\n 1. scope' v\\<^sub>1 p' v\\<^sub>2", "."], ["proof (state)\nthis:\n  v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 p'.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges;\n        hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = Some p'\\<rbrakk>\n       \\<Longrightarrow> (v\\<^sub>2, p\\<^sub>2) = (v\\<^sub>1, p') \\<or>\n                         v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')", "thus \"(v\\<^sub>2, p\\<^sub>2) = (v\\<^sub>1, p') \\<or> v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')\""], ["proof (prove)\nusing this:\n  v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')\n\ngoal (1 subgoal):\n 1. (v\\<^sub>2, p\\<^sub>2) = (v\\<^sub>1, p') \\<or>\n    v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')", ".."], ["proof (state)\nthis:\n  (v\\<^sub>2, p\\<^sub>2) = (v\\<^sub>1, p') \\<or>\n  v\\<^sub>2 \\<in> scope (v\\<^sub>1, p')\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale Acyclic_Graph nodes inPorts outPorts vertices nodeOf edges hyps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Acyclic_Graph nodes inPorts outPorts vertices nodeOf edges hyps", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v pth.\n       \\<lbrakk>path v v pth; hyps_free pth\\<rbrakk>\n       \\<Longrightarrow> pth = []", "fix v pth"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v pth.\n       \\<lbrakk>path v v pth; hyps_free pth\\<rbrakk>\n       \\<Longrightarrow> pth = []", "assume \"path v v pth\" and \"hyps_free pth\""], ["proof (state)\nthis:\n  path v v pth\n  hyps_free pth\n\ngoal (1 subgoal):\n 1. \\<And>v pth.\n       \\<lbrakk>path v v pth; hyps_free pth\\<rbrakk>\n       \\<Longrightarrow> pth = []", "from hyps_free_path_length[OF this]"], ["proof (chain)\npicking this:\n  length pth + length (snd v) = length (snd v)", "show \"pth = []\""], ["proof (prove)\nusing this:\n  length pth + length (snd v) = length (snd v)\n\ngoal (1 subgoal):\n 1. pth = []", "by simp"], ["proof (state)\nthis:\n  pth = []\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale Saturated_Graph nodes inPorts outPorts vertices nodeOf edges"], ["proof (prove)\ngoal (1 subgoal):\n 1. Saturated_Graph nodes inPorts outPorts vertices nodeOf edges", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p.\n       valid_in_port (v, p) \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = (v, p)", "fix v p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p.\n       valid_in_port (v, p) \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = (v, p)", "assume \"valid_in_port (v, p)\""], ["proof (state)\nthis:\n  valid_in_port (v, p)\n\ngoal (1 subgoal):\n 1. \\<And>v p.\n       valid_in_port (v, p) \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = (v, p)", "thus \"\\<exists>e\\<in>edges. snd e = (v, p)\""], ["proof (prove)\nusing this:\n  valid_in_port (v, p)\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>edges. snd e = (v, p)", "proof(induction v)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       valid_in_port ((a, b), p) \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((a, b), p)", "fix c cis"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       valid_in_port ((a, b), p) \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((a, b), p)", "assume \"valid_in_port ((c, cis), p)\""], ["proof (state)\nthis:\n  valid_in_port ((c, cis), p)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       valid_in_port ((a, b), p) \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((a, b), p)", "hence \"c \\<in> set conclusions\""], ["proof (prove)\nusing this:\n  valid_in_port ((c, cis), p)\n\ngoal (1 subgoal):\n 1. c \\<in> set conclusions", "by (auto simp add: mem_vertices)"], ["proof (state)\nthis:\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       valid_in_port ((a, b), p) \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((a, b), p)", "show \"\\<exists>e\\<in>edges. snd e = ((c, cis), p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "proof(cases cis)"], ["proof (state)\ngoal (2 subgoals):\n 1. cis = [] \\<Longrightarrow> \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "case Nil"], ["proof (state)\nthis:\n  cis = []\n\ngoal (2 subgoals):\n 1. cis = [] \\<Longrightarrow> \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "with \\<open>valid_in_port ((c, cis), p)\\<close>"], ["proof (chain)\npicking this:\n  valid_in_port ((c, cis), p)\n  cis = []", "have [simp]: \"p = plain_ant c\""], ["proof (prove)\nusing this:\n  valid_in_port ((c, cis), p)\n  cis = []\n\ngoal (1 subgoal):\n 1. p = plain_ant c", "by simp"], ["proof (state)\nthis:\n  p = plain_ant c\n\ngoal (2 subgoals):\n 1. cis = [] \\<Longrightarrow> \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "have \"[] \\<in> it_paths (it' c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> it_paths (it' c)", "by simp"], ["proof (state)\nthis:\n  [] \\<in> it_paths (it' c)\n\ngoal (2 subgoals):\n 1. cis = [] \\<Longrightarrow> \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "with \\<open>c \\<in> set conclusions\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> set conclusions\n  [] \\<in> it_paths (it' c)", "have \"edge_at c [] \\<in> edges\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  [] \\<in> it_paths (it' c)\n\ngoal (1 subgoal):\n 1. edge_at c [] \\<in> edges", "by (rule regular_edge)"], ["proof (state)\nthis:\n  edge_at c [] \\<in> edges\n\ngoal (2 subgoals):\n 1. cis = [] \\<Longrightarrow> \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "moreover"], ["proof (state)\nthis:\n  edge_at c [] \\<in> edges\n\ngoal (2 subgoals):\n 1. cis = [] \\<Longrightarrow> \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "have \"snd (edge_at c []) = ((c, []), plain_ant c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (edge_at c []) = ((c, []), plain_ant c)", "by (simp add: edge_to_def)"], ["proof (state)\nthis:\n  snd (edge_at c []) = ((c, []), plain_ant c)\n\ngoal (2 subgoals):\n 1. cis = [] \\<Longrightarrow> \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "ultimately"], ["proof (chain)\npicking this:\n  edge_at c [] \\<in> edges\n  snd (edge_at c []) = ((c, []), plain_ant c)", "show ?thesis"], ["proof (prove)\nusing this:\n  edge_at c [] \\<in> edges\n  snd (edge_at c []) = ((c, []), plain_ant c)\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "by (auto simp add: Nil simp del: snd_edge_at)"], ["proof (state)\nthis:\n  \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "case (Cons c' \"is\")"], ["proof (state)\nthis:\n  cis = c' # is\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "with \\<open>valid_in_port ((c, cis), p)\\<close>"], ["proof (chain)\npicking this:\n  valid_in_port ((c, cis), p)\n  cis = c' # is", "have [simp]: \"c' = 0\" and \"is \\<in> it_paths (it' c)\"\n        and \"p |\\<in>| inPorts (iNodeOf (tree_at (it' c) is))\""], ["proof (prove)\nusing this:\n  valid_in_port ((c, cis), p)\n  cis = c' # is\n\ngoal (1 subgoal):\n 1. c' = 0 &&&\n    is \\<in> it_paths (it' c) &&&\n    p |\\<in>| inPorts (iNodeOf (tree_at (it' c) is))", "by auto"], ["proof (state)\nthis:\n  c' = 0\n  is \\<in> it_paths (it' c)\n  p |\\<in>| inPorts (iNodeOf (tree_at (it' c) is))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "from this(3)"], ["proof (chain)\npicking this:\n  p |\\<in>| inPorts (iNodeOf (tree_at (it' c) is))", "obtain i where\n        \"i < length (inPorts' (iNodeOf (tree_at (it' c) is)))\" and\n        \"p = inPorts' (iNodeOf (tree_at (it' c) is)) ! i\""], ["proof (prove)\nusing this:\n  p |\\<in>| inPorts (iNodeOf (tree_at (it' c) is))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length (inPorts' (iNodeOf (tree_at (it' c) is)));\n         p = inPorts' (iNodeOf (tree_at (it' c) is)) ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: inPorts_fset_of in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length (inPorts' (iNodeOf (tree_at (it' c) is)))\n  p = inPorts' (iNodeOf (tree_at (it' c) is)) ! i\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cis = a # list \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "proof (cases \"tree_at (it' c) is\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       tree_at (it' c) is = RNode x1 x2 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "case [simp]: (RNode r ants)"], ["proof (state)\nthis:\n  tree_at (it' c) is = RNode r ants\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       tree_at (it' c) is = RNode x1 x2 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "proof(cases r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       r = I x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "case I"], ["proof (state)\nthis:\n  r = I x11_ x12_ x13_ x14_\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       r = I x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "hence \"\\<not> isHNode (tree_at (it' c) is)\""], ["proof (prove)\nusing this:\n  r = I x11_ x12_ x13_ x14_\n\ngoal (1 subgoal):\n 1. \\<not> isHNode (tree_at (it' c) is)", "by simp"], ["proof (state)\nthis:\n  \\<not> isHNode (tree_at (it' c) is)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       r = I x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "from iwf_length_inPorts_not_HNode[OF iwf_it[OF \\<open>c \\<in> set conclusions\\<close>]  \\<open>is \\<in> it_paths (it' c)\\<close> this]\n               \\<open>i < length (inPorts' (iNodeOf (tree_at (it' c) is)))\\<close>"], ["proof (chain)\npicking this:\n  length (iAnts (tree_at (it' c) is)) =\n  length (inPorts' (iNodeOf (tree_at (it' c) is)))\n  i < length (inPorts' (iNodeOf (tree_at (it' c) is)))", "have \"i < length (children (tree_at (it' c) is))\""], ["proof (prove)\nusing this:\n  length (iAnts (tree_at (it' c) is)) =\n  length (inPorts' (iNodeOf (tree_at (it' c) is)))\n  i < length (inPorts' (iNodeOf (tree_at (it' c) is)))\n\ngoal (1 subgoal):\n 1. i < length (children (tree_at (it' c) is))", "by simp"], ["proof (state)\nthis:\n  i < length (children (tree_at (it' c) is))\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       r = I x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "with \\<open>is \\<in> it_paths (it' c)\\<close>"], ["proof (chain)\npicking this:\n  is \\<in> it_paths (it' c)\n  i < length (children (tree_at (it' c) is))", "have \"is@[i] \\<in> it_paths (it' c)\""], ["proof (prove)\nusing this:\n  is \\<in> it_paths (it' c)\n  i < length (children (tree_at (it' c) is))\n\ngoal (1 subgoal):\n 1. is @ [i] \\<in> it_paths (it' c)", "by (rule it_path_SnocI)"], ["proof (state)\nthis:\n  is @ [i] \\<in> it_paths (it' c)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       r = I x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "from \\<open>c \\<in> set conclusions\\<close> this"], ["proof (chain)\npicking this:\n  c \\<in> set conclusions\n  is @ [i] \\<in> it_paths (it' c)", "have \"edge_at c (is@[i]) \\<in> edges\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  is @ [i] \\<in> it_paths (it' c)\n\ngoal (1 subgoal):\n 1. edge_at c (is @ [i]) \\<in> edges", "by (rule regular_edge)"], ["proof (state)\nthis:\n  edge_at c (is @ [i]) \\<in> edges\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       r = I x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "moreover"], ["proof (state)\nthis:\n  edge_at c (is @ [i]) \\<in> edges\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       r = I x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "have \"snd (edge_at c (is@[i])) = ((c, 0 # is),  inPorts' (iNodeOf (tree_at (it' c) is)) ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (edge_at c (is @ [i])) =\n    ((c, 0 # is), inPorts' (iNodeOf (tree_at (it' c) is)) ! i)", "by (simp add: edge_to_def)"], ["proof (state)\nthis:\n  snd (edge_at c (is @ [i])) =\n  ((c, 0 # is), inPorts' (iNodeOf (tree_at (it' c) is)) ! i)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12 x13 x14.\n       r = I x11 x12 x13 x14 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n 2. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "ultimately"], ["proof (chain)\npicking this:\n  edge_at c (is @ [i]) \\<in> edges\n  snd (edge_at c (is @ [i])) =\n  ((c, 0 # is), inPorts' (iNodeOf (tree_at (it' c) is)) ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  edge_at c (is @ [i]) \\<in> edges\n  snd (edge_at c (is @ [i])) =\n  ((c, 0 # is), inPorts' (iNodeOf (tree_at (it' c) is)) ! i)\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "by (auto simp add: Cons \\<open>p = _\\<close> simp del: snd_edge_at)"], ["proof (state)\nthis:\n  \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "case (H n s)"], ["proof (state)\nthis:\n  r = H n s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "hence \"tree_at (it' c) is = HNode n s ants\""], ["proof (prove)\nusing this:\n  r = H n s\n\ngoal (1 subgoal):\n 1. tree_at (it' c) is = HNode n s ants", "by simp"], ["proof (state)\nthis:\n  tree_at (it' c) is = HNode n s ants\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "from \\<open>c \\<in> set conclusions\\<close> \\<open>is \\<in> it_paths (it' c)\\<close>  this"], ["proof (chain)\npicking this:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode n s ants", "have \"hyp_edge_at c is n s \\<in> edges\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode n s ants\n\ngoal (1 subgoal):\n 1. hyp_edge_at c is n s \\<in> edges", ".."], ["proof (state)\nthis:\n  hyp_edge_at c is n s \\<in> edges\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "moreover"], ["proof (state)\nthis:\n  hyp_edge_at c is n s \\<in> edges\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "from H \\<open>p |\\<in>| inPorts (iNodeOf (tree_at (it' c) is))\\<close>"], ["proof (chain)\npicking this:\n  r = H n s\n  p |\\<in>| inPorts (iNodeOf (tree_at (it' c) is))", "have [simp]: \"p = plain_ant anyP\""], ["proof (prove)\nusing this:\n  r = H n s\n  p |\\<in>| inPorts (iNodeOf (tree_at (it' c) is))\n\ngoal (1 subgoal):\n 1. p = plain_ant anyP", "by simp"], ["proof (state)\nthis:\n  p = plain_ant anyP\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "have \"snd (hyp_edge_at c is n s) = ((c, 0 # is), p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (hyp_edge_at c is n s) = ((c, 0 # is), p)", "by (simp add: hyp_edge_to_def)"], ["proof (state)\nthis:\n  snd (hyp_edge_at c is n s) = ((c, 0 # is), p)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       r = H x21 x22 \\<Longrightarrow>\n       \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "ultimately"], ["proof (chain)\npicking this:\n  hyp_edge_at c is n s \\<in> edges\n  snd (hyp_edge_at c is n s) = ((c, 0 # is), p)", "show ?thesis"], ["proof (prove)\nusing this:\n  hyp_edge_at c is n s \\<in> edges\n  snd (hyp_edge_at c is n s) = ((c, 0 # is), p)\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>edges. snd e = ((c, cis), p)", "by (auto simp add: Cons simp del: snd_hyp_edge_at)"], ["proof (state)\nthis:\n  \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e\\<in>edges. snd e = ((c, cis), p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e\\<in>edges. snd e = (v, p)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale Pruned_Port_Graph nodes inPorts outPorts vertices nodeOf edges"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pruned_Port_Graph nodes inPorts outPorts vertices nodeOf edges", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v |\\<in>| vertices \\<Longrightarrow>\n       \\<exists>pth v'. path v v' pth \\<and> terminal_vertex v'", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v |\\<in>| vertices \\<Longrightarrow>\n       \\<exists>pth v'. path v v' pth \\<and> terminal_vertex v'", "assume \"v |\\<in>| vertices\""], ["proof (state)\nthis:\n  v |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v |\\<in>| vertices \\<Longrightarrow>\n       \\<exists>pth v'. path v v' pth \\<and> terminal_vertex v'", "thus \"\\<exists>pth v'. path v v' pth \\<and> terminal_vertex v'\""], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<exists>pth v'. path v v' pth \\<and> terminal_vertex v'", "proof(induct rule: vertices_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       c \\<in> set conclusions \\<Longrightarrow>\n       \\<exists>pth v'. path (c, []) v' pth \\<and> terminal_vertex v'\n 2. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth v'.\n                            path (c, 0 # is) v' pth \\<and>\n                            terminal_vertex v'", "case (None c)"], ["proof (state)\nthis:\n  c \\<in> set conclusions\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       c \\<in> set conclusions \\<Longrightarrow>\n       \\<exists>pth v'. path (c, []) v' pth \\<and> terminal_vertex v'\n 2. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth v'.\n                            path (c, 0 # is) v' pth \\<and>\n                            terminal_vertex v'", "hence \"terminal_vertex (c,[])\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. terminal_vertex (c, [])", "by simp"], ["proof (state)\nthis:\n  terminal_vertex (c, [])\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       c \\<in> set conclusions \\<Longrightarrow>\n       \\<exists>pth v'. path (c, []) v' pth \\<and> terminal_vertex v'\n 2. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth v'.\n                            path (c, 0 # is) v' pth \\<and>\n                            terminal_vertex v'", "with path.intros(1)"], ["proof (chain)\npicking this:\n  path ?v ?v []\n  terminal_vertex (c, [])", "show ?case"], ["proof (prove)\nusing this:\n  path ?v ?v []\n  terminal_vertex (c, [])\n\ngoal (1 subgoal):\n 1. \\<exists>pth v'. path (c, []) v' pth \\<and> terminal_vertex v'", "by blast"], ["proof (state)\nthis:\n  \\<exists>pth v'. path (c, []) v' pth \\<and> terminal_vertex v'\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth v'.\n                            path (c, 0 # is) v' pth \\<and>\n                            terminal_vertex v'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth v'.\n                            path (c, 0 # is) v' pth \\<and>\n                            terminal_vertex v'", "case (Some c \"is\")"], ["proof (state)\nthis:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth v'.\n                            path (c, 0 # is) v' pth \\<and>\n                            terminal_vertex v'", "hence \"path (c, 0 # is) (c, []) (terminal_path_from c is)\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n\ngoal (1 subgoal):\n 1. path (c, 0 # is) (c, []) (terminal_path_from c is)", "by (rule path_terminal_path_from)"], ["proof (state)\nthis:\n  path (c, 0 # is) (c, []) (terminal_path_from c is)\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth v'.\n                            path (c, 0 # is) v' pth \\<and>\n                            terminal_vertex v'", "moreover"], ["proof (state)\nthis:\n  path (c, 0 # is) (c, []) (terminal_path_from c is)\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth v'.\n                            path (c, 0 # is) v' pth \\<and>\n                            terminal_vertex v'", "have \"terminal_vertex (c,[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_vertex (c, [])", "using Some(1)"], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. terminal_vertex (c, [])", "by simp"], ["proof (state)\nthis:\n  terminal_vertex (c, [])\n\ngoal (1 subgoal):\n 1. \\<And>c is.\n       \\<lbrakk>c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pth v'.\n                            path (c, 0 # is) v' pth \\<and>\n                            terminal_vertex v'", "ultimately"], ["proof (chain)\npicking this:\n  path (c, 0 # is) (c, []) (terminal_path_from c is)\n  terminal_vertex (c, [])", "show ?case"], ["proof (prove)\nusing this:\n  path (c, 0 # is) (c, []) (terminal_path_from c is)\n  terminal_vertex (c, [])\n\ngoal (1 subgoal):\n 1. \\<exists>pth v'. path (c, 0 # is) v' pth \\<and> terminal_vertex v'", "by blast"], ["proof (state)\nthis:\n  \\<exists>pth v'. path (c, 0 # is) v' pth \\<and> terminal_vertex v'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pth v'. path v v' pth \\<and> terminal_vertex v'\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale Well_Shaped_Graph  nodes inPorts outPorts vertices nodeOf edges hyps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Well_Shaped_Graph nodes inPorts outPorts vertices nodeOf edges hyps", ".."], ["", "sublocale sol:Solution inPorts outPorts nodeOf hyps nodes vertices  labelsIn labelsOut freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP vidx inst edges"], ["proof (prove)\ngoal (1 subgoal):\n 1. Solution inPorts outPorts nodeOf hyps vertices labelsIn labelsOut\n     freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs\n     anyP vidx inst edges", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2.\n       ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n       \\<in> edges \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "fix v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2.\n       ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n       \\<in> edges \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "assume \"((v\\<^sub>1, p\\<^sub>1), (v\\<^sub>2, p\\<^sub>2)) \\<in> edges\""], ["proof (state)\nthis:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n\ngoal (1 subgoal):\n 1. \\<And>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2.\n       ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n       \\<in> edges \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "thus \"labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\""], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges\n\ngoal (1 subgoal):\n 1. labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "proof(cases rule:edges.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c is.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                edge_at c is;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "case (regular_edge c \"is\")"], ["proof (state)\nthis:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = edge_at c is\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n\ngoal (2 subgoals):\n 1. \\<And>c is.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                edge_at c is;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "from \\<open>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = edge_at c is\\<close>"], ["proof (chain)\npicking this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = edge_at c is", "have \"(v\\<^sub>1,p\\<^sub>1) = edge_from c is\""], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = edge_at c is\n\ngoal (1 subgoal):\n 1. (v\\<^sub>1, p\\<^sub>1) = edge_from c is", "using fst_edge_at"], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = edge_at c is\n  fst (edge_at ?c ?is) = edge_from ?c ?is\n\ngoal (1 subgoal):\n 1. (v\\<^sub>1, p\\<^sub>1) = edge_from c is", "by (metis fst_conv)"], ["proof (state)\nthis:\n  (v\\<^sub>1, p\\<^sub>1) = edge_from c is\n\ngoal (2 subgoals):\n 1. \\<And>c is.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                edge_at c is;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "hence [simp]: \"v\\<^sub>1 = (c, 0 # is)\""], ["proof (prove)\nusing this:\n  (v\\<^sub>1, p\\<^sub>1) = edge_from c is\n\ngoal (1 subgoal):\n 1. v\\<^sub>1 = (c, 0 # is)", "by (simp add: edge_from_def)"], ["proof (state)\nthis:\n  v\\<^sub>1 = (c, 0 # is)\n\ngoal (2 subgoals):\n 1. \\<And>c is.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                edge_at c is;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c)\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "proof(cases \"is\" rule:rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "case Nil"], ["proof (state)\nthis:\n  is = []\n\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "let \"?t'\" = \"it' c\""], ["proof (state)\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"labelAtOut v\\<^sub>1 p\\<^sub>1 = subst (iSubst ?t') (freshen (vidx v\\<^sub>1) (iOutPort ?t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labelAtOut v\\<^sub>1 p\\<^sub>1 =\n    subst (iSubst (it' c)) (freshen (vidx v\\<^sub>1) (iOutPort (it' c)))", "using regular_edge Nil"], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = edge_at c is\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  is = []\n\ngoal (1 subgoal):\n 1. labelAtOut v\\<^sub>1 p\\<^sub>1 =\n    subst (iSubst (it' c)) (freshen (vidx v\\<^sub>1) (iOutPort (it' c)))", "by (simp add: labelAtOut_def edge_at_def edge_from_def)"], ["proof (state)\nthis:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 =\n  subst (iSubst (it' c)) (freshen (vidx v\\<^sub>1) (iOutPort (it' c)))\n\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 =\n  subst (iSubst (it' c)) (freshen (vidx v\\<^sub>1) (iOutPort (it' c)))\n\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"vidx v\\<^sub>1 = iAnnot ?t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vidx v\\<^sub>1 = iAnnot (it' c)", "by (simp add:  Nil)"], ["proof (state)\nthis:\n  vidx v\\<^sub>1 = iAnnot (it' c)\n\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  vidx v\\<^sub>1 = iAnnot (it' c)\n\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"subst (iSubst ?t') (freshen (iAnnot ?t') (iOutPort ?t')) = snd (fst (root (ts c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (iSubst (it' c)) (freshen (iAnnot (it' c)) (iOutPort (it' c))) =\n    snd (fst (tree.root (ts c)))", "unfolding iwf_subst_freshen_outPort[OF iwf_it[OF \\<open>c \\<in> set conclusions\\<close>]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (iSubst (it' c)) (freshen (iAnnot (it' c)) (iOutPort (it' c))) =\n    subst (iSubst (it' c)) (freshen (iAnnot (it' c)) (iOutPort (it' c)))", ".."], ["proof (state)\nthis:\n  subst (iSubst (it' c)) (freshen (iAnnot (it' c)) (iOutPort (it' c))) =\n  snd (fst (tree.root (ts c)))\n\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst (iSubst (it' c)) (freshen (iAnnot (it' c)) (iOutPort (it' c))) =\n  snd (fst (tree.root (ts c)))\n\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"\\<dots> = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (fst (tree.root (ts c))) = c", "using \\<open>c \\<in> set conclusions\\<close>"], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. snd (fst (tree.root (ts c))) = c", "by (simp add: ts_conc)"], ["proof (state)\nthis:\n  snd (fst (tree.root (ts c))) = c\n\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  snd (fst (tree.root (ts c))) = c\n\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"\\<dots> = labelAtIn v\\<^sub>2 p\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = labelAtIn v\\<^sub>2 p\\<^sub>2", "using  \\<open>c \\<in> set conclusions\\<close>  regular_edge Nil"], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = edge_at c is\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  is = []\n\ngoal (1 subgoal):\n 1. c = labelAtIn v\\<^sub>2 p\\<^sub>2", "by (simp add: labelAtIn_def edge_at_def freshen_closed conclusions_closed closed_no_lconsts)"], ["proof (state)\nthis:\n  c = labelAtIn v\\<^sub>2 p\\<^sub>2\n\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n 2. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "finally"], ["proof (chain)\npicking this:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n\ngoal (1 subgoal):\n 1. labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "."], ["proof (state)\nthis:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "case (snoc is' i)"], ["proof (state)\nthis:\n  is = is' @ [i]\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "let \"?t1\" = \"tree_at (it' c) (is'@[i])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "let \"?t2\" = \"tree_at (it' c) is'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"labelAtOut v\\<^sub>1 p\\<^sub>1 = subst (iSubst ?t1) (freshen (vidx v\\<^sub>1) (iOutPort ?t1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labelAtOut v\\<^sub>1 p\\<^sub>1 =\n    subst (iSubst (tree_at (it' c) (is' @ [i])))\n     (freshen (vidx v\\<^sub>1) (iOutPort (tree_at (it' c) (is' @ [i]))))", "using regular_edge snoc"], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = edge_at c is\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  is = is' @ [i]\n\ngoal (1 subgoal):\n 1. labelAtOut v\\<^sub>1 p\\<^sub>1 =\n    subst (iSubst (tree_at (it' c) (is' @ [i])))\n     (freshen (vidx v\\<^sub>1) (iOutPort (tree_at (it' c) (is' @ [i]))))", "by (simp add: labelAtOut_def edge_at_def edge_from_def)"], ["proof (state)\nthis:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 =\n  subst (iSubst (tree_at (it' c) (is' @ [i])))\n   (freshen (vidx v\\<^sub>1) (iOutPort (tree_at (it' c) (is' @ [i]))))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 =\n  subst (iSubst (tree_at (it' c) (is' @ [i])))\n   (freshen (vidx v\\<^sub>1) (iOutPort (tree_at (it' c) (is' @ [i]))))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"vidx v\\<^sub>1 = iAnnot ?t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vidx v\\<^sub>1 = iAnnot (tree_at (it' c) (is' @ [i]))", "using snoc regular_edge(3)"], ["proof (prove)\nusing this:\n  is = is' @ [i]\n  is \\<in> it_paths (it' c)\n\ngoal (1 subgoal):\n 1. vidx v\\<^sub>1 = iAnnot (tree_at (it' c) (is' @ [i]))", "by simp"], ["proof (state)\nthis:\n  vidx v\\<^sub>1 = iAnnot (tree_at (it' c) (is' @ [i]))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  vidx v\\<^sub>1 = iAnnot (tree_at (it' c) (is' @ [i]))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"subst (iSubst ?t1) (freshen (iAnnot ?t1) (iOutPort ?t1))\n          = subst (iSubst ?t2) (freshen (iAnnot ?t2) (a_conc (inPorts' (iNodeOf ?t2) ! i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (iSubst (tree_at (it' c) (is' @ [i])))\n     (freshen (iAnnot (tree_at (it' c) (is' @ [i])))\n       (iOutPort (tree_at (it' c) (is' @ [i])))) =\n    subst (iSubst (tree_at (it' c) is'))\n     (freshen (iAnnot (tree_at (it' c) is'))\n       (a_conc (inPorts' (iNodeOf (tree_at (it' c) is')) ! i)))", "by (rule iwf_edge_match[OF iwf_it[OF \\<open>c \\<in> set conclusions\\<close>] \\<open>is \\<in> it_paths (it' c)\\<close>[unfolded snoc]])"], ["proof (state)\nthis:\n  subst (iSubst (tree_at (it' c) (is' @ [i])))\n   (freshen (iAnnot (tree_at (it' c) (is' @ [i])))\n     (iOutPort (tree_at (it' c) (is' @ [i])))) =\n  subst (iSubst (tree_at (it' c) is'))\n   (freshen (iAnnot (tree_at (it' c) is'))\n     (a_conc (inPorts' (iNodeOf (tree_at (it' c) is')) ! i)))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst (iSubst (tree_at (it' c) (is' @ [i])))\n   (freshen (iAnnot (tree_at (it' c) (is' @ [i])))\n     (iOutPort (tree_at (it' c) (is' @ [i])))) =\n  subst (iSubst (tree_at (it' c) is'))\n   (freshen (iAnnot (tree_at (it' c) is'))\n     (a_conc (inPorts' (iNodeOf (tree_at (it' c) is')) ! i)))\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"iAnnot ?t2 = vidx (c, 0 # is')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iAnnot (tree_at (it' c) is') = vidx (c, 0 # is')", "by simp"], ["proof (state)\nthis:\n  iAnnot (tree_at (it' c) is') = vidx (c, 0 # is')\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  iAnnot (tree_at (it' c) is') = vidx (c, 0 # is')\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"subst (iSubst ?t2) (freshen (vidx (c, 0 # is')) (a_conc (inPorts' (iNodeOf ?t2) ! i))) = labelAtIn v\\<^sub>2 p\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (iSubst (tree_at (it' c) is'))\n     (freshen (vidx (c, 0 # is'))\n       (a_conc (inPorts' (iNodeOf (tree_at (it' c) is')) ! i))) =\n    labelAtIn v\\<^sub>2 p\\<^sub>2", "using regular_edge snoc"], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = edge_at c is\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  is = is' @ [i]\n\ngoal (1 subgoal):\n 1. subst (iSubst (tree_at (it' c) is'))\n     (freshen (vidx (c, 0 # is'))\n       (a_conc (inPorts' (iNodeOf (tree_at (it' c) is')) ! i))) =\n    labelAtIn v\\<^sub>2 p\\<^sub>2", "by (simp add: labelAtIn_def edge_at_def)"], ["proof (state)\nthis:\n  subst (iSubst (tree_at (it' c) is'))\n   (freshen (vidx (c, 0 # is'))\n     (a_conc (inPorts' (iNodeOf (tree_at (it' c) is')) ! i))) =\n  labelAtIn v\\<^sub>2 p\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       is = ys @ [y] \\<Longrightarrow>\n       labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "finally"], ["proof (chain)\npicking this:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n\ngoal (1 subgoal):\n 1. labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "."], ["proof (state)\nthis:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "case (hyp_edge c \"is\" n s ants)"], ["proof (state)\nthis:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = hyp_edge_at c is n s\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode n s ants\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "let ?f = \"subst s (freshen n anyP)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "let ?h = \"hyp_port_h_for (it' c) is ?f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "let ?his = \"hyp_port_path_for (it' c) is ?f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "let \"?t1\" = \"tree_at (it' c) ?his\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "let \"?t2\" = \"tree_at (it' c) is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "from \\<open>c \\<in> set conclusions\\<close> \\<open>is \\<in> it_paths (it' c)\\<close> \\<open>tree_at (it' c) is = HNode n s ants\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode n s ants", "have \"?f \\<in> hyps_along (it' c) is\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode n s ants\n\ngoal (1 subgoal):\n 1. subst s (freshen n anyP) \\<in> hyps_along (it' c) is", "by (rule hyps_exist')"], ["proof (state)\nthis:\n  subst s (freshen n anyP) \\<in> hyps_along (it' c) is\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "from \\<open>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = hyp_edge_at c is n s\\<close>"], ["proof (chain)\npicking this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = hyp_edge_at c is n s", "have \"(v\\<^sub>1,p\\<^sub>1) = hyp_edge_from c is n s\""], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = hyp_edge_at c is n s\n\ngoal (1 subgoal):\n 1. (v\\<^sub>1, p\\<^sub>1) = hyp_edge_from c is n s", "using fst_hyp_edge_at"], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = hyp_edge_at c is n s\n  fst (hyp_edge_at ?c ?is ?n ?s) = hyp_edge_from ?c ?is ?n ?s\n\ngoal (1 subgoal):\n 1. (v\\<^sub>1, p\\<^sub>1) = hyp_edge_from c is n s", "by (metis fst_conv)"], ["proof (state)\nthis:\n  (v\\<^sub>1, p\\<^sub>1) = hyp_edge_from c is n s\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "hence [simp]: \"v\\<^sub>1 = (c, 0 # ?his)\""], ["proof (prove)\nusing this:\n  (v\\<^sub>1, p\\<^sub>1) = hyp_edge_from c is n s\n\ngoal (1 subgoal):\n 1. v\\<^sub>1 =\n    (c, 0 # hyp_port_path_for (it' c) is (subst s (freshen n anyP)))", "by (simp add: hyp_edge_from_def)"], ["proof (state)\nthis:\n  v\\<^sub>1 =\n  (c, 0 # hyp_port_path_for (it' c) is (subst s (freshen n anyP)))\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"labelAtOut v\\<^sub>1 p\\<^sub>1 = subst (iSubst ?t1) (freshen (vidx v\\<^sub>1) (labelsOut (iNodeOf ?t1) ?h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labelAtOut v\\<^sub>1 p\\<^sub>1 =\n    subst\n     (iSubst\n       (tree_at (it' c)\n         (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n     (freshen (vidx v\\<^sub>1)\n       (labelsOut\n         (iNodeOf\n           (tree_at (it' c)\n             (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n         (hyp_port_h_for (it' c) is (subst s (freshen n anyP)))))", "using hyp_edge"], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = hyp_edge_at c is n s\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode n s ants\n\ngoal (1 subgoal):\n 1. labelAtOut v\\<^sub>1 p\\<^sub>1 =\n    subst\n     (iSubst\n       (tree_at (it' c)\n         (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n     (freshen (vidx v\\<^sub>1)\n       (labelsOut\n         (iNodeOf\n           (tree_at (it' c)\n             (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n         (hyp_port_h_for (it' c) is (subst s (freshen n anyP)))))", "by (simp add: hyp_edge_at_def hyp_edge_from_def labelAtOut_def)"], ["proof (state)\nthis:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 =\n  subst\n   (iSubst\n     (tree_at (it' c)\n       (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n   (freshen (vidx v\\<^sub>1)\n     (labelsOut\n       (iNodeOf\n         (tree_at (it' c)\n           (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n       (hyp_port_h_for (it' c) is (subst s (freshen n anyP)))))\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 =\n  subst\n   (iSubst\n     (tree_at (it' c)\n       (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n   (freshen (vidx v\\<^sub>1)\n     (labelsOut\n       (iNodeOf\n         (tree_at (it' c)\n           (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n       (hyp_port_h_for (it' c) is (subst s (freshen n anyP)))))\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"vidx v\\<^sub>1 = iAnnot ?t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vidx v\\<^sub>1 =\n    iAnnot\n     (tree_at (it' c)\n       (hyp_port_path_for (it' c) is (subst s (freshen n anyP))))", "by simp"], ["proof (state)\nthis:\n  vidx v\\<^sub>1 =\n  iAnnot\n   (tree_at (it' c)\n     (hyp_port_path_for (it' c) is (subst s (freshen n anyP))))\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  vidx v\\<^sub>1 =\n  iAnnot\n   (tree_at (it' c)\n     (hyp_port_path_for (it' c) is (subst s (freshen n anyP))))\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"subst (iSubst ?t1) (freshen (iAnnot ?t1) (labelsOut (iNodeOf ?t1) ?h)) = ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\n     (iSubst\n       (tree_at (it' c)\n         (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n     (freshen\n       (iAnnot\n         (tree_at (it' c)\n           (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n       (labelsOut\n         (iNodeOf\n           (tree_at (it' c)\n             (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n         (hyp_port_h_for (it' c) is (subst s (freshen n anyP))))) =\n    subst s (freshen n anyP)", "using \\<open>?f \\<in> hyps_along (it' c) is\\<close>"], ["proof (prove)\nusing this:\n  subst s (freshen n anyP) \\<in> hyps_along (it' c) is\n\ngoal (1 subgoal):\n 1. subst\n     (iSubst\n       (tree_at (it' c)\n         (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n     (freshen\n       (iAnnot\n         (tree_at (it' c)\n           (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n       (labelsOut\n         (iNodeOf\n           (tree_at (it' c)\n             (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n         (hyp_port_h_for (it' c) is (subst s (freshen n anyP))))) =\n    subst s (freshen n anyP)", "by (rule local.hyp_port_eq[symmetric])"], ["proof (state)\nthis:\n  subst\n   (iSubst\n     (tree_at (it' c)\n       (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n   (freshen\n     (iAnnot\n       (tree_at (it' c)\n         (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n     (labelsOut\n       (iNodeOf\n         (tree_at (it' c)\n           (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n       (hyp_port_h_for (it' c) is (subst s (freshen n anyP))))) =\n  subst s (freshen n anyP)\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst\n   (iSubst\n     (tree_at (it' c)\n       (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n   (freshen\n     (iAnnot\n       (tree_at (it' c)\n         (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n     (labelsOut\n       (iNodeOf\n         (tree_at (it' c)\n           (hyp_port_path_for (it' c) is (subst s (freshen n anyP)))))\n       (hyp_port_h_for (it' c) is (subst s (freshen n anyP))))) =\n  subst s (freshen n anyP)\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"\\<dots> = subst (iSubst ?t2) (freshen (iAnnot ?t2) anyP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst s (freshen n anyP) =\n    subst (iSubst (tree_at (it' c) is))\n     (freshen (iAnnot (tree_at (it' c) is)) anyP)", "using hyp_edge"], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = hyp_edge_at c is n s\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode n s ants\n\ngoal (1 subgoal):\n 1. subst s (freshen n anyP) =\n    subst (iSubst (tree_at (it' c) is))\n     (freshen (iAnnot (tree_at (it' c) is)) anyP)", "by simp"], ["proof (state)\nthis:\n  subst s (freshen n anyP) =\n  subst (iSubst (tree_at (it' c) is))\n   (freshen (iAnnot (tree_at (it' c) is)) anyP)\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst s (freshen n anyP) =\n  subst (iSubst (tree_at (it' c) is))\n   (freshen (iAnnot (tree_at (it' c) is)) anyP)\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "have \"subst (iSubst ?t2) (freshen (iAnnot ?t2) anyP) = labelAtIn v\\<^sub>2 p\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (iSubst (tree_at (it' c) is))\n     (freshen (iAnnot (tree_at (it' c) is)) anyP) =\n    labelAtIn v\\<^sub>2 p\\<^sub>2", "using hyp_edge"], ["proof (prove)\nusing this:\n  ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) = hyp_edge_at c is n s\n  c \\<in> set conclusions\n  is \\<in> it_paths (it' c)\n  tree_at (it' c) is = HNode n s ants\n\ngoal (1 subgoal):\n 1. subst (iSubst (tree_at (it' c) is))\n     (freshen (iAnnot (tree_at (it' c) is)) anyP) =\n    labelAtIn v\\<^sub>2 p\\<^sub>2", "by (simp add: labelAtIn_def  hyp_edge_at_def hyp_edge_to_def)"], ["proof (state)\nthis:\n  subst (iSubst (tree_at (it' c) is))\n   (freshen (iAnnot (tree_at (it' c) is)) anyP) =\n  labelAtIn v\\<^sub>2 p\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>c is n s ants.\n       \\<lbrakk>((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) =\n                hyp_edge_at c is n s;\n        c \\<in> set conclusions; is \\<in> it_paths (it' c);\n        tree_at (it' c) is = HNode n s ants\\<rbrakk>\n       \\<Longrightarrow> labelAtOut v\\<^sub>1 p\\<^sub>1 =\n                         labelAtIn v\\<^sub>2 p\\<^sub>2", "finally"], ["proof (chain)\npicking this:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n\ngoal (1 subgoal):\n 1. labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2", "."], ["proof (state)\nthis:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  labelAtOut v\\<^sub>1 p\\<^sub>1 = labelAtIn v\\<^sub>2 p\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma node_disjoint_fresh_vars:\n  assumes \"n \\<in> sset nodes\"\n  assumes \"i < length (inPorts' n)\"\n  assumes \"i' < length (inPorts' n)\"\n  shows \"a_fresh (inPorts' n ! i) \\<inter> a_fresh (inPorts' n ! i') = {} \\<or> i = i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a_fresh (inPorts' n ! i) \\<inter> a_fresh (inPorts' n ! i') = {} \\<or>\n    i = i'", "using assms no_multiple_local_consts"], ["proof (prove)\nusing this:\n  n \\<in> i.R nodes\n  i < length (inPorts' n)\n  i' < length (inPorts' n)\n  \\<lbrakk>?r \\<in> i.R rules; ?i < length (antecedent ?r);\n   ?i' < length (antecedent ?r)\\<rbrakk>\n  \\<Longrightarrow> a_fresh (antecedent ?r ! ?i) \\<inter>\n                    a_fresh (antecedent ?r ! ?i') =\n                    {} \\<or>\n                    ?i = ?i'\n\ngoal (1 subgoal):\n 1. a_fresh (inPorts' n ! i) \\<inter> a_fresh (inPorts' n ! i') = {} \\<or>\n    i = i'", "by (fastforce simp add: nodes_def stream.set_map)"], ["", "sublocale Well_Scoped_Instantiation  freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP inPorts outPorts nodeOf hyps  nodes vertices labelsIn labelsOut vidx inst edges local_vars"], ["proof (prove)\ngoal (1 subgoal):\n 1. Well_Scoped_Instantiation freshenLC renameLCs lconsts closed subst\n     subst_lconsts subst_renameLCs anyP inPorts outPorts nodeOf hyps\n     vertices vidx inst edges local_vars", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "fix v p var v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "assume \"valid_in_port (v, p)\""], ["proof (state)\nthis:\n  valid_in_port (v, p)\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "hence \"v |\\<in>| vertices\""], ["proof (prove)\nusing this:\n  valid_in_port (v, p)\n\ngoal (1 subgoal):\n 1. v |\\<in>| vertices", "by simp"], ["proof (state)\nthis:\n  v |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "obtain c \"is\" where \"v = (c,is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c is. v = (c, is) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases v, auto)"], ["proof (state)\nthis:\n  v = (c, is)\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "from \\<open>valid_in_port (v, p)\\<close> \\<open>v= _\\<close>"], ["proof (chain)\npicking this:\n  valid_in_port (v, p)\n  v = (c, is)", "have \"(c,is) |\\<in>| vertices\"  and \"p |\\<in>| inPorts (nodeOf (c, is))\""], ["proof (prove)\nusing this:\n  valid_in_port (v, p)\n  v = (c, is)\n\ngoal (1 subgoal):\n 1. (c, is) |\\<in>| vertices &&& p |\\<in>| inPorts (nodeOf (c, is))", "by simp_all"], ["proof (state)\nthis:\n  (c, is) |\\<in>| vertices\n  p |\\<in>| inPorts (nodeOf (c, is))\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "hence \"c \\<in> set conclusions\""], ["proof (prove)\nusing this:\n  (c, is) |\\<in>| vertices\n  p |\\<in>| inPorts (nodeOf (c, is))\n\ngoal (1 subgoal):\n 1. c \\<in> set conclusions", "by (simp add: mem_vertices)"], ["proof (state)\nthis:\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "from \\<open>p |\\<in>| _\\<close>"], ["proof (chain)\npicking this:\n  p |\\<in>| inPorts (nodeOf (c, is))", "obtain i where\n    \"i < length (inPorts' (nodeOf (c, is)))\" and\n    \"p = inPorts' (nodeOf (c, is)) ! i\""], ["proof (prove)\nusing this:\n  p |\\<in>| inPorts (nodeOf (c, is))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length (inPorts' (nodeOf (c, is)));\n         p = inPorts' (nodeOf (c, is)) ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: inPorts_fset_of in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length (inPorts' (nodeOf (c, is)))\n  p = inPorts' (nodeOf (c, is)) ! i\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "hence \"p = in_port_at (c, is) i\""], ["proof (prove)\nusing this:\n  i < length (inPorts' (nodeOf (c, is)))\n  p = inPorts' (nodeOf (c, is)) ! i\n\ngoal (1 subgoal):\n 1. p = in_port_at (c, is) i", "by (cases \"is\") auto"], ["proof (state)\nthis:\n  p = in_port_at (c, is) i\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "assume \"v' |\\<in>| vertices\""], ["proof (state)\nthis:\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "then"], ["proof (chain)\npicking this:\n  v' |\\<in>| vertices", "obtain c' is' where \"v' = (c',is')\""], ["proof (prove)\nusing this:\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. (\\<And>c' is'.\n        v' = (c', is') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases v', auto)"], ["proof (state)\nthis:\n  v' = (c', is')\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "assume \"var \\<in> local_vars (nodeOf v) p\""], ["proof (state)\nthis:\n  var \\<in> local_vars (nodeOf v) p\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "hence \"var \\<in> a_fresh p\""], ["proof (prove)\nusing this:\n  var \\<in> local_vars (nodeOf v) p\n\ngoal (1 subgoal):\n 1. var \\<in> a_fresh p", "by simp"], ["proof (state)\nthis:\n  var \\<in> a_fresh p\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "assume \"freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\""], ["proof (state)\nthis:\n  freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "then"], ["proof (chain)\npicking this:\n  freshenLC (vidx v) var \\<in> subst_lconsts (inst v')", "obtain is'' where \"is' = 0#is''\" and \"is'' \\<in> it_paths (it' c')\""], ["proof (prove)\nusing this:\n  freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\n\ngoal (1 subgoal):\n 1. (\\<And>is''.\n        \\<lbrakk>is' = 0 # is''; is'' \\<in> it_paths (it' c')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>v' |\\<in>| vertices\\<close>"], ["proof (prove)\nusing this:\n  freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. (\\<And>is''.\n        \\<lbrakk>is' = 0 # is''; is'' \\<in> it_paths (it' c')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases is') (auto simp add: \\<open>v'=_\\<close>)"], ["proof (state)\nthis:\n  is' = 0 # is''\n  is'' \\<in> it_paths (it' c')\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "note \\<open>freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<close>"], ["proof (state)\nthis:\n  freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "also"], ["proof (state)\nthis:\n  freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "have \"subst_lconsts (inst v') = subst_lconsts (iSubst (tree_at (it' c') is''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_lconsts (inst v') = subst_lconsts (iSubst (tree_at (it' c') is''))", "by (simp add: \\<open>v'=_\\<close> \\<open>is'=_\\<close>)"], ["proof (state)\nthis:\n  subst_lconsts (inst v') = subst_lconsts (iSubst (tree_at (it' c') is''))\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "also"], ["proof (state)\nthis:\n  subst_lconsts (inst v') = subst_lconsts (iSubst (tree_at (it' c') is''))\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "from \\<open>is'' \\<in> it_paths (it' c')\\<close>"], ["proof (chain)\npicking this:\n  is'' \\<in> it_paths (it' c')", "have \"\\<dots> \\<subseteq> fresh_at_path (it' c') is'' \\<union> range (freshenLC v_away)\""], ["proof (prove)\nusing this:\n  is'' \\<in> it_paths (it' c')\n\ngoal (1 subgoal):\n 1. subst_lconsts (iSubst (tree_at (it' c') is''))\n    \\<subseteq> fresh_at_path (it' c') is'' \\<union>\n                range (freshenLC v_away)", "by (rule globalize_local_consts)"], ["proof (state)\nthis:\n  subst_lconsts (iSubst (tree_at (it' c') is''))\n  \\<subseteq> fresh_at_path (it' c') is'' \\<union> range (freshenLC v_away)\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "finally"], ["proof (chain)\npicking this:\n  freshenLC (vidx v) var\n  \\<in> fresh_at_path (it' c') is'' \\<union> range (freshenLC v_away)", "have \"freshenLC (vidx v) var \\<in> fresh_at_path (it' c') is''\""], ["proof (prove)\nusing this:\n  freshenLC (vidx v) var\n  \\<in> fresh_at_path (it' c') is'' \\<union> range (freshenLC v_away)\n\ngoal (1 subgoal):\n 1. freshenLC (vidx v) var \\<in> fresh_at_path (it' c') is''", "using \\<open>v |\\<in>| vertices\\<close>"], ["proof (prove)\nusing this:\n  freshenLC (vidx v) var\n  \\<in> fresh_at_path (it' c') is'' \\<union> range (freshenLC v_away)\n  v |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. freshenLC (vidx v) var \\<in> fresh_at_path (it' c') is''", "by auto"], ["proof (state)\nthis:\n  freshenLC (vidx v) var \\<in> fresh_at_path (it' c') is''\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "then"], ["proof (chain)\npicking this:\n  freshenLC (vidx v) var \\<in> fresh_at_path (it' c') is''", "obtain is''' where \"prefix is''' is''\"  and \"freshenLC (vidx v) var \\<in> fresh_at (it' c') is'''\""], ["proof (prove)\nusing this:\n  freshenLC (vidx v) var \\<in> fresh_at_path (it' c') is''\n\ngoal (1 subgoal):\n 1. (\\<And>is'''.\n        \\<lbrakk>prefix is''' is'';\n         freshenLC (vidx v) var \\<in> fresh_at (it' c') is'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fresh_at_path_def"], ["proof (prove)\nusing this:\n  freshenLC (vidx v) var\n  \\<in> \\<Union> (fresh_at (it' c') ` set (prefixes is''))\n\ngoal (1 subgoal):\n 1. (\\<And>is'''.\n        \\<lbrakk>prefix is''' is'';\n         freshenLC (vidx v) var \\<in> fresh_at (it' c') is'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prefix is''' is''\n  freshenLC (vidx v) var \\<in> fresh_at (it' c') is'''\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "then"], ["proof (chain)\npicking this:\n  prefix is''' is''\n  freshenLC (vidx v) var \\<in> fresh_at (it' c') is'''", "obtain i' is'''' where \"prefix (is''''@[i']) is''\" \n      and \"freshenLC (vidx v) var \\<in> fresh_at (it' c') (is''''@[i'])\""], ["proof (prove)\nusing this:\n  prefix is''' is''\n  freshenLC (vidx v) var \\<in> fresh_at (it' c') is'''\n\ngoal (1 subgoal):\n 1. (\\<And>is'''' i'.\n        \\<lbrakk>prefix (is'''' @ [i']) is'';\n         freshenLC (vidx v) var\n         \\<in> fresh_at (it' c') (is'''' @ [i'])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using append_butlast_last_id[where xs = is''', symmetric]"], ["proof (prove)\nusing this:\n  prefix is''' is''\n  freshenLC (vidx v) var \\<in> fresh_at (it' c') is'''\n  is''' \\<noteq> [] \\<Longrightarrow> is''' = butlast is''' @ [last is''']\n\ngoal (1 subgoal):\n 1. (\\<And>is'''' i'.\n        \\<lbrakk>prefix (is'''' @ [i']) is'';\n         freshenLC (vidx v) var\n         \\<in> fresh_at (it' c') (is'''' @ [i'])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases \"is''' = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>is'''' i'.\n                \\<lbrakk>prefix (is'''' @ [i']) is'';\n                 freshenLC (vidx v) var\n                 \\<in> fresh_at (it' c') (is'''' @ [i'])\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prefix is''' is'';\n     freshenLC (vidx v) var \\<in> fresh_at (it' c') is''';\n     is''' \\<noteq> [] \\<Longrightarrow>\n     is''' = butlast is''' @ [last is'''];\n     is''' = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>is'''' i'.\n                \\<lbrakk>prefix (is'''' @ [i']) is'';\n                 freshenLC (vidx v) var\n                 \\<in> fresh_at (it' c') (is'''' @ [i'])\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prefix is''' is'';\n     freshenLC (vidx v) var \\<in> fresh_at (it' c') is''';\n     is''' \\<noteq> [] \\<Longrightarrow>\n     is''' = butlast is''' @ [last is'''];\n     is''' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (auto simp del: fresh_at_snoc append_butlast_last_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>is'''' i'.\n                \\<lbrakk>prefix (is'''' @ [i']) is'';\n                 freshenLC (vidx v) var\n                 \\<in> fresh_at (it' c') (is'''' @ [i'])\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prefix is''' is'';\n     freshenLC (vidx v) var \\<in> fresh_at (it' c') is''';\n     is''' = butlast is''' @ [last is''']; is''' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  prefix (is'''' @ [i']) is''\n  freshenLC (vidx v) var \\<in> fresh_at (it' c') (is'''' @ [i'])\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "from  \\<open>is'' \\<in> it_paths (it' c')\\<close> \\<open>prefix (is''''@[i']) is''\\<close>"], ["proof (chain)\npicking this:\n  is'' \\<in> it_paths (it' c')\n  prefix (is'''' @ [i']) is''", "have \"(is''''@[i']) \\<in> it_paths (it' c')\""], ["proof (prove)\nusing this:\n  is'' \\<in> it_paths (it' c')\n  prefix (is'''' @ [i']) is''\n\ngoal (1 subgoal):\n 1. is'''' @ [i'] \\<in> it_paths (it' c')", "by (rule it_paths_prefix)"], ["proof (state)\nthis:\n  is'''' @ [i'] \\<in> it_paths (it' c')\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "hence \"is'''' \\<in> it_paths (it' c')\""], ["proof (prove)\nusing this:\n  is'''' @ [i'] \\<in> it_paths (it' c')\n\ngoal (1 subgoal):\n 1. is'''' \\<in> it_paths (it' c')", "using append_prefixD it_paths_prefix"], ["proof (prove)\nusing this:\n  is'''' @ [i'] \\<in> it_paths (it' c')\n  prefix (?xs @ ?ys) ?zs \\<Longrightarrow> prefix ?xs ?zs\n  \\<lbrakk>?is \\<in> it_paths ?t; prefix ?is' ?is\\<rbrakk>\n  \\<Longrightarrow> ?is' \\<in> it_paths ?t\n\ngoal (1 subgoal):\n 1. is'''' \\<in> it_paths (it' c')", "by blast"], ["proof (state)\nthis:\n  is'''' \\<in> it_paths (it' c')\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "from this \\<open>freshenLC (vidx v) var \\<in> fresh_at (it' c') (is''''@[i'])\\<close>"], ["proof (chain)\npicking this:\n  is'''' \\<in> it_paths (it' c')\n  freshenLC (vidx v) var \\<in> fresh_at (it' c') (is'''' @ [i'])", "have \"c = c' \\<and> is = 0 # is'''' \\<and> var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')\""], ["proof (prove)\nusing this:\n  is'''' \\<in> it_paths (it' c')\n  freshenLC (vidx v) var \\<in> fresh_at (it' c') (is'''' @ [i'])\n\ngoal (1 subgoal):\n 1. c = c' \\<and>\n    is = 0 # is'''' \\<and>\n    var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')", "unfolding fresh_at_def'"], ["proof (prove)\nusing this:\n  is'''' \\<in> it_paths (it' c')\n  freshenLC (vidx v) var\n  \\<in> (if is'''' @ [i'] = [] then {}\n         else freshenLC\n               (iAnnot (tree_at (it' c') (butlast (is'''' @ [i'])))) `\n              a_fresh\n               (inPorts'\n                 (iNodeOf (tree_at (it' c') (butlast (is'''' @ [i'])))) !\n                last (is'''' @ [i'])))\n\ngoal (1 subgoal):\n 1. c = c' \\<and>\n    is = 0 # is'''' \\<and>\n    var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')", "using \\<open>v |\\<in>| vertices\\<close>  \\<open>v' |\\<in>| vertices\\<close>"], ["proof (prove)\nusing this:\n  is'''' \\<in> it_paths (it' c')\n  freshenLC (vidx v) var\n  \\<in> (if is'''' @ [i'] = [] then {}\n         else freshenLC\n               (iAnnot (tree_at (it' c') (butlast (is'''' @ [i'])))) `\n              a_fresh\n               (inPorts'\n                 (iNodeOf (tree_at (it' c') (butlast (is'''' @ [i'])))) !\n                last (is'''' @ [i'])))\n  v |\\<in>| vertices\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. c = c' \\<and>\n    is = 0 # is'''' \\<and>\n    var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')", "apply (cases \"is\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is'''' \\<in> it_paths (it' c');\n     freshenLC (vidx v) var\n     \\<in> (if is'''' @ [i'] = [] then {}\n            else freshenLC\n                  (iAnnot (tree_at (it' c') (butlast (is'''' @ [i'])))) `\n                 a_fresh\n                  (inPorts'\n                    (iNodeOf (tree_at (it' c') (butlast (is'''' @ [i'])))) !\n                   last (is'''' @ [i'])));\n     v |\\<in>| vertices; v' |\\<in>| vertices; is = []\\<rbrakk>\n    \\<Longrightarrow> c = c' \\<and>\n                      is = 0 # is'''' \\<and>\n                      var\n                      \\<in> a_fresh\n                             (inPorts' (iNodeOf (tree_at (it' c') is'''')) !\n                              i')\n 2. \\<And>a list.\n       \\<lbrakk>is'''' \\<in> it_paths (it' c');\n        freshenLC (vidx v) var\n        \\<in> (if is'''' @ [i'] = [] then {}\n               else freshenLC\n                     (iAnnot (tree_at (it' c') (butlast (is'''' @ [i'])))) `\n                    a_fresh\n                     (inPorts'\n                       (iNodeOf\n                         (tree_at (it' c') (butlast (is'''' @ [i'])))) !\n                      last (is'''' @ [i'])));\n        v |\\<in>| vertices; v' |\\<in>| vertices; is = a # list\\<rbrakk>\n       \\<Longrightarrow> c = c' \\<and>\n                         is = 0 # is'''' \\<and>\n                         var\n                         \\<in> a_fresh\n                                (inPorts'\n                                  (iNodeOf (tree_at (it' c') is'''')) !\n                                 i')", "apply (auto split: if_splits simp add:  iAnnot_globalize it_paths_butlast \\<open>v=_\\<close> \\<open>v'=_\\<close> \\<open>is'=_\\<close> simp del: iAnnot.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  c = c' \\<and>\n  is = 0 # is'''' \\<and>\n  var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "hence \"c' = c\" and \"is = 0 # is''''\" and \"var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')\""], ["proof (prove)\nusing this:\n  c = c' \\<and>\n  is = 0 # is'''' \\<and>\n  var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')\n\ngoal (1 subgoal):\n 1. c' = c &&&\n    is = 0 # is'''' &&&\n    var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')", "by simp_all"], ["proof (state)\nthis:\n  c' = c\n  is = 0 # is''''\n  var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "from \\<open>(is''''@[i']) \\<in> it_paths (it' c')\\<close>"], ["proof (chain)\npicking this:\n  is'''' @ [i'] \\<in> it_paths (it' c')", "have \"i' < length (inPorts' (nodeOf (c, is)))\""], ["proof (prove)\nusing this:\n  is'''' @ [i'] \\<in> it_paths (it' c')\n\ngoal (1 subgoal):\n 1. i' < length (inPorts' (nodeOf (c, is)))", "using iwf_length_inPorts[OF iwf_it[OF \\<open>c \\<in> set conclusions\\<close>]]"], ["proof (prove)\nusing this:\n  is'''' @ [i'] \\<in> it_paths (it' c')\n  ?is \\<in> it_paths (it' c) \\<Longrightarrow>\n  length (iAnts (tree_at (it' c) ?is))\n  \\<le> length (inPorts' (iNodeOf (tree_at (it' c) ?is)))\n\ngoal (1 subgoal):\n 1. i' < length (inPorts' (nodeOf (c, is)))", "by (auto elim!: it_paths_SnocE simp add: \\<open>is=_\\<close> \\<open>c' = _\\<close> order.strict_trans2)"], ["proof (state)\nthis:\n  i' < length (inPorts' (nodeOf (c, is)))\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "have \"nodeOf (c, is) \\<in> sset nodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodeOf (c, is) \\<in> i.R nodes", "unfolding \\<open>is = _\\<close> \\<open>c' = _\\<close> nodeOf.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. iNodeOf (tree_at (it' c) is'''') \\<in> i.R nodes", "by (rule iNodeOf_tree_at[OF iwf_it[OF \\<open>c \\<in> set conclusions\\<close>]  \\<open>is'''' \\<in> it_paths (it' c')\\<close>[unfolded \\<open>c' = _\\<close>]])"], ["proof (state)\nthis:\n  nodeOf (c, is) \\<in> i.R nodes\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "from \\<open>var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')\\<close>\n       \\<open>var \\<in> a_fresh p\\<close> \\<open>p = inPorts' (nodeOf (c, is)) ! i\\<close>\n       node_disjoint_fresh_vars[OF\n          \\<open>nodeOf (c, is) \\<in> sset nodes\\<close>\n          \\<open>i < length (inPorts' (nodeOf (c, is)))\\<close> \\<open>i' < length (inPorts' (nodeOf (c, is)))\\<close>]"], ["proof (chain)\npicking this:\n  var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')\n  var \\<in> a_fresh p\n  p = inPorts' (nodeOf (c, is)) ! i\n  a_fresh (inPorts' (nodeOf (c, is)) ! i) \\<inter>\n  a_fresh (inPorts' (nodeOf (c, is)) ! i') =\n  {} \\<or>\n  i = i'", "have \"i' = i\""], ["proof (prove)\nusing this:\n  var \\<in> a_fresh (inPorts' (iNodeOf (tree_at (it' c') is'''')) ! i')\n  var \\<in> a_fresh p\n  p = inPorts' (nodeOf (c, is)) ! i\n  a_fresh (inPorts' (nodeOf (c, is)) ! i) \\<inter>\n  a_fresh (inPorts' (nodeOf (c, is)) ! i') =\n  {} \\<or>\n  i = i'\n\ngoal (1 subgoal):\n 1. i' = i", "by (auto simp add: \\<open>is=_\\<close> \\<open>c'=c\\<close>)"], ["proof (state)\nthis:\n  i' = i\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "from  \\<open>prefix (is''''@[i']) is''\\<close>"], ["proof (chain)\npicking this:\n  prefix (is'''' @ [i']) is''", "have \"prefix (is @ [i']) is'\""], ["proof (prove)\nusing this:\n  prefix (is'''' @ [i']) is''\n\ngoal (1 subgoal):\n 1. prefix (is @ [i']) is'", "by (simp add: \\<open>is'=_\\<close> \\<open>is=_\\<close>)"], ["proof (state)\nthis:\n  prefix (is @ [i']) is'\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "from \\<open>c \\<in> set conclusions\\<close>  \\<open>is'' \\<in> it_paths (it' c')\\<close> \\<open>prefix (is @ [i']) is'\\<close>\n      \\<open>p = in_port_at (c, is) i\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> set conclusions\n  is'' \\<in> it_paths (it' c')\n  prefix (is @ [i']) is'\n  p = in_port_at (c, is) i", "have \"scope' v p v'\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  is'' \\<in> it_paths (it' c')\n  prefix (is @ [i']) is'\n  p = in_port_at (c, is) i\n\ngoal (1 subgoal):\n 1. scope' v p v'", "unfolding \\<open>v=_\\<close> \\<open>v'=_\\<close> \\<open>c' = _\\<close> \\<open>is' = _\\<close>  \\<open>i'=_\\<close>"], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  is'' \\<in> it_paths (it' c)\n  prefix (is @ [i]) (0 # is'')\n  p = in_port_at (c, is) i\n\ngoal (1 subgoal):\n 1. scope' (c, is) p (c, 0 # is'')", "by (auto intro: scope'.intros)"], ["proof (state)\nthis:\n  scope' v p v'\n\ngoal (1 subgoal):\n 1. \\<And>v p var v'.\n       \\<lbrakk>valid_in_port (v, p); var \\<in> local_vars (nodeOf v) p;\n        v' |\\<in>| vertices;\n        freshenLC (vidx v) var \\<in> subst_lconsts (inst v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> scope (v, p)", "thus \"v' \\<in> scope (v, p)\""], ["proof (prove)\nusing this:\n  scope' v p v'\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p)", "using \\<open>valid_in_port (v, p)\\<close>"], ["proof (prove)\nusing this:\n  scope' v p v'\n  valid_in_port (v, p)\n\ngoal (1 subgoal):\n 1. v' \\<in> scope (v, p)", "by (simp add: in_scope)"], ["proof (state)\nthis:\n  v' \\<in> scope (v, p)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale Scoped_Proof_Graph freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP  inPorts outPorts nodeOf hyps nodes vertices labelsIn labelsOut vidx inst edges local_vars"], ["proof (prove)\ngoal (1 subgoal):\n 1. Scoped_Proof_Graph freshenLC renameLCs lconsts closed subst\n     subst_lconsts subst_renameLCs anyP inPorts outPorts nodeOf hyps nodes\n     vertices labelsIn labelsOut vidx inst edges local_vars", ".."], ["", "(* interpretation of @{term Tasked_Proof_Graph} has to be named to avoid name clashes in @{term Abstract_Task}. *)"], ["", "sublocale tpg:Tasked_Proof_Graph freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP antecedent consequent rules assumptions conclusions\n  vertices nodeOf edges vidx inst"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tasked_Proof_Graph freshenLC renameLCs lconsts closed subst\n     subst_lconsts subst_renameLCs anyP antecedent consequent rules\n     assumptions conclusions vertices nodeOf edges vidx inst", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "show \"set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "assume \"c \\<in> set conclusions\""], ["proof (state)\nthis:\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "hence \"(c, []) |\\<in>| vertices\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. (c, []) |\\<in>| vertices", "by simp"], ["proof (state)\nthis:\n  (c, []) |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "hence \"nodeOf (c, []) \\<in> nodeOf ` fset vertices\""], ["proof (prove)\nusing this:\n  (c, []) |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. nodeOf (c, []) \\<in> nodeOf ` fset vertices", "unfolding fmember.rep_eq"], ["proof (prove)\nusing this:\n  (c, []) \\<in> fset vertices\n\ngoal (1 subgoal):\n 1. nodeOf (c, []) \\<in> nodeOf ` fset vertices", "by (rule imageI)"], ["proof (state)\nthis:\n  nodeOf (c, []) \\<in> nodeOf ` fset vertices\n\ngoal (1 subgoal):\n 1. set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "hence \"Conclusion c \\<in> nodeOf ` fset vertices\""], ["proof (prove)\nusing this:\n  nodeOf (c, []) \\<in> nodeOf ` fset vertices\n\ngoal (1 subgoal):\n 1. Conclusion c \\<in> nodeOf ` fset vertices", "by simp"], ["proof (state)\nthis:\n  Conclusion c \\<in> nodeOf ` fset vertices\n\ngoal (1 subgoal):\n 1. set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "}"], ["proof (state)\nthis:\n  ?c11 \\<in> set conclusions \\<Longrightarrow>\n  Conclusion ?c11 \\<in> nodeOf ` fset vertices\n\ngoal (1 subgoal):\n 1. set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?c11 \\<in> set conclusions \\<Longrightarrow>\n  Conclusion ?c11 \\<in> nodeOf ` fset vertices\n\ngoal (1 subgoal):\n 1. set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "by auto"], ["proof (state)\nthis:\n  set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}