{"file_name": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine/Incredible_Predicate_Tasks.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine", "problem_names": ["lemma eff_NatRuleI:\n  \"nat_rule rule c ants\n    \\<Longrightarrow> entail = (\\<Gamma> \\<turnstile> subst s (freshen a c))\n    \\<Longrightarrow> hyps = ((\\<lambda>ant. ((\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>| \\<Gamma> \\<turnstile> subst s (freshen a (a_conc ant)))) |`| ants)\n    \\<Longrightarrow> (\\<And> ant f. ant |\\<in>| ants \\<Longrightarrow> f |\\<in>| \\<Gamma> \\<Longrightarrow> freshenLC a ` (a_fresh ant) \\<inter> lconsts f = {})\n    \\<Longrightarrow> (\\<And> ant. ant |\\<in>| ants \\<Longrightarrow> freshenLC a ` (a_fresh ant) \\<inter> subst_lconsts s = {})\n    \\<Longrightarrow> eff (NatRule rule) entail hyps\"", "lemma  natEff_InstI:\n  \"rule = (r,c)\n  \\<Longrightarrow> c \\<in> set (consequent r)\n  \\<Longrightarrow> antec = f_antecedent r\n  \\<Longrightarrow> natEff_Inst rule c antec\"", "lemma fv_subst_s1[simp]: \"fv_subst s1 = {}\"", "lemma subst1_simps[simp]:\n  \"subst s1 (P (LC n)) = imp (Q (LC n)) (Q (LC n))\"\n  \"subst s1 (ForallX (P x)) = ForallX (imp (Q x) (Q x))\"", "lemma subst2_simps[simp]:\n    \"subst s2 X = Q (LC lx)\" \n    \"subst s2 Y = Q (LC lx)\"\n    \"subst s2 (imp X Y) = imp (subst s2 X) (subst s2 Y)\"", "lemma substI1: \"ForallX (imp (Q x) (Q x)) = subst s1 (predicate.freshen 1 (ForallX (P x)))\"", "lemma substI2: \"imp (Q (LC lx)) (Q (LC lx)) = subst s2 (predicate.freshen 2 (imp X Y))\"", "lemma \"task.solved\"", "lemma no_path_01[simp]: \"task.path 0 v pth \\<longleftrightarrow> (pth = [] \\<and> v = 0)\"", "lemma no_path_12[simp]: \"\\<not> task.path 1 2 pth\"", "lemma path_20:\n  assumes \"task.path 2 0 pth\"\n  shows \"(1, allI_input) \\<in> snd ` set pth\"", "lemma scope_21: \"2 \\<in> task.scope (1, allI_input)\""], "translations": [["", "lemma eff_NatRuleI:\n  \"nat_rule rule c ants\n    \\<Longrightarrow> entail = (\\<Gamma> \\<turnstile> subst s (freshen a c))\n    \\<Longrightarrow> hyps = ((\\<lambda>ant. ((\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>| \\<Gamma> \\<turnstile> subst s (freshen a (a_conc ant)))) |`| ants)\n    \\<Longrightarrow> (\\<And> ant f. ant |\\<in>| ants \\<Longrightarrow> f |\\<in>| \\<Gamma> \\<Longrightarrow> freshenLC a ` (a_fresh ant) \\<inter> lconsts f = {})\n    \\<Longrightarrow> (\\<And> ant. ant |\\<in>| ants \\<Longrightarrow> freshenLC a ` (a_fresh ant) \\<inter> subst_lconsts s = {})\n    \\<Longrightarrow> eff (NatRule rule) entail hyps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nat_rule rule c ants;\n     entail = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n     hyps =\n     (\\<lambda>ant.\n         (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n         \\<Gamma> \\<turnstile>\n         subst s (freshen a (a_conc ant))) |`|\n     ants;\n     \\<And>ant f.\n        \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f = {};\n     \\<And>ant.\n        ant |\\<in>| ants \\<Longrightarrow>\n        freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n    \\<Longrightarrow> eff (NatRule rule) entail hyps", "by (drule eff.intros(2)) simp_all"], ["", "end"], ["", "context Abstract_Task begin"], ["", "lemma  natEff_InstI:\n  \"rule = (r,c)\n  \\<Longrightarrow> c \\<in> set (consequent r)\n  \\<Longrightarrow> antec = f_antecedent r\n  \\<Longrightarrow> natEff_Inst rule c antec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rule = (r, c); c \\<in> set (consequent r);\n     antec = f_antecedent r\\<rbrakk>\n    \\<Longrightarrow> natEff_Inst rule c antec", "by (metis natEff_Inst.intros)"], ["", "end"], ["", "context begin"], ["", "text \\<open>A typical task with local constants:: \\<open>\\<forall>x. Q x \\<longrightarrow> Q x\\<close>\\<close>"], ["", "text \\<open>First the task is defined as an @{term Abstract_Task}.\\<close>"], ["", "interpretation task: Abstract_Task\n  \"curry to_nat :: nat \\<Rightarrow> var \\<Rightarrow> var\"\n  map_lc\n  lc\n  \"closed\"\n  subst\n  lc_subst\n  map_lc_subst\n  \"Var 0 []\"\n  antecedent\n  consequent\n  prop_rules\n  \"[]\"\n  \"[ForallX (imp (Q x) (Q x))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abstract_Task (curry to_nat) map_lc lc Predicate_Formulas.closed subst\n     lc_subst map_lc_subst (Var 0 []) antecedent consequent prop_rules []\n     [ForallX (imp (Q x) (Q x))]", "by unfold_locales auto"], ["", "text \\<open>Then we show, that this task has a proof within our formalization of natural deduction\n  by giving a concrete proof tree.\\<close>"], ["", "abbreviation lx :: \"nat\" where \"lx \\<equiv> to_nat (1::nat,0::nat)\""], ["", "abbreviation base_tree :: \"((form fset \\<times> form) \\<times> (prop_rule \\<times> form) NatRule) tree\" where\n  \"base_tree \\<equiv> Node ({|Q (LC lx)|} \\<turnstile> Q (LC lx), Axiom) {||}\""], ["", "abbreviation imp_tree :: \"((form fset \\<times> form) \\<times> (prop_rule \\<times> form) NatRule) tree\" where\n  \"imp_tree \\<equiv> Node ({||} \\<turnstile> imp (Q (LC lx)) (Q (LC lx)), NatRule (impI, imp X Y)) {|base_tree|}\""], ["", "abbreviation solution_tree :: \"((form fset \\<times> form) \\<times> (prop_rule \\<times> form) NatRule) tree\" where\n  \"solution_tree \\<equiv> Node ({||} \\<turnstile> ForallX (imp (Q x) (Q x)), NatRule (allI, ForallX (P x))) {|imp_tree|}\""], ["", "abbreviation s1 where \"s1 \\<equiv> [(12, ([9], imp (Q x) (Q x)))] \""], ["", "abbreviation s2 where \"s2 \\<equiv> [(10, ([], Q (LC lx))), (11, ([], Q (LC lx)))] \""], ["", "lemma fv_subst_s1[simp]: \"fv_subst s1 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv_subst s1 = {}", "by (simp add: fv_subst_def)"], ["", "lemma subst1_simps[simp]:\n  \"subst s1 (P (LC n)) = imp (Q (LC n)) (Q (LC n))\"\n  \"subst s1 (ForallX (P x)) = ForallX (imp (Q x) (Q x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst s1 (P (LC n)) = imp (Q (LC n)) (Q (LC n)) &&&\n    subst s1 (ForallX (P x)) = ForallX (imp (Q x) (Q x))", "by simp_all"], ["", "lemma subst2_simps[simp]:\n    \"subst s2 X = Q (LC lx)\" \n    \"subst s2 Y = Q (LC lx)\"\n    \"subst s2 (imp X Y) = imp (subst s2 X) (subst s2 Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst s2 X = Q (LC lx) &&&\n    subst s2 Y = Q (LC lx) &&&\n    subst s2 (imp X Y) = imp (subst s2 X) (subst s2 Y)", "by simp_all"], ["", "lemma substI1: \"ForallX (imp (Q x) (Q x)) = subst s1 (predicate.freshen 1 (ForallX (P x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ForallX (imp (Q x) (Q x)) =\n    subst s1 (predicate.freshen 1 (ForallX (P x)))", "by (auto simp add: predicate.freshen_def Let_def)"], ["", "lemma substI2: \"imp (Q (LC lx)) (Q (LC lx)) = subst s2 (predicate.freshen 2 (imp X Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp (Q (LC lx)) (Q (LC lx)) = subst s2 (predicate.freshen 2 (imp X Y))", "by (auto simp add: predicate.freshen_def Let_def)"], ["", "declare subst.simps[simp del]"], ["", "lemma \"task.solved\""], ["proof (prove)\ngoal (1 subgoal):\n 1. task.solved", "unfolding task.solved_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       c |\\<in>| task.conc_forms \\<longrightarrow>\n       (\\<exists>\\<Gamma> t.\n           fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n           \\<Gamma> |\\<subseteq>| task.ass_forms \\<and>\n           task.wf t \\<and> tfinite t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma> t.\n       fst (tree.root t) =\n       (\\<Gamma> \\<turnstile> ForallX (imp (Q x) (Q x))) \\<and>\n       \\<Gamma> |\\<subseteq>| task.ass_forms \\<and>\n       task.wf t \\<and> tfinite t", "apply (rule_tac x=\"{||}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       fst (tree.root t) =\n       ({||} \\<turnstile> ForallX (imp (Q x) (Q x))) \\<and>\n       {||} |\\<subseteq>| task.ass_forms \\<and> task.wf t \\<and> tfinite t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       fst (tree.root t) =\n       ({||} \\<turnstile> ForallX (imp (Q x) (Q x))) \\<and>\n       task.wf t \\<and> tfinite t", "apply (rule_tac x=\"solution_tree\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (tree.root solution_tree) =\n    ({||} \\<turnstile> ForallX (imp (Q x) (Q x))) \\<and>\n    task.wf solution_tree \\<and> tfinite solution_tree", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. task.wf solution_tree \\<and> tfinite solution_tree", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. task.wf solution_tree\n 2. tfinite solution_tree", "apply (rule task.wf)"], ["proof (prove)\ngoal (4 subgoals):\n 1. snd (tree.root solution_tree) \\<in> task.R\n 2. task.effStep (tree.root solution_tree)\n     ((fst \\<circ> tree.root) |`| cont solution_tree)\n 3. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 4. tfinite solution_tree", "apply (solves \\<open>(auto simp add: stream.set_map task.n_rules_def)[1]\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. task.effStep (tree.root solution_tree)\n     ((fst \\<circ> tree.root) |`| cont solution_tree)\n 2. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 3. tfinite solution_tree", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. task.eff (NatRule (allI, ForallX (P x)))\n     ({||} \\<turnstile> ForallX (imp (Q x) (Q x)))\n     {|{||} \\<turnstile> imp (Q (LC lx)) (Q (LC lx))|}\n 2. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 3. tfinite solution_tree", "apply (rule task.eff_NatRuleI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. task.natEff_Inst (allI, ForallX (P x)) ?c55 ?ants55\n 2. ({||} \\<turnstile> ForallX (imp (Q x) (Q x))) =\n    (?\\<Gamma>55 \\<turnstile> subst ?s55 (predicate.freshen ?a55 ?c55))\n 3. {|{||} \\<turnstile> imp (Q (LC lx)) (Q (LC lx))|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst ?s55 (predicate.freshen ?a55 p)) |`|\n        a_hyps ant |\\<union>|\n        ?\\<Gamma>55 \\<turnstile>\n        subst ?s55 (predicate.freshen ?a55 (a_conc ant))) |`|\n    ?ants55\n 4. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| ?ants55; f |\\<in>| ?\\<Gamma>55\\<rbrakk>\n       \\<Longrightarrow> curry to_nat ?a55 ` a_fresh ant \\<inter> lc f = {}\n 5. \\<And>ant.\n       ant |\\<in>| ?ants55 \\<Longrightarrow>\n       curry to_nat ?a55 ` a_fresh ant \\<inter> lc_subst ?s55 = {}\n 6. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 7. tfinite solution_tree", "apply (solves \\<open>rule task.natEff_Inst.intros;simp\\<close>)"], ["proof (prove)\ngoal (6 subgoals):\n 1. ({||} \\<turnstile> ForallX (imp (Q x) (Q x))) =\n    (?\\<Gamma>55 \\<turnstile>\n     subst ?s55 (predicate.freshen ?a55 (ForallX (P x))))\n 2. {|{||} \\<turnstile> imp (Q (LC lx)) (Q (LC lx))|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst ?s55 (predicate.freshen ?a55 p)) |`|\n        a_hyps ant |\\<union>|\n        ?\\<Gamma>55 \\<turnstile>\n        subst ?s55 (predicate.freshen ?a55 (a_conc ant))) |`|\n    predicate.f_antecedent allI\n 3. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent allI;\n        f |\\<in>| ?\\<Gamma>55\\<rbrakk>\n       \\<Longrightarrow> curry to_nat ?a55 ` a_fresh ant \\<inter> lc f = {}\n 4. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent allI \\<Longrightarrow>\n       curry to_nat ?a55 ` a_fresh ant \\<inter> lc_subst ?s55 = {}\n 5. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 6. tfinite solution_tree", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. {||} = ?\\<Gamma>55 \\<and>\n    ForallX (imp (Q x) (Q x)) =\n    subst ?s55 (predicate.freshen ?a55 (ForallX (P x)))\n 2. {|{||} \\<turnstile> imp (Q (LC lx)) (Q (LC lx))|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst ?s55 (predicate.freshen ?a55 p)) |`|\n        a_hyps ant |\\<union>|\n        ?\\<Gamma>55 \\<turnstile>\n        subst ?s55 (predicate.freshen ?a55 (a_conc ant))) |`|\n    predicate.f_antecedent allI\n 3. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent allI;\n        f |\\<in>| ?\\<Gamma>55\\<rbrakk>\n       \\<Longrightarrow> curry to_nat ?a55 ` a_fresh ant \\<inter> lc f = {}\n 4. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent allI \\<Longrightarrow>\n       curry to_nat ?a55 ` a_fresh ant \\<inter> lc_subst ?s55 = {}\n 5. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 6. tfinite solution_tree", "apply (rule conjI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. {||} = ?\\<Gamma>55\n 2. ForallX (imp (Q x) (Q x)) =\n    subst ?s55 (predicate.freshen ?a55 (ForallX (P x)))\n 3. {|{||} \\<turnstile> imp (Q (LC lx)) (Q (LC lx))|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst ?s55 (predicate.freshen ?a55 p)) |`|\n        a_hyps ant |\\<union>|\n        ?\\<Gamma>55 \\<turnstile>\n        subst ?s55 (predicate.freshen ?a55 (a_conc ant))) |`|\n    predicate.f_antecedent allI\n 4. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent allI;\n        f |\\<in>| ?\\<Gamma>55\\<rbrakk>\n       \\<Longrightarrow> curry to_nat ?a55 ` a_fresh ant \\<inter> lc f = {}\n 5. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent allI \\<Longrightarrow>\n       curry to_nat ?a55 ` a_fresh ant \\<inter> lc_subst ?s55 = {}\n 6. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 7. tfinite solution_tree", "apply (solves \\<open>simp\\<close>)"], ["proof (prove)\ngoal (6 subgoals):\n 1. ForallX (imp (Q x) (Q x)) =\n    subst ?s55 (predicate.freshen ?a55 (ForallX (P x)))\n 2. {|{||} \\<turnstile> imp (Q (LC lx)) (Q (LC lx))|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst ?s55 (predicate.freshen ?a55 p)) |`|\n        a_hyps ant |\\<union>|\n        {||} \\<turnstile>\n        subst ?s55 (predicate.freshen ?a55 (a_conc ant))) |`|\n    predicate.f_antecedent allI\n 3. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent allI;\n        f |\\<in>| {||}\\<rbrakk>\n       \\<Longrightarrow> curry to_nat ?a55 ` a_fresh ant \\<inter> lc f = {}\n 4. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent allI \\<Longrightarrow>\n       curry to_nat ?a55 ` a_fresh ant \\<inter> lc_subst ?s55 = {}\n 5. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 6. tfinite solution_tree", "apply (solves \\<open>rule substI1\\<close>)"], ["proof (prove)\ngoal (5 subgoals):\n 1. {|{||} \\<turnstile> imp (Q (LC lx)) (Q (LC lx))|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst s1 (predicate.freshen 1 p)) |`|\n        a_hyps ant |\\<union>|\n        {||} \\<turnstile>\n        subst s1 (predicate.freshen 1 (a_conc ant))) |`|\n    predicate.f_antecedent allI\n 2. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent allI;\n        f |\\<in>| {||}\\<rbrakk>\n       \\<Longrightarrow> curry to_nat 1 ` a_fresh ant \\<inter> lc f = {}\n 3. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent allI \\<Longrightarrow>\n       curry to_nat 1 ` a_fresh ant \\<inter> lc_subst s1 = {}\n 4. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 5. tfinite solution_tree", "apply (simp add: predicate.f_antecedent_def predicate.freshen_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. imp (Q (LC lx)) (Q (LC lx)) =\n    subst s1 (map_lc (\\<lambda>x. to_nat (1, x)) (a_conc allI_input))\n 2. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent allI;\n        f |\\<in>| {||}\\<rbrakk>\n       \\<Longrightarrow> curry to_nat 1 ` a_fresh ant \\<inter> lc f = {}\n 3. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent allI \\<Longrightarrow>\n       curry to_nat 1 ` a_fresh ant \\<inter> lc_subst s1 = {}\n 4. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 5. tfinite solution_tree", "apply (subst antecedent.sel(2))"], ["proof (prove)\ngoal (5 subgoals):\n 1. imp (Q (LC lx)) (Q (LC lx)) =\n    subst s1 (map_lc (\\<lambda>x. to_nat (1, x)) (P (LC 0)))\n 2. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent allI;\n        f |\\<in>| {||}\\<rbrakk>\n       \\<Longrightarrow> curry to_nat 1 ` a_fresh ant \\<inter> lc f = {}\n 3. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent allI \\<Longrightarrow>\n       curry to_nat 1 ` a_fresh ant \\<inter> lc_subst s1 = {}\n 4. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 5. tfinite solution_tree", "apply (solves \\<open>simp\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent allI;\n        f |\\<in>| {||}\\<rbrakk>\n       \\<Longrightarrow> curry to_nat 1 ` a_fresh ant \\<inter> lc f = {}\n 2. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent allI \\<Longrightarrow>\n       curry to_nat 1 ` a_fresh ant \\<inter> lc_subst s1 = {}\n 3. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 4. tfinite solution_tree", "apply (solves \\<open>simp\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent allI \\<Longrightarrow>\n       curry to_nat 1 ` a_fresh ant \\<inter> lc_subst s1 = {}\n 2. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 3. tfinite solution_tree", "apply (solves \\<open>simp\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t'. t' |\\<in>| cont solution_tree \\<Longrightarrow> task.wf t'\n 2. tfinite solution_tree", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. task.wf imp_tree\n 2. tfinite solution_tree", "apply (rule task.wf)"], ["proof (prove)\ngoal (4 subgoals):\n 1. snd (tree.root imp_tree) \\<in> task.R\n 2. task.effStep (tree.root imp_tree)\n     ((fst \\<circ> tree.root) |`| cont imp_tree)\n 3. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 4. tfinite solution_tree", "apply (solves \\<open>(auto simp add: stream.set_map task.n_rules_def)[1]\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. task.effStep (tree.root imp_tree)\n     ((fst \\<circ> tree.root) |`| cont imp_tree)\n 2. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 3. tfinite solution_tree", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. task.eff (NatRule (impI, imp X Y))\n     ({||} \\<turnstile> imp (Q (LC lx)) (Q (LC lx)))\n     {|{|Q (LC lx)|} \\<turnstile> Q (LC lx)|}\n 2. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 3. tfinite solution_tree", "apply (rule task.eff_NatRuleI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. task.natEff_Inst (impI, imp X Y) ?c97 ?ants97\n 2. ({||} \\<turnstile> imp (Q (LC lx)) (Q (LC lx))) =\n    (?\\<Gamma>97 \\<turnstile> subst ?s97 (predicate.freshen ?a97 ?c97))\n 3. {|{|Q (LC lx)|} \\<turnstile> Q (LC lx)|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst ?s97 (predicate.freshen ?a97 p)) |`|\n        a_hyps ant |\\<union>|\n        ?\\<Gamma>97 \\<turnstile>\n        subst ?s97 (predicate.freshen ?a97 (a_conc ant))) |`|\n    ?ants97\n 4. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| ?ants97; f |\\<in>| ?\\<Gamma>97\\<rbrakk>\n       \\<Longrightarrow> curry to_nat ?a97 ` a_fresh ant \\<inter> lc f = {}\n 5. \\<And>ant.\n       ant |\\<in>| ?ants97 \\<Longrightarrow>\n       curry to_nat ?a97 ` a_fresh ant \\<inter> lc_subst ?s97 = {}\n 6. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 7. tfinite solution_tree", "apply (solves \\<open>rule task.natEff_Inst.intros; simp\\<close>)"], ["proof (prove)\ngoal (6 subgoals):\n 1. ({||} \\<turnstile> imp (Q (LC lx)) (Q (LC lx))) =\n    (?\\<Gamma>97 \\<turnstile> subst ?s97 (predicate.freshen ?a97 (imp X Y)))\n 2. {|{|Q (LC lx)|} \\<turnstile> Q (LC lx)|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst ?s97 (predicate.freshen ?a97 p)) |`|\n        a_hyps ant |\\<union>|\n        ?\\<Gamma>97 \\<turnstile>\n        subst ?s97 (predicate.freshen ?a97 (a_conc ant))) |`|\n    predicate.f_antecedent impI\n 3. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent impI;\n        f |\\<in>| ?\\<Gamma>97\\<rbrakk>\n       \\<Longrightarrow> curry to_nat ?a97 ` a_fresh ant \\<inter> lc f = {}\n 4. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent impI \\<Longrightarrow>\n       curry to_nat ?a97 ` a_fresh ant \\<inter> lc_subst ?s97 = {}\n 5. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 6. tfinite solution_tree", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. {||} = ?\\<Gamma>97 \\<and>\n    imp (Q (LC lx)) (Q (LC lx)) =\n    subst ?s97 (predicate.freshen ?a97 (imp X Y))\n 2. {|{|Q (LC lx)|} \\<turnstile> Q (LC lx)|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst ?s97 (predicate.freshen ?a97 p)) |`|\n        a_hyps ant |\\<union>|\n        ?\\<Gamma>97 \\<turnstile>\n        subst ?s97 (predicate.freshen ?a97 (a_conc ant))) |`|\n    predicate.f_antecedent impI\n 3. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent impI;\n        f |\\<in>| ?\\<Gamma>97\\<rbrakk>\n       \\<Longrightarrow> curry to_nat ?a97 ` a_fresh ant \\<inter> lc f = {}\n 4. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent impI \\<Longrightarrow>\n       curry to_nat ?a97 ` a_fresh ant \\<inter> lc_subst ?s97 = {}\n 5. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 6. tfinite solution_tree", "apply (rule conjI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. {||} = ?\\<Gamma>97\n 2. imp (Q (LC lx)) (Q (LC lx)) =\n    subst ?s97 (predicate.freshen ?a97 (imp X Y))\n 3. {|{|Q (LC lx)|} \\<turnstile> Q (LC lx)|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst ?s97 (predicate.freshen ?a97 p)) |`|\n        a_hyps ant |\\<union>|\n        ?\\<Gamma>97 \\<turnstile>\n        subst ?s97 (predicate.freshen ?a97 (a_conc ant))) |`|\n    predicate.f_antecedent impI\n 4. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent impI;\n        f |\\<in>| ?\\<Gamma>97\\<rbrakk>\n       \\<Longrightarrow> curry to_nat ?a97 ` a_fresh ant \\<inter> lc f = {}\n 5. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent impI \\<Longrightarrow>\n       curry to_nat ?a97 ` a_fresh ant \\<inter> lc_subst ?s97 = {}\n 6. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 7. tfinite solution_tree", "apply (solves \\<open>simp\\<close>)"], ["proof (prove)\ngoal (6 subgoals):\n 1. imp (Q (LC lx)) (Q (LC lx)) =\n    subst ?s97 (predicate.freshen ?a97 (imp X Y))\n 2. {|{|Q (LC lx)|} \\<turnstile> Q (LC lx)|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst ?s97 (predicate.freshen ?a97 p)) |`|\n        a_hyps ant |\\<union>|\n        {||} \\<turnstile>\n        subst ?s97 (predicate.freshen ?a97 (a_conc ant))) |`|\n    predicate.f_antecedent impI\n 3. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent impI;\n        f |\\<in>| {||}\\<rbrakk>\n       \\<Longrightarrow> curry to_nat ?a97 ` a_fresh ant \\<inter> lc f = {}\n 4. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent impI \\<Longrightarrow>\n       curry to_nat ?a97 ` a_fresh ant \\<inter> lc_subst ?s97 = {}\n 5. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 6. tfinite solution_tree", "apply (solves \\<open>rule substI2\\<close>)"], ["proof (prove)\ngoal (5 subgoals):\n 1. {|{|Q (LC lx)|} \\<turnstile> Q (LC lx)|} =\n    (\\<lambda>ant.\n        (\\<lambda>p. subst s2 (predicate.freshen 2 p)) |`|\n        a_hyps ant |\\<union>|\n        {||} \\<turnstile>\n        subst s2 (predicate.freshen 2 (a_conc ant))) |`|\n    predicate.f_antecedent impI\n 2. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent impI;\n        f |\\<in>| {||}\\<rbrakk>\n       \\<Longrightarrow> curry to_nat 2 ` a_fresh ant \\<inter> lc f = {}\n 3. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent impI \\<Longrightarrow>\n       curry to_nat 2 ` a_fresh ant \\<inter> lc_subst s2 = {}\n 4. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 5. tfinite solution_tree", "apply (solves \\<open>simp add: predicate.f_antecedent_def predicate.freshen_def\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| predicate.f_antecedent impI;\n        f |\\<in>| {||}\\<rbrakk>\n       \\<Longrightarrow> curry to_nat 2 ` a_fresh ant \\<inter> lc f = {}\n 2. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent impI \\<Longrightarrow>\n       curry to_nat 2 ` a_fresh ant \\<inter> lc_subst s2 = {}\n 3. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 4. tfinite solution_tree", "apply (solves \\<open>simp\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ant.\n       ant |\\<in>| predicate.f_antecedent impI \\<Longrightarrow>\n       curry to_nat 2 ` a_fresh ant \\<inter> lc_subst s2 = {}\n 2. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 3. tfinite solution_tree", "apply (solves \\<open>simp add: predicate.f_antecedent_def\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t'. t' |\\<in>| cont imp_tree \\<Longrightarrow> task.wf t'\n 2. tfinite solution_tree", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. task.wf base_tree\n 2. tfinite solution_tree", "apply (solves \\<open>(auto intro: task.wf intro!: task.eff.intros(1))[1]\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tfinite solution_tree", "apply (solves \\<open>(rule tfinite.intros, simp)+\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation vertices where \"vertices \\<equiv> {|0::nat,1,2 |}\""], ["", "fun nodeOf  where \n    \"nodeOf n = [Conclusion (ForallX (imp (Q x) (Q x))), \n                 Rule allI, \n                 Rule impI] ! n \""], ["", "fun inst  where \n    \"inst n = [[],s1,s2] ! n\""], ["", "interpretation task: Vertex_Graph task.nodes task.inPorts task.outPorts vertices nodeOf"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation e1 :: \"(nat, form, nat) edge'\"\n  where \"e1 \\<equiv> ((1,Reg (ForallX (P x))), (0,plain_ant (ForallX (imp (Q x) (Q x)))))\""], ["", "abbreviation e2  :: \"(nat, form, nat) edge'\"\n  where \"e2 \\<equiv> ((2,Reg (imp X Y)), (1,allI_input))\""], ["", "abbreviation e3  :: \"(nat, form, nat) edge'\"\n  where \"e3 \\<equiv> ((2,Hyp X (impI_input)), (2,impI_input))\""], ["", "abbreviation task_edges :: \"(nat, form, nat) edge' set\" where \"task_edges \\<equiv> {e1, e2, e3}\""], ["", "interpretation task: Scoped_Graph task.nodes task.inPorts task.outPorts vertices nodeOf task_edges task.hyps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Scoped_Graph task.nodes task.inPorts task.outPorts vertices nodeOf\n     task_edges task.hyps", "by standard (auto simp add: predicate.f_consequent_def predicate.f_antecedent_def)"], ["", "interpretation task: Instantiation\n  task.inPorts\n  task.outPorts\n  nodeOf\n  task.hyps\n  task.nodes\n  task_edges\n  vertices\n  task.labelsIn\n  task.labelsOut\n  \"curry to_nat :: nat \\<Rightarrow> var \\<Rightarrow> var\"\n  map_lc\n  lc\n  \"closed\"\n  subst\n  lc_subst\n  map_lc_subst\n  \"Var 0 []\"\n  \"id\"\n  \"inst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Instantiation task.inPorts task.outPorts task.hyps vertices\n     (curry to_nat) map_lc lc Predicate_Formulas.closed subst lc_subst\n     map_lc_subst (Var 0 []) id", "by unfold_locales simp"], ["", "text \\<open>Finally we can also show that there is a proof graph for this task.\\<close>"], ["", "interpretation Well_Scoped_Graph\n  task.nodes\n  task.inPorts\n  task.outPorts\n  vertices\n  nodeOf\n  task_edges\n  task.hyps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Well_Scoped_Graph task.nodes task.inPorts task.outPorts vertices nodeOf\n     task_edges task.hyps", "by standard (auto split: if_splits)"], ["", "lemma no_path_01[simp]: \"task.path 0 v pth \\<longleftrightarrow> (pth = [] \\<and> v = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. task.path 0 v pth = (pth = [] \\<and> v = 0)", "by (cases pth) (auto simp add: task.path_cons_simp)"], ["", "lemma no_path_12[simp]: \"\\<not> task.path 1 2 pth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> task.path 1 2 pth", "by (cases pth) (auto simp add: task.path_cons_simp)"], ["", "interpretation Acyclic_Graph\n  task.nodes\n  task.inPorts\n  task.outPorts\n  vertices\n  nodeOf\n  task_edges\n  task.hyps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Acyclic_Graph task.nodes task.inPorts task.outPorts vertices nodeOf\n     task_edges task.hyps", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v pth.\n       \\<lbrakk>task.path v v pth; task.hyps_free pth\\<rbrakk>\n       \\<Longrightarrow> pth = []", "fix v pth"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v pth.\n       \\<lbrakk>task.path v v pth; task.hyps_free pth\\<rbrakk>\n       \\<Longrightarrow> pth = []", "assume \"task.path v v pth\" and \"task.hyps_free pth\""], ["proof (state)\nthis:\n  task.path v v pth\n  task.hyps_free pth\n\ngoal (1 subgoal):\n 1. \\<And>v pth.\n       \\<lbrakk>task.path v v pth; task.hyps_free pth\\<rbrakk>\n       \\<Longrightarrow> pth = []", "thus \"pth = []\""], ["proof (prove)\nusing this:\n  task.path v v pth\n  task.hyps_free pth\n\ngoal (1 subgoal):\n 1. pth = []", "by (cases pth) (auto simp add: task.path_cons_simp predicate.f_antecedent_def)"], ["proof (state)\nthis:\n  pth = []\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation Saturated_Graph\n  task.nodes\n  task.inPorts\n  task.outPorts\n  vertices\n  nodeOf\n  task_edges"], ["proof (prove)\ngoal (1 subgoal):\n 1. Saturated_Graph task.nodes task.inPorts task.outPorts vertices nodeOf\n     task_edges", "by standard\n   (auto simp add: predicate.f_consequent_def predicate.f_antecedent_def)"], ["", "interpretation Pruned_Port_Graph\n  task.nodes\n  task.inPorts\n  task.outPorts\n  vertices\n  nodeOf\n  task_edges"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pruned_Port_Graph task.nodes task.inPorts task.outPorts vertices nodeOf\n     task_edges", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v |\\<in>| vertices \\<Longrightarrow>\n       \\<exists>pth v'. task.path v v' pth \\<and> task.terminal_vertex v'", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v |\\<in>| vertices \\<Longrightarrow>\n       \\<exists>pth v'. task.path v v' pth \\<and> task.terminal_vertex v'", "assume \"v |\\<in>| vertices\""], ["proof (state)\nthis:\n  v |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v |\\<in>| vertices \\<Longrightarrow>\n       \\<exists>pth v'. task.path v v' pth \\<and> task.terminal_vertex v'", "hence \"\\<exists> pth. task.path v 0 pth\""], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<exists>pth. task.path v 0 pth", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. v = 1 \\<Longrightarrow> \\<exists>pth. task.path 1 0 pth\n 2. v = 2 \\<Longrightarrow> \\<exists>pth. task.path 2 0 pth", "apply (rule exI[where x = \"[e1]\"], auto simp add: task.path_cons_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = 2 \\<Longrightarrow> \\<exists>pth. task.path 2 0 pth", "apply (rule exI[where x = \"[e2,e1]\"], auto simp add: task.path_cons_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>pth. task.path v 0 pth\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v |\\<in>| vertices \\<Longrightarrow>\n       \\<exists>pth v'. task.path v v' pth \\<and> task.terminal_vertex v'", "moreover"], ["proof (state)\nthis:\n  \\<exists>pth. task.path v 0 pth\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v |\\<in>| vertices \\<Longrightarrow>\n       \\<exists>pth v'. task.path v v' pth \\<and> task.terminal_vertex v'", "have \"task.terminal_vertex 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. task.terminal_vertex 0", "by auto"], ["proof (state)\nthis:\n  task.terminal_vertex 0\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v |\\<in>| vertices \\<Longrightarrow>\n       \\<exists>pth v'. task.path v v' pth \\<and> task.terminal_vertex v'", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>pth. task.path v 0 pth\n  task.terminal_vertex 0", "show \"\\<exists>pth v'. task.path v v' pth \\<and> task.terminal_vertex v'\""], ["proof (prove)\nusing this:\n  \\<exists>pth. task.path v 0 pth\n  task.terminal_vertex 0\n\ngoal (1 subgoal):\n 1. \\<exists>pth v'. task.path v v' pth \\<and> task.terminal_vertex v'", "by blast"], ["proof (state)\nthis:\n  \\<exists>pth v'. task.path v v' pth \\<and> task.terminal_vertex v'\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation Well_Shaped_Graph\n  task.nodes\n  task.inPorts\n  task.outPorts\n  vertices\n  nodeOf task_edges\n  task.hyps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Well_Shaped_Graph task.nodes task.inPorts task.outPorts vertices nodeOf\n     task_edges task.hyps", ".."], ["", "interpretation Solution\n  task.inPorts\n  task.outPorts\n  nodeOf\n  task.hyps\n  task.nodes\n  vertices\n  task.labelsIn\n  task.labelsOut\n  \"curry to_nat :: nat \\<Rightarrow> var \\<Rightarrow> var\"\n  map_lc\n  lc\n  \"closed\"\n  subst\n  lc_subst\n  map_lc_subst\n  \"Var 0 []\"\n  id\n  inst\n  task_edges"], ["proof (prove)\ngoal (1 subgoal):\n 1. Solution task.inPorts task.outPorts nodeOf task.hyps vertices\n     task.labelsIn task.labelsOut (curry to_nat) map_lc lc\n     Predicate_Formulas.closed subst lc_subst map_lc_subst (Var 0 []) id\n     inst task_edges", "by standard\n   (auto simp add: task.labelAtOut_def task.labelAtIn_def predicate.freshen_def, subst antecedent.sel, simp)"], ["", "interpretation Proof_Graph\n  task.nodes\n  task.inPorts\n  task.outPorts\n  vertices\n  nodeOf\n  task_edges\n  task.hyps\n  task.labelsIn\n  task.labelsOut\n  \"curry to_nat :: nat \\<Rightarrow> var \\<Rightarrow> var\"\n  map_lc\n  lc\n  \"closed\"\n  subst\n  lc_subst\n  map_lc_subst\n  \"Var 0 []\"\n  id\n  inst"], ["proof (prove)\ngoal (1 subgoal):\n 1. Proof_Graph task.nodes task.inPorts task.outPorts vertices nodeOf\n     task_edges task.hyps task.labelsIn task.labelsOut (curry to_nat) map_lc\n     lc Predicate_Formulas.closed subst lc_subst map_lc_subst (Var 0 []) id\n     inst", ".."], ["", "lemma path_20:\n  assumes \"task.path 2 0 pth\"\n  shows \"(1, allI_input) \\<in> snd ` set pth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1, allI_input) \\<in> snd ` set pth", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (1, allI_input) \\<in> snd ` set pth", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (1, allI_input) \\<in> snd ` set pth", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. (1, allI_input) \\<in> snd ` set pth", "assume \"task.path v 0 pth\""], ["proof (state)\nthis:\n  task.path v 0 pth\n\ngoal (1 subgoal):\n 1. (1, allI_input) \\<in> snd ` set pth", "hence \"v = 0 \\<or> v = 1 \\<or> (1, allI_input) \\<in> snd ` set pth\""], ["proof (prove)\nusing this:\n  task.path v 0 pth\n\ngoal (1 subgoal):\n 1. v = 0 \\<or> v = 1 \\<or> (1, allI_input) \\<in> snd ` set pth", "by (induction v \"0::nat\" pth rule: task.path.induct) auto"], ["proof (state)\nthis:\n  v = 0 \\<or> v = 1 \\<or> (1, allI_input) \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. (1, allI_input) \\<in> snd ` set pth", "}"], ["proof (state)\nthis:\n  task.path ?v3 0 pth \\<Longrightarrow>\n  ?v3 = 0 \\<or> ?v3 = 1 \\<or> (1, allI_input) \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. (1, allI_input) \\<in> snd ` set pth", "from this[OF assms]"], ["proof (chain)\npicking this:\n  2 = 0 \\<or> 2 = 1 \\<or> (1, allI_input) \\<in> snd ` set pth", "show ?thesis"], ["proof (prove)\nusing this:\n  2 = 0 \\<or> 2 = 1 \\<or> (1, allI_input) \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. (1, allI_input) \\<in> snd ` set pth", "by auto"], ["proof (state)\nthis:\n  (1, allI_input) \\<in> snd ` set pth\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scope_21: \"2 \\<in> task.scope (1, allI_input)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<in> task.scope (1, allI_input)", "by (auto intro!: task.scope.intros elim: path_20 simp add: task.outPortsRule_def predicate.f_antecedent_def predicate.f_consequent_def)"], ["", "interpretation Scoped_Proof_Graph\n  \"curry to_nat :: nat \\<Rightarrow> var \\<Rightarrow> var\"\n  map_lc\n  lc\n  \"closed\"\n  subst\n  lc_subst\n  map_lc_subst\n  \"Var 0 []\"\n  task.inPorts\n  task.outPorts\n  nodeOf\n  task.hyps\n  task.nodes\n  vertices\n  task.labelsIn\n  task.labelsOut\n  id\n  inst\n  task_edges\n  task.local_vars"], ["proof (prove)\ngoal (1 subgoal):\n 1. Scoped_Proof_Graph (curry to_nat) map_lc lc Predicate_Formulas.closed\n     subst lc_subst map_lc_subst (Var 0 []) task.inPorts task.outPorts\n     nodeOf task.hyps task.nodes vertices task.labelsIn task.labelsOut id\n     inst task_edges task.local_vars", "by standard (auto simp add: predicate.f_antecedent_def scope_21)"], ["", "interpretation Tasked_Proof_Graph\n  \"curry to_nat :: nat \\<Rightarrow> var \\<Rightarrow> var\"\n  map_lc\n  lc\n  \"closed\"\n  subst\n  lc_subst\n  map_lc_subst\n  \"Var 0 []\"\n  antecedent\n  consequent\n  prop_rules\n  \"[]\"\n  \"[ForallX (imp (Q x) (Q x))]\"\n  vertices\n  nodeOf\n  task_edges\n  id\n  inst"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tasked_Proof_Graph (curry to_nat) map_lc lc Predicate_Formulas.closed\n     subst lc_subst map_lc_subst (Var 0 []) antecedent consequent prop_rules\n     [] [ForallX (imp (Q x) (Q x))] vertices nodeOf task_edges id inst", "by unfold_locales auto"], ["", "end"], ["", "end"]]}