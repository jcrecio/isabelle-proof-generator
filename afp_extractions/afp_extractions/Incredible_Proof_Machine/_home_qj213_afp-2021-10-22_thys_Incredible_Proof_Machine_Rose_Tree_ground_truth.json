{"file_name": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine/Rose_Tree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine", "problem_names": ["lemma it_paths_eq [pred_set_conv]: \"it_pathsP t = (\\<lambda>x. x \\<in> it_paths t)\"", "lemmas it_paths_intros [intro?] = it_pathsP.intros[to_set]", "lemmas it_paths_induct [consumes 1, induct set: it_paths] = it_pathsP.induct[to_set]", "lemmas it_paths_cases [consumes 1, cases set: it_paths] = it_pathsP.cases[to_set]", "lemmas it_paths_ConsE = it_pathP_ConsE[to_set]", "lemmas it_paths_RNodeE = it_pathP_RNodeE[to_set]", "lemmas it_paths_simps = it_pathsP.simps[to_set]", "lemmas it_paths_intros(1)[simp]", "lemma it_paths_RNode_Nil[simp]: \"it_paths (RNode r []) = {[]}\"", "lemma it_paths_Union: \"it_paths t \\<subseteq> insert [] (Union (((\\<lambda> (i,t). ((#) i) ` it_paths t) ` set (List.enumerate (0::nat) (children t)))))\"", "lemma finite_it_paths[simp]: \"finite (it_paths t)\"", "lemma it_paths_SnocE[elim_format]:\n  assumes \"is @ [i] \\<in> it_paths t\"\n  shows \"is \\<in> it_paths t \\<and> i < length (children (tree_at t is))\"", "lemma it_paths_strict_prefix:\n  assumes \"is \\<in> it_paths t\"\n  assumes \"strict_prefix is' is\"\n  shows \"is' \\<in> it_paths t\"", "lemma it_paths_prefix:\n  assumes \"is \\<in> it_paths t\"\n  assumes \"prefix is' is\"\n  shows \"is' \\<in> it_paths t\"", "lemma it_paths_butlast:\n  assumes \"is \\<in> it_paths t\"\n  shows \"butlast is \\<in> it_paths t\"", "lemma it_path_SnocI:\n  assumes \"is \\<in> it_paths t\" \n  assumes \"i < length (children (tree_at t is))\"\n  shows \"is @ [i] \\<in> it_paths t\""], "translations": [["", "lemma it_paths_eq [pred_set_conv]: \"it_pathsP t = (\\<lambda>x. x \\<in> it_paths t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_pathsP t = (\\<lambda>x. x \\<in> it_paths t)", "by(simp add: it_paths_def)"], ["", "lemmas it_paths_intros [intro?] = it_pathsP.intros[to_set]"], ["", "lemmas it_paths_induct [consumes 1, induct set: it_paths] = it_pathsP.induct[to_set]"], ["", "lemmas it_paths_cases [consumes 1, cases set: it_paths] = it_pathsP.cases[to_set]"], ["", "lemmas it_paths_ConsE = it_pathP_ConsE[to_set]"], ["", "lemmas it_paths_RNodeE = it_pathP_RNodeE[to_set]"], ["", "lemmas it_paths_simps = it_pathsP.simps[to_set]"], ["", "lemmas it_paths_intros(1)[simp]"], ["", "lemma it_paths_RNode_Nil[simp]: \"it_paths (RNode r []) = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_paths (RNode r []) = {[]}", "by (auto elim: it_paths_cases)"], ["", "lemma it_paths_Union: \"it_paths t \\<subseteq> insert [] (Union (((\\<lambda> (i,t). ((#) i) ` it_paths t) ` set (List.enumerate (0::nat) (children t)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_paths t\n    \\<subseteq> insert []\n                 (\\<Union>(i, t)\\<in>set (enumerate 0 (children t)).\n                     (#) i ` it_paths t)", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> it_paths t \\<Longrightarrow>\n       x \\<in> insert []\n                (\\<Union>(i, t)\\<in>set (enumerate 0 (children t)).\n                    (#) i ` it_paths t)", "apply (erule it_paths_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x ta.\n       \\<lbrakk>t = ta; x = []\\<rbrakk>\n       \\<Longrightarrow> x \\<in> insert []\n                                  (\\<Union>(i,\nt)\\<in>set (enumerate 0 (children t)). (#) i ` it_paths t)\n 2. \\<And>x i ta t' is.\n       \\<lbrakk>t = ta; x = i # is; i < length (children ta);\n        children ta ! i = t'; is \\<in> it_paths t'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> insert []\n                                  (\\<Union>(i,\nt)\\<in>set (enumerate 0 (children t)). (#) i ` it_paths t)", "apply (auto intro!: bexI simp add: in_set_enumerate_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_it_paths[simp]: \"finite (it_paths t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (it_paths t)", "by (induction t) (auto intro!:  finite_subset[OF it_paths_Union]  simp add: in_set_enumerate_eq)"], ["", "subsubsection \\<open>Indexing into a rose tree\\<close>"], ["", "fun tree_at :: \"'a rose_tree \\<Rightarrow> nat list \\<Rightarrow> 'a rose_tree\" where\n  \"tree_at t [] = t\"\n| \"tree_at t (i#is) = tree_at (children t ! i) is\""], ["", "lemma it_paths_SnocE[elim_format]:\n  assumes \"is @ [i] \\<in> it_paths t\"\n  shows \"is \\<in> it_paths t \\<and> i < length (children (tree_at t is))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is \\<in> it_paths t \\<and> i < length (children (tree_at t is))", "using assms"], ["proof (prove)\nusing this:\n  is @ [i] \\<in> it_paths t\n\ngoal (1 subgoal):\n 1. is \\<in> it_paths t \\<and> i < length (children (tree_at t is))", "by (induction \"is\" arbitrary: t)(auto intro!: it_paths_intros elim!: it_paths_ConsE)"], ["", "lemma it_paths_strict_prefix:\n  assumes \"is \\<in> it_paths t\"\n  assumes \"strict_prefix is' is\"\n  shows \"is' \\<in> it_paths t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is' \\<in> it_paths t", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is' \\<in> it_paths t", "from assms(2)"], ["proof (chain)\npicking this:\n  strict_prefix is' is", "obtain is'' where \"is = is' @ is''\""], ["proof (prove)\nusing this:\n  strict_prefix is' is\n\ngoal (1 subgoal):\n 1. (\\<And>is''. is = is' @ is'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using strict_prefixE'"], ["proof (prove)\nusing this:\n  strict_prefix is' is\n  \\<lbrakk>strict_prefix ?xs ?ys;\n   \\<And>z zs. ?ys = ?xs @ z # zs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>is''. is = is' @ is'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is = is' @ is''\n\ngoal (1 subgoal):\n 1. is' \\<in> it_paths t", "from assms(1)[unfolded this]"], ["proof (chain)\npicking this:\n  is' @ is'' \\<in> it_paths t", "show ?thesis"], ["proof (prove)\nusing this:\n  is' @ is'' \\<in> it_paths t\n\ngoal (1 subgoal):\n 1. is' \\<in> it_paths t", "by(induction is' arbitrary: t) (auto elim!: it_paths_ConsE intro!: it_paths_intros)"], ["proof (state)\nthis:\n  is' \\<in> it_paths t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma it_paths_prefix:\n  assumes \"is \\<in> it_paths t\"\n  assumes \"prefix is' is\"\n  shows \"is' \\<in> it_paths t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is' \\<in> it_paths t", "using assms it_paths_strict_prefix strict_prefixI"], ["proof (prove)\nusing this:\n  is \\<in> it_paths t\n  prefix is' is\n  \\<lbrakk>?is \\<in> it_paths ?t; strict_prefix ?is' ?is\\<rbrakk>\n  \\<Longrightarrow> ?is' \\<in> it_paths ?t\n  \\<lbrakk>prefix ?xs ?ys; ?xs \\<noteq> ?ys\\<rbrakk>\n  \\<Longrightarrow> strict_prefix ?xs ?ys\n\ngoal (1 subgoal):\n 1. is' \\<in> it_paths t", "by fastforce"], ["", "lemma it_paths_butlast:\n  assumes \"is \\<in> it_paths t\"\n  shows \"butlast is \\<in> it_paths t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast is \\<in> it_paths t", "using assms prefixeq_butlast"], ["proof (prove)\nusing this:\n  is \\<in> it_paths t\n  prefix (butlast ?xs) ?xs\n\ngoal (1 subgoal):\n 1. butlast is \\<in> it_paths t", "by (rule it_paths_prefix)"], ["", "lemma it_path_SnocI:\n  assumes \"is \\<in> it_paths t\" \n  assumes \"i < length (children (tree_at t is))\"\n  shows \"is @ [i] \\<in> it_paths t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is @ [i] \\<in> it_paths t", "using assms"], ["proof (prove)\nusing this:\n  is \\<in> it_paths t\n  i < length (children (tree_at t is))\n\ngoal (1 subgoal):\n 1. is @ [i] \\<in> it_paths t", "by (induction t arbitrary: \"is\" i)\n     (auto 4 4  elim!: it_paths_RNodeE intro: it_paths_intros)"], ["", "end"]]}