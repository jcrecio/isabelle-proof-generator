{"file_name": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine/Incredible_Propositional.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine", "problem_names": ["lemma iR_prop_rules [simp]: \"sset prop_rules = {andI, andE, impI, impE}\""], "translations": [["", "lemma iR_prop_rules [simp]: \"sset prop_rules = {andI, andE, impI, impE}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset prop_rules = {andI, andE, impI, impE}", "unfolding prop_rules_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (cycle [andI, andE, impI, impE]) = {andI, andE, impI, impE}", "by simp"], ["", "text \\<open>Just some short notation.\\<close>"], ["", "abbreviation X :: \"(string,'a) pform\"\n  where \"X \\<equiv> Var ''X''\""], ["", "abbreviation Y :: \"(string,'a) pform\"\n  where \"Y \\<equiv> Var ''Y''\""], ["", "text \\<open>Finally the right- and left-hand sides of the rules.\\<close>"], ["", "fun consequent :: \"prop_rule \\<Rightarrow> (string, prop_funs) pform list\"\n  where \"consequent andI = [Fun and [X, Y]]\"\n  | \"consequent andE = [X, Y]\"\n  | \"consequent impI = [Fun imp [X, Y]]\"\n  | \"consequent impE = [Y]\""], ["", "fun antecedent :: \"prop_rule \\<Rightarrow> ((string,prop_funs) pform,string) antecedent list\"\n  where \"antecedent andI = [plain_ant X, plain_ant Y]\"\n  | \"antecedent andE = [plain_ant (Fun and [X, Y])]\"\n  | \"antecedent impI = [Antecedent {|X|} Y {}]\"\n  | \"antecedent impE = [plain_ant (Fun imp [X, Y]), plain_ant X]\""], ["", "interpretation propositional: Abstract_Rules\n  \"curry (SOME f. bij f):: nat \\<Rightarrow> string \\<Rightarrow> string\"\n  \"\\<lambda>_. id\"\n  \"\\<lambda>_. {}\"\n  \"closed :: (string, prop_funs) pform \\<Rightarrow> bool\"\n  subst\n  \"\\<lambda>_. {}\"\n  \"\\<lambda>_. id\"\n  \"Var undefined\"\n  antecedent\n  consequent\n  prop_rules"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abstract_Rules (curry (SOME f. bij f)) (\\<lambda>_. id) (\\<lambda>_. {})\n     closed subst (\\<lambda>_. {}) (\\<lambda>_. id) (Var undefined)\n     antecedent consequent prop_rules", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>xs\\<in>sset prop_rules. consequent xs \\<noteq> []\n 2. \\<forall>xs\\<in>sset prop_rules.\n       (\\<Union>_\\<in>set (consequent xs). {}) = {}\n 3. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 4. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {})\n                         \\<subseteq> a_fresh p", "show \"\\<forall>xs\\<in>sset prop_rules. consequent xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>sset prop_rules. consequent xs \\<noteq> []", "unfolding prop_rules_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>sset (cycle [andI, andE, impI, impE]).\n       consequent xs \\<noteq> []", "using consequent.elims"], ["proof (prove)\nusing this:\n  \\<lbrakk>consequent ?x = ?y;\n   \\<lbrakk>?x = andI; ?y = [Fun and [X, Y]]\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<lbrakk>?x = andE; ?y = [X, Y]\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<lbrakk>?x = impI; ?y = [Fun imp [X, Y]]\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<lbrakk>?x = impE; ?y = [Y]\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>sset (cycle [andI, andE, impI, impE]).\n       consequent xs \\<noteq> []", "by blast"], ["proof (state)\nthis:\n  \\<forall>xs\\<in>sset prop_rules. consequent xs \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<forall>xs\\<in>sset prop_rules.\n       (\\<Union>_\\<in>set (consequent xs). {}) = {}\n 2. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 3. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {})\n                         \\<subseteq> a_fresh p", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>xs\\<in>sset prop_rules.\n       (\\<Union>_\\<in>set (consequent xs). {}) = {}\n 2. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 3. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {})\n                         \\<subseteq> a_fresh p", "show \"\\<forall>xs\\<in>sset prop_rules. \\<Union>((\\<lambda>_. {}) ` set (consequent xs)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>sset prop_rules.\n       (\\<Union>_\\<in>set (consequent xs). {}) = {}", "by clarsimp"], ["proof (state)\nthis:\n  \\<forall>xs\\<in>sset prop_rules.\n     (\\<Union>_\\<in>set (consequent xs). {}) = {}\n\ngoal (2 subgoals):\n 1. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 2. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {})\n                         \\<subseteq> a_fresh p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 2. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {})\n                         \\<subseteq> a_fresh p", "fix i' r i ia"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 2. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {})\n                         \\<subseteq> a_fresh p", "assume \"r \\<in> sset prop_rules\"\n    and \"ia < length (antecedent r)\"\n    and \"i' < length (antecedent r)\""], ["proof (state)\nthis:\n  r \\<in> sset prop_rules\n  ia < length (antecedent r)\n  i' < length (antecedent r)\n\ngoal (2 subgoals):\n 1. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 2. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {})\n                         \\<subseteq> a_fresh p", "then"], ["proof (chain)\npicking this:\n  r \\<in> sset prop_rules\n  ia < length (antecedent r)\n  i' < length (antecedent r)", "show \"a_fresh (antecedent r ! ia) \\<inter> a_fresh (antecedent r ! i') = {} \\<or> ia = i'\""], ["proof (prove)\nusing this:\n  r \\<in> sset prop_rules\n  ia < length (antecedent r)\n  i' < length (antecedent r)\n\ngoal (1 subgoal):\n 1. a_fresh (antecedent r ! ia) \\<inter> a_fresh (antecedent r ! i') =\n    {} \\<or>\n    ia = i'", "by (cases i'; auto)"], ["proof (state)\nthis:\n  a_fresh (antecedent r ! ia) \\<inter> a_fresh (antecedent r ! i') =\n  {} \\<or>\n  ia = i'\n\ngoal (1 subgoal):\n 1. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {})\n                         \\<subseteq> a_fresh p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {})\n                         \\<subseteq> a_fresh p", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {})\n                         \\<subseteq> a_fresh p", "show \"{} \\<union> \\<Union>((\\<lambda>_. {}) ` fset (a_hyps p)) \\<subseteq> a_fresh p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {}) \\<subseteq> a_fresh p", "by clarsimp"], ["proof (state)\nthis:\n  {} \\<union> (\\<Union>_\\<in>fset (a_hyps p). {}) \\<subseteq> a_fresh p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}