{"file_name": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine/Abstract_Rules_To_Incredible.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine", "problem_names": ["lemma Helper_in_nodes[simp]:\n    \"Helper \\<in> sset nodes\"", "lemma Assumption_in_nodes[simp]:\n    \"Assumption a \\<in> sset nodes \\<longleftrightarrow> a \\<in> set assumptions\"", "lemma Conclusion_in_nodes[simp]:\n    \"Conclusion c \\<in> sset nodes \\<longleftrightarrow> c \\<in> set conclusions\"", "lemma Rule_in_nodes[simp]:\n    \"Rule r \\<in> sset nodes \\<longleftrightarrow> r \\<in> sset rules\"", "lemma inPorts_fset_of:\n    \"inPorts n = fset_from_list (inPorts' n)\"", "lemma Reg_in_outPortsRule[simp]:  \"Reg c |\\<in>| outPortsRule r \\<longleftrightarrow> c |\\<in>| f_consequent r\"", "lemma Hyp_in_outPortsRule[simp]:  \"Hyp h c |\\<in>| outPortsRule r \\<longleftrightarrow> c |\\<in>| f_antecedent r \\<and> h |\\<in>| a_hyps c\"", "lemma hyps_for_conclusion[simp]: \"hyps_for (Conclusion n) p = {||}\"", "lemma hyps_for_Helper[simp]: \"hyps_for Helper p = {||}\"", "lemma hyps_for_Rule[simp]: \"ip |\\<in>| f_antecedent r \\<Longrightarrow> hyps_for (Rule r) ip = (\\<lambda> h. Hyp h ip) |`| a_hyps ip\""], "translations": [["", "lemma Helper_in_nodes[simp]:\n    \"Helper \\<in> sset nodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Helper \\<in> sset nodes", "by (simp add: nodes_def)"], ["", "lemma Assumption_in_nodes[simp]:\n    \"Assumption a \\<in> sset nodes \\<longleftrightarrow> a \\<in> set assumptions\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Assumption a \\<in> sset nodes) = (a \\<in> set assumptions)", "by (auto simp add: nodes_def stream.set_map)"], ["", "lemma Conclusion_in_nodes[simp]:\n    \"Conclusion c \\<in> sset nodes \\<longleftrightarrow> c \\<in> set conclusions\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Conclusion c \\<in> sset nodes) = (c \\<in> set conclusions)", "by (auto simp add: nodes_def stream.set_map)"], ["", "lemma Rule_in_nodes[simp]:\n    \"Rule r \\<in> sset nodes \\<longleftrightarrow> r \\<in> sset rules\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Rule r \\<in> sset nodes) = (r \\<in> sset rules)", "by (auto simp add: nodes_def stream.set_map)"], ["", "fun inPorts' :: \"('form, 'rule) graph_node \\<Rightarrow> ('form, 'var) in_port list\"  where\n    \"inPorts' (Rule r) = antecedent r\"\n   |\"inPorts' (Assumption r) = []\"\n   |\"inPorts' (Conclusion r) = [ plain_ant r ]\"\n   |\"inPorts' Helper  = [ plain_ant anyP ]\""], ["", "fun inPorts :: \"('form, 'rule) graph_node \\<Rightarrow> ('form, 'var) in_port fset\"  where\n    \"inPorts (Rule r) = f_antecedent r\"\n   |\"inPorts (Assumption r) = {||}\"\n   |\"inPorts (Conclusion r) = {| plain_ant r |}\"\n   |\"inPorts Helper  = {| plain_ant anyP |}\""], ["", "lemma inPorts_fset_of:\n    \"inPorts n = fset_from_list (inPorts' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inPorts n = fset_from_list (inPorts' n)", "by (cases n rule: inPorts.cases) (auto simp: fmember.rep_eq f_antecedent_def)"], ["", "definition outPortsRule where\n    \"outPortsRule r = ffUnion ((\\<lambda> a. (\\<lambda> h. Hyp h a) |`| a_hyps a) |`| f_antecedent r) |\\<union>| Reg |`| f_consequent r\""], ["", "lemma Reg_in_outPortsRule[simp]:  \"Reg c |\\<in>| outPortsRule r \\<longleftrightarrow> c |\\<in>| f_consequent r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Reg c |\\<in>| outPortsRule r) = (c |\\<in>| f_consequent r)", "by (auto simp add: outPortsRule_def fmember.rep_eq ffUnion.rep_eq)"], ["", "lemma Hyp_in_outPortsRule[simp]:  \"Hyp h c |\\<in>| outPortsRule r \\<longleftrightarrow> c |\\<in>| f_antecedent r \\<and> h |\\<in>| a_hyps c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Hyp h c |\\<in>| outPortsRule r) =\n    (c |\\<in>| f_antecedent r \\<and> h |\\<in>| a_hyps c)", "by (auto simp add: outPortsRule_def fmember.rep_eq ffUnion.rep_eq)"], ["", "fun outPorts where\n    \"outPorts (Rule r) = outPortsRule r\"\n   |\"outPorts (Assumption r) = {|Reg r|}\"\n   |\"outPorts (Conclusion r) = {||}\"\n   |\"outPorts Helper  = {| Reg anyP |}\""], ["", "fun labelsIn where\n    \"labelsIn _ p = a_conc p\""], ["", "fun labelsOut where\n    \"labelsOut _ (Reg p) = p\"\n   | \"labelsOut _ (Hyp h c) = h\""], ["", "fun hyps where \n     \"hyps (Rule r) (Hyp h a) = (if a |\\<in>| f_antecedent r \\<and> h |\\<in>| a_hyps a then Some a else None)\"\n   | \"hyps _ _ = None\""], ["", "fun local_vars :: \"('form, 'rule) graph_node \\<Rightarrow> ('form, 'var) in_port \\<Rightarrow> 'var set\"  where\n     \"local_vars _ a = a_fresh a\""], ["", "sublocale Labeled_Signature nodes inPorts outPorts hyps labelsIn labelsOut"], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeled_Signature inPorts outPorts hyps", "proof(standard,goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n p1 p2.\n       hyps n p1 = Some p2 \\<Longrightarrow>\n       p1 |\\<in>| outPorts n \\<and> p2 |\\<in>| inPorts n", "case (1 n p1 p2)"], ["proof (state)\nthis:\n  hyps n p1 = Some p2\n\ngoal (1 subgoal):\n 1. \\<And>n p1 p2.\n       hyps n p1 = Some p2 \\<Longrightarrow>\n       p1 |\\<in>| outPorts n \\<and> p2 |\\<in>| inPorts n", "thus ?case"], ["proof (prove)\nusing this:\n  hyps n p1 = Some p2\n\ngoal (1 subgoal):\n 1. p1 |\\<in>| outPorts n \\<and> p2 |\\<in>| inPorts n", "by(induction n p1 rule: hyps.induct) (auto  split: if_splits)"], ["proof (state)\nthis:\n  p1 |\\<in>| outPorts n \\<and> p2 |\\<in>| inPorts n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hyps_for_conclusion[simp]: \"hyps_for (Conclusion n) p = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hyps_for (Conclusion n) p = {||}", "using hyps_for_subset"], ["proof (prove)\nusing this:\n  hyps_for ?n ?p |\\<subseteq>| outPorts ?n\n\ngoal (1 subgoal):\n 1. hyps_for (Conclusion n) p = {||}", "by auto"], ["", "lemma hyps_for_Helper[simp]: \"hyps_for Helper p = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hyps_for Helper p = {||}", "using hyps_for_subset"], ["proof (prove)\nusing this:\n  hyps_for ?n ?p |\\<subseteq>| outPorts ?n\n\ngoal (1 subgoal):\n 1. hyps_for Helper p = {||}", "by auto"], ["", "lemma hyps_for_Rule[simp]: \"ip |\\<in>| f_antecedent r \\<Longrightarrow> hyps_for (Rule r) ip = (\\<lambda> h. Hyp h ip) |`| a_hyps ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip |\\<in>| f_antecedent r \\<Longrightarrow>\n    hyps_for (Rule r) ip = (\\<lambda>h. Hyp h ip) |`| a_hyps ip", "by (auto elim!: hyps.elims split: if_splits)"], ["", "end"], ["", "text \\<open>Finally, a given proof graph solves the task at hand if all the given conclusions are present\nas conclusion blocks in the graph.\\<close>"], ["", "locale Tasked_Proof_Graph =\n  Abstract_Task freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP  antecedent consequent rules assumptions conclusions  +\n  Scoped_Proof_Graph freshenLC renameLCs lconsts closed subst subst_lconsts subst_renameLCs anyP  inPorts outPorts nodeOf hyps nodes vertices labelsIn labelsOut vidx inst edges local_vars\n   for freshenLC :: \"nat \\<Rightarrow> 'var \\<Rightarrow> 'var\" \n    and renameLCs :: \"('var \\<Rightarrow> 'var) \\<Rightarrow> 'form \\<Rightarrow> 'form\" \n    and lconsts :: \"'form \\<Rightarrow> 'var set\" \n    and closed :: \"'form \\<Rightarrow> bool\"\n    and subst :: \"'subst \\<Rightarrow> 'form \\<Rightarrow> 'form\" \n    and subst_lconsts :: \"'subst \\<Rightarrow> 'var set\" \n    and subst_renameLCs :: \"('var \\<Rightarrow> 'var) \\<Rightarrow> ('subst \\<Rightarrow> 'subst)\"\n    and anyP :: \"'form\"\n\n    and antecedent :: \"'rule \\<Rightarrow> ('form, 'var) antecedent list\" \n    and consequent :: \"'rule \\<Rightarrow> 'form list\" \n    and rules :: \"'rule stream\" \n\n    and assumptions :: \"'form list\" \n    and conclusions :: \"'form list\" \n\n    and vertices :: \"'vertex fset\" \n    and nodeOf :: \"'vertex \\<Rightarrow> ('form, 'rule) graph_node\" \n    and edges :: \"('vertex, 'form, 'var) edge' set\" \n    and vidx :: \"'vertex \\<Rightarrow> nat\"\n    and inst :: \"'vertex \\<Rightarrow> 'subst\"  +\n  assumes conclusions_present: \"set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices\""], ["", "end"]]}