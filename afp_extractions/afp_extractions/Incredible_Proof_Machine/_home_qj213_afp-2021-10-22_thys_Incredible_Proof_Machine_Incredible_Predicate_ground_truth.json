{"file_name": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine/Incredible_Predicate.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine", "problem_names": ["lemma iR_prop_rules [simp]: \"sset prop_rules = {allI, allE, impI, impE}\""], "translations": [["", "lemma iR_prop_rules [simp]: \"sset prop_rules = {allI, allE, impI, impE}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset prop_rules = {allI, allE, impI, impE}", "unfolding prop_rules_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (cycle [allI, allE, impI, impE]) = {allI, allE, impI, impE}", "by simp"], ["", "text \\<open>Just some short notation.\\<close>"], ["", "abbreviation X :: \"form\"\n  where \"X \\<equiv> Var 10 []\""], ["", "abbreviation Y :: \"form\"\n  where \"Y \\<equiv> Var 11 []\""], ["", "abbreviation x :: \"form\"\n  where \"x \\<equiv> Var 9 []\""], ["", "abbreviation t :: \"form\"\n  where \"t \\<equiv> Var 13 []\""], ["", "abbreviation P :: \"form \\<Rightarrow> form\"\n  where \"P f \\<equiv> Var 12 [f]\""], ["", "abbreviation Q :: \"form \\<Rightarrow> form\"\n  where \"Q f \\<equiv> Op ''Q'' [f]\""], ["", "abbreviation imp :: \"form \\<Rightarrow> form \\<Rightarrow> form\"\n  where \"imp f1 f2 \\<equiv> Op ''imp'' [f1, f2]\""], ["", "abbreviation ForallX :: \"form \\<Rightarrow> form\"\n  where \"ForallX f \\<equiv> Quant ''all'' 9 f\""], ["", "text \\<open>Finally the right- and left-hand sides of the rules.\\<close>"], ["", "fun consequent :: \"prop_rule \\<Rightarrow> form list\"\n  where \"consequent allI = [ForallX (P x)]\"\n  | \"consequent allE = [P t]\"\n  | \"consequent impI = [imp X Y]\"\n  | \"consequent impE = [Y]\""], ["", "abbreviation allI_input where \"allI_input \\<equiv> Antecedent {||} (P (LC 0)) {0}\""], ["", "abbreviation impI_input where \"impI_input \\<equiv> Antecedent {|X|} Y {}\""], ["", "fun antecedent :: \"prop_rule \\<Rightarrow> (form, lconst) antecedent list\"\n  where \"antecedent allI = [allI_input]\"\n  | \"antecedent allE = [plain_ant (ForallX (P x))]\"\n  | \"antecedent impI = [impI_input]\"\n  | \"antecedent impE = [plain_ant (imp X Y), plain_ant X]\""], ["", "interpretation predicate: Abstract_Rules\n  \"curry to_nat :: nat \\<Rightarrow> var \\<Rightarrow> var\"\n  map_lc\n  lc\n  \"closed\"\n  subst\n  lc_subst\n  map_lc_subst\n  \"Var 0 []\"\n  antecedent\n  consequent\n  prop_rules"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abstract_Rules (curry to_nat) map_lc lc closed subst lc_subst\n     map_lc_subst (Var 0 []) antecedent consequent prop_rules", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>xs\\<in>sset prop_rules. consequent xs \\<noteq> []\n 2. \\<forall>xs\\<in>sset prop_rules.\n       \\<Union> (lc ` set (consequent xs)) = {}\n 3. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 4. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> lc (a_conc p) \\<union>\n                         \\<Union> (lc ` fset (a_hyps p))\n                         \\<subseteq> a_fresh p", "show \"\\<forall>xs\\<in>sset prop_rules. consequent xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>sset prop_rules. consequent xs \\<noteq> []", "unfolding prop_rules_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>sset (cycle [allI, allE, impI, impE]).\n       consequent xs \\<noteq> []", "using consequent.elims"], ["proof (prove)\nusing this:\n  \\<lbrakk>consequent ?x = ?y;\n   \\<lbrakk>?x = allI; ?y = [ForallX (P x)]\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<lbrakk>?x = allE; ?y = [P t]\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<lbrakk>?x = impI; ?y = [imp X Y]\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<lbrakk>?x = impE; ?y = [Y]\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>sset (cycle [allI, allE, impI, impE]).\n       consequent xs \\<noteq> []", "by blast"], ["proof (state)\nthis:\n  \\<forall>xs\\<in>sset prop_rules. consequent xs \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<forall>xs\\<in>sset prop_rules.\n       \\<Union> (lc ` set (consequent xs)) = {}\n 2. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 3. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> lc (a_conc p) \\<union>\n                         \\<Union> (lc ` fset (a_hyps p))\n                         \\<subseteq> a_fresh p", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>xs\\<in>sset prop_rules.\n       \\<Union> (lc ` set (consequent xs)) = {}\n 2. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 3. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> lc (a_conc p) \\<union>\n                         \\<Union> (lc ` fset (a_hyps p))\n                         \\<subseteq> a_fresh p", "show \"\\<forall>xs\\<in>sset prop_rules. \\<Union>(lc ` set (consequent xs)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs\\<in>sset prop_rules.\n       \\<Union> (lc ` set (consequent xs)) = {}", "by auto"], ["proof (state)\nthis:\n  \\<forall>xs\\<in>sset prop_rules. \\<Union> (lc ` set (consequent xs)) = {}\n\ngoal (2 subgoals):\n 1. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 2. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> lc (a_conc p) \\<union>\n                         \\<Union> (lc ` fset (a_hyps p))\n                         \\<subseteq> a_fresh p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 2. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> lc (a_conc p) \\<union>\n                         \\<Union> (lc ` fset (a_hyps p))\n                         \\<subseteq> a_fresh p", "fix i' r i ia"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 2. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> lc (a_conc p) \\<union>\n                         \\<Union> (lc ` fset (a_hyps p))\n                         \\<subseteq> a_fresh p", "assume \"r \\<in> sset prop_rules\"\n    and \"ia < length (antecedent r)\"\n    and \"i' < length (antecedent r)\""], ["proof (state)\nthis:\n  r \\<in> sset prop_rules\n  ia < length (antecedent r)\n  i' < length (antecedent r)\n\ngoal (2 subgoals):\n 1. \\<And>r i i'.\n       \\<lbrakk>r \\<in> sset prop_rules; i < length (antecedent r);\n        i' < length (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> a_fresh (antecedent r ! i) \\<inter>\n                         a_fresh (antecedent r ! i') =\n                         {} \\<or>\n                         i = i'\n 2. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> lc (a_conc p) \\<union>\n                         \\<Union> (lc ` fset (a_hyps p))\n                         \\<subseteq> a_fresh p", "then"], ["proof (chain)\npicking this:\n  r \\<in> sset prop_rules\n  ia < length (antecedent r)\n  i' < length (antecedent r)", "show \"a_fresh (antecedent r ! ia) \\<inter> a_fresh (antecedent r ! i') = {} \\<or> ia = i'\""], ["proof (prove)\nusing this:\n  r \\<in> sset prop_rules\n  ia < length (antecedent r)\n  i' < length (antecedent r)\n\ngoal (1 subgoal):\n 1. a_fresh (antecedent r ! ia) \\<inter> a_fresh (antecedent r ! i') =\n    {} \\<or>\n    ia = i'", "by (cases i'; auto)"], ["proof (state)\nthis:\n  a_fresh (antecedent r ! ia) \\<inter> a_fresh (antecedent r ! i') =\n  {} \\<or>\n  ia = i'\n\ngoal (1 subgoal):\n 1. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> lc (a_conc p) \\<union>\n                         \\<Union> (lc ` fset (a_hyps p))\n                         \\<subseteq> a_fresh p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> lc (a_conc p) \\<union>\n                         \\<Union> (lc ` fset (a_hyps p))\n                         \\<subseteq> a_fresh p", "fix r p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> lc (a_conc p) \\<union>\n                         \\<Union> (lc ` fset (a_hyps p))\n                         \\<subseteq> a_fresh p", "assume \"r \\<in> sset prop_rules\"\n  and \"p \\<in> set (antecedent r)\""], ["proof (state)\nthis:\n  r \\<in> sset prop_rules\n  p \\<in> set (antecedent r)\n\ngoal (1 subgoal):\n 1. \\<And>r p.\n       \\<lbrakk>r \\<in> sset prop_rules; p \\<in> set (antecedent r)\\<rbrakk>\n       \\<Longrightarrow> lc (a_conc p) \\<union>\n                         \\<Union> (lc ` fset (a_hyps p))\n                         \\<subseteq> a_fresh p", "thus \"lc (a_conc p) \\<union> \\<Union>(lc ` fset (a_hyps p)) \\<subseteq> a_fresh p\""], ["proof (prove)\nusing this:\n  r \\<in> sset prop_rules\n  p \\<in> set (antecedent r)\n\ngoal (1 subgoal):\n 1. lc (a_conc p) \\<union> \\<Union> (lc ` fset (a_hyps p))\n    \\<subseteq> a_fresh p", "by auto"], ["proof (state)\nthis:\n  lc (a_conc p) \\<union> \\<Union> (lc ` fset (a_hyps p))\n  \\<subseteq> a_fresh p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}