{"file_name": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine/Build_Incredible_Tree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine", "problem_names": ["lemma image_eq_to_f:\n  assumes  \"f1 ` S1 = f2 ` S2\"\n  obtains f where \"\\<And> x. x \\<in> S2 \\<Longrightarrow> f x \\<in> S1 \\<and> f1 (f x) = f2 x\"", "lemma fimage_eq_to_f:\n  assumes  \"f1 |`| S1 = f2 |`| S2\"\n  obtains f where \"\\<And> x. x |\\<in>| S2 \\<Longrightarrow> f x |\\<in>| S1 \\<and> f1 (f x) = f2 x\"", "lemma build_local_iwf:\n  fixes t :: \"('form entailment \\<times> ('rule \\<times> 'form) NatRule) tree\"\n  assumes \"tfinite t\"\n  assumes \"wf t\"\n  shows \"\\<exists> it. local_iwf it (fst (root t))\"", "lemma iwf_to_it:\n  assumes \"tfinite t\" and \"wf t\"\n  shows \"local_iwf (to_it t) (fst (root t))\""], "translations": [["", "lemma image_eq_to_f:\n  assumes  \"f1 ` S1 = f2 ` S2\"\n  obtains f where \"\\<And> x. x \\<in> S2 \\<Longrightarrow> f x \\<in> S1 \\<and> f1 (f x) = f2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<And>x.\n            x \\<in> S2 \\<Longrightarrow>\n            f x \\<in> S1 \\<and> f1 (f x) = f2 x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>x.\n          x \\<in> S2 \\<longrightarrow> f x \\<in> S1 \\<and> f1 (f x) = f2 x", "from assms"], ["proof (chain)\npicking this:\n  f1 ` S1 = f2 ` S2", "have \"\\<forall>x. x \\<in> S2 \\<longrightarrow> (\\<exists> y. y \\<in> S1 \\<and> f1 y = f2 x)\""], ["proof (prove)\nusing this:\n  f1 ` S1 = f2 ` S2\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> S2 \\<longrightarrow>\n       (\\<exists>y. y \\<in> S1 \\<and> f1 y = f2 x)", "by (metis image_iff)"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in> S2 \\<longrightarrow>\n     (\\<exists>y. y \\<in> S1 \\<and> f1 y = f2 x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>x.\n          x \\<in> S2 \\<longrightarrow> f x \\<in> S1 \\<and> f1 (f x) = f2 x", "thus \"\\<exists>f. \\<forall>x. x \\<in> S2 \\<longrightarrow> f x \\<in> S1 \\<and> f1 (f x) = f2 x\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> S2 \\<longrightarrow>\n     (\\<exists>y. y \\<in> S1 \\<and> f1 y = f2 x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>x.\n          x \\<in> S2 \\<longrightarrow> f x \\<in> S1 \\<and> f1 (f x) = f2 x", "by metis"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<forall>x.\n        x \\<in> S2 \\<longrightarrow> f x \\<in> S1 \\<and> f1 (f x) = f2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "context includes fset.lifting\nbegin"], ["", "lemma fimage_eq_to_f:\n  assumes  \"f1 |`| S1 = f2 |`| S2\"\n  obtains f where \"\\<And> x. x |\\<in>| S2 \\<Longrightarrow> f x |\\<in>| S1 \\<and> f1 (f x) = f2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<And>x.\n            x |\\<in>| S2 \\<Longrightarrow>\n            f x |\\<in>| S1 \\<and> f1 (f x) = f2 x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  f1 |`| S1 = f2 |`| S2\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<And>x.\n            x |\\<in>| S2 \\<Longrightarrow>\n            f x |\\<in>| S1 \\<and> f1 (f x) = f2 x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S2 S1 f1 f2 thesis.\n       \\<lbrakk>finite S2; finite S1;\n        \\<And>f.\n           (\\<And>x.\n               x \\<in> S2 \\<Longrightarrow>\n               f x \\<in> S1 \\<and> f1 (f x) = f2 x) \\<Longrightarrow>\n           thesis;\n        f1 ` S1 = f2 ` S2\\<rbrakk>\n       \\<Longrightarrow> thesis", "using image_eq_to_f"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f1.0 ` ?S1.0 = ?f2.0 ` ?S2.0;\n   \\<And>f.\n      (\\<And>x.\n          x \\<in> ?S2.0 \\<Longrightarrow>\n          f x \\<in> ?S1.0 \\<and> ?f1.0 (f x) = ?f2.0 x) \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>S2 S1 f1 f2 thesis.\n       \\<lbrakk>finite S2; finite S1;\n        \\<And>f.\n           (\\<And>x.\n               x \\<in> S2 \\<Longrightarrow>\n               f x \\<in> S1 \\<and> f1 (f x) = f2 x) \\<Longrightarrow>\n           thesis;\n        f1 ` S1 = f2 ` S2\\<rbrakk>\n       \\<Longrightarrow> thesis", "by metis"], ["", "end"], ["", "context Abstract_Task\nbegin"], ["", "lemma build_local_iwf:\n  fixes t :: \"('form entailment \\<times> ('rule \\<times> 'form) NatRule) tree\"\n  assumes \"tfinite t\"\n  assumes \"wf t\"\n  shows \"\\<exists> it. local_iwf it (fst (root t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (fst (tree.root t))", "using assms"], ["proof (prove)\nusing this:\n  tfinite t\n  local.wf t\n\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (fst (tree.root t))", "proof(induction)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>t'. t' |\\<in>| cont t \\<Longrightarrow> tfinite t';\n        \\<And>t'.\n           \\<lbrakk>t' |\\<in>| cont t; local.wf t'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t'));\n        local.wf t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "case (tfinite t)"], ["proof (state)\nthis:\n  ?t'9 |\\<in>| cont t \\<Longrightarrow> tfinite ?t'9\n  \\<lbrakk>?t'9 |\\<in>| cont t; local.wf ?t'9\\<rbrakk>\n  \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root ?t'9))\n  local.wf t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>t'. t' |\\<in>| cont t \\<Longrightarrow> tfinite t';\n        \\<And>t'.\n           \\<lbrakk>t' |\\<in>| cont t; local.wf t'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t'));\n        local.wf t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>wf t\\<close>"], ["proof (chain)\npicking this:\n  local.wf t", "have \"snd (root t) \\<in> R\""], ["proof (prove)\nusing this:\n  local.wf t\n\ngoal (1 subgoal):\n 1. snd (tree.root t) \\<in> R", "using wf.simps"], ["proof (prove)\nusing this:\n  local.wf t\n  local.wf ?a =\n  (\\<exists>t.\n      ?a = t \\<and>\n      snd (tree.root t) \\<in> R \\<and>\n      effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t) \\<and>\n      (\\<forall>x. x |\\<in>| cont t \\<longrightarrow> local.wf x))\n\ngoal (1 subgoal):\n 1. snd (tree.root t) \\<in> R", "by blast"], ["proof (state)\nthis:\n  snd (tree.root t) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>t'. t' |\\<in>| cont t \\<Longrightarrow> tfinite t';\n        \\<And>t'.\n           \\<lbrakk>t' |\\<in>| cont t; local.wf t'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t'));\n        local.wf t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>wf t\\<close>"], ["proof (chain)\npicking this:\n  local.wf t", "have \"eff (snd (root t)) (fst (root t)) ((fst \\<circ> root) |`| cont t)\""], ["proof (prove)\nusing this:\n  local.wf t\n\ngoal (1 subgoal):\n 1. effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t)", "using wf.simps"], ["proof (prove)\nusing this:\n  local.wf t\n  local.wf ?a =\n  (\\<exists>t.\n      ?a = t \\<and>\n      snd (tree.root t) \\<in> R \\<and>\n      effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t) \\<and>\n      (\\<forall>x. x |\\<in>| cont t \\<longrightarrow> local.wf x))\n\ngoal (1 subgoal):\n 1. effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t)", "by blast"], ["proof (state)\nthis:\n  effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>t'. t' |\\<in>| cont t \\<Longrightarrow> tfinite t';\n        \\<And>t'.\n           \\<lbrakk>t' |\\<in>| cont t; local.wf t'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t'));\n        local.wf t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>wf t\\<close>"], ["proof (chain)\npicking this:\n  local.wf t", "have \"\\<And> t'. t' |\\<in>| cont t \\<Longrightarrow> wf t'\""], ["proof (prove)\nusing this:\n  local.wf t\n\ngoal (1 subgoal):\n 1. \\<And>t'. t' |\\<in>| cont t \\<Longrightarrow> local.wf t'", "using wf.simps"], ["proof (prove)\nusing this:\n  local.wf t\n  local.wf ?a =\n  (\\<exists>t.\n      ?a = t \\<and>\n      snd (tree.root t) \\<in> R \\<and>\n      effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t) \\<and>\n      (\\<forall>x. x |\\<in>| cont t \\<longrightarrow> local.wf x))\n\ngoal (1 subgoal):\n 1. \\<And>t'. t' |\\<in>| cont t \\<Longrightarrow> local.wf t'", "by blast"], ["proof (state)\nthis:\n  ?t'9 |\\<in>| cont t \\<Longrightarrow> local.wf ?t'9\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>t'. t' |\\<in>| cont t \\<Longrightarrow> tfinite t';\n        \\<And>t'.\n           \\<lbrakk>t' |\\<in>| cont t; local.wf t'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t'));\n        local.wf t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "hence IH: \"\\<And> \\<Gamma>' t'. t' |\\<in>| cont t \\<Longrightarrow> (\\<exists>it'. local_iwf it' (fst (root t')))\""], ["proof (prove)\nusing this:\n  ?t'9 |\\<in>| cont t \\<Longrightarrow> local.wf ?t'9\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma>' t'.\n       t' |\\<in>| cont t \\<Longrightarrow>\n       \\<exists>it'. local_iwf it' (fst (tree.root t'))", "using tfinite(2)"], ["proof (prove)\nusing this:\n  ?t'9 |\\<in>| cont t \\<Longrightarrow> local.wf ?t'9\n  \\<lbrakk>?t'9 |\\<in>| cont t; local.wf ?t'9\\<rbrakk>\n  \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root ?t'9))\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma>' t'.\n       t' |\\<in>| cont t \\<Longrightarrow>\n       \\<exists>it'. local_iwf it' (fst (tree.root t'))", "by blast"], ["proof (state)\nthis:\n  ?t'9 |\\<in>| cont t \\<Longrightarrow>\n  \\<exists>it'. local_iwf it' (fst (tree.root ?t'9))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>t'. t' |\\<in>| cont t \\<Longrightarrow> tfinite t';\n        \\<And>t'.\n           \\<lbrakk>t' |\\<in>| cont t; local.wf t'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t'));\n        local.wf t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "then"], ["proof (chain)\npicking this:\n  ?t'9 |\\<in>| cont t \\<Longrightarrow>\n  \\<exists>it'. local_iwf it' (fst (tree.root ?t'9))", "obtain its where its: \"\\<And> t'. t' |\\<in>| cont t \\<Longrightarrow> local_iwf (its t') (fst (root t'))\""], ["proof (prove)\nusing this:\n  ?t'9 |\\<in>| cont t \\<Longrightarrow>\n  \\<exists>it'. local_iwf it' (fst (tree.root ?t'9))\n\ngoal (1 subgoal):\n 1. (\\<And>its.\n        (\\<And>t'.\n            t' |\\<in>| cont t \\<Longrightarrow>\n            local_iwf (its t') (fst (tree.root t'))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?t'10 |\\<in>| cont t \\<Longrightarrow>\n  local_iwf (its ?t'10) (fst (tree.root ?t'10))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>t'. t' |\\<in>| cont t \\<Longrightarrow> tfinite t';\n        \\<And>t'.\n           \\<lbrakk>t' |\\<in>| cont t; local.wf t'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t'));\n        local.wf t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>eff _ _ _\\<close>"], ["proof (chain)\npicking this:\n  effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t)", "show ?case"], ["proof (prove)\nusing this:\n  effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t)\n\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (fst (tree.root t))", "proof(cases rule: eff.cases[case_names Axiom NatRule Cut])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>con \\<Gamma>.\n       \\<lbrakk>snd (tree.root t) = Axiom;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> con);\n        (fst \\<circ> tree.root) |`| cont t = {||};\n        con |\\<in>| \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 3. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "case (Axiom c \\<Gamma>)"], ["proof (state)\nthis:\n  snd (tree.root t) = Axiom\n  fst (tree.root t) = (\\<Gamma> \\<turnstile> c)\n  (fst \\<circ> tree.root) |`| cont t = {||}\n  c |\\<in>| \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>con \\<Gamma>.\n       \\<lbrakk>snd (tree.root t) = Axiom;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> con);\n        (fst \\<circ> tree.root) |`| cont t = {||};\n        con |\\<in>| \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 3. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (fst (tree.root t))", "proof (cases \"c |\\<in>| ass_forms\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c |\\<in>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))\n 2. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "case True"], ["proof (state)\nthis:\n  c |\\<in>| ass_forms\n\ngoal (2 subgoals):\n 1. c |\\<in>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))\n 2. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "(* Global assumption *)"], ["proof (state)\nthis:\n  c |\\<in>| ass_forms\n\ngoal (2 subgoals):\n 1. c |\\<in>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))\n 2. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "then"], ["proof (chain)\npicking this:\n  c |\\<in>| ass_forms", "have \"c \\<in> set assumptions\""], ["proof (prove)\nusing this:\n  c |\\<in>| ass_forms\n\ngoal (1 subgoal):\n 1. c \\<in> set assumptions", "by (auto simp add:  ass_forms_def)"], ["proof (state)\nthis:\n  c \\<in> set assumptions\n\ngoal (2 subgoals):\n 1. c |\\<in>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))\n 2. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "let \"?it\" = \"INode (Assumption c) c undefined undefined [] ::  ('form, 'rule, 'subst, 'var) itree\""], ["proof (state)\ngoal (2 subgoals):\n 1. c |\\<in>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))\n 2. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>c \\<in> set assumptions\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> set assumptions", "have \"local_iwf ?it (\\<Gamma> \\<turnstile> c)\""], ["proof (prove)\nusing this:\n  c \\<in> set assumptions\n\ngoal (1 subgoal):\n 1. local_iwf (INode (Assumption c) c undefined undefined [])\n     (\\<Gamma> \\<turnstile> c)", "by (auto intro!: iwf local_fresh_check.intros)"], ["proof (state)\nthis:\n  local_iwf (INode (Assumption c) c undefined undefined [])\n   (\\<Gamma> \\<turnstile> c)\n\ngoal (2 subgoals):\n 1. c |\\<in>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))\n 2. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "thus ?thesis"], ["proof (prove)\nusing this:\n  local_iwf (INode (Assumption c) c undefined undefined [])\n   (\\<Gamma> \\<turnstile> c)\n\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (fst (tree.root t))", "unfolding Axiom"], ["proof (prove)\nusing this:\n  local_iwf (INode (Assumption c) c undefined undefined [])\n   (\\<Gamma> \\<turnstile> c)\n\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (\\<Gamma> \\<turnstile> c)", ".."], ["proof (state)\nthis:\n  \\<exists>it. local_iwf it (fst (tree.root t))\n\ngoal (1 subgoal):\n 1. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "case False"], ["proof (state)\nthis:\n  c |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "obtain s where \"subst s anyP = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. subst s anyP = c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule anyP_is_any)"], ["proof (state)\nthis:\n  subst s anyP = c\n\ngoal (1 subgoal):\n 1. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "hence [simp]: \"subst s (freshen undefined anyP) = c\""], ["proof (prove)\nusing this:\n  subst s anyP = c\n\ngoal (1 subgoal):\n 1. subst s (freshen undefined anyP) = c", "by (simp add: lconsts_anyP freshen_closed)"], ["proof (state)\nthis:\n  subst s (freshen undefined anyP) = c\n\ngoal (1 subgoal):\n 1. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "let \"?it\" = \"HNode undefined s [] ::  ('form, 'rule, 'subst, 'var) itree\""], ["proof (state)\ngoal (1 subgoal):\n 1. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "from  \\<open>c |\\<in>| \\<Gamma>\\<close> False"], ["proof (chain)\npicking this:\n  c |\\<in>| \\<Gamma>\n  c |\\<notin>| ass_forms", "have \"local_iwf ?it (\\<Gamma> \\<turnstile> c)\""], ["proof (prove)\nusing this:\n  c |\\<in>| \\<Gamma>\n  c |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. local_iwf (HNode undefined s []) (\\<Gamma> \\<turnstile> c)", "by (auto intro: iwfH)"], ["proof (state)\nthis:\n  local_iwf (HNode undefined s []) (\\<Gamma> \\<turnstile> c)\n\ngoal (1 subgoal):\n 1. c |\\<notin>| ass_forms \\<Longrightarrow>\n    \\<exists>it. local_iwf it (fst (tree.root t))", "thus ?thesis"], ["proof (prove)\nusing this:\n  local_iwf (HNode undefined s []) (\\<Gamma> \\<turnstile> c)\n\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (fst (tree.root t))", "unfolding Axiom"], ["proof (prove)\nusing this:\n  local_iwf (HNode undefined s []) (\\<Gamma> \\<turnstile> c)\n\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (\\<Gamma> \\<turnstile> c)", ".."], ["proof (state)\nthis:\n  \\<exists>it. local_iwf it (fst (tree.root t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>it. local_iwf it (fst (tree.root t))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "case (NatRule rule c ants \\<Gamma> i s)"], ["proof (state)\nthis:\n  snd (tree.root t) = NatRule rule\n  fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen i c))\n  (fst \\<circ> tree.root) |`| cont t =\n  (\\<lambda>ant.\n      (\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>|\n      \\<Gamma> \\<turnstile>\n      subst s (freshen i (a_conc ant))) |`|\n  ants\n  natEff_Inst rule c ants\n  \\<lbrakk>?ant10 |\\<in>| ants; ?f10 |\\<in>| \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> freshenLC i ` a_fresh ?ant10 \\<inter> lconsts ?f10 = {}\n  ?ant10 |\\<in>| ants \\<Longrightarrow>\n  freshenLC i ` a_fresh ?ant10 \\<inter> subst_lconsts s = {}\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>natEff_Inst rule c ants\\<close>"], ["proof (chain)\npicking this:\n  natEff_Inst rule c ants", "have \"snd rule = c\"  and [simp]: \"ants = f_antecedent (fst rule)\" and \"c \\<in> set (consequent (fst rule))\""], ["proof (prove)\nusing this:\n  natEff_Inst rule c ants\n\ngoal (1 subgoal):\n 1. snd rule = c &&&\n    ants = f_antecedent (fst rule) &&& c \\<in> set (consequent (fst rule))", "by (auto simp add: natEff_Inst.simps)"], ["proof (state)\nthis:\n  snd rule = c\n  ants = f_antecedent (fst rule)\n  c \\<in> set (consequent (fst rule))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>(fst \\<circ> root) |`| cont t = (\\<lambda>ant. (\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>| \\<Gamma> \\<turnstile> subst s (freshen i (a_conc ant))) |`| ants\\<close>"], ["proof (chain)\npicking this:\n  (fst \\<circ> tree.root) |`| cont t =\n  (\\<lambda>ant.\n      (\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>|\n      \\<Gamma> \\<turnstile>\n      subst s (freshen i (a_conc ant))) |`|\n  ants", "obtain to_t where \"\\<And> ant. ant |\\<in>| ants \\<Longrightarrow> to_t ant |\\<in>| cont t \\<and> (fst \\<circ> root) (to_t ant) = ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>| \\<Gamma> \\<turnstile> subst s (freshen i (a_conc ant)))\""], ["proof (prove)\nusing this:\n  (fst \\<circ> tree.root) |`| cont t =\n  (\\<lambda>ant.\n      (\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>|\n      \\<Gamma> \\<turnstile>\n      subst s (freshen i (a_conc ant))) |`|\n  ants\n\ngoal (1 subgoal):\n 1. (\\<And>to_t.\n        (\\<And>ant.\n            ant |\\<in>| ants \\<Longrightarrow>\n            to_t ant |\\<in>| cont t \\<and>\n            (fst \\<circ> tree.root) (to_t ant) =\n            ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>|\n             \\<Gamma> \\<turnstile>\n             subst s (freshen i (a_conc ant)))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule fimage_eq_to_f) (rule that)"], ["proof (state)\nthis:\n  ?ant10 |\\<in>| ants \\<Longrightarrow>\n  to_t ?ant10 |\\<in>| cont t \\<and>\n  (fst \\<circ> tree.root) (to_t ?ant10) =\n  ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ?ant10 |\\<union>|\n   \\<Gamma> \\<turnstile>\n   subst s (freshen i (a_conc ?ant10)))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "hence to_t_in_cont: \"\\<And> ant. ant |\\<in>| ants \\<Longrightarrow> to_t ant |\\<in>| cont t\"\n      and to_t_root: \"\\<And> ant. ant |\\<in>| ants \\<Longrightarrow>  fst (root (to_t ant)) = ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>| \\<Gamma> \\<turnstile> subst s (freshen i (a_conc ant)))\""], ["proof (prove)\nusing this:\n  ?ant10 |\\<in>| ants \\<Longrightarrow>\n  to_t ?ant10 |\\<in>| cont t \\<and>\n  (fst \\<circ> tree.root) (to_t ?ant10) =\n  ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ?ant10 |\\<union>|\n   \\<Gamma> \\<turnstile>\n   subst s (freshen i (a_conc ?ant10)))\n\ngoal (1 subgoal):\n 1. (\\<And>ant.\n        ant |\\<in>| ants \\<Longrightarrow> to_t ant |\\<in>| cont t) &&&\n    (\\<And>ant.\n        ant |\\<in>| ants \\<Longrightarrow>\n        fst (tree.root (to_t ant)) =\n        ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>|\n         \\<Gamma> \\<turnstile>\n         subst s (freshen i (a_conc ant))))", "by auto"], ["proof (state)\nthis:\n  ?ant10 |\\<in>| ants \\<Longrightarrow> to_t ?ant10 |\\<in>| cont t\n  ?ant10 |\\<in>| ants \\<Longrightarrow>\n  fst (tree.root (to_t ?ant10)) =\n  ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ?ant10 |\\<union>|\n   \\<Gamma> \\<turnstile>\n   subst s (freshen i (a_conc ?ant10)))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "let ?ants' = \"map (\\<lambda> ant. its (to_t ant)) (antecedent (fst rule))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "let \"?it\" = \"INode (Rule (fst rule)) c i s ?ants' ::  ('form, 'rule, 'subst, 'var) itree\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>snd (root t) \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  snd (tree.root t) \\<in> R", "have \"fst rule \\<in> sset rules\""], ["proof (prove)\nusing this:\n  snd (tree.root t) \\<in> R\n\ngoal (1 subgoal):\n 1. fst rule \\<in> i.R rules", "unfolding NatRule"], ["proof (prove)\nusing this:\n  NatRule rule \\<in> R\n\ngoal (1 subgoal):\n 1. fst rule \\<in> i.R rules", "by (auto simp add: stream.set_map n_rules_def no_empty_conclusions )"], ["proof (state)\nthis:\n  fst rule \\<in> i.R rules\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "moreover"], ["proof (state)\nthis:\n  fst rule \\<in> i.R rules\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>c \\<in> set (consequent (fst rule))\\<close>"], ["proof (chain)\npicking this:\n  c \\<in> set (consequent (fst rule))", "have \"c |\\<in>| f_consequent (fst rule)\""], ["proof (prove)\nusing this:\n  c \\<in> set (consequent (fst rule))\n\ngoal (1 subgoal):\n 1. c |\\<in>| f_consequent (fst rule)", "by (simp add: f_consequent_def)"], ["proof (state)\nthis:\n  c |\\<in>| f_consequent (fst rule)\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "moreover"], ["proof (state)\nthis:\n  c |\\<in>| f_consequent (fst rule)\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "{"], ["proof (state)\nthis:\n  c |\\<in>| f_consequent (fst rule)\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "fix ant"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "assume \"ant \\<in> set (antecedent (fst rule))\""], ["proof (state)\nthis:\n  ant \\<in> set (antecedent (fst rule))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "hence \"ant |\\<in>| ants\""], ["proof (prove)\nusing this:\n  ant \\<in> set (antecedent (fst rule))\n\ngoal (1 subgoal):\n 1. ant |\\<in>| ants", "by (simp add: f_antecedent_def)"], ["proof (state)\nthis:\n  ant |\\<in>| ants\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from its[OF to_t_in_cont[OF this]]"], ["proof (chain)\npicking this:\n  local_iwf (its (to_t ant)) (fst (tree.root (to_t ant)))", "have \"local_iwf (its (to_t ant)) (fst (root (to_t ant)))\""], ["proof (prove)\nusing this:\n  local_iwf (its (to_t ant)) (fst (tree.root (to_t ant)))\n\ngoal (1 subgoal):\n 1. local_iwf (its (to_t ant)) (fst (tree.root (to_t ant)))", "."], ["proof (state)\nthis:\n  local_iwf (its (to_t ant)) (fst (tree.root (to_t ant)))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "also"], ["proof (state)\nthis:\n  local_iwf (its (to_t ant)) (fst (tree.root (to_t ant)))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "have \"fst (root (to_t ant)) =\n        ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>| \\<Gamma> \\<turnstile> subst s (freshen i (a_conc ant)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (tree.root (to_t ant)) =\n    ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>|\n     \\<Gamma> \\<turnstile>\n     subst s (freshen i (a_conc ant)))", "by (rule to_t_root[OF \\<open>ant |\\<in>| ants\\<close>])"], ["proof (state)\nthis:\n  fst (tree.root (to_t ant)) =\n  ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>|\n   \\<Gamma> \\<turnstile>\n   subst s (freshen i (a_conc ant)))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "also"], ["proof (state)\nthis:\n  fst (tree.root (to_t ant)) =\n  ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>|\n   \\<Gamma> \\<turnstile>\n   subst s (freshen i (a_conc ant)))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "have \"\\<dots> =\n        ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`| hyps_for (Rule (fst rule)) ant |\\<union>| \\<Gamma>\n         \\<turnstile> subst s (freshen i (a_conc ant)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>|\n     \\<Gamma> \\<turnstile>\n     subst s (freshen i (a_conc ant))) =\n    ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`|\n     hyps_for (Rule (fst rule)) ant |\\<union>|\n     \\<Gamma> \\<turnstile>\n     subst s (freshen i (a_conc ant)))", "using \\<open>ant |\\<in>| ants\\<close>"], ["proof (prove)\nusing this:\n  ant |\\<in>| ants\n\ngoal (1 subgoal):\n 1. ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>|\n     \\<Gamma> \\<turnstile>\n     subst s (freshen i (a_conc ant))) =\n    ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`|\n     hyps_for (Rule (fst rule)) ant |\\<union>|\n     \\<Gamma> \\<turnstile>\n     subst s (freshen i (a_conc ant)))", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>p. subst s (freshen i p)) |`| a_hyps ant |\\<union>|\n   \\<Gamma> \\<turnstile>\n   subst s (freshen i (a_conc ant))) =\n  ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`|\n   hyps_for (Rule (fst rule)) ant |\\<union>|\n   \\<Gamma> \\<turnstile>\n   subst s (freshen i (a_conc ant)))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "finally"], ["proof (chain)\npicking this:\n  local_iwf (its (to_t ant))\n   ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`|\n    hyps_for (Rule (fst rule)) ant |\\<union>|\n    \\<Gamma> \\<turnstile>\n    subst s (freshen i (a_conc ant)))", "have \"local_iwf (its (to_t ant))\n           ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`| hyps_for (Rule (fst rule)) ant |\\<union>|\n            \\<Gamma>  \\<turnstile> subst s (freshen i (a_conc ant)))\""], ["proof (prove)\nusing this:\n  local_iwf (its (to_t ant))\n   ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`|\n    hyps_for (Rule (fst rule)) ant |\\<union>|\n    \\<Gamma> \\<turnstile>\n    subst s (freshen i (a_conc ant)))\n\ngoal (1 subgoal):\n 1. local_iwf (its (to_t ant))\n     ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`|\n      hyps_for (Rule (fst rule)) ant |\\<union>|\n      \\<Gamma> \\<turnstile>\n      subst s (freshen i (a_conc ant)))", "."], ["proof (state)\nthis:\n  local_iwf (its (to_t ant))\n   ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`|\n    hyps_for (Rule (fst rule)) ant |\\<union>|\n    \\<Gamma> \\<turnstile>\n    subst s (freshen i (a_conc ant)))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "}"], ["proof (state)\nthis:\n  ?ant15 \\<in> set (antecedent (fst rule)) \\<Longrightarrow>\n  local_iwf (its (to_t ?ant15))\n   ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`|\n    hyps_for (Rule (fst rule)) ?ant15 |\\<union>|\n    \\<Gamma> \\<turnstile>\n    subst s (freshen i (a_conc ?ant15)))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "moreover"], ["proof (state)\nthis:\n  ?ant15 \\<in> set (antecedent (fst rule)) \\<Longrightarrow>\n  local_iwf (its (to_t ?ant15))\n   ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`|\n    hyps_for (Rule (fst rule)) ?ant15 |\\<union>|\n    \\<Gamma> \\<turnstile>\n    subst s (freshen i (a_conc ?ant15)))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from NatRule(5,6)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?ant10 |\\<in>| ants; ?f10 |\\<in>| \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> freshenLC i ` a_fresh ?ant10 \\<inter> lconsts ?f10 = {}\n  ?ant10 |\\<in>| ants \\<Longrightarrow>\n  freshenLC i ` a_fresh ?ant10 \\<inter> subst_lconsts s = {}", "have \"local_fresh_check (Rule (fst rule)) i s (\\<Gamma> \\<turnstile> subst s (freshen i c))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?ant10 |\\<in>| ants; ?f10 |\\<in>| \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> freshenLC i ` a_fresh ?ant10 \\<inter> lconsts ?f10 = {}\n  ?ant10 |\\<in>| ants \\<Longrightarrow>\n  freshenLC i ` a_fresh ?ant10 \\<inter> subst_lconsts s = {}\n\ngoal (1 subgoal):\n 1. local_fresh_check (Rule (fst rule)) i s\n     (\\<Gamma> \\<turnstile> subst s (freshen i c))", "by (fastforce intro!: local_fresh_check.intros simp add: all_local_vars_def fmember.rep_eq)"], ["proof (state)\nthis:\n  local_fresh_check (Rule (fst rule)) i s\n   (\\<Gamma> \\<turnstile> subst s (freshen i c))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "ultimately"], ["proof (chain)\npicking this:\n  fst rule \\<in> i.R rules\n  c |\\<in>| f_consequent (fst rule)\n  ?ant15 \\<in> set (antecedent (fst rule)) \\<Longrightarrow>\n  local_iwf (its (to_t ?ant15))\n   ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`|\n    hyps_for (Rule (fst rule)) ?ant15 |\\<union>|\n    \\<Gamma> \\<turnstile>\n    subst s (freshen i (a_conc ?ant15)))\n  local_fresh_check (Rule (fst rule)) i s\n   (\\<Gamma> \\<turnstile> subst s (freshen i c))", "have \"local_iwf ?it ((\\<Gamma> \\<turnstile> subst s (freshen i c)))\""], ["proof (prove)\nusing this:\n  fst rule \\<in> i.R rules\n  c |\\<in>| f_consequent (fst rule)\n  ?ant15 \\<in> set (antecedent (fst rule)) \\<Longrightarrow>\n  local_iwf (its (to_t ?ant15))\n   ((\\<lambda>h. subst s (freshen i (labelsOut (Rule (fst rule)) h))) |`|\n    hyps_for (Rule (fst rule)) ?ant15 |\\<union>|\n    \\<Gamma> \\<turnstile>\n    subst s (freshen i (a_conc ?ant15)))\n  local_fresh_check (Rule (fst rule)) i s\n   (\\<Gamma> \\<turnstile> subst s (freshen i c))\n\ngoal (1 subgoal):\n 1. local_iwf\n     (INode (Rule (fst rule)) c i s\n       (map (\\<lambda>ant. its (to_t ant)) (antecedent (fst rule))))\n     (\\<Gamma> \\<turnstile> subst s (freshen i c))", "by (intro iwf ) (auto simp add: list_all2_map2 list_all2_same)"], ["proof (state)\nthis:\n  local_iwf\n   (INode (Rule (fst rule)) c i s\n     (map (\\<lambda>ant. its (to_t ant)) (antecedent (fst rule))))\n   (\\<Gamma> \\<turnstile> subst s (freshen i c))\n\ngoal (2 subgoals):\n 1. \\<And>rule c ants \\<Gamma> a s.\n       \\<lbrakk>snd (tree.root t) = NatRule rule;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> subst s (freshen a c));\n        (fst \\<circ> tree.root) |`| cont t =\n        (\\<lambda>ant.\n            (\\<lambda>p. subst s (freshen a p)) |`| a_hyps ant |\\<union>|\n            \\<Gamma> \\<turnstile>\n            subst s (freshen a (a_conc ant))) |`|\n        ants;\n        natEff_Inst rule c ants;\n        \\<And>ant f.\n           \\<lbrakk>ant |\\<in>| ants; f |\\<in>| \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> freshenLC a ` a_fresh ant \\<inter> lconsts f =\n                             {};\n        \\<And>ant.\n           ant |\\<in>| ants \\<Longrightarrow>\n           freshenLC a ` a_fresh ant \\<inter> subst_lconsts s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))\n 2. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "thus ?thesis"], ["proof (prove)\nusing this:\n  local_iwf\n   (INode (Rule (fst rule)) c i s\n     (map (\\<lambda>ant. its (to_t ant)) (antecedent (fst rule))))\n   (\\<Gamma> \\<turnstile> subst s (freshen i c))\n\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (fst (tree.root t))", "unfolding NatRule"], ["proof (prove)\nusing this:\n  local_iwf\n   (INode (Rule (fst rule)) c i s\n     (map (\\<lambda>ant. its (to_t ant)) (antecedent (fst rule))))\n   (\\<Gamma> \\<turnstile> subst s (freshen i c))\n\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (\\<Gamma> \\<turnstile> subst s (freshen i c))", ".."], ["proof (state)\nthis:\n  \\<exists>it. local_iwf it (fst (tree.root t))\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "case (Cut \\<Gamma> con)"], ["proof (state)\nthis:\n  snd (tree.root t) = Cut\n  fst (tree.root t) = (\\<Gamma> \\<turnstile> con)\n  (fst \\<circ> tree.root) |`| cont t = {|\\<Gamma> \\<turnstile> con|}\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "obtain s where \"subst s anyP = con\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. subst s anyP = con \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule anyP_is_any)"], ["proof (state)\nthis:\n  subst s anyP = con\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "hence  [simp]: \"subst s (freshen undefined anyP) = con\""], ["proof (prove)\nusing this:\n  subst s anyP = con\n\ngoal (1 subgoal):\n 1. subst s (freshen undefined anyP) = con", "by (simp add: lconsts_anyP freshen_closed)"], ["proof (state)\nthis:\n  subst s (freshen undefined anyP) = con\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>(fst \\<circ> root) |`| cont t = {|\\<Gamma> \\<turnstile> con|}\\<close>"], ["proof (chain)\npicking this:\n  (fst \\<circ> tree.root) |`| cont t = {|\\<Gamma> \\<turnstile> con|}", "obtain t'  where \"t' |\\<in>| cont t\" and [simp]: \"fst (root t') = (\\<Gamma> \\<turnstile> con)\""], ["proof (prove)\nusing this:\n  (fst \\<circ> tree.root) |`| cont t = {|\\<Gamma> \\<turnstile> con|}\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' |\\<in>| cont t;\n         fst (tree.root t') = (\\<Gamma> \\<turnstile> con)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"cont t\") auto"], ["proof (state)\nthis:\n  t' |\\<in>| cont t\n  fst (tree.root t') = (\\<Gamma> \\<turnstile> con)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>t' |\\<in>| cont t\\<close>"], ["proof (chain)\npicking this:\n  t' |\\<in>| cont t", "obtain \"it'\" where \"local_iwf it' (\\<Gamma> \\<turnstile> con)\""], ["proof (prove)\nusing this:\n  t' |\\<in>| cont t\n\ngoal (1 subgoal):\n 1. (\\<And>it'.\n        local_iwf it' (\\<Gamma> \\<turnstile> con) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using IH"], ["proof (prove)\nusing this:\n  t' |\\<in>| cont t\n  ?t'9 |\\<in>| cont t \\<Longrightarrow>\n  \\<exists>it'. local_iwf it' (fst (tree.root ?t'9))\n\ngoal (1 subgoal):\n 1. (\\<And>it'.\n        local_iwf it' (\\<Gamma> \\<turnstile> con) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  local_iwf it' (\\<Gamma> \\<turnstile> con)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "let \"?it\" = \"INode Helper anyP undefined s [it'] ::  ('form, 'rule, 'subst, 'var) itree\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "from \\<open>local_iwf it' (\\<Gamma> \\<turnstile> con)\\<close>"], ["proof (chain)\npicking this:\n  local_iwf it' (\\<Gamma> \\<turnstile> con)", "have \"local_iwf ?it (\\<Gamma> \\<turnstile> con)\""], ["proof (prove)\nusing this:\n  local_iwf it' (\\<Gamma> \\<turnstile> con)\n\ngoal (1 subgoal):\n 1. local_iwf (INode Helper anyP undefined s [it'])\n     (\\<Gamma> \\<turnstile> con)", "by (auto intro!: iwf local_fresh_check.intros)"], ["proof (state)\nthis:\n  local_iwf (INode Helper anyP undefined s [it'])\n   (\\<Gamma> \\<turnstile> con)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> c'.\n       \\<lbrakk>snd (tree.root t) = Cut;\n        fst (tree.root t) = (\\<Gamma> \\<turnstile> c');\n        (fst \\<circ> tree.root) |`| cont t =\n        {|\\<Gamma> \\<turnstile> c'|}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>it. local_iwf it (fst (tree.root t))", "thus ?thesis"], ["proof (prove)\nusing this:\n  local_iwf (INode Helper anyP undefined s [it'])\n   (\\<Gamma> \\<turnstile> con)\n\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (fst (tree.root t))", "unfolding Cut"], ["proof (prove)\nusing this:\n  local_iwf (INode Helper anyP undefined s [it'])\n   (\\<Gamma> \\<turnstile> con)\n\ngoal (1 subgoal):\n 1. \\<exists>it. local_iwf it (\\<Gamma> \\<turnstile> con)", ".."], ["proof (state)\nthis:\n  \\<exists>it. local_iwf it (fst (tree.root t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>it. local_iwf it (fst (tree.root t))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition to_it :: \"('form entailment \\<times> ('rule \\<times> 'form) NatRule) tree \\<Rightarrow> ('form,'rule,'subst,'var) itree\" where\n  \"to_it t = (SOME it. local_iwf it (fst (root t)))\""], ["", "lemma iwf_to_it:\n  assumes \"tfinite t\" and \"wf t\"\n  shows \"local_iwf (to_it t) (fst (root t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local_iwf (to_it t) (fst (tree.root t))", "unfolding to_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local_iwf (SOME it. local_iwf it (fst (tree.root t)))\n     (fst (tree.root t))", "using build_local_iwf[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>it. local_iwf it (fst (tree.root t))\n\ngoal (1 subgoal):\n 1. local_iwf (SOME it. local_iwf it (fst (tree.root t)))\n     (fst (tree.root t))", "by (rule someI2_ex)"], ["", "end"], ["", "end"]]}