{"file_name": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine/Incredible_Correctness.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine", "problem_names": ["lemma finite_global_assms': \"finite (global_assms' i)\"", "lemmas global_assmsI = global_assms'.intros[Transfer.transferred]", "lemmas global_assms_simps = global_assms'.simps[Transfer.transferred]", "lemma hyps_alongE[consumes 1, case_names Hyp Assumption]:\n  assumes \"f |\\<in>| hyps_along pth\"\n  obtains v p h where \"(v,p) \\<in> snd ` set pth\" and \"f = labelAtOut v h \" and \"h |\\<in>| hyps_for (nodeOf v) p\"\n  | v pf  where \"v |\\<in>| vertices\" and \"nodeOf v = Assumption pf\" \"f = labelAtOut v (Reg pf)\"", "lemma fst_root_tree[simp]: \"fst (root (tree v p pth)) = (hyps_along ((adjacentTo v p,(v,p))#pth) \\<turnstile> labelAtIn v p)\"", "lemma out_port_cases[consumes 1, case_names Assumption Hyp Rule Helper]:\n  assumes \"p |\\<in>| outPorts n\"\n  obtains\n    a where \"n = Assumption a\" and \"p = Reg a\"\n    | r h c where \"n = Rule r\" and \"p = Hyp h c\"\n    | r f where \"n = Rule r\" and \"p = Reg f\"\n    | \"n = Helper\" and \"p = Reg anyP\"", "lemma hyps_for_fimage: \"hyps_for (Rule r) x = (if x |\\<in>| f_antecedent r then (\\<lambda> f. Hyp f x) |`| (a_hyps x) else {||})\"", "theorem wf_tree:\n  assumes \"valid_in_port (v,p)\"\n  assumes \"terminal_path v t pth\"\n  shows \"wf (tree v p pth)\"", "lemma global_in_ass: \"global_assms TYPE('var) |\\<subseteq>| ass_forms\"", "lemma tfinite_map_tree: \"tfinite (map_tree f t) \\<longleftrightarrow> tfinite t\"", "lemma finite_tree_edge_tree:\n  \"tfinite (tree v p pth) \\<longleftrightarrow> tfinite (edge_tree v p)\"", "lemma path_is_forbidden:\n  assumes \"valid_in_port (v,p)\"\n  assumes \"ipath (edge_tree v p) es\"\n  shows \"forbidden_path v es\"", "lemma forbidden_path_prefix_is_path:\n  assumes \"forbidden_path v es\"\n  obtains v' where  \"path v' v (rev (stake n es))\"", "lemma forbidden_path_prefix_is_hyp_free:\n  assumes \"forbidden_path v es\"\n  shows \"hyps_free (rev (stake n es))\"", "theorem finite_tree:\n  assumes \"valid_in_port (v,p)\"\n  assumes \"terminal_vertex v\"\n  shows \"tfinite (tree v p pth)\"", "theorem solved"], "translations": [["", "lemma finite_global_assms': \"finite (global_assms' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (global_assms' i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (global_assms' i)", "have \"finite (fset vertices)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fset vertices)", "by (rule finite_fset)"], ["proof (state)\nthis:\n  finite (fset vertices)\n\ngoal (1 subgoal):\n 1. finite (global_assms' i)", "moreover"], ["proof (state)\nthis:\n  finite (fset vertices)\n\ngoal (1 subgoal):\n 1. finite (global_assms' i)", "have \"global_assms' i \\<subseteq> (\\<lambda> v. case nodeOf v of Assumption p \\<Rightarrow>  labelAtOut v (Reg p)) ` fset vertices\""], ["proof (prove)\ngoal (1 subgoal):\n 1. global_assms' i\n    \\<subseteq> (\\<lambda>v.\n                    case nodeOf v of\n                    Assumption p \\<Rightarrow> labelAtOut v (Reg p)) `\n                fset vertices", "by (force simp add: global_assms'.simps fmember.rep_eq image_iff )"], ["proof (state)\nthis:\n  global_assms' i\n  \\<subseteq> (\\<lambda>v.\n                  case nodeOf v of\n                  Assumption p \\<Rightarrow> labelAtOut v (Reg p)) `\n              fset vertices\n\ngoal (1 subgoal):\n 1. finite (global_assms' i)", "ultimately"], ["proof (chain)\npicking this:\n  finite (fset vertices)\n  global_assms' i\n  \\<subseteq> (\\<lambda>v.\n                  case nodeOf v of\n                  Assumption p \\<Rightarrow> labelAtOut v (Reg p)) `\n              fset vertices", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (fset vertices)\n  global_assms' i\n  \\<subseteq> (\\<lambda>v.\n                  case nodeOf v of\n                  Assumption p \\<Rightarrow> labelAtOut v (Reg p)) `\n              fset vertices\n\ngoal (1 subgoal):\n 1. finite (global_assms' i)", "by (rule finite_surj)"], ["proof (state)\nthis:\n  finite (global_assms' i)\n\ngoal:\nNo subgoals!", "qed"], ["", "context includes fset.lifting\nbegin"], ["", "lift_definition global_assms :: \"'var itself \\<Rightarrow> 'form fset\" is global_assms'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>itself. finite (global_assms' itself)", "by (rule finite_global_assms')"], ["", "lemmas global_assmsI = global_assms'.intros[Transfer.transferred]"], ["", "lemmas global_assms_simps = global_assms'.simps[Transfer.transferred]"], ["", "end"], ["", "fun extra_assms :: \"('vertex \\<times> ('form, 'var) in_port) \\<Rightarrow> 'form fset\" where\n  \"extra_assms (v, p) = (\\<lambda> p. labelAtOut v p) |`| hyps_for (nodeOf v) p\""], ["", "fun hyps_along :: \"('vertex, 'form, 'var) edge' list \\<Rightarrow> 'form fset\" where\n  \"hyps_along pth = ffUnion (extra_assms |`| snd |`| fset_from_list pth) |\\<union>| global_assms TYPE('var)\""], ["", "lemma hyps_alongE[consumes 1, case_names Hyp Assumption]:\n  assumes \"f |\\<in>| hyps_along pth\"\n  obtains v p h where \"(v,p) \\<in> snd ` set pth\" and \"f = labelAtOut v h \" and \"h |\\<in>| hyps_for (nodeOf v) p\"\n  | v pf  where \"v |\\<in>| vertices\" and \"nodeOf v = Assumption pf\" \"f = labelAtOut v (Reg pf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v p h.\n                \\<lbrakk>(v, p) \\<in> snd ` set pth; f = labelAtOut v h;\n                 h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>v pf.\n        \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n         f = labelAtOut v (Reg pf)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  f |\\<in>| hyps_along pth\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v p h.\n                \\<lbrakk>(v, p) \\<in> snd ` set pth; f = labelAtOut v h;\n                 h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>v pf.\n        \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n         f = labelAtOut v (Reg pf)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (auto simp add: fmember.rep_eq ffUnion.rep_eq  global_assms_simps[unfolded fmember.rep_eq])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba x.\n       \\<lbrakk>\\<And>v p h.\n                   \\<lbrakk>(v, p) \\<in> snd ` set pth;\n                    labelAtOut aa x = labelAtOut v h;\n                    hyps (nodeOf v) h = Some p\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>v pf.\n           \\<lbrakk>v \\<in> fset vertices; nodeOf v = Assumption pf;\n            labelAtOut aa x = labelAtOut v (Reg pf)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        ((a, b), aa, ba) \\<in> set pth; hyps (nodeOf aa) x = Some ba;\n        f = labelAtOut aa x\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (metis image_iff snd_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Here we build the natural deduction tree, by walking the graph.\\<close>"], ["", "primcorec tree :: \"'vertex \\<Rightarrow> ('form, 'var) in_port \\<Rightarrow> ('vertex, 'form, 'var) edge' list \\<Rightarrow>  (('form entailment), ('rule \\<times> 'form) NatRule) dtree\" where\n \"root (tree v p pth) =\n    ((hyps_along ((adjacentTo v p,(v,p))#pth) \\<turnstile> labelAtIn v p),\n    (case adjacentTo v p of (v', p') \\<Rightarrow> toNatRule v' p'\n    ))\"\n | \"cont (tree v p pth) =\n    (case adjacentTo v p of (v', p') \\<Rightarrow>\n    (if isReg v' p' then ((\\<lambda> p''. tree v' p'' ((adjacentTo v p,(v,p))#pth)) |`| inPorts (nodeOf v')) else {||}\n    ))\""], ["", "lemma fst_root_tree[simp]: \"fst (root (tree v p pth)) = (hyps_along ((adjacentTo v p,(v,p))#pth) \\<turnstile> labelAtIn v p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (tree.root (tree v p pth)) =\n    (hyps_along ((adjacentTo v p, v, p) # pth) \\<turnstile> labelAtIn v p)", "by simp"], ["", "lemma out_port_cases[consumes 1, case_names Assumption Hyp Rule Helper]:\n  assumes \"p |\\<in>| outPorts n\"\n  obtains\n    a where \"n = Assumption a\" and \"p = Reg a\"\n    | r h c where \"n = Rule r\" and \"p = Hyp h c\"\n    | r f where \"n = Rule r\" and \"p = Reg f\"\n    | \"n = Helper\" and \"p = Reg anyP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a.\n                \\<lbrakk>n = Assumption a; p = Reg a\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>r h c.\n        \\<lbrakk>n = Rule r; p = Hyp h c\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>r f.\n        \\<lbrakk>n = Rule r; p = Reg f\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>n = Helper; p = Reg anyP\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  p |\\<in>| outPorts n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a.\n                \\<lbrakk>n = Assumption a; p = Reg a\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>r h c.\n        \\<lbrakk>n = Rule r; p = Hyp h c\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>r f.\n        \\<lbrakk>n = Rule r; p = Reg f\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>n = Helper; p = Reg anyP\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (atomize_elim, cases p; cases n) auto"], ["", "lemma hyps_for_fimage: \"hyps_for (Rule r) x = (if x |\\<in>| f_antecedent r then (\\<lambda> f. Hyp f x) |`| (a_hyps x) else {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hyps_for (Rule r) x =\n    (if x |\\<in>| f_antecedent r then (\\<lambda>f. Hyp f x) |`| a_hyps x\n     else {||})", "apply (rule fset_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa |\\<in>| hyps_for (Rule r) x) =\n       (xa |\\<in>|\n        (if x |\\<in>| f_antecedent r then (\\<lambda>f. Hyp f x) |`| a_hyps x\n         else {||}))", "apply (rename_tac p')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p'.\n       (p' |\\<in>| hyps_for (Rule r) x) =\n       (p' |\\<in>|\n        (if x |\\<in>| f_antecedent r then (\\<lambda>f. Hyp f x) |`| a_hyps x\n         else {||}))", "apply (case_tac p')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p' x1.\n       p' = Reg x1 \\<Longrightarrow>\n       (p' |\\<in>| hyps_for (Rule r) x) =\n       (p' |\\<in>|\n        (if x |\\<in>| f_antecedent r then (\\<lambda>f. Hyp f x) |`| a_hyps x\n         else {||}))\n 2. \\<And>p' x21 x22.\n       p' = Hyp x21 x22 \\<Longrightarrow>\n       (p' |\\<in>| hyps_for (Rule r) x) =\n       (p' |\\<in>|\n        (if x |\\<in>| f_antecedent r then (\\<lambda>f. Hyp f x) |`| a_hyps x\n         else {||}))", "apply (auto simp add:  split: if_splits out_port.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Now we prove that the thus produced tree is well-formed.\\<close>"], ["", "theorem wf_tree:\n  assumes \"valid_in_port (v,p)\"\n  assumes \"terminal_path v t pth\"\n  shows \"wf (tree v p pth)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf (tree v p pth)", "using assms"], ["proof (prove)\nusing this:\n  valid_in_port (v, p)\n  terminal_path v t pth\n\ngoal (1 subgoal):\n 1. local.wf (tree v p pth)", "proof (coinduction arbitrary: v p pth)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p pth.\n       \\<lbrakk>valid_in_port (v, p); terminal_path v t pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)", "case (wf v p pth)"], ["proof (state)\nthis:\n  valid_in_port (v, p)\n  terminal_path v t pth\n\ngoal (1 subgoal):\n 1. \\<And>v p pth.\n       \\<lbrakk>valid_in_port (v, p); terminal_path v t pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)", "let ?t = \"tree v p pth\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p pth.\n       \\<lbrakk>valid_in_port (v, p); terminal_path v t pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)", "from saturated[OF wf(1)]"], ["proof (chain)\npicking this:\n  \\<exists>e\\<in>edges. snd e = (v, p)", "obtain v' p'\n  where e:\"((v',p'),(v,p)) \\<in> edges\" and [simp]: \"adjacentTo v p = (v',p')\""], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>edges. snd e = (v, p)\n\ngoal (1 subgoal):\n 1. (\\<And>v' p'.\n        \\<lbrakk>((v', p'), v, p) \\<in> edges;\n         adjacentTo v p = (v', p')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: adjacentTo_def, metis (no_types, lifting) eq_fst_iff tfl_some)"], ["proof (state)\nthis:\n  ((v', p'), v, p) \\<in> edges\n  adjacentTo v p = (v', p')\n\ngoal (1 subgoal):\n 1. \\<And>v p pth.\n       \\<lbrakk>valid_in_port (v, p); terminal_path v t pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)", "let ?e = \"((v',p'),(v,p))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p pth.\n       \\<lbrakk>valid_in_port (v, p); terminal_path v t pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)", "let ?pth' = \"?e#pth\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p pth.\n       \\<lbrakk>valid_in_port (v, p); terminal_path v t pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)", "let ?\\<Gamma> = \"hyps_along ?pth'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p pth.\n       \\<lbrakk>valid_in_port (v, p); terminal_path v t pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)", "let ?l = \"labelAtIn v p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p pth.\n       \\<lbrakk>valid_in_port (v, p); terminal_path v t pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)", "from e valid_edges"], ["proof (chain)\npicking this:\n  ((v', p'), v, p) \\<in> edges\n  \\<forall>(ps1, ps2)\\<in>edges. valid_out_port ps1 \\<and> valid_in_port ps2", "have \"v' |\\<in>| vertices\" and \"p' |\\<in>| outPorts (nodeOf v')\""], ["proof (prove)\nusing this:\n  ((v', p'), v, p) \\<in> edges\n  \\<forall>(ps1, ps2)\\<in>edges. valid_out_port ps1 \\<and> valid_in_port ps2\n\ngoal (1 subgoal):\n 1. v' |\\<in>| vertices &&& p' |\\<in>| outPorts (nodeOf v')", "by auto"], ["proof (state)\nthis:\n  v' |\\<in>| vertices\n  p' |\\<in>| outPorts (nodeOf v')\n\ngoal (1 subgoal):\n 1. \\<And>v p pth.\n       \\<lbrakk>valid_in_port (v, p); terminal_path v t pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)", "hence \"nodeOf v' \\<in> sset nodes\""], ["proof (prove)\nusing this:\n  v' |\\<in>| vertices\n  p' |\\<in>| outPorts (nodeOf v')\n\ngoal (1 subgoal):\n 1. nodeOf v' \\<in> i.R nodes", "using valid_nodes"], ["proof (prove)\nusing this:\n  v' |\\<in>| vertices\n  p' |\\<in>| outPorts (nodeOf v')\n  nodeOf ` fset vertices \\<subseteq> i.R nodes\n\ngoal (1 subgoal):\n 1. nodeOf v' \\<in> i.R nodes", "by (meson image_eqI notin_fset subsetD)"], ["proof (state)\nthis:\n  nodeOf v' \\<in> i.R nodes\n\ngoal (1 subgoal):\n 1. \\<And>v p pth.\n       \\<lbrakk>valid_in_port (v, p); terminal_path v t pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)", "from \\<open>?e \\<in> edges\\<close>"], ["proof (chain)\npicking this:\n  ((v', p'), v, p) \\<in> edges", "have s: \"labelAtOut v' p' = labelAtIn v p\""], ["proof (prove)\nusing this:\n  ((v', p'), v, p) \\<in> edges\n\ngoal (1 subgoal):\n 1. labelAtOut v' p' = labelAtIn v p", "by (rule solved)"], ["proof (state)\nthis:\n  labelAtOut v' p' = labelAtIn v p\n\ngoal (1 subgoal):\n 1. \\<And>v p pth.\n       \\<lbrakk>valid_in_port (v, p); terminal_path v t pth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)", "from \\<open>p' |\\<in>| outPorts (nodeOf v')\\<close>"], ["proof (chain)\npicking this:\n  p' |\\<in>| outPorts (nodeOf v')", "show ?case"], ["proof (prove)\nusing this:\n  p' |\\<in>| outPorts (nodeOf v')\n\ngoal (1 subgoal):\n 1. \\<exists>ta.\n       tree v p pth = ta \\<and>\n       snd (tree.root ta) \\<in> R \\<and>\n       effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n       (\\<forall>x.\n           x |\\<in>| cont ta \\<longrightarrow>\n           (\\<exists>v p pth.\n               x = tree v p pth \\<and>\n               valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n           local.wf x)", "proof (cases rule: out_port_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "case (Hyp r h c)"], ["proof (state)\nthis:\n  nodeOf v' = Rule r\n  p' = Hyp h c\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "from Hyp \\<open>p' |\\<in>| outPorts (nodeOf v')\\<close>"], ["proof (chain)\npicking this:\n  nodeOf v' = Rule r\n  p' = Hyp h c\n  p' |\\<in>| outPorts (nodeOf v')", "have \"h |\\<in>| a_hyps c\" and \"c |\\<in>| f_antecedent r\""], ["proof (prove)\nusing this:\n  nodeOf v' = Rule r\n  p' = Hyp h c\n  p' |\\<in>| outPorts (nodeOf v')\n\ngoal (1 subgoal):\n 1. h |\\<in>| a_hyps c &&& c |\\<in>| f_antecedent r", "by auto"], ["proof (state)\nthis:\n  h |\\<in>| a_hyps c\n  c |\\<in>| f_antecedent r\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "hence \"hyps (nodeOf v') (Hyp h c) = Some c\""], ["proof (prove)\nusing this:\n  h |\\<in>| a_hyps c\n  c |\\<in>| f_antecedent r\n\ngoal (1 subgoal):\n 1. hyps (nodeOf v') (Hyp h c) = Some c", "using Hyp"], ["proof (prove)\nusing this:\n  h |\\<in>| a_hyps c\n  c |\\<in>| f_antecedent r\n  nodeOf v' = Rule r\n  p' = Hyp h c\n\ngoal (1 subgoal):\n 1. hyps (nodeOf v') (Hyp h c) = Some c", "by simp"], ["proof (state)\nthis:\n  hyps (nodeOf v') (Hyp h c) = Some c\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "from well_scoped[OF \\<open> _ \\<in> edges\\<close>[unfolded Hyp] this]"], ["proof (chain)\npicking this:\n  (v, p) = (v', c) \\<or> v \\<in> scope (v', c)", "have \"(v, p) = (v', c) \\<or> v \\<in> scope (v', c)\""], ["proof (prove)\nusing this:\n  (v, p) = (v', c) \\<or> v \\<in> scope (v', c)\n\ngoal (1 subgoal):\n 1. (v, p) = (v', c) \\<or> v \\<in> scope (v', c)", "."], ["proof (state)\nthis:\n  (v, p) = (v', c) \\<or> v \\<in> scope (v', c)\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "hence \"(v', c) \\<in> insert (v, p) (snd ` set pth)\""], ["proof (prove)\nusing this:\n  (v, p) = (v', c) \\<or> v \\<in> scope (v', c)\n\ngoal (1 subgoal):\n 1. (v', c) \\<in> insert (v, p) (snd ` set pth)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (v, p) = (v', c) \\<Longrightarrow>\n    (v', c) \\<in> insert (v, p) (snd ` set pth)\n 2. v \\<in> scope (v', c) \\<Longrightarrow>\n    (v', c) \\<in> insert (v, p) (snd ` set pth)", "assume \"(v, p) = (v', c)\""], ["proof (state)\nthis:\n  (v, p) = (v', c)\n\ngoal (2 subgoals):\n 1. (v, p) = (v', c) \\<Longrightarrow>\n    (v', c) \\<in> insert (v, p) (snd ` set pth)\n 2. v \\<in> scope (v', c) \\<Longrightarrow>\n    (v', c) \\<in> insert (v, p) (snd ` set pth)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (v, p) = (v', c)\n\ngoal (1 subgoal):\n 1. (v', c) \\<in> insert (v, p) (snd ` set pth)", "by simp"], ["proof (state)\nthis:\n  (v', c) \\<in> insert (v, p) (snd ` set pth)\n\ngoal (1 subgoal):\n 1. v \\<in> scope (v', c) \\<Longrightarrow>\n    (v', c) \\<in> insert (v, p) (snd ` set pth)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> scope (v', c) \\<Longrightarrow>\n    (v', c) \\<in> insert (v, p) (snd ` set pth)", "assume \"v \\<in> scope (v', c)\""], ["proof (state)\nthis:\n  v \\<in> scope (v', c)\n\ngoal (1 subgoal):\n 1. v \\<in> scope (v', c) \\<Longrightarrow>\n    (v', c) \\<in> insert (v, p) (snd ` set pth)", "from this terminal_path_end_is_terminal[OF wf(2)] terminal_path_is_path[OF wf(2)]"], ["proof (chain)\npicking this:\n  v \\<in> scope (v', c)\n  terminal_vertex t\n  path v t pth", "have \"(v', c) \\<in> snd ` set pth\""], ["proof (prove)\nusing this:\n  v \\<in> scope (v', c)\n  terminal_vertex t\n  path v t pth\n\ngoal (1 subgoal):\n 1. (v', c) \\<in> snd ` set pth", "by (rule scope_find)"], ["proof (state)\nthis:\n  (v', c) \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. v \\<in> scope (v', c) \\<Longrightarrow>\n    (v', c) \\<in> insert (v, p) (snd ` set pth)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (v', c) \\<in> snd ` set pth\n\ngoal (1 subgoal):\n 1. (v', c) \\<in> insert (v, p) (snd ` set pth)", "by simp"], ["proof (state)\nthis:\n  (v', c) \\<in> insert (v, p) (snd ` set pth)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v', c) \\<in> insert (v, p) (snd ` set pth)\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "moreover"], ["proof (state)\nthis:\n  (v', c) \\<in> insert (v, p) (snd ` set pth)\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "from \\<open>hyps (nodeOf v') (Hyp h c) = Some c\\<close>"], ["proof (chain)\npicking this:\n  hyps (nodeOf v') (Hyp h c) = Some c", "have \"Hyp h c |\\<in>| hyps_for (nodeOf v') c\""], ["proof (prove)\nusing this:\n  hyps (nodeOf v') (Hyp h c) = Some c\n\ngoal (1 subgoal):\n 1. Hyp h c |\\<in>| hyps_for (nodeOf v') c", "by simp"], ["proof (state)\nthis:\n  Hyp h c |\\<in>| hyps_for (nodeOf v') c\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "hence \"labelAtOut v' (Hyp h c) |\\<in>| extra_assms (v',c)\""], ["proof (prove)\nusing this:\n  Hyp h c |\\<in>| hyps_for (nodeOf v') c\n\ngoal (1 subgoal):\n 1. labelAtOut v' (Hyp h c) |\\<in>| extra_assms (v', c)", "by auto"], ["proof (state)\nthis:\n  labelAtOut v' (Hyp h c) |\\<in>| extra_assms (v', c)\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "ultimately"], ["proof (chain)\npicking this:\n  (v', c) \\<in> insert (v, p) (snd ` set pth)\n  labelAtOut v' (Hyp h c) |\\<in>| extra_assms (v', c)", "have \"labelAtOut v' (Hyp h c) |\\<in>| ?\\<Gamma>\""], ["proof (prove)\nusing this:\n  (v', c) \\<in> insert (v, p) (snd ` set pth)\n  labelAtOut v' (Hyp h c) |\\<in>| extra_assms (v', c)\n\ngoal (1 subgoal):\n 1. labelAtOut v' (Hyp h c) |\\<in>| hyps_along (((v', p'), v, p) # pth)", "by (fastforce simp add: fmember.rep_eq ffUnion.rep_eq)"], ["proof (state)\nthis:\n  labelAtOut v' (Hyp h c) |\\<in>| hyps_along (((v', p'), v, p) # pth)\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "hence \"labelAtIn v p |\\<in>| ?\\<Gamma>\""], ["proof (prove)\nusing this:\n  labelAtOut v' (Hyp h c) |\\<in>| hyps_along (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. labelAtIn v p |\\<in>| hyps_along (((v', p'), v, p) # pth)", "by (simp add: s[symmetric] Hyp fmember.rep_eq)"], ["proof (state)\nthis:\n  labelAtIn v p |\\<in>| hyps_along (((v', p'), v, p) # pth)\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  labelAtIn v p |\\<in>| hyps_along (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. \\<exists>ta.\n       tree v p pth = ta \\<and>\n       snd (tree.root ta) \\<in> R \\<and>\n       effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n       (\\<forall>x.\n           x |\\<in>| cont ta \\<longrightarrow>\n           (\\<exists>v p pth.\n               x = tree v p pth \\<and>\n               valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n           local.wf x)", "using Hyp"], ["proof (prove)\nusing this:\n  labelAtIn v p |\\<in>| hyps_along (((v', p'), v, p) # pth)\n  nodeOf v' = Rule r\n  p' = Hyp h c\n\ngoal (1 subgoal):\n 1. \\<exists>ta.\n       tree v p pth = ta \\<and>\n       snd (tree.root ta) \\<in> R \\<and>\n       effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n       (\\<forall>x.\n           x |\\<in>| cont ta \\<longrightarrow>\n           (\\<exists>v p pth.\n               x = tree v p pth \\<and>\n               valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n           local.wf x)", "apply (auto intro: exI[where x = ?t] simp add: eff.simps simp del: hyps_along.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ta.\n     tree v p pth = ta \\<and>\n     snd (tree.root ta) \\<in> R \\<and>\n     effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n     (\\<forall>x.\n         x |\\<in>| cont ta \\<longrightarrow>\n         (\\<exists>v p pth.\n             x = tree v p pth \\<and>\n             valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n         local.wf x)\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "case (Assumption f)"], ["proof (state)\nthis:\n  nodeOf v' = Assumption f\n  p' = Reg f\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "from \\<open>v' |\\<in>| vertices\\<close> \\<open>nodeOf v' = Assumption f\\<close>"], ["proof (chain)\npicking this:\n  v' |\\<in>| vertices\n  nodeOf v' = Assumption f", "have \"labelAtOut v' (Reg f) |\\<in>| global_assms TYPE('var)\""], ["proof (prove)\nusing this:\n  v' |\\<in>| vertices\n  nodeOf v' = Assumption f\n\ngoal (1 subgoal):\n 1. labelAtOut v' (Reg f) |\\<in>| global_assms TYPE('var)", "by (rule global_assmsI)"], ["proof (state)\nthis:\n  labelAtOut v' (Reg f) |\\<in>| global_assms TYPE('var)\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "hence \"labelAtOut v' (Reg f) |\\<in>| ?\\<Gamma>\""], ["proof (prove)\nusing this:\n  labelAtOut v' (Reg f) |\\<in>| global_assms TYPE('var)\n\ngoal (1 subgoal):\n 1. labelAtOut v' (Reg f) |\\<in>| hyps_along (((v', p'), v, p) # pth)", "by auto"], ["proof (state)\nthis:\n  labelAtOut v' (Reg f) |\\<in>| hyps_along (((v', p'), v, p) # pth)\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "hence \"labelAtIn v p |\\<in>| ?\\<Gamma>\""], ["proof (prove)\nusing this:\n  labelAtOut v' (Reg f) |\\<in>| hyps_along (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. labelAtIn v p |\\<in>| hyps_along (((v', p'), v, p) # pth)", "by (simp add: s[symmetric] Assumption fmember.rep_eq)"], ["proof (state)\nthis:\n  labelAtIn v p |\\<in>| hyps_along (((v', p'), v, p) # pth)\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 3. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  labelAtIn v p |\\<in>| hyps_along (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. \\<exists>ta.\n       tree v p pth = ta \\<and>\n       snd (tree.root ta) \\<in> R \\<and>\n       effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n       (\\<forall>x.\n           x |\\<in>| cont ta \\<longrightarrow>\n           (\\<exists>v p pth.\n               x = tree v p pth \\<and>\n               valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n           local.wf x)", "using Assumption"], ["proof (prove)\nusing this:\n  labelAtIn v p |\\<in>| hyps_along (((v', p'), v, p) # pth)\n  nodeOf v' = Assumption f\n  p' = Reg f\n\ngoal (1 subgoal):\n 1. \\<exists>ta.\n       tree v p pth = ta \\<and>\n       snd (tree.root ta) \\<in> R \\<and>\n       effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n       (\\<forall>x.\n           x |\\<in>| cont ta \\<longrightarrow>\n           (\\<exists>v p pth.\n               x = tree v p pth \\<and>\n               valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n           local.wf x)", "by (auto intro: exI[where x = ?t] simp add: eff.simps)"], ["proof (state)\nthis:\n  \\<exists>ta.\n     tree v p pth = ta \\<and>\n     snd (tree.root ta) \\<in> R \\<and>\n     effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n     (\\<forall>x.\n         x |\\<in>| cont ta \\<longrightarrow>\n         (\\<exists>v p pth.\n             x = tree v p pth \\<and>\n             valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n         local.wf x)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "case (Rule r f)"], ["proof (state)\nthis:\n  nodeOf v' = Rule r\n  p' = Reg f\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "with \\<open>nodeOf v' \\<in> sset nodes\\<close>"], ["proof (chain)\npicking this:\n  nodeOf v' \\<in> i.R nodes\n  nodeOf v' = Rule r\n  p' = Reg f", "have \"r \\<in> sset rules\""], ["proof (prove)\nusing this:\n  nodeOf v' \\<in> i.R nodes\n  nodeOf v' = Rule r\n  p' = Reg f\n\ngoal (1 subgoal):\n 1. r \\<in> i.R rules", "by (auto simp add: nodes_def stream.set_map)"], ["proof (state)\nthis:\n  r \\<in> i.R rules\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "from Rule"], ["proof (chain)\npicking this:\n  nodeOf v' = Rule r\n  p' = Reg f", "have \"hyps (nodeOf v') p' = None\""], ["proof (prove)\nusing this:\n  nodeOf v' = Rule r\n  p' = Reg f\n\ngoal (1 subgoal):\n 1. hyps (nodeOf v') p' = None", "by simp"], ["proof (state)\nthis:\n  hyps (nodeOf v') p' = None\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "with e \\<open>terminal_path v t pth\\<close>"], ["proof (chain)\npicking this:\n  ((v', p'), v, p) \\<in> edges\n  terminal_path v t pth\n  hyps (nodeOf v') p' = None", "have \"terminal_path v' t ?pth'\""], ["proof (prove)\nusing this:\n  ((v', p'), v, p) \\<in> edges\n  terminal_path v t pth\n  hyps (nodeOf v') p' = None\n\ngoal (1 subgoal):\n 1. terminal_path v' t (((v', p'), v, p) # pth)", ".."], ["proof (state)\nthis:\n  terminal_path v' t (((v', p'), v, p) # pth)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "from Rule  \\<open>p' |\\<in>| outPorts (nodeOf v')\\<close>"], ["proof (chain)\npicking this:\n  nodeOf v' = Rule r\n  p' = Reg f\n  p' |\\<in>| outPorts (nodeOf v')", "have \"f |\\<in>| f_consequent r\""], ["proof (prove)\nusing this:\n  nodeOf v' = Rule r\n  p' = Reg f\n  p' |\\<in>| outPorts (nodeOf v')\n\ngoal (1 subgoal):\n 1. f |\\<in>| f_consequent r", "by simp"], ["proof (state)\nthis:\n  f |\\<in>| f_consequent r\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "hence \"f \\<in> set (consequent r)\""], ["proof (prove)\nusing this:\n  f |\\<in>| f_consequent r\n\ngoal (1 subgoal):\n 1. f \\<in> set (consequent r)", "by (simp add: f_consequent_def)"], ["proof (state)\nthis:\n  f \\<in> set (consequent r)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "with \\<open>r \\<in> sset rules\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> i.R rules\n  f \\<in> set (consequent r)", "have \"NatRule (r, f) \\<in> sset (smap NatRule n_rules)\""], ["proof (prove)\nusing this:\n  r \\<in> i.R rules\n  f \\<in> set (consequent r)\n\ngoal (1 subgoal):\n 1. NatRule (r, f) \\<in> i.R (smap NatRule n_rules)", "by (auto simp add: stream.set_map n_rules_def no_empty_conclusions)"], ["proof (state)\nthis:\n  NatRule (r, f) \\<in> i.R (smap NatRule n_rules)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "moreover"], ["proof (state)\nthis:\n  NatRule (r, f) \\<in> i.R (smap NatRule n_rules)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "{"], ["proof (state)\nthis:\n  NatRule (r, f) \\<in> i.R (smap NatRule n_rules)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "from \\<open>f |\\<in>| f_consequent r\\<close>"], ["proof (chain)\npicking this:\n  f |\\<in>| f_consequent r", "have \"f \\<in> set (consequent r)\""], ["proof (prove)\nusing this:\n  f |\\<in>| f_consequent r\n\ngoal (1 subgoal):\n 1. f \\<in> set (consequent r)", "by (simp add: f_consequent_def)"], ["proof (state)\nthis:\n  f \\<in> set (consequent r)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "hence \"natEff_Inst (r, f) f (f_antecedent r)\""], ["proof (prove)\nusing this:\n  f \\<in> set (consequent r)\n\ngoal (1 subgoal):\n 1. natEff_Inst (r, f) f (f_antecedent r)", "by (rule natEff_Inst.intros)"], ["proof (state)\nthis:\n  natEff_Inst (r, f) f (f_antecedent r)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "hence \"eff (NatRule (r, f)) (?\\<Gamma> \\<turnstile> subst (inst v') (freshen (vidx v') f))\n           ((\\<lambda>ant. ((\\<lambda>p. subst (inst v') (freshen (vidx v') p)) |`| a_hyps ant |\\<union>| ?\\<Gamma> \\<turnstile> subst (inst v') (freshen (vidx v') (a_conc ant)))) |`| f_antecedent r)\"\n           (is \"eff _ _ ?ants\")"], ["proof (prove)\nusing this:\n  natEff_Inst (r, f) f (f_antecedent r)\n\ngoal (1 subgoal):\n 1. eff (NatRule (r, f))\n     (hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n      subst (inst v') (freshen (vidx v') f))\n     ((\\<lambda>ant.\n          (\\<lambda>p. subst (inst v') (freshen (vidx v') p)) |`|\n          a_hyps ant |\\<union>|\n          hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n          subst (inst v') (freshen (vidx v') (a_conc ant))) |`|\n      f_antecedent r)", "proof (rule eff.intros)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| f_antecedent r;\n        f |\\<in>| hyps_along (((v', p'), v, p) # pth)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "fix ant f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| f_antecedent r;\n        f |\\<in>| hyps_along (((v', p'), v, p) # pth)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "assume \"ant |\\<in>| f_antecedent r\""], ["proof (state)\nthis:\n  ant |\\<in>| f_antecedent r\n\ngoal (2 subgoals):\n 1. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| f_antecedent r;\n        f |\\<in>| hyps_along (((v', p'), v, p) # pth)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "from  \\<open>v' |\\<in>| vertices\\<close> \\<open>ant |\\<in>| f_antecedent r\\<close>"], ["proof (chain)\npicking this:\n  v' |\\<in>| vertices\n  ant |\\<in>| f_antecedent r", "have \"valid_in_port (v',ant)\""], ["proof (prove)\nusing this:\n  v' |\\<in>| vertices\n  ant |\\<in>| f_antecedent r\n\ngoal (1 subgoal):\n 1. valid_in_port (v', ant)", "by (simp add: Rule)"], ["proof (state)\nthis:\n  valid_in_port (v', ant)\n\ngoal (2 subgoals):\n 1. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| f_antecedent r;\n        f |\\<in>| hyps_along (((v', p'), v, p) # pth)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "assume \"f |\\<in>| ?\\<Gamma>\""], ["proof (state)\nthis:\n  f |\\<in>| hyps_along (((v', p'), v, p) # pth)\n\ngoal (2 subgoals):\n 1. \\<And>ant f.\n       \\<lbrakk>ant |\\<in>| f_antecedent r;\n        f |\\<in>| hyps_along (((v', p'), v, p) # pth)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "thus \"freshenLC (vidx v') ` a_fresh ant \\<inter> lconsts f = {}\""], ["proof (prove)\nusing this:\n  f |\\<in>| hyps_along (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. freshenLC (vidx v') ` a_fresh ant \\<inter> lconsts f = {}", "proof(induct rule: hyps_alongE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v p h.\n       \\<lbrakk>(v, p) \\<in> snd ` set (((v', p'), v, p) # pth);\n        f = labelAtOut v h; h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "case (Hyp v'' p'' h'')"], ["proof (state)\nthis:\n  (v'', p'') \\<in> snd ` set (((v', p'), v, p) # pth)\n  f = labelAtOut v'' h''\n  h'' |\\<in>| hyps_for (nodeOf v'') p''\n\ngoal (2 subgoals):\n 1. \\<And>v p h.\n       \\<lbrakk>(v, p) \\<in> snd ` set (((v', p'), v, p) # pth);\n        f = labelAtOut v h; h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "from Hyp(1) snd_set_path_verties[OF terminal_path_is_path[OF \\<open>terminal_path v' t ?pth'\\<close>]]"], ["proof (chain)\npicking this:\n  (v'', p'') \\<in> snd ` set (((v', p'), v, p) # pth)\n  fst ` snd ` set (((v', p'), v, p) # pth) \\<subseteq> fset vertices", "have \"v'' |\\<in>| vertices\""], ["proof (prove)\nusing this:\n  (v'', p'') \\<in> snd ` set (((v', p'), v, p) # pth)\n  fst ` snd ` set (((v', p'), v, p) # pth) \\<subseteq> fset vertices\n\ngoal (1 subgoal):\n 1. v'' |\\<in>| vertices", "by (force simp add: fmember.rep_eq)"], ["proof (state)\nthis:\n  v'' |\\<in>| vertices\n\ngoal (2 subgoals):\n 1. \\<And>v p h.\n       \\<lbrakk>(v, p) \\<in> snd ` set (((v', p'), v, p) # pth);\n        f = labelAtOut v h; h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "from \\<open>terminal_path v' t ?pth'\\<close> Hyp(1)"], ["proof (chain)\npicking this:\n  terminal_path v' t (((v', p'), v, p) # pth)\n  (v'', p'') \\<in> snd ` set (((v', p'), v, p) # pth)", "have \"v'' \\<notin> scope (v', ant)\""], ["proof (prove)\nusing this:\n  terminal_path v' t (((v', p'), v, p) # pth)\n  (v'', p'') \\<in> snd ` set (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. v'' \\<notin> scope (v', ant)", "by (rule hyps_free_path_not_in_scope)"], ["proof (state)\nthis:\n  v'' \\<notin> scope (v', ant)\n\ngoal (2 subgoals):\n 1. \\<And>v p h.\n       \\<lbrakk>(v, p) \\<in> snd ` set (((v', p'), v, p) # pth);\n        f = labelAtOut v h; h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "with \\<open>valid_in_port (v',ant)\\<close> \\<open>v'' |\\<in>| vertices\\<close>"], ["proof (chain)\npicking this:\n  valid_in_port (v', ant)\n  v'' |\\<in>| vertices\n  v'' \\<notin> scope (v', ant)", "have \"freshenLC (vidx v') ` local_vars (nodeOf v') ant \\<inter> subst_lconsts (inst v'') = {}\""], ["proof (prove)\nusing this:\n  valid_in_port (v', ant)\n  v'' |\\<in>| vertices\n  v'' \\<notin> scope (v', ant)\n\ngoal (1 subgoal):\n 1. freshenLC (vidx v') ` local_vars (nodeOf v') ant \\<inter>\n    subst_lconsts (inst v'') =\n    {}", "by (rule out_of_scope)"], ["proof (state)\nthis:\n  freshenLC (vidx v') ` local_vars (nodeOf v') ant \\<inter>\n  subst_lconsts (inst v'') =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>v p h.\n       \\<lbrakk>(v, p) \\<in> snd ` set (((v', p'), v, p) # pth);\n        f = labelAtOut v h; h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "moreover"], ["proof (state)\nthis:\n  freshenLC (vidx v') ` local_vars (nodeOf v') ant \\<inter>\n  subst_lconsts (inst v'') =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>v p h.\n       \\<lbrakk>(v, p) \\<in> snd ` set (((v', p'), v, p) # pth);\n        f = labelAtOut v h; h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "from hyps_free_vertices_distinct'[OF \\<open>terminal_path v' t ?pth'\\<close>] Hyp.hyps(1)"], ["proof (chain)\npicking this:\n  distinct (v' # map fst (map snd (((v', p'), v, p) # pth)))\n  (v'', p'') \\<in> snd ` set (((v', p'), v, p) # pth)", "have \"v'' \\<noteq> v'\""], ["proof (prove)\nusing this:\n  distinct (v' # map fst (map snd (((v', p'), v, p) # pth)))\n  (v'', p'') \\<in> snd ` set (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. v'' \\<noteq> v'", "by (metis distinct.simps(2) fst_conv image_eqI list.set_map)"], ["proof (state)\nthis:\n  v'' \\<noteq> v'\n\ngoal (2 subgoals):\n 1. \\<And>v p h.\n       \\<lbrakk>(v, p) \\<in> snd ` set (((v', p'), v, p) # pth);\n        f = labelAtOut v h; h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "hence \"vidx v'' \\<noteq> vidx v'\""], ["proof (prove)\nusing this:\n  v'' \\<noteq> v'\n\ngoal (1 subgoal):\n 1. vidx v'' \\<noteq> vidx v'", "using \\<open>v' |\\<in>| vertices\\<close> \\<open>v'' |\\<in>| vertices\\<close>"], ["proof (prove)\nusing this:\n  v'' \\<noteq> v'\n  v' |\\<in>| vertices\n  v'' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. vidx v'' \\<noteq> vidx v'", "by (meson vidx_inj inj_onD notin_fset)"], ["proof (state)\nthis:\n  vidx v'' \\<noteq> vidx v'\n\ngoal (2 subgoals):\n 1. \\<And>v p h.\n       \\<lbrakk>(v, p) \\<in> snd ` set (((v', p'), v, p) # pth);\n        f = labelAtOut v h; h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "hence \"freshenLC (vidx v') ` a_fresh ant \\<inter> freshenLC (vidx v'') ` lconsts (labelsOut (nodeOf v'') h'') = {}\""], ["proof (prove)\nusing this:\n  vidx v'' \\<noteq> vidx v'\n\ngoal (1 subgoal):\n 1. freshenLC (vidx v') ` a_fresh ant \\<inter>\n    freshenLC (vidx v'') ` lconsts (labelsOut (nodeOf v'') h'') =\n    {}", "by auto"], ["proof (state)\nthis:\n  freshenLC (vidx v') ` a_fresh ant \\<inter>\n  freshenLC (vidx v'') ` lconsts (labelsOut (nodeOf v'') h'') =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>v p h.\n       \\<lbrakk>(v, p) \\<in> snd ` set (((v', p'), v, p) # pth);\n        f = labelAtOut v h; h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "moreover"], ["proof (state)\nthis:\n  freshenLC (vidx v') ` a_fresh ant \\<inter>\n  freshenLC (vidx v'') ` lconsts (labelsOut (nodeOf v'') h'') =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>v p h.\n       \\<lbrakk>(v, p) \\<in> snd ` set (((v', p'), v, p) # pth);\n        f = labelAtOut v h; h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "have \"lconsts f \\<subseteq> lconsts (freshen (vidx v'') (labelsOut (nodeOf v'') h'')) \\<union> subst_lconsts (inst v'') \""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconsts f\n    \\<subseteq> lconsts\n                 (freshen (vidx v'') (labelsOut (nodeOf v'') h'')) \\<union>\n                subst_lconsts (inst v'')", "using \\<open>f = _\\<close>"], ["proof (prove)\nusing this:\n  f = labelAtOut v'' h''\n\ngoal (1 subgoal):\n 1. lconsts f\n    \\<subseteq> lconsts\n                 (freshen (vidx v'') (labelsOut (nodeOf v'') h'')) \\<union>\n                subst_lconsts (inst v'')", "by (simp add: labelAtOut_def fv_subst)"], ["proof (state)\nthis:\n  lconsts f\n  \\<subseteq> lconsts\n               (freshen (vidx v'') (labelsOut (nodeOf v'') h'')) \\<union>\n              subst_lconsts (inst v'')\n\ngoal (2 subgoals):\n 1. \\<And>v p h.\n       \\<lbrakk>(v, p) \\<in> snd ` set (((v', p'), v, p) # pth);\n        f = labelAtOut v h; h |\\<in>| hyps_for (nodeOf v) p\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}\n 2. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "ultimately"], ["proof (chain)\npicking this:\n  freshenLC (vidx v') ` local_vars (nodeOf v') ant \\<inter>\n  subst_lconsts (inst v'') =\n  {}\n  freshenLC (vidx v') ` a_fresh ant \\<inter>\n  freshenLC (vidx v'') ` lconsts (labelsOut (nodeOf v'') h'') =\n  {}\n  lconsts f\n  \\<subseteq> lconsts\n               (freshen (vidx v'') (labelsOut (nodeOf v'') h'')) \\<union>\n              subst_lconsts (inst v'')", "show ?thesis"], ["proof (prove)\nusing this:\n  freshenLC (vidx v') ` local_vars (nodeOf v') ant \\<inter>\n  subst_lconsts (inst v'') =\n  {}\n  freshenLC (vidx v') ` a_fresh ant \\<inter>\n  freshenLC (vidx v'') ` lconsts (labelsOut (nodeOf v'') h'') =\n  {}\n  lconsts f\n  \\<subseteq> lconsts\n               (freshen (vidx v'') (labelsOut (nodeOf v'') h'')) \\<union>\n              subst_lconsts (inst v'')\n\ngoal (1 subgoal):\n 1. freshenLC (vidx v') ` a_fresh ant \\<inter> lconsts f = {}", "by (fastforce simp add:  lconsts_freshen)"], ["proof (state)\nthis:\n  freshenLC (vidx v') ` a_fresh ant \\<inter> lconsts f = {}\n\ngoal (1 subgoal):\n 1. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "case (Assumption v pf)"], ["proof (state)\nthis:\n  v |\\<in>| vertices\n  nodeOf v = Assumption pf\n  f = labelAtOut v (Reg pf)\n\ngoal (1 subgoal):\n 1. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "hence \"f = subst (inst v) (freshen (vidx v) pf)\""], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n  nodeOf v = Assumption pf\n  f = labelAtOut v (Reg pf)\n\ngoal (1 subgoal):\n 1. f = subst (inst v) (freshen (vidx v) pf)", "by (simp add: labelAtOut_def)"], ["proof (state)\nthis:\n  f = subst (inst v) (freshen (vidx v) pf)\n\ngoal (1 subgoal):\n 1. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "moreover"], ["proof (state)\nthis:\n  f = subst (inst v) (freshen (vidx v) pf)\n\ngoal (1 subgoal):\n 1. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "from Assumption"], ["proof (chain)\npicking this:\n  v |\\<in>| vertices\n  nodeOf v = Assumption pf\n  f = labelAtOut v (Reg pf)", "have \"Assumption pf \\<in> sset nodes\""], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n  nodeOf v = Assumption pf\n  f = labelAtOut v (Reg pf)\n\ngoal (1 subgoal):\n 1. Assumption pf \\<in> i.R nodes", "using valid_nodes"], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n  nodeOf v = Assumption pf\n  f = labelAtOut v (Reg pf)\n  nodeOf ` fset vertices \\<subseteq> i.R nodes\n\ngoal (1 subgoal):\n 1. Assumption pf \\<in> i.R nodes", "by (auto simp add: fmember.rep_eq)"], ["proof (state)\nthis:\n  Assumption pf \\<in> i.R nodes\n\ngoal (1 subgoal):\n 1. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "hence \"pf \\<in> set assumptions\""], ["proof (prove)\nusing this:\n  Assumption pf \\<in> i.R nodes\n\ngoal (1 subgoal):\n 1. pf \\<in> set assumptions", "unfolding nodes_def"], ["proof (prove)\nusing this:\n  Assumption pf\n  \\<in> i.R (Helper ##\n             map Assumption assumptions @-\n             map Conclusion conclusions @- smap Rule rules)\n\ngoal (1 subgoal):\n 1. pf \\<in> set assumptions", "by (auto simp add: stream.set_map)"], ["proof (state)\nthis:\n  pf \\<in> set assumptions\n\ngoal (1 subgoal):\n 1. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "hence \"closed pf\""], ["proof (prove)\nusing this:\n  pf \\<in> set assumptions\n\ngoal (1 subgoal):\n 1. closed pf", "by (rule assumptions_closed)"], ["proof (state)\nthis:\n  closed pf\n\ngoal (1 subgoal):\n 1. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "ultimately"], ["proof (chain)\npicking this:\n  f = subst (inst v) (freshen (vidx v) pf)\n  closed pf", "have \"lconsts f = {}\""], ["proof (prove)\nusing this:\n  f = subst (inst v) (freshen (vidx v) pf)\n  closed pf\n\ngoal (1 subgoal):\n 1. lconsts f = {}", "by (simp add: closed_no_lconsts lconsts_freshen subst_closed freshen_closed)"], ["proof (state)\nthis:\n  lconsts f = {}\n\ngoal (1 subgoal):\n 1. \\<And>v pf.\n       \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n        f = labelAtOut v (Reg pf)\\<rbrakk>\n       \\<Longrightarrow> freshenLC (vidx v') ` a_fresh ant \\<inter>\n                         lconsts f =\n                         {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  lconsts f = {}\n\ngoal (1 subgoal):\n 1. freshenLC (vidx v') ` a_fresh ant \\<inter> lconsts f = {}", "by simp"], ["proof (state)\nthis:\n  freshenLC (vidx v') ` a_fresh ant \\<inter> lconsts f = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  freshenLC (vidx v') ` a_fresh ant \\<inter> lconsts f = {}\n\ngoal (1 subgoal):\n 1. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "fix ant"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "assume \"ant |\\<in>| f_antecedent r\""], ["proof (state)\nthis:\n  ant |\\<in>| f_antecedent r\n\ngoal (1 subgoal):\n 1. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "from  \\<open>v' |\\<in>| vertices\\<close> \\<open>ant |\\<in>| f_antecedent r\\<close>"], ["proof (chain)\npicking this:\n  v' |\\<in>| vertices\n  ant |\\<in>| f_antecedent r", "have \"valid_in_port (v',ant)\""], ["proof (prove)\nusing this:\n  v' |\\<in>| vertices\n  ant |\\<in>| f_antecedent r\n\ngoal (1 subgoal):\n 1. valid_in_port (v', ant)", "by (simp add: Rule)"], ["proof (state)\nthis:\n  valid_in_port (v', ant)\n\ngoal (1 subgoal):\n 1. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "moreover"], ["proof (state)\nthis:\n  valid_in_port (v', ant)\n\ngoal (1 subgoal):\n 1. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "note \\<open>v' |\\<in>| vertices\\<close>"], ["proof (state)\nthis:\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "moreover"], ["proof (state)\nthis:\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "hence \"v' \\<notin> scope (v', ant)\""], ["proof (prove)\nusing this:\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. v' \\<notin> scope (v', ant)", "by (rule scopes_not_refl)"], ["proof (state)\nthis:\n  v' \\<notin> scope (v', ant)\n\ngoal (1 subgoal):\n 1. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "ultimately"], ["proof (chain)\npicking this:\n  valid_in_port (v', ant)\n  v' |\\<in>| vertices\n  v' \\<notin> scope (v', ant)", "have \"freshenLC (vidx v') ` local_vars (nodeOf v') ant \\<inter> subst_lconsts (inst v') = {}\""], ["proof (prove)\nusing this:\n  valid_in_port (v', ant)\n  v' |\\<in>| vertices\n  v' \\<notin> scope (v', ant)\n\ngoal (1 subgoal):\n 1. freshenLC (vidx v') ` local_vars (nodeOf v') ant \\<inter>\n    subst_lconsts (inst v') =\n    {}", "by (rule out_of_scope)"], ["proof (state)\nthis:\n  freshenLC (vidx v') ` local_vars (nodeOf v') ant \\<inter>\n  subst_lconsts (inst v') =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>ant.\n       ant |\\<in>| f_antecedent r \\<Longrightarrow>\n       freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') =\n       {}", "thus \"freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') = {}\""], ["proof (prove)\nusing this:\n  freshenLC (vidx v') ` local_vars (nodeOf v') ant \\<inter>\n  subst_lconsts (inst v') =\n  {}\n\ngoal (1 subgoal):\n 1. freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') = {}", "by simp"], ["proof (state)\nthis:\n  freshenLC (vidx v') ` a_fresh ant \\<inter> subst_lconsts (inst v') = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eff (NatRule (r, f))\n   (hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n    subst (inst v') (freshen (vidx v') f))\n   ((\\<lambda>ant.\n        (\\<lambda>p. subst (inst v') (freshen (vidx v') p)) |`|\n        a_hyps ant |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        subst (inst v') (freshen (vidx v') (a_conc ant))) |`|\n    f_antecedent r)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "also"], ["proof (state)\nthis:\n  eff (NatRule (r, f))\n   (hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n    subst (inst v') (freshen (vidx v') f))\n   ((\\<lambda>ant.\n        (\\<lambda>p. subst (inst v') (freshen (vidx v') p)) |`|\n        a_hyps ant |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        subst (inst v') (freshen (vidx v') (a_conc ant))) |`|\n    f_antecedent r)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "have \"subst (inst v') (freshen (vidx v') f) = labelAtOut v' p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (inst v') (freshen (vidx v') f) = labelAtOut v' p'", "using Rule"], ["proof (prove)\nusing this:\n  nodeOf v' = Rule r\n  p' = Reg f\n\ngoal (1 subgoal):\n 1. subst (inst v') (freshen (vidx v') f) = labelAtOut v' p'", "by (simp add: labelAtOut_def)"], ["proof (state)\nthis:\n  subst (inst v') (freshen (vidx v') f) = labelAtOut v' p'\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "also"], ["proof (state)\nthis:\n  subst (inst v') (freshen (vidx v') f) = labelAtOut v' p'\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "note \\<open>labelAtOut v' p' = labelAtIn v p\\<close>"], ["proof (state)\nthis:\n  labelAtOut v' p' = labelAtIn v p\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "also"], ["proof (state)\nthis:\n  labelAtOut v' p' = labelAtIn v p\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "have \"?ants = ((\\<lambda>x. (extra_assms (v',x) |\\<union>| hyps_along ?pth' \\<turnstile> labelAtIn  v' x)) |`| f_antecedent r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ant.\n        (\\<lambda>p. subst (inst v') (freshen (vidx v') p)) |`|\n        a_hyps ant |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        subst (inst v') (freshen (vidx v') (a_conc ant))) |`|\n    f_antecedent r =\n    (\\<lambda>x.\n        extra_assms (v', x) |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        labelAtIn v' x) |`|\n    f_antecedent r", "by (rule fimage_cong[OF refl])\n        (auto simp add: labelAtIn_def labelAtOut_def Rule hyps_for_fimage fmember.rep_eq ffUnion.rep_eq)"], ["proof (state)\nthis:\n  (\\<lambda>ant.\n      (\\<lambda>p. subst (inst v') (freshen (vidx v') p)) |`|\n      a_hyps ant |\\<union>|\n      hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n      subst (inst v') (freshen (vidx v') (a_conc ant))) |`|\n  f_antecedent r =\n  (\\<lambda>x.\n      extra_assms (v', x) |\\<union>|\n      hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n      labelAtIn v' x) |`|\n  f_antecedent r\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "finally"], ["proof (chain)\npicking this:\n  eff (NatRule (r, f))\n   (hyps_along (((v', p'), v, p) # pth) \\<turnstile> labelAtIn v p)\n   ((\\<lambda>x.\n        extra_assms (v', x) |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        labelAtIn v' x) |`|\n    f_antecedent r)", "have \"eff (NatRule (r, f))\n        (?\\<Gamma>, labelAtIn v p)\n        ((\\<lambda>x. extra_assms (v',x) |\\<union>| ?\\<Gamma> \\<turnstile> labelAtIn v' x) |`| f_antecedent r)\""], ["proof (prove)\nusing this:\n  eff (NatRule (r, f))\n   (hyps_along (((v', p'), v, p) # pth) \\<turnstile> labelAtIn v p)\n   ((\\<lambda>x.\n        extra_assms (v', x) |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        labelAtIn v' x) |`|\n    f_antecedent r)\n\ngoal (1 subgoal):\n 1. eff (NatRule (r, f))\n     (hyps_along (((v', p'), v, p) # pth) \\<turnstile> labelAtIn v p)\n     ((\\<lambda>x.\n          extra_assms (v', x) |\\<union>|\n          hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n          labelAtIn v' x) |`|\n      f_antecedent r)", "."], ["proof (state)\nthis:\n  eff (NatRule (r, f))\n   (hyps_along (((v', p'), v, p) # pth) \\<turnstile> labelAtIn v p)\n   ((\\<lambda>x.\n        extra_assms (v', x) |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        labelAtIn v' x) |`|\n    f_antecedent r)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "}"], ["proof (state)\nthis:\n  eff (NatRule (r, f))\n   (hyps_along (((v', p'), v, p) # pth) \\<turnstile> labelAtIn v p)\n   ((\\<lambda>x.\n        extra_assms (v', x) |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        labelAtIn v' x) |`|\n    f_antecedent r)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "moreover"], ["proof (state)\nthis:\n  eff (NatRule (r, f))\n   (hyps_along (((v', p'), v, p) # pth) \\<turnstile> labelAtIn v p)\n   ((\\<lambda>x.\n        extra_assms (v', x) |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        labelAtIn v' x) |`|\n    f_antecedent r)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "{"], ["proof (state)\nthis:\n  eff (NatRule (r, f))\n   (hyps_along (((v', p'), v, p) # pth) \\<turnstile> labelAtIn v p)\n   ((\\<lambda>x.\n        extra_assms (v', x) |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        labelAtIn v' x) |`|\n    f_antecedent r)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "assume \"x |\\<in>| cont ?t\""], ["proof (state)\nthis:\n  x |\\<in>| cont (tree v p pth)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "then"], ["proof (chain)\npicking this:\n  x |\\<in>| cont (tree v p pth)", "obtain a where \"x = tree v' a ?pth'\" and \"a |\\<in>| f_antecedent r\""], ["proof (prove)\nusing this:\n  x |\\<in>| cont (tree v p pth)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>x = tree v' a (((v', p'), v, p) # pth);\n         a |\\<in>| f_antecedent r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: Rule)"], ["proof (state)\nthis:\n  x = tree v' a (((v', p'), v, p) # pth)\n  a |\\<in>| f_antecedent r\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "note this(1)"], ["proof (state)\nthis:\n  x = tree v' a (((v', p'), v, p) # pth)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "moreover"], ["proof (state)\nthis:\n  x = tree v' a (((v', p'), v, p) # pth)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "from  \\<open>v' |\\<in>| vertices\\<close> \\<open>a |\\<in>| f_antecedent r\\<close>"], ["proof (chain)\npicking this:\n  v' |\\<in>| vertices\n  a |\\<in>| f_antecedent r", "have \"valid_in_port (v',a)\""], ["proof (prove)\nusing this:\n  v' |\\<in>| vertices\n  a |\\<in>| f_antecedent r\n\ngoal (1 subgoal):\n 1. valid_in_port (v', a)", "by (simp add: Rule)"], ["proof (state)\nthis:\n  valid_in_port (v', a)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "moreover"], ["proof (state)\nthis:\n  valid_in_port (v', a)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "note \\<open>terminal_path v' t ?pth'\\<close>"], ["proof (state)\nthis:\n  terminal_path v' t (((v', p'), v, p) # pth)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "ultimately"], ["proof (chain)\npicking this:\n  x = tree v' a (((v', p'), v, p) # pth)\n  valid_in_port (v', a)\n  terminal_path v' t (((v', p'), v, p) # pth)", "have \"\\<exists>v p pth. x = tree v p pth \\<and> valid_in_port (v,p) \\<and>  terminal_path v t pth\""], ["proof (prove)\nusing this:\n  x = tree v' a (((v', p'), v, p) # pth)\n  valid_in_port (v', a)\n  terminal_path v' t (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. \\<exists>v p pth.\n       x = tree v p pth \\<and>\n       valid_in_port (v, p) \\<and> terminal_path v t pth", "by blast"], ["proof (state)\nthis:\n  \\<exists>v p pth.\n     x = tree v p pth \\<and>\n     valid_in_port (v, p) \\<and> terminal_path v t pth\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "}"], ["proof (state)\nthis:\n  ?x17 |\\<in>| cont (tree v p pth) \\<Longrightarrow>\n  \\<exists>v p pth.\n     ?x17 = tree v p pth \\<and>\n     valid_in_port (v, p) \\<and> terminal_path v t pth\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            tree v p pth = ta \\<and>\n                            snd (tree.root ta) \\<in> R \\<and>\n                            effStep (tree.root ta)\n                             ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont ta \\<longrightarrow>\n                                (\\<exists>v p pth.\n                                    x = tree v p pth \\<and>\n                                    valid_in_port (v, p) \\<and>\n                                    terminal_path v t pth) \\<or>\n                                local.wf x)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "ultimately"], ["proof (chain)\npicking this:\n  NatRule (r, f) \\<in> i.R (smap NatRule n_rules)\n  eff (NatRule (r, f))\n   (hyps_along (((v', p'), v, p) # pth) \\<turnstile> labelAtIn v p)\n   ((\\<lambda>x.\n        extra_assms (v', x) |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        labelAtIn v' x) |`|\n    f_antecedent r)\n  ?x17 |\\<in>| cont (tree v p pth) \\<Longrightarrow>\n  \\<exists>v p pth.\n     ?x17 = tree v p pth \\<and>\n     valid_in_port (v, p) \\<and> terminal_path v t pth", "show ?thesis"], ["proof (prove)\nusing this:\n  NatRule (r, f) \\<in> i.R (smap NatRule n_rules)\n  eff (NatRule (r, f))\n   (hyps_along (((v', p'), v, p) # pth) \\<turnstile> labelAtIn v p)\n   ((\\<lambda>x.\n        extra_assms (v', x) |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        labelAtIn v' x) |`|\n    f_antecedent r)\n  ?x17 |\\<in>| cont (tree v p pth) \\<Longrightarrow>\n  \\<exists>v p pth.\n     ?x17 = tree v p pth \\<and>\n     valid_in_port (v, p) \\<and> terminal_path v t pth\n\ngoal (1 subgoal):\n 1. \\<exists>ta.\n       tree v p pth = ta \\<and>\n       snd (tree.root ta) \\<in> R \\<and>\n       effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n       (\\<forall>x.\n           x |\\<in>| cont ta \\<longrightarrow>\n           (\\<exists>v p pth.\n               x = tree v p pth \\<and>\n               valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n           local.wf x)", "using Rule"], ["proof (prove)\nusing this:\n  NatRule (r, f) \\<in> i.R (smap NatRule n_rules)\n  eff (NatRule (r, f))\n   (hyps_along (((v', p'), v, p) # pth) \\<turnstile> labelAtIn v p)\n   ((\\<lambda>x.\n        extra_assms (v', x) |\\<union>|\n        hyps_along (((v', p'), v, p) # pth) \\<turnstile>\n        labelAtIn v' x) |`|\n    f_antecedent r)\n  ?x17 |\\<in>| cont (tree v p pth) \\<Longrightarrow>\n  \\<exists>v p pth.\n     ?x17 = tree v p pth \\<and>\n     valid_in_port (v, p) \\<and> terminal_path v t pth\n  nodeOf v' = Rule r\n  p' = Reg f\n\ngoal (1 subgoal):\n 1. \\<exists>ta.\n       tree v p pth = ta \\<and>\n       snd (tree.root ta) \\<in> R \\<and>\n       effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n       (\\<forall>x.\n           x |\\<in>| cont ta \\<longrightarrow>\n           (\\<exists>v p pth.\n               x = tree v p pth \\<and>\n               valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n           local.wf x)", "by (auto intro!: exI[where x = ?t]  simp add: comp_def funion_assoc)"], ["proof (state)\nthis:\n  \\<exists>ta.\n     tree v p pth = ta \\<and>\n     snd (tree.root ta) \\<in> R \\<and>\n     effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n     (\\<forall>x.\n         x |\\<in>| cont ta \\<longrightarrow>\n         (\\<exists>v p pth.\n             x = tree v p pth \\<and>\n             valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n         local.wf x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "case Helper"], ["proof (state)\nthis:\n  nodeOf v' = Helper\n  p' = Reg anyP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "from Helper"], ["proof (chain)\npicking this:\n  nodeOf v' = Helper\n  p' = Reg anyP", "have \"hyps (nodeOf v') p' = None\""], ["proof (prove)\nusing this:\n  nodeOf v' = Helper\n  p' = Reg anyP\n\ngoal (1 subgoal):\n 1. hyps (nodeOf v') p' = None", "by simp"], ["proof (state)\nthis:\n  hyps (nodeOf v') p' = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "with e \\<open>terminal_path v t pth\\<close>"], ["proof (chain)\npicking this:\n  ((v', p'), v, p) \\<in> edges\n  terminal_path v t pth\n  hyps (nodeOf v') p' = None", "have \"terminal_path v' t ?pth'\""], ["proof (prove)\nusing this:\n  ((v', p'), v, p) \\<in> edges\n  terminal_path v t pth\n  hyps (nodeOf v') p' = None\n\ngoal (1 subgoal):\n 1. terminal_path v' t (((v', p'), v, p) # pth)", ".."], ["proof (state)\nthis:\n  terminal_path v' t (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "have \"labelAtIn v' (plain_ant anyP) = labelAtIn v p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. labelAtIn v' (plain_ant anyP) = labelAtIn v p", "unfolding s[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. labelAtIn v' (plain_ant anyP) = labelAtOut v' p'", "using Helper"], ["proof (prove)\nusing this:\n  nodeOf v' = Helper\n  p' = Reg anyP\n\ngoal (1 subgoal):\n 1. labelAtIn v' (plain_ant anyP) = labelAtOut v' p'", "by (simp add: labelAtIn_def labelAtOut_def)"], ["proof (state)\nthis:\n  labelAtIn v' (plain_ant anyP) = labelAtIn v p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "moreover"], ["proof (state)\nthis:\n  labelAtIn v' (plain_ant anyP) = labelAtIn v p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "{"], ["proof (state)\nthis:\n  labelAtIn v' (plain_ant anyP) = labelAtIn v p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "assume \"x |\\<in>| cont ?t\""], ["proof (state)\nthis:\n  x |\\<in>| cont (tree v p pth)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "hence \"x = tree v' (plain_ant anyP) ?pth'\""], ["proof (prove)\nusing this:\n  x |\\<in>| cont (tree v p pth)\n\ngoal (1 subgoal):\n 1. x = tree v' (plain_ant anyP) (((v', p'), v, p) # pth)", "by (auto simp add: Helper)"], ["proof (state)\nthis:\n  x = tree v' (plain_ant anyP) (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "note this(1)"], ["proof (state)\nthis:\n  x = tree v' (plain_ant anyP) (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "moreover"], ["proof (state)\nthis:\n  x = tree v' (plain_ant anyP) (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "from  \\<open>v' |\\<in>| vertices\\<close>"], ["proof (chain)\npicking this:\n  v' |\\<in>| vertices", "have \"valid_in_port (v',plain_ant anyP)\""], ["proof (prove)\nusing this:\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. valid_in_port (v', plain_ant anyP)", "by (simp add: Helper)"], ["proof (state)\nthis:\n  valid_in_port (v', plain_ant anyP)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "moreover"], ["proof (state)\nthis:\n  valid_in_port (v', plain_ant anyP)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "note \\<open>terminal_path v' t ?pth'\\<close>"], ["proof (state)\nthis:\n  terminal_path v' t (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "ultimately"], ["proof (chain)\npicking this:\n  x = tree v' (plain_ant anyP) (((v', p'), v, p) # pth)\n  valid_in_port (v', plain_ant anyP)\n  terminal_path v' t (((v', p'), v, p) # pth)", "have \"\\<exists>v p pth. x = tree v p pth \\<and> valid_in_port (v,p) \\<and>  terminal_path v t pth\""], ["proof (prove)\nusing this:\n  x = tree v' (plain_ant anyP) (((v', p'), v, p) # pth)\n  valid_in_port (v', plain_ant anyP)\n  terminal_path v' t (((v', p'), v, p) # pth)\n\ngoal (1 subgoal):\n 1. \\<exists>v p pth.\n       x = tree v p pth \\<and>\n       valid_in_port (v, p) \\<and> terminal_path v t pth", "by blast"], ["proof (state)\nthis:\n  \\<exists>v p pth.\n     x = tree v p pth \\<and>\n     valid_in_port (v, p) \\<and> terminal_path v t pth\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "}"], ["proof (state)\nthis:\n  ?x17 |\\<in>| cont (tree v p pth) \\<Longrightarrow>\n  \\<exists>v p pth.\n     ?x17 = tree v p pth \\<and>\n     valid_in_port (v, p) \\<and> terminal_path v t pth\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ta.\n                         tree v p pth = ta \\<and>\n                         snd (tree.root ta) \\<in> R \\<and>\n                         effStep (tree.root ta)\n                          ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n                         (\\<forall>x.\n                             x |\\<in>| cont ta \\<longrightarrow>\n                             (\\<exists>v p pth.\n                                 x = tree v p pth \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 terminal_path v t pth) \\<or>\n                             local.wf x)", "ultimately"], ["proof (chain)\npicking this:\n  labelAtIn v' (plain_ant anyP) = labelAtIn v p\n  ?x17 |\\<in>| cont (tree v p pth) \\<Longrightarrow>\n  \\<exists>v p pth.\n     ?x17 = tree v p pth \\<and>\n     valid_in_port (v, p) \\<and> terminal_path v t pth", "show ?thesis"], ["proof (prove)\nusing this:\n  labelAtIn v' (plain_ant anyP) = labelAtIn v p\n  ?x17 |\\<in>| cont (tree v p pth) \\<Longrightarrow>\n  \\<exists>v p pth.\n     ?x17 = tree v p pth \\<and>\n     valid_in_port (v, p) \\<and> terminal_path v t pth\n\ngoal (1 subgoal):\n 1. \\<exists>ta.\n       tree v p pth = ta \\<and>\n       snd (tree.root ta) \\<in> R \\<and>\n       effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n       (\\<forall>x.\n           x |\\<in>| cont ta \\<longrightarrow>\n           (\\<exists>v p pth.\n               x = tree v p pth \\<and>\n               valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n           local.wf x)", "using Helper"], ["proof (prove)\nusing this:\n  labelAtIn v' (plain_ant anyP) = labelAtIn v p\n  ?x17 |\\<in>| cont (tree v p pth) \\<Longrightarrow>\n  \\<exists>v p pth.\n     ?x17 = tree v p pth \\<and>\n     valid_in_port (v, p) \\<and> terminal_path v t pth\n  nodeOf v' = Helper\n  p' = Reg anyP\n\ngoal (1 subgoal):\n 1. \\<exists>ta.\n       tree v p pth = ta \\<and>\n       snd (tree.root ta) \\<in> R \\<and>\n       effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n       (\\<forall>x.\n           x |\\<in>| cont ta \\<longrightarrow>\n           (\\<exists>v p pth.\n               x = tree v p pth \\<and>\n               valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n           local.wf x)", "by (auto intro!: exI[where x = ?t]  simp add: comp_def funion_assoc )"], ["proof (state)\nthis:\n  \\<exists>ta.\n     tree v p pth = ta \\<and>\n     snd (tree.root ta) \\<in> R \\<and>\n     effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n     (\\<forall>x.\n         x |\\<in>| cont ta \\<longrightarrow>\n         (\\<exists>v p pth.\n             x = tree v p pth \\<and>\n             valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n         local.wf x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ta.\n     tree v p pth = ta \\<and>\n     snd (tree.root ta) \\<in> R \\<and>\n     effStep (tree.root ta) ((fst \\<circ> tree.root) |`| cont ta) \\<and>\n     (\\<forall>x.\n         x |\\<in>| cont ta \\<longrightarrow>\n         (\\<exists>v p pth.\n             x = tree v p pth \\<and>\n             valid_in_port (v, p) \\<and> terminal_path v t pth) \\<or>\n         local.wf x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma global_in_ass: \"global_assms TYPE('var) |\\<subseteq>| ass_forms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. global_assms TYPE('var) |\\<subseteq>| ass_forms", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| global_assms TYPE('var) \\<Longrightarrow>\n       x |\\<in>| ass_forms", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| global_assms TYPE('var) \\<Longrightarrow>\n       x |\\<in>| ass_forms", "assume \"x |\\<in>| global_assms TYPE('var)\""], ["proof (state)\nthis:\n  x |\\<in>| global_assms TYPE('var)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| global_assms TYPE('var) \\<Longrightarrow>\n       x |\\<in>| ass_forms", "then"], ["proof (chain)\npicking this:\n  x |\\<in>| global_assms TYPE('var)", "obtain v pf where \"v |\\<in>| vertices\" and \"nodeOf v = Assumption pf\" and \"x = labelAtOut v (Reg pf)\""], ["proof (prove)\nusing this:\n  x |\\<in>| global_assms TYPE('var)\n\ngoal (1 subgoal):\n 1. (\\<And>v pf.\n        \\<lbrakk>v |\\<in>| vertices; nodeOf v = Assumption pf;\n         x = labelAtOut v (Reg pf)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: global_assms_simps)"], ["proof (state)\nthis:\n  v |\\<in>| vertices\n  nodeOf v = Assumption pf\n  x = labelAtOut v (Reg pf)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| global_assms TYPE('var) \\<Longrightarrow>\n       x |\\<in>| ass_forms", "from this (1,2) valid_nodes"], ["proof (chain)\npicking this:\n  v |\\<in>| vertices\n  nodeOf v = Assumption pf\n  nodeOf ` fset vertices \\<subseteq> i.R nodes", "have \"Assumption pf \\<in> sset nodes\""], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n  nodeOf v = Assumption pf\n  nodeOf ` fset vertices \\<subseteq> i.R nodes\n\ngoal (1 subgoal):\n 1. Assumption pf \\<in> i.R nodes", "by (auto simp add: fmember.rep_eq)"], ["proof (state)\nthis:\n  Assumption pf \\<in> i.R nodes\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| global_assms TYPE('var) \\<Longrightarrow>\n       x |\\<in>| ass_forms", "hence \"pf \\<in> set assumptions\""], ["proof (prove)\nusing this:\n  Assumption pf \\<in> i.R nodes\n\ngoal (1 subgoal):\n 1. pf \\<in> set assumptions", "by (auto simp add: nodes_def stream.set_map)"], ["proof (state)\nthis:\n  pf \\<in> set assumptions\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| global_assms TYPE('var) \\<Longrightarrow>\n       x |\\<in>| ass_forms", "hence \"closed pf\""], ["proof (prove)\nusing this:\n  pf \\<in> set assumptions\n\ngoal (1 subgoal):\n 1. closed pf", "by (rule  assumptions_closed)"], ["proof (state)\nthis:\n  closed pf\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| global_assms TYPE('var) \\<Longrightarrow>\n       x |\\<in>| ass_forms", "with \\<open>x = labelAtOut v (Reg pf)\\<close>"], ["proof (chain)\npicking this:\n  x = labelAtOut v (Reg pf)\n  closed pf", "have \"x = pf\""], ["proof (prove)\nusing this:\n  x = labelAtOut v (Reg pf)\n  closed pf\n\ngoal (1 subgoal):\n 1. x = pf", "by (auto simp add: labelAtOut_def lconsts_freshen closed_no_lconsts freshen_closed subst_closed)"], ["proof (state)\nthis:\n  x = pf\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| global_assms TYPE('var) \\<Longrightarrow>\n       x |\\<in>| ass_forms", "thus \"x |\\<in>| ass_forms\""], ["proof (prove)\nusing this:\n  x = pf\n\ngoal (1 subgoal):\n 1. x |\\<in>| ass_forms", "using \\<open>pf \\<in> set assumptions\\<close>"], ["proof (prove)\nusing this:\n  x = pf\n  pf \\<in> set assumptions\n\ngoal (1 subgoal):\n 1. x |\\<in>| ass_forms", "by (auto simp add: ass_forms_def)"], ["proof (state)\nthis:\n  x |\\<in>| ass_forms\n\ngoal:\nNo subgoals!", "qed"], ["", "primcorec edge_tree :: \"'vertex \\<Rightarrow> ('form, 'var) in_port \\<Rightarrow> ('vertex, 'form, 'var) edge' tree\" where\n \"root (edge_tree v p) = (adjacentTo v p, (v,p))\"\n | \"cont (edge_tree v p) =\n    (case adjacentTo v p of (v', p') \\<Rightarrow>\n    (if isReg v' p' then ((\\<lambda> p. edge_tree  v' p) |`| inPorts (nodeOf v')) else {||}\n    ))\""], ["", "lemma tfinite_map_tree: \"tfinite (map_tree f t) \\<longleftrightarrow> tfinite t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfinite (map_tree f t) = tfinite t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. tfinite (map_tree f t) \\<Longrightarrow> tfinite t\n 2. tfinite t \\<Longrightarrow> tfinite (map_tree f t)", "assume \"tfinite (map_tree f t)\""], ["proof (state)\nthis:\n  tfinite (map_tree f t)\n\ngoal (2 subgoals):\n 1. tfinite (map_tree f t) \\<Longrightarrow> tfinite t\n 2. tfinite t \\<Longrightarrow> tfinite (map_tree f t)", "thus \"tfinite t\""], ["proof (prove)\nusing this:\n  tfinite (map_tree f t)\n\ngoal (1 subgoal):\n 1. tfinite t", "by (induction \"map_tree f t\" arbitrary: t rule: tfinite.induct)\n       (fastforce intro:  tfinite.intros simp add:  tree.map_sel)"], ["proof (state)\nthis:\n  tfinite t\n\ngoal (1 subgoal):\n 1. tfinite t \\<Longrightarrow> tfinite (map_tree f t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tfinite t \\<Longrightarrow> tfinite (map_tree f t)", "assume \"tfinite t\""], ["proof (state)\nthis:\n  tfinite t\n\ngoal (1 subgoal):\n 1. tfinite t \\<Longrightarrow> tfinite (map_tree f t)", "thus \"tfinite (map_tree f t)\""], ["proof (prove)\nusing this:\n  tfinite t\n\ngoal (1 subgoal):\n 1. tfinite (map_tree f t)", "by (induction t rule: tfinite.induct)\n       (fastforce intro:  tfinite.intros simp add:  tree.map_sel)"], ["proof (state)\nthis:\n  tfinite (map_tree f t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_tree_edge_tree:\n  \"tfinite (tree v p pth) \\<longleftrightarrow> tfinite (edge_tree v p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfinite (tree v p pth) = tfinite (edge_tree v p)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. tfinite (tree v p pth) = tfinite (edge_tree v p)", "have \"map_tree (\\<lambda> _. ())  (tree v p pth) = map_tree (\\<lambda> _. ()) (edge_tree v p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_tree (\\<lambda>_. ()) (tree v p pth) =\n    map_tree (\\<lambda>_. ()) (edge_tree v p)", "by(coinduction arbitrary: v p pth)\n     (fastforce simp add: tree.map_sel rel_fset_def rel_set_def split: prod.split out_port.split graph_node.split option.split)"], ["proof (state)\nthis:\n  map_tree (\\<lambda>_. ()) (tree v p pth) =\n  map_tree (\\<lambda>_. ()) (edge_tree v p)\n\ngoal (1 subgoal):\n 1. tfinite (tree v p pth) = tfinite (edge_tree v p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_tree (\\<lambda>_. ()) (tree v p pth) =\n  map_tree (\\<lambda>_. ()) (edge_tree v p)\n\ngoal (1 subgoal):\n 1. tfinite (tree v p pth) = tfinite (edge_tree v p)", "by (metis tfinite_map_tree)"], ["proof (state)\nthis:\n  tfinite (tree v p pth) = tfinite (edge_tree v p)\n\ngoal:\nNo subgoals!", "qed"], ["", "coinductive forbidden_path :: \"'vertex \\<Rightarrow> ('vertex, 'form, 'var) edge' stream \\<Rightarrow> bool\"   where\n    forbidden_path: \"((v\\<^sub>1,p\\<^sub>1),(v\\<^sub>2,p\\<^sub>2)) \\<in> edges \\<Longrightarrow> hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<Longrightarrow> forbidden_path v\\<^sub>1 pth \\<Longrightarrow> forbidden_path v\\<^sub>2 (((v\\<^sub>1,p\\<^sub>1),(v\\<^sub>2,p\\<^sub>2))##pth)\""], ["", "lemma path_is_forbidden:\n  assumes \"valid_in_port (v,p)\"\n  assumes \"ipath (edge_tree v p) es\"\n  shows \"forbidden_path v es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forbidden_path v es", "using assms"], ["proof (prove)\nusing this:\n  valid_in_port (v, p)\n  ipath (edge_tree v p) es\n\ngoal (1 subgoal):\n 1. forbidden_path v es", "proof(coinduction arbitrary: v p es)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p es.\n       \\<lbrakk>valid_in_port (v, p); ipath (edge_tree v p) es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)", "case forbidden_path"], ["proof (state)\nthis:\n  valid_in_port (v, p)\n  ipath (edge_tree v p) es\n\ngoal (1 subgoal):\n 1. \\<And>v p es.\n       \\<lbrakk>valid_in_port (v, p); ipath (edge_tree v p) es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)", "let ?es' = \"stl es\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p es.\n       \\<lbrakk>valid_in_port (v, p); ipath (edge_tree v p) es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)", "from forbidden_path(2)"], ["proof (chain)\npicking this:\n  ipath (edge_tree v p) es", "obtain t' where \"root (edge_tree v p) = shd es\" and \"t' |\\<in>| cont (edge_tree v p)\" and \"ipath t' ?es'\""], ["proof (prove)\nusing this:\n  ipath (edge_tree v p) es\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>tree.root (edge_tree v p) = shd es;\n         t' |\\<in>| cont (edge_tree v p); ipath t' (stl es)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by rule blast"], ["proof (state)\nthis:\n  tree.root (edge_tree v p) = shd es\n  t' |\\<in>| cont (edge_tree v p)\n  ipath t' (stl es)\n\ngoal (1 subgoal):\n 1. \\<And>v p es.\n       \\<lbrakk>valid_in_port (v, p); ipath (edge_tree v p) es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)", "from \\<open>root (edge_tree v p) = shd es\\<close>"], ["proof (chain)\npicking this:\n  tree.root (edge_tree v p) = shd es", "have [simp]: \"shd es = (adjacentTo v p, (v,p))\""], ["proof (prove)\nusing this:\n  tree.root (edge_tree v p) = shd es\n\ngoal (1 subgoal):\n 1. shd es = (adjacentTo v p, v, p)", "by simp"], ["proof (state)\nthis:\n  shd es = (adjacentTo v p, v, p)\n\ngoal (1 subgoal):\n 1. \\<And>v p es.\n       \\<lbrakk>valid_in_port (v, p); ipath (edge_tree v p) es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)", "from saturated[OF \\<open>valid_in_port (v,p)\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>e\\<in>edges. snd e = (v, p)", "obtain v' p'\n  where e:\"((v',p'),(v,p)) \\<in> edges\" and [simp]: \"adjacentTo v p = (v',p')\""], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>edges. snd e = (v, p)\n\ngoal (1 subgoal):\n 1. (\\<And>v' p'.\n        \\<lbrakk>((v', p'), v, p) \\<in> edges;\n         adjacentTo v p = (v', p')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: adjacentTo_def, metis (no_types, lifting) eq_fst_iff tfl_some)"], ["proof (state)\nthis:\n  ((v', p'), v, p) \\<in> edges\n  adjacentTo v p = (v', p')\n\ngoal (1 subgoal):\n 1. \\<And>v p es.\n       \\<lbrakk>valid_in_port (v, p); ipath (edge_tree v p) es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)", "let ?e = \"((v',p'),(v,p))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p es.\n       \\<lbrakk>valid_in_port (v, p); ipath (edge_tree v p) es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)", "from e"], ["proof (chain)\npicking this:\n  ((v', p'), v, p) \\<in> edges", "have \"p' |\\<in>| outPorts (nodeOf v')\""], ["proof (prove)\nusing this:\n  ((v', p'), v, p) \\<in> edges\n\ngoal (1 subgoal):\n 1. p' |\\<in>| outPorts (nodeOf v')", "using valid_edges"], ["proof (prove)\nusing this:\n  ((v', p'), v, p) \\<in> edges\n  \\<forall>(ps1, ps2)\\<in>edges. valid_out_port ps1 \\<and> valid_in_port ps2\n\ngoal (1 subgoal):\n 1. p' |\\<in>| outPorts (nodeOf v')", "by auto"], ["proof (state)\nthis:\n  p' |\\<in>| outPorts (nodeOf v')\n\ngoal (1 subgoal):\n 1. \\<And>v p es.\n       \\<lbrakk>valid_in_port (v, p); ipath (edge_tree v p) es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)", "thus ?case"], ["proof (prove)\nusing this:\n  p' |\\<in>| outPorts (nodeOf v')\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n       v = v\\<^sub>2 \\<and>\n       es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n       ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n       hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n       ((\\<exists>v p es.\n            v\\<^sub>1 = v \\<and>\n            pth = es \\<and>\n            valid_in_port (v, p) \\<and> ipath (edge_tree v p) es) \\<or>\n        forbidden_path v\\<^sub>1 pth)", "proof(cases rule: out_port_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "case Hyp"], ["proof (state)\nthis:\n  nodeOf v' = Rule r_\n  p' = Hyp h_ c_\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "with  \\<open>t' |\\<in>| cont (edge_tree v p)\\<close>"], ["proof (chain)\npicking this:\n  t' |\\<in>| cont (edge_tree v p)\n  nodeOf v' = Rule r_\n  p' = Hyp h_ c_", "have False"], ["proof (prove)\nusing this:\n  t' |\\<in>| cont (edge_tree v p)\n  nodeOf v' = Rule r_\n  p' = Hyp h_ c_\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<And>r h c.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Hyp h c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 3. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 4. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n       v = v\\<^sub>2 \\<and>\n       es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n       ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n       hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n       ((\\<exists>v p es.\n            v\\<^sub>1 = v \\<and>\n            pth = es \\<and>\n            valid_in_port (v, p) \\<and> ipath (edge_tree v p) es) \\<or>\n        forbidden_path v\\<^sub>1 pth)", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n     v = v\\<^sub>2 \\<and>\n     es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n     ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n     hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n     ((\\<exists>v p es.\n          v\\<^sub>1 = v \\<and>\n          pth = es \\<and>\n          valid_in_port (v, p) \\<and> ipath (edge_tree v p) es) \\<or>\n      forbidden_path v\\<^sub>1 pth)\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 3. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 3. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "case Assumption"], ["proof (state)\nthis:\n  nodeOf v' = Assumption a_\n  p' = Reg a_\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 3. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "with  \\<open>t' |\\<in>| cont (edge_tree v p)\\<close>"], ["proof (chain)\npicking this:\n  t' |\\<in>| cont (edge_tree v p)\n  nodeOf v' = Assumption a_\n  p' = Reg a_", "have False"], ["proof (prove)\nusing this:\n  t' |\\<in>| cont (edge_tree v p)\n  nodeOf v' = Assumption a_\n  p' = Reg a_\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nodeOf v' = Assumption a; p' = Reg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 3. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n       v = v\\<^sub>2 \\<and>\n       es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n       ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n       hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n       ((\\<exists>v p es.\n            v\\<^sub>1 = v \\<and>\n            pth = es \\<and>\n            valid_in_port (v, p) \\<and> ipath (edge_tree v p) es) \\<or>\n        forbidden_path v\\<^sub>1 pth)", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n     v = v\\<^sub>2 \\<and>\n     es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n     ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n     hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n     ((\\<exists>v p es.\n          v\\<^sub>1 = v \\<and>\n          pth = es \\<and>\n          valid_in_port (v, p) \\<and> ipath (edge_tree v p) es) \\<or>\n      forbidden_path v\\<^sub>1 pth)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "case (Rule r f)"], ["proof (state)\nthis:\n  nodeOf v' = Rule r\n  p' = Reg f\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "from \\<open>t' |\\<in>| cont (edge_tree v p)\\<close> Rule"], ["proof (chain)\npicking this:\n  t' |\\<in>| cont (edge_tree v p)\n  nodeOf v' = Rule r\n  p' = Reg f", "obtain a where [simp]: \"t' = edge_tree v' a\" and \"a |\\<in>| f_antecedent r\""], ["proof (prove)\nusing this:\n  t' |\\<in>| cont (edge_tree v p)\n  nodeOf v' = Rule r\n  p' = Reg f\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>t' = edge_tree v' a; a |\\<in>| f_antecedent r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t' = edge_tree v' a\n  a |\\<in>| f_antecedent r\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "have \"es = ?e ## ?es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. es = ((v', p'), v, p) ## stl es", "by (cases es rule: stream.exhaust_sel) simp"], ["proof (state)\nthis:\n  es = ((v', p'), v, p) ## stl es\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "moreover"], ["proof (state)\nthis:\n  es = ((v', p'), v, p) ## stl es\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "have \"?e \\<in> edges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v', p'), v, p) \\<in> edges", "using e"], ["proof (prove)\nusing this:\n  ((v', p'), v, p) \\<in> edges\n\ngoal (1 subgoal):\n 1. ((v', p'), v, p) \\<in> edges", "by simp"], ["proof (state)\nthis:\n  ((v', p'), v, p) \\<in> edges\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "moreover"], ["proof (state)\nthis:\n  ((v', p'), v, p) \\<in> edges\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "from \\<open>p' = Reg f\\<close> \\<open>nodeOf v' = Rule r\\<close>"], ["proof (chain)\npicking this:\n  p' = Reg f\n  nodeOf v' = Rule r", "have \"hyps (nodeOf v') p' = None\""], ["proof (prove)\nusing this:\n  p' = Reg f\n  nodeOf v' = Rule r\n\ngoal (1 subgoal):\n 1. hyps (nodeOf v') p' = None", "by simp"], ["proof (state)\nthis:\n  hyps (nodeOf v') p' = None\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "moreover"], ["proof (state)\nthis:\n  hyps (nodeOf v') p' = None\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "from e valid_edges"], ["proof (chain)\npicking this:\n  ((v', p'), v, p) \\<in> edges\n  \\<forall>(ps1, ps2)\\<in>edges. valid_out_port ps1 \\<and> valid_in_port ps2", "have \"v' |\\<in>| vertices\""], ["proof (prove)\nusing this:\n  ((v', p'), v, p) \\<in> edges\n  \\<forall>(ps1, ps2)\\<in>edges. valid_out_port ps1 \\<and> valid_in_port ps2\n\ngoal (1 subgoal):\n 1. v' |\\<in>| vertices", "by auto"], ["proof (state)\nthis:\n  v' |\\<in>| vertices\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "with \\<open>nodeOf v' = Rule r\\<close> \\<open>a |\\<in>| f_antecedent r\\<close>"], ["proof (chain)\npicking this:\n  nodeOf v' = Rule r\n  a |\\<in>| f_antecedent r\n  v' |\\<in>| vertices", "have \"valid_in_port (v', a)\""], ["proof (prove)\nusing this:\n  nodeOf v' = Rule r\n  a |\\<in>| f_antecedent r\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. valid_in_port (v', a)", "by simp"], ["proof (state)\nthis:\n  valid_in_port (v', a)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "moreover"], ["proof (state)\nthis:\n  valid_in_port (v', a)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "have \"ipath (edge_tree v' a) ?es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath (edge_tree v' a) (stl es)", "using \\<open>ipath t' _\\<close>"], ["proof (prove)\nusing this:\n  ipath t' (stl es)\n\ngoal (1 subgoal):\n 1. ipath (edge_tree v' a) (stl es)", "by simp"], ["proof (state)\nthis:\n  ipath (edge_tree v' a) (stl es)\n\ngoal (2 subgoals):\n 1. \\<And>r f.\n       \\<lbrakk>nodeOf v' = Rule r; p' = Reg f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2\n                            pth.\n                            v = v\\<^sub>2 \\<and>\n                            es =\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2,\n                             p\\<^sub>2) ##\n                            pth \\<and>\n                            ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                            \\<in> edges \\<and>\n                            hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                            ((\\<exists>v p es.\n                                 v\\<^sub>1 = v \\<and>\n                                 pth = es \\<and>\n                                 valid_in_port (v, p) \\<and>\n                                 ipath (edge_tree v p) es) \\<or>\n                             forbidden_path v\\<^sub>1 pth)\n 2. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "ultimately"], ["proof (chain)\npicking this:\n  es = ((v', p'), v, p) ## stl es\n  ((v', p'), v, p) \\<in> edges\n  hyps (nodeOf v') p' = None\n  valid_in_port (v', a)\n  ipath (edge_tree v' a) (stl es)", "show ?thesis"], ["proof (prove)\nusing this:\n  es = ((v', p'), v, p) ## stl es\n  ((v', p'), v, p) \\<in> edges\n  hyps (nodeOf v') p' = None\n  valid_in_port (v', a)\n  ipath (edge_tree v' a) (stl es)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n       v = v\\<^sub>2 \\<and>\n       es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n       ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n       hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n       ((\\<exists>v p es.\n            v\\<^sub>1 = v \\<and>\n            pth = es \\<and>\n            valid_in_port (v, p) \\<and> ipath (edge_tree v p) es) \\<or>\n        forbidden_path v\\<^sub>1 pth)", "by metis"], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n     v = v\\<^sub>2 \\<and>\n     es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n     ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n     hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n     ((\\<exists>v p es.\n          v\\<^sub>1 = v \\<and>\n          pth = es \\<and>\n          valid_in_port (v, p) \\<and> ipath (edge_tree v p) es) \\<or>\n      forbidden_path v\\<^sub>1 pth)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "case Helper"], ["proof (state)\nthis:\n  nodeOf v' = Helper\n  p' = Reg anyP\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "from \\<open>t' |\\<in>| cont (edge_tree v p)\\<close> Helper"], ["proof (chain)\npicking this:\n  t' |\\<in>| cont (edge_tree v p)\n  nodeOf v' = Helper\n  p' = Reg anyP", "have [simp]: \"t' = edge_tree v' (plain_ant anyP)\""], ["proof (prove)\nusing this:\n  t' |\\<in>| cont (edge_tree v p)\n  nodeOf v' = Helper\n  p' = Reg anyP\n\ngoal (1 subgoal):\n 1. t' = edge_tree v' (plain_ant anyP)", "by simp"], ["proof (state)\nthis:\n  t' = edge_tree v' (plain_ant anyP)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "have \"es = ?e ## ?es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. es = ((v', p'), v, p) ## stl es", "by (cases es rule: stream.exhaust_sel) simp"], ["proof (state)\nthis:\n  es = ((v', p'), v, p) ## stl es\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "moreover"], ["proof (state)\nthis:\n  es = ((v', p'), v, p) ## stl es\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "have \"?e \\<in> edges\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v', p'), v, p) \\<in> edges", "using e"], ["proof (prove)\nusing this:\n  ((v', p'), v, p) \\<in> edges\n\ngoal (1 subgoal):\n 1. ((v', p'), v, p) \\<in> edges", "by simp"], ["proof (state)\nthis:\n  ((v', p'), v, p) \\<in> edges\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "moreover"], ["proof (state)\nthis:\n  ((v', p'), v, p) \\<in> edges\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "from \\<open>p' = Reg anyP\\<close> \\<open>nodeOf v' = Helper\\<close>"], ["proof (chain)\npicking this:\n  p' = Reg anyP\n  nodeOf v' = Helper", "have \"hyps (nodeOf v') p' = None\""], ["proof (prove)\nusing this:\n  p' = Reg anyP\n  nodeOf v' = Helper\n\ngoal (1 subgoal):\n 1. hyps (nodeOf v') p' = None", "by simp"], ["proof (state)\nthis:\n  hyps (nodeOf v') p' = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "moreover"], ["proof (state)\nthis:\n  hyps (nodeOf v') p' = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "from e valid_edges"], ["proof (chain)\npicking this:\n  ((v', p'), v, p) \\<in> edges\n  \\<forall>(ps1, ps2)\\<in>edges. valid_out_port ps1 \\<and> valid_in_port ps2", "have \"v' |\\<in>| vertices\""], ["proof (prove)\nusing this:\n  ((v', p'), v, p) \\<in> edges\n  \\<forall>(ps1, ps2)\\<in>edges. valid_out_port ps1 \\<and> valid_in_port ps2\n\ngoal (1 subgoal):\n 1. v' |\\<in>| vertices", "by auto"], ["proof (state)\nthis:\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "with \\<open>nodeOf v' = Helper\\<close>"], ["proof (chain)\npicking this:\n  nodeOf v' = Helper\n  v' |\\<in>| vertices", "have \"valid_in_port (v', plain_ant anyP)\""], ["proof (prove)\nusing this:\n  nodeOf v' = Helper\n  v' |\\<in>| vertices\n\ngoal (1 subgoal):\n 1. valid_in_port (v', plain_ant anyP)", "by simp"], ["proof (state)\nthis:\n  valid_in_port (v', plain_ant anyP)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "moreover"], ["proof (state)\nthis:\n  valid_in_port (v', plain_ant anyP)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "have \"ipath (edge_tree v' (plain_ant anyP)) ?es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath (edge_tree v' (plain_ant anyP)) (stl es)", "using \\<open>ipath t' _\\<close>"], ["proof (prove)\nusing this:\n  ipath t' (stl es)\n\ngoal (1 subgoal):\n 1. ipath (edge_tree v' (plain_ant anyP)) (stl es)", "by simp"], ["proof (state)\nthis:\n  ipath (edge_tree v' (plain_ant anyP)) (stl es)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nodeOf v' = Helper; p' = Reg anyP\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n                         v = v\\<^sub>2 \\<and>\n                         es =\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ##\n                         pth \\<and>\n                         ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2)\n                         \\<in> edges \\<and>\n                         hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n                         ((\\<exists>v p es.\n                              v\\<^sub>1 = v \\<and>\n                              pth = es \\<and>\n                              valid_in_port (v, p) \\<and>\n                              ipath (edge_tree v p) es) \\<or>\n                          forbidden_path v\\<^sub>1 pth)", "ultimately"], ["proof (chain)\npicking this:\n  es = ((v', p'), v, p) ## stl es\n  ((v', p'), v, p) \\<in> edges\n  hyps (nodeOf v') p' = None\n  valid_in_port (v', plain_ant anyP)\n  ipath (edge_tree v' (plain_ant anyP)) (stl es)", "show ?thesis"], ["proof (prove)\nusing this:\n  es = ((v', p'), v, p) ## stl es\n  ((v', p'), v, p) \\<in> edges\n  hyps (nodeOf v') p' = None\n  valid_in_port (v', plain_ant anyP)\n  ipath (edge_tree v' (plain_ant anyP)) (stl es)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n       v = v\\<^sub>2 \\<and>\n       es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n       ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n       hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n       ((\\<exists>v p es.\n            v\\<^sub>1 = v \\<and>\n            pth = es \\<and>\n            valid_in_port (v, p) \\<and> ipath (edge_tree v p) es) \\<or>\n        forbidden_path v\\<^sub>1 pth)", "by metis"], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n     v = v\\<^sub>2 \\<and>\n     es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n     ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n     hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n     ((\\<exists>v p es.\n          v\\<^sub>1 = v \\<and>\n          pth = es \\<and>\n          valid_in_port (v, p) \\<and> ipath (edge_tree v p) es) \\<or>\n      forbidden_path v\\<^sub>1 pth)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n     v = v\\<^sub>2 \\<and>\n     es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n     ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n     hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n     ((\\<exists>v p es.\n          v\\<^sub>1 = v \\<and>\n          pth = es \\<and>\n          valid_in_port (v, p) \\<and> ipath (edge_tree v p) es) \\<or>\n      forbidden_path v\\<^sub>1 pth)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma forbidden_path_prefix_is_path:\n  assumes \"forbidden_path v es\"\n  obtains v' where  \"path v' v (rev (stake n es))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        path v' v (rev (stake n es)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  forbidden_path v es\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        path v' v (rev (stake n es)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (atomize_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. forbidden_path v es \\<Longrightarrow>\n    \\<exists>v'. path v' v (rev (stake n es))", "apply (induction n arbitrary: v es)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v es.\n       forbidden_path v es \\<Longrightarrow>\n       \\<exists>v'. path v' v (rev (stake 0 es))\n 2. \\<And>n v es.\n       \\<lbrakk>\\<And>v es.\n                   forbidden_path v es \\<Longrightarrow>\n                   \\<exists>v'. path v' v (rev (stake n es));\n        forbidden_path v es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'. path v' v (rev (stake (Suc n) es))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n v es.\n       \\<lbrakk>\\<And>v es.\n                   forbidden_path v es \\<Longrightarrow>\n                   \\<exists>v'. path v' v (rev (stake n es));\n        forbidden_path v es\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'. path v' v (rev (stake (Suc n) es))", "apply (simp add: path_snoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n v es.\n       \\<lbrakk>\\<And>v es.\n                   forbidden_path v es \\<Longrightarrow>\n                   \\<exists>v'. path v' v (rev (stake n es));\n        forbidden_path v es\\<rbrakk>\n       \\<Longrightarrow> shd es \\<in> edges \\<and>\n                         (\\<exists>v'.\n                             path v' (edge_begin (shd es))\n                              (rev (stake n (stl es)))) \\<and>\n                         edge_end (shd es) = v", "apply (subst (asm) (2) forbidden_path.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n v es.\n       \\<lbrakk>\\<And>v es.\n                   forbidden_path v es \\<Longrightarrow>\n                   \\<exists>v'. path v' v (rev (stake n es));\n        \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n           v = v\\<^sub>2 \\<and>\n           es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n           ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n           hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n           forbidden_path v\\<^sub>1 pth\\<rbrakk>\n       \\<Longrightarrow> shd es \\<in> edges \\<and>\n                         (\\<exists>v'.\n                             path v' (edge_begin (shd es))\n                              (rev (stake n (stl es)))) \\<and>\n                         edge_end (shd es) = v", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma forbidden_path_prefix_is_hyp_free:\n  assumes \"forbidden_path v es\"\n  shows \"hyps_free (rev (stake n es))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hyps_free (rev (stake n es))", "using assms"], ["proof (prove)\nusing this:\n  forbidden_path v es\n\ngoal (1 subgoal):\n 1. hyps_free (rev (stake n es))", "apply (induction n arbitrary: v es)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v es.\n       forbidden_path v es \\<Longrightarrow> hyps_free (rev (stake 0 es))\n 2. \\<And>n v es.\n       \\<lbrakk>\\<And>v es.\n                   forbidden_path v es \\<Longrightarrow>\n                   hyps_free (rev (stake n es));\n        forbidden_path v es\\<rbrakk>\n       \\<Longrightarrow> hyps_free (rev (stake (Suc n) es))", "apply (simp add: hyps_free_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n v es.\n       \\<lbrakk>\\<And>v es.\n                   forbidden_path v es \\<Longrightarrow>\n                   hyps_free (rev (stake n es));\n        forbidden_path v es\\<rbrakk>\n       \\<Longrightarrow> hyps_free (rev (stake (Suc n) es))", "apply (subst (asm) (2) forbidden_path.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n v es.\n       \\<lbrakk>\\<And>v es.\n                   forbidden_path v es \\<Longrightarrow>\n                   hyps_free (rev (stake n es));\n        \\<exists>v\\<^sub>1 p\\<^sub>1 v\\<^sub>2 p\\<^sub>2 pth.\n           v = v\\<^sub>2 \\<and>\n           es = ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) ## pth \\<and>\n           ((v\\<^sub>1, p\\<^sub>1), v\\<^sub>2, p\\<^sub>2) \\<in> edges \\<and>\n           hyps (nodeOf v\\<^sub>1) p\\<^sub>1 = None \\<and>\n           forbidden_path v\\<^sub>1 pth\\<rbrakk>\n       \\<Longrightarrow> hyps_free (rev (stake (Suc n) es))", "apply (force simp add: hyps_free_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>And now we prove that the tree is finite, which requires the above notion of a\n@{term forbidden_path}, i.e.\\@ an infinite path.\\<close>"], ["", "theorem finite_tree:\n  assumes \"valid_in_port (v,p)\"\n  assumes \"terminal_vertex v\"\n  shows \"tfinite (tree v p pth)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfinite (tree v p pth)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tfinite (tree v p pth) \\<Longrightarrow> False", "let ?n = \"Suc (fcard vertices)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tfinite (tree v p pth) \\<Longrightarrow> False", "assume \"\\<not> tfinite (tree v p pth)\""], ["proof (state)\nthis:\n  \\<not> tfinite (tree v p pth)\n\ngoal (1 subgoal):\n 1. \\<not> tfinite (tree v p pth) \\<Longrightarrow> False", "hence \"\\<not> tfinite (edge_tree v p)\""], ["proof (prove)\nusing this:\n  \\<not> tfinite (tree v p pth)\n\ngoal (1 subgoal):\n 1. \\<not> tfinite (edge_tree v p)", "unfolding finite_tree_edge_tree"], ["proof (prove)\nusing this:\n  \\<not> tfinite (edge_tree v p)\n\ngoal (1 subgoal):\n 1. \\<not> tfinite (edge_tree v p)", "."], ["proof (state)\nthis:\n  \\<not> tfinite (edge_tree v p)\n\ngoal (1 subgoal):\n 1. \\<not> tfinite (tree v p pth) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> tfinite (edge_tree v p)", "obtain es  :: \"('vertex, 'form, 'var) edge' stream\"\n    where \"ipath (edge_tree v p) es\""], ["proof (prove)\nusing this:\n  \\<not> tfinite (edge_tree v p)\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        ipath (edge_tree v p) es \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Konig"], ["proof (prove)\nusing this:\n  \\<not> tfinite (edge_tree v p)\n  \\<not> tfinite ?t \\<Longrightarrow> ipath ?t (konig ?t)\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        ipath (edge_tree v p) es \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ipath (edge_tree v p) es\n\ngoal (1 subgoal):\n 1. \\<not> tfinite (tree v p pth) \\<Longrightarrow> False", "with \\<open>valid_in_port (v,p)\\<close>"], ["proof (chain)\npicking this:\n  valid_in_port (v, p)\n  ipath (edge_tree v p) es", "have \"forbidden_path v es\""], ["proof (prove)\nusing this:\n  valid_in_port (v, p)\n  ipath (edge_tree v p) es\n\ngoal (1 subgoal):\n 1. forbidden_path v es", "by (rule path_is_forbidden)"], ["proof (state)\nthis:\n  forbidden_path v es\n\ngoal (1 subgoal):\n 1. \\<not> tfinite (tree v p pth) \\<Longrightarrow> False", "from forbidden_path_prefix_is_path[OF this] forbidden_path_prefix_is_hyp_free[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>v'.\n      path v' v (rev (stake ?n es)) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n  hyps_free (rev (stake ?n es))", "obtain v' where \"path v' v (rev (stake ?n es))\" and \"hyps_free (rev (stake ?n es))\""], ["proof (prove)\nusing this:\n  (\\<And>v'.\n      path v' v (rev (stake ?n es)) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n  hyps_free (rev (stake ?n es))\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>path v' v (rev (stake (Suc (fcard vertices)) es));\n         hyps_free (rev (stake (Suc (fcard vertices)) es))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  path v' v (rev (stake (Suc (fcard vertices)) es))\n  hyps_free (rev (stake (Suc (fcard vertices)) es))\n\ngoal (1 subgoal):\n 1. \\<not> tfinite (tree v p pth) \\<Longrightarrow> False", "from this \\<open>terminal_vertex v\\<close>"], ["proof (chain)\npicking this:\n  path v' v (rev (stake (Suc (fcard vertices)) es))\n  hyps_free (rev (stake (Suc (fcard vertices)) es))\n  terminal_vertex v", "have \"terminal_path  v' v (rev (stake ?n es))\""], ["proof (prove)\nusing this:\n  path v' v (rev (stake (Suc (fcard vertices)) es))\n  hyps_free (rev (stake (Suc (fcard vertices)) es))\n  terminal_vertex v\n\ngoal (1 subgoal):\n 1. terminal_path v' v (rev (stake (Suc (fcard vertices)) es))", "by (rule terminal_pathI)"], ["proof (state)\nthis:\n  terminal_path v' v (rev (stake (Suc (fcard vertices)) es))\n\ngoal (1 subgoal):\n 1. \\<not> tfinite (tree v p pth) \\<Longrightarrow> False", "hence \"length (rev (stake ?n es)) \\<le> fcard vertices\""], ["proof (prove)\nusing this:\n  terminal_path v' v (rev (stake (Suc (fcard vertices)) es))\n\ngoal (1 subgoal):\n 1. length (rev (stake (Suc (fcard vertices)) es)) \\<le> fcard vertices", "by (rule hyps_free_limited)"], ["proof (state)\nthis:\n  length (rev (stake (Suc (fcard vertices)) es)) \\<le> fcard vertices\n\ngoal (1 subgoal):\n 1. \\<not> tfinite (tree v p pth) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  length (rev (stake (Suc (fcard vertices)) es)) \\<le> fcard vertices\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The main result of this theory.\\<close>"], ["", "theorem solved"], ["proof (prove)\ngoal (1 subgoal):\n 1. solved", "unfolding solved_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c.\n       c |\\<in>| conc_forms \\<longrightarrow>\n       (\\<exists>\\<Gamma> t.\n           fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n           \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n           local.wf t \\<and> tfinite t)", "proof(intro ballI allI conjI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "assume \"c |\\<in>| conc_forms\""], ["proof (state)\nthis:\n  c |\\<in>| conc_forms\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "hence \"c \\<in> set conclusions\""], ["proof (prove)\nusing this:\n  c |\\<in>| conc_forms\n\ngoal (1 subgoal):\n 1. c \\<in> set conclusions", "by (auto simp add: conc_forms_def)"], ["proof (state)\nthis:\n  c \\<in> set conclusions\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "from this(1) conclusions_present"], ["proof (chain)\npicking this:\n  c \\<in> set conclusions\n  set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices", "obtain v where \"v |\\<in>| vertices\" and \"nodeOf v = Conclusion c\""], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  set (map Conclusion conclusions) \\<subseteq> nodeOf ` fset vertices\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v |\\<in>| vertices; nodeOf v = Conclusion c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto, metis (no_types, lifting) image_iff image_subset_iff notin_fset)"], ["proof (state)\nthis:\n  v |\\<in>| vertices\n  nodeOf v = Conclusion c\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "have \"valid_in_port (v, (plain_ant c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_in_port (v, plain_ant c)", "using \\<open>v |\\<in>| vertices\\<close> \\<open>nodeOf _ = _ \\<close>"], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n  nodeOf v = Conclusion c\n\ngoal (1 subgoal):\n 1. valid_in_port (v, plain_ant c)", "by simp"], ["proof (state)\nthis:\n  valid_in_port (v, plain_ant c)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "have \"terminal_vertex v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_vertex v", "using \\<open>v |\\<in>| vertices\\<close> \\<open>nodeOf v = Conclusion c\\<close>"], ["proof (prove)\nusing this:\n  v |\\<in>| vertices\n  nodeOf v = Conclusion c\n\ngoal (1 subgoal):\n 1. terminal_vertex v", "by auto"], ["proof (state)\nthis:\n  terminal_vertex v\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "let ?t = \"tree v (plain_ant c) []\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "have \"fst (root ?t) = (global_assms TYPE('var), c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (tree.root (tree v (plain_ant c) [])) =\n    (global_assms TYPE('var) \\<turnstile> c)", "using \\<open>c \\<in> set conclusions\\<close> \\<open>nodeOf _ = _\\<close>"], ["proof (prove)\nusing this:\n  c \\<in> set conclusions\n  nodeOf v = Conclusion c\n\ngoal (1 subgoal):\n 1. fst (tree.root (tree v (plain_ant c) [])) =\n    (global_assms TYPE('var) \\<turnstile> c)", "by (auto simp add: labelAtIn_def conclusions_closed closed_no_lconsts  freshen_def rename_closed subst_closed)"], ["proof (state)\nthis:\n  fst (tree.root (tree v (plain_ant c) [])) =\n  (global_assms TYPE('var) \\<turnstile> c)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "moreover"], ["proof (state)\nthis:\n  fst (tree.root (tree v (plain_ant c) [])) =\n  (global_assms TYPE('var) \\<turnstile> c)\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "have \"global_assms TYPE('var) |\\<subseteq>| ass_forms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. global_assms TYPE('var) |\\<subseteq>| ass_forms", "by (rule global_in_ass)"], ["proof (state)\nthis:\n  global_assms TYPE('var) |\\<subseteq>| ass_forms\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "moreover"], ["proof (state)\nthis:\n  global_assms TYPE('var) |\\<subseteq>| ass_forms\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "from  \\<open>terminal_vertex v\\<close>"], ["proof (chain)\npicking this:\n  terminal_vertex v", "have \"terminal_path v v []\""], ["proof (prove)\nusing this:\n  terminal_vertex v\n\ngoal (1 subgoal):\n 1. terminal_path v v []", "by (rule terminal_path_empty)"], ["proof (state)\nthis:\n  terminal_path v v []\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "with \\<open>valid_in_port (v, (plain_ant c))\\<close>"], ["proof (chain)\npicking this:\n  valid_in_port (v, plain_ant c)\n  terminal_path v v []", "have \"wf ?t\""], ["proof (prove)\nusing this:\n  valid_in_port (v, plain_ant c)\n  terminal_path v v []\n\ngoal (1 subgoal):\n 1. local.wf (tree v (plain_ant c) [])", "by (rule wf_tree)"], ["proof (state)\nthis:\n  local.wf (tree v (plain_ant c) [])\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "moreover"], ["proof (state)\nthis:\n  local.wf (tree v (plain_ant c) [])\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "from \\<open>valid_in_port (v, plain_ant c)\\<close> \\<open>terminal_vertex v\\<close>"], ["proof (chain)\npicking this:\n  valid_in_port (v, plain_ant c)\n  terminal_vertex v", "have \"tfinite ?t\""], ["proof (prove)\nusing this:\n  valid_in_port (v, plain_ant c)\n  terminal_vertex v\n\ngoal (1 subgoal):\n 1. tfinite (tree v (plain_ant c) [])", "by (rule finite_tree)"], ["proof (state)\nthis:\n  tfinite (tree v (plain_ant c) [])\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c |\\<in>| conc_forms \\<Longrightarrow>\n       \\<exists>\\<Gamma> t.\n          fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n          \\<Gamma> |\\<subseteq>| ass_forms \\<and>\n          local.wf t \\<and> tfinite t", "ultimately"], ["proof (chain)\npicking this:\n  fst (tree.root (tree v (plain_ant c) [])) =\n  (global_assms TYPE('var) \\<turnstile> c)\n  global_assms TYPE('var) |\\<subseteq>| ass_forms\n  local.wf (tree v (plain_ant c) [])\n  tfinite (tree v (plain_ant c) [])", "show \"\\<exists>\\<Gamma> t. fst (root t) = (\\<Gamma> \\<turnstile> c) \\<and> \\<Gamma> |\\<subseteq>| ass_forms \\<and> wf t \\<and> tfinite t\""], ["proof (prove)\nusing this:\n  fst (tree.root (tree v (plain_ant c) [])) =\n  (global_assms TYPE('var) \\<turnstile> c)\n  global_assms TYPE('var) |\\<subseteq>| ass_forms\n  local.wf (tree v (plain_ant c) [])\n  tfinite (tree v (plain_ant c) [])\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma> t.\n       fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n       \\<Gamma> |\\<subseteq>| ass_forms \\<and> local.wf t \\<and> tfinite t", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma> t.\n     fst (tree.root t) = (\\<Gamma> \\<turnstile> c) \\<and>\n     \\<Gamma> |\\<subseteq>| ass_forms \\<and> local.wf t \\<and> tfinite t\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}