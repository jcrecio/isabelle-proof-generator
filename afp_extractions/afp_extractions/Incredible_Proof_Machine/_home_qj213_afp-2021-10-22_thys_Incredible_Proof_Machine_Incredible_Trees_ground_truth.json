{"file_name": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine/Incredible_Trees.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Incredible_Proof_Machine", "problem_names": ["lemma iwf_subst_freshen_outPort:\n  \"iwf lc ts ent \\<Longrightarrow>\n  snd ent = subst (iSubst ts) (freshen (iAnnot ts) (iOutPort ts))\"", "lemma all_local_vars_Helper[simp]:\n  \"all_local_vars Helper = {}\"", "lemma all_local_vars_Assumption[simp]:\n  \"all_local_vars (Assumption c) = {}\"", "lemma iwf_edge_match:\n  assumes \"iwf fc t ent\"\n  assumes \"is@[i] \\<in> it_paths t\"\n  shows \"subst (iSubst (tree_at t (is@[i]))) (freshen (iAnnot (tree_at t (is@[i]))) (iOutPort (tree_at t (is@[i]))))\n     = subst (iSubst (tree_at t is)) (freshen (iAnnot (tree_at t is)) (a_conc (inPorts' (iNodeOf (tree_at t is)) ! i)))\"", "lemma iwf_length_inPorts:\n  assumes \"iwf fc t ent\"\n  assumes \"is \\<in> it_paths t\"\n  shows \"length (iAnts (tree_at t is)) \\<le> length (inPorts' (iNodeOf (tree_at t is)))\"", "lemma iwf_local_not_in_subst:\n  assumes \"local_iwf t ent\"\n  assumes \"is \\<in> it_paths t\"\n  assumes \"var \\<in> all_local_vars (iNodeOf (tree_at t is))\"\n  shows \"freshenLC (iAnnot (tree_at t is)) var \\<notin> subst_lconsts (iSubst (tree_at t is))\"", "lemma iwf_length_inPorts_not_HNode:\n  assumes \"iwf fc t ent\"\n  assumes \"is \\<in> it_paths t\"\n  assumes \"\\<not> (isHNode (tree_at t is))\"\n  shows \"length (iAnts (tree_at t is)) = length (inPorts' (iNodeOf (tree_at t is)))\"", "lemma iNodeOf_outPorts:\n  \"iwf fc t ent \\<Longrightarrow> is \\<in> it_paths t \\<Longrightarrow> outPorts (iNodeOf (tree_at t is)) = {||} \\<Longrightarrow> False\"", "lemma iNodeOf_tree_at:\n  \"iwf fc t ent \\<Longrightarrow> is \\<in> it_paths t \\<Longrightarrow> iNodeOf (tree_at t is) \\<in> sset nodes\"", "lemma iwf_outPort: \n  assumes \"iwf fc t ent\"\n  assumes \"is \\<in> it_paths t\"\n  shows \"Reg (iOutPort (tree_at t is)) |\\<in>| outPorts (iNodeOf (tree_at t is))\"", "lemma hyps_along_Nil[simp]: \"hyps_along t [] = {}\"", "lemma prefix_app_Cons_elim:\n  assumes \"prefix (xs@[y]) (z#zs)\"\n  obtains \"xs = []\" and \"y = z\"\n   | xs' where \"xs = z#xs'\" and \"prefix (xs'@[y]) zs\"", "lemma hyps_along_Cons:\n  assumes \"iwf fc t ent\"\n  assumes \"i#is \\<in> it_paths t\"\n  shows \"hyps_along t (i#is) =\n    (\\<lambda>h. subst (iSubst t) (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) ` fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i))\n    \\<union> hyps_along (iAnts t ! i) is\" (is \"?S1 = ?S2 \\<union> ?S3\")", "lemma iwf_hyps_exist:\n  assumes \"iwf lc it ent\"\n  assumes \"is \\<in> it_paths it\"\n  assumes \"tree_at it is = (HNode i s ants')\"\n  assumes \"fst ent |\\<subseteq>| ass_forms\"\n  shows \"subst s (freshen i anyP) \\<in> hyps_along it is\"", "lemma hyp_port_for_spec':\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"(case hyp_port_for' t is f of (is', i, h) \\<Rightarrow> \n      prefix (is' @ [i]) is \\<and>\n      i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n      hyps (iNodeOf (tree_at t is')) h =  Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n      f = subst (iSubst  (tree_at t is')) (freshen (iAnnot (tree_at t is')) (labelsOut (iNodeOf (tree_at t is')) h)))\"", "lemma hyp_port_prefix:\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"prefix (hyp_port_path_for t is f@[hyp_port_i_for t is f]) is\"", "lemma hyp_port_strict_prefix:\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"strict_prefix (hyp_port_path_for t is f) is\"", "lemma hyp_port_it_paths:\n  assumes \"is \\<in> it_paths t\"\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"hyp_port_path_for t is f \\<in> it_paths t\"", "lemma hyp_port_hyps:\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"hyps (iNodeOf (tree_at t (hyp_port_path_for t is f))) (hyp_port_h_for t is f) = Some (inPorts' (iNodeOf (tree_at t (hyp_port_path_for t is f))) ! hyp_port_i_for t is f)\"", "lemma hyp_port_outPort:\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"(hyp_port_h_for t is f) |\\<in>| outPorts (iNodeOf (tree_at t (hyp_port_path_for t is f)))\"", "lemma hyp_port_eq:\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"f = subst (iSubst (tree_at t (hyp_port_path_for t is f))) (freshen (iAnnot (tree_at t (hyp_port_path_for t is f))) (labelsOut (iNodeOf (tree_at t (hyp_port_path_for t is f))) (hyp_port_h_for t is f)))\"", "lemma isidx_inj[simp]: \"isidx xs = isidx ys \\<longleftrightarrow> xs = ys\"", "lemma isidx_v_away[simp]: \"isidx xs \\<noteq> v_away\"", "lemma mapWithIndex_cong [fundef_cong]:\n  \"xs = ys \\<Longrightarrow> (\\<And>x i. x \\<in> set ys \\<Longrightarrow> f i x = g i x) \\<Longrightarrow> mapWithIndex f xs = mapWithIndex g ys\"", "lemma mapWithIndex_Nil[simp]: \"mapWithIndex f [] = []\"", "lemma length_mapWithIndex[simp]: \"length (mapWithIndex f xs) = length xs\"", "lemma nth_mapWithIndex[simp]: \"i < length xs \\<Longrightarrow> mapWithIndex f xs ! i = f i (xs ! i)\"", "lemma list_all2_mapWithIndex2E:\n  assumes \"list_all2 P as bs\"\n  assumes \"\\<And> i a b . i < length bs \\<Longrightarrow> P a b \\<Longrightarrow> Q a (f i b)\"\n  shows \"list_all2 Q as (mapWithIndex f bs)\"", "lemma iAnnot'_globalize_node[simp]: \"iAnnot' (globalize_node is f n) = isidx is\"", "lemma iAnnot_globalize:\n  assumes \"is' \\<in> it_paths (globalize is f t)\"\n  shows  \"iAnnot (tree_at (globalize is f t) is') = isidx (is@is')\"", "lemma all_local_consts_listed':\n  assumes \"n \\<in> sset nodes\"\n  assumes \"p |\\<in>| inPorts n\"\n  shows \"lconsts (a_conc p) \\<union> (\\<Union>(lconsts ` fset (a_hyps p))) \\<subseteq> a_fresh p \"", "lemma no_local_consts_in_consequences':\n  \"n \\<in> sset nodes \\<Longrightarrow> Reg p |\\<in>| outPorts n \\<Longrightarrow>  lconsts p = {}\"", "lemma iwf_globalize:\n  assumes \"local_iwf t (\\<Gamma> \\<turnstile> c)\"\n  shows \"plain_iwf (globalize is f t) (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)\"", "lemma fresh_at_Nil[simp]:\n  \"fresh_at t [] = {}\"", "lemma fresh_at_snoc[simp]:\n  \"fresh_at t (is@[i]) = freshenLC (iAnnot (tree_at t is)) ` (a_fresh (inPorts' (iNodeOf (tree_at t is)) ! i))\"", "lemma fresh_at_def':\n  \"fresh_at t is =\n   (if is = [] then {}\n    else freshenLC (iAnnot (tree_at t (butlast is))) ` (a_fresh (inPorts' (iNodeOf (tree_at t (butlast is))) ! last is)))\"", "lemma fresh_at_Cons[simp]:\n  \"fresh_at t (i#is) = (if is = [] then freshenLC (iAnnot t) ` (a_fresh (inPorts' (iNodeOf t) ! i)) else (let t' = iAnts t ! i in fresh_at t' is))\"", "lemma fresh_at_path_Nil[simp]:\n  \"fresh_at_path t [] = {}\"", "lemma fresh_at_path_Cons[simp]:\n  \"fresh_at_path t (i#is) = fresh_at t [i] \\<union> fresh_at_path (iAnts t ! i) is\"", "lemma globalize_local_consts:\n  assumes \"is' \\<in> it_paths (globalize is f t)\"\n  shows \"subst_lconsts (iSubst (tree_at (globalize is f t) is')) \\<subseteq>\n    fresh_at_path (globalize is f t) is' \\<union> range f\"", "lemma iwf_globalize':\n  assumes \"local_iwf t ent\"\n  assumes \"\\<And> x. x |\\<in>| fst ent \\<Longrightarrow> closed x\"\n  assumes \"closed (snd ent)\"\n  shows \"plain_iwf (globalize is (freshenLC v_away) t) ent\""], "translations": [["", "lemma iwf_subst_freshen_outPort:\n  \"iwf lc ts ent \\<Longrightarrow>\n  snd ent = subst (iSubst ts) (freshen (iAnnot ts) (iOutPort ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwf lc ts ent \\<Longrightarrow>\n    snd ent = subst (iSubst ts) (freshen (iAnnot ts) (iOutPort ts))", "by (auto elim: iwf.cases)"], ["", "definition all_local_vars :: \"('form, 'rule) graph_node \\<Rightarrow> 'var set\" where\n  \"all_local_vars n = \\<Union>(local_vars n ` fset (inPorts n))\""], ["", "lemma all_local_vars_Helper[simp]:\n  \"all_local_vars Helper = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_local_vars Helper = {}", "unfolding all_local_vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (local_vars Helper ` fset (inPorts Helper)) = {}", "by simp"], ["", "lemma all_local_vars_Assumption[simp]:\n  \"all_local_vars (Assumption c) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_local_vars (Assumption c) = {}", "unfolding all_local_vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (local_vars (Assumption c) ` fset (inPorts (Assumption c))) =\n    {}", "by simp"], ["", "text \\<open>Local freshness side-conditions, corresponding what we have in the\ntheory \\<open>Natural_Deduction\\<close>.\\<close>"], ["", "inductive local_fresh_check :: \"('form, 'rule, 'subst) fresh_check\" where\n  \"\\<lbrakk>\\<And> f. f |\\<in>| \\<Gamma> \\<Longrightarrow> freshenLC i ` (all_local_vars n) \\<inter> lconsts f = {};\n    freshenLC i ` (all_local_vars n) \\<inter> subst_lconsts s = {}\n   \\<rbrakk> \\<Longrightarrow> local_fresh_check n i s (\\<Gamma> \\<turnstile> c)\""], ["", "abbreviation \"local_iwf \\<equiv> iwf local_fresh_check\""], ["", "text \\<open>No freshness side-conditions. Used with the tree that comes out of\n\\<open>globalize\\<close>, where we establish the (global) freshness conditions\nseparately.\\<close>"], ["", "inductive no_fresh_check :: \"('form, 'rule, 'subst) fresh_check\" where\n  \"no_fresh_check n i s (\\<Gamma> \\<turnstile> c)\""], ["", "abbreviation \"plain_iwf \\<equiv> iwf no_fresh_check\""], ["", "fun isHNode where\n  \"isHNode (HNode _ _ _ ) = True\"\n |\"isHNode _ = False\""], ["", "lemma iwf_edge_match:\n  assumes \"iwf fc t ent\"\n  assumes \"is@[i] \\<in> it_paths t\"\n  shows \"subst (iSubst (tree_at t (is@[i]))) (freshen (iAnnot (tree_at t (is@[i]))) (iOutPort (tree_at t (is@[i]))))\n     = subst (iSubst (tree_at t is)) (freshen (iAnnot (tree_at t is)) (a_conc (inPorts' (iNodeOf (tree_at t is)) ! i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (iSubst (tree_at t (is @ [i])))\n     (freshen (iAnnot (tree_at t (is @ [i])))\n       (iOutPort (tree_at t (is @ [i])))) =\n    subst (iSubst (tree_at t is))\n     (freshen (iAnnot (tree_at t is))\n       (a_conc (inPorts' (iNodeOf (tree_at t is)) ! i)))", "using assms"], ["proof (prove)\nusing this:\n  iwf fc t ent\n  is @ [i] \\<in> it_paths t\n\ngoal (1 subgoal):\n 1. subst (iSubst (tree_at t (is @ [i])))\n     (freshen (iAnnot (tree_at t (is @ [i])))\n       (iOutPort (tree_at t (is @ [i])))) =\n    subst (iSubst (tree_at t is))\n     (freshen (iAnnot (tree_at t is))\n       (a_conc (inPorts' (iNodeOf (tree_at t is)) ! i)))", "apply (induction arbitrary: \"is\" i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is ia.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             iwf fc t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 x @ [xa] \\<in> it_paths t \\<longrightarrow>\n                 subst (iSubst (tree_at t (x @ [xa])))\n                  (freshen (iAnnot (tree_at t (x @ [xa])))\n                    (iOutPort (tree_at t (x @ [xa])))) =\n                 subst (iSubst (tree_at t x))\n                  (freshen (iAnnot (tree_at t x))\n                    (a_conc (inPorts' (iNodeOf (tree_at t x)) ! xa)))))\n         (inPorts' n) ants;\n        fc n i s (\\<Gamma> \\<turnstile> c); c = subst s (freshen i p);\n        is @ [ia] \\<in> it_paths (INode n p i s ants)\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (iSubst\n                            (tree_at (INode n p i s ants) (is @ [ia])))\n                          (freshen\n                            (iAnnot\n                              (tree_at (INode n p i s ants) (is @ [ia])))\n                            (iOutPort\n                              (tree_at (INode n p i s ants) (is @ [ia])))) =\n                         subst (iSubst (tree_at (INode n p i s ants) is))\n                          (freshen\n                            (iAnnot (tree_at (INode n p i s ants) is))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf\n                                  (tree_at (INode n p i s ants) is)) !\n                               ia)))\n 2. \\<And>c \\<Gamma> s i is ia.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP);\n        is @ [ia] \\<in> it_paths (HNode i s [])\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst (tree_at (HNode i s []) (is @ [ia])))\n                          (freshen\n                            (iAnnot (tree_at (HNode i s []) (is @ [ia])))\n                            (iOutPort\n                              (tree_at (HNode i s []) (is @ [ia])))) =\n                         subst (iSubst (tree_at (HNode i s []) is))\n                          (freshen (iAnnot (tree_at (HNode i s []) is))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (HNode i s []) is)) !\n                               ia)))", "apply (auto elim!: it_paths_SnocE)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants is ia.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             iwf fc t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (a_conc ip))) \\<and>\n             (\\<forall>x xa.\n                 x @ [xa] \\<in> it_paths t \\<longrightarrow>\n                 subst (iSubst' (root (tree_at t (x @ [xa]))))\n                  (freshen (iAnnot' (root (tree_at t (x @ [xa]))))\n                    (iOutPort (tree_at t (x @ [xa])))) =\n                 subst (iSubst' (root (tree_at t x)))\n                  (freshen (iAnnot' (root (tree_at t x)))\n                    (a_conc (inPorts' (iNodeOf (tree_at t x)) ! xa)))))\n         (inPorts' n) ants;\n        fc n i s (\\<Gamma> \\<turnstile> subst s (freshen i p));\n        is \\<in> it_paths (INode n p i s ants);\n        ia < length (children (tree_at (INode n p i s ants) is))\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (iSubst'\n                            (root\n                              (tree_at (INode n p i s ants) (is @ [ia]))))\n                          (freshen\n                            (iAnnot'\n                              (root\n                                (tree_at (INode n p i s ants) (is @ [ia]))))\n                            (iOutPort\n                              (tree_at (INode n p i s ants) (is @ [ia])))) =\n                         subst\n                          (iSubst' (root (tree_at (INode n p i s ants) is)))\n                          (freshen\n                            (iAnnot'\n                              (root (tree_at (INode n p i s ants) is)))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf\n                                  (tree_at (INode n p i s ants) is)) !\n                               ia)))\n 2. \\<And>c \\<Gamma> s i is ia.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP);\n        is @ [ia] \\<in> it_paths (HNode i s [])\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst (tree_at (HNode i s []) (is @ [ia])))\n                          (freshen\n                            (iAnnot (tree_at (HNode i s []) (is @ [ia])))\n                            (iOutPort\n                              (tree_at (HNode i s []) (is @ [ia])))) =\n                         subst (iSubst (tree_at (HNode i s []) is))\n                          (freshen (iAnnot (tree_at (HNode i s []) is))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (HNode i s []) is)) !\n                               ia)))", "apply (rename_tac \"is\" i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n p s ia \\<Gamma> ants is i.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             iwf fc t\n              ((\\<lambda>h. subst s (freshen ia (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen ia (a_conc ip))) \\<and>\n             (\\<forall>x xa.\n                 x @ [xa] \\<in> it_paths t \\<longrightarrow>\n                 subst (iSubst' (root (tree_at t (x @ [xa]))))\n                  (freshen (iAnnot' (root (tree_at t (x @ [xa]))))\n                    (iOutPort (tree_at t (x @ [xa])))) =\n                 subst (iSubst' (root (tree_at t x)))\n                  (freshen (iAnnot' (root (tree_at t x)))\n                    (a_conc (inPorts' (iNodeOf (tree_at t x)) ! xa)))))\n         (inPorts' n) ants;\n        fc n ia s (\\<Gamma> \\<turnstile> subst s (freshen ia p));\n        is \\<in> it_paths (INode n p ia s ants);\n        i < length (children (tree_at (INode n p ia s ants) is))\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (iSubst'\n                            (root\n                              (tree_at (INode n p ia s ants) (is @ [i]))))\n                          (freshen\n                            (iAnnot'\n                              (root\n                                (tree_at (INode n p ia s ants) (is @ [i]))))\n                            (iOutPort\n                              (tree_at (INode n p ia s ants) (is @ [i])))) =\n                         subst\n                          (iSubst'\n                            (root (tree_at (INode n p ia s ants) is)))\n                          (freshen\n                            (iAnnot'\n                              (root (tree_at (INode n p ia s ants) is)))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf\n                                  (tree_at (INode n p ia s ants) is)) !\n                               i)))\n 2. \\<And>c \\<Gamma> s i is ia.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP);\n        is @ [ia] \\<in> it_paths (HNode i s [])\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst (tree_at (HNode i s []) (is @ [ia])))\n                          (freshen\n                            (iAnnot (tree_at (HNode i s []) (is @ [ia])))\n                            (iOutPort\n                              (tree_at (HNode i s []) (is @ [ia])))) =\n                         subst (iSubst (tree_at (HNode i s []) is))\n                          (freshen (iAnnot (tree_at (HNode i s []) is))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (HNode i s []) is)) !\n                               ia)))", "apply (case_tac \"is\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n p s ia \\<Gamma> ants is i.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             iwf fc t\n              ((\\<lambda>h. subst s (freshen ia (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen ia (a_conc ip))) \\<and>\n             (\\<forall>x xa.\n                 x @ [xa] \\<in> it_paths t \\<longrightarrow>\n                 subst (iSubst' (root (tree_at t (x @ [xa]))))\n                  (freshen (iAnnot' (root (tree_at t (x @ [xa]))))\n                    (iOutPort (tree_at t (x @ [xa])))) =\n                 subst (iSubst' (root (tree_at t x)))\n                  (freshen (iAnnot' (root (tree_at t x)))\n                    (a_conc (inPorts' (iNodeOf (tree_at t x)) ! xa)))))\n         (inPorts' n) ants;\n        fc n ia s (\\<Gamma> \\<turnstile> subst s (freshen ia p));\n        is \\<in> it_paths (INode n p ia s ants);\n        i < length (children (tree_at (INode n p ia s ants) is));\n        is = []\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (iSubst'\n                            (root\n                              (tree_at (INode n p ia s ants) (is @ [i]))))\n                          (freshen\n                            (iAnnot'\n                              (root\n                                (tree_at (INode n p ia s ants) (is @ [i]))))\n                            (iOutPort\n                              (tree_at (INode n p ia s ants) (is @ [i])))) =\n                         subst\n                          (iSubst'\n                            (root (tree_at (INode n p ia s ants) is)))\n                          (freshen\n                            (iAnnot'\n                              (root (tree_at (INode n p ia s ants) is)))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf\n                                  (tree_at (INode n p ia s ants) is)) !\n                               i)))\n 2. \\<And>n p s ia \\<Gamma> ants is i a list.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             iwf fc t\n              ((\\<lambda>h. subst s (freshen ia (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen ia (a_conc ip))) \\<and>\n             (\\<forall>x xa.\n                 x @ [xa] \\<in> it_paths t \\<longrightarrow>\n                 subst (iSubst' (root (tree_at t (x @ [xa]))))\n                  (freshen (iAnnot' (root (tree_at t (x @ [xa]))))\n                    (iOutPort (tree_at t (x @ [xa])))) =\n                 subst (iSubst' (root (tree_at t x)))\n                  (freshen (iAnnot' (root (tree_at t x)))\n                    (a_conc (inPorts' (iNodeOf (tree_at t x)) ! xa)))))\n         (inPorts' n) ants;\n        fc n ia s (\\<Gamma> \\<turnstile> subst s (freshen ia p));\n        is \\<in> it_paths (INode n p ia s ants);\n        i < length (children (tree_at (INode n p ia s ants) is));\n        is = a # list\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (iSubst'\n                            (root\n                              (tree_at (INode n p ia s ants) (is @ [i]))))\n                          (freshen\n                            (iAnnot'\n                              (root\n                                (tree_at (INode n p ia s ants) (is @ [i]))))\n                            (iOutPort\n                              (tree_at (INode n p ia s ants) (is @ [i])))) =\n                         subst\n                          (iSubst'\n                            (root (tree_at (INode n p ia s ants) is)))\n                          (freshen\n                            (iAnnot'\n                              (root (tree_at (INode n p ia s ants) is)))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf\n                                  (tree_at (INode n p ia s ants) is)) !\n                               i)))\n 3. \\<And>c \\<Gamma> s i is ia.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP);\n        is @ [ia] \\<in> it_paths (HNode i s [])\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst (tree_at (HNode i s []) (is @ [ia])))\n                          (freshen\n                            (iAnnot (tree_at (HNode i s []) (is @ [ia])))\n                            (iOutPort\n                              (tree_at (HNode i s []) (is @ [ia])))) =\n                         subst (iSubst (tree_at (HNode i s []) is))\n                          (freshen (iAnnot (tree_at (HNode i s []) is))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (HNode i s []) is)) !\n                               ia)))", "apply (auto dest!: list_all2_nthD2)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n p s ia \\<Gamma> ants i.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        fc n ia s (\\<Gamma> \\<turnstile> subst s (freshen ia p));\n        i < length ants;\n        iwf fc (ants ! i)\n         ((\\<lambda>h. subst s (freshen ia (labelsOut n h))) |`|\n          hyps_for n (inPorts' n ! i) |\\<union>|\n          \\<Gamma> \\<turnstile>\n          subst s (freshen ia (a_conc (inPorts' n ! i))));\n        \\<forall>x xa.\n           x @ [xa] \\<in> it_paths (ants ! i) \\<longrightarrow>\n           subst (iSubst' (root (tree_at (ants ! i) (x @ [xa]))))\n            (freshen (iAnnot' (root (tree_at (ants ! i) (x @ [xa]))))\n              (iOutPort (tree_at (ants ! i) (x @ [xa])))) =\n           subst (iSubst' (root (tree_at (ants ! i) x)))\n            (freshen (iAnnot' (root (tree_at (ants ! i) x)))\n              (a_conc\n                (inPorts' (iNodeOf (tree_at (ants ! i) x)) ! xa)))\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst' (root (ants ! i)))\n                          (freshen (iAnnot' (root (ants ! i)))\n                            (iOutPort (ants ! i))) =\n                         subst s (freshen ia (a_conc (inPorts' n ! i)))\n 2. \\<And>n p s ia \\<Gamma> ants is i a list.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             iwf fc t\n              ((\\<lambda>h. subst s (freshen ia (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen ia (a_conc ip))) \\<and>\n             (\\<forall>x xa.\n                 x @ [xa] \\<in> it_paths t \\<longrightarrow>\n                 subst (iSubst' (root (tree_at t (x @ [xa]))))\n                  (freshen (iAnnot' (root (tree_at t (x @ [xa]))))\n                    (iOutPort (tree_at t (x @ [xa])))) =\n                 subst (iSubst' (root (tree_at t x)))\n                  (freshen (iAnnot' (root (tree_at t x)))\n                    (a_conc (inPorts' (iNodeOf (tree_at t x)) ! xa)))))\n         (inPorts' n) ants;\n        fc n ia s (\\<Gamma> \\<turnstile> subst s (freshen ia p));\n        is \\<in> it_paths (INode n p ia s ants);\n        i < length (children (tree_at (INode n p ia s ants) is));\n        is = a # list\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (iSubst'\n                            (root\n                              (tree_at (INode n p ia s ants) (is @ [i]))))\n                          (freshen\n                            (iAnnot'\n                              (root\n                                (tree_at (INode n p ia s ants) (is @ [i]))))\n                            (iOutPort\n                              (tree_at (INode n p ia s ants) (is @ [i])))) =\n                         subst\n                          (iSubst'\n                            (root (tree_at (INode n p ia s ants) is)))\n                          (freshen\n                            (iAnnot'\n                              (root (tree_at (INode n p ia s ants) is)))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf\n                                  (tree_at (INode n p ia s ants) is)) !\n                               i)))\n 3. \\<And>c \\<Gamma> s i is ia.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP);\n        is @ [ia] \\<in> it_paths (HNode i s [])\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst (tree_at (HNode i s []) (is @ [ia])))\n                          (freshen\n                            (iAnnot (tree_at (HNode i s []) (is @ [ia])))\n                            (iOutPort\n                              (tree_at (HNode i s []) (is @ [ia])))) =\n                         subst (iSubst (tree_at (HNode i s []) is))\n                          (freshen (iAnnot (tree_at (HNode i s []) is))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (HNode i s []) is)) !\n                               ia)))", "using iwf_subst_freshen_outPort"], ["proof (prove)\nusing this:\n  iwf ?lc ?ts ?ent \\<Longrightarrow>\n  snd ?ent = subst (iSubst ?ts) (freshen (iAnnot ?ts) (iOutPort ?ts))\n\ngoal (3 subgoals):\n 1. \\<And>n p s ia \\<Gamma> ants i.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        fc n ia s (\\<Gamma> \\<turnstile> subst s (freshen ia p));\n        i < length ants;\n        iwf fc (ants ! i)\n         ((\\<lambda>h. subst s (freshen ia (labelsOut n h))) |`|\n          hyps_for n (inPorts' n ! i) |\\<union>|\n          \\<Gamma> \\<turnstile>\n          subst s (freshen ia (a_conc (inPorts' n ! i))));\n        \\<forall>x xa.\n           x @ [xa] \\<in> it_paths (ants ! i) \\<longrightarrow>\n           subst (iSubst' (root (tree_at (ants ! i) (x @ [xa]))))\n            (freshen (iAnnot' (root (tree_at (ants ! i) (x @ [xa]))))\n              (iOutPort (tree_at (ants ! i) (x @ [xa])))) =\n           subst (iSubst' (root (tree_at (ants ! i) x)))\n            (freshen (iAnnot' (root (tree_at (ants ! i) x)))\n              (a_conc\n                (inPorts' (iNodeOf (tree_at (ants ! i) x)) ! xa)))\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst' (root (ants ! i)))\n                          (freshen (iAnnot' (root (ants ! i)))\n                            (iOutPort (ants ! i))) =\n                         subst s (freshen ia (a_conc (inPorts' n ! i)))\n 2. \\<And>n p s ia \\<Gamma> ants is i a list.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             iwf fc t\n              ((\\<lambda>h. subst s (freshen ia (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen ia (a_conc ip))) \\<and>\n             (\\<forall>x xa.\n                 x @ [xa] \\<in> it_paths t \\<longrightarrow>\n                 subst (iSubst' (root (tree_at t (x @ [xa]))))\n                  (freshen (iAnnot' (root (tree_at t (x @ [xa]))))\n                    (iOutPort (tree_at t (x @ [xa])))) =\n                 subst (iSubst' (root (tree_at t x)))\n                  (freshen (iAnnot' (root (tree_at t x)))\n                    (a_conc (inPorts' (iNodeOf (tree_at t x)) ! xa)))))\n         (inPorts' n) ants;\n        fc n ia s (\\<Gamma> \\<turnstile> subst s (freshen ia p));\n        is \\<in> it_paths (INode n p ia s ants);\n        i < length (children (tree_at (INode n p ia s ants) is));\n        is = a # list\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (iSubst'\n                            (root\n                              (tree_at (INode n p ia s ants) (is @ [i]))))\n                          (freshen\n                            (iAnnot'\n                              (root\n                                (tree_at (INode n p ia s ants) (is @ [i]))))\n                            (iOutPort\n                              (tree_at (INode n p ia s ants) (is @ [i])))) =\n                         subst\n                          (iSubst'\n                            (root (tree_at (INode n p ia s ants) is)))\n                          (freshen\n                            (iAnnot'\n                              (root (tree_at (INode n p ia s ants) is)))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf\n                                  (tree_at (INode n p ia s ants) is)) !\n                               i)))\n 3. \\<And>c \\<Gamma> s i is ia.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP);\n        is @ [ia] \\<in> it_paths (HNode i s [])\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst (tree_at (HNode i s []) (is @ [ia])))\n                          (freshen\n                            (iAnnot (tree_at (HNode i s []) (is @ [ia])))\n                            (iOutPort\n                              (tree_at (HNode i s []) (is @ [ia])))) =\n                         subst (iSubst (tree_at (HNode i s []) is))\n                          (freshen (iAnnot (tree_at (HNode i s []) is))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (HNode i s []) is)) !\n                               ia)))", "apply (solves \\<open>(auto)[1]\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n p s ia \\<Gamma> ants is i a list.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             iwf fc t\n              ((\\<lambda>h. subst s (freshen ia (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen ia (a_conc ip))) \\<and>\n             (\\<forall>x xa.\n                 x @ [xa] \\<in> it_paths t \\<longrightarrow>\n                 subst (iSubst' (root (tree_at t (x @ [xa]))))\n                  (freshen (iAnnot' (root (tree_at t (x @ [xa]))))\n                    (iOutPort (tree_at t (x @ [xa])))) =\n                 subst (iSubst' (root (tree_at t x)))\n                  (freshen (iAnnot' (root (tree_at t x)))\n                    (a_conc (inPorts' (iNodeOf (tree_at t x)) ! xa)))))\n         (inPorts' n) ants;\n        fc n ia s (\\<Gamma> \\<turnstile> subst s (freshen ia p));\n        is \\<in> it_paths (INode n p ia s ants);\n        i < length (children (tree_at (INode n p ia s ants) is));\n        is = a # list\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (iSubst'\n                            (root\n                              (tree_at (INode n p ia s ants) (is @ [i]))))\n                          (freshen\n                            (iAnnot'\n                              (root\n                                (tree_at (INode n p ia s ants) (is @ [i]))))\n                            (iOutPort\n                              (tree_at (INode n p ia s ants) (is @ [i])))) =\n                         subst\n                          (iSubst'\n                            (root (tree_at (INode n p ia s ants) is)))\n                          (freshen\n                            (iAnnot'\n                              (root (tree_at (INode n p ia s ants) is)))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf\n                                  (tree_at (INode n p ia s ants) is)) !\n                               i)))\n 2. \\<And>c \\<Gamma> s i is ia.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP);\n        is @ [ia] \\<in> it_paths (HNode i s [])\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst (tree_at (HNode i s []) (is @ [ia])))\n                          (freshen\n                            (iAnnot (tree_at (HNode i s []) (is @ [ia])))\n                            (iOutPort\n                              (tree_at (HNode i s []) (is @ [ia])))) =\n                         subst (iSubst (tree_at (HNode i s []) is))\n                          (freshen (iAnnot (tree_at (HNode i s []) is))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (HNode i s []) is)) !\n                               ia)))", "apply (auto elim!: it_paths_ConsE dest!: list_all2_nthD2)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n p s ia \\<Gamma> ants i a list.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        fc n ia s (\\<Gamma> \\<turnstile> subst s (freshen ia p));\n        i < length (children (tree_at (ants ! a) list)); a < length ants;\n        list \\<in> it_paths (ants ! a);\n        iwf fc (ants ! a)\n         ((\\<lambda>h. subst s (freshen ia (labelsOut n h))) |`|\n          hyps_for n (inPorts' n ! a) |\\<union>|\n          \\<Gamma> \\<turnstile>\n          subst s (freshen ia (a_conc (inPorts' n ! a))));\n        \\<forall>x xa.\n           x @ [xa] \\<in> it_paths (ants ! a) \\<longrightarrow>\n           subst (iSubst' (root (tree_at (ants ! a) (x @ [xa]))))\n            (freshen (iAnnot' (root (tree_at (ants ! a) (x @ [xa]))))\n              (iOutPort (tree_at (ants ! a) (x @ [xa])))) =\n           subst (iSubst' (root (tree_at (ants ! a) x)))\n            (freshen (iAnnot' (root (tree_at (ants ! a) x)))\n              (a_conc\n                (inPorts' (iNodeOf (tree_at (ants ! a) x)) ! xa)))\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (iSubst' (root (tree_at (ants ! a) (list @ [i]))))\n                          (freshen\n                            (iAnnot'\n                              (root (tree_at (ants ! a) (list @ [i]))))\n                            (iOutPort (tree_at (ants ! a) (list @ [i])))) =\n                         subst (iSubst' (root (tree_at (ants ! a) list)))\n                          (freshen\n                            (iAnnot' (root (tree_at (ants ! a) list)))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (ants ! a) list)) !\n                               i)))\n 2. \\<And>c \\<Gamma> s i is ia.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP);\n        is @ [ia] \\<in> it_paths (HNode i s [])\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst (tree_at (HNode i s []) (is @ [ia])))\n                          (freshen\n                            (iAnnot (tree_at (HNode i s []) (is @ [ia])))\n                            (iOutPort\n                              (tree_at (HNode i s []) (is @ [ia])))) =\n                         subst (iSubst (tree_at (HNode i s []) is))\n                          (freshen (iAnnot (tree_at (HNode i s []) is))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (HNode i s []) is)) !\n                               ia)))", "using it_path_SnocI"], ["proof (prove)\nusing this:\n  \\<lbrakk>?is \\<in> it_paths ?t;\n   ?i < length (children (tree_at ?t ?is))\\<rbrakk>\n  \\<Longrightarrow> ?is @ [?i] \\<in> it_paths ?t\n\ngoal (2 subgoals):\n 1. \\<And>n p s ia \\<Gamma> ants i a list.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        fc n ia s (\\<Gamma> \\<turnstile> subst s (freshen ia p));\n        i < length (children (tree_at (ants ! a) list)); a < length ants;\n        list \\<in> it_paths (ants ! a);\n        iwf fc (ants ! a)\n         ((\\<lambda>h. subst s (freshen ia (labelsOut n h))) |`|\n          hyps_for n (inPorts' n ! a) |\\<union>|\n          \\<Gamma> \\<turnstile>\n          subst s (freshen ia (a_conc (inPorts' n ! a))));\n        \\<forall>x xa.\n           x @ [xa] \\<in> it_paths (ants ! a) \\<longrightarrow>\n           subst (iSubst' (root (tree_at (ants ! a) (x @ [xa]))))\n            (freshen (iAnnot' (root (tree_at (ants ! a) (x @ [xa]))))\n              (iOutPort (tree_at (ants ! a) (x @ [xa])))) =\n           subst (iSubst' (root (tree_at (ants ! a) x)))\n            (freshen (iAnnot' (root (tree_at (ants ! a) x)))\n              (a_conc\n                (inPorts' (iNodeOf (tree_at (ants ! a) x)) ! xa)))\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (iSubst' (root (tree_at (ants ! a) (list @ [i]))))\n                          (freshen\n                            (iAnnot'\n                              (root (tree_at (ants ! a) (list @ [i]))))\n                            (iOutPort (tree_at (ants ! a) (list @ [i])))) =\n                         subst (iSubst' (root (tree_at (ants ! a) list)))\n                          (freshen\n                            (iAnnot' (root (tree_at (ants ! a) list)))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (ants ! a) list)) !\n                               i)))\n 2. \\<And>c \\<Gamma> s i is ia.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP);\n        is @ [ia] \\<in> it_paths (HNode i s [])\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst (tree_at (HNode i s []) (is @ [ia])))\n                          (freshen\n                            (iAnnot (tree_at (HNode i s []) (is @ [ia])))\n                            (iOutPort\n                              (tree_at (HNode i s []) (is @ [ia])))) =\n                         subst (iSubst (tree_at (HNode i s []) is))\n                          (freshen (iAnnot (tree_at (HNode i s []) is))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (HNode i s []) is)) !\n                               ia)))", "apply (solves blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> s i is ia.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP);\n        is @ [ia] \\<in> it_paths (HNode i s [])\\<rbrakk>\n       \\<Longrightarrow> subst (iSubst (tree_at (HNode i s []) (is @ [ia])))\n                          (freshen\n                            (iAnnot (tree_at (HNode i s []) (is @ [ia])))\n                            (iOutPort\n                              (tree_at (HNode i s []) (is @ [ia])))) =\n                         subst (iSubst (tree_at (HNode i s []) is))\n                          (freshen (iAnnot (tree_at (HNode i s []) is))\n                            (a_conc\n                              (inPorts'\n                                (iNodeOf (tree_at (HNode i s []) is)) !\n                               ia)))", "apply (solves auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iwf_length_inPorts:\n  assumes \"iwf fc t ent\"\n  assumes \"is \\<in> it_paths t\"\n  shows \"length (iAnts (tree_at t is)) \\<le> length (inPorts' (iNodeOf (tree_at t is)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (iAnts (tree_at t is))\n    \\<le> length (inPorts' (iNodeOf (tree_at t is)))", "using assms"], ["proof (prove)\nusing this:\n  iwf fc t ent\n  is \\<in> it_paths t\n\ngoal (1 subgoal):\n 1. length (iAnts (tree_at t is))\n    \\<le> length (inPorts' (iNodeOf (tree_at t is)))", "by (induction arbitrary: \"is\" rule: iwf.induct)\n     (auto elim!: it_paths_RNodeE dest: list_all2_lengthD list_all2_nthD2)"], ["", "lemma iwf_local_not_in_subst:\n  assumes \"local_iwf t ent\"\n  assumes \"is \\<in> it_paths t\"\n  assumes \"var \\<in> all_local_vars (iNodeOf (tree_at t is))\"\n  shows \"freshenLC (iAnnot (tree_at t is)) var \\<notin> subst_lconsts (iSubst (tree_at t is))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freshenLC (iAnnot (tree_at t is)) var\n    \\<notin> subst_lconsts (iSubst (tree_at t is))", "using assms"], ["proof (prove)\nusing this:\n  local_iwf t ent\n  is \\<in> it_paths t\n  var \\<in> all_local_vars (iNodeOf (tree_at t is))\n\ngoal (1 subgoal):\n 1. freshenLC (iAnnot (tree_at t is)) var\n    \\<notin> subst_lconsts (iSubst (tree_at t is))", "by (induction arbitrary: \"is\" rule: iwf.induct)\n     (auto 4 4 elim!: it_paths_RNodeE local_fresh_check.cases dest: list_all2_lengthD list_all2_nthD2)"], ["", "lemma iwf_length_inPorts_not_HNode:\n  assumes \"iwf fc t ent\"\n  assumes \"is \\<in> it_paths t\"\n  assumes \"\\<not> (isHNode (tree_at t is))\"\n  shows \"length (iAnts (tree_at t is)) = length (inPorts' (iNodeOf (tree_at t is)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (iAnts (tree_at t is)) =\n    length (inPorts' (iNodeOf (tree_at t is)))", "using assms"], ["proof (prove)\nusing this:\n  iwf fc t ent\n  is \\<in> it_paths t\n  \\<not> isHNode (tree_at t is)\n\ngoal (1 subgoal):\n 1. length (iAnts (tree_at t is)) =\n    length (inPorts' (iNodeOf (tree_at t is)))", "by (induction arbitrary: \"is\" rule: iwf.induct)\n     (auto 4 4 elim!: it_paths_RNodeE  dest: list_all2_lengthD list_all2_nthD2)"], ["", "lemma iNodeOf_outPorts:\n  \"iwf fc t ent \\<Longrightarrow> is \\<in> it_paths t \\<Longrightarrow> outPorts (iNodeOf (tree_at t is)) = {||} \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>iwf fc t ent; is \\<in> it_paths t;\n     outPorts (iNodeOf (tree_at t is)) = {||}\\<rbrakk>\n    \\<Longrightarrow> False", "by (induction arbitrary: \"is\" rule: iwf.induct)\n     (auto 4 4 elim!: it_paths_RNodeE  dest: list_all2_lengthD list_all2_nthD2)"], ["", "lemma iNodeOf_tree_at:\n  \"iwf fc t ent \\<Longrightarrow> is \\<in> it_paths t \\<Longrightarrow> iNodeOf (tree_at t is) \\<in> sset nodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>iwf fc t ent; is \\<in> it_paths t\\<rbrakk>\n    \\<Longrightarrow> iNodeOf (tree_at t is) \\<in> sset nodes", "by (induction arbitrary: \"is\" rule: iwf.induct)\n     (auto 4 4 elim!: it_paths_RNodeE  dest: list_all2_lengthD list_all2_nthD2)"], ["", "lemma iwf_outPort: \n  assumes \"iwf fc t ent\"\n  assumes \"is \\<in> it_paths t\"\n  shows \"Reg (iOutPort (tree_at t is)) |\\<in>| outPorts (iNodeOf (tree_at t is))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Reg (iOutPort (tree_at t is)) |\\<in>| outPorts (iNodeOf (tree_at t is))", "using assms"], ["proof (prove)\nusing this:\n  iwf fc t ent\n  is \\<in> it_paths t\n\ngoal (1 subgoal):\n 1. Reg (iOutPort (tree_at t is)) |\\<in>| outPorts (iNodeOf (tree_at t is))", "by (induction arbitrary: \"is\" rule: iwf.induct)\n     (auto 4 4 elim!: it_paths_RNodeE  dest: list_all2_lengthD list_all2_nthD2)"], ["", "inductive_set hyps_along for t \"is\" where\n \"prefix (is'@[i]) is \\<Longrightarrow>\n  i < length (inPorts' (iNodeOf (tree_at t is'))) \\<Longrightarrow>\n  hyps (iNodeOf (tree_at t is')) h = Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<Longrightarrow>\n  subst (iSubst (tree_at t is')) (freshen (iAnnot (tree_at t is')) (labelsOut (iNodeOf (tree_at t is')) h)) \\<in> hyps_along t is\""], ["", "lemma hyps_along_Nil[simp]: \"hyps_along t [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hyps_along t [] = {}", "by (auto simp add: hyps_along.simps)"], ["", "lemma prefix_app_Cons_elim:\n  assumes \"prefix (xs@[y]) (z#zs)\"\n  obtains \"xs = []\" and \"y = z\"\n   | xs' where \"xs = z#xs'\" and \"prefix (xs'@[y]) zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>xs = []; y = z\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>xs'.\n        \\<lbrakk>xs = z # xs'; prefix (xs' @ [y]) zs\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  prefix (xs @ [y]) (z # zs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>xs = []; y = z\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>xs'.\n        \\<lbrakk>xs = z # xs'; prefix (xs' @ [y]) zs\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases xs) auto"], ["", "lemma hyps_along_Cons:\n  assumes \"iwf fc t ent\"\n  assumes \"i#is \\<in> it_paths t\"\n  shows \"hyps_along t (i#is) =\n    (\\<lambda>h. subst (iSubst t) (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) ` fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i))\n    \\<union> hyps_along (iAnts t ! i) is\" (is \"?S1 = ?S2 \\<union> ?S3\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. hyps_along t (i # is) =\n    (\\<lambda>h.\n        subst (iSubst t) (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n    fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n    hyps_along (iAnts t ! i) is", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. hyps_along t (i # is) =\n    (\\<lambda>h.\n        subst (iSubst t) (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n    fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n    hyps_along (iAnts t ! i) is", "from assms"], ["proof (chain)\npicking this:\n  iwf fc t ent\n  i # is \\<in> it_paths t", "have \"i < length (iAnts t)\" and \"is \\<in> it_paths (iAnts t ! i)\""], ["proof (prove)\nusing this:\n  iwf fc t ent\n  i # is \\<in> it_paths t\n\ngoal (1 subgoal):\n 1. i < length (iAnts t) &&& is \\<in> it_paths (iAnts t ! i)", "by (auto elim: it_paths_ConsE)"], ["proof (state)\nthis:\n  i < length (iAnts t)\n  is \\<in> it_paths (iAnts t ! i)\n\ngoal (1 subgoal):\n 1. hyps_along t (i # is) =\n    (\\<lambda>h.\n        subst (iSubst t) (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n    fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n    hyps_along (iAnts t ! i) is", "let \"?t'\" = \"iAnts t ! i\""], ["proof (state)\ngoal (1 subgoal):\n 1. hyps_along t (i # is) =\n    (\\<lambda>h.\n        subst (iSubst t) (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n    fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n    hyps_along (iAnts t ! i) is", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. hyps_along t (i # is) =\n    (\\<lambda>h.\n        subst (iSubst t) (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n    fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n    hyps_along (iAnts t ! i) is", "proof (rule; rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> hyps_along t (i # is) \\<Longrightarrow>\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is\n 2. \\<And>x.\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is \\<Longrightarrow>\n       x \\<in> hyps_along t (i # is)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> hyps_along t (i # is) \\<Longrightarrow>\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is\n 2. \\<And>x.\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is \\<Longrightarrow>\n       x \\<in> hyps_along t (i # is)", "assume \"x \\<in> hyps_along t (i # is)\""], ["proof (state)\nthis:\n  x \\<in> hyps_along t (i # is)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> hyps_along t (i # is) \\<Longrightarrow>\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is\n 2. \\<And>x.\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is \\<Longrightarrow>\n       x \\<in> hyps_along t (i # is)", "then"], ["proof (chain)\npicking this:\n  x \\<in> hyps_along t (i # is)", "obtain is' i' h where\n      \"prefix (is'@[i']) (i#is)\"\n      and \"i' < length (inPorts' (iNodeOf (tree_at t is')))\"\n      and \"hyps (iNodeOf (tree_at t is')) h = Some (inPorts' (iNodeOf (tree_at t is')) ! i')\"\n      and [simp]: \"x = subst (iSubst (tree_at t is')) (freshen (iAnnot (tree_at t is')) (labelsOut (iNodeOf (tree_at t is')) h))\""], ["proof (prove)\nusing this:\n  x \\<in> hyps_along t (i # is)\n\ngoal (1 subgoal):\n 1. (\\<And>is' i' h.\n        \\<lbrakk>prefix (is' @ [i']) (i # is);\n         i' < length (inPorts' (iNodeOf (tree_at t is')));\n         hyps (iNodeOf (tree_at t is')) h =\n         Some (inPorts' (iNodeOf (tree_at t is')) ! i');\n         x =\n         subst (iSubst (tree_at t is'))\n          (freshen (iAnnot (tree_at t is'))\n            (labelsOut (iNodeOf (tree_at t is')) h))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: hyps_along.cases)"], ["proof (state)\nthis:\n  prefix (is' @ [i']) (i # is)\n  i' < length (inPorts' (iNodeOf (tree_at t is')))\n  hyps (iNodeOf (tree_at t is')) h =\n  Some (inPorts' (iNodeOf (tree_at t is')) ! i')\n  x =\n  subst (iSubst (tree_at t is'))\n   (freshen (iAnnot (tree_at t is'))\n     (labelsOut (iNodeOf (tree_at t is')) h))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> hyps_along t (i # is) \\<Longrightarrow>\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is\n 2. \\<And>x.\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is \\<Longrightarrow>\n       x \\<in> hyps_along t (i # is)", "from this(1)"], ["proof (chain)\npicking this:\n  prefix (is' @ [i']) (i # is)", "show \"x \\<in> ?S2 \\<union> ?S3\""], ["proof (prove)\nusing this:\n  prefix (is' @ [i']) (i # is)\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n            hyps_along (iAnts t ! i) is", "proof(cases rule: prefix_app_Cons_elim)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is' = []; i' = i\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                  subst (iSubst t)\n                                   (freshen (iAnnot t)\n                                     (labelsOut (iNodeOf t) h))) `\n                              fset\n                               (hyps_for (iNodeOf t)\n                                 (inPorts' (iNodeOf t) ! i)) \\<union>\n                              hyps_along (iAnts t ! i) is\n 2. \\<And>xs'.\n       \\<lbrakk>is' = i # xs'; prefix (xs' @ [i']) is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                     subst (iSubst t)\n(freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n                                 fset\n                                  (hyps_for (iNodeOf t)\n                                    (inPorts' (iNodeOf t) ! i)) \\<union>\n                                 hyps_along (iAnts t ! i) is", "assume \"is' = []\" and \"i' = i\""], ["proof (state)\nthis:\n  is' = []\n  i' = i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is' = []; i' = i\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                  subst (iSubst t)\n                                   (freshen (iAnnot t)\n                                     (labelsOut (iNodeOf t) h))) `\n                              fset\n                               (hyps_for (iNodeOf t)\n                                 (inPorts' (iNodeOf t) ! i)) \\<union>\n                              hyps_along (iAnts t ! i) is\n 2. \\<And>xs'.\n       \\<lbrakk>is' = i # xs'; prefix (xs' @ [i']) is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                     subst (iSubst t)\n(freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n                                 fset\n                                  (hyps_for (iNodeOf t)\n                                    (inPorts' (iNodeOf t) ! i)) \\<union>\n                                 hyps_along (iAnts t ! i) is", "with \\<open>hyps (iNodeOf (tree_at t is')) h = Some _\\<close>"], ["proof (chain)\npicking this:\n  hyps (iNodeOf (tree_at t is')) h =\n  Some (inPorts' (iNodeOf (tree_at t is')) ! i')\n  is' = []\n  i' = i", "have \"x \\<in> ?S2\""], ["proof (prove)\nusing this:\n  hyps (iNodeOf (tree_at t is')) h =\n  Some (inPorts' (iNodeOf (tree_at t is')) ! i')\n  is' = []\n  i' = i\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i))", "by auto"], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>h.\n              subst (iSubst t)\n               (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n          fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is' = []; i' = i\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                  subst (iSubst t)\n                                   (freshen (iAnnot t)\n                                     (labelsOut (iNodeOf t) h))) `\n                              fset\n                               (hyps_for (iNodeOf t)\n                                 (inPorts' (iNodeOf t) ! i)) \\<union>\n                              hyps_along (iAnts t ! i) is\n 2. \\<And>xs'.\n       \\<lbrakk>is' = i # xs'; prefix (xs' @ [i']) is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                     subst (iSubst t)\n(freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n                                 fset\n                                  (hyps_for (iNodeOf t)\n                                    (inPorts' (iNodeOf t) ! i)) \\<union>\n                                 hyps_along (iAnts t ! i) is", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>h.\n              subst (iSubst t)\n               (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n          fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i))\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n            hyps_along (iAnts t ! i) is", ".."], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>h.\n              subst (iSubst t)\n               (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n          fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n          hyps_along (iAnts t ! i) is\n\ngoal (1 subgoal):\n 1. \\<And>xs'.\n       \\<lbrakk>is' = i # xs'; prefix (xs' @ [i']) is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                     subst (iSubst t)\n(freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n                                 fset\n                                  (hyps_for (iNodeOf t)\n                                    (inPorts' (iNodeOf t) ! i)) \\<union>\n                                 hyps_along (iAnts t ! i) is", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs'.\n       \\<lbrakk>is' = i # xs'; prefix (xs' @ [i']) is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                     subst (iSubst t)\n(freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n                                 fset\n                                  (hyps_for (iNodeOf t)\n                                    (inPorts' (iNodeOf t) ! i)) \\<union>\n                                 hyps_along (iAnts t ! i) is", "fix is''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs'.\n       \\<lbrakk>is' = i # xs'; prefix (xs' @ [i']) is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                     subst (iSubst t)\n(freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n                                 fset\n                                  (hyps_for (iNodeOf t)\n                                    (inPorts' (iNodeOf t) ! i)) \\<union>\n                                 hyps_along (iAnts t ! i) is", "assume [simp]: \"is' = i # is''\" and \"prefix (is'' @ [i']) is\""], ["proof (state)\nthis:\n  is' = i # is''\n  prefix (is'' @ [i']) is\n\ngoal (1 subgoal):\n 1. \\<And>xs'.\n       \\<lbrakk>is' = i # xs'; prefix (xs' @ [i']) is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                     subst (iSubst t)\n(freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n                                 fset\n                                  (hyps_for (iNodeOf t)\n                                    (inPorts' (iNodeOf t) ! i)) \\<union>\n                                 hyps_along (iAnts t ! i) is", "have \"tree_at t is' = tree_at ?t' is''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tree_at t is' = tree_at (iAnts t ! i) is''", "by simp"], ["proof (state)\nthis:\n  tree_at t is' = tree_at (iAnts t ! i) is''\n\ngoal (1 subgoal):\n 1. \\<And>xs'.\n       \\<lbrakk>is' = i # xs'; prefix (xs' @ [i']) is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                     subst (iSubst t)\n(freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n                                 fset\n                                  (hyps_for (iNodeOf t)\n                                    (inPorts' (iNodeOf t) ! i)) \\<union>\n                                 hyps_along (iAnts t ! i) is", "note \\<open>prefix (is'' @ [i']) is\\<close>\n           \\<open>i' < length (inPorts' (iNodeOf (tree_at t is')))\\<close>\n           \\<open>hyps (iNodeOf (tree_at t is')) h = Some (inPorts' (iNodeOf (tree_at t is')) ! i')\\<close>"], ["proof (state)\nthis:\n  prefix (is'' @ [i']) is\n  i' < length (inPorts' (iNodeOf (tree_at t is')))\n  hyps (iNodeOf (tree_at t is')) h =\n  Some (inPorts' (iNodeOf (tree_at t is')) ! i')\n\ngoal (1 subgoal):\n 1. \\<And>xs'.\n       \\<lbrakk>is' = i # xs'; prefix (xs' @ [i']) is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                     subst (iSubst t)\n(freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n                                 fset\n                                  (hyps_for (iNodeOf t)\n                                    (inPorts' (iNodeOf t) ! i)) \\<union>\n                                 hyps_along (iAnts t ! i) is", "from this[unfolded \\<open>tree_at t is' = tree_at ?t' is''\\<close>]"], ["proof (chain)\npicking this:\n  prefix (is'' @ [i']) is\n  i' < length (inPorts' (iNodeOf (tree_at (iAnts t ! i) is'')))\n  hyps (iNodeOf (tree_at (iAnts t ! i) is'')) h =\n  Some (inPorts' (iNodeOf (tree_at (iAnts t ! i) is'')) ! i')", "have \"subst (iSubst (tree_at (iAnts t ! i) is'')) (freshen (iAnnot (tree_at (iAnts t ! i) is'')) (labelsOut (iNodeOf (tree_at (iAnts t ! i) is'')) h))\n          \\<in> hyps_along (iAnts t ! i) is\""], ["proof (prove)\nusing this:\n  prefix (is'' @ [i']) is\n  i' < length (inPorts' (iNodeOf (tree_at (iAnts t ! i) is'')))\n  hyps (iNodeOf (tree_at (iAnts t ! i) is'')) h =\n  Some (inPorts' (iNodeOf (tree_at (iAnts t ! i) is'')) ! i')\n\ngoal (1 subgoal):\n 1. subst (iSubst (tree_at (iAnts t ! i) is''))\n     (freshen (iAnnot (tree_at (iAnts t ! i) is''))\n       (labelsOut (iNodeOf (tree_at (iAnts t ! i) is'')) h))\n    \\<in> hyps_along (iAnts t ! i) is", "by (rule hyps_along.intros)"], ["proof (state)\nthis:\n  subst (iSubst (tree_at (iAnts t ! i) is''))\n   (freshen (iAnnot (tree_at (iAnts t ! i) is''))\n     (labelsOut (iNodeOf (tree_at (iAnts t ! i) is'')) h))\n  \\<in> hyps_along (iAnts t ! i) is\n\ngoal (1 subgoal):\n 1. \\<And>xs'.\n       \\<lbrakk>is' = i # xs'; prefix (xs' @ [i']) is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                     subst (iSubst t)\n(freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n                                 fset\n                                  (hyps_for (iNodeOf t)\n                                    (inPorts' (iNodeOf t) ! i)) \\<union>\n                                 hyps_along (iAnts t ! i) is", "hence \"x \\<in> ?S3\""], ["proof (prove)\nusing this:\n  subst (iSubst (tree_at (iAnts t ! i) is''))\n   (freshen (iAnnot (tree_at (iAnts t ! i) is''))\n     (labelsOut (iNodeOf (tree_at (iAnts t ! i) is'')) h))\n  \\<in> hyps_along (iAnts t ! i) is\n\ngoal (1 subgoal):\n 1. x \\<in> hyps_along (iAnts t ! i) is", "by simp"], ["proof (state)\nthis:\n  x \\<in> hyps_along (iAnts t ! i) is\n\ngoal (1 subgoal):\n 1. \\<And>xs'.\n       \\<lbrakk>is' = i # xs'; prefix (xs' @ [i']) is\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>h.\n                                     subst (iSubst t)\n(freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n                                 fset\n                                  (hyps_for (iNodeOf t)\n                                    (inPorts' (iNodeOf t) ! i)) \\<union>\n                                 hyps_along (iAnts t ! i) is", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> hyps_along (iAnts t ! i) is\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n            hyps_along (iAnts t ! i) is", ".."], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>h.\n              subst (iSubst t)\n               (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n          fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n          hyps_along (iAnts t ! i) is\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>h.\n              subst (iSubst t)\n               (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n          fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n          hyps_along (iAnts t ! i) is\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is \\<Longrightarrow>\n       x \\<in> hyps_along t (i # is)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is \\<Longrightarrow>\n       x \\<in> hyps_along t (i # is)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is \\<Longrightarrow>\n       x \\<in> hyps_along t (i # is)", "assume \"x \\<in> ?S2 \\<union> ?S3\""], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>h.\n              subst (iSubst t)\n               (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n          fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n          hyps_along (iAnts t ! i) is\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>h.\n                   subst (iSubst t)\n                    (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n               fset\n                (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n               hyps_along (iAnts t ! i) is \\<Longrightarrow>\n       x \\<in> hyps_along t (i # is)", "thus \"x \\<in> ?S1\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>h.\n              subst (iSubst t)\n               (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n          fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n          hyps_along (iAnts t ! i) is\n\ngoal (1 subgoal):\n 1. x \\<in> hyps_along t (i # is)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset\n             (hyps_for (iNodeOf t)\n               (inPorts' (iNodeOf t) ! i)) \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)\n 2. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "have \"prefix ([]@[i]) (i#is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix ([] @ [i]) (i # is)", "by simp"], ["proof (state)\nthis:\n  prefix ([] @ [i]) (i # is)\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset\n             (hyps_for (iNodeOf t)\n               (inPorts' (iNodeOf t) ! i)) \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)\n 2. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "moreover"], ["proof (state)\nthis:\n  prefix ([] @ [i]) (i # is)\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset\n             (hyps_for (iNodeOf t)\n               (inPorts' (iNodeOf t) ! i)) \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)\n 2. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "from \\<open>iwf _ t _\\<close>"], ["proof (chain)\npicking this:\n  iwf fc t ent", "have \"length (iAnts t) \\<le> length (inPorts' (iNodeOf (tree_at t []))) \""], ["proof (prove)\nusing this:\n  iwf fc t ent\n\ngoal (1 subgoal):\n 1. length (iAnts t) \\<le> length (inPorts' (iNodeOf (tree_at t [])))", "by cases (auto dest: list_all2_lengthD)"], ["proof (state)\nthis:\n  length (iAnts t) \\<le> length (inPorts' (iNodeOf (tree_at t [])))\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset\n             (hyps_for (iNodeOf t)\n               (inPorts' (iNodeOf t) ! i)) \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)\n 2. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "with \\<open>i < _\\<close>"], ["proof (chain)\npicking this:\n  i < length (iAnts t)\n  length (iAnts t) \\<le> length (inPorts' (iNodeOf (tree_at t [])))", "have \"i < length (inPorts' (iNodeOf (tree_at t [])))\""], ["proof (prove)\nusing this:\n  i < length (iAnts t)\n  length (iAnts t) \\<le> length (inPorts' (iNodeOf (tree_at t [])))\n\ngoal (1 subgoal):\n 1. i < length (inPorts' (iNodeOf (tree_at t [])))", "by simp"], ["proof (state)\nthis:\n  i < length (inPorts' (iNodeOf (tree_at t [])))\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset\n             (hyps_for (iNodeOf t)\n               (inPorts' (iNodeOf t) ! i)) \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)\n 2. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "moreover"], ["proof (state)\nthis:\n  i < length (inPorts' (iNodeOf (tree_at t [])))\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset\n             (hyps_for (iNodeOf t)\n               (inPorts' (iNodeOf t) ! i)) \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)\n 2. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "assume \"x \\<in> ?S2\""], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>h.\n              subst (iSubst t)\n               (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n          fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i))\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset\n             (hyps_for (iNodeOf t)\n               (inPorts' (iNodeOf t) ! i)) \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)\n 2. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<lambda>h.\n              subst (iSubst t)\n               (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n          fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i))", "obtain h where \"h |\\<in>| hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)\"\n        and [simp]: \"x = subst (iSubst t) (freshen (iAnnot t) (labelsOut (iNodeOf t) h))\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>h.\n              subst (iSubst t)\n               (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n          fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i))\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h |\\<in>| hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i);\n         x =\n         subst (iSubst t)\n          (freshen (iAnnot t) (labelsOut (iNodeOf t) h))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  h |\\<in>| hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)\n  x = subst (iSubst t) (freshen (iAnnot t) (labelsOut (iNodeOf t) h))\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset\n             (hyps_for (iNodeOf t)\n               (inPorts' (iNodeOf t) ! i)) \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)\n 2. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "from this(1)"], ["proof (chain)\npicking this:\n  h |\\<in>| hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)", "have \"hyps (iNodeOf (tree_at t [])) h = Some (inPorts' (iNodeOf (tree_at t [])) ! i)\""], ["proof (prove)\nusing this:\n  h |\\<in>| hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)\n\ngoal (1 subgoal):\n 1. hyps (iNodeOf (tree_at t [])) h =\n    Some (inPorts' (iNodeOf (tree_at t [])) ! i)", "by simp"], ["proof (state)\nthis:\n  hyps (iNodeOf (tree_at t [])) h =\n  Some (inPorts' (iNodeOf (tree_at t [])) ! i)\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset\n             (hyps_for (iNodeOf t)\n               (inPorts' (iNodeOf t) ! i)) \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)\n 2. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "ultimately"], ["proof (chain)\npicking this:\n  prefix ([] @ [i]) (i # is)\n  i < length (inPorts' (iNodeOf (tree_at t [])))\n  hyps (iNodeOf (tree_at t [])) h =\n  Some (inPorts' (iNodeOf (tree_at t [])) ! i)", "have \"subst (iSubst (tree_at t [])) (freshen (iAnnot (tree_at t [])) (labelsOut (iNodeOf (tree_at t [])) h)) \\<in> hyps_along t (i # is)\""], ["proof (prove)\nusing this:\n  prefix ([] @ [i]) (i # is)\n  i < length (inPorts' (iNodeOf (tree_at t [])))\n  hyps (iNodeOf (tree_at t [])) h =\n  Some (inPorts' (iNodeOf (tree_at t [])) ! i)\n\ngoal (1 subgoal):\n 1. subst (iSubst (tree_at t []))\n     (freshen (iAnnot (tree_at t []))\n       (labelsOut (iNodeOf (tree_at t [])) h))\n    \\<in> hyps_along t (i # is)", "by (rule hyps_along.intros)"], ["proof (state)\nthis:\n  subst (iSubst (tree_at t []))\n   (freshen (iAnnot (tree_at t [])) (labelsOut (iNodeOf (tree_at t [])) h))\n  \\<in> hyps_along t (i # is)\n\ngoal (2 subgoals):\n 1. x \\<in> (\\<lambda>h.\n                subst (iSubst t)\n                 (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n            fset\n             (hyps_for (iNodeOf t)\n               (inPorts' (iNodeOf t) ! i)) \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)\n 2. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "thus \"x \\<in> hyps_along t (i # is)\""], ["proof (prove)\nusing this:\n  subst (iSubst (tree_at t []))\n   (freshen (iAnnot (tree_at t [])) (labelsOut (iNodeOf (tree_at t [])) h))\n  \\<in> hyps_along t (i # is)\n\ngoal (1 subgoal):\n 1. x \\<in> hyps_along t (i # is)", "by simp"], ["proof (state)\nthis:\n  x \\<in> hyps_along t (i # is)\n\ngoal (1 subgoal):\n 1. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "assume \"x \\<in> ?S3\""], ["proof (state)\nthis:\n  x \\<in> hyps_along (iAnts t ! i) is\n\ngoal (1 subgoal):\n 1. x \\<in> hyps_along (iAnts t ! i) is \\<Longrightarrow>\n    x \\<in> hyps_along t (i # is)", "thus \"x \\<in> ?S1\""], ["proof (prove)\nusing this:\n  x \\<in> hyps_along (iAnts t ! i) is\n\ngoal (1 subgoal):\n 1. x \\<in> hyps_along t (i # is)", "apply (auto simp add: hyps_along.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is' ia h.\n       \\<lbrakk>x =\n                subst (iSubst' (root (tree_at (children t ! i) is')))\n                 (freshen (iAnnot' (root (tree_at (children t ! i) is')))\n                   (labelsOut (iNodeOf (tree_at (children t ! i) is')) h));\n        prefix (is' @ [ia]) is;\n        ia < length (inPorts' (iNodeOf (tree_at (children t ! i) is')));\n        hyps (iNodeOf (tree_at (children t ! i) is')) h =\n        Some\n         (inPorts' (iNodeOf (tree_at (children t ! i) is')) ! ia)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>is'a ia ha.\n                            subst\n                             (iSubst' (root (tree_at (children t ! i) is')))\n                             (freshen\n                               (iAnnot'\n                                 (root (tree_at (children t ! i) is')))\n                               (labelsOut\n                                 (iNodeOf (tree_at (children t ! i) is'))\n                                 h)) =\n                            subst (iSubst' (root (tree_at t is'a)))\n                             (freshen (iAnnot' (root (tree_at t is'a)))\n                               (labelsOut (iNodeOf (tree_at t is'a))\n                                 ha)) \\<and>\n                            prefix (is'a @ [ia]) (i # is) \\<and>\n                            ia < length\n                                  (inPorts'\n                                    (iNodeOf (tree_at t is'a))) \\<and>\n                            hyps (iNodeOf (tree_at t is'a)) ha =\n                            Some (inPorts' (iNodeOf (tree_at t is'a)) ! ia)", "apply (rule_tac x = \"i#is'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is' ia h.\n       \\<lbrakk>x =\n                subst (iSubst' (root (tree_at (children t ! i) is')))\n                 (freshen (iAnnot' (root (tree_at (children t ! i) is')))\n                   (labelsOut (iNodeOf (tree_at (children t ! i) is')) h));\n        prefix (is' @ [ia]) is;\n        ia < length (inPorts' (iNodeOf (tree_at (children t ! i) is')));\n        hyps (iNodeOf (tree_at (children t ! i) is')) h =\n        Some\n         (inPorts' (iNodeOf (tree_at (children t ! i) is')) ! ia)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia ha.\n                            subst\n                             (iSubst' (root (tree_at (children t ! i) is')))\n                             (freshen\n                               (iAnnot'\n                                 (root (tree_at (children t ! i) is')))\n                               (labelsOut\n                                 (iNodeOf (tree_at (children t ! i) is'))\n                                 h)) =\n                            subst (iSubst' (root (tree_at t (i # is'))))\n                             (freshen (iAnnot' (root (tree_at t (i # is'))))\n                               (labelsOut (iNodeOf (tree_at t (i # is')))\n                                 ha)) \\<and>\n                            prefix ((i # is') @ [ia]) (i # is) \\<and>\n                            ia < length\n                                  (inPorts'\n                                    (iNodeOf (tree_at t (i # is')))) \\<and>\n                            hyps (iNodeOf (tree_at t (i # is'))) ha =\n                            Some\n                             (inPorts' (iNodeOf (tree_at t (i # is'))) ! ia)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<in> hyps_along t (i # is)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> hyps_along t (i # is)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hyps_along t (i # is) =\n  (\\<lambda>h.\n      subst (iSubst t) (freshen (iAnnot t) (labelsOut (iNodeOf t) h))) `\n  fset (hyps_for (iNodeOf t) (inPorts' (iNodeOf t) ! i)) \\<union>\n  hyps_along (iAnts t ! i) is\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iwf_hyps_exist:\n  assumes \"iwf lc it ent\"\n  assumes \"is \\<in> it_paths it\"\n  assumes \"tree_at it is = (HNode i s ants')\"\n  assumes \"fst ent |\\<subseteq>| ass_forms\"\n  shows \"subst s (freshen i anyP) \\<in> hyps_along it is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along it is", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along it is", "from assms(1,2,3)"], ["proof (chain)\npicking this:\n  iwf lc it ent\n  is \\<in> it_paths it\n  tree_at it is = HNode i s ants'", "have \"subst s (freshen i anyP) \\<in> hyps_along it is \n     \\<or> subst s (freshen i anyP) |\\<in>| fst ent\n       \\<and> subst s (freshen i anyP) |\\<notin>| ass_forms\""], ["proof (prove)\nusing this:\n  iwf lc it ent\n  is \\<in> it_paths it\n  tree_at it is = HNode i s ants'\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along it is \\<or>\n    subst s (freshen i anyP) |\\<in>| fst ent \\<and>\n    subst s (freshen i anyP) |\\<notin>| ass_forms", "proof(induction arbitrary: \"is\" rule: iwf.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p sa ia \\<Gamma> ants c is.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             iwf lc t\n              ((\\<lambda>h. subst sa (freshen ia (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst sa (freshen ia (labelsIn n ip))) \\<and>\n             (\\<forall>x.\n                 x \\<in> it_paths t \\<longrightarrow>\n                 tree_at t x = HNode i s ants' \\<longrightarrow>\n                 subst s (freshen i anyP) \\<in> hyps_along t x \\<or>\n                 subst s (freshen i anyP) |\\<in>|\n                 fst ((\\<lambda>h.\n                          subst sa (freshen ia (labelsOut n h))) |`|\n                      hyps_for n ip |\\<union>|\n                      \\<Gamma> \\<turnstile>\n                      subst sa (freshen ia (labelsIn n ip))) \\<and>\n                 subst s (freshen i anyP) |\\<notin>| ass_forms))\n         (inPorts' n) ants;\n        lc n ia sa (\\<Gamma> \\<turnstile> c); c = subst sa (freshen ia p);\n        is \\<in> it_paths (INode n p ia sa ants);\n        tree_at (INode n p ia sa ants) is = HNode i s ants'\\<rbrakk>\n       \\<Longrightarrow> subst s (freshen i anyP)\n                         \\<in> hyps_along (INode n p ia sa ants) is \\<or>\n                         subst s (freshen i anyP) |\\<in>|\n                         fst (\\<Gamma> \\<turnstile> c) \\<and>\n                         subst s (freshen i anyP) |\\<notin>| ass_forms\n 2. \\<And>c \\<Gamma> sa ia is.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst sa (freshen ia anyP); is \\<in> it_paths (HNode ia sa []);\n        tree_at (HNode ia sa []) is = HNode i s ants'\\<rbrakk>\n       \\<Longrightarrow> subst s (freshen i anyP)\n                         \\<in> hyps_along (HNode ia sa []) is \\<or>\n                         subst s (freshen i anyP) |\\<in>|\n                         fst (\\<Gamma> \\<turnstile> c) \\<and>\n                         subst s (freshen i anyP) |\\<notin>| ass_forms", "case (iwf n p  s' a' \\<Gamma> ants c \"is\")"], ["proof (state)\nthis:\n  n \\<in> sset nodes\n  Reg p |\\<in>| outPorts n\n  lc n a' s' (\\<Gamma> \\<turnstile> c)\n  c = subst s' (freshen a' p)\n  list_all2\n   (\\<lambda>ip t.\n       iwf lc t\n        ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n         hyps_for n ip |\\<union>|\n         \\<Gamma> \\<turnstile>\n         subst s' (freshen a' (labelsIn n ip))) \\<and>\n       (\\<forall>x.\n           x \\<in> it_paths t \\<longrightarrow>\n           tree_at t x = HNode i s ants' \\<longrightarrow>\n           subst s (freshen i anyP) \\<in> hyps_along t x \\<or>\n           subst s (freshen i anyP) |\\<in>|\n           fst ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n                hyps_for n ip |\\<union>|\n                \\<Gamma> \\<turnstile>\n                subst s' (freshen a' (labelsIn n ip))) \\<and>\n           subst s (freshen i anyP) |\\<notin>| ass_forms))\n   (inPorts' n) ants\n  is \\<in> it_paths (INode n p a' s' ants)\n  tree_at (INode n p a' s' ants) is = HNode i s ants'\n\ngoal (2 subgoals):\n 1. \\<And>n p sa ia \\<Gamma> ants c is.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             iwf lc t\n              ((\\<lambda>h. subst sa (freshen ia (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst sa (freshen ia (labelsIn n ip))) \\<and>\n             (\\<forall>x.\n                 x \\<in> it_paths t \\<longrightarrow>\n                 tree_at t x = HNode i s ants' \\<longrightarrow>\n                 subst s (freshen i anyP) \\<in> hyps_along t x \\<or>\n                 subst s (freshen i anyP) |\\<in>|\n                 fst ((\\<lambda>h.\n                          subst sa (freshen ia (labelsOut n h))) |`|\n                      hyps_for n ip |\\<union>|\n                      \\<Gamma> \\<turnstile>\n                      subst sa (freshen ia (labelsIn n ip))) \\<and>\n                 subst s (freshen i anyP) |\\<notin>| ass_forms))\n         (inPorts' n) ants;\n        lc n ia sa (\\<Gamma> \\<turnstile> c); c = subst sa (freshen ia p);\n        is \\<in> it_paths (INode n p ia sa ants);\n        tree_at (INode n p ia sa ants) is = HNode i s ants'\\<rbrakk>\n       \\<Longrightarrow> subst s (freshen i anyP)\n                         \\<in> hyps_along (INode n p ia sa ants) is \\<or>\n                         subst s (freshen i anyP) |\\<in>|\n                         fst (\\<Gamma> \\<turnstile> c) \\<and>\n                         subst s (freshen i anyP) |\\<notin>| ass_forms\n 2. \\<And>c \\<Gamma> sa ia is.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst sa (freshen ia anyP); is \\<in> it_paths (HNode ia sa []);\n        tree_at (HNode ia sa []) is = HNode i s ants'\\<rbrakk>\n       \\<Longrightarrow> subst s (freshen i anyP)\n                         \\<in> hyps_along (HNode ia sa []) is \\<or>\n                         subst s (freshen i anyP) |\\<in>|\n                         fst (\\<Gamma> \\<turnstile> c) \\<and>\n                         subst s (freshen i anyP) |\\<notin>| ass_forms", "have \"iwf lc (INode n p a' s' ants) (\\<Gamma> \\<turnstile> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iwf lc (INode n p a' s' ants) (\\<Gamma> \\<turnstile> c)", "using iwf(1,2,3,4,5)"], ["proof (prove)\nusing this:\n  n \\<in> sset nodes\n  Reg p |\\<in>| outPorts n\n  lc n a' s' (\\<Gamma> \\<turnstile> c)\n  c = subst s' (freshen a' p)\n  list_all2\n   (\\<lambda>ip t.\n       iwf lc t\n        ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n         hyps_for n ip |\\<union>|\n         \\<Gamma> \\<turnstile>\n         subst s' (freshen a' (labelsIn n ip))) \\<and>\n       (\\<forall>x.\n           x \\<in> it_paths t \\<longrightarrow>\n           tree_at t x = HNode i s ants' \\<longrightarrow>\n           subst s (freshen i anyP) \\<in> hyps_along t x \\<or>\n           subst s (freshen i anyP) |\\<in>|\n           fst ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n                hyps_for n ip |\\<union>|\n                \\<Gamma> \\<turnstile>\n                subst s' (freshen a' (labelsIn n ip))) \\<and>\n           subst s (freshen i anyP) |\\<notin>| ass_forms))\n   (inPorts' n) ants\n\ngoal (1 subgoal):\n 1. iwf lc (INode n p a' s' ants) (\\<Gamma> \\<turnstile> c)", "by (auto intro!: iwf.intros elim!: list_all2_mono)"], ["proof (state)\nthis:\n  iwf lc (INode n p a' s' ants) (\\<Gamma> \\<turnstile> c)\n\ngoal (2 subgoals):\n 1. \\<And>n p sa ia \\<Gamma> ants c is.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             iwf lc t\n              ((\\<lambda>h. subst sa (freshen ia (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst sa (freshen ia (labelsIn n ip))) \\<and>\n             (\\<forall>x.\n                 x \\<in> it_paths t \\<longrightarrow>\n                 tree_at t x = HNode i s ants' \\<longrightarrow>\n                 subst s (freshen i anyP) \\<in> hyps_along t x \\<or>\n                 subst s (freshen i anyP) |\\<in>|\n                 fst ((\\<lambda>h.\n                          subst sa (freshen ia (labelsOut n h))) |`|\n                      hyps_for n ip |\\<union>|\n                      \\<Gamma> \\<turnstile>\n                      subst sa (freshen ia (labelsIn n ip))) \\<and>\n                 subst s (freshen i anyP) |\\<notin>| ass_forms))\n         (inPorts' n) ants;\n        lc n ia sa (\\<Gamma> \\<turnstile> c); c = subst sa (freshen ia p);\n        is \\<in> it_paths (INode n p ia sa ants);\n        tree_at (INode n p ia sa ants) is = HNode i s ants'\\<rbrakk>\n       \\<Longrightarrow> subst s (freshen i anyP)\n                         \\<in> hyps_along (INode n p ia sa ants) is \\<or>\n                         subst s (freshen i anyP) |\\<in>|\n                         fst (\\<Gamma> \\<turnstile> c) \\<and>\n                         subst s (freshen i anyP) |\\<notin>| ass_forms\n 2. \\<And>c \\<Gamma> sa ia is.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst sa (freshen ia anyP); is \\<in> it_paths (HNode ia sa []);\n        tree_at (HNode ia sa []) is = HNode i s ants'\\<rbrakk>\n       \\<Longrightarrow> subst s (freshen i anyP)\n                         \\<in> hyps_along (HNode ia sa []) is \\<or>\n                         subst s (freshen i anyP) |\\<in>|\n                         fst (\\<Gamma> \\<turnstile> c) \\<and>\n                         subst s (freshen i anyP) |\\<notin>| ass_forms", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst s (freshen i anyP)\n    \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n    subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n    subst s (freshen i anyP) |\\<notin>| ass_forms", "proof(cases \"is\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    subst s (freshen i anyP)\n    \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n    subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n    subst s (freshen i anyP) |\\<notin>| ass_forms\n 2. \\<And>a list.\n       is = a # list \\<Longrightarrow>\n       subst s (freshen i anyP)\n       \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n       subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n       subst s (freshen i anyP) |\\<notin>| ass_forms", "case Nil"], ["proof (state)\nthis:\n  is = []\n\ngoal (2 subgoals):\n 1. is = [] \\<Longrightarrow>\n    subst s (freshen i anyP)\n    \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n    subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n    subst s (freshen i anyP) |\\<notin>| ass_forms\n 2. \\<And>a list.\n       is = a # list \\<Longrightarrow>\n       subst s (freshen i anyP)\n       \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n       subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n       subst s (freshen i anyP) |\\<notin>| ass_forms", "with \\<open>tree_at (INode n p a' s' ants) is = HNode i s ants'\\<close>"], ["proof (chain)\npicking this:\n  tree_at (INode n p a' s' ants) is = HNode i s ants'\n  is = []", "show ?thesis"], ["proof (prove)\nusing this:\n  tree_at (INode n p a' s' ants) is = HNode i s ants'\n  is = []\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP)\n    \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n    subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n    subst s (freshen i anyP) |\\<notin>| ass_forms", "by auto"], ["proof (state)\nthis:\n  subst s (freshen i anyP) \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n  subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n  subst s (freshen i anyP) |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       is = a # list \\<Longrightarrow>\n       subst s (freshen i anyP)\n       \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n       subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n       subst s (freshen i anyP) |\\<notin>| ass_forms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       is = a # list \\<Longrightarrow>\n       subst s (freshen i anyP)\n       \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n       subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n       subst s (freshen i anyP) |\\<notin>| ass_forms", "case (Cons i' \"is'\")"], ["proof (state)\nthis:\n  is = i' # is'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       is = a # list \\<Longrightarrow>\n       subst s (freshen i anyP)\n       \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n       subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n       subst s (freshen i anyP) |\\<notin>| ass_forms", "with \\<open>is \\<in> it_paths (INode n p a' s' ants)\\<close>"], ["proof (chain)\npicking this:\n  is \\<in> it_paths (INode n p a' s' ants)\n  is = i' # is'", "have \"i' < length ants\" and \"is' \\<in> it_paths (ants ! i')\""], ["proof (prove)\nusing this:\n  is \\<in> it_paths (INode n p a' s' ants)\n  is = i' # is'\n\ngoal (1 subgoal):\n 1. i' < length ants &&& is' \\<in> it_paths (ants ! i')", "by (auto elim: it_paths_ConsE)"], ["proof (state)\nthis:\n  i' < length ants\n  is' \\<in> it_paths (ants ! i')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       is = a # list \\<Longrightarrow>\n       subst s (freshen i anyP)\n       \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n       subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n       subst s (freshen i anyP) |\\<notin>| ass_forms", "let ?\\<Gamma>' = \"(\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`| hyps_for n (inPorts' n ! i')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       is = a # list \\<Longrightarrow>\n       subst s (freshen i anyP)\n       \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n       subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n       subst s (freshen i anyP) |\\<notin>| ass_forms", "from \\<open>tree_at (INode n p a' s' ants) is = HNode i s ants'\\<close>"], ["proof (chain)\npicking this:\n  tree_at (INode n p a' s' ants) is = HNode i s ants'", "have \"tree_at (ants ! i') is' = HNode i s ants'\""], ["proof (prove)\nusing this:\n  tree_at (INode n p a' s' ants) is = HNode i s ants'\n\ngoal (1 subgoal):\n 1. tree_at (ants ! i') is' = HNode i s ants'", "using Cons"], ["proof (prove)\nusing this:\n  tree_at (INode n p a' s' ants) is = HNode i s ants'\n  is = i' # is'\n\ngoal (1 subgoal):\n 1. tree_at (ants ! i') is' = HNode i s ants'", "by simp"], ["proof (state)\nthis:\n  tree_at (ants ! i') is' = HNode i s ants'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       is = a # list \\<Longrightarrow>\n       subst s (freshen i anyP)\n       \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n       subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n       subst s (freshen i anyP) |\\<notin>| ass_forms", "from  iwf.IH \\<open>i' < length ants\\<close>  \\<open>is' \\<in> it_paths (ants ! i')\\<close> this"], ["proof (chain)\npicking this:\n  list_all2\n   (\\<lambda>ip t.\n       iwf lc t\n        ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n         hyps_for n ip |\\<union>|\n         \\<Gamma> \\<turnstile>\n         subst s' (freshen a' (labelsIn n ip))) \\<and>\n       (\\<forall>x.\n           x \\<in> it_paths t \\<longrightarrow>\n           tree_at t x = HNode i s ants' \\<longrightarrow>\n           subst s (freshen i anyP) \\<in> hyps_along t x \\<or>\n           subst s (freshen i anyP) |\\<in>|\n           fst ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n                hyps_for n ip |\\<union>|\n                \\<Gamma> \\<turnstile>\n                subst s' (freshen a' (labelsIn n ip))) \\<and>\n           subst s (freshen i anyP) |\\<notin>| ass_forms))\n   (inPorts' n) ants\n  i' < length ants\n  is' \\<in> it_paths (ants ! i')\n  tree_at (ants ! i') is' = HNode i s ants'", "have  \"subst s (freshen i anyP) \\<in> hyps_along (ants ! i') is'\n        \\<or> subst s (freshen i anyP) |\\<in>| ?\\<Gamma>' |\\<union>| \\<Gamma> \\<and> subst s (freshen i anyP) |\\<notin>| ass_forms\""], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>ip t.\n       iwf lc t\n        ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n         hyps_for n ip |\\<union>|\n         \\<Gamma> \\<turnstile>\n         subst s' (freshen a' (labelsIn n ip))) \\<and>\n       (\\<forall>x.\n           x \\<in> it_paths t \\<longrightarrow>\n           tree_at t x = HNode i s ants' \\<longrightarrow>\n           subst s (freshen i anyP) \\<in> hyps_along t x \\<or>\n           subst s (freshen i anyP) |\\<in>|\n           fst ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n                hyps_for n ip |\\<union>|\n                \\<Gamma> \\<turnstile>\n                subst s' (freshen a' (labelsIn n ip))) \\<and>\n           subst s (freshen i anyP) |\\<notin>| ass_forms))\n   (inPorts' n) ants\n  i' < length ants\n  is' \\<in> it_paths (ants ! i')\n  tree_at (ants ! i') is' = HNode i s ants'\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along (ants ! i') is' \\<or>\n    subst s (freshen i anyP) |\\<in>|\n    (\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! i') |\\<union>|\n    \\<Gamma> \\<and>\n    subst s (freshen i anyP) |\\<notin>| ass_forms", "by (auto dest: list_all2_nthD2)"], ["proof (state)\nthis:\n  subst s (freshen i anyP) \\<in> hyps_along (ants ! i') is' \\<or>\n  subst s (freshen i anyP) |\\<in>|\n  (\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n  hyps_for n (inPorts' n ! i') |\\<union>|\n  \\<Gamma> \\<and>\n  subst s (freshen i anyP) |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       is = a # list \\<Longrightarrow>\n       subst s (freshen i anyP)\n       \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n       subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n       subst s (freshen i anyP) |\\<notin>| ass_forms", "moreover"], ["proof (state)\nthis:\n  subst s (freshen i anyP) \\<in> hyps_along (ants ! i') is' \\<or>\n  subst s (freshen i anyP) |\\<in>|\n  (\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n  hyps_for n (inPorts' n ! i') |\\<union>|\n  \\<Gamma> \\<and>\n  subst s (freshen i anyP) |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       is = a # list \\<Longrightarrow>\n       subst s (freshen i anyP)\n       \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n       subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n       subst s (freshen i anyP) |\\<notin>| ass_forms", "from  \\<open>is \\<in> it_paths (INode n p a' s' ants)\\<close>"], ["proof (chain)\npicking this:\n  is \\<in> it_paths (INode n p a' s' ants)", "have \"hyps_along (INode n p a' s' ants) is = fset ?\\<Gamma>' \\<union> hyps_along (ants ! i') is'\""], ["proof (prove)\nusing this:\n  is \\<in> it_paths (INode n p a' s' ants)\n\ngoal (1 subgoal):\n 1. hyps_along (INode n p a' s' ants) is =\n    fset\n     ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n      hyps_for n (inPorts' n ! i')) \\<union>\n    hyps_along (ants ! i') is'", "using \\<open>is = _\\<close>"], ["proof (prove)\nusing this:\n  is \\<in> it_paths (INode n p a' s' ants)\n  is = i' # is'\n\ngoal (1 subgoal):\n 1. hyps_along (INode n p a' s' ants) is =\n    fset\n     ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n      hyps_for n (inPorts' n ! i')) \\<union>\n    hyps_along (ants ! i') is'", "by (simp add: hyps_along_Cons[OF \\<open>iwf lc (INode n p a' s' ants) (\\<Gamma> \\<turnstile> c)\\<close>])"], ["proof (state)\nthis:\n  hyps_along (INode n p a' s' ants) is =\n  fset\n   ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! i')) \\<union>\n  hyps_along (ants ! i') is'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       is = a # list \\<Longrightarrow>\n       subst s (freshen i anyP)\n       \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n       subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n       subst s (freshen i anyP) |\\<notin>| ass_forms", "ultimately"], ["proof (chain)\npicking this:\n  subst s (freshen i anyP) \\<in> hyps_along (ants ! i') is' \\<or>\n  subst s (freshen i anyP) |\\<in>|\n  (\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n  hyps_for n (inPorts' n ! i') |\\<union>|\n  \\<Gamma> \\<and>\n  subst s (freshen i anyP) |\\<notin>| ass_forms\n  hyps_along (INode n p a' s' ants) is =\n  fset\n   ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! i')) \\<union>\n  hyps_along (ants ! i') is'", "show ?thesis"], ["proof (prove)\nusing this:\n  subst s (freshen i anyP) \\<in> hyps_along (ants ! i') is' \\<or>\n  subst s (freshen i anyP) |\\<in>|\n  (\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n  hyps_for n (inPorts' n ! i') |\\<union>|\n  \\<Gamma> \\<and>\n  subst s (freshen i anyP) |\\<notin>| ass_forms\n  hyps_along (INode n p a' s' ants) is =\n  fset\n   ((\\<lambda>h. subst s' (freshen a' (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! i')) \\<union>\n  hyps_along (ants ! i') is'\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP)\n    \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n    subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n    subst s (freshen i anyP) |\\<notin>| ass_forms", "by auto"], ["proof (state)\nthis:\n  subst s (freshen i anyP) \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n  subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n  subst s (freshen i anyP) |\\<notin>| ass_forms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst s (freshen i anyP) \\<in> hyps_along (INode n p a' s' ants) is \\<or>\n  subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n  subst s (freshen i anyP) |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> sa ia is.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst sa (freshen ia anyP); is \\<in> it_paths (HNode ia sa []);\n        tree_at (HNode ia sa []) is = HNode i s ants'\\<rbrakk>\n       \\<Longrightarrow> subst s (freshen i anyP)\n                         \\<in> hyps_along (HNode ia sa []) is \\<or>\n                         subst s (freshen i anyP) |\\<in>|\n                         fst (\\<Gamma> \\<turnstile> c) \\<and>\n                         subst s (freshen i anyP) |\\<notin>| ass_forms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> sa ia is.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst sa (freshen ia anyP); is \\<in> it_paths (HNode ia sa []);\n        tree_at (HNode ia sa []) is = HNode i s ants'\\<rbrakk>\n       \\<Longrightarrow> subst s (freshen i anyP)\n                         \\<in> hyps_along (HNode ia sa []) is \\<or>\n                         subst s (freshen i anyP) |\\<in>|\n                         fst (\\<Gamma> \\<turnstile> c) \\<and>\n                         subst s (freshen i anyP) |\\<notin>| ass_forms", "case (iwfH c  \\<Gamma> s' i' \"is\")"], ["proof (state)\nthis:\n  c |\\<notin>| ass_forms\n  c |\\<in>| \\<Gamma>\n  c = subst s' (freshen i' anyP)\n  is \\<in> it_paths (HNode i' s' [])\n  tree_at (HNode i' s' []) is = HNode i s ants'\n\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> sa ia is.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst sa (freshen ia anyP); is \\<in> it_paths (HNode ia sa []);\n        tree_at (HNode ia sa []) is = HNode i s ants'\\<rbrakk>\n       \\<Longrightarrow> subst s (freshen i anyP)\n                         \\<in> hyps_along (HNode ia sa []) is \\<or>\n                         subst s (freshen i anyP) |\\<in>|\n                         fst (\\<Gamma> \\<turnstile> c) \\<and>\n                         subst s (freshen i anyP) |\\<notin>| ass_forms", "hence [simp]: \"is = []\" \"i' = i\" \"s' = s\""], ["proof (prove)\nusing this:\n  c |\\<notin>| ass_forms\n  c |\\<in>| \\<Gamma>\n  c = subst s' (freshen i' anyP)\n  is \\<in> it_paths (HNode i' s' [])\n  tree_at (HNode i' s' []) is = HNode i s ants'\n\ngoal (1 subgoal):\n 1. is = [] &&& i' = i &&& s' = s", "by simp_all"], ["proof (state)\nthis:\n  is = []\n  i' = i\n  s' = s\n\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> sa ia is.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst sa (freshen ia anyP); is \\<in> it_paths (HNode ia sa []);\n        tree_at (HNode ia sa []) is = HNode i s ants'\\<rbrakk>\n       \\<Longrightarrow> subst s (freshen i anyP)\n                         \\<in> hyps_along (HNode ia sa []) is \\<or>\n                         subst s (freshen i anyP) |\\<in>|\n                         fst (\\<Gamma> \\<turnstile> c) \\<and>\n                         subst s (freshen i anyP) |\\<notin>| ass_forms", "from \\<open>c = subst s' (freshen i' anyP)\\<close> \\<open>c |\\<in>| \\<Gamma>\\<close> \\<open>c |\\<notin>| ass_forms\\<close>"], ["proof (chain)\npicking this:\n  c = subst s' (freshen i' anyP)\n  c |\\<in>| \\<Gamma>\n  c |\\<notin>| ass_forms", "show ?case"], ["proof (prove)\nusing this:\n  c = subst s' (freshen i' anyP)\n  c |\\<in>| \\<Gamma>\n  c |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along (HNode i' s' []) is \\<or>\n    subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n    subst s (freshen i anyP) |\\<notin>| ass_forms", "by simp"], ["proof (state)\nthis:\n  subst s (freshen i anyP) \\<in> hyps_along (HNode i' s' []) is \\<or>\n  subst s (freshen i anyP) |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<and>\n  subst s (freshen i anyP) |\\<notin>| ass_forms\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst s (freshen i anyP) \\<in> hyps_along it is \\<or>\n  subst s (freshen i anyP) |\\<in>| fst ent \\<and>\n  subst s (freshen i anyP) |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along it is", "with assms(4)"], ["proof (chain)\npicking this:\n  fst ent |\\<subseteq>| ass_forms\n  subst s (freshen i anyP) \\<in> hyps_along it is \\<or>\n  subst s (freshen i anyP) |\\<in>| fst ent \\<and>\n  subst s (freshen i anyP) |\\<notin>| ass_forms", "show ?thesis"], ["proof (prove)\nusing this:\n  fst ent |\\<subseteq>| ass_forms\n  subst s (freshen i anyP) \\<in> hyps_along it is \\<or>\n  subst s (freshen i anyP) |\\<in>| fst ent \\<and>\n  subst s (freshen i anyP) |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. subst s (freshen i anyP) \\<in> hyps_along it is", "by blast"], ["proof (state)\nthis:\n  subst s (freshen i anyP) \\<in> hyps_along it is\n\ngoal:\nNo subgoals!", "qed"], ["", "definition hyp_port_for' :: \"('form, 'rule, 'subst, 'var) itree \\<Rightarrow> nat list \\<Rightarrow> 'form \\<Rightarrow> nat list \\<times> nat \\<times> ('form, 'var) out_port\" where\n  \"hyp_port_for' t is f = (SOME x.\n   (case x of (is', i, h) \\<Rightarrow> \n      prefix (is' @ [i]) is \\<and>\n      i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n      hyps (iNodeOf (tree_at t is')) h =  Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n      f = subst (iSubst  (tree_at t is')) (freshen (iAnnot (tree_at t is')) (labelsOut (iNodeOf (tree_at t is')) h))\n   ))\""], ["", "lemma hyp_port_for_spec':\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"(case hyp_port_for' t is f of (is', i, h) \\<Rightarrow> \n      prefix (is' @ [i]) is \\<and>\n      i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n      hyps (iNodeOf (tree_at t is')) h =  Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n      f = subst (iSubst  (tree_at t is')) (freshen (iAnnot (tree_at t is')) (labelsOut (iNodeOf (tree_at t is')) h)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case hyp_port_for' t is f of\n    (is', i, h) \\<Rightarrow>\n      prefix (is' @ [i]) is \\<and>\n      i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n      hyps (iNodeOf (tree_at t is')) h =\n      Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n      f =\n      subst (iSubst (tree_at t is'))\n       (freshen (iAnnot (tree_at t is'))\n         (labelsOut (iNodeOf (tree_at t is')) h))", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> hyps_along t is\n\ngoal (1 subgoal):\n 1. case hyp_port_for' t is f of\n    (is', i, h) \\<Rightarrow>\n      prefix (is' @ [i]) is \\<and>\n      i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n      hyps (iNodeOf (tree_at t is')) h =\n      Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n      f =\n      subst (iSubst (tree_at t is'))\n       (freshen (iAnnot (tree_at t is'))\n         (labelsOut (iNodeOf (tree_at t is')) h))", "unfolding hyps_along.simps hyp_port_for'_def"], ["proof (prove)\nusing this:\n  \\<exists>is' i h.\n     f =\n     subst (iSubst (tree_at t is'))\n      (freshen (iAnnot (tree_at t is'))\n        (labelsOut (iNodeOf (tree_at t is')) h)) \\<and>\n     prefix (is' @ [i]) is \\<and>\n     i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n     hyps (iNodeOf (tree_at t is')) h =\n     Some (inPorts' (iNodeOf (tree_at t is')) ! i)\n\ngoal (1 subgoal):\n 1. case SOME (is', i, h).\n            prefix (is' @ [i]) is \\<and>\n            i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n            hyps (iNodeOf (tree_at t is')) h =\n            Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n            f =\n            subst (iSubst (tree_at t is'))\n             (freshen (iAnnot (tree_at t is'))\n               (labelsOut (iNodeOf (tree_at t is')) h)) of\n    (is', i, h) \\<Rightarrow>\n      prefix (is' @ [i]) is \\<and>\n      i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n      hyps (iNodeOf (tree_at t is')) h =\n      Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n      f =\n      subst (iSubst (tree_at t is'))\n       (freshen (iAnnot (tree_at t is'))\n         (labelsOut (iNodeOf (tree_at t is')) h))", "by -(rule someI_ex, blast)"], ["", "definition hyp_port_path_for :: \"('form, 'rule, 'subst, 'var) itree \\<Rightarrow> nat list \\<Rightarrow> 'form \\<Rightarrow> nat list\"\n  where \"hyp_port_path_for t is f = fst (hyp_port_for' t is f)\""], ["", "definition hyp_port_i_for ::  \"('form, 'rule, 'subst, 'var) itree \\<Rightarrow> nat list \\<Rightarrow> 'form \\<Rightarrow> nat\"\n  where \"hyp_port_i_for t is f = fst (snd (hyp_port_for' t is f))\""], ["", "definition hyp_port_h_for :: \"('form, 'rule, 'subst, 'var) itree \\<Rightarrow> nat list \\<Rightarrow> 'form \\<Rightarrow> ('form, 'var) out_port\"\n  where \"hyp_port_h_for t is f = snd (snd (hyp_port_for' t is f))\""], ["", "lemma hyp_port_prefix:\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"prefix (hyp_port_path_for t is f@[hyp_port_i_for t is f]) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (hyp_port_path_for t is f @ [hyp_port_i_for t is f]) is", "using hyp_port_for_spec'[OF assms]"], ["proof (prove)\nusing this:\n  case hyp_port_for' t is f of\n  (is', i, h) \\<Rightarrow>\n    prefix (is' @ [i]) is \\<and>\n    i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n    hyps (iNodeOf (tree_at t is')) h =\n    Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n    f =\n    subst (iSubst (tree_at t is'))\n     (freshen (iAnnot (tree_at t is'))\n       (labelsOut (iNodeOf (tree_at t is')) h))\n\ngoal (1 subgoal):\n 1. prefix (hyp_port_path_for t is f @ [hyp_port_i_for t is f]) is", "unfolding hyp_port_path_for_def hyp_port_i_for_def"], ["proof (prove)\nusing this:\n  case hyp_port_for' t is f of\n  (is', i, h) \\<Rightarrow>\n    prefix (is' @ [i]) is \\<and>\n    i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n    hyps (iNodeOf (tree_at t is')) h =\n    Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n    f =\n    subst (iSubst (tree_at t is'))\n     (freshen (iAnnot (tree_at t is'))\n       (labelsOut (iNodeOf (tree_at t is')) h))\n\ngoal (1 subgoal):\n 1. prefix (fst (hyp_port_for' t is f) @ [fst (snd (hyp_port_for' t is f))])\n     is", "by auto"], ["", "lemma hyp_port_strict_prefix:\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"strict_prefix (hyp_port_path_for t is f) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_prefix (hyp_port_path_for t is f) is", "using hyp_port_prefix[OF assms]"], ["proof (prove)\nusing this:\n  prefix (hyp_port_path_for t is f @ [hyp_port_i_for t is f]) is\n\ngoal (1 subgoal):\n 1. strict_prefix (hyp_port_path_for t is f) is", "by (simp add: strict_prefixI' prefix_order.dual_order.strict_trans1)"], ["", "lemma hyp_port_it_paths:\n  assumes \"is \\<in> it_paths t\"\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"hyp_port_path_for t is f \\<in> it_paths t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hyp_port_path_for t is f \\<in> it_paths t", "using assms"], ["proof (prove)\nusing this:\n  is \\<in> it_paths t\n  f \\<in> hyps_along t is\n\ngoal (1 subgoal):\n 1. hyp_port_path_for t is f \\<in> it_paths t", "by (rule it_paths_strict_prefix[OF _ hyp_port_strict_prefix] )"], ["", "lemma hyp_port_hyps:\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"hyps (iNodeOf (tree_at t (hyp_port_path_for t is f))) (hyp_port_h_for t is f) = Some (inPorts' (iNodeOf (tree_at t (hyp_port_path_for t is f))) ! hyp_port_i_for t is f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hyps (iNodeOf (tree_at t (hyp_port_path_for t is f)))\n     (hyp_port_h_for t is f) =\n    Some\n     (inPorts' (iNodeOf (tree_at t (hyp_port_path_for t is f))) !\n      hyp_port_i_for t is f)", "using hyp_port_for_spec'[OF assms]"], ["proof (prove)\nusing this:\n  case hyp_port_for' t is f of\n  (is', i, h) \\<Rightarrow>\n    prefix (is' @ [i]) is \\<and>\n    i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n    hyps (iNodeOf (tree_at t is')) h =\n    Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n    f =\n    subst (iSubst (tree_at t is'))\n     (freshen (iAnnot (tree_at t is'))\n       (labelsOut (iNodeOf (tree_at t is')) h))\n\ngoal (1 subgoal):\n 1. hyps (iNodeOf (tree_at t (hyp_port_path_for t is f)))\n     (hyp_port_h_for t is f) =\n    Some\n     (inPorts' (iNodeOf (tree_at t (hyp_port_path_for t is f))) !\n      hyp_port_i_for t is f)", "unfolding hyp_port_path_for_def hyp_port_i_for_def hyp_port_h_for_def"], ["proof (prove)\nusing this:\n  case hyp_port_for' t is f of\n  (is', i, h) \\<Rightarrow>\n    prefix (is' @ [i]) is \\<and>\n    i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n    hyps (iNodeOf (tree_at t is')) h =\n    Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n    f =\n    subst (iSubst (tree_at t is'))\n     (freshen (iAnnot (tree_at t is'))\n       (labelsOut (iNodeOf (tree_at t is')) h))\n\ngoal (1 subgoal):\n 1. hyps (iNodeOf (tree_at t (fst (hyp_port_for' t is f))))\n     (snd (snd (hyp_port_for' t is f))) =\n    Some\n     (inPorts' (iNodeOf (tree_at t (fst (hyp_port_for' t is f)))) !\n      fst (snd (hyp_port_for' t is f)))", "by auto"], ["", "lemma hyp_port_outPort:\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"(hyp_port_h_for t is f) |\\<in>| outPorts (iNodeOf (tree_at t (hyp_port_path_for t is f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hyp_port_h_for t is f |\\<in>|\n    outPorts (iNodeOf (tree_at t (hyp_port_path_for t is f)))", "using hyps_correct[OF hyp_port_hyps[OF assms]]"], ["proof (prove)\nusing this:\n  hyp_port_h_for t is f |\\<in>|\n  outPorts (iNodeOf (tree_at t (hyp_port_path_for t is f))) \\<and>\n  inPorts' (iNodeOf (tree_at t (hyp_port_path_for t is f))) !\n  hyp_port_i_for t is f |\\<in>|\n  inPorts (iNodeOf (tree_at t (hyp_port_path_for t is f)))\n\ngoal (1 subgoal):\n 1. hyp_port_h_for t is f |\\<in>|\n    outPorts (iNodeOf (tree_at t (hyp_port_path_for t is f)))", ".."], ["", "lemma hyp_port_eq:\n  assumes \"f \\<in> hyps_along t is\"\n  shows \"f = subst (iSubst (tree_at t (hyp_port_path_for t is f))) (freshen (iAnnot (tree_at t (hyp_port_path_for t is f))) (labelsOut (iNodeOf (tree_at t (hyp_port_path_for t is f))) (hyp_port_h_for t is f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f =\n    subst (iSubst (tree_at t (hyp_port_path_for t is f)))\n     (freshen (iAnnot (tree_at t (hyp_port_path_for t is f)))\n       (labelsOut (iNodeOf (tree_at t (hyp_port_path_for t is f)))\n         (hyp_port_h_for t is f)))", "using hyp_port_for_spec'[OF assms]"], ["proof (prove)\nusing this:\n  case hyp_port_for' t is f of\n  (is', i, h) \\<Rightarrow>\n    prefix (is' @ [i]) is \\<and>\n    i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n    hyps (iNodeOf (tree_at t is')) h =\n    Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n    f =\n    subst (iSubst (tree_at t is'))\n     (freshen (iAnnot (tree_at t is'))\n       (labelsOut (iNodeOf (tree_at t is')) h))\n\ngoal (1 subgoal):\n 1. f =\n    subst (iSubst (tree_at t (hyp_port_path_for t is f)))\n     (freshen (iAnnot (tree_at t (hyp_port_path_for t is f)))\n       (labelsOut (iNodeOf (tree_at t (hyp_port_path_for t is f)))\n         (hyp_port_h_for t is f)))", "unfolding hyp_port_path_for_def hyp_port_i_for_def hyp_port_h_for_def"], ["proof (prove)\nusing this:\n  case hyp_port_for' t is f of\n  (is', i, h) \\<Rightarrow>\n    prefix (is' @ [i]) is \\<and>\n    i < length (inPorts' (iNodeOf (tree_at t is'))) \\<and>\n    hyps (iNodeOf (tree_at t is')) h =\n    Some (inPorts' (iNodeOf (tree_at t is')) ! i) \\<and>\n    f =\n    subst (iSubst (tree_at t is'))\n     (freshen (iAnnot (tree_at t is'))\n       (labelsOut (iNodeOf (tree_at t is')) h))\n\ngoal (1 subgoal):\n 1. f =\n    subst (iSubst (tree_at t (fst (hyp_port_for' t is f))))\n     (freshen (iAnnot (tree_at t (fst (hyp_port_for' t is f))))\n       (labelsOut (iNodeOf (tree_at t (fst (hyp_port_for' t is f))))\n         (snd (snd (hyp_port_for' t is f)))))", "by auto"], ["", "definition isidx :: \"nat list \\<Rightarrow> nat\" where \"isidx xs = to_nat (Some xs)\""], ["", "definition v_away :: \"nat\" where \"v_away = to_nat (None :: nat list option)\""], ["", "lemma isidx_inj[simp]: \"isidx xs = isidx ys \\<longleftrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (isidx xs = isidx ys) = (xs = ys)", "unfolding isidx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_nat (Some xs) = to_nat (Some ys)) = (xs = ys)", "by simp"], ["", "lemma isidx_v_away[simp]: \"isidx xs \\<noteq> v_away\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isidx xs \\<noteq> v_away", "unfolding isidx_def v_away_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_nat (Some xs) \\<noteq> to_nat None", "by simp"], ["", "definition mapWithIndex where \"mapWithIndex f xs = map (\\<lambda> (i,t) . f i t) (List.enumerate 0 xs)\""], ["", "lemma mapWithIndex_cong [fundef_cong]:\n  \"xs = ys \\<Longrightarrow> (\\<And>x i. x \\<in> set ys \\<Longrightarrow> f i x = g i x) \\<Longrightarrow> mapWithIndex f xs = mapWithIndex g ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = ys;\n     \\<And>x i. x \\<in> set ys \\<Longrightarrow> f i x = g i x\\<rbrakk>\n    \\<Longrightarrow> mapWithIndex f xs = mapWithIndex g ys", "unfolding mapWithIndex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = ys;\n     \\<And>x i. x \\<in> set ys \\<Longrightarrow> f i x = g i x\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>(x, y). f x y) (enumerate 0 xs) =\n                      map (\\<lambda>(x, y). g x y) (enumerate 0 ys)", "by (auto simp add: in_set_enumerate_eq)"], ["", "lemma mapWithIndex_Nil[simp]: \"mapWithIndex f [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapWithIndex f [] = []", "unfolding mapWithIndex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>(x, y). f x y) (enumerate 0 []) = []", "by simp"], ["", "lemma length_mapWithIndex[simp]: \"length (mapWithIndex f xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mapWithIndex f xs) = length xs", "unfolding mapWithIndex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (\\<lambda>(x, y). f x y) (enumerate 0 xs)) = length xs", "by simp"], ["", "lemma nth_mapWithIndex[simp]: \"i < length xs \\<Longrightarrow> mapWithIndex f xs ! i = f i (xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow> mapWithIndex f xs ! i = f i (xs ! i)", "unfolding mapWithIndex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    map (\\<lambda>(x, y). f x y) (enumerate 0 xs) ! i = f i (xs ! i)", "by (auto simp add: nth_enumerate_eq)"], ["", "lemma list_all2_mapWithIndex2E:\n  assumes \"list_all2 P as bs\"\n  assumes \"\\<And> i a b . i < length bs \\<Longrightarrow> P a b \\<Longrightarrow> Q a (f i b)\"\n  shows \"list_all2 Q as (mapWithIndex f bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 Q as (mapWithIndex f bs)", "using assms(1)"], ["proof (prove)\nusing this:\n  list_all2 P as bs\n\ngoal (1 subgoal):\n 1. list_all2 Q as (mapWithIndex f bs)", "by (auto simp add: list_all2_conv_all_nth mapWithIndex_def nth_enumerate_eq intro: assms(2) split: prod.split)"], ["", "text \\<open>The globalize function, which renames all local constants so that they cannot clash with \nlocal constants occurring anywhere else in the tree.\\<close>"], ["", "fun globalize_node :: \"nat list \\<Rightarrow> ('var \\<Rightarrow> 'var) \\<Rightarrow> ('form,'rule,'subst,'var) itnode \\<Rightarrow>  ('form,'rule,'subst,'var) itnode\"  where\n  \"globalize_node is f (I n p i s) =  I n p (isidx is) (subst_renameLCs f s)\"\n  | \"globalize_node is f (H i s) = H (isidx is) (subst_renameLCs f s)\""], ["", "fun globalize :: \"nat list \\<Rightarrow> ('var \\<Rightarrow> 'var) \\<Rightarrow> ('form,'rule,'subst,'var) itree \\<Rightarrow> ('form,'rule,'subst,'var) itree\" where\n  \"globalize is f (RNode r ants) = RNode \n    (globalize_node is f r)\n    (mapWithIndex (\\<lambda> i' t.\n      globalize (is@[i'])\n                (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i'))\n                          (iAnnot (RNode r ants)) (isidx is) f)\n                t\n      ) ants)\""], ["", "lemma iAnnot'_globalize_node[simp]: \"iAnnot' (globalize_node is f n) = isidx is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iAnnot' (globalize_node is f n) = isidx is", "by (cases n) auto"], ["", "lemma iAnnot_globalize:\n  assumes \"is' \\<in> it_paths (globalize is f t)\"\n  shows  \"iAnnot (tree_at (globalize is f t) is') = isidx (is@is')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iAnnot (tree_at (globalize is f t) is') = isidx (is @ is')", "using assms"], ["proof (prove)\nusing this:\n  is' \\<in> it_paths (globalize is f t)\n\ngoal (1 subgoal):\n 1. iAnnot (tree_at (globalize is f t) is') = isidx (is @ is')", "by (induction t arbitrary: f \"is\" is') (auto elim!: it_paths_RNodeE)"], ["", "lemma all_local_consts_listed':\n  assumes \"n \\<in> sset nodes\"\n  assumes \"p |\\<in>| inPorts n\"\n  shows \"lconsts (a_conc p) \\<union> (\\<Union>(lconsts ` fset (a_hyps p))) \\<subseteq> a_fresh p \""], ["proof (prove)\ngoal (1 subgoal):\n 1. lconsts (a_conc p) \\<union> \\<Union> (lconsts ` fset (a_hyps p))\n    \\<subseteq> a_fresh p", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> sset nodes\n  p |\\<in>| inPorts n\n\ngoal (1 subgoal):\n 1. lconsts (a_conc p) \\<union> \\<Union> (lconsts ` fset (a_hyps p))\n    \\<subseteq> a_fresh p", "by (auto simp add: nodes_def stream.set_map lconsts_anyP closed_no_lconsts conclusions_closed fmember.rep_eq f_antecedent_def dest!: all_local_consts_listed)"], ["", "lemma no_local_consts_in_consequences':\n  \"n \\<in> sset nodes \\<Longrightarrow> Reg p |\\<in>| outPorts n \\<Longrightarrow>  lconsts p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n\\<rbrakk>\n    \\<Longrightarrow> lconsts p = {}", "using no_local_consts_in_consequences"], ["proof (prove)\nusing this:\n  \\<forall>xs\\<in>sset rules. \\<Union> (lconsts ` set (consequent xs)) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n\\<rbrakk>\n    \\<Longrightarrow> lconsts p = {}", "by (auto simp add: nodes_def lconsts_anyP closed_no_lconsts assumptions_closed stream.set_map f_consequent_def)"], ["", "lemma iwf_globalize:\n  assumes \"local_iwf t (\\<Gamma> \\<turnstile> c)\"\n  shows \"plain_iwf (globalize is f t) (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plain_iwf (globalize is f t)\n     (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)", "using assms"], ["proof (prove)\nusing this:\n  local_iwf t (\\<Gamma> \\<turnstile> c)\n\ngoal (1 subgoal):\n 1. plain_iwf (globalize is f t)\n     (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)", "proof (induction t \"\\<Gamma> \\<turnstile> c\" arbitrary: \"is\" f \\<Gamma> c rule: iwf.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "case (iwf n p s i \\<Gamma> ants c \"is\" f)"], ["proof (state)\nthis:\n  n \\<in> sset nodes\n  Reg p |\\<in>| outPorts n\n  list_all2\n   (\\<lambda>ip t.\n       local_iwf t\n        ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n         hyps_for n ip |\\<union>|\n         \\<Gamma> \\<turnstile>\n         subst s (freshen i (labelsIn n ip))) \\<and>\n       (\\<forall>x xa.\n           (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n           hyps_for n ip |\\<union>|\n           \\<Gamma> =\n           x \\<and>\n           subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n           (\\<forall>xb xc.\n               plain_iwf (globalize xb xc t)\n                (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n   (inPorts' n) ants\n  local_fresh_check n i s (\\<Gamma> \\<turnstile> c)\n  c = subst s (freshen i p)\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "note \\<open>n \\<in> sset nodes\\<close>"], ["proof (state)\nthis:\n  n \\<in> sset nodes\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "moreover"], ["proof (state)\nthis:\n  n \\<in> sset nodes\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "note \\<open>Reg p |\\<in>| outPorts n\\<close>"], ["proof (state)\nthis:\n  Reg p |\\<in>| outPorts n\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "moreover"], ["proof (state)\nthis:\n  Reg p |\\<in>| outPorts n\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "{"], ["proof (state)\nthis:\n  Reg p |\\<in>| outPorts n\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "fix i'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "let ?V = \"a_fresh (inPorts' n ! i')\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "let ?f' = \"rerename ?V i (isidx is) f\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "let ?t = \"globalize (is @ [i']) ?f' (ants ! i')\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "let ?ip = \"inPorts' n ! i'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "let ?\\<Gamma>' = \"(\\<lambda>h. subst (subst_renameLCs f s) (freshen (isidx is) (labelsOut n h))) |`| hyps_for n ?ip\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "let ?c' = \"subst (subst_renameLCs f s) (freshen (isidx is) (labelsIn n ?ip))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "assume \"i' < length (inPorts' n)\""], ["proof (state)\nthis:\n  i' < length (inPorts' n)\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "hence \"(inPorts' n ! i') |\\<in>| inPorts n\""], ["proof (prove)\nusing this:\n  i' < length (inPorts' n)\n\ngoal (1 subgoal):\n 1. inPorts' n ! i' |\\<in>| inPorts n", "by (simp add: inPorts_fset_of)"], ["proof (state)\nthis:\n  inPorts' n ! i' |\\<in>| inPorts n\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "from \\<open>i' < length (inPorts' n)\\<close>"], ["proof (chain)\npicking this:\n  i' < length (inPorts' n)", "have subset_V: \"?V \\<subseteq> all_local_vars n\""], ["proof (prove)\nusing this:\n  i' < length (inPorts' n)\n\ngoal (1 subgoal):\n 1. a_fresh (inPorts' n ! i') \\<subseteq> all_local_vars n", "unfolding all_local_vars_def"], ["proof (prove)\nusing this:\n  i' < length (inPorts' n)\n\ngoal (1 subgoal):\n 1. a_fresh (inPorts' n ! i')\n    \\<subseteq> \\<Union> (local_vars n ` fset (inPorts n))", "by (auto simp add: inPorts_fset_of set_conv_nth)"], ["proof (state)\nthis:\n  a_fresh (inPorts' n ! i') \\<subseteq> all_local_vars n\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "from \\<open>local_fresh_check n i s (\\<Gamma> \\<turnstile> c)\\<close>"], ["proof (chain)\npicking this:\n  local_fresh_check n i s (\\<Gamma> \\<turnstile> c)", "have \"freshenLC i ` all_local_vars n \\<inter> subst_lconsts s = {}\""], ["proof (prove)\nusing this:\n  local_fresh_check n i s (\\<Gamma> \\<turnstile> c)\n\ngoal (1 subgoal):\n 1. freshenLC i ` all_local_vars n \\<inter> subst_lconsts s = {}", "by (rule local_fresh_check.cases) simp"], ["proof (state)\nthis:\n  freshenLC i ` all_local_vars n \\<inter> subst_lconsts s = {}\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "hence \"freshenLC i ` ?V \\<inter> subst_lconsts s = {}\""], ["proof (prove)\nusing this:\n  freshenLC i ` all_local_vars n \\<inter> subst_lconsts s = {}\n\ngoal (1 subgoal):\n 1. freshenLC i ` a_fresh (inPorts' n ! i') \\<inter> subst_lconsts s = {}", "using subset_V"], ["proof (prove)\nusing this:\n  freshenLC i ` all_local_vars n \\<inter> subst_lconsts s = {}\n  a_fresh (inPorts' n ! i') \\<subseteq> all_local_vars n\n\ngoal (1 subgoal):\n 1. freshenLC i ` a_fresh (inPorts' n ! i') \\<inter> subst_lconsts s = {}", "by auto"], ["proof (state)\nthis:\n  freshenLC i ` a_fresh (inPorts' n ! i') \\<inter> subst_lconsts s = {}\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "hence rerename_subst: \"subst_renameLCs ?f' s = subst_renameLCs f s\""], ["proof (prove)\nusing this:\n  freshenLC i ` a_fresh (inPorts' n ! i') \\<inter> subst_lconsts s = {}\n\ngoal (1 subgoal):\n 1. subst_renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n     s =\n    subst_renameLCs f s", "by (rule rerename_subst_noop)"], ["proof (state)\nthis:\n  subst_renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s =\n  subst_renameLCs f s\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "from all_local_consts_listed'[OF \\<open> n \\<in> sset nodes\\<close> \\<open>(inPorts' n ! i') |\\<in>| inPorts n\\<close>]"], ["proof (chain)\npicking this:\n  lconsts (a_conc (inPorts' n ! i')) \\<union>\n  \\<Union> (lconsts ` fset (a_hyps (inPorts' n ! i')))\n  \\<subseteq> a_fresh (inPorts' n ! i')", "have subset_conc: \"lconsts (a_conc (inPorts' n ! i')) \\<subseteq> ?V\"\n      and subset_hyp': \"\\<And> hyp . hyp |\\<in>| a_hyps (inPorts' n ! i') \\<Longrightarrow> lconsts hyp \\<subseteq> ?V\""], ["proof (prove)\nusing this:\n  lconsts (a_conc (inPorts' n ! i')) \\<union>\n  \\<Union> (lconsts ` fset (a_hyps (inPorts' n ! i')))\n  \\<subseteq> a_fresh (inPorts' n ! i')\n\ngoal (1 subgoal):\n 1. lconsts (a_conc (inPorts' n ! i'))\n    \\<subseteq> a_fresh (inPorts' n ! i') &&&\n    (\\<And>hyp.\n        hyp |\\<in>| a_hyps (inPorts' n ! i') \\<Longrightarrow>\n        lconsts hyp \\<subseteq> a_fresh (inPorts' n ! i'))", "by (auto simp add: fmember.rep_eq)"], ["proof (state)\nthis:\n  lconsts (a_conc (inPorts' n ! i')) \\<subseteq> a_fresh (inPorts' n ! i')\n  ?hyp7 |\\<in>| a_hyps (inPorts' n ! i') \\<Longrightarrow>\n  lconsts ?hyp7 \\<subseteq> a_fresh (inPorts' n ! i')\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "from List.list_all2_nthD[OF \\<open>list_all2 _ _ _\\<close> \\<open>i' < length (inPorts' n)\\<close>,simplified]"], ["proof (chain)\npicking this:\n  local_iwf (ants ! i')\n   ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! i') |\\<union>|\n    \\<Gamma> \\<turnstile>\n    subst s (freshen i (a_conc (inPorts' n ! i')))) \\<and>\n  (\\<forall>x xa.\n      plain_iwf (globalize x xa (ants ! i'))\n       (renameLCs xa |`|\n        ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n         hyps_for n (inPorts' n ! i') |\\<union>|\n         \\<Gamma>) \\<turnstile>\n        renameLCs xa (subst s (freshen i (a_conc (inPorts' n ! i'))))))", "have \"plain_iwf ?t\n           (renameLCs ?f' |`| ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`| hyps_for n ?ip |\\<union>|  \\<Gamma>) \\<turnstile>\n            renameLCs ?f' (subst s (freshen i (a_conc ?ip))))\""], ["proof (prove)\nusing this:\n  local_iwf (ants ! i')\n   ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! i') |\\<union>|\n    \\<Gamma> \\<turnstile>\n    subst s (freshen i (a_conc (inPorts' n ! i')))) \\<and>\n  (\\<forall>x xa.\n      plain_iwf (globalize x xa (ants ! i'))\n       (renameLCs xa |`|\n        ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n         hyps_for n (inPorts' n ! i') |\\<union>|\n         \\<Gamma>) \\<turnstile>\n        renameLCs xa (subst s (freshen i (a_conc (inPorts' n ! i'))))))\n\ngoal (1 subgoal):\n 1. plain_iwf\n     (globalize (is @ [i'])\n       (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) (ants ! i'))\n     (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n      ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n       hyps_for n (inPorts' n ! i') |\\<union>|\n       \\<Gamma>) \\<turnstile>\n      renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n       (subst s (freshen i (a_conc (inPorts' n ! i')))))", "by simp"], ["proof (state)\nthis:\n  plain_iwf\n   (globalize (is @ [i'])\n     (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) (ants ! i'))\n   (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n    ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n     hyps_for n (inPorts' n ! i') |\\<union>|\n     \\<Gamma>) \\<turnstile>\n    renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n     (subst s (freshen i (a_conc (inPorts' n ! i')))))\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "also"], ["proof (state)\nthis:\n  plain_iwf\n   (globalize (is @ [i'])\n     (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) (ants ! i'))\n   (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n    ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n     hyps_for n (inPorts' n ! i') |\\<union>|\n     \\<Gamma>) \\<turnstile>\n    renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n     (subst s (freshen i (a_conc (inPorts' n ! i')))))\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "have \"renameLCs ?f' |`| ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`| hyps_for n ?ip |\\<union>|  \\<Gamma>)\n      = (\\<lambda>x. subst (subst_renameLCs ?f' s) (renameLCs ?f' (freshen i (labelsOut n x)))) |`|  hyps_for n ?ip |\\<union>| renameLCs ?f' |`| \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n    ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n     hyps_for n (inPorts' n ! i') |\\<union>|\n     \\<Gamma>) =\n    (\\<lambda>x.\n        subst\n         (subst_renameLCs\n           (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n         (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n           (freshen i (labelsOut n x)))) |`|\n    hyps_for n (inPorts' n ! i') |\\<union>|\n    renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n    \\<Gamma>", "by (simp add: fimage_fimage fimage_funion comp_def rename_subst)"], ["proof (state)\nthis:\n  renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n  ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n   hyps_for n (inPorts' n ! i') |\\<union>|\n   \\<Gamma>) =\n  (\\<lambda>x.\n      subst\n       (subst_renameLCs\n         (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n       (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n         (freshen i (labelsOut n x)))) |`|\n  hyps_for n (inPorts' n ! i') |\\<union>|\n  renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n  \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "also"], ["proof (state)\nthis:\n  renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n  ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n   hyps_for n (inPorts' n ! i') |\\<union>|\n   \\<Gamma>) =\n  (\\<lambda>x.\n      subst\n       (subst_renameLCs\n         (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n       (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n         (freshen i (labelsOut n x)))) |`|\n  hyps_for n (inPorts' n ! i') |\\<union>|\n  renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n  \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "have \"renameLCs ?f' |`| \\<Gamma> =  renameLCs f |`| \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n    \\<Gamma> =\n    renameLCs f |`| \\<Gamma>", "proof(rule fimage_cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| \\<Gamma> \\<Longrightarrow>\n       renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) x =\n       renameLCs f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| \\<Gamma> \\<Longrightarrow>\n       renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) x =\n       renameLCs f x", "assume \"x |\\<in>| \\<Gamma>\""], ["proof (state)\nthis:\n  x |\\<in>| \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| \\<Gamma> \\<Longrightarrow>\n       renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) x =\n       renameLCs f x", "with \\<open>local_fresh_check n i s (\\<Gamma> \\<turnstile> c)\\<close>"], ["proof (chain)\npicking this:\n  local_fresh_check n i s (\\<Gamma> \\<turnstile> c)\n  x |\\<in>| \\<Gamma>", "have \"freshenLC i ` all_local_vars n \\<inter> lconsts x = {}\""], ["proof (prove)\nusing this:\n  local_fresh_check n i s (\\<Gamma> \\<turnstile> c)\n  x |\\<in>| \\<Gamma>\n\ngoal (1 subgoal):\n 1. freshenLC i ` all_local_vars n \\<inter> lconsts x = {}", "by (elim local_fresh_check.cases) simp"], ["proof (state)\nthis:\n  freshenLC i ` all_local_vars n \\<inter> lconsts x = {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| \\<Gamma> \\<Longrightarrow>\n       renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) x =\n       renameLCs f x", "hence \"freshenLC i ` ?V \\<inter> lconsts x = {}\""], ["proof (prove)\nusing this:\n  freshenLC i ` all_local_vars n \\<inter> lconsts x = {}\n\ngoal (1 subgoal):\n 1. freshenLC i ` a_fresh (inPorts' n ! i') \\<inter> lconsts x = {}", "using subset_V"], ["proof (prove)\nusing this:\n  freshenLC i ` all_local_vars n \\<inter> lconsts x = {}\n  a_fresh (inPorts' n ! i') \\<subseteq> all_local_vars n\n\ngoal (1 subgoal):\n 1. freshenLC i ` a_fresh (inPorts' n ! i') \\<inter> lconsts x = {}", "by auto"], ["proof (state)\nthis:\n  freshenLC i ` a_fresh (inPorts' n ! i') \\<inter> lconsts x = {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| \\<Gamma> \\<Longrightarrow>\n       renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) x =\n       renameLCs f x", "thus \"renameLCs ?f' x = renameLCs f x\""], ["proof (prove)\nusing this:\n  freshenLC i ` a_fresh (inPorts' n ! i') \\<inter> lconsts x = {}\n\ngoal (1 subgoal):\n 1. renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) x =\n    renameLCs f x", "by (rule rerename_rename_noop)"], ["proof (state)\nthis:\n  renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) x =\n  renameLCs f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n  \\<Gamma> =\n  renameLCs f |`| \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "also"], ["proof (state)\nthis:\n  renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) |`|\n  \\<Gamma> =\n  renameLCs f |`| \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "have \"(\\<lambda>x. subst (subst_renameLCs ?f' s) (renameLCs ?f' (freshen i (labelsOut n x)))) |`|  hyps_for n ?ip = ?\\<Gamma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        subst\n         (subst_renameLCs\n           (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n         (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n           (freshen i (labelsOut n x)))) |`|\n    hyps_for n (inPorts' n ! i') =\n    (\\<lambda>h.\n        subst (subst_renameLCs f s)\n         (freshen (isidx is) (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! i')", "proof(rule fimage_cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| hyps_for n (inPorts' n ! i') \\<Longrightarrow>\n       subst\n        (subst_renameLCs\n          (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n        (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n          (freshen i (labelsOut n x))) =\n       subst (subst_renameLCs f s) (freshen (isidx is) (labelsOut n x))", "fix hyp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| hyps_for n (inPorts' n ! i') \\<Longrightarrow>\n       subst\n        (subst_renameLCs\n          (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n        (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n          (freshen i (labelsOut n x))) =\n       subst (subst_renameLCs f s) (freshen (isidx is) (labelsOut n x))", "assume \"hyp |\\<in>| hyps_for n (inPorts' n ! i')\""], ["proof (state)\nthis:\n  hyp |\\<in>| hyps_for n (inPorts' n ! i')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| hyps_for n (inPorts' n ! i') \\<Longrightarrow>\n       subst\n        (subst_renameLCs\n          (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n        (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n          (freshen i (labelsOut n x))) =\n       subst (subst_renameLCs f s) (freshen (isidx is) (labelsOut n x))", "hence \"labelsOut n hyp |\\<in>| a_hyps (inPorts' n ! i')\""], ["proof (prove)\nusing this:\n  hyp |\\<in>| hyps_for n (inPorts' n ! i')\n\ngoal (1 subgoal):\n 1. labelsOut n hyp |\\<in>| a_hyps (inPorts' n ! i')", "apply (cases hyp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>hyp |\\<in>| hyps_for n (inPorts' n ! i');\n        hyp = Reg x1\\<rbrakk>\n       \\<Longrightarrow> labelsOut n hyp |\\<in>| a_hyps (inPorts' n ! i')\n 2. \\<And>x21 x22.\n       \\<lbrakk>hyp |\\<in>| hyps_for n (inPorts' n ! i');\n        hyp = Hyp x21 x22\\<rbrakk>\n       \\<Longrightarrow> labelsOut n hyp |\\<in>| a_hyps (inPorts' n ! i')", "apply (solves simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>hyp |\\<in>| hyps_for n (inPorts' n ! i');\n        hyp = Hyp x21 x22\\<rbrakk>\n       \\<Longrightarrow> labelsOut n hyp |\\<in>| a_hyps (inPorts' n ! i')", "apply (cases n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22 x1.\n       \\<lbrakk>hyp |\\<in>| hyps_for n (inPorts' n ! i'); hyp = Hyp x21 x22;\n        n = Assumption x1\\<rbrakk>\n       \\<Longrightarrow> labelsOut n hyp |\\<in>| a_hyps (inPorts' n ! i')\n 2. \\<And>x21 x22 x2.\n       \\<lbrakk>hyp |\\<in>| hyps_for n (inPorts' n ! i'); hyp = Hyp x21 x22;\n        n = Conclusion x2\\<rbrakk>\n       \\<Longrightarrow> labelsOut n hyp |\\<in>| a_hyps (inPorts' n ! i')\n 3. \\<And>x21 x22 x3.\n       \\<lbrakk>hyp |\\<in>| hyps_for n (inPorts' n ! i'); hyp = Hyp x21 x22;\n        n = Rule x3\\<rbrakk>\n       \\<Longrightarrow> labelsOut n hyp |\\<in>| a_hyps (inPorts' n ! i')\n 4. \\<And>x21 x22.\n       \\<lbrakk>hyp |\\<in>| hyps_for n (inPorts' n ! i'); hyp = Hyp x21 x22;\n        n = Helper\\<rbrakk>\n       \\<Longrightarrow> labelsOut n hyp |\\<in>| a_hyps (inPorts' n ! i')", "apply (auto split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  labelsOut n hyp |\\<in>| a_hyps (inPorts' n ! i')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| hyps_for n (inPorts' n ! i') \\<Longrightarrow>\n       subst\n        (subst_renameLCs\n          (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n        (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n          (freshen i (labelsOut n x))) =\n       subst (subst_renameLCs f s) (freshen (isidx is) (labelsOut n x))", "from subset_hyp'[OF this]"], ["proof (chain)\npicking this:\n  lconsts (labelsOut n hyp) \\<subseteq> a_fresh (inPorts' n ! i')", "have subset_hyp: \"lconsts (labelsOut n hyp) \\<subseteq> ?V\""], ["proof (prove)\nusing this:\n  lconsts (labelsOut n hyp) \\<subseteq> a_fresh (inPorts' n ! i')\n\ngoal (1 subgoal):\n 1. lconsts (labelsOut n hyp) \\<subseteq> a_fresh (inPorts' n ! i')", "."], ["proof (state)\nthis:\n  lconsts (labelsOut n hyp) \\<subseteq> a_fresh (inPorts' n ! i')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| hyps_for n (inPorts' n ! i') \\<Longrightarrow>\n       subst\n        (subst_renameLCs\n          (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n        (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n          (freshen i (labelsOut n x))) =\n       subst (subst_renameLCs f s) (freshen (isidx is) (labelsOut n x))", "show \"subst (subst_renameLCs ?f' s) (renameLCs ?f' (freshen i (labelsOut n hyp))) =\n            subst (subst_renameLCs f s)  (freshen (isidx is) (labelsOut n hyp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\n     (subst_renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n       s)\n     (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n       (freshen i (labelsOut n hyp))) =\n    subst (subst_renameLCs f s) (freshen (isidx is) (labelsOut n hyp))", "apply (simp add: freshen_def rename_rename  rerename_subst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (subst_renameLCs f s)\n     (renameLCs\n       (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f \\<circ>\n        freshenLC i)\n       (labelsOut n hyp)) =\n    subst (subst_renameLCs f s)\n     (renameLCs (freshenLC (isidx is)) (labelsOut n hyp))", "apply (rule arg_cong[OF renameLCs_cong])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lconsts (labelsOut n hyp) \\<Longrightarrow>\n       (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f \\<circ>\n        freshenLC i)\n        x =\n       freshenLC (isidx is) x", "apply (auto dest: subsetD[OF subset_hyp])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst\n   (subst_renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n   (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n     (freshen i (labelsOut n hyp))) =\n  subst (subst_renameLCs f s) (freshen (isidx is) (labelsOut n hyp))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      subst\n       (subst_renameLCs\n         (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n       (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n         (freshen i (labelsOut n x)))) |`|\n  hyps_for n (inPorts' n ! i') =\n  (\\<lambda>h.\n      subst (subst_renameLCs f s) (freshen (isidx is) (labelsOut n h))) |`|\n  hyps_for n (inPorts' n ! i')\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "also"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      subst\n       (subst_renameLCs\n         (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n       (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n         (freshen i (labelsOut n x)))) |`|\n  hyps_for n (inPorts' n ! i') =\n  (\\<lambda>h.\n      subst (subst_renameLCs f s) (freshen (isidx is) (labelsOut n h))) |`|\n  hyps_for n (inPorts' n ! i')\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "have \"renameLCs ?f' (subst s (freshen i (a_conc ?ip))) = subst (subst_renameLCs ?f' s) (renameLCs ?f' (freshen i (a_conc ?ip)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n     (subst s (freshen i (a_conc (inPorts' n ! i')))) =\n    subst\n     (subst_renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n       s)\n     (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n       (freshen i (a_conc (inPorts' n ! i'))))", "by (simp add: rename_subst)"], ["proof (state)\nthis:\n  renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n   (subst s (freshen i (a_conc (inPorts' n ! i')))) =\n  subst\n   (subst_renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n   (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n     (freshen i (a_conc (inPorts' n ! i'))))\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "also"], ["proof (state)\nthis:\n  renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n   (subst s (freshen i (a_conc (inPorts' n ! i')))) =\n  subst\n   (subst_renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n   (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n     (freshen i (a_conc (inPorts' n ! i'))))\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "have \"... = ?c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\n     (subst_renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n       s)\n     (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n       (freshen i (a_conc (inPorts' n ! i')))) =\n    subst (subst_renameLCs f s)\n     (freshen (isidx is) (labelsIn n (inPorts' n ! i')))", "apply (simp add: freshen_def rename_rename  rerename_subst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (subst_renameLCs f s)\n     (renameLCs\n       (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f \\<circ>\n        freshenLC i)\n       (a_conc (inPorts' n ! i'))) =\n    subst (subst_renameLCs f s)\n     (renameLCs (freshenLC (isidx is)) (a_conc (inPorts' n ! i')))", "apply (rule arg_cong[OF renameLCs_cong])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> lconsts (a_conc (inPorts' n ! i')) \\<Longrightarrow>\n       (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f \\<circ>\n        freshenLC i)\n        x =\n       freshenLC (isidx is) x", "apply (auto dest: subsetD[OF subset_conc])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst\n   (subst_renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) s)\n   (renameLCs (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f)\n     (freshen i (a_conc (inPorts' n ! i')))) =\n  subst (subst_renameLCs f s)\n   (freshen (isidx is) (labelsIn n (inPorts' n ! i')))\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "finally"], ["proof (chain)\npicking this:\n  plain_iwf\n   (globalize (is @ [i'])\n     (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) (ants ! i'))\n   ((\\<lambda>h.\n        subst (subst_renameLCs f s)\n         (freshen (isidx is) (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! i') |\\<union>|\n    renameLCs f |`| \\<Gamma> \\<turnstile>\n    subst (subst_renameLCs f s)\n     (freshen (isidx is) (labelsIn n (inPorts' n ! i'))))", "have \"plain_iwf ?t (?\\<Gamma>' |\\<union>| renameLCs f |`| \\<Gamma> \\<turnstile> ?c')\""], ["proof (prove)\nusing this:\n  plain_iwf\n   (globalize (is @ [i'])\n     (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) (ants ! i'))\n   ((\\<lambda>h.\n        subst (subst_renameLCs f s)\n         (freshen (isidx is) (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! i') |\\<union>|\n    renameLCs f |`| \\<Gamma> \\<turnstile>\n    subst (subst_renameLCs f s)\n     (freshen (isidx is) (labelsIn n (inPorts' n ! i'))))\n\ngoal (1 subgoal):\n 1. plain_iwf\n     (globalize (is @ [i'])\n       (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) (ants ! i'))\n     ((\\<lambda>h.\n          subst (subst_renameLCs f s)\n           (freshen (isidx is) (labelsOut n h))) |`|\n      hyps_for n (inPorts' n ! i') |\\<union>|\n      renameLCs f |`| \\<Gamma> \\<turnstile>\n      subst (subst_renameLCs f s)\n       (freshen (isidx is) (labelsIn n (inPorts' n ! i'))))", "."], ["proof (state)\nthis:\n  plain_iwf\n   (globalize (is @ [i'])\n     (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) (ants ! i'))\n   ((\\<lambda>h.\n        subst (subst_renameLCs f s)\n         (freshen (isidx is) (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! i') |\\<union>|\n    renameLCs f |`| \\<Gamma> \\<turnstile>\n    subst (subst_renameLCs f s)\n     (freshen (isidx is) (labelsIn n (inPorts' n ! i'))))\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "}"], ["proof (state)\nthis:\n  ?i'9 < length (inPorts' n) \\<Longrightarrow>\n  plain_iwf\n   (globalize (is @ [?i'9])\n     (rerename (a_fresh (inPorts' n ! ?i'9)) i (isidx is) f) (ants ! ?i'9))\n   ((\\<lambda>h.\n        subst (subst_renameLCs f s)\n         (freshen (isidx is) (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! ?i'9) |\\<union>|\n    renameLCs f |`| \\<Gamma> \\<turnstile>\n    subst (subst_renameLCs f s)\n     (freshen (isidx is) (labelsIn n (inPorts' n ! ?i'9))))\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "with list_all2_lengthD[OF \\<open>list_all2 _ _ _\\<close>]"], ["proof (chain)\npicking this:\n  length (inPorts' n) = length ants\n  ?i'9 < length (inPorts' n) \\<Longrightarrow>\n  plain_iwf\n   (globalize (is @ [?i'9])\n     (rerename (a_fresh (inPorts' n ! ?i'9)) i (isidx is) f) (ants ! ?i'9))\n   ((\\<lambda>h.\n        subst (subst_renameLCs f s)\n         (freshen (isidx is) (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! ?i'9) |\\<union>|\n    renameLCs f |`| \\<Gamma> \\<turnstile>\n    subst (subst_renameLCs f s)\n     (freshen (isidx is) (labelsIn n (inPorts' n ! ?i'9))))", "have \"list_all2\n     (\\<lambda>ip t. plain_iwf t ((\\<lambda>h. subst (subst_renameLCs f s)\n       (freshen (isidx is) (labelsOut n h))) |`| hyps_for n ip |\\<union>|  renameLCs f |`| \\<Gamma> \\<turnstile> subst (subst_renameLCs f s) (freshen (isidx is) (labelsIn n ip))))\n     (inPorts' n)\n     (mapWithIndex (\\<lambda> i' t. globalize (is@[i']) (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f) t) ants)\""], ["proof (prove)\nusing this:\n  length (inPorts' n) = length ants\n  ?i'9 < length (inPorts' n) \\<Longrightarrow>\n  plain_iwf\n   (globalize (is @ [?i'9])\n     (rerename (a_fresh (inPorts' n ! ?i'9)) i (isidx is) f) (ants ! ?i'9))\n   ((\\<lambda>h.\n        subst (subst_renameLCs f s)\n         (freshen (isidx is) (labelsOut n h))) |`|\n    hyps_for n (inPorts' n ! ?i'9) |\\<union>|\n    renameLCs f |`| \\<Gamma> \\<turnstile>\n    subst (subst_renameLCs f s)\n     (freshen (isidx is) (labelsIn n (inPorts' n ! ?i'9))))\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>ip t.\n         plain_iwf t\n          ((\\<lambda>h.\n               subst (subst_renameLCs f s)\n                (freshen (isidx is) (labelsOut n h))) |`|\n           hyps_for n ip |\\<union>|\n           renameLCs f |`| \\<Gamma> \\<turnstile>\n           subst (subst_renameLCs f s)\n            (freshen (isidx is) (labelsIn n ip))))\n     (inPorts' n)\n     (mapWithIndex\n       (\\<lambda>i'.\n           globalize (is @ [i'])\n            (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f))\n       ants)", "by (auto simp add: list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>ip t.\n       plain_iwf t\n        ((\\<lambda>h.\n             subst (subst_renameLCs f s)\n              (freshen (isidx is) (labelsOut n h))) |`|\n         hyps_for n ip |\\<union>|\n         renameLCs f |`| \\<Gamma> \\<turnstile>\n         subst (subst_renameLCs f s) (freshen (isidx is) (labelsIn n ip))))\n   (inPorts' n)\n   (mapWithIndex\n     (\\<lambda>i'.\n         globalize (is @ [i'])\n          (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f))\n     ants)\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "moreover"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>ip t.\n       plain_iwf t\n        ((\\<lambda>h.\n             subst (subst_renameLCs f s)\n              (freshen (isidx is) (labelsOut n h))) |`|\n         hyps_for n ip |\\<union>|\n         renameLCs f |`| \\<Gamma> \\<turnstile>\n         subst (subst_renameLCs f s) (freshen (isidx is) (labelsIn n ip))))\n   (inPorts' n)\n   (mapWithIndex\n     (\\<lambda>i'.\n         globalize (is @ [i'])\n          (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f))\n     ants)\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "have \"no_fresh_check n (isidx is) (subst_renameLCs f s) (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_fresh_check n (isidx is) (subst_renameLCs f s)\n     (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)", ".."], ["proof (state)\nthis:\n  no_fresh_check n (isidx is) (subst_renameLCs f s)\n   (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "moreover"], ["proof (state)\nthis:\n  no_fresh_check n (isidx is) (subst_renameLCs f s)\n   (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "from \\<open>n \\<in> sset nodes\\<close> \\<open>Reg p |\\<in>| outPorts n\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> sset nodes\n  Reg p |\\<in>| outPorts n", "have \"lconsts p = {}\""], ["proof (prove)\nusing this:\n  n \\<in> sset nodes\n  Reg p |\\<in>| outPorts n\n\ngoal (1 subgoal):\n 1. lconsts p = {}", "by (rule no_local_consts_in_consequences')"], ["proof (state)\nthis:\n  lconsts p = {}\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "with \\<open>c = subst s (freshen i p)\\<close>"], ["proof (chain)\npicking this:\n  c = subst s (freshen i p)\n  lconsts p = {}", "have \"renameLCs f c = subst (subst_renameLCs f s) (freshen (isidx is) p)\""], ["proof (prove)\nusing this:\n  c = subst s (freshen i p)\n  lconsts p = {}\n\ngoal (1 subgoal):\n 1. renameLCs f c = subst (subst_renameLCs f s) (freshen (isidx is) p)", "by (simp add: rename_subst rename_closed freshen_closed)"], ["proof (state)\nthis:\n  renameLCs f c = subst (subst_renameLCs f s) (freshen (isidx is) p)\n\ngoal (2 subgoals):\n 1. \\<And>n p s i \\<Gamma> ants c is f.\n       \\<lbrakk>n \\<in> sset nodes; Reg p |\\<in>| outPorts n;\n        list_all2\n         (\\<lambda>ip t.\n             local_iwf t\n              ((\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n               hyps_for n ip |\\<union>|\n               \\<Gamma> \\<turnstile>\n               subst s (freshen i (labelsIn n ip))) \\<and>\n             (\\<forall>x xa.\n                 (\\<lambda>h. subst s (freshen i (labelsOut n h))) |`|\n                 hyps_for n ip |\\<union>|\n                 \\<Gamma> =\n                 x \\<and>\n                 subst s (freshen i (labelsIn n ip)) = xa \\<longrightarrow>\n                 (\\<forall>xb xc.\n                     plain_iwf (globalize xb xc t)\n                      (renameLCs xc |`| x \\<turnstile> renameLCs xc xa))))\n         (inPorts' n) ants;\n        local_fresh_check n i s (\\<Gamma> \\<turnstile> c);\n        c = subst s (freshen i p)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (INode n p i s ants))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)\n 2. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "ultimately"], ["proof (chain)\npicking this:\n  n \\<in> sset nodes\n  Reg p |\\<in>| outPorts n\n  list_all2\n   (\\<lambda>ip t.\n       plain_iwf t\n        ((\\<lambda>h.\n             subst (subst_renameLCs f s)\n              (freshen (isidx is) (labelsOut n h))) |`|\n         hyps_for n ip |\\<union>|\n         renameLCs f |`| \\<Gamma> \\<turnstile>\n         subst (subst_renameLCs f s) (freshen (isidx is) (labelsIn n ip))))\n   (inPorts' n)\n   (mapWithIndex\n     (\\<lambda>i'.\n         globalize (is @ [i'])\n          (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f))\n     ants)\n  no_fresh_check n (isidx is) (subst_renameLCs f s)\n   (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)\n  renameLCs f c = subst (subst_renameLCs f s) (freshen (isidx is) p)", "show ?case"], ["proof (prove)\nusing this:\n  n \\<in> sset nodes\n  Reg p |\\<in>| outPorts n\n  list_all2\n   (\\<lambda>ip t.\n       plain_iwf t\n        ((\\<lambda>h.\n             subst (subst_renameLCs f s)\n              (freshen (isidx is) (labelsOut n h))) |`|\n         hyps_for n ip |\\<union>|\n         renameLCs f |`| \\<Gamma> \\<turnstile>\n         subst (subst_renameLCs f s) (freshen (isidx is) (labelsIn n ip))))\n   (inPorts' n)\n   (mapWithIndex\n     (\\<lambda>i'.\n         globalize (is @ [i'])\n          (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f))\n     ants)\n  no_fresh_check n (isidx is) (subst_renameLCs f s)\n   (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)\n  renameLCs f c = subst (subst_renameLCs f s) (freshen (isidx is) p)\n\ngoal (1 subgoal):\n 1. plain_iwf (globalize is f (INode n p i s ants))\n     (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)", "unfolding globalize.simps globalize_node.simps iNodeOf.simps iAnnot.simps itnode.sel rose_tree.sel  Let_def"], ["proof (prove)\nusing this:\n  n \\<in> sset nodes\n  Reg p |\\<in>| outPorts n\n  list_all2\n   (\\<lambda>ip t.\n       plain_iwf t\n        ((\\<lambda>h.\n             subst (subst_renameLCs f s)\n              (freshen (isidx is) (labelsOut n h))) |`|\n         hyps_for n ip |\\<union>|\n         renameLCs f |`| \\<Gamma> \\<turnstile>\n         subst (subst_renameLCs f s) (freshen (isidx is) (labelsIn n ip))))\n   (inPorts' n)\n   (mapWithIndex\n     (\\<lambda>i'.\n         globalize (is @ [i'])\n          (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f))\n     ants)\n  no_fresh_check n (isidx is) (subst_renameLCs f s)\n   (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)\n  renameLCs f c = subst (subst_renameLCs f s) (freshen (isidx is) p)\n\ngoal (1 subgoal):\n 1. plain_iwf\n     (INode n p (isidx is) (subst_renameLCs f s)\n       (mapWithIndex\n         (\\<lambda>i'.\n             globalize (is @ [i'])\n              (rerename (a_fresh (inPorts' n ! i')) i (isidx is) f))\n         ants))\n     (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)", "by (rule iwf.intros(1))"], ["proof (state)\nthis:\n  plain_iwf (globalize is f (INode n p i s ants))\n   (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)\n\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "case (iwfH c \\<Gamma> s i \"is\" f)"], ["proof (state)\nthis:\n  c |\\<notin>| ass_forms\n  c |\\<in>| \\<Gamma>\n  c = subst s (freshen i anyP)\n\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "from \\<open>c |\\<notin>| ass_forms\\<close>"], ["proof (chain)\npicking this:\n  c |\\<notin>| ass_forms", "have \"renameLCs f c |\\<notin>| ass_forms\""], ["proof (prove)\nusing this:\n  c |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. renameLCs f c |\\<notin>| ass_forms", "using assumptions_closed closed_no_lconsts lconsts_renameLCs rename_closed"], ["proof (prove)\nusing this:\n  c |\\<notin>| ass_forms\n  ?a \\<in> set assumptions \\<Longrightarrow> closed ?a\n  closed ?f \\<Longrightarrow> lconsts ?f = {}\n  lconsts (renameLCs ?p ?f) = ?p ` lconsts ?f\n  lconsts ?f = {} \\<Longrightarrow> renameLCs ?p ?f = ?f\n\ngoal (1 subgoal):\n 1. renameLCs f c |\\<notin>| ass_forms", "by fastforce"], ["proof (state)\nthis:\n  renameLCs f c |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "moreover"], ["proof (state)\nthis:\n  renameLCs f c |\\<notin>| ass_forms\n\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "from \\<open>c |\\<in>| \\<Gamma>\\<close>"], ["proof (chain)\npicking this:\n  c |\\<in>| \\<Gamma>", "have \"renameLCs f c |\\<in>| renameLCs f |`| \\<Gamma>\""], ["proof (prove)\nusing this:\n  c |\\<in>| \\<Gamma>\n\ngoal (1 subgoal):\n 1. renameLCs f c |\\<in>| renameLCs f |`| \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  renameLCs f c |\\<in>| renameLCs f |`| \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "moreover"], ["proof (state)\nthis:\n  renameLCs f c |\\<in>| renameLCs f |`| \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "from \\<open>c = subst s (freshen i anyP)\\<close>"], ["proof (chain)\npicking this:\n  c = subst s (freshen i anyP)", "have \"renameLCs f c = subst (subst_renameLCs f s)  (freshen (isidx is) anyP)\""], ["proof (prove)\nusing this:\n  c = subst s (freshen i anyP)\n\ngoal (1 subgoal):\n 1. renameLCs f c = subst (subst_renameLCs f s) (freshen (isidx is) anyP)", "by (metis freshen_closed lconsts_anyP rename_closed rename_subst)"], ["proof (state)\nthis:\n  renameLCs f c = subst (subst_renameLCs f s) (freshen (isidx is) anyP)\n\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> s i is f.\n       \\<lbrakk>c |\\<notin>| ass_forms; c |\\<in>| \\<Gamma>;\n        c = subst s (freshen i anyP)\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is f (HNode i s []))\n                          (renameLCs f |`| \\<Gamma> \\<turnstile>\n                           renameLCs f c)", "ultimately"], ["proof (chain)\npicking this:\n  renameLCs f c |\\<notin>| ass_forms\n  renameLCs f c |\\<in>| renameLCs f |`| \\<Gamma>\n  renameLCs f c = subst (subst_renameLCs f s) (freshen (isidx is) anyP)", "show \"plain_iwf (globalize is f (HNode i s [])) (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)\""], ["proof (prove)\nusing this:\n  renameLCs f c |\\<notin>| ass_forms\n  renameLCs f c |\\<in>| renameLCs f |`| \\<Gamma>\n  renameLCs f c = subst (subst_renameLCs f s) (freshen (isidx is) anyP)\n\ngoal (1 subgoal):\n 1. plain_iwf (globalize is f (HNode i s []))\n     (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)", "unfolding globalize.simps globalize_node.simps  mapWithIndex_Nil  Let_def"], ["proof (prove)\nusing this:\n  renameLCs f c |\\<notin>| ass_forms\n  renameLCs f c |\\<in>| renameLCs f |`| \\<Gamma>\n  renameLCs f c = subst (subst_renameLCs f s) (freshen (isidx is) anyP)\n\ngoal (1 subgoal):\n 1. plain_iwf (HNode (isidx is) (subst_renameLCs f s) [])\n     (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)", "by (rule iwf.intros(2))"], ["proof (state)\nthis:\n  plain_iwf (globalize is f (HNode i s []))\n   (renameLCs f |`| \\<Gamma> \\<turnstile> renameLCs f c)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition fresh_at where\n  \"fresh_at t xs =\n   (case rev xs of [] \\<Rightarrow> {}\n                 | (i#is') \\<Rightarrow> freshenLC (iAnnot (tree_at t (rev is'))) ` (a_fresh (inPorts' (iNodeOf (tree_at t (rev is'))) ! i)))\""], ["", "lemma fresh_at_Nil[simp]:\n  \"fresh_at t [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_at t [] = {}", "unfolding fresh_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case rev [] of [] \\<Rightarrow> {}\n     | i # is' \\<Rightarrow>\n         freshenLC (iAnnot (tree_at t (rev is'))) `\n         a_fresh (inPorts' (iNodeOf (tree_at t (rev is'))) ! i)) =\n    {}", "by simp"], ["", "lemma fresh_at_snoc[simp]:\n  \"fresh_at t (is@[i]) = freshenLC (iAnnot (tree_at t is)) ` (a_fresh (inPorts' (iNodeOf (tree_at t is)) ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_at t (is @ [i]) =\n    freshenLC (iAnnot (tree_at t is)) `\n    a_fresh (inPorts' (iNodeOf (tree_at t is)) ! i)", "unfolding fresh_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case rev (is @ [i]) of [] \\<Rightarrow> {}\n     | i # is' \\<Rightarrow>\n         freshenLC (iAnnot (tree_at t (rev is'))) `\n         a_fresh (inPorts' (iNodeOf (tree_at t (rev is'))) ! i)) =\n    freshenLC (iAnnot (tree_at t is)) `\n    a_fresh (inPorts' (iNodeOf (tree_at t is)) ! i)", "by simp"], ["", "lemma fresh_at_def':\n  \"fresh_at t is =\n   (if is = [] then {}\n    else freshenLC (iAnnot (tree_at t (butlast is))) ` (a_fresh (inPorts' (iNodeOf (tree_at t (butlast is))) ! last is)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_at t is =\n    (if is = [] then {}\n     else freshenLC (iAnnot (tree_at t (butlast is))) `\n          a_fresh (inPorts' (iNodeOf (tree_at t (butlast is))) ! last is))", "unfolding fresh_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case rev is of [] \\<Rightarrow> {}\n     | i # is' \\<Rightarrow>\n         freshenLC (iAnnot (tree_at t (rev is'))) `\n         a_fresh (inPorts' (iNodeOf (tree_at t (rev is'))) ! i)) =\n    (if is = [] then {}\n     else freshenLC (iAnnot (tree_at t (butlast is))) `\n          a_fresh (inPorts' (iNodeOf (tree_at t (butlast is))) ! last is))", "by (auto split: list.split)"], ["", "lemma fresh_at_Cons[simp]:\n  \"fresh_at t (i#is) = (if is = [] then freshenLC (iAnnot t) ` (a_fresh (inPorts' (iNodeOf t) ! i)) else (let t' = iAnts t ! i in fresh_at t' is))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_at t (i # is) =\n    (if is = []\n     then freshenLC (iAnnot t) ` a_fresh (inPorts' (iNodeOf t) ! i)\n     else let t' = iAnts t ! i in fresh_at t' is)", "unfolding fresh_at_def'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i # is = [] then {}\n     else freshenLC (iAnnot (tree_at t (butlast (i # is)))) `\n          a_fresh\n           (inPorts' (iNodeOf (tree_at t (butlast (i # is)))) !\n            last (i # is))) =\n    (if is = []\n     then freshenLC (iAnnot t) ` a_fresh (inPorts' (iNodeOf t) ! i)\n     else let t' = iAnts t ! i\n          in if is = [] then {}\n             else freshenLC (iAnnot (tree_at t' (butlast is))) `\n                  a_fresh\n                   (inPorts' (iNodeOf (tree_at t' (butlast is))) ! last is))", "by (auto simp add: Let_def)"], ["", "definition fresh_at_path where\n  \"fresh_at_path t is = \\<Union>(fresh_at t ` set (prefixes is))\""], ["", "lemma fresh_at_path_Nil[simp]:\n  \"fresh_at_path t [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_at_path t [] = {}", "unfolding fresh_at_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (fresh_at t ` set (prefixes [])) = {}", "by simp"], ["", "lemma fresh_at_path_Cons[simp]:\n  \"fresh_at_path t (i#is) = fresh_at t [i] \\<union> fresh_at_path (iAnts t ! i) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_at_path t (i # is) =\n    fresh_at t [i] \\<union> fresh_at_path (iAnts t ! i) is", "unfolding fresh_at_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (fresh_at t ` set (prefixes (i # is))) =\n    fresh_at t [i] \\<union>\n    \\<Union> (fresh_at (iAnts t ! i) ` set (prefixes is))", "by (fastforce split: if_splits)"], ["", "lemma globalize_local_consts:\n  assumes \"is' \\<in> it_paths (globalize is f t)\"\n  shows \"subst_lconsts (iSubst (tree_at (globalize is f t) is')) \\<subseteq>\n    fresh_at_path (globalize is f t) is' \\<union> range f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_lconsts (iSubst (tree_at (globalize is f t) is'))\n    \\<subseteq> fresh_at_path (globalize is f t) is' \\<union> range f", "using assms"], ["proof (prove)\nusing this:\n  is' \\<in> it_paths (globalize is f t)\n\ngoal (1 subgoal):\n 1. subst_lconsts (iSubst (tree_at (globalize is f t) is'))\n    \\<subseteq> fresh_at_path (globalize is f t) is' \\<union> range f", "apply (induction \"is\" f t  arbitrary: is' rule:globalize.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is f r ants is'.\n       \\<lbrakk>\\<And>x i is'.\n                   \\<lbrakk>x \\<in> set ants;\n                    is'\n                    \\<in> it_paths\n                           (globalize (is @ [i])\n                             (rerename\n                               (a_fresh\n                                 (inPorts' (iNodeOf (RNode r ants)) ! i))\n                               (iAnnot (RNode r ants)) (isidx is) f)\n                             x)\\<rbrakk>\n                   \\<Longrightarrow> subst_lconsts\n(iSubst\n  (tree_at\n    (globalize (is @ [i])\n      (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n        (iAnnot (RNode r ants)) (isidx is) f)\n      x)\n    is'))\n                                     \\<subseteq> fresh_at_path\n            (globalize (is @ [i])\n              (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n                (iAnnot (RNode r ants)) (isidx is) f)\n              x)\n            is' \\<union>\n           range\n            (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n              (iAnnot (RNode r ants)) (isidx is) f);\n        is' \\<in> it_paths (globalize is f (RNode r ants))\\<rbrakk>\n       \\<Longrightarrow> subst_lconsts\n                          (iSubst\n                            (tree_at (globalize is f (RNode r ants)) is'))\n                         \\<subseteq> fresh_at_path\n(globalize is f (RNode r ants)) is' \\<union>\n                                     range f", "apply (rename_tac \"is\" f r ants is')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is f r ants is'.\n       \\<lbrakk>\\<And>x i is'.\n                   \\<lbrakk>x \\<in> set ants;\n                    is'\n                    \\<in> it_paths\n                           (globalize (is @ [i])\n                             (rerename\n                               (a_fresh\n                                 (inPorts' (iNodeOf (RNode r ants)) ! i))\n                               (iAnnot (RNode r ants)) (isidx is) f)\n                             x)\\<rbrakk>\n                   \\<Longrightarrow> subst_lconsts\n(iSubst\n  (tree_at\n    (globalize (is @ [i])\n      (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n        (iAnnot (RNode r ants)) (isidx is) f)\n      x)\n    is'))\n                                     \\<subseteq> fresh_at_path\n            (globalize (is @ [i])\n              (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n                (iAnnot (RNode r ants)) (isidx is) f)\n              x)\n            is' \\<union>\n           range\n            (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n              (iAnnot (RNode r ants)) (isidx is) f);\n        is' \\<in> it_paths (globalize is f (RNode r ants))\\<rbrakk>\n       \\<Longrightarrow> subst_lconsts\n                          (iSubst\n                            (tree_at (globalize is f (RNode r ants)) is'))\n                         \\<subseteq> fresh_at_path\n(globalize is f (RNode r ants)) is' \\<union>\n                                     range f", "apply (case_tac r)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is f r ants is' x11 x12 x13 x14.\n       \\<lbrakk>\\<And>x i is'.\n                   \\<lbrakk>x \\<in> set ants;\n                    is'\n                    \\<in> it_paths\n                           (globalize (is @ [i])\n                             (rerename\n                               (a_fresh\n                                 (inPorts' (iNodeOf (RNode r ants)) ! i))\n                               (iAnnot (RNode r ants)) (isidx is) f)\n                             x)\\<rbrakk>\n                   \\<Longrightarrow> subst_lconsts\n(iSubst\n  (tree_at\n    (globalize (is @ [i])\n      (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n        (iAnnot (RNode r ants)) (isidx is) f)\n      x)\n    is'))\n                                     \\<subseteq> fresh_at_path\n            (globalize (is @ [i])\n              (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n                (iAnnot (RNode r ants)) (isidx is) f)\n              x)\n            is' \\<union>\n           range\n            (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n              (iAnnot (RNode r ants)) (isidx is) f);\n        is' \\<in> it_paths (globalize is f (RNode r ants));\n        r = I x11 x12 x13 x14\\<rbrakk>\n       \\<Longrightarrow> subst_lconsts\n                          (iSubst\n                            (tree_at (globalize is f (RNode r ants)) is'))\n                         \\<subseteq> fresh_at_path\n(globalize is f (RNode r ants)) is' \\<union>\n                                     range f\n 2. \\<And>is f r ants is' x21 x22.\n       \\<lbrakk>\\<And>x i is'.\n                   \\<lbrakk>x \\<in> set ants;\n                    is'\n                    \\<in> it_paths\n                           (globalize (is @ [i])\n                             (rerename\n                               (a_fresh\n                                 (inPorts' (iNodeOf (RNode r ants)) ! i))\n                               (iAnnot (RNode r ants)) (isidx is) f)\n                             x)\\<rbrakk>\n                   \\<Longrightarrow> subst_lconsts\n(iSubst\n  (tree_at\n    (globalize (is @ [i])\n      (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n        (iAnnot (RNode r ants)) (isidx is) f)\n      x)\n    is'))\n                                     \\<subseteq> fresh_at_path\n            (globalize (is @ [i])\n              (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n                (iAnnot (RNode r ants)) (isidx is) f)\n              x)\n            is' \\<union>\n           range\n            (rerename (a_fresh (inPorts' (iNodeOf (RNode r ants)) ! i))\n              (iAnnot (RNode r ants)) (isidx is) f);\n        is' \\<in> it_paths (globalize is f (RNode r ants));\n        r = H x21 x22\\<rbrakk>\n       \\<Longrightarrow> subst_lconsts\n                          (iSubst\n                            (tree_at (globalize is f (RNode r ants)) is'))\n                         \\<subseteq> fresh_at_path\n(globalize is f (RNode r ants)) is' \\<union>\n                                     range f", "apply (auto simp add: subst_lconsts_subst_renameLCs  elim!: it_paths_RNodeE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>is f ants x11 x13 x i isa.\n       \\<lbrakk>\\<And>x i is'.\n                   \\<lbrakk>x \\<in> set ants;\n                    is'\n                    \\<in> it_paths\n                           (globalize (is @ [i])\n                             (rerename (a_fresh (inPorts' x11 ! i)) x13\n                               (isidx is) f)\n                             x)\\<rbrakk>\n                   \\<Longrightarrow> subst_lconsts\n(iSubst'\n  (root\n    (tree_at\n      (globalize (is @ [i])\n        (rerename (a_fresh (inPorts' x11 ! i)) x13 (isidx is) f) x)\n      is')))\n                                     \\<subseteq> fresh_at_path\n            (globalize (is @ [i])\n              (rerename (a_fresh (inPorts' x11 ! i)) x13 (isidx is) f) x)\n            is' \\<union>\n           range (rerename (a_fresh (inPorts' x11 ! i)) x13 (isidx is) f);\n        x \\<in> subst_lconsts\n                 (iSubst'\n                   (root\n                     (tree_at\n                       (globalize (is @ [i])\n                         (rerename (a_fresh (inPorts' x11 ! i)) x13\n                           (isidx is) f)\n                         (ants ! i))\n                       isa)));\n        x \\<notin> range f; i < length ants;\n        isa\n        \\<in> it_paths\n               (globalize (is @ [i])\n                 (rerename (a_fresh (inPorts' x11 ! i)) x13 (isidx is) f)\n                 (ants ! i));\n        x \\<notin> fresh_at_path\n                    (globalize (is @ [i])\n                      (rerename (a_fresh (inPorts' x11 ! i)) x13 (isidx is)\n                        f)\n                      (ants ! i))\n                    isa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> freshenLC (isidx is) `\n                                 a_fresh (inPorts' x11 ! i)\n 2. \\<And>is f ants x21 x i isa.\n       \\<lbrakk>\\<And>x i is'.\n                   \\<lbrakk>x \\<in> set ants;\n                    is'\n                    \\<in> it_paths\n                           (globalize (is @ [i])\n                             (rerename (a_fresh ([plain_ant anyP] ! i)) x21\n                               (isidx is) f)\n                             x)\\<rbrakk>\n                   \\<Longrightarrow> subst_lconsts\n(iSubst'\n  (root\n    (tree_at\n      (globalize (is @ [i])\n        (rerename (a_fresh ([plain_ant anyP] ! i)) x21 (isidx is) f) x)\n      is')))\n                                     \\<subseteq> fresh_at_path\n            (globalize (is @ [i])\n              (rerename (a_fresh ([plain_ant anyP] ! i)) x21 (isidx is) f)\n              x)\n            is' \\<union>\n           range\n            (rerename (a_fresh ([plain_ant anyP] ! i)) x21 (isidx is) f);\n        x \\<in> subst_lconsts\n                 (iSubst'\n                   (root\n                     (tree_at\n                       (globalize (is @ [i])\n                         (rerename (a_fresh ([plain_ant anyP] ! i)) x21\n                           (isidx is) f)\n                         (ants ! i))\n                       isa)));\n        x \\<notin> range f; i < length ants;\n        isa\n        \\<in> it_paths\n               (globalize (is @ [i])\n                 (rerename (a_fresh ([plain_ant anyP] ! i)) x21 (isidx is)\n                   f)\n                 (ants ! i));\n        x \\<notin> fresh_at_path\n                    (globalize (is @ [i])\n                      (rerename (a_fresh ([plain_ant anyP] ! i)) x21\n                        (isidx is) f)\n                      (ants ! i))\n                    isa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> freshenLC (isidx is) `\n                                 a_fresh ([plain_ant anyP] ! i)", "apply (solves \\<open>force dest!: subsetD[OF range_rerename]\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is f ants x21 x i isa.\n       \\<lbrakk>\\<And>x i is'.\n                   \\<lbrakk>x \\<in> set ants;\n                    is'\n                    \\<in> it_paths\n                           (globalize (is @ [i])\n                             (rerename (a_fresh ([plain_ant anyP] ! i)) x21\n                               (isidx is) f)\n                             x)\\<rbrakk>\n                   \\<Longrightarrow> subst_lconsts\n(iSubst'\n  (root\n    (tree_at\n      (globalize (is @ [i])\n        (rerename (a_fresh ([plain_ant anyP] ! i)) x21 (isidx is) f) x)\n      is')))\n                                     \\<subseteq> fresh_at_path\n            (globalize (is @ [i])\n              (rerename (a_fresh ([plain_ant anyP] ! i)) x21 (isidx is) f)\n              x)\n            is' \\<union>\n           range\n            (rerename (a_fresh ([plain_ant anyP] ! i)) x21 (isidx is) f);\n        x \\<in> subst_lconsts\n                 (iSubst'\n                   (root\n                     (tree_at\n                       (globalize (is @ [i])\n                         (rerename (a_fresh ([plain_ant anyP] ! i)) x21\n                           (isidx is) f)\n                         (ants ! i))\n                       isa)));\n        x \\<notin> range f; i < length ants;\n        isa\n        \\<in> it_paths\n               (globalize (is @ [i])\n                 (rerename (a_fresh ([plain_ant anyP] ! i)) x21 (isidx is)\n                   f)\n                 (ants ! i));\n        x \\<notin> fresh_at_path\n                    (globalize (is @ [i])\n                      (rerename (a_fresh ([plain_ant anyP] ! i)) x21\n                        (isidx is) f)\n                      (ants ! i))\n                    isa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> freshenLC (isidx is) `\n                                 a_fresh ([plain_ant anyP] ! i)", "apply (solves \\<open>force dest!: subsetD[OF range_rerename]\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iwf_globalize':\n  assumes \"local_iwf t ent\"\n  assumes \"\\<And> x. x |\\<in>| fst ent \\<Longrightarrow> closed x\"\n  assumes \"closed (snd ent)\"\n  shows \"plain_iwf (globalize is (freshenLC v_away) t) ent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plain_iwf (globalize is (freshenLC v_away) t) ent", "using assms"], ["proof (prove)\nusing this:\n  local_iwf t ent\n  ?x9 |\\<in>| fst ent \\<Longrightarrow> closed ?x9\n  closed (snd ent)\n\ngoal (1 subgoal):\n 1. plain_iwf (globalize is (freshenLC v_away) t) ent", "proof(induction ent rule: prod.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>local_iwf t (a \\<turnstile> b);\n        \\<And>x.\n           x |\\<in>| fst (a \\<turnstile> b) \\<Longrightarrow> closed x;\n        closed (snd (a \\<turnstile> b))\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is (freshenLC v_away) t)\n                          (a \\<turnstile> b)", "case (Pair \\<Gamma> c)"], ["proof (state)\nthis:\n  local_iwf t (\\<Gamma> \\<turnstile> c)\n  ?x9 |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<Longrightarrow> closed ?x9\n  closed (snd (\\<Gamma> \\<turnstile> c))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>local_iwf t (a \\<turnstile> b);\n        \\<And>x.\n           x |\\<in>| fst (a \\<turnstile> b) \\<Longrightarrow> closed x;\n        closed (snd (a \\<turnstile> b))\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is (freshenLC v_away) t)\n                          (a \\<turnstile> b)", "have \"plain_iwf (globalize is (freshenLC v_away) t) (renameLCs (freshenLC v_away) |`| \\<Gamma> \\<turnstile> renameLCs (freshenLC v_away) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plain_iwf (globalize is (freshenLC v_away) t)\n     (renameLCs (freshenLC v_away) |`| \\<Gamma> \\<turnstile>\n      renameLCs (freshenLC v_away) c)", "by (rule iwf_globalize[OF Pair(1)])"], ["proof (state)\nthis:\n  plain_iwf (globalize is (freshenLC v_away) t)\n   (renameLCs (freshenLC v_away) |`| \\<Gamma> \\<turnstile>\n    renameLCs (freshenLC v_away) c)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>local_iwf t (a \\<turnstile> b);\n        \\<And>x.\n           x |\\<in>| fst (a \\<turnstile> b) \\<Longrightarrow> closed x;\n        closed (snd (a \\<turnstile> b))\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is (freshenLC v_away) t)\n                          (a \\<turnstile> b)", "also"], ["proof (state)\nthis:\n  plain_iwf (globalize is (freshenLC v_away) t)\n   (renameLCs (freshenLC v_away) |`| \\<Gamma> \\<turnstile>\n    renameLCs (freshenLC v_away) c)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>local_iwf t (a \\<turnstile> b);\n        \\<And>x.\n           x |\\<in>| fst (a \\<turnstile> b) \\<Longrightarrow> closed x;\n        closed (snd (a \\<turnstile> b))\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is (freshenLC v_away) t)\n                          (a \\<turnstile> b)", "from Pair(3)"], ["proof (chain)\npicking this:\n  closed (snd (\\<Gamma> \\<turnstile> c))", "have \"closed c\""], ["proof (prove)\nusing this:\n  closed (snd (\\<Gamma> \\<turnstile> c))\n\ngoal (1 subgoal):\n 1. closed c", "by simp"], ["proof (state)\nthis:\n  closed c\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>local_iwf t (a \\<turnstile> b);\n        \\<And>x.\n           x |\\<in>| fst (a \\<turnstile> b) \\<Longrightarrow> closed x;\n        closed (snd (a \\<turnstile> b))\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is (freshenLC v_away) t)\n                          (a \\<turnstile> b)", "hence \"renameLCs (freshenLC v_away) c = c\""], ["proof (prove)\nusing this:\n  closed c\n\ngoal (1 subgoal):\n 1. renameLCs (freshenLC v_away) c = c", "by (simp add: closed_no_lconsts rename_closed)"], ["proof (state)\nthis:\n  renameLCs (freshenLC v_away) c = c\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>local_iwf t (a \\<turnstile> b);\n        \\<And>x.\n           x |\\<in>| fst (a \\<turnstile> b) \\<Longrightarrow> closed x;\n        closed (snd (a \\<turnstile> b))\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is (freshenLC v_away) t)\n                          (a \\<turnstile> b)", "also"], ["proof (state)\nthis:\n  renameLCs (freshenLC v_away) c = c\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>local_iwf t (a \\<turnstile> b);\n        \\<And>x.\n           x |\\<in>| fst (a \\<turnstile> b) \\<Longrightarrow> closed x;\n        closed (snd (a \\<turnstile> b))\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is (freshenLC v_away) t)\n                          (a \\<turnstile> b)", "from Pair(2)"], ["proof (chain)\npicking this:\n  ?x9 |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<Longrightarrow> closed ?x9", "have \"renameLCs (freshenLC v_away) |`| \\<Gamma> = \\<Gamma>\""], ["proof (prove)\nusing this:\n  ?x9 |\\<in>| fst (\\<Gamma> \\<turnstile> c) \\<Longrightarrow> closed ?x9\n\ngoal (1 subgoal):\n 1. renameLCs (freshenLC v_away) |`| \\<Gamma> = \\<Gamma>", "by (auto simp add: closed_no_lconsts rename_closed fmember.rep_eq image_iff)"], ["proof (state)\nthis:\n  renameLCs (freshenLC v_away) |`| \\<Gamma> = \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>local_iwf t (a \\<turnstile> b);\n        \\<And>x.\n           x |\\<in>| fst (a \\<turnstile> b) \\<Longrightarrow> closed x;\n        closed (snd (a \\<turnstile> b))\\<rbrakk>\n       \\<Longrightarrow> plain_iwf (globalize is (freshenLC v_away) t)\n                          (a \\<turnstile> b)", "finally"], ["proof (chain)\npicking this:\n  plain_iwf (globalize is (freshenLC v_away) t) (\\<Gamma> \\<turnstile> c)", "show ?case"], ["proof (prove)\nusing this:\n  plain_iwf (globalize is (freshenLC v_away) t) (\\<Gamma> \\<turnstile> c)\n\ngoal (1 subgoal):\n 1. plain_iwf (globalize is (freshenLC v_away) t) (\\<Gamma> \\<turnstile> c)", "."], ["proof (state)\nthis:\n  plain_iwf (globalize is (freshenLC v_away) t) (\\<Gamma> \\<turnstile> c)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}