{"file_name": "/home/qj213/afp-2021-10-22/thys/Containers/RBT_ext.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Containers", "problem_names": ["lemma is_rbt_fold_rbt_insert_impl:\n  \"is_rbt t \\<Longrightarrow> is_rbt (RBT_Impl.fold rbt_insert t' t)\"", "lemma rbt_sorted_fold_insert: \"rbt_sorted t \\<Longrightarrow> rbt_sorted (RBT_Impl.fold rbt_insert t' t)\"", "lemma rbt_lookup_rbt_insert': \"rbt_sorted t \\<Longrightarrow> rbt_lookup (rbt_insert k v t) = rbt_lookup t(k \\<mapsto> v)\"", "lemma rbt_lookup_fold_rbt_insert_impl:\n  \"rbt_sorted t2 \\<Longrightarrow> \n  rbt_lookup (RBT_Impl.fold rbt_insert t1 t2) = rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t1))\"", "lemma alist_product_simps [simp]:\n  \"alist_product [] ys = []\"\n  \"alist_product xs [] = []\"\n  \"alist_product ((a, b) # xs) ys = map (\\<lambda>(c, d). ((a, c), f a b c d)) ys @ alist_product xs ys\"", "lemma append_alist_product_conv_fold:\n  \"zs @ alist_product xs ys = rev (fold (\\<lambda>(a, b). fold (\\<lambda>(c, d) rest. ((a, c), f a b c d) # rest) ys) xs (rev zs))\"", "lemma alist_product_code [code]:\n  \"alist_product xs ys =\n  rev (fold (\\<lambda>(a, b). fold (\\<lambda>(c, d) rest. ((a, c), f a b c d) # rest) ys) xs [])\"", "lemma set_alist_product:\n  \"set (alist_product xs ys) =\n  (\\<lambda>((a, b), (c, d)). ((a, c), f a b c d)) ` (set xs \\<times> set ys)\"", "lemma distinct_alist_product:\n  \"\\<lbrakk> distinct (map fst xs); distinct (map fst ys) \\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (alist_product xs ys))\"", "lemma map_of_alist_product:\n  \"map_of (alist_product xs ys) (a, c) = \n  (case map_of xs a of None \\<Rightarrow> None\n   | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))\"", "lemma rbt_product_code [code]:\n  \"rbt_product rbt1 rbt2 =\n   rbtreeify (rev (RBT_Impl.fold (\\<lambda>a b. RBT_Impl.fold (\\<lambda>c d rest. ((a, c), f a b c d) # rest) rbt2) rbt1 []))\"", "lemmas linorder_prod = linorder_prod[OF lin_a lin_b]", "lemma sorted_alist_product: \n  assumes xs: \"linorder.sorted leq_a (map fst xs)\" \"distinct (map fst xs)\"\n  and ys: \"linorder.sorted (\\<sqsubseteq>\\<^sub>b) (map fst ys)\"\n  shows \"linorder.sorted (\\<sqsubseteq>) (map fst (alist_product f xs ys))\"", "lemma is_rbt_rbt_product:\n  \"\\<lbrakk> ord.is_rbt (\\<sqsubset>\\<^sub>a) rbt1; ord.is_rbt (\\<sqsubset>\\<^sub>b) rbt2 \\<rbrakk>\n  \\<Longrightarrow> ord.is_rbt (\\<sqsubset>) (rbt_product f rbt1 rbt2)\"", "lemma rbt_lookup_rbt_product:\n  \"\\<lbrakk> ord.is_rbt (\\<sqsubset>\\<^sub>a) rbt1; ord.is_rbt (\\<sqsubset>\\<^sub>b) rbt2 \\<rbrakk>\n  \\<Longrightarrow> ord.rbt_lookup (\\<sqsubset>) (rbt_product f rbt1 rbt2) (a, c) =\n     (case ord.rbt_lookup (\\<sqsubset>\\<^sub>a) rbt1 a of None \\<Rightarrow> None\n      | Some b \\<Rightarrow> map_option (f a b c) (ord.rbt_lookup (\\<sqsubset>\\<^sub>b) rbt2 c))\"", "lemma entries_RBT_Impl_diag:\n  \"RBT_Impl.entries (RBT_Impl_diag t) = map (\\<lambda>(k, v). ((k, k), v)) (RBT_Impl.entries t)\"", "lemma keys_RBT_Impl_diag:\n  \"RBT_Impl.keys (RBT_Impl_diag t) = map (\\<lambda>k. (k, k)) (RBT_Impl.keys t)\"", "lemma rbt_sorted_RBT_Impl_diag:\n  \"ord.rbt_sorted lt t \\<Longrightarrow> ord.rbt_sorted (less_prod leq lt lt) (RBT_Impl_diag t)\"", "lemma bheight_RBT_Impl_diag:\n  \"bheight (RBT_Impl_diag t) = bheight t\"", "lemma inv_RBT_Impl_diag:\n  assumes \"inv1 t\" \"inv2 t\"\n  shows \"inv1 (RBT_Impl_diag t)\" \"inv2 (RBT_Impl_diag t)\"\n  and \"color_of t = color.B \\<Longrightarrow> color_of (RBT_Impl_diag t) = color.B\"", "lemma is_rbt_RBT_Impl_diag:\n  \"ord.is_rbt lt t \\<Longrightarrow> ord.is_rbt (less_prod leq lt lt) (RBT_Impl_diag t)\"", "lemma (in linorder) rbt_lookup_RBT_Impl_diag:\n  \"ord.rbt_lookup (less_prod (\\<le>) (<) (<)) (RBT_Impl_diag t) =\n  (\\<lambda>(k, k'). if k = k' then ord.rbt_lookup (<) t k else None)\"", "lemma RBT_Impl_fold1_simps [simp, code]:\n  \"RBT_Impl_fold1 f rbt.Empty = undefined\"\n  \"RBT_Impl_fold1 f (Branch c rbt.Empty k v r) = RBT_Impl.fold (\\<lambda>k v. f k) r k\"\n  \"RBT_Impl_fold1 f (Branch c (Branch c' l' k' v' r') k v r) = \n   RBT_Impl.fold (\\<lambda>k v. f k) r (f k (RBT_Impl_fold1 f (Branch c' l' k' v' r')))\"", "lemma RBT_Impl_rbt_all_simps [simp, code]:\n  \"RBT_Impl_rbt_all P rbt.Empty \\<longleftrightarrow> True\"\n  \"RBT_Impl_rbt_all P (Branch c l k v r) \\<longleftrightarrow> P k v \\<and> RBT_Impl_rbt_all P l \\<and> RBT_Impl_rbt_all P r\"", "lemma RBT_Impl_rbt_ex_simps [simp, code]:\n  \"RBT_Impl_rbt_ex P rbt.Empty \\<longleftrightarrow> False\"\n  \"RBT_Impl_rbt_ex P (Branch c l k v r) \\<longleftrightarrow> P k v \\<or> RBT_Impl_rbt_ex P l \\<or> RBT_Impl_rbt_ex P r\"", "lemma rbt_generator_induct [case_names empty split shuffle]:\n  assumes \"P ([], rbt.Empty)\"\n  and \"\\<And>k t kts. P (kts, t) \\<Longrightarrow> P ((k, t) # kts, rbt.Empty)\"\n  and \"\\<And>kts c l k v r. P ((f k v, r) # kts, l) \\<Longrightarrow> P (kts, Branch c l k v r)\"\n  shows \"P ktst\"", "lemma terminates_rbt_keys_generator:\n  \"terminates (rbt_has_next, rbt_keys_next)\"", "lemma has_next_rbt_keys_generator [simp]:\n  \"list.has_next rbt_keys_generator = rbt_has_next\"", "lemma next_rbt_keys_generator [simp]:\n  \"list.next rbt_keys_generator = rbt_keys_next\"", "lemma unfoldr_rbt_keys_generator_aux:\n  \"list.unfoldr rbt_keys_generator (kts, t) = \n  RBT_Impl.keys t @ concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts)\"", "lemma terminates_rbt_entries_generator:\n  \"terminates (rbt_has_next, rbt_entries_next)\"", "lemma has_next_rbt_entries_generator [simp]:\n  \"list.has_next rbt_entries_generator = rbt_has_next\"", "lemma next_rbt_entries_generator [simp]:\n  \"list.next rbt_entries_generator = rbt_entries_next\"", "lemma unfoldr_rbt_entries_generator_aux:\n  \"list.unfoldr rbt_entries_generator (kts, t) = \n  RBT_Impl.entries t @ concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts)\""], "translations": [["", "lemma is_rbt_fold_rbt_insert_impl:\n  \"is_rbt t \\<Longrightarrow> is_rbt (RBT_Impl.fold rbt_insert t' t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rbt t \\<Longrightarrow> is_rbt (RBT_Impl.fold rbt_insert t' t)", "by(simp add: rbt_insert_def is_rbt_fold_rbt_insertwk)"], ["", "lemma rbt_sorted_fold_insert: \"rbt_sorted t \\<Longrightarrow> rbt_sorted (RBT_Impl.fold rbt_insert t' t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_sorted (RBT_Impl.fold rbt_insert t' t)", "by(induct t' arbitrary: t)(simp_all add: rbt_insert_rbt_sorted)"], ["", "lemma rbt_lookup_rbt_insert': \"rbt_sorted t \\<Longrightarrow> rbt_lookup (rbt_insert k v t) = rbt_lookup t(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t \\<Longrightarrow>\n    rbt_lookup (rbt_insert k v t) = rbt_lookup t(k \\<mapsto> v)", "by(simp add: rbt_insert_def rbt_lookup_rbt_insertwk fun_eq_iff split: option.split)"], ["", "lemma rbt_lookup_fold_rbt_insert_impl:\n  \"rbt_sorted t2 \\<Longrightarrow> \n  rbt_lookup (RBT_Impl.fold rbt_insert t1 t2) = rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_sorted t2 \\<Longrightarrow>\n    rbt_lookup (RBT_Impl.fold rbt_insert t1 t2) =\n    rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t1))", "proof(induction t1 arbitrary: t2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t2.\n       rbt_sorted t2 \\<Longrightarrow>\n       rbt_lookup (RBT_Impl.fold rbt_insert rbt.Empty t2) =\n       rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries rbt.Empty))\n 2. \\<And>x1 t11 x3 x4 t12 t2.\n       \\<lbrakk>\\<And>t2.\n                   rbt_sorted t2 \\<Longrightarrow>\n                   rbt_lookup (RBT_Impl.fold rbt_insert t11 t2) =\n                   rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t11));\n        \\<And>t2.\n           rbt_sorted t2 \\<Longrightarrow>\n           rbt_lookup (RBT_Impl.fold rbt_insert t12 t2) =\n           rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t12));\n        rbt_sorted t2\\<rbrakk>\n       \\<Longrightarrow> rbt_lookup\n                          (RBT_Impl.fold rbt_insert\n                            (Branch x1 t11 x3 x4 t12) t2) =\n                         rbt_lookup t2 ++\n                         map_of\n                          (rev (RBT_Impl.entries (Branch x1 t11 x3 x4 t12)))", "case Empty"], ["proof (state)\nthis:\n  rbt_sorted t2\n\ngoal (2 subgoals):\n 1. \\<And>t2.\n       rbt_sorted t2 \\<Longrightarrow>\n       rbt_lookup (RBT_Impl.fold rbt_insert rbt.Empty t2) =\n       rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries rbt.Empty))\n 2. \\<And>x1 t11 x3 x4 t12 t2.\n       \\<lbrakk>\\<And>t2.\n                   rbt_sorted t2 \\<Longrightarrow>\n                   rbt_lookup (RBT_Impl.fold rbt_insert t11 t2) =\n                   rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t11));\n        \\<And>t2.\n           rbt_sorted t2 \\<Longrightarrow>\n           rbt_lookup (RBT_Impl.fold rbt_insert t12 t2) =\n           rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t12));\n        rbt_sorted t2\\<rbrakk>\n       \\<Longrightarrow> rbt_lookup\n                          (RBT_Impl.fold rbt_insert\n                            (Branch x1 t11 x3 x4 t12) t2) =\n                         rbt_lookup t2 ++\n                         map_of\n                          (rev (RBT_Impl.entries (Branch x1 t11 x3 x4 t12)))", "thus ?case"], ["proof (prove)\nusing this:\n  rbt_sorted t2\n\ngoal (1 subgoal):\n 1. rbt_lookup (RBT_Impl.fold rbt_insert rbt.Empty t2) =\n    rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries rbt.Empty))", "by simp"], ["proof (state)\nthis:\n  rbt_lookup (RBT_Impl.fold rbt_insert rbt.Empty t2) =\n  rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries rbt.Empty))\n\ngoal (1 subgoal):\n 1. \\<And>x1 t11 x3 x4 t12 t2.\n       \\<lbrakk>\\<And>t2.\n                   rbt_sorted t2 \\<Longrightarrow>\n                   rbt_lookup (RBT_Impl.fold rbt_insert t11 t2) =\n                   rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t11));\n        \\<And>t2.\n           rbt_sorted t2 \\<Longrightarrow>\n           rbt_lookup (RBT_Impl.fold rbt_insert t12 t2) =\n           rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t12));\n        rbt_sorted t2\\<rbrakk>\n       \\<Longrightarrow> rbt_lookup\n                          (RBT_Impl.fold rbt_insert\n                            (Branch x1 t11 x3 x4 t12) t2) =\n                         rbt_lookup t2 ++\n                         map_of\n                          (rev (RBT_Impl.entries (Branch x1 t11 x3 x4 t12)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 t11 x3 x4 t12 t2.\n       \\<lbrakk>\\<And>t2.\n                   rbt_sorted t2 \\<Longrightarrow>\n                   rbt_lookup (RBT_Impl.fold rbt_insert t11 t2) =\n                   rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t11));\n        \\<And>t2.\n           rbt_sorted t2 \\<Longrightarrow>\n           rbt_lookup (RBT_Impl.fold rbt_insert t12 t2) =\n           rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t12));\n        rbt_sorted t2\\<rbrakk>\n       \\<Longrightarrow> rbt_lookup\n                          (RBT_Impl.fold rbt_insert\n                            (Branch x1 t11 x3 x4 t12) t2) =\n                         rbt_lookup t2 ++\n                         map_of\n                          (rev (RBT_Impl.entries (Branch x1 t11 x3 x4 t12)))", "case (Branch c l x k r)"], ["proof (state)\nthis:\n  rbt_sorted ?t2.0 \\<Longrightarrow>\n  rbt_lookup (RBT_Impl.fold rbt_insert l ?t2.0) =\n  rbt_lookup ?t2.0 ++ map_of (rev (RBT_Impl.entries l))\n  rbt_sorted ?t2.0 \\<Longrightarrow>\n  rbt_lookup (RBT_Impl.fold rbt_insert r ?t2.0) =\n  rbt_lookup ?t2.0 ++ map_of (rev (RBT_Impl.entries r))\n  rbt_sorted t2\n\ngoal (1 subgoal):\n 1. \\<And>x1 t11 x3 x4 t12 t2.\n       \\<lbrakk>\\<And>t2.\n                   rbt_sorted t2 \\<Longrightarrow>\n                   rbt_lookup (RBT_Impl.fold rbt_insert t11 t2) =\n                   rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t11));\n        \\<And>t2.\n           rbt_sorted t2 \\<Longrightarrow>\n           rbt_lookup (RBT_Impl.fold rbt_insert t12 t2) =\n           rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries t12));\n        rbt_sorted t2\\<rbrakk>\n       \\<Longrightarrow> rbt_lookup\n                          (RBT_Impl.fold rbt_insert\n                            (Branch x1 t11 x3 x4 t12) t2) =\n                         rbt_lookup t2 ++\n                         map_of\n                          (rev (RBT_Impl.entries (Branch x1 t11 x3 x4 t12)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbt_lookup (RBT_Impl.fold rbt_insert (Branch c l x k r) t2) =\n    rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries (Branch c l x k r)))", "using Branch.prems"], ["proof (prove)\nusing this:\n  rbt_sorted t2\n\ngoal (1 subgoal):\n 1. rbt_lookup (RBT_Impl.fold rbt_insert (Branch c l x k r) t2) =\n    rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries (Branch c l x k r)))", "by(simp add: map_add_def Branch.IH rbt_insert_rbt_sorted rbt_sorted_fold_insert rbt_lookup_rbt_insert' fun_eq_iff split: option.split)"], ["proof (state)\nthis:\n  rbt_lookup (RBT_Impl.fold rbt_insert (Branch c l x k r) t2) =\n  rbt_lookup t2 ++ map_of (rev (RBT_Impl.entries (Branch c l x k r)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Build the cross product of two RBTs\\<close>"], ["", "context fixes f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd \\<Rightarrow> 'e\" begin"], ["", "definition alist_product :: \"('a \\<times> 'b) list \\<Rightarrow> ('c \\<times> 'd) list \\<Rightarrow> (('a \\<times> 'c) \\<times> 'e) list\"\nwhere \"alist_product xs ys = concat (map (\\<lambda>(a, b). map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) xs)\""], ["", "lemma alist_product_simps [simp]:\n  \"alist_product [] ys = []\"\n  \"alist_product xs [] = []\"\n  \"alist_product ((a, b) # xs) ys = map (\\<lambda>(c, d). ((a, c), f a b c d)) ys @ alist_product xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alist_product [] ys = [] &&&\n    local.alist_product xs [] = [] &&&\n    local.alist_product ((a, b) # xs) ys =\n    map (\\<lambda>(c, d). ((a, c), f a b c d)) ys @\n    local.alist_product xs ys", "by(simp_all add: alist_product_def)"], ["", "lemma append_alist_product_conv_fold:\n  \"zs @ alist_product xs ys = rev (fold (\\<lambda>(a, b). fold (\\<lambda>(c, d) rest. ((a, c), f a b c d) # rest) ys) xs (rev zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zs @ local.alist_product xs ys =\n    rev (fold\n          (\\<lambda>(a, b).\n              fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n          xs (rev zs))", "proof(induction xs arbitrary: zs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       zs @ local.alist_product [] ys =\n       rev (fold\n             (\\<lambda>(a, b).\n                 fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n             [] (rev zs))\n 2. \\<And>a xs zs.\n       (\\<And>zs.\n           zs @ local.alist_product xs ys =\n           rev (fold\n                 (\\<lambda>(a, b).\n                     fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n                 xs (rev zs))) \\<Longrightarrow>\n       zs @ local.alist_product (a # xs) ys =\n       rev (fold\n             (\\<lambda>(a, b).\n                 fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n             (a # xs) (rev zs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       zs @ local.alist_product [] ys =\n       rev (fold\n             (\\<lambda>(a, b).\n                 fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n             [] (rev zs))\n 2. \\<And>a xs zs.\n       (\\<And>zs.\n           zs @ local.alist_product xs ys =\n           rev (fold\n                 (\\<lambda>(a, b).\n                     fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n                 xs (rev zs))) \\<Longrightarrow>\n       zs @ local.alist_product (a # xs) ys =\n       rev (fold\n             (\\<lambda>(a, b).\n                 fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n             (a # xs) (rev zs))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. zs @ local.alist_product [] ys =\n    rev (fold\n          (\\<lambda>a.\n              case a of\n              (a, b) \\<Rightarrow>\n                fold\n                 (\\<lambda>c.\n                     case c of (c, d) \\<Rightarrow> (#) ((a, c), f a b c d))\n                 ys)\n          [] (rev zs))", "by simp"], ["proof (state)\nthis:\n  zs @ local.alist_product [] ys =\n  rev (fold\n        (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              fold\n               (\\<lambda>c.\n                   case c of (c, d) \\<Rightarrow> (#) ((a, c), f a b c d))\n               ys)\n        [] (rev zs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs zs.\n       (\\<And>zs.\n           zs @ local.alist_product xs ys =\n           rev (fold\n                 (\\<lambda>(a, b).\n                     fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n                 xs (rev zs))) \\<Longrightarrow>\n       zs @ local.alist_product (a # xs) ys =\n       rev (fold\n             (\\<lambda>(a, b).\n                 fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n             (a # xs) (rev zs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs zs.\n       (\\<And>zs.\n           zs @ local.alist_product xs ys =\n           rev (fold\n                 (\\<lambda>(a, b).\n                     fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n                 xs (rev zs))) \\<Longrightarrow>\n       zs @ local.alist_product (a # xs) ys =\n       rev (fold\n             (\\<lambda>(a, b).\n                 fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n             (a # xs) (rev zs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  ?zs @ local.alist_product xs ys =\n  rev (fold\n        (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              fold\n               (\\<lambda>c.\n                   case c of (c, d) \\<Rightarrow> (#) ((a, c), f a b c d))\n               ys)\n        xs (rev ?zs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs zs.\n       (\\<And>zs.\n           zs @ local.alist_product xs ys =\n           rev (fold\n                 (\\<lambda>(a, b).\n                     fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n                 xs (rev zs))) \\<Longrightarrow>\n       zs @ local.alist_product (a # xs) ys =\n       rev (fold\n             (\\<lambda>(a, b).\n                 fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n             (a # xs) (rev zs))", "obtain a b where x: \"x = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x)"], ["proof (state)\nthis:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>a xs zs.\n       (\\<And>zs.\n           zs @ local.alist_product xs ys =\n           rev (fold\n                 (\\<lambda>(a, b).\n                     fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n                 xs (rev zs))) \\<Longrightarrow>\n       zs @ local.alist_product (a # xs) ys =\n       rev (fold\n             (\\<lambda>(a, b).\n                 fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n             (a # xs) (rev zs))", "have \"\\<And>zs. fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys zs =\n    rev (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys zs =\n       rev (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) @ zs", "by(induct ys) auto"], ["proof (state)\nthis:\n  fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys ?zs =\n  rev (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) @ ?zs\n\ngoal (1 subgoal):\n 1. \\<And>a xs zs.\n       (\\<And>zs.\n           zs @ local.alist_product xs ys =\n           rev (fold\n                 (\\<lambda>(a, b).\n                     fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n                 xs (rev zs))) \\<Longrightarrow>\n       zs @ local.alist_product (a # xs) ys =\n       rev (fold\n             (\\<lambda>(a, b).\n                 fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n             (a # xs) (rev zs))", "with Cons.IH[of \"zs @ map (\\<lambda>(c, d). ((a, c), f a b c d)) ys\"] x"], ["proof (chain)\npicking this:\n  (zs @ map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) @\n  local.alist_product xs ys =\n  rev (fold\n        (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              fold\n               (\\<lambda>c.\n                   case c of (c, d) \\<Rightarrow> (#) ((a, c), f a b c d))\n               ys)\n        xs (rev (zs @ map (\\<lambda>(c, d). ((a, c), f a b c d)) ys)))\n  x = (a, b)\n  fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys ?zs =\n  rev (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) @ ?zs", "show ?case"], ["proof (prove)\nusing this:\n  (zs @ map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) @\n  local.alist_product xs ys =\n  rev (fold\n        (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              fold\n               (\\<lambda>c.\n                   case c of (c, d) \\<Rightarrow> (#) ((a, c), f a b c d))\n               ys)\n        xs (rev (zs @ map (\\<lambda>(c, d). ((a, c), f a b c d)) ys)))\n  x = (a, b)\n  fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys ?zs =\n  rev (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) @ ?zs\n\ngoal (1 subgoal):\n 1. zs @ local.alist_product (x # xs) ys =\n    rev (fold\n          (\\<lambda>a.\n              case a of\n              (a, b) \\<Rightarrow>\n                fold\n                 (\\<lambda>c.\n                     case c of (c, d) \\<Rightarrow> (#) ((a, c), f a b c d))\n                 ys)\n          (x # xs) (rev zs))", "by simp"], ["proof (state)\nthis:\n  zs @ local.alist_product (x # xs) ys =\n  rev (fold\n        (\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              fold\n               (\\<lambda>c.\n                   case c of (c, d) \\<Rightarrow> (#) ((a, c), f a b c d))\n               ys)\n        (x # xs) (rev zs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alist_product_code [code]:\n  \"alist_product xs ys =\n  rev (fold (\\<lambda>(a, b). fold (\\<lambda>(c, d) rest. ((a, c), f a b c d) # rest) ys) xs [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alist_product xs ys =\n    rev (fold\n          (\\<lambda>(a, b).\n              fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n          xs [])", "using append_alist_product_conv_fold[of \"[]\" xs ys]"], ["proof (prove)\nusing this:\n  [] @ local.alist_product xs ys =\n  rev (fold\n        (\\<lambda>(a, b).\n            fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n        xs (rev []))\n\ngoal (1 subgoal):\n 1. local.alist_product xs ys =\n    rev (fold\n          (\\<lambda>(a, b).\n              fold (\\<lambda>(c, d). (#) ((a, c), f a b c d)) ys)\n          xs [])", "by simp"], ["", "lemma set_alist_product:\n  \"set (alist_product xs ys) =\n  (\\<lambda>((a, b), (c, d)). ((a, c), f a b c d)) ` (set xs \\<times> set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.alist_product xs ys) =\n    (\\<lambda>((a, b), c, d). ((a, c), f a b c d)) `\n    (set xs \\<times> set ys)", "by(auto 4 3 simp add: alist_product_def intro: rev_image_eqI rev_bexI)"], ["", "lemma distinct_alist_product:\n  \"\\<lbrakk> distinct (map fst xs); distinct (map fst ys) \\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (alist_product xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst xs); distinct (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (local.alist_product xs ys))", "proof(induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst []); distinct (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (local.alist_product [] ys))\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs);\n                 distinct (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (local.alist_product xs ys));\n        distinct (map fst (a # xs)); distinct (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (local.alist_product (a # xs) ys))", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n  distinct (map fst ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst []); distinct (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (local.alist_product [] ys))\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs);\n                 distinct (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (local.alist_product xs ys));\n        distinct (map fst (a # xs)); distinct (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (local.alist_product (a # xs) ys))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n  distinct (map fst ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst (local.alist_product [] ys))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (local.alist_product [] ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs);\n                 distinct (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (local.alist_product xs ys));\n        distinct (map fst (a # xs)); distinct (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (local.alist_product (a # xs) ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs);\n                 distinct (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (local.alist_product xs ys));\n        distinct (map fst (a # xs)); distinct (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (local.alist_product (a # xs) ys))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst xs); distinct (map fst ys)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (local.alist_product xs ys))\n  distinct (map fst (x # xs))\n  distinct (map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs);\n                 distinct (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (local.alist_product xs ys));\n        distinct (map fst (a # xs)); distinct (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (local.alist_product (a # xs) ys))", "obtain a b where x: \"x = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x)"], ["proof (state)\nthis:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs);\n                 distinct (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (local.alist_product xs ys));\n        distinct (map fst (a # xs)); distinct (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (local.alist_product (a # xs) ys))", "have \"distinct (map (fst \\<circ> (\\<lambda>(c, d). ((a, c), f a b c d))) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (fst \\<circ> (\\<lambda>(c, d). ((a, c), f a b c d))) ys)", "using \\<open>distinct (map fst ys)\\<close>"], ["proof (prove)\nusing this:\n  distinct (map fst ys)\n\ngoal (1 subgoal):\n 1. distinct (map (fst \\<circ> (\\<lambda>(c, d). ((a, c), f a b c d))) ys)", "by(induct ys)(auto intro: rev_image_eqI)"], ["proof (state)\nthis:\n  distinct (map (fst \\<circ> (\\<lambda>(c, d). ((a, c), f a b c d))) ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst xs);\n                 distinct (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map fst (local.alist_product xs ys));\n        distinct (map fst (a # xs)); distinct (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (local.alist_product (a # xs) ys))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map (fst \\<circ> (\\<lambda>(c, d). ((a, c), f a b c d))) ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst (local.alist_product (x # xs) ys))", "using Cons x"], ["proof (prove)\nusing this:\n  distinct (map (fst \\<circ> (\\<lambda>(c, d). ((a, c), f a b c d))) ys)\n  \\<lbrakk>distinct (map fst xs); distinct (map fst ys)\\<rbrakk>\n  \\<Longrightarrow> distinct (map fst (local.alist_product xs ys))\n  distinct (map fst (x # xs))\n  distinct (map fst ys)\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. distinct (map fst (local.alist_product (x # xs) ys))", "by(auto simp add: set_alist_product intro: rev_image_eqI)"], ["proof (state)\nthis:\n  distinct (map fst (local.alist_product (x # xs) ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_alist_product:\n  \"map_of (alist_product xs ys) (a, c) = \n  (case map_of xs a of None \\<Rightarrow> None\n   | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (local.alist_product xs ys) (a, c) =\n    (case map_of xs a of None \\<Rightarrow> None\n     | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of (local.alist_product [] ys) (a, c) =\n    (case map_of [] a of None \\<Rightarrow> None\n     | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))\n 2. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. map_of (local.alist_product [] ys) (a, c) =\n    (case map_of [] a of None \\<Rightarrow> None\n     | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))\n 2. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (local.alist_product [] ys) (a, c) =\n    (case map_of [] a of None \\<Rightarrow> None\n     | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "by simp"], ["proof (state)\nthis:\n  map_of (local.alist_product [] ys) (a, c) =\n  (case map_of [] a of None \\<Rightarrow> None\n   | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "case (Cons x xs)"], ["proof (state)\nthis:\n  map_of (local.alist_product xs ys) (a, c) =\n  (case map_of xs a of None \\<Rightarrow> None\n   | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "obtain a b where x: \"x = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x)"], ["proof (state)\nthis:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "let ?map = \"map (\\<lambda>(c, d). ((a, c), f a b c d)) ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "have \"map_of ?map (a, c) = map_option (f a b c) (map_of ys c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (a, c) =\n    map_option (f a b c) (map_of ys c)", "by(induct ys) auto"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (a, c) =\n  map_option (f a b c) (map_of ys c)\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "moreover"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (a, c) =\n  map_option (f a b c) (map_of ys c)\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "{"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (a, c) =\n  map_option (f a b c) (map_of ys c)\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "fix a'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "assume \"a' \\<noteq> a\""], ["proof (state)\nthis:\n  a' \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "hence \"map_of ?map (a', c) = None\""], ["proof (prove)\nusing this:\n  a' \\<noteq> a\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (a', c) = None", "by(induct ys) auto"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (a', c) = None\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "}"], ["proof (state)\nthis:\n  ?a'2 \\<noteq> a \\<Longrightarrow>\n  map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (?a'2, c) = None\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       map_of (local.alist_product xs ys) (a, c) =\n       (case map_of xs a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow>\n            map_option (f a b c) (map_of ys c)) \\<Longrightarrow>\n       map_of (local.alist_product (aa # xs) ys) (a, c) =\n       (case map_of (aa # xs) a of None \\<Rightarrow> None\n        | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "ultimately"], ["proof (chain)\npicking this:\n  map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (a, c) =\n  map_option (f a b c) (map_of ys c)\n  ?a'2 \\<noteq> a \\<Longrightarrow>\n  map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (?a'2, c) = None", "show ?case"], ["proof (prove)\nusing this:\n  map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (a, c) =\n  map_option (f a b c) (map_of ys c)\n  ?a'2 \\<noteq> a \\<Longrightarrow>\n  map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (?a'2, c) = None\n\ngoal (1 subgoal):\n 1. map_of (local.alist_product (x # xs) ys) (a, c) =\n    (case map_of (x # xs) a of None \\<Rightarrow> None\n     | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "using x Cons.IH"], ["proof (prove)\nusing this:\n  map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (a, c) =\n  map_option (f a b c) (map_of ys c)\n  ?a'2 \\<noteq> a \\<Longrightarrow>\n  map_of (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys) (?a'2, c) = None\n  x = (a, b)\n  map_of (local.alist_product xs ys) (a, c) =\n  (case map_of xs a of None \\<Rightarrow> None\n   | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))\n\ngoal (1 subgoal):\n 1. map_of (local.alist_product (x # xs) ys) (a, c) =\n    (case map_of (x # xs) a of None \\<Rightarrow> None\n     | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))", "by(auto simp add: map_add_def split: option.split)"], ["proof (state)\nthis:\n  map_of (local.alist_product (x # xs) ys) (a, c) =\n  (case map_of (x # xs) a of None \\<Rightarrow> None\n   | Some b \\<Rightarrow> map_option (f a b c) (map_of ys c))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition rbt_product :: \"('a, 'b) rbt \\<Rightarrow> ('c, 'd) rbt \\<Rightarrow> ('a \\<times> 'c, 'e) rbt\"\nwhere\n  \"rbt_product rbt1 rbt2 = rbtreeify (alist_product (RBT_Impl.entries rbt1) (RBT_Impl.entries rbt2))\""], ["", "lemma rbt_product_code [code]:\n  \"rbt_product rbt1 rbt2 =\n   rbtreeify (rev (RBT_Impl.fold (\\<lambda>a b. RBT_Impl.fold (\\<lambda>c d rest. ((a, c), f a b c d) # rest) rbt2) rbt1 []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_product rbt1 rbt2 =\n    rbtreeify\n     (rev (RBT_Impl.fold\n            (\\<lambda>a b.\n                RBT_Impl.fold (\\<lambda>c d. (#) ((a, c), f a b c d)) rbt2)\n            rbt1 []))", "unfolding rbt_product_def alist_product_code RBT_Impl.fold_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rbtreeify\n     (rev (fold\n            (\\<lambda>(a, b).\n                fold (\\<lambda>(c, d). (#) ((a, c), f a b c d))\n                 (RBT_Impl.entries rbt2))\n            (RBT_Impl.entries rbt1) [])) =\n    rbtreeify\n     (rev (fold\n            (\\<lambda>(a, b).\n                fold (\\<lambda>(c, d). (#) ((a, c), f a b c d))\n                 (RBT_Impl.entries rbt2))\n            (RBT_Impl.entries rbt1) []))", ".."], ["", "end"], ["", "context\n  fixes leq_a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<sqsubseteq>\\<^sub>a\" 50) \n  and less_a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<sqsubset>\\<^sub>a\" 50) \n  and leq_b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\" (infix \"\\<sqsubseteq>\\<^sub>b\" 50) \n  and less_b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\" (infix \"\\<sqsubset>\\<^sub>b\" 50) \n  assumes lin_a: \"class.linorder leq_a less_a\" \n  and lin_b: \"class.linorder leq_b less_b\"\nbegin"], ["", "abbreviation (input) less_eq_prod' :: \"('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'b) \\<Rightarrow> bool\" (infix \"\\<sqsubseteq>\" 50)\nwhere \"less_eq_prod' \\<equiv> less_eq_prod leq_a less_a leq_b\""], ["", "abbreviation (input) less_prod' :: \"('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'b) \\<Rightarrow> bool\" (infix \"\\<sqsubset>\" 50)\nwhere \"less_prod' \\<equiv> less_prod leq_a less_a less_b\""], ["", "lemmas linorder_prod = linorder_prod[OF lin_a lin_b]"], ["", "lemma sorted_alist_product: \n  assumes xs: \"linorder.sorted leq_a (map fst xs)\" \"distinct (map fst xs)\"\n  and ys: \"linorder.sorted (\\<sqsubseteq>\\<^sub>b) (map fst ys)\"\n  shows \"linorder.sorted (\\<sqsubseteq>) (map fst (alist_product f xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder.sorted\n     (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n       (\\<sqsubseteq>\\<^sub>b))\n     (map fst (alist_product f xs ys))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linorder.sorted\n     (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n       (\\<sqsubseteq>\\<^sub>b))\n     (map fst (alist_product f xs ys))", "interpret a: linorder \"(\\<sqsubseteq>\\<^sub>a)\" \"(\\<sqsubset>\\<^sub>a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)", "by(fact lin_a)"], ["proof (state)\ngoal (1 subgoal):\n 1. linorder.sorted\n     (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n       (\\<sqsubseteq>\\<^sub>b))\n     (map fst (alist_product f xs ys))", "note [simp] = \n    linorder.sorted.simps(1)[OF linorder_prod] linorder.sorted.simps(2)[OF linorder_prod]\n    linorder.sorted_append[OF linorder_prod]\n    linorder.sorted.simps(2)[OF lin_b]"], ["proof (state)\nthis:\n  linorder.sorted\n   (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n     (\\<sqsubseteq>\\<^sub>b))\n   [] =\n  True\n  linorder.sorted\n   (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n     (\\<sqsubseteq>\\<^sub>b))\n   (?x # ?ys) =\n  (Ball (set ?ys)\n    (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n      (\\<sqsubseteq>\\<^sub>b) ?x) \\<and>\n   linorder.sorted\n    (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n      (\\<sqsubseteq>\\<^sub>b))\n    ?ys)\n  linorder.sorted\n   (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n     (\\<sqsubseteq>\\<^sub>b))\n   (?xs @ ?ys) =\n  (linorder.sorted\n    (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n      (\\<sqsubseteq>\\<^sub>b))\n    ?xs \\<and>\n   linorder.sorted\n    (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n      (\\<sqsubseteq>\\<^sub>b))\n    ?ys \\<and>\n   (\\<forall>x\\<in>set ?xs.\n       \\<forall>y\\<in>set ?ys.\n          less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n           (\\<sqsubseteq>\\<^sub>b) x y))\n  linorder.sorted (\\<sqsubseteq>\\<^sub>b) (?x # ?ys) =\n  (Ball (set ?ys) ((\\<sqsubseteq>\\<^sub>b) ?x) \\<and>\n   linorder.sorted (\\<sqsubseteq>\\<^sub>b) ?ys)\n\ngoal (1 subgoal):\n 1. linorder.sorted\n     (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n       (\\<sqsubseteq>\\<^sub>b))\n     (map fst (alist_product f xs ys))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder.sorted\n     (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n       (\\<sqsubseteq>\\<^sub>b))\n     (map fst (alist_product f xs ys))", "using xs"], ["proof (prove)\nusing this:\n  a.sorted (map fst xs)\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. linorder.sorted\n     (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n       (\\<sqsubseteq>\\<^sub>b))\n     (map fst (alist_product f xs ys))", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a.sorted (map fst []); distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> linorder.sorted\n                       (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                         (\\<sqsubset>\\<^sub>a) (\\<sqsubseteq>\\<^sub>b))\n                       (map fst (alist_product f [] ys))\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>a.sorted (map fst xs);\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> linorder.sorted\n                                   (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                                     (\\<sqsubset>\\<^sub>a)\n                                     (\\<sqsubseteq>\\<^sub>b))\n                                   (map fst (alist_product f xs ys));\n        a.sorted (map fst (a # xs)); distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> linorder.sorted\n                          (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                            (\\<sqsubset>\\<^sub>a) (\\<sqsubseteq>\\<^sub>b))\n                          (map fst (alist_product f (a # xs) ys))", "case Nil"], ["proof (state)\nthis:\n  a.sorted (map fst [])\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a.sorted (map fst []); distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> linorder.sorted\n                       (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                         (\\<sqsubset>\\<^sub>a) (\\<sqsubseteq>\\<^sub>b))\n                       (map fst (alist_product f [] ys))\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>a.sorted (map fst xs);\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> linorder.sorted\n                                   (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                                     (\\<sqsubset>\\<^sub>a)\n                                     (\\<sqsubseteq>\\<^sub>b))\n                                   (map fst (alist_product f xs ys));\n        a.sorted (map fst (a # xs)); distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> linorder.sorted\n                          (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                            (\\<sqsubset>\\<^sub>a) (\\<sqsubseteq>\\<^sub>b))\n                          (map fst (alist_product f (a # xs) ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder.sorted\n     (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n       (\\<sqsubseteq>\\<^sub>b))\n     (map fst (alist_product f [] ys))", "by simp"], ["proof (state)\nthis:\n  linorder.sorted\n   (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n     (\\<sqsubseteq>\\<^sub>b))\n   (map fst (alist_product f [] ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>a.sorted (map fst xs);\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> linorder.sorted\n                                   (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                                     (\\<sqsubset>\\<^sub>a)\n                                     (\\<sqsubseteq>\\<^sub>b))\n                                   (map fst (alist_product f xs ys));\n        a.sorted (map fst (a # xs)); distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> linorder.sorted\n                          (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                            (\\<sqsubset>\\<^sub>a) (\\<sqsubseteq>\\<^sub>b))\n                          (map fst (alist_product f (a # xs) ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>a.sorted (map fst xs);\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> linorder.sorted\n                                   (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                                     (\\<sqsubset>\\<^sub>a)\n                                     (\\<sqsubseteq>\\<^sub>b))\n                                   (map fst (alist_product f xs ys));\n        a.sorted (map fst (a # xs)); distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> linorder.sorted\n                          (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                            (\\<sqsubset>\\<^sub>a) (\\<sqsubseteq>\\<^sub>b))\n                          (map fst (alist_product f (a # xs) ys))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>a.sorted (map fst xs); distinct (map fst xs)\\<rbrakk>\n  \\<Longrightarrow> linorder.sorted\n                     (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                       (\\<sqsubset>\\<^sub>a) (\\<sqsubseteq>\\<^sub>b))\n                     (map fst (alist_product f xs ys))\n  a.sorted (map fst (x # xs))\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>a.sorted (map fst xs);\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> linorder.sorted\n                                   (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                                     (\\<sqsubset>\\<^sub>a)\n                                     (\\<sqsubseteq>\\<^sub>b))\n                                   (map fst (alist_product f xs ys));\n        a.sorted (map fst (a # xs)); distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> linorder.sorted\n                          (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                            (\\<sqsubset>\\<^sub>a) (\\<sqsubseteq>\\<^sub>b))\n                          (map fst (alist_product f (a # xs) ys))", "obtain a b where x: \"x = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x)"], ["proof (state)\nthis:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>a.sorted (map fst xs);\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> linorder.sorted\n                                   (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                                     (\\<sqsubset>\\<^sub>a)\n                                     (\\<sqsubseteq>\\<^sub>b))\n                                   (map fst (alist_product f xs ys));\n        a.sorted (map fst (a # xs)); distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> linorder.sorted\n                          (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                            (\\<sqsubset>\\<^sub>a) (\\<sqsubseteq>\\<^sub>b))\n                          (map fst (alist_product f (a # xs) ys))", "have \"linorder.sorted (\\<sqsubseteq>) (map fst (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder.sorted\n     (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n       (\\<sqsubseteq>\\<^sub>b))\n     (map fst (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys))", "using ys"], ["proof (prove)\nusing this:\n  linorder.sorted (\\<sqsubseteq>\\<^sub>b) (map fst ys)\n\ngoal (1 subgoal):\n 1. linorder.sorted\n     (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n       (\\<sqsubseteq>\\<^sub>b))\n     (map fst (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys))", "by(induct ys) auto"], ["proof (state)\nthis:\n  linorder.sorted\n   (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n     (\\<sqsubseteq>\\<^sub>b))\n   (map fst (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>a.sorted (map fst xs);\n                 distinct (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> linorder.sorted\n                                   (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                                     (\\<sqsubset>\\<^sub>a)\n                                     (\\<sqsubseteq>\\<^sub>b))\n                                   (map fst (alist_product f xs ys));\n        a.sorted (map fst (a # xs)); distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> linorder.sorted\n                          (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                            (\\<sqsubset>\\<^sub>a) (\\<sqsubseteq>\\<^sub>b))\n                          (map fst (alist_product f (a # xs) ys))", "thus ?case"], ["proof (prove)\nusing this:\n  linorder.sorted\n   (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n     (\\<sqsubseteq>\\<^sub>b))\n   (map fst (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys))\n\ngoal (1 subgoal):\n 1. linorder.sorted\n     (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n       (\\<sqsubseteq>\\<^sub>b))\n     (map fst (alist_product f (x # xs) ys))", "using x Cons"], ["proof (prove)\nusing this:\n  linorder.sorted\n   (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n     (\\<sqsubseteq>\\<^sub>b))\n   (map fst (map (\\<lambda>(c, d). ((a, c), f a b c d)) ys))\n  x = (a, b)\n  \\<lbrakk>a.sorted (map fst xs); distinct (map fst xs)\\<rbrakk>\n  \\<Longrightarrow> linorder.sorted\n                     (less_eq_prod (\\<sqsubseteq>\\<^sub>a)\n                       (\\<sqsubset>\\<^sub>a) (\\<sqsubseteq>\\<^sub>b))\n                     (map fst (alist_product f xs ys))\n  a.sorted (map fst (x # xs))\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. linorder.sorted\n     (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n       (\\<sqsubseteq>\\<^sub>b))\n     (map fst (alist_product f (x # xs) ys))", "by(fastforce simp add: set_alist_product a.not_less dest: bspec a.antisym intro: rev_image_eqI)"], ["proof (state)\nthis:\n  linorder.sorted\n   (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n     (\\<sqsubseteq>\\<^sub>b))\n   (map fst (alist_product f (x # xs) ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  linorder.sorted\n   (less_eq_prod (\\<sqsubseteq>\\<^sub>a) (\\<sqsubset>\\<^sub>a)\n     (\\<sqsubseteq>\\<^sub>b))\n   (map fst (alist_product f xs ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_rbt_rbt_product:\n  \"\\<lbrakk> ord.is_rbt (\\<sqsubset>\\<^sub>a) rbt1; ord.is_rbt (\\<sqsubset>\\<^sub>b) rbt2 \\<rbrakk>\n  \\<Longrightarrow> ord.is_rbt (\\<sqsubset>) (rbt_product f rbt1 rbt2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ord.is_rbt (\\<sqsubset>\\<^sub>a) rbt1;\n     ord.is_rbt (\\<sqsubset>\\<^sub>b) rbt2\\<rbrakk>\n    \\<Longrightarrow> ord.is_rbt\n                       (less_prod (\\<sqsubseteq>\\<^sub>a)\n                         (\\<sqsubset>\\<^sub>a) (\\<sqsubset>\\<^sub>b))\n                       (rbt_product f rbt1 rbt2)", "unfolding rbt_product_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ord.is_rbt (\\<sqsubset>\\<^sub>a) rbt1;\n     ord.is_rbt (\\<sqsubset>\\<^sub>b) rbt2\\<rbrakk>\n    \\<Longrightarrow> ord.is_rbt\n                       (less_prod (\\<sqsubseteq>\\<^sub>a)\n                         (\\<sqsubset>\\<^sub>a) (\\<sqsubset>\\<^sub>b))\n                       (rbtreeify\n                         (alist_product f (RBT_Impl.entries rbt1)\n                           (RBT_Impl.entries rbt2)))", "by(blast intro: linorder.is_rbt_rbtreeify[OF linorder_prod] sorted_alist_product linorder.rbt_sorted_entries[OF lin_a] ord.is_rbt_rbt_sorted linorder.distinct_entries[OF lin_a] linorder.rbt_sorted_entries[OF lin_b] distinct_alist_product linorder.distinct_entries[OF lin_b])"], ["", "lemma rbt_lookup_rbt_product:\n  \"\\<lbrakk> ord.is_rbt (\\<sqsubset>\\<^sub>a) rbt1; ord.is_rbt (\\<sqsubset>\\<^sub>b) rbt2 \\<rbrakk>\n  \\<Longrightarrow> ord.rbt_lookup (\\<sqsubset>) (rbt_product f rbt1 rbt2) (a, c) =\n     (case ord.rbt_lookup (\\<sqsubset>\\<^sub>a) rbt1 a of None \\<Rightarrow> None\n      | Some b \\<Rightarrow> map_option (f a b c) (ord.rbt_lookup (\\<sqsubset>\\<^sub>b) rbt2 c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ord.is_rbt (\\<sqsubset>\\<^sub>a) rbt1;\n     ord.is_rbt (\\<sqsubset>\\<^sub>b) rbt2\\<rbrakk>\n    \\<Longrightarrow> ord.rbt_lookup\n                       (less_prod (\\<sqsubseteq>\\<^sub>a)\n                         (\\<sqsubset>\\<^sub>a) (\\<sqsubset>\\<^sub>b))\n                       (rbt_product f rbt1 rbt2) (a, c) =\n                      (case ord.rbt_lookup (\\<sqsubset>\\<^sub>a) rbt1 a of\n                       None \\<Rightarrow> None\n                       | Some b \\<Rightarrow>\n                           map_option (f a b c)\n                            (ord.rbt_lookup (\\<sqsubset>\\<^sub>b) rbt2 c))", "by(simp add: rbt_product_def linorder.rbt_lookup_rbtreeify[OF linorder_prod] linorder.is_rbt_rbtreeify[OF linorder_prod] sorted_alist_product linorder.rbt_sorted_entries[OF lin_a] ord.is_rbt_rbt_sorted linorder.distinct_entries[OF lin_a] linorder.rbt_sorted_entries[OF lin_b] distinct_alist_product linorder.distinct_entries[OF lin_b] map_of_alist_product linorder.map_of_entries[OF lin_a] linorder.map_of_entries[OF lin_b] cong: option.case_cong)"], ["", "end"], ["", "hide_const less_eq_prod' less_prod'"], ["", "subsection \\<open>Build an RBT where keys are paired with themselves\\<close>"], ["", "primrec RBT_Impl_diag :: \"('a, 'b) rbt \\<Rightarrow> ('a \\<times> 'a, 'b) rbt\"\nwhere\n  \"RBT_Impl_diag rbt.Empty = rbt.Empty\"\n| \"RBT_Impl_diag (rbt.Branch c l k v r) = rbt.Branch c (RBT_Impl_diag l) (k, k) v (RBT_Impl_diag r)\""], ["", "lemma entries_RBT_Impl_diag:\n  \"RBT_Impl.entries (RBT_Impl_diag t) = map (\\<lambda>(k, v). ((k, k), v)) (RBT_Impl.entries t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_Impl.entries (RBT_Impl_diag t) =\n    map (\\<lambda>(k, v). ((k, k), v)) (RBT_Impl.entries t)", "by(induct t) simp_all"], ["", "lemma keys_RBT_Impl_diag:\n  \"RBT_Impl.keys (RBT_Impl_diag t) = map (\\<lambda>k. (k, k)) (RBT_Impl.keys t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_Impl.keys (RBT_Impl_diag t) =\n    map (\\<lambda>k. (k, k)) (RBT_Impl.keys t)", "by(simp add: RBT_Impl.keys_def entries_RBT_Impl_diag split_beta)"], ["", "lemma rbt_sorted_RBT_Impl_diag:\n  \"ord.rbt_sorted lt t \\<Longrightarrow> ord.rbt_sorted (less_prod leq lt lt) (RBT_Impl_diag t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.rbt_sorted lt t \\<Longrightarrow>\n    ord.rbt_sorted (less_prod leq lt lt) (RBT_Impl_diag t)", "by(induct t)(auto simp add: ord.rbt_sorted.simps ord.rbt_less_prop ord.rbt_greater_prop keys_RBT_Impl_diag)"], ["", "lemma bheight_RBT_Impl_diag:\n  \"bheight (RBT_Impl_diag t) = bheight t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bheight (RBT_Impl_diag t) = bheight t", "by(induct t) simp_all"], ["", "lemma inv_RBT_Impl_diag:\n  assumes \"inv1 t\" \"inv2 t\"\n  shows \"inv1 (RBT_Impl_diag t)\" \"inv2 (RBT_Impl_diag t)\"\n  and \"color_of t = color.B \\<Longrightarrow> color_of (RBT_Impl_diag t) = color.B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv1 (RBT_Impl_diag t) &&& inv2 (RBT_Impl_diag t)) &&&\n    (color_of t = color.B \\<Longrightarrow>\n     color_of (RBT_Impl_diag t) = color.B)", "using assms"], ["proof (prove)\nusing this:\n  inv1 t\n  inv2 t\n\ngoal (1 subgoal):\n 1. (inv1 (RBT_Impl_diag t) &&& inv2 (RBT_Impl_diag t)) &&&\n    (color_of t = color.B \\<Longrightarrow>\n     color_of (RBT_Impl_diag t) = color.B)", "by(induct t)(auto simp add: bheight_RBT_Impl_diag)"], ["", "lemma is_rbt_RBT_Impl_diag:\n  \"ord.is_rbt lt t \\<Longrightarrow> ord.is_rbt (less_prod leq lt lt) (RBT_Impl_diag t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.is_rbt lt t \\<Longrightarrow>\n    ord.is_rbt (less_prod leq lt lt) (RBT_Impl_diag t)", "by(simp add: ord.is_rbt_def rbt_sorted_RBT_Impl_diag inv_RBT_Impl_diag)"], ["", "lemma (in linorder) rbt_lookup_RBT_Impl_diag:\n  \"ord.rbt_lookup (less_prod (\\<le>) (<) (<)) (RBT_Impl_diag t) =\n  (\\<lambda>(k, k'). if k = k' then ord.rbt_lookup (<) t k else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.rbt_lookup (less_prod (\\<le>) (<) (<)) (RBT_Impl_diag t) =\n    (\\<lambda>(k, k'). if k = k' then rbt_lookup t k else None)", "by(induct t)(auto simp add: ord.rbt_lookup.simps fun_eq_iff)"], ["", "subsection \\<open>Folding and quantifiers over RBTs\\<close>"], ["", "definition RBT_Impl_fold1 :: \"('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> ('a, unit) RBT_Impl.rbt \\<Rightarrow> 'a\"\nwhere \"RBT_Impl_fold1 f rbt = fold f (tl (RBT_Impl.keys rbt)) (hd (RBT_Impl.keys rbt))\""], ["", "lemma RBT_Impl_fold1_simps [simp, code]:\n  \"RBT_Impl_fold1 f rbt.Empty = undefined\"\n  \"RBT_Impl_fold1 f (Branch c rbt.Empty k v r) = RBT_Impl.fold (\\<lambda>k v. f k) r k\"\n  \"RBT_Impl_fold1 f (Branch c (Branch c' l' k' v' r') k v r) = \n   RBT_Impl.fold (\\<lambda>k v. f k) r (f k (RBT_Impl_fold1 f (Branch c' l' k' v' r')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_Impl_fold1 f rbt.Empty = undefined &&&\n    RBT_Impl_fold1 f (Branch c rbt.Empty k v r) =\n    RBT_Impl.fold (\\<lambda>k v. f k) r k &&&\n    RBT_Impl_fold1 f (Branch c (Branch c' l' k' v' r') k v r) =\n    RBT_Impl.fold (\\<lambda>k v. f k) r\n     (f k (RBT_Impl_fold1 f (Branch c' l' k' v' r')))", "by(simp_all add: RBT_Impl_fold1_def RBT_Impl.keys_def fold_map RBT_Impl.fold_def split_def o_def tl_append hd_def split: list.split)"], ["", "definition RBT_Impl_rbt_all :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> bool\"\nwhere [code del]: \"RBT_Impl_rbt_all P rbt = (\\<forall>(k, v) \\<in> set (RBT_Impl.entries rbt). P k v)\""], ["", "lemma RBT_Impl_rbt_all_simps [simp, code]:\n  \"RBT_Impl_rbt_all P rbt.Empty \\<longleftrightarrow> True\"\n  \"RBT_Impl_rbt_all P (Branch c l k v r) \\<longleftrightarrow> P k v \\<and> RBT_Impl_rbt_all P l \\<and> RBT_Impl_rbt_all P r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_Impl_rbt_all P rbt.Empty = True &&&\n    RBT_Impl_rbt_all P (Branch c l k v r) =\n    (P k v \\<and> RBT_Impl_rbt_all P l \\<and> RBT_Impl_rbt_all P r)", "by(auto simp add: RBT_Impl_rbt_all_def)"], ["", "definition RBT_Impl_rbt_ex :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) rbt \\<Rightarrow> bool\"\nwhere [code del]: \"RBT_Impl_rbt_ex P rbt = (\\<exists>(k, v) \\<in> set (RBT_Impl.entries rbt). P k v)\""], ["", "lemma RBT_Impl_rbt_ex_simps [simp, code]:\n  \"RBT_Impl_rbt_ex P rbt.Empty \\<longleftrightarrow> False\"\n  \"RBT_Impl_rbt_ex P (Branch c l k v r) \\<longleftrightarrow> P k v \\<or> RBT_Impl_rbt_ex P l \\<or> RBT_Impl_rbt_ex P r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_Impl_rbt_ex P rbt.Empty = False &&&\n    RBT_Impl_rbt_ex P (Branch c l k v r) =\n    (P k v \\<or> RBT_Impl_rbt_ex P l \\<or> RBT_Impl_rbt_ex P r)", "by(auto simp add: RBT_Impl_rbt_ex_def)"], ["", "subsection \\<open>List fusion for RBTs\\<close>"], ["", "type_synonym ('a, 'b, 'c) rbt_generator_state = \"('c \\<times> ('a, 'b) RBT_Impl.rbt) list \\<times> ('a, 'b) RBT_Impl.rbt\""], ["", "fun rbt_has_next :: \"('a, 'b, 'c) rbt_generator_state \\<Rightarrow> bool\"\nwhere\n  \"rbt_has_next ([], rbt.Empty) = False\"\n| \"rbt_has_next _ = True\""], ["", "fun rbt_keys_next :: \"('a, 'b, 'a) rbt_generator_state \\<Rightarrow> 'a \\<times> ('a, 'b, 'a) rbt_generator_state\"\nwhere\n  \"rbt_keys_next ((k, t) # kts, rbt.Empty) = (k, kts, t)\"\n| \"rbt_keys_next (kts, rbt.Branch c l k v r) = rbt_keys_next ((k, r) # kts, l)\""], ["", "lemma rbt_generator_induct [case_names empty split shuffle]:\n  assumes \"P ([], rbt.Empty)\"\n  and \"\\<And>k t kts. P (kts, t) \\<Longrightarrow> P ((k, t) # kts, rbt.Empty)\"\n  and \"\\<And>kts c l k v r. P ((f k v, r) # kts, l) \\<Longrightarrow> P (kts, Branch c l k v r)\"\n  shows \"P ktst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ktst", "using assms"], ["proof (prove)\nusing this:\n  P ([], rbt.Empty)\n  P (?kts, ?t) \\<Longrightarrow> P ((?k, ?t) # ?kts, rbt.Empty)\n  P ((f ?k ?v, ?r) # ?kts, ?l) \\<Longrightarrow>\n  P (?kts, Branch ?c ?l ?k ?v ?r)\n\ngoal (1 subgoal):\n 1. P ktst", "apply(induction_schema)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P ktst.\n       \\<lbrakk>ktst = ([], rbt.Empty) \\<Longrightarrow> P;\n        \\<And>kts__ t__ k__.\n           ktst = ((k__, t__) # kts__, rbt.Empty) \\<Longrightarrow> P;\n        \\<And>k__ v__ r__ kts__ l__ c__.\n           ktst = (kts__, Branch c__ l__ k__ v__ r__) \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. wf ?R2\n 3. \\<And>kts__ t__ k__.\n       ((kts__, t__), (k__, t__) # kts__, rbt.Empty) \\<in> ?R2\n 4. \\<And>k__ v__ r__ kts__ l__ c__.\n       (((f k__ v__, r__) # kts__, l__), kts__, Branch c__ l__ k__ v__ r__)\n       \\<in> ?R2", "apply pat_completeness"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf ?R2\n 2. \\<And>kts__ t__ k__.\n       ((kts__, t__), (k__, t__) # kts__, rbt.Empty) \\<in> ?R2\n 3. \\<And>k__ v__ r__ kts__ l__ c__.\n       (((f k__ v__, r__) # kts__, l__), kts__, Branch c__ l__ k__ v__ r__)\n       \\<in> ?R2", "apply(relation \"measure (\\<lambda>(kts, t). size_list (\\<lambda>(k, t). size_rbt (\\<lambda>_. 1) (\\<lambda>_. 1) t) kts + size_rbt (\\<lambda>_. 1) (\\<lambda>_. 1) t)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (measure\n         (\\<lambda>(kts, t).\n             size_list\n              (\\<lambda>(k, t). size_rbt (\\<lambda>_. 1) (\\<lambda>_. 1) t)\n              kts +\n             size_rbt (\\<lambda>_. 1) (\\<lambda>_. 1) t))\n 2. \\<And>kts__ t__ k__.\n       ((kts__, t__), (k__, t__) # kts__, rbt.Empty)\n       \\<in> measure\n              (\\<lambda>(kts, t).\n                  size_list\n                   (\\<lambda>(k, t).\n                       size_rbt (\\<lambda>_. 1) (\\<lambda>_. 1) t)\n                   kts +\n                  size_rbt (\\<lambda>_. 1) (\\<lambda>_. 1) t)\n 3. \\<And>k__ v__ r__ kts__ l__ c__.\n       (((f k__ v__, r__) # kts__, l__), kts__, Branch c__ l__ k__ v__ r__)\n       \\<in> measure\n              (\\<lambda>(kts, t).\n                  size_list\n                   (\\<lambda>(k, t).\n                       size_rbt (\\<lambda>_. 1) (\\<lambda>_. 1) t)\n                   kts +\n                  size_rbt (\\<lambda>_. 1) (\\<lambda>_. 1) t)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma terminates_rbt_keys_generator:\n  \"terminates (rbt_has_next, rbt_keys_next)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (rbt_has_next, rbt_keys_next)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (rbt_has_next, rbt_keys_next)", "fix ktst :: \"('a \\<times> ('a, 'b) rbt) list \\<times> ('a, 'b) rbt\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (rbt_has_next, rbt_keys_next)", "show \"ktst \\<in> terminates_on (rbt_has_next, rbt_keys_next)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ktst \\<in> terminates_on (rbt_has_next, rbt_keys_next)", "by(induct ktst taking: \"\\<lambda>k _. k\" rule: rbt_generator_induct)(auto 4 3 intro: terminates_on.intros elim: terminates_on.cases)"], ["proof (state)\nthis:\n  ktst \\<in> terminates_on (rbt_has_next, rbt_keys_next)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition rbt_keys_generator :: \"('a, ('a, 'b, 'a) rbt_generator_state) generator\"\n  is \"(rbt_has_next, rbt_keys_next)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (rbt_has_next, rbt_keys_next)", "by(rule terminates_rbt_keys_generator)"], ["", "definition rbt_init :: \"('a, 'b) rbt \\<Rightarrow> ('a, 'b, 'c) rbt_generator_state\"\nwhere \"rbt_init = Pair []\""], ["", "lemma has_next_rbt_keys_generator [simp]:\n  \"list.has_next rbt_keys_generator = rbt_has_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.has_next rbt_keys_generator = rbt_has_next", "by transfer simp"], ["", "lemma next_rbt_keys_generator [simp]:\n  \"list.next rbt_keys_generator = rbt_keys_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.next rbt_keys_generator = rbt_keys_next", "by transfer simp"], ["", "lemma unfoldr_rbt_keys_generator_aux:\n  \"list.unfoldr rbt_keys_generator (kts, t) = \n  RBT_Impl.keys t @ concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr rbt_keys_generator (kts, t) =\n    RBT_Impl.keys t @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts)", "proof(induct \"(kts, t)\" arbitrary: kts t taking: \"\\<lambda>k _. k\" rule: rbt_generator_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. list.unfoldr rbt_keys_generator ([], rbt.Empty) =\n    RBT_Impl.keys rbt.Empty @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) [])\n 2. \\<And>k t kts.\n       list.unfoldr rbt_keys_generator (kts, t) =\n       RBT_Impl.keys t @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator ((k, t) # kts, rbt.Empty) =\n       RBT_Impl.keys rbt.Empty @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) ((k, t) # kts))\n 3. \\<And>kts c l k v r.\n       list.unfoldr rbt_keys_generator ((k, r) # kts, l) =\n       RBT_Impl.keys l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t)\n          ((k, r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator (kts, Branch c l k v r) =\n       RBT_Impl.keys (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. list.unfoldr rbt_keys_generator ([], rbt.Empty) =\n    RBT_Impl.keys rbt.Empty @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) [])\n 2. \\<And>k t kts.\n       list.unfoldr rbt_keys_generator (kts, t) =\n       RBT_Impl.keys t @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator ((k, t) # kts, rbt.Empty) =\n       RBT_Impl.keys rbt.Empty @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) ((k, t) # kts))\n 3. \\<And>kts c l k v r.\n       list.unfoldr rbt_keys_generator ((k, r) # kts, l) =\n       RBT_Impl.keys l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t)\n          ((k, r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator (kts, Branch c l k v r) =\n       RBT_Impl.keys (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr rbt_keys_generator ([], rbt.Empty) =\n    RBT_Impl.keys rbt.Empty @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) [])", "by(simp add: list.unfoldr.simps)"], ["proof (state)\nthis:\n  list.unfoldr rbt_keys_generator ([], rbt.Empty) =\n  RBT_Impl.keys rbt.Empty @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) [])\n\ngoal (2 subgoals):\n 1. \\<And>k t kts.\n       list.unfoldr rbt_keys_generator (kts, t) =\n       RBT_Impl.keys t @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator ((k, t) # kts, rbt.Empty) =\n       RBT_Impl.keys rbt.Empty @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) ((k, t) # kts))\n 2. \\<And>kts c l k v r.\n       list.unfoldr rbt_keys_generator ((k, r) # kts, l) =\n       RBT_Impl.keys l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t)\n          ((k, r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator (kts, Branch c l k v r) =\n       RBT_Impl.keys (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k t kts.\n       list.unfoldr rbt_keys_generator (kts, t) =\n       RBT_Impl.keys t @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator ((k, t) # kts, rbt.Empty) =\n       RBT_Impl.keys rbt.Empty @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) ((k, t) # kts))\n 2. \\<And>kts c l k v r.\n       list.unfoldr rbt_keys_generator ((k, r) # kts, l) =\n       RBT_Impl.keys l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t)\n          ((k, r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator (kts, Branch c l k v r) =\n       RBT_Impl.keys (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts)", "case split"], ["proof (state)\nthis:\n  list.unfoldr rbt_keys_generator (kts_, t_) =\n  RBT_Impl.keys t_ @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts_)\n\ngoal (2 subgoals):\n 1. \\<And>k t kts.\n       list.unfoldr rbt_keys_generator (kts, t) =\n       RBT_Impl.keys t @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator ((k, t) # kts, rbt.Empty) =\n       RBT_Impl.keys rbt.Empty @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) ((k, t) # kts))\n 2. \\<And>kts c l k v r.\n       list.unfoldr rbt_keys_generator ((k, r) # kts, l) =\n       RBT_Impl.keys l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t)\n          ((k, r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator (kts, Branch c l k v r) =\n       RBT_Impl.keys (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts)", "thus ?case"], ["proof (prove)\nusing this:\n  list.unfoldr rbt_keys_generator (kts_, t_) =\n  RBT_Impl.keys t_ @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts_)\n\ngoal (1 subgoal):\n 1. list.unfoldr rbt_keys_generator ((k_, t_) # kts_, rbt.Empty) =\n    RBT_Impl.keys rbt.Empty @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) ((k_, t_) # kts_))", "by(subst list.unfoldr.simps) simp"], ["proof (state)\nthis:\n  list.unfoldr rbt_keys_generator ((k_, t_) # kts_, rbt.Empty) =\n  RBT_Impl.keys rbt.Empty @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) ((k_, t_) # kts_))\n\ngoal (1 subgoal):\n 1. \\<And>kts c l k v r.\n       list.unfoldr rbt_keys_generator ((k, r) # kts, l) =\n       RBT_Impl.keys l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t)\n          ((k, r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator (kts, Branch c l k v r) =\n       RBT_Impl.keys (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>kts c l k v r.\n       list.unfoldr rbt_keys_generator ((k, r) # kts, l) =\n       RBT_Impl.keys l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t)\n          ((k, r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator (kts, Branch c l k v r) =\n       RBT_Impl.keys (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts)", "case shuffle"], ["proof (state)\nthis:\n  list.unfoldr rbt_keys_generator ((k_, r_) # kts_, l_) =\n  RBT_Impl.keys l_ @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) ((k_, r_) # kts_))\n\ngoal (1 subgoal):\n 1. \\<And>kts c l k v r.\n       list.unfoldr rbt_keys_generator ((k, r) # kts, l) =\n       RBT_Impl.keys l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.keys t)\n          ((k, r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_keys_generator (kts, Branch c l k v r) =\n       RBT_Impl.keys (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts)", "thus ?case"], ["proof (prove)\nusing this:\n  list.unfoldr rbt_keys_generator ((k_, r_) # kts_, l_) =\n  RBT_Impl.keys l_ @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) ((k_, r_) # kts_))\n\ngoal (1 subgoal):\n 1. list.unfoldr rbt_keys_generator (kts_, Branch c_ l_ k_ v_ r_) =\n    RBT_Impl.keys (Branch c_ l_ k_ v_ r_) @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts_)", "by(subst list.unfoldr.simps)(subst (asm) list.unfoldr.simps, simp)"], ["proof (state)\nthis:\n  list.unfoldr rbt_keys_generator (kts_, Branch c_ l_ k_ v_ r_) =\n  RBT_Impl.keys (Branch c_ l_ k_ v_ r_) @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.keys t) kts_)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary unfoldr_rbt_keys_generator:\n  \"list.unfoldr rbt_keys_generator (rbt_init t) = RBT_Impl.keys t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr rbt_keys_generator (rbt_init t) = RBT_Impl.keys t", "by(simp add: unfoldr_rbt_keys_generator_aux rbt_init_def)"], ["", "fun rbt_entries_next :: \n  \"('a, 'b, 'a \\<times> 'b) rbt_generator_state \\<Rightarrow> ('a \\<times> 'b) \\<times> ('a, 'b, 'a \\<times> 'b) rbt_generator_state\"\nwhere\n  \"rbt_entries_next ((kv, t) # kts, rbt.Empty) = (kv, kts, t)\"\n| \"rbt_entries_next (kts, rbt.Branch c l k v r) = rbt_entries_next (((k, v), r) # kts, l)\""], ["", "lemma terminates_rbt_entries_generator:\n  \"terminates (rbt_has_next, rbt_entries_next)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (rbt_has_next, rbt_entries_next)", "proof(rule terminatesI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (rbt_has_next, rbt_entries_next)", "fix ktst :: \"('a, 'b, 'a \\<times> 'b) rbt_generator_state\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> terminates_on (rbt_has_next, rbt_entries_next)", "show \"ktst \\<in> terminates_on (rbt_has_next, rbt_entries_next)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ktst \\<in> terminates_on (rbt_has_next, rbt_entries_next)", "by(induct ktst taking: Pair rule: rbt_generator_induct)(auto 4 3 intro: terminates_on.intros elim: terminates_on.cases)"], ["proof (state)\nthis:\n  ktst \\<in> terminates_on (rbt_has_next, rbt_entries_next)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition rbt_entries_generator :: \"('a \\<times> 'b, ('a, 'b, 'a \\<times> 'b) rbt_generator_state) generator\"\n  is \"(rbt_has_next, rbt_entries_next)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminates (rbt_has_next, rbt_entries_next)", "by(rule terminates_rbt_entries_generator)"], ["", "lemma has_next_rbt_entries_generator [simp]:\n  \"list.has_next rbt_entries_generator = rbt_has_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.has_next rbt_entries_generator = rbt_has_next", "by transfer simp"], ["", "lemma next_rbt_entries_generator [simp]:\n  \"list.next rbt_entries_generator = rbt_entries_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.next rbt_entries_generator = rbt_entries_next", "by transfer simp"], ["", "lemma unfoldr_rbt_entries_generator_aux:\n  \"list.unfoldr rbt_entries_generator (kts, t) = \n  RBT_Impl.entries t @ concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr rbt_entries_generator (kts, t) =\n    RBT_Impl.entries t @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts)", "proof(induct \"(kts, t)\" arbitrary: kts t taking: Pair rule: rbt_generator_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. list.unfoldr rbt_entries_generator ([], rbt.Empty) =\n    RBT_Impl.entries rbt.Empty @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) [])\n 2. \\<And>k t kts.\n       list.unfoldr rbt_entries_generator (kts, t) =\n       RBT_Impl.entries t @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          kts) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator ((k, t) # kts, rbt.Empty) =\n       RBT_Impl.entries rbt.Empty @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) ((k, t) # kts))\n 3. \\<And>kts c l k v r.\n       list.unfoldr rbt_entries_generator (((k, v), r) # kts, l) =\n       RBT_Impl.entries l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          (((k, v), r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator (kts, Branch c l k v r) =\n       RBT_Impl.entries (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. list.unfoldr rbt_entries_generator ([], rbt.Empty) =\n    RBT_Impl.entries rbt.Empty @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) [])\n 2. \\<And>k t kts.\n       list.unfoldr rbt_entries_generator (kts, t) =\n       RBT_Impl.entries t @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          kts) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator ((k, t) # kts, rbt.Empty) =\n       RBT_Impl.entries rbt.Empty @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) ((k, t) # kts))\n 3. \\<And>kts c l k v r.\n       list.unfoldr rbt_entries_generator (((k, v), r) # kts, l) =\n       RBT_Impl.entries l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          (((k, v), r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator (kts, Branch c l k v r) =\n       RBT_Impl.entries (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr rbt_entries_generator ([], rbt.Empty) =\n    RBT_Impl.entries rbt.Empty @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) [])", "by(simp add: list.unfoldr.simps)"], ["proof (state)\nthis:\n  list.unfoldr rbt_entries_generator ([], rbt.Empty) =\n  RBT_Impl.entries rbt.Empty @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) [])\n\ngoal (2 subgoals):\n 1. \\<And>k t kts.\n       list.unfoldr rbt_entries_generator (kts, t) =\n       RBT_Impl.entries t @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          kts) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator ((k, t) # kts, rbt.Empty) =\n       RBT_Impl.entries rbt.Empty @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) ((k, t) # kts))\n 2. \\<And>kts c l k v r.\n       list.unfoldr rbt_entries_generator (((k, v), r) # kts, l) =\n       RBT_Impl.entries l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          (((k, v), r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator (kts, Branch c l k v r) =\n       RBT_Impl.entries (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k t kts.\n       list.unfoldr rbt_entries_generator (kts, t) =\n       RBT_Impl.entries t @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          kts) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator ((k, t) # kts, rbt.Empty) =\n       RBT_Impl.entries rbt.Empty @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) ((k, t) # kts))\n 2. \\<And>kts c l k v r.\n       list.unfoldr rbt_entries_generator (((k, v), r) # kts, l) =\n       RBT_Impl.entries l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          (((k, v), r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator (kts, Branch c l k v r) =\n       RBT_Impl.entries (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts)", "case split"], ["proof (state)\nthis:\n  list.unfoldr rbt_entries_generator (kts_, t_) =\n  RBT_Impl.entries t_ @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts_)\n\ngoal (2 subgoals):\n 1. \\<And>k t kts.\n       list.unfoldr rbt_entries_generator (kts, t) =\n       RBT_Impl.entries t @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          kts) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator ((k, t) # kts, rbt.Empty) =\n       RBT_Impl.entries rbt.Empty @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) ((k, t) # kts))\n 2. \\<And>kts c l k v r.\n       list.unfoldr rbt_entries_generator (((k, v), r) # kts, l) =\n       RBT_Impl.entries l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          (((k, v), r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator (kts, Branch c l k v r) =\n       RBT_Impl.entries (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts)", "thus ?case"], ["proof (prove)\nusing this:\n  list.unfoldr rbt_entries_generator (kts_, t_) =\n  RBT_Impl.entries t_ @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts_)\n\ngoal (1 subgoal):\n 1. list.unfoldr rbt_entries_generator ((k_, t_) # kts_, rbt.Empty) =\n    RBT_Impl.entries rbt.Empty @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) ((k_, t_) # kts_))", "by(subst list.unfoldr.simps) simp"], ["proof (state)\nthis:\n  list.unfoldr rbt_entries_generator ((k_, t_) # kts_, rbt.Empty) =\n  RBT_Impl.entries rbt.Empty @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) ((k_, t_) # kts_))\n\ngoal (1 subgoal):\n 1. \\<And>kts c l k v r.\n       list.unfoldr rbt_entries_generator (((k, v), r) # kts, l) =\n       RBT_Impl.entries l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          (((k, v), r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator (kts, Branch c l k v r) =\n       RBT_Impl.entries (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>kts c l k v r.\n       list.unfoldr rbt_entries_generator (((k, v), r) # kts, l) =\n       RBT_Impl.entries l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          (((k, v), r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator (kts, Branch c l k v r) =\n       RBT_Impl.entries (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts)", "case shuffle"], ["proof (state)\nthis:\n  list.unfoldr rbt_entries_generator (((k_, v_), r_) # kts_, l_) =\n  RBT_Impl.entries l_ @\n  concat\n   (map (\\<lambda>(k, t). k # RBT_Impl.entries t) (((k_, v_), r_) # kts_))\n\ngoal (1 subgoal):\n 1. \\<And>kts c l k v r.\n       list.unfoldr rbt_entries_generator (((k, v), r) # kts, l) =\n       RBT_Impl.entries l @\n       concat\n        (map (\\<lambda>(k, t). k # RBT_Impl.entries t)\n          (((k, v), r) # kts)) \\<Longrightarrow>\n       list.unfoldr rbt_entries_generator (kts, Branch c l k v r) =\n       RBT_Impl.entries (Branch c l k v r) @\n       concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts)", "thus ?case"], ["proof (prove)\nusing this:\n  list.unfoldr rbt_entries_generator (((k_, v_), r_) # kts_, l_) =\n  RBT_Impl.entries l_ @\n  concat\n   (map (\\<lambda>(k, t). k # RBT_Impl.entries t) (((k_, v_), r_) # kts_))\n\ngoal (1 subgoal):\n 1. list.unfoldr rbt_entries_generator (kts_, Branch c_ l_ k_ v_ r_) =\n    RBT_Impl.entries (Branch c_ l_ k_ v_ r_) @\n    concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts_)", "by(subst list.unfoldr.simps)(subst (asm) list.unfoldr.simps, simp)"], ["proof (state)\nthis:\n  list.unfoldr rbt_entries_generator (kts_, Branch c_ l_ k_ v_ r_) =\n  RBT_Impl.entries (Branch c_ l_ k_ v_ r_) @\n  concat (map (\\<lambda>(k, t). k # RBT_Impl.entries t) kts_)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary unfoldr_rbt_entries_generator:\n  \"list.unfoldr rbt_entries_generator (rbt_init t) = RBT_Impl.entries t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.unfoldr rbt_entries_generator (rbt_init t) = RBT_Impl.entries t", "by(simp add: unfoldr_rbt_entries_generator_aux rbt_init_def)"], ["", "end"]]}